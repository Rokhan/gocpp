// generated by GoCpp from file '$(ImportDir)/runtime/atomic_pointer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/atomic_pointer.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goexperiment/exp_cgocheck2_off.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/cgocheck.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    void atomicwb(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        auto slot = (uintptr_t*)(unsafe::Pointer(ptr));
        auto buf = get2(gocpp::recv(ptr(gocpp::recv(getg()->m->p))->wbBuf));
        buf[0] = *slot;
        buf[1] = uintptr_t(go_new);
    }

    void atomicstorep(unsafe::Pointer ptr, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb((unsafe::Pointer*)(ptr), go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite((unsafe::Pointer*)(ptr), go_new);
        }
        atomic::StorepNoWB(noescape(ptr), go_new);
    }

    void atomic_storePointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        atomicstorep(unsafe::Pointer(ptr), go_new);
    }

    bool atomic_casPointer(unsafe::Pointer* ptr, unsafe::Pointer old, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        return atomic::Casp1(ptr, old, go_new);
    }

    void sync_atomic_StoreUintptr(uintptr_t* ptr, uintptr_t go_new)
    /* convertBlockStmt, nil block */;

    void sync_atomic_StorePointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        sync_atomic_StoreUintptr((uintptr_t*)(unsafe::Pointer(ptr)), uintptr_t(go_new));
    }

    uintptr_t sync_atomic_SwapUintptr(uintptr_t* ptr, uintptr_t go_new)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer sync_atomic_SwapPointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        auto old = unsafe::Pointer(sync_atomic_SwapUintptr((uintptr_t*)(noescape(unsafe::Pointer(ptr))), uintptr_t(go_new)));
        return old;
    }

    bool sync_atomic_CompareAndSwapUintptr(uintptr_t* ptr, uintptr_t old, uintptr_t go_new)
    /* convertBlockStmt, nil block */;

    bool sync_atomic_CompareAndSwapPointer(unsafe::Pointer* ptr, unsafe::Pointer old, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        return sync_atomic_CompareAndSwapUintptr((uintptr_t*)(noescape(unsafe::Pointer(ptr))), uintptr_t(old), uintptr_t(go_new));
    }

}

