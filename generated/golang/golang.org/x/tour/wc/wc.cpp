// generated by GoCpp from file '$(ImportDir)/golang.org/x/tour/wc/wc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/golang.org/x/tour/wc/wc.h"
#include "gocpp/support.h"

#include "golang/fmt/print.h"

namespace golang::wc
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace fmt::rec;
    }

    void Test(std::function<gocpp::map<std::string, int> (std::string)> f)
    {
        auto ok = true;
        for(auto [gocpp_ignored, c] : testCases)
        {
            auto got = f(c.in);
            if(len(c.want) != len(got))
            {
                ok = false;
            }
            else
            {
                for(auto [k, gocpp_ignored] : c.want)
                {
                    if(c.want[k] != got[k])
                    {
                        ok = false;
                    }
                }
            }
            if(! ok)
            {
                mocklib::Printf("FAIL\n f(%q) =\n  %#v\n want:\n  %#v", c.in, got, c.want);
                break;
            }
            mocklib::Printf("PASS\n f(%q) = \n  %#v\n", c.in, got);
        }
    }

    struct gocpp_id_0
    {
        std::string in;
        gocpp::map<std::string, int> want;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.in = this->in;
            result.want = this->want;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (in != ref.in) return false;
            if (want != ref.want) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << in;
            os << " " << want;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp::slice<gocpp_id_0> testCases = gocpp::slice<gocpp_id_0> { {"I am learning Go!", gocpp::map<std::string, int> {{ "I", 1 }, { "am", 1 }, { "learning", 1 }, { "Go!", 1 }}},  {"The quick brown fox jumped over the lazy dog.", gocpp::map<std::string, int> {{ "The", 1 }, { "quick", 1 }, { "brown", 1 }, { "fox", 1 }, { "jumped", 1 }, { "over", 1 }, { "the", 1 }, { "lazy", 1 }, { "dog.", 1 }}},  {"I ate a donut. Then I ate another donut.", gocpp::map<std::string, int> {{ "I", 2 }, { "ate", 2 }, { "a", 1 }, { "donut.", 2 }, { "Then", 1 }, { "another", 1 }}},  {"A man a plan a canal panama.", gocpp::map<std::string, int> {{ "A", 1 }, { "man", 1 }, { "a", 2 }, { "plan", 1 }, { "canal", 1 }, { "panama.", 1 }}}};
}

