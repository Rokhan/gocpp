// generated by GoCpp from file '$(ImportDir)/runtime/debug.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/debug.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
    }

    int GOMAXPROCS(int n)
    {
        if(GOARCH == "wasm"s && n > 1)
        {
            n = 1;
        }
        lock(& sched.lock);
        auto ret = int(gomaxprocs);
        unlock(& sched.lock);
        if(n <= 0 || n == ret)
        {
            return ret;
        }
        auto stw = stopTheWorldGC(stwGOMAXPROCS);
        newprocs = int32_t(n);
        startTheWorldGC(stw);
        return ret;
    }

    int NumCPU()
    {
        return int(ncpu);
    }

    int64_t NumCgoCall()
    {
        auto n = int64_t(atomic::Load64(& ncgocall));
        for(auto mp = (m*)(atomic::Loadp(unsafe::Pointer(& allm))); mp != nullptr; mp = mp->alllink)
        {
            n += int64_t(mp->ncgocall);
        }
        return n;
    }

    int64_t totalMutexWaitTimeNanos()
    {
        auto total = rec::Load(gocpp::recv(sched.totalMutexWaitTime));
        total += rec::Load(gocpp::recv(sched.totalRuntimeLockWaitTime));
        for(auto mp = (m*)(atomic::Loadp(unsafe::Pointer(& allm))); mp != nullptr; mp = mp->alllink)
        {
            total += rec::Load(gocpp::recv(mp->mLockProfile.waitTime));
        }
        return total;
    }

    int NumGoroutine()
    {
        return int(gcount());
    }

    std::string debug_modinfo()
    {
        return modinfo;
    }

    void mayMoreStackPreempt()
    {
        auto gp = getg();
        if(gp == gp->m->g0 || gp == gp->m->gsignal)
        {
            return;
        }
        if(gp->stackguard0 < stackPoisonMin)
        {
            gp->stackguard0 = stackPreempt;
        }
    }

    void mayMoreStackMove()
    {
        auto gp = getg();
        if(gp == gp->m->g0 || gp == gp->m->gsignal)
        {
            return;
        }
        if(gp->stackguard0 < stackPoisonMin)
        {
            gp->stackguard0 = stackForceMove;
        }
    }

}

