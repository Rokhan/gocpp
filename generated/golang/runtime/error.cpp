// generated by GoCpp from file '$(ImportDir)/runtime/error.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/error.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // The Error interface identifies a run time error.
    
    template<typename T>
    Error::Error(T& ref)
    {
        value.reset(new ErrorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Error::Error(const T& ref)
    {
        value.reset(new ErrorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Error::Error(T* ptr)
    {
        value.reset(new ErrorImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Error::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Error::ErrorImpl<T, StoreT>::vRuntimeError()
    {
        return rec::RuntimeError(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        void RuntimeError(const gocpp::PtrRecv<struct Error, false>& self)
        {
            return self.ptr->value->vRuntimeError();
        }

        void RuntimeError(const gocpp::ObjRecv<struct Error>& self)
        {
            return self.obj.value->vRuntimeError();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Error& value)
    {
        return value.PrintTo(os);
    }

    // A TypeAssertionError explains a failed type assertion.
    
    template<typename T> requires gocpp::GoStruct<T>
    TypeAssertionError::operator T()
    {
        T result;
        result._interface = this->_interface;
        result.concrete = this->concrete;
        result.asserted = this->asserted;
        result.missingMethod = this->missingMethod;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool TypeAssertionError::operator==(const T& ref) const
    {
        if (_interface != ref._interface) return false;
        if (concrete != ref.concrete) return false;
        if (asserted != ref.asserted) return false;
        if (missingMethod != ref.missingMethod) return false;
        return true;
    }

    std::ostream& TypeAssertionError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _interface;
        os << " " << concrete;
        os << " " << asserted;
        os << " " << missingMethod;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct TypeAssertionError& value)
    {
        return value.PrintTo(os);
    }

    void rec::RuntimeError(TypeAssertionError*)
    {
    }

    gocpp::string rec::Error(struct TypeAssertionError* e)
    {
        auto inter = "interface"_s;
        if(e->_interface != nullptr)
        {
            inter = rec::string(gocpp::recv(toRType(e->_interface)));
        }
        auto as = rec::string(gocpp::recv(toRType(e->asserted)));
        if(e->concrete == nullptr)
        {
            return "interface conversion: "_s + inter + " is nil, not "_s + as;
        }
        auto cs = rec::string(gocpp::recv(toRType(e->concrete)));
        if(e->missingMethod == ""_s)
        {
            auto msg = "interface conversion: "_s + inter + " is "_s + cs + ", not "_s + as;
            if(cs == as)
            {
                if(rec::pkgpath(gocpp::recv(toRType(e->concrete))) != rec::pkgpath(gocpp::recv(toRType(e->asserted))))
                {
                    msg += " (types from different packages)"_s;
                }
                else
                {
                    msg += " (types from different scopes)"_s;
                }
            }
            return msg;
        }
        return "interface conversion: "_s + cs + " is not "_s + as + ": missing method "_s + e->missingMethod;
    }

    // itoa converts val to a decimal representation. The result is
    // written somewhere within buf and the location of the result is returned.
    // buf must be at least 20 bytes.
    //
    //go:nosplit
    gocpp::slice<unsigned char> itoa(gocpp::slice<unsigned char> buf, uint64_t val)
    {
        auto i = len(buf) - 1;
        for(; val >= 10; )
        {
            buf[i] = (unsigned char)(val % 10 + '0');
            i--;
            val /= 10;
        }
        buf[i] = (unsigned char)(val + '0');
        return buf.make_slice(i);
    }

    // An errorString represents a runtime error described by a single string.
    void rec::RuntimeError(golang::runtime::errorString e)
    {
    }

    gocpp::string rec::Error(golang::runtime::errorString e)
    {
        return "runtime error: "_s + gocpp::string(e);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    errorAddressString::operator T()
    {
        T result;
        result.msg = this->msg;
        result.addr = this->addr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool errorAddressString::operator==(const T& ref) const
    {
        if (msg != ref.msg) return false;
        if (addr != ref.addr) return false;
        return true;
    }

    std::ostream& errorAddressString::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << msg;
        os << " " << addr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct errorAddressString& value)
    {
        return value.PrintTo(os);
    }

    void rec::RuntimeError(struct errorAddressString e)
    {
    }

    gocpp::string rec::Error(struct errorAddressString e)
    {
        return "runtime error: "_s + e.msg;
    }

    // Addr returns the memory address where a fault occurred.
    // The address provided is best-effort.
    // The veracity of the result may depend on the platform.
    // Errors providing this method will only be returned as
    // a result of using [runtime/debug.SetPanicOnFault].
    uintptr_t rec::Addr(struct errorAddressString e)
    {
        return e.addr;
    }

    // plainError represents a runtime error described a string without
    // the prefix "runtime error: " after invoking errorString.Error().
    // See Issue #14965.
    void rec::RuntimeError(golang::runtime::plainError e)
    {
    }

    gocpp::string rec::Error(golang::runtime::plainError e)
    {
        return gocpp::string(e);
    }

    // A boundsError represents an indexing or slicing operation gone wrong.
    
    template<typename T> requires gocpp::GoStruct<T>
    boundsError::operator T()
    {
        T result;
        result.x = this->x;
        result.y = this->y;
        result.go_signed = this->go_signed;
        result.code = this->code;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool boundsError::operator==(const T& ref) const
    {
        if (x != ref.x) return false;
        if (y != ref.y) return false;
        if (go_signed != ref.go_signed) return false;
        if (code != ref.code) return false;
        return true;
    }

    std::ostream& boundsError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << x;
        os << " " << y;
        os << " " << go_signed;
        os << " " << code;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct boundsError& value)
    {
        return value.PrintTo(os);
    }

    // boundsErrorFmts provide error text for various out-of-bounds panics.
    // Note: if you change these strings, you should adjust the size of the buffer
    // in boundsError.Error below as well.
    gocpp::array<gocpp::string, 9> boundsErrorFmts = gocpp::Init<gocpp::array<gocpp::string, 9>>([](auto& x) {
        x[boundsIndex] = "index out of range [%x] with length %y"_s;
        x[boundsSliceAlen] = "slice bounds out of range [:%x] with length %y"_s;
        x[boundsSliceAcap] = "slice bounds out of range [:%x] with capacity %y"_s;
        x[boundsSliceB] = "slice bounds out of range [%x:%y]"_s;
        x[boundsSlice3Alen] = "slice bounds out of range [::%x] with length %y"_s;
        x[boundsSlice3Acap] = "slice bounds out of range [::%x] with capacity %y"_s;
        x[boundsSlice3B] = "slice bounds out of range [:%x:%y]"_s;
        x[boundsSlice3C] = "slice bounds out of range [%x:%y:]"_s;
        x[boundsConvert] = "cannot convert slice with length %y to array or pointer to array with length %x"_s;
    });
    // boundsNegErrorFmts are overriding formats if x is negative. In this case there's no need to report y.
    gocpp::array<gocpp::string, 8> boundsNegErrorFmts = gocpp::Init<gocpp::array<gocpp::string, 8>>([](auto& x) {
        x[boundsIndex] = "index out of range [%x]"_s;
        x[boundsSliceAlen] = "slice bounds out of range [:%x]"_s;
        x[boundsSliceAcap] = "slice bounds out of range [:%x]"_s;
        x[boundsSliceB] = "slice bounds out of range [%x:]"_s;
        x[boundsSlice3Alen] = "slice bounds out of range [::%x]"_s;
        x[boundsSlice3Acap] = "slice bounds out of range [::%x]"_s;
        x[boundsSlice3B] = "slice bounds out of range [:%x:]"_s;
        x[boundsSlice3C] = "slice bounds out of range [%x::]"_s;
    });
    void rec::RuntimeError(struct boundsError e)
    {
    }

    gocpp::slice<unsigned char> appendIntStr(gocpp::slice<unsigned char> b, int64_t v, bool go_signed)
    {
        if(go_signed && v < 0)
        {
            b = append(b, '-');
            v = - v;
        }
        gocpp::array<unsigned char, 20> buf = {};
        b = append(b, itoa(buf.make_slice(0), uint64_t(v)));
        return b;
    }

    gocpp::string rec::Error(struct boundsError e)
    {
        auto fmt = boundsErrorFmts[e.code];
        if(e.go_signed && e.x < 0)
        {
            fmt = boundsNegErrorFmts[e.code];
        }
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 100);
        b = append(b, "runtime error: "_s);
        for(auto i = 0; i < len(fmt); i++)
        {
            auto c = fmt[i];
            if(c != '%')
            {
                b = append(b, c);
                continue;
            }
            i++;
            //Go switch emulation
            {
                auto condition = fmt[i];
                int conditionId = -1;
                if(condition == 'x') { conditionId = 0; }
                else if(condition == 'y') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        b = appendIntStr(b, e.x, e.go_signed);
                        break;
                    case 1:
                        b = appendIntStr(b, int64_t(e.y), true);
                        break;
                }
            }
        }
        return gocpp::string(b);
    }

    
    template<typename T>
    stringer::stringer(T& ref)
    {
        value.reset(new stringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    stringer::stringer(const T& ref)
    {
        value.reset(new stringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    stringer::stringer(T* ptr)
    {
        value.reset(new stringerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& stringer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::string stringer::stringerImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        gocpp::string String(const gocpp::PtrRecv<struct stringer, false>& self)
        {
            return self.ptr->value->vString();
        }

        gocpp::string String(const gocpp::ObjRecv<struct stringer>& self)
        {
            return self.obj.value->vString();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct stringer& value)
    {
        return value.PrintTo(os);
    }

    // printany prints an argument passed to panic.
    // If panic is called with a value that has a String or Error method,
    // it has already been converted into a string by preprintpanics.
    void printany(go_any i)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_0 = gocpp::type_info(i);
            int conditionId = -1;
            if(gocpp_id_0 == typeid(untyped nil)) { conditionId = 0; }
            else if(gocpp_id_0 == typeid(bool)) { conditionId = 1; }
            else if(gocpp_id_0 == typeid(int)) { conditionId = 2; }
            else if(gocpp_id_0 == typeid(int8_t)) { conditionId = 3; }
            else if(gocpp_id_0 == typeid(int16_t)) { conditionId = 4; }
            else if(gocpp_id_0 == typeid(int32_t)) { conditionId = 5; }
            else if(gocpp_id_0 == typeid(int64_t)) { conditionId = 6; }
            else if(gocpp_id_0 == typeid(unsigned int)) { conditionId = 7; }
            else if(gocpp_id_0 == typeid(uint8_t)) { conditionId = 8; }
            else if(gocpp_id_0 == typeid(uint16_t)) { conditionId = 9; }
            else if(gocpp_id_0 == typeid(uint32_t)) { conditionId = 10; }
            else if(gocpp_id_0 == typeid(uint64_t)) { conditionId = 11; }
            else if(gocpp_id_0 == typeid(uintptr_t)) { conditionId = 12; }
            else if(gocpp_id_0 == typeid(float)) { conditionId = 13; }
            else if(gocpp_id_0 == typeid(double)) { conditionId = 14; }
            else if(gocpp_id_0 == typeid(gocpp::complex64)) { conditionId = 15; }
            else if(gocpp_id_0 == typeid(gocpp::complex128)) { conditionId = 16; }
            else if(gocpp_id_0 == typeid(gocpp::string)) { conditionId = 17; }
            switch(conditionId)
            {
                case 0:
                {
                    untyped nil v = gocpp::any_cast<untyped nil>(i);
                    print("nil"_s);
                    break;
                }
                case 1:
                {
                    bool v = gocpp::any_cast<bool>(i);
                    print(v);
                    break;
                }
                case 2:
                {
                    int v = gocpp::any_cast<int>(i);
                    print(v);
                    break;
                }
                case 3:
                {
                    int8_t v = gocpp::any_cast<int8_t>(i);
                    print(v);
                    break;
                }
                case 4:
                {
                    int16_t v = gocpp::any_cast<int16_t>(i);
                    print(v);
                    break;
                }
                case 5:
                {
                    int32_t v = gocpp::any_cast<int32_t>(i);
                    print(v);
                    break;
                }
                case 6:
                {
                    int64_t v = gocpp::any_cast<int64_t>(i);
                    print(v);
                    break;
                }
                case 7:
                {
                    unsigned int v = gocpp::any_cast<unsigned int>(i);
                    print(v);
                    break;
                }
                case 8:
                {
                    uint8_t v = gocpp::any_cast<uint8_t>(i);
                    print(v);
                    break;
                }
                case 9:
                {
                    uint16_t v = gocpp::any_cast<uint16_t>(i);
                    print(v);
                    break;
                }
                case 10:
                {
                    uint32_t v = gocpp::any_cast<uint32_t>(i);
                    print(v);
                    break;
                }
                case 11:
                {
                    uint64_t v = gocpp::any_cast<uint64_t>(i);
                    print(v);
                    break;
                }
                case 12:
                {
                    uintptr_t v = gocpp::any_cast<uintptr_t>(i);
                    print(v);
                    break;
                }
                case 13:
                {
                    float v = gocpp::any_cast<float>(i);
                    print(v);
                    break;
                }
                case 14:
                {
                    double v = gocpp::any_cast<double>(i);
                    print(v);
                    break;
                }
                case 15:
                {
                    gocpp::complex64 v = gocpp::any_cast<gocpp::complex64>(i);
                    print(v);
                    break;
                }
                case 16:
                {
                    gocpp::complex128 v = gocpp::any_cast<gocpp::complex128>(i);
                    print(v);
                    break;
                }
                case 17:
                {
                    gocpp::string v = gocpp::any_cast<gocpp::string>(i);
                    print(v);
                    break;
                }
                default:
                {
                    auto v = i;
                    printanycustomtype(i);
                    break;
                }
            }
        }
    }

    void printanycustomtype(go_any i)
    {
        auto eface = efaceOf(& i);
        auto typestring = rec::string(gocpp::recv(toRType(eface->_type)));
        //Go switch emulation
        {
            auto condition = eface->_type->Kind_;
            int conditionId = -1;
            if(condition == kindString) { conditionId = 0; }
            else if(condition == kindBool) { conditionId = 1; }
            else if(condition == kindInt) { conditionId = 2; }
            else if(condition == kindInt8) { conditionId = 3; }
            else if(condition == kindInt16) { conditionId = 4; }
            else if(condition == kindInt32) { conditionId = 5; }
            else if(condition == kindInt64) { conditionId = 6; }
            else if(condition == kindUint) { conditionId = 7; }
            else if(condition == kindUint8) { conditionId = 8; }
            else if(condition == kindUint16) { conditionId = 9; }
            else if(condition == kindUint32) { conditionId = 10; }
            else if(condition == kindUint64) { conditionId = 11; }
            else if(condition == kindUintptr) { conditionId = 12; }
            else if(condition == kindFloat32) { conditionId = 13; }
            else if(condition == kindFloat64) { conditionId = 14; }
            else if(condition == kindComplex64) { conditionId = 15; }
            else if(condition == kindComplex128) { conditionId = 16; }
            switch(conditionId)
            {
                case 0:
                    print(typestring, "(""_s, *(gocpp::string*)(eface->data), "")"_s);
                    break;
                case 1:
                    print(typestring, "("_s, *(bool*)(eface->data), ")"_s);
                    break;
                case 2:
                    print(typestring, "("_s, *(int*)(eface->data), ")"_s);
                    break;
                case 3:
                    print(typestring, "("_s, *(int8_t*)(eface->data), ")"_s);
                    break;
                case 4:
                    print(typestring, "("_s, *(int16_t*)(eface->data), ")"_s);
                    break;
                case 5:
                    print(typestring, "("_s, *(int32_t*)(eface->data), ")"_s);
                    break;
                case 6:
                    print(typestring, "("_s, *(int64_t*)(eface->data), ")"_s);
                    break;
                case 7:
                    print(typestring, "("_s, *(unsigned int*)(eface->data), ")"_s);
                    break;
                case 8:
                    print(typestring, "("_s, *(uint8_t*)(eface->data), ")"_s);
                    break;
                case 9:
                    print(typestring, "("_s, *(uint16_t*)(eface->data), ")"_s);
                    break;
                case 10:
                    print(typestring, "("_s, *(uint32_t*)(eface->data), ")"_s);
                    break;
                case 11:
                    print(typestring, "("_s, *(uint64_t*)(eface->data), ")"_s);
                    break;
                case 12:
                    print(typestring, "("_s, *(uintptr_t*)(eface->data), ")"_s);
                    break;
                case 13:
                    print(typestring, "("_s, *(float*)(eface->data), ")"_s);
                    break;
                case 14:
                    print(typestring, "("_s, *(double*)(eface->data), ")"_s);
                    break;
                case 15:
                    print(typestring, *(gocpp::complex64*)(eface->data));
                    break;
                case 16:
                    print(typestring, *(gocpp::complex128*)(eface->data));
                    break;
                default:
                    print("("_s, typestring, ") "_s, eface->data);
                    break;
            }
        }
    }

    // panicwrap generates a panic for a call to a wrapped value method
    // with a nil pointer receiver.
    //
    // It is called from the generated wrapper code.
    void panicwrap()
    {
        auto pc = getcallerpc();
        auto name = funcNameForPrint(funcname(findfunc(pc)));
        auto i = bytealg::IndexByteString(name, '(');
        if(i < 0)
        {
            go_throw("panicwrap: no ( in "_s + name);
        }
        auto pkg = name.make_slice(0, i - 1);
        if(i + 2 >= len(name) || name.make_slice(i - 1, i + 2) != ".(*"_s)
        {
            go_throw("panicwrap: unexpected string after package name: "_s + name);
        }
        name = name.make_slice(i + 2);
        i = bytealg::IndexByteString(name, ')');
        if(i < 0)
        {
            go_throw("panicwrap: no ) in "_s + name);
        }
        if(i + 2 >= len(name) || name.make_slice(i, i + 2) != ")."_s)
        {
            go_throw("panicwrap: unexpected string after type name: "_s + name);
        }
        auto typ = name.make_slice(0, i);
        auto meth = name.make_slice(i + 2);
        gocpp::panic(plainError("value method "_s + pkg + "."_s + typ + "."_s + meth + " called using nil *"_s + typ + " pointer"_s));
    }

}

