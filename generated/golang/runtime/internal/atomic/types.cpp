// generated by GoCpp from file '$(ImportDir)/runtime/internal/atomic/types.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/internal/atomic/types.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::atomic
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Int32 is an atomically accessed int32 value.
    //
    // An Int32 must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Int32::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Int32::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& Int32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Int32& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    int32_t rec::Load(golang::atomic::Int32* i)
    {
        return Loadint32(& i->value);
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Int32* i, int32_t value)
    {
        Storeint32(& i->value, value);
    }

    // CompareAndSwap atomically compares i's value with old,
    // and if they're equal, swaps i's value with new.
    // It reports whether the swap ran.
    //
    //go:nosplit
    bool rec::CompareAndSwap(golang::atomic::Int32* i, int32_t old, int32_t go_new)
    {
        return Casint32(& i->value, old, go_new);
    }

    // Swap replaces i's value with new, returning
    // i's value before the replacement.
    //
    //go:nosplit
    int32_t rec::Swap(golang::atomic::Int32* i, int32_t go_new)
    {
        return Xchgint32(& i->value, go_new);
    }

    // Add adds delta to i atomically, returning
    // the new updated value.
    //
    // This operation wraps around in the usual
    // two's-complement way.
    //
    //go:nosplit
    int32_t rec::Add(golang::atomic::Int32* i, int32_t delta)
    {
        return Xaddint32(& i->value, delta);
    }

    // Int64 is an atomically accessed int64 value.
    //
    // 8-byte aligned on all platforms, unlike a regular int64.
    //
    // An Int64 must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Int64::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result._1 = this->_1;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Int64::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (_1 != ref._1) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& Int64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << _1;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Int64& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    int64_t rec::Load(golang::atomic::Int64* i)
    {
        return Loadint64(& i->value);
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Int64* i, int64_t value)
    {
        Storeint64(& i->value, value);
    }

    // CompareAndSwap atomically compares i's value with old,
    // and if they're equal, swaps i's value with new.
    // It reports whether the swap ran.
    //
    //go:nosplit
    bool rec::CompareAndSwap(golang::atomic::Int64* i, int64_t old, int64_t go_new)
    {
        return Casint64(& i->value, old, go_new);
    }

    // Swap replaces i's value with new, returning
    // i's value before the replacement.
    //
    //go:nosplit
    int64_t rec::Swap(golang::atomic::Int64* i, int64_t go_new)
    {
        return Xchgint64(& i->value, go_new);
    }

    // Add adds delta to i atomically, returning
    // the new updated value.
    //
    // This operation wraps around in the usual
    // two's-complement way.
    //
    //go:nosplit
    int64_t rec::Add(golang::atomic::Int64* i, int64_t delta)
    {
        return Xaddint64(& i->value, delta);
    }

    // Uint8 is an atomically accessed uint8 value.
    //
    // A Uint8 must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uint8::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uint8::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& Uint8::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint8& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    uint8_t rec::Load(golang::atomic::Uint8* u)
    {
        return Load8(& u->value);
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Uint8* u, uint8_t value)
    {
        Store8(& u->value, value);
    }

    // And takes value and performs a bit-wise
    // "and" operation with the value of u, storing
    // the result into u.
    //
    // The full process is performed atomically.
    //
    //go:nosplit
    void rec::And(golang::atomic::Uint8* u, uint8_t value)
    {
        And8(& u->value, value);
    }

    // Or takes value and performs a bit-wise
    // "or" operation with the value of u, storing
    // the result into u.
    //
    // The full process is performed atomically.
    //
    //go:nosplit
    void rec::Or(golang::atomic::Uint8* u, uint8_t value)
    {
        Or8(& u->value, value);
    }

    // Bool is an atomically accessed bool value.
    //
    // A Bool must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Bool::operator T()
    {
        T result;
        result.u = this->u;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Bool::operator==(const T& ref) const
    {
        if (u != ref.u) return false;
        return true;
    }

    std::ostream& Bool::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Bool& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    bool rec::Load(golang::atomic::Bool* b)
    {
        return rec::Load(gocpp::recv(b->u)) != 0;
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Bool* b, bool value)
    {
        auto s = uint8_t(0);
        if(value)
        {
            s = 1;
        }
        rec::Store(gocpp::recv(b->u), s);
    }

    // Uint32 is an atomically accessed uint32 value.
    //
    // A Uint32 must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uint32::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uint32::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& Uint32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint32& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    uint32_t rec::Load(golang::atomic::Uint32* u)
    {
        return Load(& u->value);
    }

    // LoadAcquire is a partially unsynchronized version
    // of Load that relaxes ordering constraints. Other threads
    // may observe operations that precede this operation to
    // occur after it, but no operation that occurs after it
    // on this thread can be observed to occur before it.
    //
    // WARNING: Use sparingly and with great care.
    //
    //go:nosplit
    uint32_t rec::LoadAcquire(golang::atomic::Uint32* u)
    {
        return LoadAcq(& u->value);
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Uint32* u, uint32_t value)
    {
        Store(& u->value, value);
    }

    // StoreRelease is a partially unsynchronized version
    // of Store that relaxes ordering constraints. Other threads
    // may observe operations that occur after this operation to
    // precede it, but no operation that precedes it
    // on this thread can be observed to occur after it.
    //
    // WARNING: Use sparingly and with great care.
    //
    //go:nosplit
    void rec::StoreRelease(golang::atomic::Uint32* u, uint32_t value)
    {
        StoreRel(& u->value, value);
    }

    // CompareAndSwap atomically compares u's value with old,
    // and if they're equal, swaps u's value with new.
    // It reports whether the swap ran.
    //
    //go:nosplit
    bool rec::CompareAndSwap(golang::atomic::Uint32* u, uint32_t old, uint32_t go_new)
    {
        return Cas(& u->value, old, go_new);
    }

    // CompareAndSwapRelease is a partially unsynchronized version
    // of Cas that relaxes ordering constraints. Other threads
    // may observe operations that occur after this operation to
    // precede it, but no operation that precedes it
    // on this thread can be observed to occur after it.
    // It reports whether the swap ran.
    //
    // WARNING: Use sparingly and with great care.
    //
    //go:nosplit
    bool rec::CompareAndSwapRelease(golang::atomic::Uint32* u, uint32_t old, uint32_t go_new)
    {
        return CasRel(& u->value, old, go_new);
    }

    // Swap replaces u's value with new, returning
    // u's value before the replacement.
    //
    //go:nosplit
    uint32_t rec::Swap(golang::atomic::Uint32* u, uint32_t value)
    {
        return Xchg(& u->value, value);
    }

    // And takes value and performs a bit-wise
    // "and" operation with the value of u, storing
    // the result into u.
    //
    // The full process is performed atomically.
    //
    //go:nosplit
    void rec::And(golang::atomic::Uint32* u, uint32_t value)
    {
        And(& u->value, value);
    }

    // Or takes value and performs a bit-wise
    // "or" operation with the value of u, storing
    // the result into u.
    //
    // The full process is performed atomically.
    //
    //go:nosplit
    void rec::Or(golang::atomic::Uint32* u, uint32_t value)
    {
        Or(& u->value, value);
    }

    // Add adds delta to u atomically, returning
    // the new updated value.
    //
    // This operation wraps around in the usual
    // two's-complement way.
    //
    //go:nosplit
    uint32_t rec::Add(golang::atomic::Uint32* u, int32_t delta)
    {
        return Xadd(& u->value, delta);
    }

    // Uint64 is an atomically accessed uint64 value.
    //
    // 8-byte aligned on all platforms, unlike a regular uint64.
    //
    // A Uint64 must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uint64::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result._1 = this->_1;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uint64::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (_1 != ref._1) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& Uint64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << _1;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint64& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    uint64_t rec::Load(golang::atomic::Uint64* u)
    {
        return Load64(& u->value);
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Uint64* u, uint64_t value)
    {
        Store64(& u->value, value);
    }

    // CompareAndSwap atomically compares u's value with old,
    // and if they're equal, swaps u's value with new.
    // It reports whether the swap ran.
    //
    //go:nosplit
    bool rec::CompareAndSwap(golang::atomic::Uint64* u, uint64_t old, uint64_t go_new)
    {
        return Cas64(& u->value, old, go_new);
    }

    // Swap replaces u's value with new, returning
    // u's value before the replacement.
    //
    //go:nosplit
    uint64_t rec::Swap(golang::atomic::Uint64* u, uint64_t value)
    {
        return Xchg64(& u->value, value);
    }

    // Add adds delta to u atomically, returning
    // the new updated value.
    //
    // This operation wraps around in the usual
    // two's-complement way.
    //
    //go:nosplit
    uint64_t rec::Add(golang::atomic::Uint64* u, int64_t delta)
    {
        return Xadd64(& u->value, delta);
    }

    // Uintptr is an atomically accessed uintptr value.
    //
    // A Uintptr must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uintptr::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uintptr::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& Uintptr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uintptr& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    uintptr_t rec::Load(golang::atomic::Uintptr* u)
    {
        return Loaduintptr(& u->value);
    }

    // LoadAcquire is a partially unsynchronized version
    // of Load that relaxes ordering constraints. Other threads
    // may observe operations that precede this operation to
    // occur after it, but no operation that occurs after it
    // on this thread can be observed to occur before it.
    //
    // WARNING: Use sparingly and with great care.
    //
    //go:nosplit
    uintptr_t rec::LoadAcquire(golang::atomic::Uintptr* u)
    {
        return LoadAcquintptr(& u->value);
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Uintptr* u, uintptr_t value)
    {
        Storeuintptr(& u->value, value);
    }

    // StoreRelease is a partially unsynchronized version
    // of Store that relaxes ordering constraints. Other threads
    // may observe operations that occur after this operation to
    // precede it, but no operation that precedes it
    // on this thread can be observed to occur after it.
    //
    // WARNING: Use sparingly and with great care.
    //
    //go:nosplit
    void rec::StoreRelease(golang::atomic::Uintptr* u, uintptr_t value)
    {
        StoreReluintptr(& u->value, value);
    }

    // CompareAndSwap atomically compares u's value with old,
    // and if they're equal, swaps u's value with new.
    // It reports whether the swap ran.
    //
    //go:nosplit
    bool rec::CompareAndSwap(golang::atomic::Uintptr* u, uintptr_t old, uintptr_t go_new)
    {
        return Casuintptr(& u->value, old, go_new);
    }

    // Swap replaces u's value with new, returning
    // u's value before the replacement.
    //
    //go:nosplit
    uintptr_t rec::Swap(golang::atomic::Uintptr* u, uintptr_t value)
    {
        return Xchguintptr(& u->value, value);
    }

    // Add adds delta to u atomically, returning
    // the new updated value.
    //
    // This operation wraps around in the usual
    // two's-complement way.
    //
    //go:nosplit
    uintptr_t rec::Add(golang::atomic::Uintptr* u, uintptr_t delta)
    {
        return Xadduintptr(& u->value, delta);
    }

    // Float64 is an atomically accessed float64 value.
    //
    // 8-byte aligned on all platforms, unlike a regular float64.
    //
    // A Float64 must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    Float64::operator T()
    {
        T result;
        result.u = this->u;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Float64::operator==(const T& ref) const
    {
        if (u != ref.u) return false;
        return true;
    }

    std::ostream& Float64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Float64& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    double rec::Load(golang::atomic::Float64* f)
    {
        auto r = rec::Load(gocpp::recv(f->u));
        return *(double*)(gocpp::unsafe_pointer(& r));
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    void rec::Store(golang::atomic::Float64* f, double value)
    {
        rec::Store(gocpp::recv(f->u), *(uint64_t*)(gocpp::unsafe_pointer(& value)));
    }

    // UnsafePointer is an atomically accessed unsafe.Pointer value.
    //
    // Note that because of the atomicity guarantees, stores to values
    // of this type never trigger a write barrier, and the relevant
    // methods are suffixed with "NoWB" to indicate that explicitly.
    // As a result, this type should be used carefully, and sparingly,
    // mostly with values that do not live in the Go heap anyway.
    //
    // An UnsafePointer must not be copied.
    
    template<typename T> requires gocpp::GoStruct<T>
    UnsafePointer::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool UnsafePointer::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& UnsafePointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct UnsafePointer& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    gocpp::unsafe_pointer rec::Load(golang::atomic::UnsafePointer* u)
    {
        return Loadp(gocpp::unsafe_pointer(& u->value));
    }

    // StoreNoWB updates the value atomically.
    //
    // WARNING: As the name implies this operation does *not*
    // perform a write barrier on value, and so this operation may
    // hide pointers from the GC. Use with care and sparingly.
    // It is safe to use with values not found in the Go heap.
    // Prefer Store instead.
    //
    //go:nosplit
    void rec::StoreNoWB(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer value)
    {
        StorepNoWB(gocpp::unsafe_pointer(& u->value), value);
    }

    // Store updates the value atomically.
    void rec::Store(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer value)
    {
        storePointer(& u->value, value);
    }

    // provided by runtime
    //
    //go:linkname storePointer
    void storePointer(gocpp::unsafe_pointer* ptr, gocpp::unsafe_pointer go_new)
    /* convertBlockStmt, nil block */;

    // CompareAndSwapNoWB atomically (with respect to other methods)
    // compares u's value with old, and if they're equal,
    // swaps u's value with new.
    // It reports whether the swap ran.
    //
    // WARNING: As the name implies this operation does *not*
    // perform a write barrier on value, and so this operation may
    // hide pointers from the GC. Use with care and sparingly.
    // It is safe to use with values not found in the Go heap.
    // Prefer CompareAndSwap instead.
    //
    //go:nosplit
    bool rec::CompareAndSwapNoWB(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer old, gocpp::unsafe_pointer go_new)
    {
        return Casp1(& u->value, old, go_new);
    }

    // CompareAndSwap atomically compares u's value with old,
    // and if they're equal, swaps u's value with new.
    // It reports whether the swap ran.
    bool rec::CompareAndSwap(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer old, gocpp::unsafe_pointer go_new)
    {
        return casPointer(& u->value, old, go_new);
    }

    bool casPointer(gocpp::unsafe_pointer* ptr, gocpp::unsafe_pointer old, gocpp::unsafe_pointer go_new)
    /* convertBlockStmt, nil block */;

    // Pointer is an atomic pointer of type *T.
    
    template<typename T>
    template<typename U> requires gocpp::GoStruct<U>
    Pointer<T>::operator U()
    {
        U result;
        result.u = this->u;
        return result;
    }

    template<typename T>
    template<typename U> requires gocpp::GoStruct<U>
    bool Pointer<T>::operator==(const U& ref) const
    {
        if (u != ref.u) return false;
        return true;
    }

    template<typename T>
    std::ostream& Pointer<T>::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const struct Pointer<T>& value)
    {
        return value.PrintTo(os);
    }

    // Load accesses and returns the value atomically.
    //
    //go:nosplit
    template<typename T>
    T* rec::Load(golang::atomic::Pointer<T>* p)
    {
        return (T*)(rec::Load(gocpp::recv(p->u)));
    }

    // StoreNoWB updates the value atomically.
    //
    // WARNING: As the name implies this operation does *not*
    // perform a write barrier on value, and so this operation may
    // hide pointers from the GC. Use with care and sparingly.
    // It is safe to use with values not found in the Go heap.
    // Prefer Store instead.
    //
    //go:nosplit
    template<typename T>
    void rec::StoreNoWB(golang::atomic::Pointer<T>* p, T* value)
    {
        rec::StoreNoWB(gocpp::recv(p->u), gocpp::unsafe_pointer(value));
    }

    // Store updates the value atomically.
    //
    //go:nosplit
    template<typename T>
    void rec::Store(golang::atomic::Pointer<T>* p, T* value)
    {
        rec::Store(gocpp::recv(p->u), gocpp::unsafe_pointer(value));
    }

    // CompareAndSwapNoWB atomically (with respect to other methods)
    // compares u's value with old, and if they're equal,
    // swaps u's value with new.
    // It reports whether the swap ran.
    //
    // WARNING: As the name implies this operation does *not*
    // perform a write barrier on value, and so this operation may
    // hide pointers from the GC. Use with care and sparingly.
    // It is safe to use with values not found in the Go heap.
    // Prefer CompareAndSwap instead.
    //
    //go:nosplit
    template<typename T>
    bool rec::CompareAndSwapNoWB(golang::atomic::Pointer<T>* p, T* old, T* go_new)
    {
        return rec::CompareAndSwapNoWB(gocpp::recv(p->u), gocpp::unsafe_pointer(old), gocpp::unsafe_pointer(go_new));
    }

    // CompareAndSwap atomically (with respect to other methods)
    // compares u's value with old, and if they're equal,
    // swaps u's value with new.
    // It reports whether the swap ran.
    template<typename T>
    bool rec::CompareAndSwap(golang::atomic::Pointer<T>* p, T* old, T* go_new)
    {
        return rec::CompareAndSwap(gocpp::recv(p->u), gocpp::unsafe_pointer(old), gocpp::unsafe_pointer(go_new));
    }

    // noCopy may be embedded into structs which must not be copied
    // after the first use.
    //
    // See https://golang.org/issues/8005#issuecomment-190753527
    // for details.
    
    template<typename T> requires gocpp::GoStruct<T>
    noCopy::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noCopy::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noCopy::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value)
    {
        return value.PrintTo(os);
    }

    // Lock is a no-op used by -copylocks checker from `go vet`.
    void rec::Lock(golang::atomic::noCopy*)
    {
    }

    void rec::Unlock(golang::atomic::noCopy*)
    {
    }

    // align64 may be added to structs that must be 64-bit aligned.
    // This struct is recognized by a special case in the compiler
    // and will not work if copied to any other package.
    
    template<typename T> requires gocpp::GoStruct<T>
    align64::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool align64::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& align64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct align64& value)
    {
        return value.PrintTo(os);
    }

}

