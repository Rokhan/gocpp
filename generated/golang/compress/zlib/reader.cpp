// generated by GoCpp from file '$(ImportDir)/compress/zlib/reader.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/zlib/reader.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/inflate.h"
#include "golang/encoding/binary/binary.h"
#include "golang/errors/errors.h"
#include "golang/hash/adler32/adler32.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"

/*
Package zlib implements reading and writing of zlib format compressed data,
as specified in RFC 1950.

The implementation provides filters that uncompress during reading
and compress during writing.  For example, to write compressed data
to a buffer:

	var b bytes.Buffer
	w := zlib.NewWriter(&b)
	w.Write([]byte("hello, world\n"))
	w.Close()

and to read that data back:

	r, err := zlib.NewReader(&b)
	io.Copy(os.Stdout, r)
	r.Close()
*/
namespace golang::zlib
{
    namespace rec
    {
        using namespace mocklib::rec;
        using binary::rec::Uint16;
        using binary::rec::Uint32;
        using flate::rec::Reset;
        using hash::rec::Sum32;
        using io::rec::Close;
        using io::rec::Read;
        using io::rec::Write;
    }

    // ErrChecksum is returned when reading ZLIB data that has an invalid checksum.
    // ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.
    // ErrHeader is returned when reading ZLIB data that has an invalid header.
    gocpp::error ErrChecksum = errors::New("zlib: invalid checksum"_s);
    gocpp::error ErrDictionary = errors::New("zlib: invalid dictionary"_s);
    gocpp::error ErrHeader = errors::New("zlib: invalid header"_s);
    
    template<typename T> requires gocpp::GoStruct<T>
    reader::operator T()
    {
        T result;
        result.r = this->r;
        result.decompressor = this->decompressor;
        result.digest = this->digest;
        result.err = this->err;
        result.scratch = this->scratch;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool reader::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (decompressor != ref.decompressor) return false;
        if (digest != ref.digest) return false;
        if (err != ref.err) return false;
        if (scratch != ref.scratch) return false;
        return true;
    }

    std::ostream& reader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << decompressor;
        os << " " << digest;
        os << " " << err;
        os << " " << scratch;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct reader& value)
    {
        return value.PrintTo(os);
    }

    // Resetter resets a ReadCloser returned by [NewReader] or [NewReaderDict]
    // to switch to a new underlying Reader. This permits reusing a ReadCloser
    // instead of allocating a new one.
    
    template<typename T>
    Resetter::Resetter(T& ref)
    {
        value.reset(new ResetterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Resetter::Resetter(const T& ref)
    {
        value.reset(new ResetterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Resetter::Resetter(T* ptr)
    {
        value.reset(new ResetterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Resetter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error Resetter::ResetterImpl<T, StoreT>::vReset(io::Reader r, gocpp::slice<unsigned char> dict)
    {
        return rec::Reset(gocpp::PtrRecv<T, false>(value.get()), r, dict);
    }

    namespace rec
    {
        struct gocpp::error Reset(const gocpp::PtrRecv<struct Resetter, false>& self, io::Reader r, gocpp::slice<unsigned char> dict)
        {
            return self.ptr->value->vReset(r, dict);
        }

        struct gocpp::error Reset(const gocpp::ObjRecv<struct Resetter>& self, io::Reader r, gocpp::slice<unsigned char> dict)
        {
            return self.obj.value->vReset(r, dict);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Resetter& value)
    {
        return value.PrintTo(os);
    }

    // NewReader creates a new ReadCloser.
    // Reads from the returned ReadCloser read and decompress data from r.
    // If r does not implement [io.ByteReader], the decompressor may read more
    // data than necessary from r.
    // It is the caller's responsibility to call Close on the ReadCloser when done.
    //
    // The [io.ReadCloser] returned by NewReader also implements [Resetter].
    std::tuple<io::ReadCloser, struct gocpp::error> NewReader(io::Reader r)
    {
        return NewReaderDict(r, nullptr);
    }

    // NewReaderDict is like [NewReader] but uses a preset dictionary.
    // NewReaderDict ignores the dictionary if the compressed data does not refer to it.
    // If the compressed data refers to a different dictionary, NewReaderDict returns [ErrDictionary].
    //
    // The ReadCloser returned by NewReaderDict also implements [Resetter].
    std::tuple<io::ReadCloser, struct gocpp::error> NewReaderDict(io::Reader r, gocpp::slice<unsigned char> dict)
    {
        auto z = new(reader);
        auto err = rec::Reset(gocpp::recv(z), r, dict);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {z, nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct reader* z, gocpp::slice<unsigned char> p)
    {
        if(z->err != nullptr)
        {
            return {0, z->err};
        }
        int n = {};
        std::tie(n, z->err) = rec::Read(gocpp::recv(z->decompressor), p);
        rec::Write(gocpp::recv(z->digest), p.make_slice(0, n));
        if(z->err != io::go_EOF)
        {
            return {n, z->err};
        }
        if(auto [gocpp_id_0, err] = io::ReadFull(z->r, z->scratch.make_slice(0, 4)); err != nullptr)
        {
            if(err == io::go_EOF)
            {
                err = io::ErrUnexpectedEOF;
            }
            z->err = err;
            return {n, z->err};
        }
        auto checksum = rec::Uint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 4));
        if(checksum != rec::Sum32(gocpp::recv(z->digest)))
        {
            z->err = ErrChecksum;
            return {n, z->err};
        }
        return {n, io::go_EOF};
    }

    // Calling Close does not close the wrapped [io.Reader] originally passed to [NewReader].
    // In order for the ZLIB checksum to be verified, the reader must be
    // fully consumed until the [io.EOF].
    struct gocpp::error rec::Close(struct reader* z)
    {
        if(z->err != nullptr && z->err != io::go_EOF)
        {
            return z->err;
        }
        z->err = rec::Close(gocpp::recv(z->decompressor));
        return z->err;
    }

    struct gocpp::error rec::Reset(struct reader* z, io::Reader r, gocpp::slice<unsigned char> dict)
    {
        *z = gocpp::Init<reader>([=](auto& x) {
            x.decompressor = z->decompressor;
        });
        if(auto [fr, ok] = gocpp::getValue<flate::Reader>(r); ok)
        {
            z->r = fr;
        }
        else
        {
            z->r = bufio::NewReader(r);
        }
        std::tie(std::ignore, z->err) = io::ReadFull(z->r, z->scratch.make_slice(0, 2));
        if(z->err != nullptr)
        {
            if(z->err == io::go_EOF)
            {
                z->err = io::ErrUnexpectedEOF;
            }
            return z->err;
        }
        auto h = rec::Uint16(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 2));
        if((z->scratch[0] & 0x0f != zlibDeflate) || ((z->scratch[0] >> 4) > zlibMaxWindow) || (h % 31 != 0))
        {
            z->err = ErrHeader;
            return z->err;
        }
        auto haveDict = z->scratch[1] & 0x20 != 0;
        if(haveDict)
        {
            std::tie(std::ignore, z->err) = io::ReadFull(z->r, z->scratch.make_slice(0, 4));
            if(z->err != nullptr)
            {
                if(z->err == io::go_EOF)
                {
                    z->err = io::ErrUnexpectedEOF;
                }
                return z->err;
            }
            auto checksum = rec::Uint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 4));
            if(checksum != adler32::Checksum(dict))
            {
                z->err = ErrDictionary;
                return z->err;
            }
        }
        if(z->decompressor == nullptr)
        {
            if(haveDict)
            {
                z->decompressor = flate::NewReaderDict(z->r, dict);
            }
            else
            {
                z->decompressor = flate::NewReader(z->r);
            }
        }
        else
        {
            rec::Reset(gocpp::recv(gocpp::getValue<flate::Resetter>(z->decompressor)), z->r, dict);
        }
        z->digest = adler32::New();
        return nullptr;
    }

}

