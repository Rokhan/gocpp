// generated by GoCpp from file '$(ImportDir)/sync/mutex.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/mutex.fwd.h"
#include "gocpp/support.h"


namespace golang::sync
{
    void go_throw(std::string);
    void fatal(std::string);
    struct Mutex
    {
        int32_t state;
        uint32_t sema;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Mutex& value);
    struct Locker : gocpp::Interface
    {
        Locker(){}
        Locker(Locker& i) = default;
        Locker(const Locker& i) = default;
        Locker& operator=(Locker& i) = default;
        Locker& operator=(const Locker& i) = default;

        template<typename T>
        Locker(T& ref);

        template<typename T>
        Locker(const T& ref);

        template<typename T>
        Locker(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct ILocker
        {
            virtual void vLock() = 0;
            virtual void vUnlock() = 0;
        };

        template<typename T, typename StoreT>
        struct LockerImpl : ILocker
        {
            explicit LockerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            void vLock() override;

            void vUnlock() override;

            StoreT value;
        };

        std::shared_ptr<ILocker> value;
    };

    void Lock(const gocpp::PtrRecv<Locker, false>& self);
    void Lock(const gocpp::ObjRecv<Locker>& self);

    void Unlock(const gocpp::PtrRecv<Locker, false>& self);
    void Unlock(const gocpp::ObjRecv<Locker>& self);

    std::ostream& operator<<(std::ostream& os, const struct Locker& value);
    void Lock(struct Mutex* m);
    bool TryLock(struct Mutex* m);
    void lockSlow(struct Mutex* m);
    void Unlock(struct Mutex* m);
    void unlockSlow(struct Mutex* m, int32_t go_new);
}

