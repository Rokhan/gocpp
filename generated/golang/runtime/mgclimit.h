// generated by GoCpp from file '$(ImportDir)/runtime/mgclimit.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgclimit.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]

namespace golang::runtime
{
    struct gcCPULimiterState
    {
        atomic::Uint32 lock;
        atomic::Bool enabled;
        gocpp_id_0 bucket;
        uint64_t overflow;
        bool gcEnabled;
        bool transitioning;
        atomic::Int64 assistTimePool;
        atomic::Int64 idleMarkTimePool;
        atomic::Int64 idleTimePool;
        atomic::Int64 lastUpdate;
        atomic::Uint32 lastEnabledCycle;
        int32_t nprocs;
        bool test;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const gcCPULimiterState& value);
    bool limiting(gcCPULimiterState* l);
    void startGCTransition(gcCPULimiterState* l, bool enableGC, int64_t now);
    void finishGCTransition(gcCPULimiterState* l, int64_t now);
    extern double gcCPULimiterUpdatePeriod;
    bool needUpdate(gcCPULimiterState* l, int64_t now);
    void addAssistTime(gcCPULimiterState* l, int64_t t);
    void addIdleTime(gcCPULimiterState* l, int64_t t);
    void update(gcCPULimiterState* l, int64_t now);
    void updateLocked(gcCPULimiterState* l, int64_t now);
    void accumulate(gcCPULimiterState* l, int64_t mutatorTime, int64_t gcTime);
    bool tryLock(gcCPULimiterState* l);
    void unlock(gcCPULimiterState* l);
    extern double capacityPerProc;
    void resetCapacity(gcCPULimiterState* l, int64_t now, int32_t nprocs);
    extern runtime.limiterEventType limiterEventIdleMarkWork;
    extern runtime.limiterEventType limiterEventMarkAssist;
    extern runtime.limiterEventType limiterEventScavengeAssist;
    extern runtime.limiterEventType limiterEventIdle;
    extern int limiterEventBits;
    extern uint64_t limiterEventTypeMask;
    extern runtime.limiterEventStamp limiterEventStampNone;
    limiterEventStamp makeLimiterEventStamp(limiterEventType typ, int64_t now);
    int64_t duration(limiterEventStamp s, int64_t now);
    limiterEventType typ(limiterEventStamp s);
    struct limiterEvent
    {
        atomic::Uint64 stamp;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const limiterEvent& value);
    bool start(limiterEvent* e, limiterEventType typ, int64_t now);
    std::tuple<limiterEventType, int64_t> consume(limiterEvent* e, int64_t now);
    void stop(limiterEvent* e, limiterEventType typ, int64_t now);
}

