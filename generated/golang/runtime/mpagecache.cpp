// generated by GoCpp from file '$(ImportDir)/runtime/mpagecache.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mpagecache.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stubs.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // pageCache represents a per-p cache of pages the allocator can
    // allocate from without a lock. More specifically, it represents
    // a pageCachePages*pageSize chunk of memory with 0 or more free
    // pages in it.
    
    template<typename T> requires gocpp::GoStruct<T>
    pageCache::operator T()
    {
        T result;
        result.base = this->base;
        result.cache = this->cache;
        result.scav = this->scav;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pageCache::operator==(const T& ref) const
    {
        if (base != ref.base) return false;
        if (cache != ref.cache) return false;
        if (scav != ref.scav) return false;
        return true;
    }

    std::ostream& pageCache::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << base;
        os << " " << cache;
        os << " " << scav;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pageCache& value)
    {
        return value.PrintTo(os);
    }

    // empty reports whether the page cache has no free pages.
    bool rec::empty(struct pageCache* c)
    {
        return c->cache == 0;
    }

    // alloc allocates npages from the page cache and is the main entry
    // point for allocation.
    //
    // Returns a base address and the amount of scavenged memory in the
    // allocated region in bytes.
    //
    // Returns a base address of zero on failure, in which case the
    // amount of scavenged memory should be ignored.
    std::tuple<uintptr_t, uintptr_t> rec::alloc(struct pageCache* c, uintptr_t npages)
    {
        if(c->cache == 0)
        {
            return {0, 0};
        }
        if(npages == 1)
        {
            auto i = uintptr_t(sys::TrailingZeros64(c->cache));
            auto scav = (c->scav >> i) & 1;
            c->cache &^= 1 << i;
            c->scav &^= 1 << i;
            return {c->base + i * pageSize, uintptr_t(scav) * pageSize};
        }
        return rec::allocN(gocpp::recv(c), npages);
    }

    // allocN is a helper which attempts to allocate npages worth of pages
    // from the cache. It represents the general case for allocating from
    // the page cache.
    //
    // Returns a base address and the amount of scavenged memory in the
    // allocated region in bytes.
    std::tuple<uintptr_t, uintptr_t> rec::allocN(struct pageCache* c, uintptr_t npages)
    {
        auto i = findBitRange64(c->cache, (unsigned int)(npages));
        if(i >= 64)
        {
            return {0, 0};
        }
        auto mask = ((uint64_t(1) << npages) - 1) << i;
        auto scav = sys::OnesCount64(c->scav & mask);
        c->cache &^= mask;
        c->scav &^= mask;
        return {c->base + uintptr_t(i * pageSize), uintptr_t(scav) * pageSize};
    }

    // flush empties out unallocated free pages in the given cache
    // into s. Then, it clears the cache, such that empty returns
    // true.
    //
    // p.mheapLock must be held.
    //
    // Must run on the system stack because p.mheapLock must be held.
    //
    //go:systemstack
    void rec::flush(struct pageCache* c, struct pageAlloc* p)
    {
        assertLockHeld(p->mheapLock);
        if(rec::empty(gocpp::recv(c)))
        {
            return;
        }
        auto ci = chunkIndex(c->base);
        auto pi = chunkPageIndex(c->base);
        for(auto i = (unsigned int)(0); i < 64; i++)
        {
            if(c->cache & (1 << i) != 0)
            {
                rec::free1(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)), pi + i);
                rec::free(gocpp::recv(p->scav.index), ci, pi + i, 1);
            }
            if(c->scav & (1 << i) != 0)
            {
                rec::setRange(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)->scavenged), pi + i, 1);
            }
        }
        if(auto b = (offAddr {c->base}); rec::lessThan(gocpp::recv(b), p->searchAddr))
        {
            p->searchAddr = b;
        }
        rec::update(gocpp::recv(p), c->base, pageCachePages, false, false);
        *c = pageCache {};
    }

    // allocToCache acquires a pageCachePages-aligned chunk of free pages which
    // may not be contiguous, and returns a pageCache structure which owns the
    // chunk.
    //
    // p.mheapLock must be held.
    //
    // Must run on the system stack because p.mheapLock must be held.
    //
    //go:systemstack
    struct pageCache rec::allocToCache(struct pageAlloc* p)
    {
        assertLockHeld(p->mheapLock);
        if(chunkIndex(rec::addr(gocpp::recv(p->searchAddr))) >= p->end)
        {
            return pageCache {};
        }
        auto c = pageCache {};
        auto ci = chunkIndex(rec::addr(gocpp::recv(p->searchAddr)));
        pallocData* chunk = {};
        if(p->summary[len(p->summary) - 1][ci] != 0)
        {
            chunk = rec::chunkOf(gocpp::recv(p), ci);
            auto [j, gocpp_id_1] = rec::find(gocpp::recv(chunk), 1, chunkPageIndex(rec::addr(gocpp::recv(p->searchAddr))));
            if(j == ~ (unsigned int)(0))
            {
                go_throw("bad summary data"s);
            }
            c = gocpp::Init<pageCache>([=](auto& x) {
                x.base = chunkBase(ci) + alignDown(uintptr_t(j), 64) * pageSize;
                x.cache = ~ rec::pages64(gocpp::recv(chunk), j);
                x.scav = rec::block64(gocpp::recv(chunk->scavenged), j);
            });
        }
        else
        {
            auto [addr, gocpp_id_3] = rec::find(gocpp::recv(p), 1);
            if(addr == 0)
            {
                p->searchAddr = maxSearchAddr();
                return pageCache {};
            }
            ci = chunkIndex(addr);
            chunk = rec::chunkOf(gocpp::recv(p), ci);
            c = gocpp::Init<pageCache>([=](auto& x) {
                x.base = alignDown(addr, 64 * pageSize);
                x.cache = ~ rec::pages64(gocpp::recv(chunk), chunkPageIndex(addr));
                x.scav = rec::block64(gocpp::recv(chunk->scavenged), chunkPageIndex(addr));
            });
        }
        auto cpi = chunkPageIndex(c->base);
        rec::allocPages64(gocpp::recv(chunk), cpi, c->cache);
        rec::clearBlock64(gocpp::recv(chunk->scavenged), cpi, c->cache & c->scav);
        rec::update(gocpp::recv(p), c->base, pageCachePages, false, true);
        rec::alloc(gocpp::recv(p->scav.index), ci, (unsigned int)(sys::OnesCount64(c->cache)));
        p->searchAddr = offAddr {c->base + pageSize * (pageCachePages - 1)};
        return c;
    }

}

