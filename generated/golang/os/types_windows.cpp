// generated by GoCpp from file '$(ImportDir)/os/types_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/types_windows.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/reparse_windows.h"
#include "golang/internal/syscall/windows/symlink_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/internal/syscall/windows/zsyscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/error.h"
#include "golang/os/path_windows.h"
#include "golang/os/types.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/exec_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/unsafe/unsafe.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace fs::rec;
        using namespace os::rec;
        using namespace sync::rec;
        using namespace syscall::rec;
        using namespace time::rec;
        using namespace unsafe::rec;
        using namespace windows::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    fileStat::operator T()
    {
        T result;
        result.name = this->name;
        result.FileAttributes = this->FileAttributes;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.FileSizeHigh = this->FileSizeHigh;
        result.FileSizeLow = this->FileSizeLow;
        result.ReparseTag = this->ReparseTag;
        result.filetype = this->filetype;
        result.path = this->path;
        result.vol = this->vol;
        result.idxhi = this->idxhi;
        result.idxlo = this->idxlo;
        result.appendNameToPath = this->appendNameToPath;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fileStat::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (FileAttributes != ref.FileAttributes) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (FileSizeHigh != ref.FileSizeHigh) return false;
        if (FileSizeLow != ref.FileSizeLow) return false;
        if (ReparseTag != ref.ReparseTag) return false;
        if (filetype != ref.filetype) return false;
        if (path != ref.path) return false;
        if (vol != ref.vol) return false;
        if (idxhi != ref.idxhi) return false;
        if (idxlo != ref.idxlo) return false;
        if (appendNameToPath != ref.appendNameToPath) return false;
        return true;
    }

    std::ostream& fileStat::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << FileAttributes;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << FileSizeHigh;
        os << " " << FileSizeLow;
        os << " " << ReparseTag;
        os << " " << filetype;
        os << " " << path;
        os << " " << vol;
        os << " " << idxhi;
        os << " " << idxlo;
        os << " " << appendNameToPath;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fileStat& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<struct fileStat*, struct gocpp::error> newFileStatFromGetFileInformationByHandle(std::string path, syscall::Handle h)
    {
        struct fileStat* fs;
        struct gocpp::error err;
        syscall::ByHandleFileInformation d = {};
        err = syscall::GetFileInformationByHandle(h, & d);
        if(err != nullptr)
        {
            struct fileStat* fs;
            struct gocpp::error err;
            return {nullptr, gocpp::InitPtr<os::PathError>([](os::PathError& x) { x.Op = "GetFileInformationByHandle"; x.Path = path; x.Err = err; })};
        }
        windows::FILE_ATTRIBUTE_TAG_INFO ti = {};
        err = windows::GetFileInformationByHandleEx(h, windows::FileAttributeTagInfo, (unsigned char*)(unsafe::Pointer(& ti)), uint32_t(gocpp::Sizeof<windows::FILE_ATTRIBUTE_TAG_INFO>()));
        if(err != nullptr)
        {
            struct fileStat* fs;
            struct gocpp::error err;
            if(auto [errno, ok] = gocpp::getValue<syscall::Errno>(err); ok && errno == windows::ERROR_INVALID_PARAMETER)
            {
                struct fileStat* fs;
                struct gocpp::error err;
                ti.ReparseTag = 0;
            }
            else
            {
                struct fileStat* fs;
                struct gocpp::error err;
                return {nullptr, gocpp::InitPtr<os::PathError>([](os::PathError& x) { x.Op = "GetFileInformationByHandleEx"; x.Path = path; x.Err = err; })};
            }
        }
        return {gocpp::InitPtr<fileStat>([](fileStat& x) { x.name = basename(path); x.FileAttributes = d.FileAttributes; x.CreationTime = d.CreationTime; x.LastAccessTime = d.LastAccessTime; x.LastWriteTime = d.LastWriteTime; x.FileSizeHigh = d.FileSizeHigh; x.FileSizeLow = d.FileSizeLow; x.vol = d.VolumeSerialNumber; x.idxhi = d.FileIndexHigh; x.idxlo = d.FileIndexLow; x.ReparseTag = ti.ReparseTag; }), nullptr};
    }

    struct fileStat* newFileStatFromFileIDBothDirInfo(windows::FILE_ID_BOTH_DIR_INFO* d)
    {
        return gocpp::InitPtr<fileStat>([](fileStat& x) { x.FileAttributes = d->FileAttributes; x.CreationTime = d->CreationTime; x.LastAccessTime = d->LastAccessTime; x.LastWriteTime = d->LastWriteTime; x.FileSizeHigh = uint32_t(d->EndOfFile >> 32); x.FileSizeLow = uint32_t(d->EndOfFile); x.ReparseTag = d->EaSize; x.idxhi = uint32_t(d->FileID >> 32); x.idxlo = uint32_t(d->FileID); });
    }

    struct fileStat* newFileStatFromFileFullDirInfo(windows::FILE_FULL_DIR_INFO* d)
    {
        return gocpp::InitPtr<fileStat>([](fileStat& x) { x.FileAttributes = d->FileAttributes; x.CreationTime = d->CreationTime; x.LastAccessTime = d->LastAccessTime; x.LastWriteTime = d->LastWriteTime; x.FileSizeHigh = uint32_t(d->EndOfFile >> 32); x.FileSizeLow = uint32_t(d->EndOfFile); x.ReparseTag = d->EaSize; });
    }

    struct fileStat* newFileStatFromWin32finddata(syscall::Win32finddata* d)
    {
        auto fs = gocpp::InitPtr<fileStat>([](fileStat& x) { x.FileAttributes = d->FileAttributes; x.CreationTime = d->CreationTime; x.LastAccessTime = d->LastAccessTime; x.LastWriteTime = d->LastWriteTime; x.FileSizeHigh = d->FileSizeHigh; x.FileSizeLow = d->FileSizeLow; });
        if(d->FileAttributes & syscall::FILE_ATTRIBUTE_REPARSE_POINT != 0)
        {
            fs->ReparseTag = d->Reserved0;
        }
        return fs;
    }

    bool rec::isReparseTagNameSurrogate(struct fileStat* fs)
    {
        return fs->ReparseTag & 0x20000000 != 0;
    }

    bool rec::isSymlink(struct fileStat* fs)
    {
        return fs->ReparseTag == syscall::IO_REPARSE_TAG_SYMLINK || fs->ReparseTag == windows::IO_REPARSE_TAG_MOUNT_POINT;
    }

    int64_t rec::Size(struct fileStat* fs)
    {
        return (int64_t(fs->FileSizeHigh) << 32) + int64_t(fs->FileSizeLow);
    }

    os::FileMode rec::Mode(struct fileStat* fs)
    {
        os::FileMode m;
        if(fs->FileAttributes & syscall::FILE_ATTRIBUTE_READONLY != 0)
        {
            os::FileMode m;
            m |= 0444;
        }
        else
        {
            os::FileMode m;
            m |= 0666;
        }
        if(rec::isSymlink(gocpp::recv(fs)))
        {
            os::FileMode m;
            return m | ModeSymlink;
        }
        if(fs->FileAttributes & syscall::FILE_ATTRIBUTE_DIRECTORY != 0)
        {
            os::FileMode m;
            m |= ModeDir | 0111;
        }
        //Go switch emulation
        {
            auto condition = fs->filetype;
            int conditionId = -1;
            if(condition == syscall::FILE_TYPE_PIPE) { conditionId = 0; }
            else if(condition == syscall::FILE_TYPE_CHAR) { conditionId = 1; }
            switch(conditionId)
            {
                os::FileMode m;
                case 0:
                    m |= ModeNamedPipe;
                    break;
                case 1:
                    m |= ModeDevice | ModeCharDevice;
                    break;
            }
        }
        if(fs->FileAttributes & syscall::FILE_ATTRIBUTE_REPARSE_POINT != 0 && m & ModeType == 0)
        {
            os::FileMode m;
            if(fs->ReparseTag == windows::IO_REPARSE_TAG_DEDUP)
            {
                os::FileMode m;
            }
            else
            {
                os::FileMode m;
                m |= ModeIrregular;
            }
        }
        return m;
    }

    mocklib::Date rec::ModTime(struct fileStat* fs)
    {
        return time::Unix(0, rec::Nanoseconds(gocpp::recv(fs->LastWriteTime)));
    }

    go_any rec::Sys(struct fileStat* fs)
    {
        return gocpp::InitPtr<syscall::Win32FileAttributeData>([](syscall::Win32FileAttributeData& x) { x.FileAttributes = fs->FileAttributes; x.CreationTime = fs->CreationTime; x.LastAccessTime = fs->LastAccessTime; x.LastWriteTime = fs->LastWriteTime; x.FileSizeHigh = fs->FileSizeHigh; x.FileSizeLow = fs->FileSizeLow; });
    }

    struct gocpp::error rec::loadFileId(struct fileStat* fs)
    {
        gocpp::Defer defer;
        try
        {
            rec::Lock(gocpp::recv(fs));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(fs)); });
            if(fs->path == "")
            {
                return nullptr;
            }
            std::string path = {};
            if(fs->appendNameToPath)
            {
                path = fixLongPath(fs->path + "\\" + fs->name);
            }
            else
            {
                path = fs->path;
            }
            auto [pathp, err] = syscall::UTF16PtrFromString(path);
            if(err != nullptr)
            {
                return err;
            }
            auto attrs = uint32_t(syscall::FILE_FLAG_BACKUP_SEMANTICS | syscall::FILE_FLAG_OPEN_REPARSE_POINT);
            syscall::Handle h;
            std::tie(h, err) = syscall::CreateFile(pathp, 0, 0, nullptr, syscall::OPEN_EXISTING, attrs, 0);
            if(err != nullptr)
            {
                return err;
            }
            defer.push_back([=]{ syscall::CloseHandle(h); });
            syscall::ByHandleFileInformation i = {};
            err = syscall::GetFileInformationByHandle(h, & i);
            if(err != nullptr)
            {
                return err;
            }
            fs->path = "";
            fs->vol = i.VolumeSerialNumber;
            fs->idxhi = i.FileIndexHigh;
            fs->idxlo = i.FileIndexLow;
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error rec::saveInfoFromPath(struct fileStat* fs, std::string path)
    {
        fs->path = path;
        if(! isAbs(fs->path))
        {
            gocpp::error err = {};
            std::tie(fs->path, err) = syscall::FullPath(fs->path);
            if(err != nullptr)
            {
                return gocpp::InitPtr<os::PathError>([](os::PathError& x) { x.Op = "FullPath"; x.Path = path; x.Err = err; });
            }
        }
        fs->name = basename(path);
        return nullptr;
    }

    bool sameFile(struct fileStat* fs1, struct fileStat* fs2)
    {
        auto e = rec::loadFileId(gocpp::recv(fs1));
        if(e != nullptr)
        {
            return false;
        }
        e = rec::loadFileId(gocpp::recv(fs2));
        if(e != nullptr)
        {
            return false;
        }
        return fs1->vol == fs2->vol && fs1->idxhi == fs2->idxhi && fs1->idxlo == fs2->idxlo;
    }

    mocklib::Date atime(golang::os::FileInfo fi)
    {
        return time::Unix(0, rec::Nanoseconds(gocpp::recv(gocpp::getValue<syscall::Win32FileAttributeData*>(rec::Sys(gocpp::recv(fi)))->LastAccessTime)));
    }

}

