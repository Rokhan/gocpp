// generated by GoCpp from file '$(ImportDir)/io/io.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/io/io.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/sync/cond.h"
#include "golang/sync/pool.h"

// Package io provides basic interfaces to I/O primitives.
// Its primary job is to wrap existing implementations of such primitives,
// such as those in package os, into shared public interfaces that
// abstract the functionality, plus some other related primitives.
//
// Because these interfaces and primitives wrap lower-level operations with
// various implementations, unless otherwise informed clients should not
// assume they are safe for parallel execution.
namespace golang::io
{
    namespace rec
    {
        using namespace mocklib::rec;
        using sync::rec::Get;
        using sync::rec::Put;
    }

    // Seek whence values.
    // ErrShortWrite means that a write accepted fewer bytes than requested
    // but failed to return an explicit error.
    gocpp::error ErrShortWrite = errors::New("short write"_s);
    // errInvalidWrite means that a write returned an impossible count.
    gocpp::error errInvalidWrite = errors::New("invalid write result"_s);
    // ErrShortBuffer means that a read required a longer buffer than was provided.
    gocpp::error ErrShortBuffer = errors::New("short buffer"_s);
    // EOF is the error returned by Read when no more input is available.
    // (Read must return EOF itself, not an error wrapping EOF,
    // because callers will test for EOF using ==.)
    // Functions should return EOF only to signal a graceful end of input.
    // If the EOF occurs unexpectedly in a structured data stream,
    // the appropriate error is either [ErrUnexpectedEOF] or some other error
    // giving more detail.
    gocpp::error go_EOF = errors::New("EOF"_s);
    // ErrUnexpectedEOF means that EOF was encountered in the
    // middle of reading a fixed-size block or data structure.
    gocpp::error ErrUnexpectedEOF = errors::New("unexpected EOF"_s);
    // ErrNoProgress is returned by some clients of a [Reader] when
    // many calls to Read have failed to return any data or error,
    // usually the sign of a broken [Reader] implementation.
    gocpp::error ErrNoProgress = errors::New("multiple Read calls return no data or error"_s);
    // Reader is the interface that wraps the basic Read method.
    //
    // Read reads up to len(p) bytes into p. It returns the number of bytes
    // read (0 <= n <= len(p)) and any error encountered. Even if Read
    // returns n < len(p), it may use all of p as scratch space during the call.
    // If some data is available but not len(p) bytes, Read conventionally
    // returns what is available instead of waiting for more.
    //
    // When Read encounters an error or end-of-file condition after
    // successfully reading n > 0 bytes, it returns the number of
    // bytes read. It may return the (non-nil) error from the same call
    // or return the error (and n == 0) from a subsequent call.
    // An instance of this general case is that a Reader returning
    // a non-zero number of bytes at the end of the input stream may
    // return either err == EOF or err == nil. The next Read should
    // return 0, EOF.
    //
    // Callers should always process the n > 0 bytes returned before
    // considering the error err. Doing so correctly handles I/O errors
    // that happen after reading some bytes and also both of the
    // allowed EOF behaviors.
    //
    // If len(p) == 0, Read should always return n == 0. It may return a
    // non-nil error if some error condition is known, such as EOF.
    //
    // Implementations of Read are discouraged from returning a
    // zero byte count with a nil error, except when len(p) == 0.
    // Callers should treat a return of 0 and nil as indicating that
    // nothing happened; in particular it does not indicate EOF.
    //
    // Implementations must not retain p.
    
    template<typename T>
    Reader::Reader(T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(const T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(T* ptr)
    {
        value.reset(new ReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> Reader::ReaderImpl<T, StoreT>::vRead(gocpp::slice<unsigned char> p)
    {
        return rec::Read(gocpp::PtrRecv<T, false>(value.get()), p);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Read(const gocpp::PtrRecv<struct Reader, false>& self, gocpp::slice<unsigned char> p)
        {
            return self.ptr->value->vRead(p);
        }

        std::tuple<int, struct gocpp::error> Read(const gocpp::ObjRecv<struct Reader>& self, gocpp::slice<unsigned char> p)
        {
            return self.obj.value->vRead(p);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    // Writer is the interface that wraps the basic Write method.
    //
    // Write writes len(p) bytes from p to the underlying data stream.
    // It returns the number of bytes written from p (0 <= n <= len(p))
    // and any error encountered that caused the write to stop early.
    // Write must return a non-nil error if it returns n < len(p).
    // Write must not modify the slice data, even temporarily.
    //
    // Implementations must not retain p.
    
    template<typename T>
    Writer::Writer(T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(const T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(T* ptr)
    {
        value.reset(new WriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> Writer::WriterImpl<T, StoreT>::vWrite(gocpp::slice<unsigned char> p)
    {
        return rec::Write(gocpp::PtrRecv<T, false>(value.get()), p);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Write(const gocpp::PtrRecv<struct Writer, false>& self, gocpp::slice<unsigned char> p)
        {
            return self.ptr->value->vWrite(p);
        }

        std::tuple<int, struct gocpp::error> Write(const gocpp::ObjRecv<struct Writer>& self, gocpp::slice<unsigned char> p)
        {
            return self.obj.value->vWrite(p);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    // Closer is the interface that wraps the basic Close method.
    //
    // The behavior of Close after the first call is undefined.
    // Specific implementations may document their own behavior.
    
    template<typename T>
    Closer::Closer(T& ref)
    {
        value.reset(new CloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Closer::Closer(const T& ref)
    {
        value.reset(new CloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Closer::Closer(T* ptr)
    {
        value.reset(new CloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Closer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error Closer::CloserImpl<T, StoreT>::vClose()
    {
        return rec::Close(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        struct gocpp::error Close(const gocpp::PtrRecv<struct Closer, false>& self)
        {
            return self.ptr->value->vClose();
        }

        struct gocpp::error Close(const gocpp::ObjRecv<struct Closer>& self)
        {
            return self.obj.value->vClose();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Closer& value)
    {
        return value.PrintTo(os);
    }

    // Seeker is the interface that wraps the basic Seek method.
    //
    // Seek sets the offset for the next Read or Write to offset,
    // interpreted according to whence:
    // [SeekStart] means relative to the start of the file,
    // [SeekCurrent] means relative to the current offset, and
    // [SeekEnd] means relative to the end
    // (for example, offset = -2 specifies the penultimate byte of the file).
    // Seek returns the new offset relative to the start of the
    // file or an error, if any.
    //
    // Seeking to an offset before the start of the file is an error.
    // Seeking to any positive offset may be allowed, but if the new offset exceeds
    // the size of the underlying object the behavior of subsequent I/O operations
    // is implementation-dependent.
    
    template<typename T>
    Seeker::Seeker(T& ref)
    {
        value.reset(new SeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Seeker::Seeker(const T& ref)
    {
        value.reset(new SeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Seeker::Seeker(T* ptr)
    {
        value.reset(new SeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Seeker::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, struct gocpp::error> Seeker::SeekerImpl<T, StoreT>::vSeek(int64_t offset, int whence)
    {
        return rec::Seek(gocpp::PtrRecv<T, false>(value.get()), offset, whence);
    }

    namespace rec
    {
        std::tuple<int64_t, struct gocpp::error> Seek(const gocpp::PtrRecv<struct Seeker, false>& self, int64_t offset, int whence)
        {
            return self.ptr->value->vSeek(offset, whence);
        }

        std::tuple<int64_t, struct gocpp::error> Seek(const gocpp::ObjRecv<struct Seeker>& self, int64_t offset, int whence)
        {
            return self.obj.value->vSeek(offset, whence);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Seeker& value)
    {
        return value.PrintTo(os);
    }

    // ReadWriter is the interface that groups the basic Read and Write methods.
    
    template<typename T>
    ReadWriter::ReadWriter(T& ref)
    {
        value.reset(new ReadWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriter::ReadWriter(const T& ref)
    {
        value.reset(new ReadWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriter::ReadWriter(T* ptr)
    {
        value.reset(new ReadWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriter& value)
    {
        return value.PrintTo(os);
    }

    // ReadCloser is the interface that groups the basic Read and Close methods.
    
    template<typename T>
    ReadCloser::ReadCloser(T& ref)
    {
        value.reset(new ReadCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadCloser::ReadCloser(const T& ref)
    {
        value.reset(new ReadCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadCloser::ReadCloser(T* ptr)
    {
        value.reset(new ReadCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadCloser& value)
    {
        return value.PrintTo(os);
    }

    // WriteCloser is the interface that groups the basic Write and Close methods.
    
    template<typename T>
    WriteCloser::WriteCloser(T& ref)
    {
        value.reset(new WriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteCloser::WriteCloser(const T& ref)
    {
        value.reset(new WriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteCloser::WriteCloser(T* ptr)
    {
        value.reset(new WriteCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriteCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct WriteCloser& value)
    {
        return value.PrintTo(os);
    }

    // ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.
    
    template<typename T>
    ReadWriteCloser::ReadWriteCloser(T& ref)
    {
        value.reset(new ReadWriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteCloser::ReadWriteCloser(const T& ref)
    {
        value.reset(new ReadWriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteCloser::ReadWriteCloser(T* ptr)
    {
        value.reset(new ReadWriteCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriteCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriteCloser& value)
    {
        return value.PrintTo(os);
    }

    // ReadSeeker is the interface that groups the basic Read and Seek methods.
    
    template<typename T>
    ReadSeeker::ReadSeeker(T& ref)
    {
        value.reset(new ReadSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeeker::ReadSeeker(const T& ref)
    {
        value.reset(new ReadSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeeker::ReadSeeker(T* ptr)
    {
        value.reset(new ReadSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadSeeker& value)
    {
        return value.PrintTo(os);
    }

    // ReadSeekCloser is the interface that groups the basic Read, Seek and Close
    // methods.
    
    template<typename T>
    ReadSeekCloser::ReadSeekCloser(T& ref)
    {
        value.reset(new ReadSeekCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeekCloser::ReadSeekCloser(const T& ref)
    {
        value.reset(new ReadSeekCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeekCloser::ReadSeekCloser(T* ptr)
    {
        value.reset(new ReadSeekCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadSeekCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadSeekCloser& value)
    {
        return value.PrintTo(os);
    }

    // WriteSeeker is the interface that groups the basic Write and Seek methods.
    
    template<typename T>
    WriteSeeker::WriteSeeker(T& ref)
    {
        value.reset(new WriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteSeeker::WriteSeeker(const T& ref)
    {
        value.reset(new WriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteSeeker::WriteSeeker(T* ptr)
    {
        value.reset(new WriteSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriteSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct WriteSeeker& value)
    {
        return value.PrintTo(os);
    }

    // ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.
    
    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(T& ref)
    {
        value.reset(new ReadWriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(const T& ref)
    {
        value.reset(new ReadWriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(T* ptr)
    {
        value.reset(new ReadWriteSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriteSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriteSeeker& value)
    {
        return value.PrintTo(os);
    }

    // ReaderFrom is the interface that wraps the ReadFrom method.
    //
    // ReadFrom reads data from r until EOF or error.
    // The return value n is the number of bytes read.
    // Any error except EOF encountered during the read is also returned.
    //
    // The [Copy] function uses [ReaderFrom] if available.
    
    template<typename T>
    ReaderFrom::ReaderFrom(T& ref)
    {
        value.reset(new ReaderFromImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderFrom::ReaderFrom(const T& ref)
    {
        value.reset(new ReaderFromImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderFrom::ReaderFrom(T* ptr)
    {
        value.reset(new ReaderFromImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReaderFrom::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, struct gocpp::error> ReaderFrom::ReaderFromImpl<T, StoreT>::vReadFrom(struct Reader r)
    {
        return rec::ReadFrom(gocpp::PtrRecv<T, false>(value.get()), r);
    }

    namespace rec
    {
        std::tuple<int64_t, struct gocpp::error> ReadFrom(const gocpp::PtrRecv<struct ReaderFrom, false>& self, struct Reader r)
        {
            return self.ptr->value->vReadFrom(r);
        }

        std::tuple<int64_t, struct gocpp::error> ReadFrom(const gocpp::ObjRecv<struct ReaderFrom>& self, struct Reader r)
        {
            return self.obj.value->vReadFrom(r);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ReaderFrom& value)
    {
        return value.PrintTo(os);
    }

    // WriterTo is the interface that wraps the WriteTo method.
    //
    // WriteTo writes data to w until there's no more data to write or
    // when an error occurs. The return value n is the number of bytes
    // written. Any error encountered during the write is also returned.
    //
    // The Copy function uses WriterTo if available.
    
    template<typename T>
    WriterTo::WriterTo(T& ref)
    {
        value.reset(new WriterToImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterTo::WriterTo(const T& ref)
    {
        value.reset(new WriterToImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterTo::WriterTo(T* ptr)
    {
        value.reset(new WriterToImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriterTo::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, struct gocpp::error> WriterTo::WriterToImpl<T, StoreT>::vWriteTo(struct Writer w)
    {
        return rec::WriteTo(gocpp::PtrRecv<T, false>(value.get()), w);
    }

    namespace rec
    {
        std::tuple<int64_t, struct gocpp::error> WriteTo(const gocpp::PtrRecv<struct WriterTo, false>& self, struct Writer w)
        {
            return self.ptr->value->vWriteTo(w);
        }

        std::tuple<int64_t, struct gocpp::error> WriteTo(const gocpp::ObjRecv<struct WriterTo>& self, struct Writer w)
        {
            return self.obj.value->vWriteTo(w);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct WriterTo& value)
    {
        return value.PrintTo(os);
    }

    // ReaderAt is the interface that wraps the basic ReadAt method.
    //
    // ReadAt reads len(p) bytes into p starting at offset off in the
    // underlying input source. It returns the number of bytes
    // read (0 <= n <= len(p)) and any error encountered.
    //
    // When ReadAt returns n < len(p), it returns a non-nil error
    // explaining why more bytes were not returned. In this respect,
    // ReadAt is stricter than Read.
    //
    // Even if ReadAt returns n < len(p), it may use all of p as scratch
    // space during the call. If some data is available but not len(p) bytes,
    // ReadAt blocks until either all the data is available or an error occurs.
    // In this respect ReadAt is different from Read.
    //
    // If the n = len(p) bytes returned by ReadAt are at the end of the
    // input source, ReadAt may return either err == EOF or err == nil.
    //
    // If ReadAt is reading from an input source with a seek offset,
    // ReadAt should not affect nor be affected by the underlying
    // seek offset.
    //
    // Clients of ReadAt can execute parallel ReadAt calls on the
    // same input source.
    //
    // Implementations must not retain p.
    
    template<typename T>
    ReaderAt::ReaderAt(T& ref)
    {
        value.reset(new ReaderAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderAt::ReaderAt(const T& ref)
    {
        value.reset(new ReaderAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderAt::ReaderAt(T* ptr)
    {
        value.reset(new ReaderAtImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReaderAt::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> ReaderAt::ReaderAtImpl<T, StoreT>::vReadAt(gocpp::slice<unsigned char> p, int64_t off)
    {
        return rec::ReadAt(gocpp::PtrRecv<T, false>(value.get()), p, off);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> ReadAt(const gocpp::PtrRecv<struct ReaderAt, false>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.ptr->value->vReadAt(p, off);
        }

        std::tuple<int, struct gocpp::error> ReadAt(const gocpp::ObjRecv<struct ReaderAt>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.obj.value->vReadAt(p, off);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ReaderAt& value)
    {
        return value.PrintTo(os);
    }

    // WriterAt is the interface that wraps the basic WriteAt method.
    //
    // WriteAt writes len(p) bytes from p to the underlying data stream
    // at offset off. It returns the number of bytes written from p (0 <= n <= len(p))
    // and any error encountered that caused the write to stop early.
    // WriteAt must return a non-nil error if it returns n < len(p).
    //
    // If WriteAt is writing to a destination with a seek offset,
    // WriteAt should not affect nor be affected by the underlying
    // seek offset.
    //
    // Clients of WriteAt can execute parallel WriteAt calls on the same
    // destination if the ranges do not overlap.
    //
    // Implementations must not retain p.
    
    template<typename T>
    WriterAt::WriterAt(T& ref)
    {
        value.reset(new WriterAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterAt::WriterAt(const T& ref)
    {
        value.reset(new WriterAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterAt::WriterAt(T* ptr)
    {
        value.reset(new WriterAtImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriterAt::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> WriterAt::WriterAtImpl<T, StoreT>::vWriteAt(gocpp::slice<unsigned char> p, int64_t off)
    {
        return rec::WriteAt(gocpp::PtrRecv<T, false>(value.get()), p, off);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> WriteAt(const gocpp::PtrRecv<struct WriterAt, false>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.ptr->value->vWriteAt(p, off);
        }

        std::tuple<int, struct gocpp::error> WriteAt(const gocpp::ObjRecv<struct WriterAt>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.obj.value->vWriteAt(p, off);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct WriterAt& value)
    {
        return value.PrintTo(os);
    }

    // ByteReader is the interface that wraps the ReadByte method.
    //
    // ReadByte reads and returns the next byte from the input or
    // any error encountered. If ReadByte returns an error, no input
    // byte was consumed, and the returned byte value is undefined.
    //
    // ReadByte provides an efficient interface for byte-at-time
    // processing. A [Reader] that does not implement  ByteReader
    // can be wrapped using bufio.NewReader to add this method.
    
    template<typename T>
    ByteReader::ByteReader(T& ref)
    {
        value.reset(new ByteReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteReader::ByteReader(const T& ref)
    {
        value.reset(new ByteReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteReader::ByteReader(T* ptr)
    {
        value.reset(new ByteReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteReader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<unsigned char, struct gocpp::error> ByteReader::ByteReaderImpl<T, StoreT>::vReadByte()
    {
        return rec::ReadByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<unsigned char, struct gocpp::error> ReadByte(const gocpp::PtrRecv<struct ByteReader, false>& self)
        {
            return self.ptr->value->vReadByte();
        }

        std::tuple<unsigned char, struct gocpp::error> ReadByte(const gocpp::ObjRecv<struct ByteReader>& self)
        {
            return self.obj.value->vReadByte();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteReader& value)
    {
        return value.PrintTo(os);
    }

    // ByteScanner is the interface that adds the UnreadByte method to the
    // basic ReadByte method.
    //
    // UnreadByte causes the next call to ReadByte to return the last byte read.
    // If the last operation was not a successful call to ReadByte, UnreadByte may
    // return an error, unread the last byte read (or the byte prior to the
    // last-unread byte), or (in implementations that support the [Seeker] interface)
    // seek to one byte before the current offset.
    
    template<typename T>
    ByteScanner::ByteScanner(T& ref)
    {
        value.reset(new ByteScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteScanner::ByteScanner(const T& ref)
    {
        value.reset(new ByteScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteScanner::ByteScanner(T* ptr)
    {
        value.reset(new ByteScannerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteScanner::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error ByteScanner::ByteScannerImpl<T, StoreT>::vUnreadByte()
    {
        return rec::UnreadByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        struct gocpp::error UnreadByte(const gocpp::PtrRecv<struct ByteScanner, false>& self)
        {
            return self.ptr->value->vUnreadByte();
        }

        struct gocpp::error UnreadByte(const gocpp::ObjRecv<struct ByteScanner>& self)
        {
            return self.obj.value->vUnreadByte();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteScanner& value)
    {
        return value.PrintTo(os);
    }

    // ByteWriter is the interface that wraps the WriteByte method.
    
    template<typename T>
    ByteWriter::ByteWriter(T& ref)
    {
        value.reset(new ByteWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteWriter::ByteWriter(const T& ref)
    {
        value.reset(new ByteWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteWriter::ByteWriter(T* ptr)
    {
        value.reset(new ByteWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error ByteWriter::ByteWriterImpl<T, StoreT>::vWriteByte(unsigned char c)
    {
        return rec::WriteByte(gocpp::PtrRecv<T, false>(value.get()), c);
    }

    namespace rec
    {
        struct gocpp::error WriteByte(const gocpp::PtrRecv<struct ByteWriter, false>& self, unsigned char c)
        {
            return self.ptr->value->vWriteByte(c);
        }

        struct gocpp::error WriteByte(const gocpp::ObjRecv<struct ByteWriter>& self, unsigned char c)
        {
            return self.obj.value->vWriteByte(c);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteWriter& value)
    {
        return value.PrintTo(os);
    }

    // RuneReader is the interface that wraps the ReadRune method.
    //
    // ReadRune reads a single encoded Unicode character
    // and returns the rune and its size in bytes. If no character is
    // available, err will be set.
    
    template<typename T>
    RuneReader::RuneReader(T& ref)
    {
        value.reset(new RuneReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneReader::RuneReader(const T& ref)
    {
        value.reset(new RuneReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneReader::RuneReader(T* ptr)
    {
        value.reset(new RuneReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RuneReader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<gocpp::rune, int, struct gocpp::error> RuneReader::RuneReaderImpl<T, StoreT>::vReadRune()
    {
        return rec::ReadRune(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<gocpp::rune, int, struct gocpp::error> ReadRune(const gocpp::PtrRecv<struct RuneReader, false>& self)
        {
            return self.ptr->value->vReadRune();
        }

        std::tuple<gocpp::rune, int, struct gocpp::error> ReadRune(const gocpp::ObjRecv<struct RuneReader>& self)
        {
            return self.obj.value->vReadRune();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct RuneReader& value)
    {
        return value.PrintTo(os);
    }

    // RuneScanner is the interface that adds the UnreadRune method to the
    // basic ReadRune method.
    //
    // UnreadRune causes the next call to ReadRune to return the last rune read.
    // If the last operation was not a successful call to ReadRune, UnreadRune may
    // return an error, unread the last rune read (or the rune prior to the
    // last-unread rune), or (in implementations that support the [Seeker] interface)
    // seek to the start of the rune before the current offset.
    
    template<typename T>
    RuneScanner::RuneScanner(T& ref)
    {
        value.reset(new RuneScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneScanner::RuneScanner(const T& ref)
    {
        value.reset(new RuneScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneScanner::RuneScanner(T* ptr)
    {
        value.reset(new RuneScannerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RuneScanner::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error RuneScanner::RuneScannerImpl<T, StoreT>::vUnreadRune()
    {
        return rec::UnreadRune(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        struct gocpp::error UnreadRune(const gocpp::PtrRecv<struct RuneScanner, false>& self)
        {
            return self.ptr->value->vUnreadRune();
        }

        struct gocpp::error UnreadRune(const gocpp::ObjRecv<struct RuneScanner>& self)
        {
            return self.obj.value->vUnreadRune();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct RuneScanner& value)
    {
        return value.PrintTo(os);
    }

    // StringWriter is the interface that wraps the WriteString method.
    
    template<typename T>
    StringWriter::StringWriter(T& ref)
    {
        value.reset(new StringWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    StringWriter::StringWriter(const T& ref)
    {
        value.reset(new StringWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    StringWriter::StringWriter(T* ptr)
    {
        value.reset(new StringWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& StringWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> StringWriter::StringWriterImpl<T, StoreT>::vWriteString(gocpp::string s)
    {
        return rec::WriteString(gocpp::PtrRecv<T, false>(value.get()), s);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> WriteString(const gocpp::PtrRecv<struct StringWriter, false>& self, gocpp::string s)
        {
            return self.ptr->value->vWriteString(s);
        }

        std::tuple<int, struct gocpp::error> WriteString(const gocpp::ObjRecv<struct StringWriter>& self, gocpp::string s)
        {
            return self.obj.value->vWriteString(s);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct StringWriter& value)
    {
        return value.PrintTo(os);
    }

    // WriteString writes the contents of the string s to w, which accepts a slice of bytes.
    // If w implements [StringWriter], [StringWriter.WriteString] is invoked directly.
    // Otherwise, [Writer.Write] is called exactly once.
    std::tuple<int, struct gocpp::error> WriteString(struct Writer w, gocpp::string s)
    {
        int n;
        struct gocpp::error err;
        if(auto [sw, ok] = gocpp::getValue<StringWriter>(w); ok)
        {
            return rec::WriteString(gocpp::recv(sw), s);
        }
        return rec::Write(gocpp::recv(w), gocpp::slice<unsigned char>(s));
    }

    // ReadAtLeast reads from r into buf until it has read at least min bytes.
    // It returns the number of bytes copied and an error if fewer bytes were read.
    // The error is EOF only if no bytes were read.
    // If an EOF happens after reading fewer than min bytes,
    // ReadAtLeast returns [ErrUnexpectedEOF].
    // If min is greater than the length of buf, ReadAtLeast returns [ErrShortBuffer].
    // On return, n >= min if and only if err == nil.
    // If r returns an error having read at least min bytes, the error is dropped.
    std::tuple<int, struct gocpp::error> ReadAtLeast(struct Reader r, gocpp::slice<unsigned char> buf, int min)
    {
        int n;
        struct gocpp::error err;
        if(len(buf) < min)
        {
            return {0, ErrShortBuffer};
        }
        for(; n < min && err == nullptr; )
        {
            int nn = {};
            std::tie(nn, err) = rec::Read(gocpp::recv(r), buf.make_slice(n));
            n += nn;
        }
        if(n >= min)
        {
            err = nullptr;
        }
        else
        if(n > 0 && err == go_EOF)
        {
            err = ErrUnexpectedEOF;
        }
        return {n, err};
    }

    // ReadFull reads exactly len(buf) bytes from r into buf.
    // It returns the number of bytes copied and an error if fewer bytes were read.
    // The error is EOF only if no bytes were read.
    // If an EOF happens after reading some but not all the bytes,
    // ReadFull returns [ErrUnexpectedEOF].
    // On return, n == len(buf) if and only if err == nil.
    // If r returns an error having read at least len(buf) bytes, the error is dropped.
    std::tuple<int, struct gocpp::error> ReadFull(struct Reader r, gocpp::slice<unsigned char> buf)
    {
        int n;
        struct gocpp::error err;
        return ReadAtLeast(r, buf, len(buf));
    }

    // CopyN copies n bytes (or until an error) from src to dst.
    // It returns the number of bytes copied and the earliest
    // error encountered while copying.
    // On return, written == n if and only if err == nil.
    //
    // If dst implements [ReaderFrom], the copy is implemented using it.
    std::tuple<int64_t, struct gocpp::error> CopyN(struct Writer dst, struct Reader src, int64_t n)
    {
        int64_t written;
        struct gocpp::error err;
        std::tie(written, err) = Copy(dst, LimitReader(src, n));
        if(written == n)
        {
            return {n, nullptr};
        }
        if(written < n && err == nullptr)
        {
            err = go_EOF;
        }
        return {written, err};
    }

    // Copy copies from src to dst until either EOF is reached
    // on src or an error occurs. It returns the number of bytes
    // copied and the first error encountered while copying, if any.
    //
    // A successful Copy returns err == nil, not err == EOF.
    // Because Copy is defined to read from src until EOF, it does
    // not treat an EOF from Read as an error to be reported.
    //
    // If src implements [WriterTo],
    // the copy is implemented by calling src.WriteTo(dst).
    // Otherwise, if dst implements [ReaderFrom],
    // the copy is implemented by calling dst.ReadFrom(src).
    std::tuple<int64_t, struct gocpp::error> Copy(struct Writer dst, struct Reader src)
    {
        int64_t written;
        struct gocpp::error err;
        return copyBuffer(dst, src, nullptr);
    }

    // CopyBuffer is identical to Copy except that it stages through the
    // provided buffer (if one is required) rather than allocating a
    // temporary one. If buf is nil, one is allocated; otherwise if it has
    // zero length, CopyBuffer panics.
    //
    // If either src implements [WriterTo] or dst implements [ReaderFrom],
    // buf will not be used to perform the copy.
    std::tuple<int64_t, struct gocpp::error> CopyBuffer(struct Writer dst, struct Reader src, gocpp::slice<unsigned char> buf)
    {
        int64_t written;
        struct gocpp::error err;
        if(buf != nullptr && len(buf) == 0)
        {
            gocpp::panic("empty buffer in CopyBuffer"_s);
        }
        return copyBuffer(dst, src, buf);
    }

    // copyBuffer is the actual implementation of Copy and CopyBuffer.
    // if buf is nil, one is allocated.
    std::tuple<int64_t, struct gocpp::error> copyBuffer(struct Writer dst, struct Reader src, gocpp::slice<unsigned char> buf)
    {
        int64_t written;
        struct gocpp::error err;
        if(auto [wt, ok] = gocpp::getValue<WriterTo>(src); ok)
        {
            return rec::WriteTo(gocpp::recv(wt), dst);
        }
        if(auto [rt, ok] = gocpp::getValue<ReaderFrom>(dst); ok)
        {
            return rec::ReadFrom(gocpp::recv(rt), src);
        }
        if(buf == nullptr)
        {
            auto size = 32 * 1024;
            if(auto [l, ok] = gocpp::getValue<LimitedReader*>(src); ok && int64_t(size) > l->N)
            {
                if(l->N < 1)
                {
                    size = 1;
                }
                else
                {
                    size = int(l->N);
                }
            }
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        }
        for(; ; )
        {
            auto [nr, er] = rec::Read(gocpp::recv(src), buf);
            if(nr > 0)
            {
                auto [nw, ew] = rec::Write(gocpp::recv(dst), buf.make_slice(0, nr));
                if(nw < 0 || nr < nw)
                {
                    nw = 0;
                    if(ew == nullptr)
                    {
                        ew = errInvalidWrite;
                    }
                }
                written += int64_t(nw);
                if(ew != nullptr)
                {
                    err = ew;
                    break;
                }
                if(nr != nw)
                {
                    err = ErrShortWrite;
                    break;
                }
            }
            if(er != nullptr)
            {
                if(er != go_EOF)
                {
                    err = er;
                }
                break;
            }
        }
        return {written, err};
    }

    // LimitReader returns a Reader that reads from r
    // but stops with EOF after n bytes.
    // The underlying implementation is a *LimitedReader.
    struct Reader LimitReader(struct Reader r, int64_t n)
    {
        return new LimitedReader {r, n};
    }

    // A LimitedReader reads from R but limits the amount of
    // data returned to just N bytes. Each call to Read
    // updates N to reflect the new amount remaining.
    // Read returns EOF when N <= 0 or when the underlying R returns EOF.
    
    template<typename T> requires gocpp::GoStruct<T>
    LimitedReader::operator T()
    {
        T result;
        result.R = this->R;
        result.N = this->N;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool LimitedReader::operator==(const T& ref) const
    {
        if (R != ref.R) return false;
        if (N != ref.N) return false;
        return true;
    }

    std::ostream& LimitedReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << N;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LimitedReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(golang::io::LimitedReader* l, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(l->N <= 0)
        {
            return {0, go_EOF};
        }
        if(int64_t(len(p)) > l->N)
        {
            p = p.make_slice(0, l->N);
        }
        std::tie(n, err) = rec::Read(gocpp::recv(l->R), p);
        l->N -= int64_t(n);
        return {n, err};
    }

    // NewSectionReader returns a [SectionReader] that reads from r
    // starting at offset off and stops with EOF after n bytes.
    struct SectionReader* NewSectionReader(struct ReaderAt r, int64_t off, int64_t n)
    {
        int64_t remaining = {};
        auto maxint64 = (1 << 63) - 1;
        if(off <= maxint64 - n)
        {
            remaining = n + off;
        }
        else
        {
            remaining = maxint64;
        }
        return new SectionReader {r, off, off, remaining, n};
    }

    // SectionReader implements Read, Seek, and ReadAt on a section
    // of an underlying [ReaderAt].
    
    template<typename T> requires gocpp::GoStruct<T>
    SectionReader::operator T()
    {
        T result;
        result.r = this->r;
        result.base = this->base;
        result.off = this->off;
        result.limit = this->limit;
        result.n = this->n;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SectionReader::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (base != ref.base) return false;
        if (off != ref.off) return false;
        if (limit != ref.limit) return false;
        if (n != ref.n) return false;
        return true;
    }

    std::ostream& SectionReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << base;
        os << " " << off;
        os << " " << limit;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SectionReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(golang::io::SectionReader* s, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(s->off >= s->limit)
        {
            return {0, go_EOF};
        }
        if(auto max = s->limit - s->off; int64_t(len(p)) > max)
        {
            p = p.make_slice(0, max);
        }
        std::tie(n, err) = rec::ReadAt(gocpp::recv(s->r), p, s->off);
        s->off += int64_t(n);
        return {n, err};
    }

    gocpp::error errWhence = errors::New("Seek: invalid whence"_s);
    gocpp::error errOffset = errors::New("Seek: invalid offset"_s);
    std::tuple<int64_t, struct gocpp::error> rec::Seek(golang::io::SectionReader* s, int64_t offset, int whence)
    {
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            if(condition == SeekStart) { conditionId = 0; }
            else if(condition == SeekCurrent) { conditionId = 1; }
            else if(condition == SeekEnd) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    return {0, errWhence};
                    break;
                case 0:
                    offset += s->base;
                    break;
                case 1:
                    offset += s->off;
                    break;
                case 2:
                    offset += s->limit;
                    break;
            }
        }
        if(offset < s->base)
        {
            return {0, errOffset};
        }
        s->off = offset;
        return {offset - s->base, nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::ReadAt(golang::io::SectionReader* s, gocpp::slice<unsigned char> p, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(off < 0 || off >= rec::Size(gocpp::recv(s)))
        {
            return {0, go_EOF};
        }
        off += s->base;
        if(auto max = s->limit - off; int64_t(len(p)) > max)
        {
            p = p.make_slice(0, max);
            std::tie(n, err) = rec::ReadAt(gocpp::recv(s->r), p, off);
            if(err == nullptr)
            {
                err = go_EOF;
            }
            return {n, err};
        }
        return rec::ReadAt(gocpp::recv(s->r), p, off);
    }

    // Size returns the size of the section in bytes.
    int64_t rec::Size(golang::io::SectionReader* s)
    {
        return s->limit - s->base;
    }

    // Outer returns the underlying [ReaderAt] and offsets for the section.
    //
    // The returned values are the same that were passed to [NewSectionReader]
    // when the [SectionReader] was created.
    std::tuple<struct ReaderAt, int64_t, int64_t> rec::Outer(golang::io::SectionReader* s)
    {
        struct ReaderAt r;
        int64_t off;
        int64_t n;
        return {s->r, s->base, s->n};
    }

    // An OffsetWriter maps writes at offset base to offset base+off in the underlying writer.
    
    template<typename T> requires gocpp::GoStruct<T>
    OffsetWriter::operator T()
    {
        T result;
        result.w = this->w;
        result.base = this->base;
        result.off = this->off;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool OffsetWriter::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (base != ref.base) return false;
        if (off != ref.off) return false;
        return true;
    }

    std::ostream& OffsetWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << base;
        os << " " << off;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct OffsetWriter& value)
    {
        return value.PrintTo(os);
    }

    // NewOffsetWriter returns an [OffsetWriter] that writes to w
    // starting at offset off.
    struct OffsetWriter* NewOffsetWriter(struct WriterAt w, int64_t off)
    {
        return new OffsetWriter {w, off, off};
    }

    std::tuple<int, struct gocpp::error> rec::Write(golang::io::OffsetWriter* o, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::WriteAt(gocpp::recv(o->w), p, o->off);
        o->off += int64_t(n);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> rec::WriteAt(golang::io::OffsetWriter* o, gocpp::slice<unsigned char> p, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(off < 0)
        {
            return {0, errOffset};
        }
        off += o->base;
        return rec::WriteAt(gocpp::recv(o->w), p, off);
    }

    std::tuple<int64_t, struct gocpp::error> rec::Seek(golang::io::OffsetWriter* o, int64_t offset, int whence)
    {
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            if(condition == SeekStart) { conditionId = 0; }
            else if(condition == SeekCurrent) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    return {0, errWhence};
                    break;
                case 0:
                    offset += o->base;
                    break;
                case 1:
                    offset += o->off;
                    break;
            }
        }
        if(offset < o->base)
        {
            return {0, errOffset};
        }
        o->off = offset;
        return {offset - o->base, nullptr};
    }

    // TeeReader returns a [Reader] that writes to w what it reads from r.
    // All reads from r performed through it are matched with
    // corresponding writes to w. There is no internal buffering -
    // the write must complete before the read completes.
    // Any error encountered while writing is reported as a read error.
    struct Reader TeeReader(struct Reader r, struct Writer w)
    {
        return new teeReader {r, w};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    teeReader::operator T()
    {
        T result;
        result.r = this->r;
        result.w = this->w;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool teeReader::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (w != ref.w) return false;
        return true;
    }

    std::ostream& teeReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << w;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct teeReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(golang::io::teeReader* t, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Read(gocpp::recv(t->r), p);
        if(n > 0)
        {
            {
                auto [n_tmp, err] = rec::Write(gocpp::recv(t->w), p.make_slice(0, n));
                if(auto& n = n_tmp; err != nullptr)
                {
                    return {n, err};
                }
            }
        }
        return {n, err};
    }

    // Discard is a [Writer] on which all Write calls succeed
    // without doing anything.
    Writer Discard = discard {};
    
    template<typename T> requires gocpp::GoStruct<T>
    discard::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool discard::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& discard::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct discard& value)
    {
        return value.PrintTo(os);
    }

    // discard implements ReaderFrom as an optimization so Copy to
    // io.Discard can avoid doing unnecessary work.
    ReaderFrom _ = discard {};
    std::tuple<int, struct gocpp::error> rec::Write(golang::io::discard, gocpp::slice<unsigned char> p)
    {
        return {len(p), nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::WriteString(golang::io::discard, gocpp::string s)
    {
        return {len(s), nullptr};
    }

    sync::Pool blackHolePool = gocpp::Init<sync::Pool>([](auto& x) {
        x.New = []() mutable -> go_any
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 8192);
            return & b;
        };
    });
    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(golang::io::discard, struct Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        auto bufp = gocpp::getValue<gocpp::slice<unsigned char>*>(rec::Get(gocpp::recv(blackHolePool)));
        auto readSize = 0;
        for(; ; )
        {
            std::tie(readSize, err) = rec::Read(gocpp::recv(r), *bufp);
            n += int64_t(readSize);
            if(err != nullptr)
            {
                rec::Put(gocpp::recv(blackHolePool), bufp);
                if(err == go_EOF)
                {
                    return {n, nullptr};
                }
                return {n, err};
            }
        }
    }

    // NopCloser returns a [ReadCloser] with a no-op Close method wrapping
    // the provided [Reader] r.
    // If r implements [WriterTo], the returned [ReadCloser] will implement [WriterTo]
    // by forwarding calls to r.
    struct ReadCloser NopCloser(struct Reader r)
    {
        if(auto [gocpp_id_0, ok] = gocpp::getValue<WriterTo>(r); ok)
        {
            return nopCloserWriterTo {r};
        }
        return nopCloser {r};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    nopCloser::operator T()
    {
        T result;
        result.Reader = this->Reader;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool nopCloser::operator==(const T& ref) const
    {
        if (Reader != ref.Reader) return false;
        return true;
    }

    std::ostream& nopCloser::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Reader;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nopCloser& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp::error rec::Close(golang::io::nopCloser)
    {
        return nullptr;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    nopCloserWriterTo::operator T()
    {
        T result;
        result.Reader = this->Reader;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool nopCloserWriterTo::operator==(const T& ref) const
    {
        if (Reader != ref.Reader) return false;
        return true;
    }

    std::ostream& nopCloserWriterTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Reader;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nopCloserWriterTo& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp::error rec::Close(golang::io::nopCloserWriterTo)
    {
        return nullptr;
    }

    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(golang::io::nopCloserWriterTo c, struct Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        return rec::WriteTo(gocpp::recv(gocpp::getValue<WriterTo>(c.Reader)), w);
    }

    // ReadAll reads from r until an error or EOF and returns the data it read.
    // A successful call returns err == nil, not err == EOF. Because ReadAll is
    // defined to read from src until EOF, it does not treat an EOF from Read
    // as an error to be reported.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadAll(struct Reader r)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 512);
        for(; ; )
        {
            auto [n, err] = rec::Read(gocpp::recv(r), b.make_slice(len(b), cap(b)));
            b = b.make_slice(0, len(b) + n);
            if(err != nullptr)
            {
                if(err == go_EOF)
                {
                    err = nullptr;
                }
                return {b, err};
            }
            if(len(b) == cap(b))
            {
                b = append(b, 0).make_slice(0, len(b));
            }
        }
    }

}

