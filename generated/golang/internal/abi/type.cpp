// generated by GoCpp from file '$(ImportDir)/internal/abi/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/type.h"
#include "gocpp/support.h"

#include "golang/unsafe/unsafe.h"

namespace golang::abi
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Type is the runtime representation of a Go type.
    //
    // Be careful about accessing this type at build time, as the version
    // of this type in the compiler/linker may not have the same layout
    // as the version in the target binary, due to pointer width
    // differences and any experiments. Use cmd/compile/internal/rttype
    // or the functions in compiletype.go to access this type instead.
    // (TODO: this admonition applies to every type in this package.
    // Put it in some shared location?)
    
    template<typename T> requires gocpp::GoStruct<T>
    Type::operator T()
    {
        T result;
        result.Size_ = this->Size_;
        result.PtrBytes = this->PtrBytes;
        result.Hash = this->Hash;
        result.TFlag = this->TFlag;
        result.Align_ = this->Align_;
        result.FieldAlign_ = this->FieldAlign_;
        result.Kind_ = this->Kind_;
        result.Equal = this->Equal;
        result.GCData = this->GCData;
        result.Str = this->Str;
        result.PtrToThis = this->PtrToThis;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Type::operator==(const T& ref) const
    {
        if (Size_ != ref.Size_) return false;
        if (PtrBytes != ref.PtrBytes) return false;
        if (Hash != ref.Hash) return false;
        if (TFlag != ref.TFlag) return false;
        if (Align_ != ref.Align_) return false;
        if (FieldAlign_ != ref.FieldAlign_) return false;
        if (Kind_ != ref.Kind_) return false;
        if (Equal != ref.Equal) return false;
        if (GCData != ref.GCData) return false;
        if (Str != ref.Str) return false;
        if (PtrToThis != ref.PtrToThis) return false;
        return true;
    }

    std::ostream& Type::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size_;
        os << " " << PtrBytes;
        os << " " << Hash;
        os << " " << TFlag;
        os << " " << Align_;
        os << " " << FieldAlign_;
        os << " " << Kind_;
        os << " " << Equal;
        os << " " << GCData;
        os << " " << Str;
        os << " " << PtrToThis;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value)
    {
        return value.PrintTo(os);
    }

    // A Kind represents the specific kind of type that a Type represents.
    // The zero Kind is not a valid kind.
    // TODO (khr, drchase) why aren't these in TFlag?  Investigate, fix if possible.
    // TFlag is used by a Type to signal what extra type information is
    // available in the memory directly following the Type value.
    // TFlagUncommon means that there is a data with a type, UncommonType,
    // just beyond the shared-per-type common data.  That is, the data
    // for struct types will store their UncommonType at one offset, the
    // data for interface types will store their UncommonType at a different
    // offset.  UncommonType is always accessed via a pointer that is computed
    // using trust-us-we-are-the-implementors pointer arithmetic.
    //
    // For example, if t.Kind() == Struct and t.tflag&TFlagUncommon != 0,
    // then t has UncommonType data and it can be accessed as:
    //
    //	type structTypeUncommon struct {
    //		structType
    //		u UncommonType
    //	}
    //	u := &(*structTypeUncommon)(unsafe.Pointer(t)).u
    // TFlagExtraStar means the name in the str field has an
    // extraneous '*' prefix. This is because for most types T in
    // a program, the type *T also exists and reusing the str data
    // saves binary size.
    // TFlagNamed means the type has a name.
    // TFlagRegularMemory means that equal and hash functions can treat
    // this type as a single region of t.size bytes.
    // TFlagUnrolledBitmap marks special types that are unrolled-bitmap
    // versions of types with GC programs.
    // These types need to be deallocated when the underlying object
    // is freed.
    // NameOff is the offset to a name from moduledata.types.  See resolveNameOff in runtime.
    // TypeOff is the offset to a type from moduledata.types.  See resolveTypeOff in runtime.
    // TextOff is an offset from the top of a text section.  See (rtype).textOff in runtime.
    // String returns the name of k.
    std::string rec::String(golang::abi::Kind k)
    {
        if(int(k) < len(kindNames))
        {
            return kindNames[k];
        }
        return kindNames[0];
    }

    gocpp::slice<std::string> kindNames = gocpp::Init<gocpp::slice<std::string>>([](auto& x) {
        x[Invalid] = "invalid"s;
        x[Bool] = "bool"s;
        x[Int] = "int"s;
        x[Int8] = "int8"s;
        x[Int16] = "int16"s;
        x[Int32] = "int32"s;
        x[Int64] = "int64"s;
        x[Uint] = "uint"s;
        x[Uint8] = "uint8"s;
        x[Uint16] = "uint16"s;
        x[Uint32] = "uint32"s;
        x[Uint64] = "uint64"s;
        x[Uintptr] = "uintptr"s;
        x[Float32] = "float32"s;
        x[Float64] = "float64"s;
        x[Complex64] = "complex64"s;
        x[Complex128] = "complex128"s;
        x[Array] = "array"s;
        x[Chan] = "chan"s;
        x[Func] = "func"s;
        x[Interface] = "interface"s;
        x[Map] = "map"s;
        x[Pointer] = "ptr"s;
        x[Slice] = "slice"s;
        x[String] = "string"s;
        x[Struct] = "struct"s;
        x[UnsafePointer] = "unsafe.Pointer"s;
    });
    abi::Kind rec::Kind(struct Type* t)
    {
        return Kind(t->Kind_ & KindMask);
    }

    bool rec::HasName(struct Type* t)
    {
        return t->TFlag & TFlagNamed != 0;
    }

    bool rec::Pointers(struct Type* t)
    {
        return t->PtrBytes != 0;
    }

    // IfaceIndir reports whether t is stored indirectly in an interface value.
    bool rec::IfaceIndir(struct Type* t)
    {
        return t->Kind_ & KindDirectIface == 0;
    }

    // isDirectIface reports whether t is stored directly in an interface value.
    bool rec::IsDirectIface(struct Type* t)
    {
        return t->Kind_ & KindDirectIface != 0;
    }

    gocpp::slice<unsigned char> rec::GcSlice(struct Type* t, uintptr_t begin, uintptr_t end)
    {
        return unsafe::Slice(t->GCData, int(end)).make_slice(begin);
    }

    // Method on non-interface type
    
    template<typename T> requires gocpp::GoStruct<T>
    Method::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Mtyp = this->Mtyp;
        result.Ifn = this->Ifn;
        result.Tfn = this->Tfn;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Method::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Mtyp != ref.Mtyp) return false;
        if (Ifn != ref.Ifn) return false;
        if (Tfn != ref.Tfn) return false;
        return true;
    }

    std::ostream& Method::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Mtyp;
        os << " " << Ifn;
        os << " " << Tfn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Method& value)
    {
        return value.PrintTo(os);
    }

    // UncommonType is present only for defined types or types with methods
    // (if T is a defined type, the uncommonTypes for T and *T have methods).
    // Using a pointer to this struct reduces the overall size required
    // to describe a non-defined type with no methods.
    
    template<typename T> requires gocpp::GoStruct<T>
    UncommonType::operator T()
    {
        T result;
        result.PkgPath = this->PkgPath;
        result.Mcount = this->Mcount;
        result.Xcount = this->Xcount;
        result.Moff = this->Moff;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool UncommonType::operator==(const T& ref) const
    {
        if (PkgPath != ref.PkgPath) return false;
        if (Mcount != ref.Mcount) return false;
        if (Xcount != ref.Xcount) return false;
        if (Moff != ref.Moff) return false;
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& UncommonType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PkgPath;
        os << " " << Mcount;
        os << " " << Xcount;
        os << " " << Moff;
        os << " " << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct UncommonType& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<Method> rec::Methods(struct UncommonType* t)
    {
        if(t->Mcount == 0)
        {
            return nullptr;
        }
        return (gocpp::array<Method, 1 << 16>*)(addChecked(unsafe::Pointer(t), uintptr_t(t->Moff), "t.mcount > 0"s)).make_slice(, t->Mcount, t->Mcount);
    }

    gocpp::slice<Method> rec::ExportedMethods(struct UncommonType* t)
    {
        if(t->Xcount == 0)
        {
            return nullptr;
        }
        return (gocpp::array<Method, 1 << 16>*)(addChecked(unsafe::Pointer(t), uintptr_t(t->Moff), "t.xcount > 0"s)).make_slice(, t->Xcount, t->Xcount);
    }

    // addChecked returns p+x.
    //
    // The whySafe string is ignored, so that the function still inlines
    // as efficiently as p+x, but all call sites should use the string to
    // record why the addition is safe, which is to say why the addition
    // does not cause x to advance to the very end of p's allocation
    // and therefore point incorrectly at the next block in memory.
    unsafe::Pointer addChecked(unsafe::Pointer p, uintptr_t x, std::string whySafe)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    // Imethod represents a method on an interface type
    
    template<typename T> requires gocpp::GoStruct<T>
    Imethod::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Typ = this->Typ;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Imethod::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Typ != ref.Typ) return false;
        return true;
    }

    std::ostream& Imethod::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Typ;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Imethod& value)
    {
        return value.PrintTo(os);
    }

    // ArrayType represents a fixed array type.
    
    template<typename T> requires gocpp::GoStruct<T>
    ArrayType::operator T()
    {
        T result;
        result.Elem = this->Elem;
        result.Slice = this->Slice;
        result.Len = this->Len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ArrayType::operator==(const T& ref) const
    {
        if (Elem != ref.Elem) return false;
        if (Slice != ref.Slice) return false;
        if (Len != ref.Len) return false;
        return true;
    }

    std::ostream& ArrayType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << " " << Slice;
        os << " " << Len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ArrayType& value)
    {
        return value.PrintTo(os);
    }

    // Len returns the length of t if t is an array type, otherwise 0
    int rec::Len(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) == Array)
        {
            return int((ArrayType*)(unsafe::Pointer(t))->Len);
        }
        return 0;
    }

    struct Type* rec::Common(struct Type* t)
    {
        return t;
    }

    // ChanType represents a channel type
    
    template<typename T> requires gocpp::GoStruct<T>
    ChanType::operator T()
    {
        T result;
        result.Elem = this->Elem;
        result.Dir = this->Dir;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ChanType::operator==(const T& ref) const
    {
        if (Elem != ref.Elem) return false;
        if (Dir != ref.Dir) return false;
        return true;
    }

    std::ostream& ChanType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << " " << Dir;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ChanType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    structTypeUncommon::operator T()
    {
        T result;
        result.u = this->u;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool structTypeUncommon::operator==(const T& ref) const
    {
        if (u != ref.u) return false;
        return true;
    }

    std::ostream& structTypeUncommon::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value)
    {
        return value.PrintTo(os);
    }

    // ChanDir returns the direction of t if t is a channel type, otherwise InvalidDir (0).
    abi::ChanDir rec::ChanDir(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) == Chan)
        {
            auto ch = (ChanType*)(unsafe::Pointer(t));
            return ch->Dir;
        }
        return InvalidDir;
    }

    // Uncommon returns a pointer to T's "uncommon" data if there is any, otherwise nil
    struct UncommonType* rec::Uncommon(struct Type* t)
    {
        if(t->TFlag & TFlagUncommon == 0)
        {
            return nullptr;
        }
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == Struct) { conditionId = 0; }
            else if(condition == Pointer) { conditionId = 1; }
            else if(condition == Func) { conditionId = 2; }
            else if(condition == Slice) { conditionId = 3; }
            else if(condition == Array) { conditionId = 4; }
            else if(condition == Chan) { conditionId = 5; }
            else if(condition == Map) { conditionId = 6; }
            else if(condition == Interface) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return & (structTypeUncommon*)(unsafe::Pointer(t))->u;
                    break;
                case 1:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 2:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 3:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 4:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 5:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 6:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 7:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                default:
                    
                    template<typename T> requires gocpp::GoStruct<T>
                    u::operator T()
                    {
                        T result;
                        result.u = this->u;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool u::operator==(const T& ref) const
                    {
                        if (u != ref.u) return false;
                        return true;
                    }

                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
            }
        }
    }

    // Elem returns the element type for t if t is an array, channel, map, pointer, or slice, otherwise nil.
    struct Type* rec::Elem(struct Type* t)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == Pointer) { conditionId = 3; }
            else if(condition == Slice) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    auto tt = (ArrayType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 1:
                    auto tt = (ChanType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 2:
                    auto tt = (MapType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 3:
                    auto tt = (PtrType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 4:
                    auto tt = (SliceType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
            }
        }
        return nullptr;
    }

    // StructType returns t cast to a *StructType, or nil if its tag does not match.
    struct StructType* rec::StructType(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            return nullptr;
        }
        return (StructType*)(unsafe::Pointer(t));
    }

    // MapType returns t cast to a *MapType, or nil if its tag does not match.
    struct MapType* rec::MapType(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Map)
        {
            return nullptr;
        }
        return (MapType*)(unsafe::Pointer(t));
    }

    // ArrayType returns t cast to a *ArrayType, or nil if its tag does not match.
    struct ArrayType* rec::ArrayType(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Array)
        {
            return nullptr;
        }
        return (ArrayType*)(unsafe::Pointer(t));
    }

    // FuncType returns t cast to a *FuncType, or nil if its tag does not match.
    struct FuncType* rec::FuncType(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            return nullptr;
        }
        return (FuncType*)(unsafe::Pointer(t));
    }

    // InterfaceType returns t cast to a *InterfaceType, or nil if its tag does not match.
    struct InterfaceType* rec::InterfaceType(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Interface)
        {
            return nullptr;
        }
        return (InterfaceType*)(unsafe::Pointer(t));
    }

    // Size returns the size of data with type t.
    uintptr_t rec::Size(struct Type* t)
    {
        return t->Size_;
    }

    // Align returns the alignment of data with type t.
    int rec::Align(struct Type* t)
    {
        return int(t->Align_);
    }

    int rec::FieldAlign(struct Type* t)
    {
        return int(t->FieldAlign_);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    InterfaceType::operator T()
    {
        T result;
        result.PkgPath = this->PkgPath;
        result.Methods = this->Methods;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool InterfaceType::operator==(const T& ref) const
    {
        if (PkgPath != ref.PkgPath) return false;
        if (Methods != ref.Methods) return false;
        return true;
    }

    std::ostream& InterfaceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PkgPath;
        os << " " << Methods;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct InterfaceType& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<Method> rec::ExportedMethods(struct Type* t)
    {
        auto ut = rec::Uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return nullptr;
        }
        return rec::ExportedMethods(gocpp::recv(ut));
    }

    int rec::NumMethod(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (InterfaceType*)(unsafe::Pointer(t));
            return rec::NumMethod(gocpp::recv(tt));
        }
        return len(rec::ExportedMethods(gocpp::recv(t)));
    }

    // NumMethod returns the number of interface methods in the type's method set.
    int rec::NumMethod(struct InterfaceType* t)
    {
        return len(t->Methods);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    MapType::operator T()
    {
        T result;
        result.Key = this->Key;
        result.Elem = this->Elem;
        result.Bucket = this->Bucket;
        result.Hasher = this->Hasher;
        result.KeySize = this->KeySize;
        result.ValueSize = this->ValueSize;
        result.BucketSize = this->BucketSize;
        result.Flags = this->Flags;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool MapType::operator==(const T& ref) const
    {
        if (Key != ref.Key) return false;
        if (Elem != ref.Elem) return false;
        if (Bucket != ref.Bucket) return false;
        if (Hasher != ref.Hasher) return false;
        if (KeySize != ref.KeySize) return false;
        if (ValueSize != ref.ValueSize) return false;
        if (BucketSize != ref.BucketSize) return false;
        if (Flags != ref.Flags) return false;
        return true;
    }

    std::ostream& MapType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Key;
        os << " " << Elem;
        os << " " << Bucket;
        os << " " << Hasher;
        os << " " << KeySize;
        os << " " << ValueSize;
        os << " " << BucketSize;
        os << " " << Flags;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MapType& value)
    {
        return value.PrintTo(os);
    }

    // Note: flag values must match those used in the TMAP case
    // in ../cmd/compile/internal/reflectdata/reflect.go:writeType.
    bool rec::IndirectKey(struct MapType* mt)
    {
        return mt->Flags & 1 != 0;
    }

    bool rec::IndirectElem(struct MapType* mt)
    {
        return mt->Flags & 2 != 0;
    }

    bool rec::ReflexiveKey(struct MapType* mt)
    {
        return mt->Flags & 4 != 0;
    }

    bool rec::NeedKeyUpdate(struct MapType* mt)
    {
        return mt->Flags & 8 != 0;
    }

    bool rec::HashMightPanic(struct MapType* mt)
    {
        return mt->Flags & 16 != 0;
    }

    struct Type* rec::Key(struct Type* t)
    {
        if(rec::Kind(gocpp::recv(t)) == Map)
        {
            return (MapType*)(unsafe::Pointer(t))->Key;
        }
        return nullptr;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SliceType::operator T()
    {
        T result;
        result.Elem = this->Elem;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SliceType::operator==(const T& ref) const
    {
        if (Elem != ref.Elem) return false;
        return true;
    }

    std::ostream& SliceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SliceType& value)
    {
        return value.PrintTo(os);
    }

    // funcType represents a function type.
    //
    // A *Type for each in and out parameter is stored in an array that
    // directly follows the funcType (and possibly its uncommonType). So
    // a function type with one method, one input, and one output is:
    //
    //	struct {
    //		funcType
    //		uncommonType
    //		[2]*rtype    // [0] is in, [1] is out
    //	}
    
    template<typename T> requires gocpp::GoStruct<T>
    FuncType::operator T()
    {
        T result;
        result.InCount = this->InCount;
        result.OutCount = this->OutCount;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool FuncType::operator==(const T& ref) const
    {
        if (InCount != ref.InCount) return false;
        if (OutCount != ref.OutCount) return false;
        return true;
    }

    std::ostream& FuncType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << InCount;
        os << " " << OutCount;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FuncType& value)
    {
        return value.PrintTo(os);
    }

    struct Type* rec::In(struct FuncType* t, int i)
    {
        return rec::InSlice(gocpp::recv(t))[i];
    }

    int rec::NumIn(struct FuncType* t)
    {
        return int(t->InCount);
    }

    int rec::NumOut(struct FuncType* t)
    {
        return int(t->OutCount & ((1 << 15) - 1));
    }

    struct Type* rec::Out(struct FuncType* t, int i)
    {
        return (rec::OutSlice(gocpp::recv(t))[i]);
    }

    gocpp::slice<Type*> rec::InSlice(struct FuncType* t)
    {
        auto uadd = gocpp::Sizeof<FuncType>();
        if(t->TFlag & TFlagUncommon != 0)
        {
            uadd += gocpp::Sizeof<UncommonType>();
        }
        if(t->InCount == 0)
        {
            return nullptr;
        }
        return (gocpp::array<Type*, 1 << 16>*)(addChecked(unsafe::Pointer(t), uadd, "t.inCount > 0"s)).make_slice(, t->InCount, t->InCount);
    }

    gocpp::slice<Type*> rec::OutSlice(struct FuncType* t)
    {
        auto outCount = uint16_t(rec::NumOut(gocpp::recv(t)));
        if(outCount == 0)
        {
            return nullptr;
        }
        auto uadd = gocpp::Sizeof<FuncType>();
        if(t->TFlag & TFlagUncommon != 0)
        {
            uadd += gocpp::Sizeof<UncommonType>();
        }
        return (gocpp::array<Type*, 1 << 17>*)(addChecked(unsafe::Pointer(t), uadd, "outCount > 0"s)).make_slice(t->InCount, t->InCount + outCount, t->InCount + outCount);
    }

    bool rec::IsVariadic(struct FuncType* t)
    {
        return t->OutCount & (1 << 15) != 0;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    PtrType::operator T()
    {
        T result;
        result.Elem = this->Elem;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool PtrType::operator==(const T& ref) const
    {
        if (Elem != ref.Elem) return false;
        return true;
    }

    std::ostream& PtrType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct PtrType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    StructField::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Typ = this->Typ;
        result.Offset = this->Offset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StructField::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Typ != ref.Typ) return false;
        if (Offset != ref.Offset) return false;
        return true;
    }

    std::ostream& StructField::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Typ;
        os << " " << Offset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructField& value)
    {
        return value.PrintTo(os);
    }

    bool rec::Embedded(struct StructField* f)
    {
        return rec::IsEmbedded(gocpp::recv(f->Name));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    StructType::operator T()
    {
        T result;
        result.PkgPath = this->PkgPath;
        result.Fields = this->Fields;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StructType::operator==(const T& ref) const
    {
        if (PkgPath != ref.PkgPath) return false;
        if (Fields != ref.Fields) return false;
        return true;
    }

    std::ostream& StructType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PkgPath;
        os << " " << Fields;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Name::operator T()
    {
        T result;
        result.Bytes = this->Bytes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Name::operator==(const T& ref) const
    {
        if (Bytes != ref.Bytes) return false;
        return true;
    }

    std::ostream& Name::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Bytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Name& value)
    {
        return value.PrintTo(os);
    }

    // DataChecked does pointer arithmetic on n's Bytes, and that arithmetic is asserted to
    // be safe for the reason in whySafe (which can appear in a backtrace, etc.)
    unsigned char* rec::DataChecked(struct Name n, int off, std::string whySafe)
    {
        return (unsigned char*)(addChecked(unsafe::Pointer(n.Bytes), uintptr_t(off), whySafe));
    }

    // Data does pointer arithmetic on n's Bytes, and that arithmetic is asserted to
    // be safe because the runtime made the call (other packages use DataChecked)
    unsigned char* rec::Data(struct Name n, int off)
    {
        return (unsigned char*)(addChecked(unsafe::Pointer(n.Bytes), uintptr_t(off), "the runtime doesn't need to give you a reason"s));
    }

    // IsExported returns "is n exported?"
    bool rec::IsExported(struct Name n)
    {
        return (*n.Bytes) & (1 << 0) != 0;
    }

    // HasTag returns true iff there is tag data following this name
    bool rec::HasTag(struct Name n)
    {
        return (*n.Bytes) & (1 << 1) != 0;
    }

    // IsEmbedded returns true iff n is embedded (an anonymous field).
    bool rec::IsEmbedded(struct Name n)
    {
        return (*n.Bytes) & (1 << 3) != 0;
    }

    // ReadVarint parses a varint as encoded by encoding/binary.
    // It returns the number of encoded bytes and the encoded value.
    std::tuple<int, int> rec::ReadVarint(struct Name n, int off)
    {
        auto v = 0;
        for(auto i = 0; ; i++)
        {
            auto x = *rec::DataChecked(gocpp::recv(n), off + i, "read varint"s);
            v += int(x & 0x7f) << (7 * i);
            if(x & 0x80 == 0)
            {
                return {i + 1, v};
            }
        }
    }

    // IsBlank indicates whether n is "_".
    bool rec::IsBlank(struct Name n)
    {
        if(n.Bytes == nullptr)
        {
            return false;
        }
        auto [gocpp_id_1, l] = rec::ReadVarint(gocpp::recv(n), 1);
        return l == 1 && *rec::Data(gocpp::recv(n), 2) == '_';
    }

    // writeVarint writes n to buf in varint form. Returns the
    // number of bytes written. n must be nonnegative.
    // Writes at most 10 bytes.
    int writeVarint(gocpp::slice<unsigned char> buf, int n)
    {
        for(auto i = 0; ; i++)
        {
            auto b = (unsigned char)(n & 0x7f);
            n >>= 7;
            if(n == 0)
            {
                buf[i] = b;
                return i + 1;
            }
            buf[i] = b | 0x80;
        }
    }

    // Name returns the tag string for n, or empty if there is none.
    std::string rec::Name(struct Name n)
    {
        if(n.Bytes == nullptr)
        {
            return ""s;
        }
        auto [i, l] = rec::ReadVarint(gocpp::recv(n), 1);
        return unsafe::String(rec::DataChecked(gocpp::recv(n), 1 + i, "non-empty string"s), l);
    }

    // Tag returns the tag string for n, or empty if there is none.
    std::string rec::Tag(struct Name n)
    {
        if(! rec::HasTag(gocpp::recv(n)))
        {
            return ""s;
        }
        auto [i, l] = rec::ReadVarint(gocpp::recv(n), 1);
        auto [i2, l2] = rec::ReadVarint(gocpp::recv(n), 1 + i + l);
        return unsafe::String(rec::DataChecked(gocpp::recv(n), 1 + i + l + i2, "non-empty string"s), l2);
    }

    struct Name NewName(std::string n, std::string tag, bool exported, bool embedded)
    {
        if(len(n) >= (1 << 29))
        {
            gocpp::panic("abi.NewName: name too long: "s + n.make_slice(0, 1024) + "..."s);
        }
        if(len(tag) >= (1 << 29))
        {
            gocpp::panic("abi.NewName: tag too long: "s + tag.make_slice(0, 1024) + "..."s);
        }
        gocpp::array<unsigned char, 10> nameLen = {};
        gocpp::array<unsigned char, 10> tagLen = {};
        auto nameLenLen = writeVarint(nameLen.make_slice(0), len(n));
        auto tagLenLen = writeVarint(tagLen.make_slice(0), len(tag));
        unsigned char bits = {};
        auto l = 1 + nameLenLen + len(n);
        if(exported)
        {
            bits |= 1 << 0;
        }
        if(len(tag) > 0)
        {
            l += tagLenLen + len(tag);
            bits |= 1 << 1;
        }
        if(embedded)
        {
            bits |= 1 << 3;
        }
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), l);
        b[0] = bits;
        copy(b.make_slice(1), nameLen.make_slice(0, nameLenLen));
        copy(b.make_slice(1 + nameLenLen), n);
        if(len(tag) > 0)
        {
            auto tb = b.make_slice(1 + nameLenLen + len(n));
            copy(tb, tagLen.make_slice(0, tagLenLen));
            copy(tb.make_slice(tagLenLen), tag);
        }
        return gocpp::Init<Name>([=](auto& x) {
            x.Bytes = & b[0];
        });
    }

}

