// generated by GoCpp from file '$(ImportDir)/compress/zlib/writer.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/zlib/writer.fwd.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"

namespace golang::zlib
{
    struct Writer
    {
        io::Writer w;
        int level;
        gocpp::slice<unsigned char> dict;
        flate::Writer* compressor;
        hash::Hash32 digest;
        gocpp::error err;
        gocpp::array<unsigned char, 4> scratch;
        bool wroteHeader;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Writer& value);
    struct Writer* NewWriter(io::Writer w);
    std::tuple<struct Writer*, struct gocpp::error> NewWriterLevel(io::Writer w, int level);
    std::tuple<struct Writer*, struct gocpp::error> NewWriterLevelDict(io::Writer w, int level, gocpp::slice<unsigned char> dict);

    namespace rec
    {
        void Reset(golang::zlib::Writer* z, io::Writer w);
        struct gocpp::error writeHeader(golang::zlib::Writer* z);
        std::tuple<int, struct gocpp::error> Write(golang::zlib::Writer* z, gocpp::slice<unsigned char> p);
        struct gocpp::error Flush(golang::zlib::Writer* z);
        struct gocpp::error Close(golang::zlib::Writer* z);
    }
}

