// generated by GoCpp from file '$(ImportDir)/os/path_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/path_windows.h"
#include "gocpp/support.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    bool IsPathSeparator(uint8_t c)
    {
        return c == '\\' || c == '/';
    }

    std::string basename(std::string name)
    {
        if(len(name) == 2 && name[1] == ':')
        {
            name = ".";
        }
        else
        if(len(name) > 2 && name[1] == ':')
        {
            name = name.make_slice(2);
        }
        auto i = len(name) - 1;
        for(; i > 0 && (name[i] == '/' || name[i] == '\\'); i--)
        {
            name = name.make_slice(0, i);
        }
        for(i--; i >= 0; i--)
        {
            if(name[i] == '/' || name[i] == '\\')
            {
                name = name.make_slice(i + 1);
                break;
            }
        }
        return name;
    }

    bool isAbs(std::string path)
    {
        bool b;
        auto v = volumeName(path);
        if(v == "")
        {
            return false;
        }
        path = path.make_slice(len(v));
        if(path == "")
        {
            return false;
        }
        return IsPathSeparator(path[0]);
    }

    std::string volumeName(std::string path)
    {
        std::string v;
        if(len(path) < 2)
        {
            return "";
        }
        auto c = path[0];
        if(path[1] == ':' && ('0' <= c && c <= '9' || 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'))
        {
            return path.make_slice(0, 2);
        }
        if(auto l = len(path); l >= 5 && IsPathSeparator(path[0]) && IsPathSeparator(path[1]) && ! IsPathSeparator(path[2]) && path[2] != '.')
        {
            for(auto n = 3; n < l - 1; n++)
            {
                if(IsPathSeparator(path[n]))
                {
                    n++;
                    if(! IsPathSeparator(path[n]))
                    {
                        if(path[n] == '.')
                        {
                            break;
                        }
                        for(; n < l; n++)
                        {
                            if(IsPathSeparator(path[n]))
                            {
                                break;
                            }
                        }
                        return path.make_slice(0, n);
                    }
                    break;
                }
            }
        }
        return "";
    }

    std::string fromSlash(std::string path)
    {
        gocpp::slice<unsigned char> pathbuf = {};
        int lastSlash = {};
        for(auto [i, b] : path)
        {
            if(b == '/')
            {
                if(pathbuf == nullptr)
                {
                    pathbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(path));
                }
                copy(pathbuf.make_slice(lastSlash), path.make_slice(lastSlash, i));
                pathbuf[i] = '\\';
                lastSlash = i + 1;
            }
        }
        if(pathbuf == nullptr)
        {
            return path;
        }
        copy(pathbuf.make_slice(lastSlash), path.make_slice(lastSlash));
        return std::string(pathbuf);
    }

    std::string dirname(std::string path)
    {
        auto vol = volumeName(path);
        auto i = len(path) - 1;
        for(; i >= len(vol) && ! IsPathSeparator(path[i]); )
        {
            i--;
        }
        auto dir = path.make_slice(len(vol), i + 1);
        auto last = len(dir) - 1;
        if(last > 0 && IsPathSeparator(dir[last]))
        {
            dir = dir.make_slice(0, last);
        }
        if(dir == "")
        {
            dir = ".";
        }
        return vol + dir;
    }

    bool canUseLongPaths;
    std::string fixLongPath(std::string path)
    {
        if(canUseLongPaths)
        {
            return path;
        }
        if(len(path) < 248)
        {
            return path;
        }
        if(len(path) >= 2 && path.make_slice(0, 2) == "\\\\")
        {
            return path;
        }
        if(! isAbs(path))
        {
            return path;
        }
        auto prefix = "\\\\?";
        auto pathbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(prefix) + len(path) + len("\\"));
        copy(pathbuf, prefix);
        auto n = len(path);
        auto [r, w] = std::tuple{0, len(prefix)};
        for(; r < n; )
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if(IsPathSeparator(path[r])) { conditionId = 0; }
                else if(path[r] == '.' && (r + 1 == n || IsPathSeparator(path[r + 1]))) { conditionId = 1; }
                else if(r + 1 < n && path[r] == '.' && path[r + 1] == '.' && (r + 2 == n || IsPathSeparator(path[r + 2]))) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        r++;
                        break;
                    case 1:
                        r++;
                        break;
                    case 2:
                        return path;
                        break;
                    default:
                        pathbuf[w] = '\\';
                        w++;
                        for(; r < n && ! IsPathSeparator(path[r]); r++)
                        {
                            pathbuf[w] = path[r];
                            w++;
                        }
                        break;
                }
            }
        }
        if(w == len("\\\\?\\c:"))
        {
            pathbuf[w] = '\\';
            w++;
        }
        return std::string(pathbuf.make_slice(0, w));
    }

}

