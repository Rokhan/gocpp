// generated by GoCpp from file '$(ImportDir)/internal/syscall/windows/registry/key.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/syscall/windows/registry/key.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/registry/syscall.h"
#include "golang/internal/syscall/windows/registry/zsyscall_windows.h"
#include "golang/runtime/proc.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"

namespace golang::registry
{
    gocpp::error Close(Key k)
    {
        return syscall::RegCloseKey(syscall::Handle(k));
    }

    std::tuple<Key, gocpp::error> OpenKey(Key k, std::string path, uint32_t access)
    {
        auto [p, err] = syscall::UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return {0, err};
        }
        syscall::Handle subkey = {};
        err = syscall::RegOpenKeyEx(syscall::Handle(k), p, 0, access, & subkey);
        if(err != nullptr)
        {
            return {0, err};
        }
        return {Key(subkey), nullptr};
    }

    std::tuple<gocpp::slice<std::string>, gocpp::error> ReadSubKeyNames(Key k)
    {
        gocpp::Defer defer;
        try
        {
            runtime::LockOSThread();
            defer.push_back([=]{ runtime::UnlockOSThread(); });
            auto names = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0);
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 256);
            loopItems:
            for(auto i = uint32_t(0); ; i++)
            {
                auto l = uint32_t(len(buf));
                for(; ; )
                {
                    auto err = syscall::RegEnumKeyEx(syscall::Handle(k), i, & buf[0], & l, nullptr, nullptr, nullptr, nullptr);
                    if(err == nullptr)
                    {
                        break;
                    }
                    if(err == syscall::ERROR_MORE_DATA)
                    {
                        l = uint32_t(2 * len(buf));
                        buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), l);
                        continue;
                    }
                    if(err == _ERROR_NO_MORE_ITEMS)
                    {
                        goto loopItems_break;
                    }
                    return {names, err};
                }
                names = append(names, syscall::UTF16ToString(buf.make_slice(0, l)));
                if(false) {
                loopItems_continue:
                    continue;
                loopItems_break:
                    break;
                }
            }
            return {names, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<Key, bool, gocpp::error> CreateKey(Key k, std::string path, uint32_t access)
    {
        Key newk;
        bool openedExisting;
        gocpp::error err;
        syscall::Handle h = {};
        uint32_t d = {};
        err = regCreateKeyEx(syscall::Handle(k), syscall::StringToUTF16Ptr(path), 0, nullptr, _REG_OPTION_NON_VOLATILE, access, nullptr, & h, & d);
        if(err != nullptr)
        {
            Key newk;
            bool openedExisting;
            gocpp::error err;
            return {0, false, err};
        }
        return {Key(h), d == _REG_OPENED_EXISTING_KEY, nullptr};
    }

    gocpp::error DeleteKey(Key k, std::string path)
    {
        return regDeleteKey(syscall::Handle(k), syscall::StringToUTF16Ptr(path));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    KeyInfo::operator T()
    {
        T result;
        result.SubKeyCount = this->SubKeyCount;
        result.MaxSubKeyLen = this->MaxSubKeyLen;
        result.ValueCount = this->ValueCount;
        result.MaxValueNameLen = this->MaxValueNameLen;
        result.MaxValueLen = this->MaxValueLen;
        result.lastWriteTime = this->lastWriteTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool KeyInfo::operator==(const T& ref) const
    {
        if (SubKeyCount != ref.SubKeyCount) return false;
        if (MaxSubKeyLen != ref.MaxSubKeyLen) return false;
        if (ValueCount != ref.ValueCount) return false;
        if (MaxValueNameLen != ref.MaxValueNameLen) return false;
        if (MaxValueLen != ref.MaxValueLen) return false;
        if (lastWriteTime != ref.lastWriteTime) return false;
        return true;
    }

    std::ostream& KeyInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << SubKeyCount;
        os << " " << MaxSubKeyLen;
        os << " " << ValueCount;
        os << " " << MaxValueNameLen;
        os << " " << MaxValueLen;
        os << " " << lastWriteTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct KeyInfo& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<KeyInfo*, gocpp::error> Stat(Key k)
    {
        KeyInfo ki = {};
        auto err = syscall::RegQueryInfoKey(syscall::Handle(k), nullptr, nullptr, nullptr, & ki.SubKeyCount, & ki.MaxSubKeyLen, nullptr, & ki.ValueCount, & ki.MaxValueNameLen, & ki.MaxValueLen, nullptr, & ki.lastWriteTime);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {& ki, nullptr};
    }

}

