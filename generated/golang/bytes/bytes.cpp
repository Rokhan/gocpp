// generated by GoCpp from file '$(ImportDir)/bytes/bytes.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bytes/bytes.h"
#include "gocpp/support.h"

#include "golang/bytes/buffer.h"
// #include "golang/internal/bytealg/bytealg.h"  [Ignored, known errors]
#include "golang/internal/bytealg/compare_native.h"
#include "golang/internal/bytealg/count_native.h"
#include "golang/internal/bytealg/index_amd64.h"
#include "golang/internal/bytealg/index_native.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/bytealg/lastindexbyte_generic.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/letter.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::bytes
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace bytealg::rec;
        using namespace bytes::rec;
        using namespace unicode::rec;
        using namespace utf8::rec;
    }

    bool Equal(gocpp::slice<unsigned char> a, gocpp::slice<unsigned char> b)
    {
        return string(a) == string(b);
    }

    int Compare(gocpp::slice<unsigned char> a, gocpp::slice<unsigned char> b)
    {
        return bytealg::Compare(a, b);
    }

    gocpp::slice<gocpp::slice<unsigned char>> explode(gocpp::slice<unsigned char> s, int n)
    {
        if(n <= 0 || n > len(s))
        {
            n = len(s);
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), n);
        int size = {};
        auto na = 0;
        for(; len(s) > 0; )
        {
            if(na + 1 >= n)
            {
                a[na] = s;
                na++;
                break;
            }
            std::tie(gocpp_id_0, size) = utf8::DecodeRune(s);
            a[na] = s.make_slice(0, size, size);
            s = s.make_slice(size);
            na++;
        }
        return a.make_slice(0, na);
    }

    int Count(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        if(len(sep) == 0)
        {
            return utf8::RuneCount(s) + 1;
        }
        if(len(sep) == 1)
        {
            return bytealg::Count(s, sep[0]);
        }
        auto n = 0;
        for(; ; )
        {
            auto i = Index(s, sep);
            if(i == - 1)
            {
                return n;
            }
            n++;
            s = s.make_slice(i + len(sep));
        }
    }

    bool Contains(gocpp::slice<unsigned char> b, gocpp::slice<unsigned char> subslice)
    {
        return Index(b, subslice) != - 1;
    }

    bool ContainsAny(gocpp::slice<unsigned char> b, std::string chars)
    {
        return IndexAny(b, chars) >= 0;
    }

    bool ContainsRune(gocpp::slice<unsigned char> b, gocpp::rune r)
    {
        return IndexRune(b, r) >= 0;
    }

    bool ContainsFunc(gocpp::slice<unsigned char> b, std::function<bool (gocpp::rune)> f)
    {
        return IndexFunc(b, f) >= 0;
    }

    int IndexByte(gocpp::slice<unsigned char> b, unsigned char c)
    {
        return bytealg::IndexByte(b, c);
    }

    int indexBytePortable(gocpp::slice<unsigned char> s, unsigned char c)
    {
        for(auto [i, b] : s)
        {
            if(b == c)
            {
                return i;
            }
        }
        return - 1;
    }

    int LastIndex(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        auto n = len(sep);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return len(s);
                    break;
                case 1:
                    return bytealg::LastIndexByte(s, sep[0]);
                    break;
                case 2:
                    if(Equal(s, sep))
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
            }
        }
        return bytealg::LastIndexRabinKarp(s, sep);
    }

    int LastIndexByte(gocpp::slice<unsigned char> s, unsigned char c)
    {
        return bytealg::LastIndexByte(s, c);
    }

    int IndexRune(gocpp::slice<unsigned char> s, gocpp::rune r)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(0 <= r && r < utf8::RuneSelf) { conditionId = 0; }
            else if(r == utf8::RuneError) { conditionId = 1; }
            else if(! utf8::ValidRune(r)) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return IndexByte(s, unsigned char(r));
                    break;
                case 1:
                    for(auto i = 0; i < len(s); )
                    {
                        auto [r1, n] = utf8::DecodeRune(s.make_slice(i));
                        if(r1 == utf8::RuneError)
                        {
                            return i;
                        }
                        i += n;
                    }
                    return - 1;
                    break;
                case 2:
                    return - 1;
                    break;
                default:
                    gocpp::array<unsigned char, utf8::UTFMax> b = {};
                    auto n = utf8::EncodeRune(b.make_slice(0, ), r);
                    return Index(s, b.make_slice(0, n));
                    break;
            }
        }
    }

    int IndexAny(gocpp::slice<unsigned char> s, std::string chars)
    {
        if(chars == "")
        {
            return - 1;
        }
        if(len(s) == 1)
        {
            auto r = rune(s[0]);
            if(r >= utf8::RuneSelf)
            {
                for(std::tie(std::ignored, r) : chars)
                {
                    if(r == utf8::RuneError)
                    {
                        return 0;
                    }
                }
                return - 1;
            }
            if(bytealg::IndexByteString(chars, s[0]) >= 0)
            {
                return 0;
            }
            return - 1;
        }
        if(len(chars) == 1)
        {
            auto r = rune(chars[0]);
            if(r >= utf8::RuneSelf)
            {
                r = utf8::RuneError;
            }
            return IndexRune(s, r);
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto [i, c] : s)
                {
                    if(rec::contains(gocpp::recv(as), c))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        int width = {};
        for(auto i = 0; i < len(s); i += width)
        {
            auto r = rune(s[i]);
            if(r < utf8::RuneSelf)
            {
                if(bytealg::IndexByteString(chars, s[i]) >= 0)
                {
                    return i;
                }
                width = 1;
                continue;
            }
            std::tie(r, width) = utf8::DecodeRune(s.make_slice(i));
            if(r != utf8::RuneError)
            {
                if(len(chars) == width)
                {
                    if(chars == string(r))
                    {
                        return i;
                    }
                    continue;
                }
                if(bytealg::MaxLen >= width)
                {
                    if(bytealg::IndexString(chars, string(r)) >= 0)
                    {
                        return i;
                    }
                    continue;
                }
            }
            for(auto [gocpp_ignored, ch] : chars)
            {
                if(r == ch)
                {
                    return i;
                }
            }
        }
        return - 1;
    }

    int LastIndexAny(gocpp::slice<unsigned char> s, std::string chars)
    {
        if(chars == "")
        {
            return - 1;
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto i = len(s) - 1; i >= 0; i--)
                {
                    if(rec::contains(gocpp::recv(as), s[i]))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        if(len(s) == 1)
        {
            auto r = rune(s[0]);
            if(r >= utf8::RuneSelf)
            {
                for(std::tie(std::ignored, r) : chars)
                {
                    if(r == utf8::RuneError)
                    {
                        return 0;
                    }
                }
                return - 1;
            }
            if(bytealg::IndexByteString(chars, s[0]) >= 0)
            {
                return 0;
            }
            return - 1;
        }
        if(len(chars) == 1)
        {
            auto cr = rune(chars[0]);
            if(cr >= utf8::RuneSelf)
            {
                cr = utf8::RuneError;
            }
            for(auto i = len(s); i > 0; )
            {
                auto [r, size] = utf8::DecodeLastRune(s.make_slice(0, i));
                i -= size;
                if(r == cr)
                {
                    return i;
                }
            }
            return - 1;
        }
        for(auto i = len(s); i > 0; )
        {
            auto r = rune(s[i - 1]);
            if(r < utf8::RuneSelf)
            {
                if(bytealg::IndexByteString(chars, s[i - 1]) >= 0)
                {
                    return i - 1;
                }
                i--;
                continue;
            }
            int size;
            std::tie(r, size) = utf8::DecodeLastRune(s.make_slice(0, i));
            i -= size;
            if(r != utf8::RuneError)
            {
                if(len(chars) == size)
                {
                    if(chars == string(r))
                    {
                        return i;
                    }
                    continue;
                }
                if(bytealg::MaxLen >= size)
                {
                    if(bytealg::IndexString(chars, string(r)) >= 0)
                    {
                        return i;
                    }
                    continue;
                }
            }
            for(auto [gocpp_ignored, ch] : chars)
            {
                if(r == ch)
                {
                    return i;
                }
            }
        }
        return - 1;
    }

    gocpp::slice<gocpp::slice<unsigned char>> genSplit(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep, int sepSave, int n)
    {
        if(n == 0)
        {
            return nullptr;
        }
        if(len(sep) == 0)
        {
            return explode(s, n);
        }
        if(n < 0)
        {
            n = Count(s, sep) + 1;
        }
        if(n > len(s) + 1)
        {
            n = len(s) + 1;
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), n);
        n--;
        auto i = 0;
        for(; i < n; )
        {
            auto m = Index(s, sep);
            if(m < 0)
            {
                break;
            }
            a[i] = s.make_slice(, m + sepSave, m + sepSave);
            s = s.make_slice(m + len(sep));
            i++;
        }
        a[i] = s;
        return a.make_slice(0, i + 1);
    }

    gocpp::slice<gocpp::slice<unsigned char>> SplitN(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep, int n)
    {
        return genSplit(s, sep, 0, n);
    }

    gocpp::slice<gocpp::slice<unsigned char>> SplitAfterN(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep, int n)
    {
        return genSplit(s, sep, len(sep), n);
    }

    gocpp::slice<gocpp::slice<unsigned char>> Split(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        return genSplit(s, sep, 0, - 1);
    }

    gocpp::slice<gocpp::slice<unsigned char>> SplitAfter(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        return genSplit(s, sep, len(sep), - 1);
    }

    gocpp::array<uint8_t, 256> asciiSpace = gocpp::Init<gocpp::array<uint8_t, 256>>([](gocpp::array<uint8_t, 256>& x) { x.'\t' = 1; x.'\n' = 1; x.'\v' = 1; x.'\f' = 1; x.'\r' = 1; x.' ' = 1; });
    gocpp::slice<gocpp::slice<unsigned char>> Fields(gocpp::slice<unsigned char> s)
    {
        auto n = 0;
        auto wasSpace = 1;
        auto setBits = uint8_t(0);
        for(auto i = 0; i < len(s); i++)
        {
            auto r = s[i];
            setBits |= r;
            auto isSpace = int(asciiSpace[r]);
            n += wasSpace & ~ isSpace;
            wasSpace = isSpace;
        }
        if(setBits >= utf8::RuneSelf)
        {
            return FieldsFunc(s, unicode::IsSpace);
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), n);
        auto na = 0;
        auto fieldStart = 0;
        auto i = 0;
        for(; i < len(s) && asciiSpace[s[i]] != 0; )
        {
            i++;
        }
        fieldStart = i;
        for(; i < len(s); )
        {
            if(asciiSpace[s[i]] == 0)
            {
                i++;
                continue;
            }
            a[na] = s.make_slice(fieldStart, i, i);
            na++;
            i++;
            for(; i < len(s) && asciiSpace[s[i]] != 0; )
            {
                i++;
            }
            fieldStart = i;
        }
        if(fieldStart < len(s))
        {
            a[na] = s.make_slice(fieldStart, len(s), len(s));
        }
        return a;
    }

    gocpp::slice<gocpp::slice<unsigned char>> FieldsFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune)> f)
    {
        
        template<typename T> requires gocpp::GoStruct<T>
        span::operator T()
        {
            T result;
            result.start = this->start;
            result.end = this->end;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool span::operator==(const T& ref) const
        {
            if (start != ref.start) return false;
            if (end != ref.end) return false;
            return true;
        }

        std::ostream& span::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << start;
            os << " " << end;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct span& value)
        {
            return value.PrintTo(os);
        }

        auto spans = gocpp::make(gocpp::Tag<gocpp::slice<span>>(), 0, 32);
        auto start = - 1;
        for(auto i = 0; i < len(s); )
        {
            auto size = 1;
            auto r = rune(s[i]);
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, size) = utf8::DecodeRune(s.make_slice(i));
            }
            if(f(r))
            {
                if(start >= 0)
                {
                    spans = append(spans, span {start, i});
                    start = - 1;
                }
            }
            else
            {
                if(start < 0)
                {
                    start = i;
                }
            }
            i += size;
        }
        if(start >= 0)
        {
            spans = append(spans, span {start, len(s)});
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), len(spans));
        for(auto [i, span] : spans)
        {
            a[i] = s.make_slice(span.start, span.end, span.end);
        }
        return a;
    }

    gocpp::slice<unsigned char> Join(gocpp::slice<gocpp::slice<unsigned char>> s, gocpp::slice<unsigned char> sep)
    {
        if(len(s) == 0)
        {
            return gocpp::slice<unsigned char> {};
        }
        if(len(s) == 1)
        {
            return append(gocpp::Tag<gocpp::slice<unsigned char>>()(nullptr), s[0]);
        }
        int n = {};
        if(len(sep) > 0)
        {
            if(len(sep) >= maxInt / (len(s) - 1))
            {
                gocpp::panic("bytes: Join output length overflow");
            }
            n += len(sep) * (len(s) - 1);
        }
        for(auto [gocpp_ignored, v] : s)
        {
            if(len(v) > maxInt - n)
            {
                gocpp::panic("bytes: Join output length overflow");
            }
            n += len(v);
        }
        auto b = bytealg::MakeNoZero(n);
        auto bp = copy(b, s[0]);
        for(auto [gocpp_ignored, v] : s.make_slice(1))
        {
            bp += copy(b.make_slice(bp), sep);
            bp += copy(b.make_slice(bp), v);
        }
        return b;
    }

    bool HasPrefix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> prefix)
    {
        return len(s) >= len(prefix) && Equal(s.make_slice(0, len(prefix)), prefix);
    }

    bool HasSuffix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> suffix)
    {
        return len(s) >= len(suffix) && Equal(s.make_slice(len(s) - len(suffix)), suffix);
    }

    gocpp::slice<unsigned char> Map(std::function<gocpp::rune (gocpp::rune r)> mapping, gocpp::slice<unsigned char> s)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(s));
        for(auto i = 0; i < len(s); )
        {
            auto wid = 1;
            auto r = rune(s[i]);
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, wid) = utf8::DecodeRune(s.make_slice(i));
            }
            r = mapping(r);
            if(r >= 0)
            {
                b = utf8::AppendRune(b, r);
            }
            i += wid;
        }
        return b;
    }

    gocpp::slice<unsigned char> Repeat(gocpp::slice<unsigned char> b, int count)
    {
        if(count == 0)
        {
            return gocpp::slice<unsigned char> {};
        }
        if(count < 0)
        {
            gocpp::panic("bytes: negative Repeat count");
        }
        if(len(b) >= maxInt / count)
        {
            gocpp::panic("bytes: Repeat output length overflow");
        }
        auto n = len(b) * count;
        if(len(b) == 0)
        {
            return gocpp::slice<unsigned char> {};
        }
        auto chunkLimit = 8 * 1024;
        auto chunkMax = n;
        if(chunkMax > chunkLimit)
        {
            chunkMax = chunkLimit / len(b) * len(b);
            if(chunkMax == 0)
            {
                chunkMax = len(b);
            }
        }
        auto nb = bytealg::MakeNoZero(n);
        auto bp = copy(nb, b);
        for(; bp < n; )
        {
            auto chunk = bp;
            if(chunk > chunkMax)
            {
                chunk = chunkMax;
            }
            bp += copy(nb.make_slice(bp), nb.make_slice(0, chunk));
        }
        return nb;
    }

    gocpp::slice<unsigned char> ToUpper(gocpp::slice<unsigned char> s)
    {
        auto [isASCII, hasLower] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasLower = hasLower || ('a' <= c && c <= 'z');
        }
        if(isASCII)
        {
            if(! hasLower)
            {
                return append(gocpp::Tag<gocpp::slice<unsigned char>>()(""), s);
            }
            auto b = bytealg::MakeNoZero(len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('a' <= c && c <= 'z')
                {
                    c -= 'a' - 'A';
                }
                b[i] = c;
            }
            return b;
        }
        return Map(unicode::ToUpper, s);
    }

    gocpp::slice<unsigned char> ToLower(gocpp::slice<unsigned char> s)
    {
        auto [isASCII, hasUpper] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasUpper = hasUpper || ('A' <= c && c <= 'Z');
        }
        if(isASCII)
        {
            if(! hasUpper)
            {
                return append(gocpp::Tag<gocpp::slice<unsigned char>>()(""), s);
            }
            auto b = bytealg::MakeNoZero(len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('A' <= c && c <= 'Z')
                {
                    c += 'a' - 'A';
                }
                b[i] = c;
            }
            return b;
        }
        return Map(unicode::ToLower, s);
    }

    gocpp::slice<unsigned char> ToTitle(gocpp::slice<unsigned char> s)
    {
        return Map(unicode::ToTitle, s);
    }

    gocpp::slice<unsigned char> ToUpperSpecial(unicode::SpecialCase c, gocpp::slice<unsigned char> s)
    {
        return Map(c->ToUpper, s);
    }

    gocpp::slice<unsigned char> ToLowerSpecial(unicode::SpecialCase c, gocpp::slice<unsigned char> s)
    {
        return Map(c->ToLower, s);
    }

    gocpp::slice<unsigned char> ToTitleSpecial(unicode::SpecialCase c, gocpp::slice<unsigned char> s)
    {
        return Map(c->ToTitle, s);
    }

    gocpp::slice<unsigned char> ToValidUTF8(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> replacement)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(s) + len(replacement));
        auto invalid = false;
        for(auto i = 0; i < len(s); )
        {
            auto c = s[i];
            if(c < utf8::RuneSelf)
            {
                i++;
                invalid = false;
                b = append(b, c);
                continue;
            }
            auto [gocpp_id_2, wid] = utf8::DecodeRune(s.make_slice(i));
            if(wid == 1)
            {
                i++;
                if(! invalid)
                {
                    invalid = true;
                    b = append(b, replacement);
                }
                continue;
            }
            invalid = false;
            b = append(b, s.make_slice(i, i + wid));
            i += wid;
        }
        return b;
    }

    bool isSeparator(gocpp::rune r)
    {
        if(r <= 0x7F)
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if('0' <= r && r <= '9') { conditionId = 0; }
                else if('a' <= r && r <= 'z') { conditionId = 1; }
                else if('A' <= r && r <= 'Z') { conditionId = 2; }
                else if(r == '_') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        return false;
                        break;
                    case 1:
                        return false;
                        break;
                    case 2:
                        return false;
                        break;
                    case 3:
                        return false;
                        break;
                }
            }
            return true;
        }
        if(unicode::IsLetter(r) || unicode::IsDigit(r))
        {
            return false;
        }
        return unicode::IsSpace(r);
    }

    gocpp::slice<unsigned char> Title(gocpp::slice<unsigned char> s)
    {
        auto prev = ' ';
        return Map([=](gocpp::rune r) mutable -> gocpp::rune
        {
            if(isSeparator(prev))
            {
                prev = r;
                return unicode::ToTitle(r);
            }
            prev = r;
            return r;
        }, s);
    }

    gocpp::slice<unsigned char> TrimLeftFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        auto i = indexFunc(s, f, false);
        if(i == - 1)
        {
            return nullptr;
        }
        return s.make_slice(i);
    }

    gocpp::slice<unsigned char> TrimRightFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        auto i = lastIndexFunc(s, f, false);
        if(i >= 0 && s[i] >= utf8::RuneSelf)
        {
            auto [gocpp_id_4, wid] = utf8::DecodeRune(s.make_slice(i));
            i += wid;
        }
        else
        {
            i++;
        }
        return s.make_slice(0, i);
    }

    gocpp::slice<unsigned char> TrimFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        return TrimRightFunc(TrimLeftFunc(s, f), f);
    }

    gocpp::slice<unsigned char> TrimPrefix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> prefix)
    {
        if(HasPrefix(s, prefix))
        {
            return s.make_slice(len(prefix));
        }
        return s;
    }

    gocpp::slice<unsigned char> TrimSuffix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> suffix)
    {
        if(HasSuffix(s, suffix))
        {
            return s.make_slice(0, len(s) - len(suffix));
        }
        return s;
    }

    int IndexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        return indexFunc(s, f, true);
    }

    int LastIndexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        return lastIndexFunc(s, f, true);
    }

    int indexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f, bool truth)
    {
        auto start = 0;
        for(; start < len(s); )
        {
            auto wid = 1;
            auto r = rune(s[start]);
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, wid) = utf8::DecodeRune(s.make_slice(start));
            }
            if(f(r) == truth)
            {
                return start;
            }
            start += wid;
        }
        return - 1;
    }

    int lastIndexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f, bool truth)
    {
        for(auto i = len(s); i > 0; )
        {
            auto [r, size] = std::tuple{rune(s[i - 1]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, size) = utf8::DecodeLastRune(s.make_slice(0, i));
            }
            i -= size;
            if(f(r) == truth)
            {
                return i;
            }
        }
        return - 1;
    }

    std::tuple<asciiSet, bool> makeASCIISet(std::string chars)
    {
        asciiSet as;
        bool ok;
        for(auto i = 0; i < len(chars); i++)
        {
            asciiSet as;
            bool ok;
            auto c = chars[i];
            if(c >= utf8::RuneSelf)
            {
                asciiSet as;
                bool ok;
                return {as, false};
            }
            as[c / 32] |= 1 << (c % 32);
        }
        return {as, true};
    }

    bool rec::contains(asciiSet* as, unsigned char c)
    {
        return (as[c / 32] & (1 << (c % 32))) != 0;
    }

    bool containsRune(std::string s, gocpp::rune r)
    {
        for(auto [gocpp_ignored, c] : s)
        {
            if(c == r)
            {
                return true;
            }
        }
        return false;
    }

    gocpp::slice<unsigned char> Trim(gocpp::slice<unsigned char> s, std::string cutset)
    {
        if(len(s) == 0)
        {
            return nullptr;
        }
        if(cutset == "")
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(trimRightByte(s, cutset[0]), cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(trimRightASCII(s, & as), & as);
        }
        return trimLeftUnicode(trimRightUnicode(s, cutset), cutset);
    }

    gocpp::slice<unsigned char> TrimLeft(gocpp::slice<unsigned char> s, std::string cutset)
    {
        if(len(s) == 0)
        {
            return nullptr;
        }
        if(cutset == "")
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(s, & as);
        }
        return trimLeftUnicode(s, cutset);
    }

    gocpp::slice<unsigned char> trimLeftByte(gocpp::slice<unsigned char> s, unsigned char c)
    {
        for(; len(s) > 0 && s[0] == c; )
        {
            s = s.make_slice(1);
        }
        if(len(s) == 0)
        {
            return nullptr;
        }
        return s;
    }

    gocpp::slice<unsigned char> trimLeftASCII(gocpp::slice<unsigned char> s, asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[0]))
            {
                break;
            }
            s = s.make_slice(1);
        }
        if(len(s) == 0)
        {
            return nullptr;
        }
        return s;
    }

    gocpp::slice<unsigned char> trimLeftUnicode(gocpp::slice<unsigned char> s, std::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{rune(s[0]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeRune(s);
            }
            if(! containsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(n);
        }
        if(len(s) == 0)
        {
            return nullptr;
        }
        return s;
    }

    gocpp::slice<unsigned char> TrimRight(gocpp::slice<unsigned char> s, std::string cutset)
    {
        if(len(s) == 0 || cutset == "")
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimRightByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimRightASCII(s, & as);
        }
        return trimRightUnicode(s, cutset);
    }

    gocpp::slice<unsigned char> trimRightByte(gocpp::slice<unsigned char> s, unsigned char c)
    {
        for(; len(s) > 0 && s[len(s) - 1] == c; )
        {
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    gocpp::slice<unsigned char> trimRightASCII(gocpp::slice<unsigned char> s, asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[len(s) - 1]))
            {
                break;
            }
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    gocpp::slice<unsigned char> trimRightUnicode(gocpp::slice<unsigned char> s, std::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{rune(s[len(s) - 1]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeLastRune(s);
            }
            if(! containsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(0, len(s) - n);
        }
        return s;
    }

    gocpp::slice<unsigned char> TrimSpace(gocpp::slice<unsigned char> s)
    {
        auto start = 0;
        for(; start < len(s); start++)
        {
            auto c = s[start];
            if(c >= utf8::RuneSelf)
            {
                return TrimFunc(s.make_slice(start), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        auto stop = len(s);
        for(; stop > start; stop--)
        {
            auto c = s[stop - 1];
            if(c >= utf8::RuneSelf)
            {
                return TrimFunc(s.make_slice(start, stop), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        if(start == stop)
        {
            return nullptr;
        }
        return s.make_slice(start, stop);
    }

    gocpp::slice<gocpp::rune> Runes(gocpp::slice<unsigned char> s)
    {
        auto t = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::rune>>(), utf8::RuneCount(s));
        auto i = 0;
        for(; len(s) > 0; )
        {
            auto [r, l] = utf8::DecodeRune(s);
            t[i] = r;
            i++;
            s = s.make_slice(l);
        }
        return t;
    }

    gocpp::slice<unsigned char> Replace(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> old, gocpp::slice<unsigned char> go_new, int n)
    {
        auto m = 0;
        if(n != 0)
        {
            m = Count(s, old);
        }
        if(m == 0)
        {
            return append(gocpp::Tag<gocpp::slice<unsigned char>>()(nullptr), s);
        }
        if(n < 0 || m < n)
        {
            n = m;
        }
        auto t = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(s) + n * (len(go_new) - len(old)));
        auto w = 0;
        auto start = 0;
        for(auto i = 0; i < n; i++)
        {
            auto j = start;
            if(len(old) == 0)
            {
                if(i > 0)
                {
                    auto [gocpp_id_6, wid] = utf8::DecodeRune(s.make_slice(start));
                    j += wid;
                }
            }
            else
            {
                j += Index(s.make_slice(start), old);
            }
            w += copy(t.make_slice(w), s.make_slice(start, j));
            w += copy(t.make_slice(w), go_new);
            start = j + len(old);
        }
        w += copy(t.make_slice(w), s.make_slice(start));
        return t.make_slice(0, w);
    }

    gocpp::slice<unsigned char> ReplaceAll(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> old, gocpp::slice<unsigned char> go_new)
    {
        return Replace(s, old, go_new, - 1);
    }

    bool EqualFold(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> t)
    {
        auto i = 0;
        for(; i < len(s) && i < len(t); i++)
        {
            auto sr = s[i];
            auto tr = t[i];
            if(sr | tr >= utf8::RuneSelf)
            {
                goto hasUnicode;
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
            {
                continue;
            }
            return false;
        }
        return len(s) == len(t);
        hasUnicode:
        s = s.make_slice(i);
        t = t.make_slice(i);
        for(; len(s) != 0 && len(t) != 0; )
        {
            gocpp::rune sr = {};
            gocpp::rune tr = {};
            if(s[0] < utf8::RuneSelf)
            {
                std::tie(sr, s) = std::tuple{rune(s[0]), s.make_slice(1)};
            }
            else
            {
                auto [r, size] = utf8::DecodeRune(s);
                std::tie(sr, s) = std::tuple{r, s.make_slice(size)};
            }
            if(t[0] < utf8::RuneSelf)
            {
                std::tie(tr, t) = std::tuple{rune(t[0]), t.make_slice(1)};
            }
            else
            {
                auto [r, size] = utf8::DecodeRune(t);
                std::tie(tr, t) = std::tuple{r, t.make_slice(size)};
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if(tr < utf8::RuneSelf)
            {
                if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
                {
                    continue;
                }
                return false;
            }
            auto r = unicode::SimpleFold(sr);
            for(; r != sr && r < tr; )
            {
                r = unicode::SimpleFold(r);
            }
            if(r == tr)
            {
                continue;
            }
            return false;
        }
        return len(s) == len(t);
    }

    int Index(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        auto n = len(sep);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            else if(n <= bytealg::MaxLen) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    return 0;
                    break;
                case 1:
                    return IndexByte(s, sep[0]);
                    break;
                case 2:
                    if(Equal(sep, s))
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
                case 4:
                    if(len(s) <= bytealg::MaxBruteForce)
                    {
                        return bytealg::Index(s, sep);
                    }
                    auto c0 = sep[0];
                    auto c1 = sep[1];
                    auto i = 0;
                    auto t = len(s) - n + 1;
                    auto fails = 0;
                    for(; i < t; )
                    {
                        if(s[i] != c0)
                        {
                            auto o = IndexByte(s.make_slice(i + 1, t), c0);
                            if(o < 0)
                            {
                                return - 1;
                            }
                            i += o + 1;
                        }
                        if(s[i + 1] == c1 && Equal(s.make_slice(i, i + n), sep))
                        {
                            return i;
                        }
                        fails++;
                        i++;
                        if(fails > bytealg::Cutover(i))
                        {
                            auto r = bytealg::Index(s.make_slice(i), sep);
                            if(r >= 0)
                            {
                                return r + i;
                            }
                            return - 1;
                        }
                    }
                    return - 1;
                    break;
            }
        }
        auto c0 = sep[0];
        auto c1 = sep[1];
        auto i = 0;
        auto fails = 0;
        auto t = len(s) - n + 1;
        for(; i < t; )
        {
            if(s[i] != c0)
            {
                auto o = IndexByte(s.make_slice(i + 1, t), c0);
                if(o < 0)
                {
                    break;
                }
                i += o + 1;
            }
            if(s[i + 1] == c1 && Equal(s.make_slice(i, i + n), sep))
            {
                return i;
            }
            i++;
            fails++;
            if(fails >= 4 + (i >> 4) && i < t)
            {
                auto j = bytealg::IndexRabinKarp(s.make_slice(i), sep);
                if(j < 0)
                {
                    return - 1;
                }
                return i + j;
            }
        }
        return - 1;
    }

    std::tuple<gocpp::slice<unsigned char>, gocpp::slice<unsigned char>, bool> Cut(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        gocpp::slice<unsigned char> before;
        gocpp::slice<unsigned char> after;
        bool found;
        if(auto i = Index(s, sep); i >= 0)
        {
            gocpp::slice<unsigned char> before;
            gocpp::slice<unsigned char> after;
            bool found;
            return {s.make_slice(0, i), s.make_slice(i + len(sep)), true};
        }
        return {s, nullptr, false};
    }

    gocpp::slice<unsigned char> Clone(gocpp::slice<unsigned char> b)
    {
        if(b == nullptr)
        {
            return nullptr;
        }
        return append(gocpp::slice<unsigned char> {}, b);
    }

    std::tuple<gocpp::slice<unsigned char>, bool> CutPrefix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> prefix)
    {
        gocpp::slice<unsigned char> after;
        bool found;
        if(! HasPrefix(s, prefix))
        {
            gocpp::slice<unsigned char> after;
            bool found;
            return {s, false};
        }
        return {s.make_slice(len(prefix)), true};
    }

    std::tuple<gocpp::slice<unsigned char>, bool> CutSuffix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> suffix)
    {
        gocpp::slice<unsigned char> before;
        bool found;
        if(! HasSuffix(s, suffix))
        {
            gocpp::slice<unsigned char> before;
            bool found;
            return {s, false};
        }
        return {s.make_slice(0, len(s) - len(suffix)), true};
    }

}

