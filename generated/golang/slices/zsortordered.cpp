// generated by GoCpp from file '$(ImportDir)/slices/zsortordered.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/slices/zsortordered.h"
#include "gocpp/support.h"

// #include "golang/cmp/cmp.h"  [Ignored, known errors]
// #include "golang/slices/sort.h"  [Ignored, known errors]

namespace golang::slices
{
    void insertionSortOrdered(gocpp::slice<E> data, int a, int b)
    {
        for(auto i = a + 1; i < b; i++)
        {
            for(auto j = i; j > a && cmp::Less(data[j], data[j - 1]); j--)
            {
                std::tie(data[j], data[j - 1]) = std::tuple{data[j - 1], data[j]};
            }
        }
    }

    void siftDownOrdered(gocpp::slice<E> data, int lo, int hi, int first)
    {
        auto root = lo;
        for(; ; )
        {
            auto child = 2 * root + 1;
            if(child >= hi)
            {
                break;
            }
            if(child + 1 < hi && cmp::Less(data[first + child], data[first + child + 1]))
            {
                child++;
            }
            if(! cmp::Less(data[first + root], data[first + child]))
            {
                return;
            }
            std::tie(data[first + root], data[first + child]) = std::tuple{data[first + child], data[first + root]};
            root = child;
        }
    }

    void heapSortOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto first = a;
        auto lo = 0;
        auto hi = b - a;
        for(auto i = (hi - 1) / 2; i >= 0; i--)
        {
            siftDownOrdered(data, i, hi, first);
        }
        for(auto i = hi - 1; i >= 0; i--)
        {
            std::tie(data[first], data[first + i]) = std::tuple{data[first + i], data[first]};
            siftDownOrdered(data, lo, i, first);
        }
    }

    void pdqsortOrdered(gocpp::slice<E> data, int a, int b, int limit)
    {
        auto maxInsertion = 12;
        auto wasBalanced = true;
        auto wasPartitioned = true;
        for(; ; )
        {
            auto length = b - a;
            if(length <= maxInsertion)
            {
                insertionSortOrdered(data, a, b);
                return;
            }
            if(limit == 0)
            {
                heapSortOrdered(data, a, b);
                return;
            }
            if(! wasBalanced)
            {
                breakPatternsOrdered(data, a, b);
                limit--;
            }
            auto [pivot, hint] = choosePivotOrdered(data, a, b);
            if(hint == decreasingHint)
            {
                reverseRangeOrdered(data, a, b);
                pivot = (b - 1) - (pivot - a);
                hint = increasingHint;
            }
            if(wasBalanced && wasPartitioned && hint == increasingHint)
            {
                if(partialInsertionSortOrdered(data, a, b))
                {
                    return;
                }
            }
            if(a > 0 && ! cmp::Less(data[a - 1], data[pivot]))
            {
                auto mid = partitionEqualOrdered(data, a, b, pivot);
                a = mid;
                continue;
            }
            auto [mid, alreadyPartitioned] = partitionOrdered(data, a, b, pivot);
            wasPartitioned = alreadyPartitioned;
            auto [leftLen, rightLen] = std::tuple{mid - a, b - mid};
            auto balanceThreshold = length / 8;
            if(leftLen < rightLen)
            {
                wasBalanced = leftLen >= balanceThreshold;
                pdqsortOrdered(data, a, mid, limit);
                a = mid + 1;
            }
            else
            {
                wasBalanced = rightLen >= balanceThreshold;
                pdqsortOrdered(data, mid + 1, b, limit);
                b = mid;
            }
        }
    }

    std::tuple<int, bool> partitionOrdered(gocpp::slice<E> data, int a, int b, int pivot)
    {
        int newpivot;
        bool alreadyPartitioned;
        std::tie(data[a], data[pivot]) = std::tuple{data[pivot], data[a]};
        auto [i, j] = std::tuple{a + 1, b - 1};
        for(; i <= j && cmp::Less(data[i], data[a]); )
        {
            int newpivot;
            bool alreadyPartitioned;
            i++;
        }
        for(; i <= j && ! cmp::Less(data[j], data[a]); )
        {
            int newpivot;
            bool alreadyPartitioned;
            j--;
        }
        if(i > j)
        {
            int newpivot;
            bool alreadyPartitioned;
            std::tie(data[j], data[a]) = std::tuple{data[a], data[j]};
            return {j, true};
        }
        std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
        i++;
        j--;
        for(; ; )
        {
            int newpivot;
            bool alreadyPartitioned;
            for(; i <= j && cmp::Less(data[i], data[a]); )
            {
                int newpivot;
                bool alreadyPartitioned;
                i++;
            }
            for(; i <= j && ! cmp::Less(data[j], data[a]); )
            {
                int newpivot;
                bool alreadyPartitioned;
                j--;
            }
            if(i > j)
            {
                int newpivot;
                bool alreadyPartitioned;
                break;
            }
            std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
            i++;
            j--;
        }
        std::tie(data[j], data[a]) = std::tuple{data[a], data[j]};
        return {j, false};
    }

    int partitionEqualOrdered(gocpp::slice<E> data, int a, int b, int pivot)
    {
        int newpivot;
        std::tie(data[a], data[pivot]) = std::tuple{data[pivot], data[a]};
        auto [i, j] = std::tuple{a + 1, b - 1};
        for(; ; )
        {
            int newpivot;
            for(; i <= j && ! cmp::Less(data[a], data[i]); )
            {
                int newpivot;
                i++;
            }
            for(; i <= j && cmp::Less(data[a], data[j]); )
            {
                int newpivot;
                j--;
            }
            if(i > j)
            {
                int newpivot;
                break;
            }
            std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
            i++;
            j--;
        }
        return i;
    }

    bool partialInsertionSortOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto maxSteps = 5;
        auto shortestShifting = 50;
        auto i = a + 1;
        for(auto j = 0; j < maxSteps; j++)
        {
            for(; i < b && ! cmp::Less(data[i], data[i - 1]); )
            {
                i++;
            }
            if(i == b)
            {
                return true;
            }
            if(b - a < shortestShifting)
            {
                return false;
            }
            std::tie(data[i], data[i - 1]) = std::tuple{data[i - 1], data[i]};
            if(i - a >= 2)
            {
                for(auto j = i - 1; j >= 1; j--)
                {
                    if(! cmp::Less(data[j], data[j - 1]))
                    {
                        break;
                    }
                    std::tie(data[j], data[j - 1]) = std::tuple{data[j - 1], data[j]};
                }
            }
            if(b - i >= 2)
            {
                for(auto j = i + 1; j < b; j++)
                {
                    if(! cmp::Less(data[j], data[j - 1]))
                    {
                        break;
                    }
                    std::tie(data[j], data[j - 1]) = std::tuple{data[j - 1], data[j]};
                }
            }
        }
        return false;
    }

    void breakPatternsOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto length = b - a;
        if(length >= 8)
        {
            auto random = xorshift(length);
            auto modulus = nextPowerOfTwo(length);
            for(auto idx = a + (length / 4) * 2 - 1; idx <= a + (length / 4) * 2 + 1; idx++)
            {
                auto other = int((unsigned int)(Next(gocpp::recv(random))) & (modulus - 1));
                if(other >= length)
                {
                    other -= length;
                }
                std::tie(data[idx], data[a + other]) = std::tuple{data[a + other], data[idx]};
            }
        }
    }

    std::tuple<int, sortedHint> choosePivotOrdered(gocpp::slice<E> data, int a, int b)
    {
        int pivot;
        sortedHint hint;
        auto shortestNinther = 50;
        auto maxSwaps = 4 * 3;
        auto l = b - a;
        int swaps = {};
        auto i = a + l / 4 * 1;
        auto j = a + l / 4 * 2;
        auto k = a + l / 4 * 3;
        if(l >= 8)
        {
            int pivot;
            sortedHint hint;
            if(l >= shortestNinther)
            {
                int pivot;
                sortedHint hint;
                i = medianAdjacentOrdered(data, i, & swaps);
                j = medianAdjacentOrdered(data, j, & swaps);
                k = medianAdjacentOrdered(data, k, & swaps);
            }
            j = medianOrdered(data, i, j, k, & swaps);
        }
        //Go switch emulation
        {
            auto condition = swaps;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == maxSwaps) { conditionId = 1; }
            switch(conditionId)
            {
                int pivot;
                sortedHint hint;
                case 0:
                    return {j, increasingHint};
                    break;
                case 1:
                    return {j, decreasingHint};
                    break;
                default:
                    return {j, unknownHint};
                    break;
            }
        }
    }

    std::tuple<int, int> order2Ordered(gocpp::slice<E> data, int a, int b, int* swaps)
    {
        if(cmp::Less(data[b], data[a]))
        {
            *swaps++;
            return {b, a};
        }
        return {a, b};
    }

    int medianOrdered(gocpp::slice<E> data, int a, int b, int c, int* swaps)
    {
        std::tie(a, b) = order2Ordered(data, a, b, swaps);
        std::tie(b, c) = order2Ordered(data, b, c, swaps);
        std::tie(a, b) = order2Ordered(data, a, b, swaps);
        return b;
    }

    int medianAdjacentOrdered(gocpp::slice<E> data, int a, int* swaps)
    {
        return medianOrdered(data, a - 1, a, a + 1, swaps);
    }

    void reverseRangeOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto i = a;
        auto j = b - 1;
        for(; i < j; )
        {
            std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
            i++;
            j--;
        }
    }

    void swapRangeOrdered(gocpp::slice<E> data, int a, int b, int n)
    {
        for(auto i = 0; i < n; i++)
        {
            std::tie(data[a + i], data[b + i]) = std::tuple{data[b + i], data[a + i]};
        }
    }

    void stableOrdered(gocpp::slice<E> data, int n)
    {
        auto blockSize = 20;
        auto [a, b] = std::tuple{0, blockSize};
        for(; b <= n; )
        {
            insertionSortOrdered(data, a, b);
            a = b;
            b += blockSize;
        }
        insertionSortOrdered(data, a, n);
        for(; blockSize < n; )
        {
            std::tie(a, b) = std::tuple{0, 2 * blockSize};
            for(; b <= n; )
            {
                symMergeOrdered(data, a, a + blockSize, b);
                a = b;
                b += 2 * blockSize;
            }
            if(auto m = a + blockSize; m < n)
            {
                symMergeOrdered(data, a, m, n);
            }
            blockSize *= 2;
        }
    }

    void symMergeOrdered(gocpp::slice<E> data, int a, int m, int b)
    {
        if(m - a == 1)
        {
            auto i = m;
            auto j = b;
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(cmp::Less(data[h], data[a]))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto k = a; k < i - 1; k++)
            {
                std::tie(data[k], data[k + 1]) = std::tuple{data[k + 1], data[k]};
            }
            return;
        }
        if(b - m == 1)
        {
            auto i = a;
            auto j = m;
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(! cmp::Less(data[m], data[h]))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto k = m; k > i; k--)
            {
                std::tie(data[k], data[k - 1]) = std::tuple{data[k - 1], data[k]};
            }
            return;
        }
        auto mid = int((unsigned int)(a + b) >> 1);
        auto n = mid + m;
        int start = {};
        int r = {};
        if(m > mid)
        {
            start = n - b;
            r = mid;
        }
        else
        {
            start = a;
            r = m;
        }
        auto p = n - 1;
        for(; start < r; )
        {
            auto c = int((unsigned int)(start + r) >> 1);
            if(! cmp::Less(data[p - c], data[c]))
            {
                start = c + 1;
            }
            else
            {
                r = c;
            }
        }
        auto end = n - start;
        if(start < m && m < end)
        {
            rotateOrdered(data, start, m, end);
        }
        if(a < start && start < mid)
        {
            symMergeOrdered(data, a, start, mid);
        }
        if(mid < end && end < b)
        {
            symMergeOrdered(data, mid, end, b);
        }
    }

    void rotateOrdered(gocpp::slice<E> data, int a, int m, int b)
    {
        auto i = m - a;
        auto j = b - m;
        for(; i != j; )
        {
            if(i > j)
            {
                swapRangeOrdered(data, m - i, m, j);
                i -= j;
            }
            else
            {
                swapRangeOrdered(data, m - i, m + j - i, i);
                j -= i;
            }
        }
        swapRangeOrdered(data, m - i, m, i);
    }

}

