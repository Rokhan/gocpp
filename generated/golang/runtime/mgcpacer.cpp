// generated by GoCpp from file '$(ImportDir)/runtime/mgcpacer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcpacer.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goexperiment/exp_heapminimum512kib_off.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcsweep.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace cpu::rec;
        using namespace goexperiment::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
    }

    gcControllerState gcController;
    
    template<typename T> requires gocpp::GoStruct<T>
    gcControllerState::operator T()
    {
        T result;
        result.gcPercent = this->gcPercent;
        result.memoryLimit = this->memoryLimit;
        result.heapMinimum = this->heapMinimum;
        result.runway = this->runway;
        result.consMark = this->consMark;
        result.lastConsMark = this->lastConsMark;
        result.gcPercentHeapGoal = this->gcPercentHeapGoal;
        result.sweepDistMinTrigger = this->sweepDistMinTrigger;
        result.triggered = this->triggered;
        result.lastHeapGoal = this->lastHeapGoal;
        result.heapLive = this->heapLive;
        result.heapScan = this->heapScan;
        result.lastHeapScan = this->lastHeapScan;
        result.lastStackScan = this->lastStackScan;
        result.maxStackScan = this->maxStackScan;
        result.globalsScan = this->globalsScan;
        result.heapMarked = this->heapMarked;
        result.heapScanWork = this->heapScanWork;
        result.stackScanWork = this->stackScanWork;
        result.globalsScanWork = this->globalsScanWork;
        result.bgScanCredit = this->bgScanCredit;
        result.assistTime = this->assistTime;
        result.dedicatedMarkTime = this->dedicatedMarkTime;
        result.fractionalMarkTime = this->fractionalMarkTime;
        result.idleMarkTime = this->idleMarkTime;
        result.markStartTime = this->markStartTime;
        result.dedicatedMarkWorkersNeeded = this->dedicatedMarkWorkersNeeded;
        result.idleMarkWorkers = this->idleMarkWorkers;
        result.assistWorkPerByte = this->assistWorkPerByte;
        result.assistBytesPerWork = this->assistBytesPerWork;
        result.fractionalUtilizationGoal = this->fractionalUtilizationGoal;
        result.heapInUse = this->heapInUse;
        result.heapReleased = this->heapReleased;
        result.heapFree = this->heapFree;
        result.totalAlloc = this->totalAlloc;
        result.totalFree = this->totalFree;
        result.mappedReady = this->mappedReady;
        result.test = this->test;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcControllerState::operator==(const T& ref) const
    {
        if (gcPercent != ref.gcPercent) return false;
        if (memoryLimit != ref.memoryLimit) return false;
        if (heapMinimum != ref.heapMinimum) return false;
        if (runway != ref.runway) return false;
        if (consMark != ref.consMark) return false;
        if (lastConsMark != ref.lastConsMark) return false;
        if (gcPercentHeapGoal != ref.gcPercentHeapGoal) return false;
        if (sweepDistMinTrigger != ref.sweepDistMinTrigger) return false;
        if (triggered != ref.triggered) return false;
        if (lastHeapGoal != ref.lastHeapGoal) return false;
        if (heapLive != ref.heapLive) return false;
        if (heapScan != ref.heapScan) return false;
        if (lastHeapScan != ref.lastHeapScan) return false;
        if (lastStackScan != ref.lastStackScan) return false;
        if (maxStackScan != ref.maxStackScan) return false;
        if (globalsScan != ref.globalsScan) return false;
        if (heapMarked != ref.heapMarked) return false;
        if (heapScanWork != ref.heapScanWork) return false;
        if (stackScanWork != ref.stackScanWork) return false;
        if (globalsScanWork != ref.globalsScanWork) return false;
        if (bgScanCredit != ref.bgScanCredit) return false;
        if (assistTime != ref.assistTime) return false;
        if (dedicatedMarkTime != ref.dedicatedMarkTime) return false;
        if (fractionalMarkTime != ref.fractionalMarkTime) return false;
        if (idleMarkTime != ref.idleMarkTime) return false;
        if (markStartTime != ref.markStartTime) return false;
        if (dedicatedMarkWorkersNeeded != ref.dedicatedMarkWorkersNeeded) return false;
        if (idleMarkWorkers != ref.idleMarkWorkers) return false;
        if (assistWorkPerByte != ref.assistWorkPerByte) return false;
        if (assistBytesPerWork != ref.assistBytesPerWork) return false;
        if (fractionalUtilizationGoal != ref.fractionalUtilizationGoal) return false;
        if (heapInUse != ref.heapInUse) return false;
        if (heapReleased != ref.heapReleased) return false;
        if (heapFree != ref.heapFree) return false;
        if (totalAlloc != ref.totalAlloc) return false;
        if (totalFree != ref.totalFree) return false;
        if (mappedReady != ref.mappedReady) return false;
        if (test != ref.test) return false;
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& gcControllerState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << gcPercent;
        os << " " << memoryLimit;
        os << " " << heapMinimum;
        os << " " << runway;
        os << " " << consMark;
        os << " " << lastConsMark;
        os << " " << gcPercentHeapGoal;
        os << " " << sweepDistMinTrigger;
        os << " " << triggered;
        os << " " << lastHeapGoal;
        os << " " << heapLive;
        os << " " << heapScan;
        os << " " << lastHeapScan;
        os << " " << lastStackScan;
        os << " " << maxStackScan;
        os << " " << globalsScan;
        os << " " << heapMarked;
        os << " " << heapScanWork;
        os << " " << stackScanWork;
        os << " " << globalsScanWork;
        os << " " << bgScanCredit;
        os << " " << assistTime;
        os << " " << dedicatedMarkTime;
        os << " " << fractionalMarkTime;
        os << " " << idleMarkTime;
        os << " " << markStartTime;
        os << " " << dedicatedMarkWorkersNeeded;
        os << " " << idleMarkWorkers;
        os << " " << assistWorkPerByte;
        os << " " << assistBytesPerWork;
        os << " " << fractionalUtilizationGoal;
        os << " " << heapInUse;
        os << " " << heapReleased;
        os << " " << heapFree;
        os << " " << totalAlloc;
        os << " " << totalFree;
        os << " " << mappedReady;
        os << " " << test;
        os << " " << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcControllerState& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct gcControllerState* c, int32_t gcPercent, int64_t memoryLimit)
    {
        c->heapMinimum = defaultHeapMinimum;
        c->triggered = ~ uint64_t(0);
        rec::setGCPercent(gocpp::recv(c), gcPercent);
        rec::setMemoryLimit(gocpp::recv(c), memoryLimit);
        rec::commit(gocpp::recv(c), true);
    }

    void rec::startCycle(struct gcControllerState* c, int64_t markStartTime, int procs, struct gcTrigger trigger)
    {
        rec::Store(gocpp::recv(c->heapScanWork), 0);
        rec::Store(gocpp::recv(c->stackScanWork), 0);
        rec::Store(gocpp::recv(c->globalsScanWork), 0);
        rec::Store(gocpp::recv(c->bgScanCredit), 0);
        rec::Store(gocpp::recv(c->assistTime), 0);
        rec::Store(gocpp::recv(c->dedicatedMarkTime), 0);
        rec::Store(gocpp::recv(c->fractionalMarkTime), 0);
        rec::Store(gocpp::recv(c->idleMarkTime), 0);
        c->markStartTime = markStartTime;
        c->triggered = rec::Load(gocpp::recv(c->heapLive));
        auto totalUtilizationGoal = double(procs) * gcBackgroundUtilization;
        auto dedicatedMarkWorkersNeeded = int64_t(totalUtilizationGoal + 0.5);
        auto utilError = double(dedicatedMarkWorkersNeeded) / totalUtilizationGoal - 1;
        auto maxUtilError = 0.3;
        if(utilError < - maxUtilError || utilError > maxUtilError)
        {
            if(double(dedicatedMarkWorkersNeeded) > totalUtilizationGoal)
            {
                dedicatedMarkWorkersNeeded--;
            }
            c->fractionalUtilizationGoal = (totalUtilizationGoal - double(dedicatedMarkWorkersNeeded)) / double(procs);
        }
        else
        {
            c->fractionalUtilizationGoal = 0;
        }
        if(debug.gcstoptheworld > 0)
        {
            dedicatedMarkWorkersNeeded = int64_t(procs);
            c->fractionalUtilizationGoal = 0;
        }
        for(auto [gocpp_ignored, p] : allp)
        {
            p->gcAssistTime = 0;
            p->gcFractionalMarkTime = 0;
        }
        if(trigger.kind == gcTriggerTime)
        {
            if(dedicatedMarkWorkersNeeded > 0)
            {
                rec::setMaxIdleMarkWorkers(gocpp::recv(c), 0);
            }
            else
            {
                rec::setMaxIdleMarkWorkers(gocpp::recv(c), 1);
            }
        }
        else
        {
            rec::setMaxIdleMarkWorkers(gocpp::recv(c), int32_t(procs) - int32_t(dedicatedMarkWorkersNeeded));
        }
        rec::Store(gocpp::recv(c->dedicatedMarkWorkersNeeded), dedicatedMarkWorkersNeeded);
        rec::revise(gocpp::recv(c));
        if(debug.gcpacertrace > 0)
        {
            auto heapGoal = rec::heapGoal(gocpp::recv(c));
            auto assistRatio = rec::Load(gocpp::recv(c->assistWorkPerByte));
            print("pacer: assist ratio=", assistRatio, " (scan ", rec::Load(gocpp::recv(gcController.heapScan)) >> 20, " MB in ", work.initialHeapLive >> 20, "->", heapGoal >> 20, " MB)", " workers=", dedicatedMarkWorkersNeeded, "+", c->fractionalUtilizationGoal, "\n");
        }
    }

    void rec::revise(struct gcControllerState* c)
    {
        auto gcPercent = rec::Load(gocpp::recv(c->gcPercent));
        if(gcPercent < 0)
        {
            gcPercent = 100000;
        }
        auto live = rec::Load(gocpp::recv(c->heapLive));
        auto scan = rec::Load(gocpp::recv(c->heapScan));
        auto work = rec::Load(gocpp::recv(c->heapScanWork)) + rec::Load(gocpp::recv(c->stackScanWork)) + rec::Load(gocpp::recv(c->globalsScanWork));
        auto heapGoal = int64_t(rec::heapGoal(gocpp::recv(c)));
        auto scanWorkExpected = int64_t(c->lastHeapScan + rec::Load(gocpp::recv(c->lastStackScan)) + rec::Load(gocpp::recv(c->globalsScan)));
        auto maxStackScan = rec::Load(gocpp::recv(c->maxStackScan));
        auto maxScanWork = int64_t(scan + maxStackScan + rec::Load(gocpp::recv(c->globalsScan)));
        if(work > scanWorkExpected)
        {
            auto extHeapGoal = int64_t(double(heapGoal - int64_t(c->triggered)) / double(scanWorkExpected) * double(maxScanWork)) + int64_t(c->triggered);
            scanWorkExpected = maxScanWork;
            auto hardGoal = int64_t((1.0 + double(gcPercent) / 100.0) * double(heapGoal));
            if(extHeapGoal > hardGoal)
            {
                extHeapGoal = hardGoal;
            }
            heapGoal = extHeapGoal;
        }
        if(int64_t(live) > heapGoal)
        {
            auto maxOvershoot = 1.1;
            heapGoal = int64_t(double(heapGoal) * maxOvershoot);
            scanWorkExpected = maxScanWork;
        }
        auto scanWorkRemaining = scanWorkExpected - work;
        if(scanWorkRemaining < 1000)
        {
            scanWorkRemaining = 1000;
        }
        auto heapRemaining = heapGoal - int64_t(live);
        if(heapRemaining <= 0)
        {
            heapRemaining = 1;
        }
        auto assistWorkPerByte = double(scanWorkRemaining) / double(heapRemaining);
        auto assistBytesPerWork = double(heapRemaining) / double(scanWorkRemaining);
        rec::Store(gocpp::recv(c->assistWorkPerByte), assistWorkPerByte);
        rec::Store(gocpp::recv(c->assistBytesPerWork), assistBytesPerWork);
    }

    void rec::endCycle(struct gcControllerState* c, int64_t now, int procs, bool userForced)
    {
        gcController.lastHeapGoal = rec::heapGoal(gocpp::recv(c));
        auto assistDuration = now - c->markStartTime;
        auto utilization = gcBackgroundUtilization;
        if(assistDuration > 0)
        {
            utilization += double(rec::Load(gocpp::recv(c->assistTime))) / double(assistDuration * int64_t(procs));
        }
        if(rec::Load(gocpp::recv(c->heapLive)) <= c->triggered)
        {
            return;
        }
        auto idleUtilization = 0.0;
        if(assistDuration > 0)
        {
            idleUtilization = double(rec::Load(gocpp::recv(c->idleMarkTime))) / double(assistDuration * int64_t(procs));
        }
        auto scanWork = rec::Load(gocpp::recv(c->heapScanWork)) + rec::Load(gocpp::recv(c->stackScanWork)) + rec::Load(gocpp::recv(c->globalsScanWork));
        auto currentConsMark = (double(rec::Load(gocpp::recv(c->heapLive)) - c->triggered) * (utilization + idleUtilization)) / (double(scanWork) * (1 - utilization));
        auto oldConsMark = c->consMark;
        c->consMark = currentConsMark;
        for(auto [i, gocpp_ignored] : c->lastConsMark)
        {
            if(c->lastConsMark[i] > c->consMark)
            {
                c->consMark = c->lastConsMark[i];
            }
        }
        copy(c->lastConsMark.make_slice(0), c->lastConsMark.make_slice(1));
        c->lastConsMark[len(c->lastConsMark) - 1] = currentConsMark;
        if(debug.gcpacertrace > 0)
        {
            printlock();
            auto goal = gcGoalUtilization * 100;
            print("pacer: ", int(utilization * 100), "% CPU (", int(goal), " exp.) for ");
            print(rec::Load(gocpp::recv(c->heapScanWork)), "+", rec::Load(gocpp::recv(c->stackScanWork)), "+", rec::Load(gocpp::recv(c->globalsScanWork)), " B work (", c->lastHeapScan + rec::Load(gocpp::recv(c->lastStackScan)) + rec::Load(gocpp::recv(c->globalsScan)), " B exp.) ");
            auto live = rec::Load(gocpp::recv(c->heapLive));
            print("in ", c->triggered, " B -> ", live, " B (∆goal ", int64_t(live) - int64_t(c->lastHeapGoal), ", cons/mark ", oldConsMark, ")");
            println();
            printunlock();
        }
    }

    void rec::enlistWorker(struct gcControllerState* c)
    {
        if(rec::Load(gocpp::recv(c->dedicatedMarkWorkersNeeded)) <= 0)
        {
            return;
        }
        if(gomaxprocs <= 1)
        {
            return;
        }
        auto gp = getg();
        if(gp == nullptr || gp->m == nullptr || gp->m->p == 0)
        {
            return;
        }
        auto myID = rec::ptr(gocpp::recv(gp->m->p))->id;
        for(auto tries = 0; tries < 5; tries++)
        {
            auto id = int32_t(cheaprandn(uint32_t(gomaxprocs - 1)));
            if(id >= myID)
            {
                id++;
            }
            auto p = allp[id];
            if(p->status != _Prunning)
            {
                continue;
            }
            if(preemptone(p))
            {
                return;
            }
        }
    }

    std::tuple<struct g*, int64_t> rec::findRunnableGCWorker(struct gcControllerState* c, struct p* pp, int64_t now)
    {
        if(gcBlackenEnabled == 0)
        {
            go_throw("gcControllerState.findRunnable: blackening not enabled");
        }
        if(now == 0)
        {
            now = nanotime();
        }
        if(rec::needUpdate(gocpp::recv(gcCPULimiter), now))
        {
            rec::update(gocpp::recv(gcCPULimiter), now);
        }
        if(! gcMarkWorkAvailable(pp))
        {
            return {nullptr, now};
        }
        auto node = (gcBgMarkWorkerNode*)(rec::pop(gocpp::recv(gcBgMarkWorkerPool)));
        if(node == nullptr)
        {
            return {nullptr, now};
        }
        auto decIfPositive = [=](atomic::Int64* val) mutable -> bool
        {
            for(; ; )
            {
                auto v = rec::Load(gocpp::recv(val));
                if(v <= 0)
                {
                    return false;
                }
                if(rec::CompareAndSwap(gocpp::recv(val), v, v - 1))
                {
                    return true;
                }
            }
        };
        if(decIfPositive(& c->dedicatedMarkWorkersNeeded))
        {
            pp->gcMarkWorkerMode = gcMarkWorkerDedicatedMode;
        }
        else
        if(c->fractionalUtilizationGoal == 0)
        {
            rec::push(gocpp::recv(gcBgMarkWorkerPool), & node->node);
            return {nullptr, now};
        }
        else
        {
            auto delta = now - c->markStartTime;
            if(delta > 0 && double(pp->gcFractionalMarkTime) / double(delta) > c->fractionalUtilizationGoal)
            {
                rec::push(gocpp::recv(gcBgMarkWorkerPool), & node->node);
                return {nullptr, now};
            }
            pp->gcMarkWorkerMode = gcMarkWorkerFractionalMode;
        }
        auto gp = rec::ptr(gocpp::recv(node->gp));
        auto trace = traceAcquire();
        casgstatus(gp, _Gwaiting, _Grunnable);
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoUnpark(gocpp::recv(trace), gp, 0);
            traceRelease(trace);
        }
        return {gp, now};
    }

    void rec::resetLive(struct gcControllerState* c, uint64_t bytesMarked)
    {
        c->heapMarked = bytesMarked;
        rec::Store(gocpp::recv(c->heapLive), bytesMarked);
        rec::Store(gocpp::recv(c->heapScan), uint64_t(rec::Load(gocpp::recv(c->heapScanWork))));
        c->lastHeapScan = uint64_t(rec::Load(gocpp::recv(c->heapScanWork)));
        rec::Store(gocpp::recv(c->lastStackScan), uint64_t(rec::Load(gocpp::recv(c->stackScanWork))));
        c->triggered = ~ uint64_t(0);
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::HeapAlloc(gocpp::recv(trace), bytesMarked);
            traceRelease(trace);
        }
    }

    void rec::markWorkerStop(struct gcControllerState* c, golang::runtime::gcMarkWorkerMode mode, int64_t duration)
    {
        //Go switch emulation
        {
            auto condition = mode;
            int conditionId = -1;
            if(condition == gcMarkWorkerDedicatedMode) { conditionId = 0; }
            else if(condition == gcMarkWorkerFractionalMode) { conditionId = 1; }
            else if(condition == gcMarkWorkerIdleMode) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    rec::Add(gocpp::recv(c->dedicatedMarkTime), duration);
                    rec::Add(gocpp::recv(c->dedicatedMarkWorkersNeeded), 1);
                    break;
                case 1:
                    rec::Add(gocpp::recv(c->fractionalMarkTime), duration);
                    break;
                case 2:
                    rec::Add(gocpp::recv(c->idleMarkTime), duration);
                    rec::removeIdleMarkWorker(gocpp::recv(c));
                    break;
                default:
                    go_throw("markWorkerStop: unknown mark worker mode");
                    break;
            }
        }
    }

    void rec::update(struct gcControllerState* c, int64_t dHeapLive, int64_t dHeapScan)
    {
        if(dHeapLive != 0)
        {
            auto trace = traceAcquire();
            auto live = rec::Add(gocpp::recv(gcController.heapLive), dHeapLive);
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::HeapAlloc(gocpp::recv(trace), live);
                traceRelease(trace);
            }
        }
        if(gcBlackenEnabled == 0)
        {
            if(dHeapScan != 0)
            {
                rec::Add(gocpp::recv(gcController.heapScan), dHeapScan);
            }
        }
        else
        {
            rec::revise(gocpp::recv(c));
        }
    }

    void rec::addScannableStack(struct gcControllerState* c, struct p* pp, int64_t amount)
    {
        if(pp == nullptr)
        {
            rec::Add(gocpp::recv(c->maxStackScan), amount);
            return;
        }
        pp->maxStackScanDelta += amount;
        if(pp->maxStackScanDelta >= maxStackScanSlack || pp->maxStackScanDelta <= - maxStackScanSlack)
        {
            rec::Add(gocpp::recv(c->maxStackScan), pp->maxStackScanDelta);
            pp->maxStackScanDelta = 0;
        }
    }

    void rec::addGlobals(struct gcControllerState* c, int64_t amount)
    {
        rec::Add(gocpp::recv(c->globalsScan), amount);
    }

    uint64_t rec::heapGoal(struct gcControllerState* c)
    {
        auto [goal, gocpp_id_1] = rec::heapGoalInternal(gocpp::recv(c));
        return goal;
    }

    std::tuple<uint64_t, uint64_t> rec::heapGoalInternal(struct gcControllerState* c)
    {
        uint64_t goal;
        uint64_t minTrigger;
        goal = rec::Load(gocpp::recv(c->gcPercentHeapGoal));
        if(auto newGoal = rec::memoryLimitHeapGoal(gocpp::recv(c)); newGoal < goal)
        {
            uint64_t goal;
            uint64_t minTrigger;
            goal = newGoal;
        }
        else
        {
            uint64_t goal;
            uint64_t minTrigger;
            auto sweepDistTrigger = rec::Load(gocpp::recv(c->sweepDistMinTrigger));
            if(sweepDistTrigger > goal)
            {
                uint64_t goal;
                uint64_t minTrigger;
                goal = sweepDistTrigger;
            }
            minTrigger = sweepDistTrigger;
            auto minRunway = 64 << 10;
            if(c->triggered != ~ uint64_t(0) && goal < c->triggered + minRunway)
            {
                uint64_t goal;
                uint64_t minTrigger;
                goal = c->triggered + minRunway;
            }
        }
        return {goal, minTrigger};
    }

    uint64_t rec::memoryLimitHeapGoal(struct gcControllerState* c)
    {
        uint64_t heapFree = {};
        uint64_t heapAlloc = {};
        uint64_t mappedReady = {};
        for(; ; )
        {
            heapFree = rec::load(gocpp::recv(c->heapFree));
            heapAlloc = rec::Load(gocpp::recv(c->totalAlloc)) - rec::Load(gocpp::recv(c->totalFree));
            mappedReady = rec::Load(gocpp::recv(c->mappedReady));
            if(heapFree + heapAlloc <= mappedReady)
            {
                break;
            }
        }
        auto memoryLimit = uint64_t(rec::Load(gocpp::recv(c->memoryLimit)));
        auto nonHeapMemory = mappedReady - heapFree - heapAlloc;
        uint64_t overage = {};
        if(mappedReady > memoryLimit)
        {
            overage = mappedReady - memoryLimit;
        }
        if(nonHeapMemory + overage >= memoryLimit)
        {
            return c->heapMarked;
        }
        auto goal = memoryLimit - (nonHeapMemory + overage);
        auto headroom = goal / 100 * memoryLimitHeapGoalHeadroomPercent;
        if(headroom < memoryLimitMinHeapGoalHeadroom)
        {
            headroom = memoryLimitMinHeapGoalHeadroom;
        }
        if(goal < headroom || goal - headroom < headroom)
        {
            goal = headroom;
        }
        else
        {
            goal = goal - headroom;
        }
        if(goal < c->heapMarked)
        {
            goal = c->heapMarked;
        }
        return goal;
    }

    std::tuple<uint64_t, uint64_t> rec::trigger(struct gcControllerState* c)
    {
        auto [goal, minTrigger] = rec::heapGoalInternal(gocpp::recv(c));
        if(c->heapMarked >= goal)
        {
            return {goal, goal};
        }
        if(minTrigger < c->heapMarked)
        {
            minTrigger = c->heapMarked;
        }
        auto triggerLowerBound = ((goal - c->heapMarked) / triggerRatioDen) * minTriggerRatioNum + c->heapMarked;
        if(minTrigger < triggerLowerBound)
        {
            minTrigger = triggerLowerBound;
        }
        auto maxTrigger = ((goal - c->heapMarked) / triggerRatioDen) * maxTriggerRatioNum + c->heapMarked;
        if(goal > defaultHeapMinimum && goal - defaultHeapMinimum > maxTrigger)
        {
            maxTrigger = goal - defaultHeapMinimum;
        }
        maxTrigger = gocpp::max(maxTrigger, minTrigger);
        uint64_t trigger = {};
        auto runway = rec::Load(gocpp::recv(c->runway));
        if(runway > goal)
        {
            trigger = minTrigger;
        }
        else
        {
            trigger = goal - runway;
        }
        trigger = gocpp::max(trigger, minTrigger);
        trigger = gocpp::min(trigger, maxTrigger);
        if(trigger > goal)
        {
            print("trigger=", trigger, " heapGoal=", goal, "\n");
            print("minTrigger=", minTrigger, " maxTrigger=", maxTrigger, "\n");
            go_throw("produced a trigger greater than the heap goal");
        }
        return {trigger, goal};
    }

    void rec::commit(struct gcControllerState* c, bool isSweepDone)
    {
        if(! c->test)
        {
            assertWorldStoppedOrLockHeld(& mheap_.lock);
        }
        if(isSweepDone)
        {
            rec::Store(gocpp::recv(c->sweepDistMinTrigger), 0);
        }
        else
        {
            rec::Store(gocpp::recv(c->sweepDistMinTrigger), rec::Load(gocpp::recv(c->heapLive)) + sweepMinHeapDistance);
        }
        auto gcPercentHeapGoal = ~ uint64_t(0);
        if(auto gcPercent = rec::Load(gocpp::recv(c->gcPercent)); gcPercent >= 0)
        {
            gcPercentHeapGoal = c->heapMarked + (c->heapMarked + rec::Load(gocpp::recv(c->lastStackScan)) + rec::Load(gocpp::recv(c->globalsScan))) * uint64_t(gcPercent) / 100;
        }
        if(gcPercentHeapGoal < c->heapMinimum)
        {
            gcPercentHeapGoal = c->heapMinimum;
        }
        rec::Store(gocpp::recv(c->gcPercentHeapGoal), gcPercentHeapGoal);
        rec::Store(gocpp::recv(c->runway), uint64_t((c->consMark * (1 - gcGoalUtilization) / (gcGoalUtilization)) * double(c->lastHeapScan + rec::Load(gocpp::recv(c->lastStackScan)) + rec::Load(gocpp::recv(c->globalsScan)))));
    }

    int32_t rec::setGCPercent(struct gcControllerState* c, int32_t in)
    {
        if(! c->test)
        {
            assertWorldStoppedOrLockHeld(& mheap_.lock);
        }
        auto out = rec::Load(gocpp::recv(c->gcPercent));
        if(in < 0)
        {
            in = - 1;
        }
        c->heapMinimum = defaultHeapMinimum * uint64_t(in) / 100;
        rec::Store(gocpp::recv(c->gcPercent), in);
        return out;
    }

    int32_t setGCPercent(int32_t in)
    {
        int32_t out;
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            out = rec::setGCPercent(gocpp::recv(gcController), in);
            gcControllerCommit();
            unlock(& mheap_.lock);
        });
        if(in < 0)
        {
            int32_t out;
            gcWaitOnMark(rec::Load(gocpp::recv(work.cycles)));
        }
        return out;
    }

    int32_t readGOGC()
    {
        auto p = gogetenv("GOGC");
        if(p == "off")
        {
            return - 1;
        }
        if(auto [n, ok] = atoi32(p); ok)
        {
            return n;
        }
        return 100;
    }

    int64_t rec::setMemoryLimit(struct gcControllerState* c, int64_t in)
    {
        if(! c->test)
        {
            assertWorldStoppedOrLockHeld(& mheap_.lock);
        }
        auto out = rec::Load(gocpp::recv(c->memoryLimit));
        if(in >= 0)
        {
            rec::Store(gocpp::recv(c->memoryLimit), in);
        }
        return out;
    }

    int64_t setMemoryLimit(int64_t in)
    {
        int64_t out;
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            out = rec::setMemoryLimit(gocpp::recv(gcController), in);
            if(in < 0 || out == in)
            {
                unlock(& mheap_.lock);
                return;
            }
            gcControllerCommit();
            unlock(& mheap_.lock);
        });
        return out;
    }

    int64_t readGOMEMLIMIT()
    {
        auto p = gogetenv("GOMEMLIMIT");
        if(p == "" || p == "off")
        {
            return maxInt64;
        }
        auto [n, ok] = parseByteCount(p);
        if(! ok)
        {
            print("GOMEMLIMIT=", p, "\n");
            go_throw("malformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`");
        }
        return n;
    }

    bool rec::addIdleMarkWorker(struct gcControllerState* c)
    {
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(c->idleMarkWorkers));
            auto [n, max] = std::tuple{int32_t(old & uint64_t(~ uint32_t(0))), int32_t(old >> 32)};
            if(n >= max)
            {
                return false;
            }
            if(n < 0)
            {
                print("n=", n, " max=", max, "\n");
                go_throw("negative idle mark workers");
            }
            auto go_new = uint64_t(uint32_t(n + 1)) | (uint64_t(max) << 32);
            if(rec::CompareAndSwap(gocpp::recv(c->idleMarkWorkers), old, go_new))
            {
                return true;
            }
        }
    }

    bool rec::needIdleMarkWorker(struct gcControllerState* c)
    {
        auto p = rec::Load(gocpp::recv(c->idleMarkWorkers));
        auto [n, max] = std::tuple{int32_t(p & uint64_t(~ uint32_t(0))), int32_t(p >> 32)};
        return n < max;
    }

    void rec::removeIdleMarkWorker(struct gcControllerState* c)
    {
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(c->idleMarkWorkers));
            auto [n, max] = std::tuple{int32_t(old & uint64_t(~ uint32_t(0))), int32_t(old >> 32)};
            if(n - 1 < 0)
            {
                print("n=", n, " max=", max, "\n");
                go_throw("negative idle mark workers");
            }
            auto go_new = uint64_t(uint32_t(n - 1)) | (uint64_t(max) << 32);
            if(rec::CompareAndSwap(gocpp::recv(c->idleMarkWorkers), old, go_new))
            {
                return;
            }
        }
    }

    void rec::setMaxIdleMarkWorkers(struct gcControllerState* c, int32_t max)
    {
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(c->idleMarkWorkers));
            auto n = int32_t(old & uint64_t(~ uint32_t(0)));
            if(n < 0)
            {
                print("n=", n, " max=", max, "\n");
                go_throw("negative idle mark workers");
            }
            auto go_new = uint64_t(uint32_t(n)) | (uint64_t(max) << 32);
            if(rec::CompareAndSwap(gocpp::recv(c->idleMarkWorkers), old, go_new))
            {
                return;
            }
        }
    }

    void gcControllerCommit()
    {
        assertWorldStoppedOrLockHeld(& mheap_.lock);
        rec::commit(gocpp::recv(gcController), isSweepDone());
        if(gcphase != _GCoff)
        {
            rec::revise(gocpp::recv(gcController));
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::HeapGoal(gocpp::recv(trace));
            traceRelease(trace);
        }
        auto [trigger, heapGoal] = rec::trigger(gocpp::recv(gcController));
        gcPaceSweeper(trigger);
        gcPaceScavenger(rec::Load(gocpp::recv(gcController.memoryLimit)), heapGoal, gcController.lastHeapGoal);
    }

}

