// generated by GoCpp from file '$(ImportDir)/runtime/mgcpacer.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcpacer.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goexperiment/exp_heapminimum512kib_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lock_sema.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcsweep.h"
// #include "golang/runtime/mstats.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2runtime.h"

namespace golang::runtime
{
    extern double gcGoalUtilization;
    extern double gcBackgroundUtilization;
    extern int gcCreditSlack;
    extern int gcAssistTimeSlack;
    extern int gcOverAssistWork;
    extern int defaultHeapMinimum;
    extern int maxStackScanSlack;
    extern int memoryLimitMinHeapGoalHeadroom;
    extern int memoryLimitHeapGoalHeadroomPercent;
    struct gcControllerState
    {
        atomic::Int32 gcPercent;
        atomic::Int64 memoryLimit;
        uint64_t heapMinimum;
        atomic::Uint64 runway;
        double consMark;
        gocpp::array<double, 4> lastConsMark;
        atomic::Uint64 gcPercentHeapGoal;
        atomic::Uint64 sweepDistMinTrigger;
        uint64_t triggered;
        uint64_t lastHeapGoal;
        atomic::Uint64 heapLive;
        atomic::Uint64 heapScan;
        uint64_t lastHeapScan;
        atomic::Uint64 lastStackScan;
        atomic::Uint64 maxStackScan;
        atomic::Uint64 globalsScan;
        uint64_t heapMarked;
        atomic::Int64 heapScanWork;
        atomic::Int64 stackScanWork;
        atomic::Int64 globalsScanWork;
        atomic::Int64 bgScanCredit;
        atomic::Int64 assistTime;
        atomic::Int64 dedicatedMarkTime;
        atomic::Int64 fractionalMarkTime;
        atomic::Int64 idleMarkTime;
        int64_t markStartTime;
        atomic::Int64 dedicatedMarkWorkersNeeded;
        atomic::Uint64 idleMarkWorkers;
        atomic::Float64 assistWorkPerByte;
        atomic::Float64 assistBytesPerWork;
        double fractionalUtilizationGoal;
        sysMemStat heapInUse;
        sysMemStat heapReleased;
        sysMemStat heapFree;
        atomic::Uint64 totalAlloc;
        atomic::Uint64 totalFree;
        atomic::Uint64 mappedReady;
        bool test;
        cpu::CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const gcControllerState& value);
    void init(gcControllerState* c, int32_t gcPercent, int64_t memoryLimit);
    void startCycle(gcControllerState* c, int64_t markStartTime, int procs, gcTrigger trigger);
    void revise(gcControllerState* c);
    void endCycle(gcControllerState* c, int64_t now, int procs, bool userForced);
    void enlistWorker(gcControllerState* c);
    std::tuple<g*, int64_t> findRunnableGCWorker(gcControllerState* c, p* pp, int64_t now);
    void resetLive(gcControllerState* c, uint64_t bytesMarked);
    void markWorkerStop(gcControllerState* c, gcMarkWorkerMode mode, int64_t duration);
    void update(gcControllerState* c, int64_t dHeapLive, int64_t dHeapScan);
    void addScannableStack(gcControllerState* c, p* pp, int64_t amount);
    void addGlobals(gcControllerState* c, int64_t amount);
    uint64_t heapGoal(gcControllerState* c);
    std::tuple<uint64_t, uint64_t> heapGoalInternal(gcControllerState* c);
    uint64_t memoryLimitHeapGoal(gcControllerState* c);
    extern int triggerRatioDen;
    extern int minTriggerRatioNum;
    extern int maxTriggerRatioNum;
    std::tuple<uint64_t, uint64_t> trigger(gcControllerState* c);
    void commit(gcControllerState* c, bool isSweepDone);
    int32_t setGCPercent(gcControllerState* c, int32_t in);
    int32_t setGCPercent(int32_t in);
    int32_t readGOGC();
    int64_t setMemoryLimit(gcControllerState* c, int64_t in);
    int64_t setMemoryLimit(int64_t in);
    int64_t readGOMEMLIMIT();
    bool addIdleMarkWorker(gcControllerState* c);
    bool needIdleMarkWorker(gcControllerState* c);
    void removeIdleMarkWorker(gcControllerState* c);
    void setMaxIdleMarkWorkers(gcControllerState* c, int32_t max);
    void gcControllerCommit();
}

