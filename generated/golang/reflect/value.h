// generated by GoCpp from file '$(ImportDir)/reflect/value.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/value.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/unsafeheader/unsafeheader.h"
#include "golang/reflect/makefunc.h"
#include "golang/reflect/type.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/pool.h"

namespace golang::reflect
{
    struct Value
    {
        abi::Type* typ_;
        unsafe::Pointer ptr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Value& value);
    Kind kind(flag f);
    flag ro(flag f);
    abi::Type* typ(struct Value v);
    unsafe::Pointer pointer(struct Value v);
    go_any packEface(Value v);
    Value unpackEface(go_any i);
    struct ValueError
    {
        std::string Method;
        Kind Kind;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value);
    std::string Error(struct ValueError* e);
    std::string valueMethodName();
    struct emptyInterface
    {
        abi::Type* typ;
        unsafe::Pointer word;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value);
    struct nonEmptyInterface
    {
        gocpp_id_0* itab;
        unsafe::Pointer word;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct nonEmptyInterface& value);
    void mustBe(flag f, Kind expected);
    void mustBeExported(flag f);
    void mustBeExportedSlow(flag f);
    void mustBeAssignable(flag f);
    void mustBeAssignableSlow(flag f);
    Value Addr(struct Value v);
    bool Bool(struct Value v);
    void panicNotBool(struct Value v);
    extern abi::Type* bytesType;
    gocpp::slice<unsigned char> Bytes(struct Value v);
    gocpp::slice<unsigned char> bytesSlow(struct Value v);
    gocpp::slice<gocpp::rune> runes(struct Value v);
    bool CanAddr(struct Value v);
    bool CanSet(struct Value v);
    gocpp::slice<Value> Call(struct Value v, gocpp::slice<Value> in);
    gocpp::slice<Value> CallSlice(struct Value v, gocpp::slice<Value> in);
    gocpp::slice<Value> call(struct Value v, std::string op, gocpp::slice<Value> in);
    void callReflect(makeFuncImpl* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs);
    std::tuple<abi::Type*, funcType*, unsafe::Pointer> methodReceiver(std::string op, Value v, int methodIndex);
    void storeRcvr(Value v, unsafe::Pointer p);
    uintptr_t align(uintptr_t x, uintptr_t n);
    void callMethod(methodValue* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs);
    std::string funcName(std::function<gocpp::slice<Value> (gocpp::slice<Value>)> f);
    int Cap(struct Value v);
    int capNonSlice(struct Value v);
    void Close(struct Value v);
    bool CanComplex(struct Value v);
    gocpp::complex128 Complex(struct Value v);
    Value Elem(struct Value v);
    struct gocpp_id_9 : gocpp::Interface
    {
        gocpp_id_9(){}
        gocpp_id_9(gocpp_id_9& i) = default;
        gocpp_id_9(const gocpp_id_9& i) = default;
        gocpp_id_9& operator=(gocpp_id_9& i) = default;
        gocpp_id_9& operator=(const gocpp_id_9& i) = default;

        template<typename T>
        gocpp_id_9(T& ref);

        template<typename T>
        gocpp_id_9(const T& ref);

        template<typename T>
        gocpp_id_9(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_9
        {
            virtual void vM() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_9Impl : Igocpp_id_9
        {
            explicit gocpp_id_9Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_9> value;
    };

    void M(const gocpp::PtrRecv<gocpp_id_9, false>& self);
    void M(const gocpp::ObjRecv<gocpp_id_9>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_9& value);
    Value Field(struct Value v, int i);
    Value FieldByIndex(struct Value v, gocpp::slice<int> index);
    std::tuple<Value, std::string> FieldByIndexErr(struct Value v, gocpp::slice<int> index);
    Value FieldByName(struct Value v, std::string name);
    Value FieldByNameFunc(struct Value v, std::function<bool (std::string)> match);
    bool CanFloat(struct Value v);
    double Float(struct Value v);
    extern abi::Type* uint8Type;
    Value Index(struct Value v, int i);
    bool CanInt(struct Value v);
    int64_t Int(struct Value v);
    bool CanInterface(struct Value v);
    go_any Interface(struct Value v);
    go_any valueInterface(Value v, bool safe);
    struct gocpp_id_10 : gocpp::Interface
    {
        gocpp_id_10(){}
        gocpp_id_10(gocpp_id_10& i) = default;
        gocpp_id_10(const gocpp_id_10& i) = default;
        gocpp_id_10& operator=(gocpp_id_10& i) = default;
        gocpp_id_10& operator=(const gocpp_id_10& i) = default;

        template<typename T>
        gocpp_id_10(T& ref);

        template<typename T>
        gocpp_id_10(const T& ref);

        template<typename T>
        gocpp_id_10(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_10
        {
            virtual void vM() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_10Impl : Igocpp_id_10
        {
            explicit gocpp_id_10Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_10> value;
    };

    void M(const gocpp::PtrRecv<gocpp_id_10, false>& self);
    void M(const gocpp::ObjRecv<gocpp_id_10>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_10& value);
    gocpp::array<uintptr_t, 2> InterfaceData(struct Value v);
    bool IsNil(struct Value v);
    bool IsValid(struct Value v);
    bool IsZero(struct Value v);
    bool isZero(gocpp::slice<unsigned char> b);
    void SetZero(struct Value v);
    Kind Kind(struct Value v);
    int Len(struct Value v);
    int lenNonSlice(struct Value v);
    extern abi::Type* stringType;
    Value MapIndex(struct Value v, Value key);
    gocpp::slice<Value> MapKeys(struct Value v);
    struct hiter
    {
        unsafe::Pointer key;
        unsafe::Pointer elem;
        unsafe::Pointer t;
        unsafe::Pointer h;
        unsafe::Pointer buckets;
        unsafe::Pointer bptr;
        gocpp::slice<unsafe::Pointer>* overflow;
        gocpp::slice<unsafe::Pointer>* oldoverflow;
        uintptr_t startBucket;
        uint8_t offset;
        bool wrapped;
        uint8_t B;
        uint8_t i;
        uintptr_t bucket;
        uintptr_t checkBucket;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hiter& value);
    bool initialized(struct hiter* h);
    struct MapIter
    {
        Value m;
        hiter hiter;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MapIter& value);
    Value Key(struct MapIter* iter);
    void SetIterKey(struct Value v, MapIter* iter);
    Value Value(struct MapIter* iter);
    void SetIterValue(struct Value v, MapIter* iter);
    bool Next(struct MapIter* iter);
    void Reset(struct MapIter* iter, Value v);
    MapIter* MapRange(struct Value v);
    void panicNotMap(flag f);
    Value copyVal(abi::Type* typ, flag fl, unsafe::Pointer ptr);
    Value Method(struct Value v, int i);
    int NumMethod(struct Value v);
    Value MethodByName(struct Value v, std::string name);
    int NumField(struct Value v);
    bool OverflowComplex(struct Value v, gocpp::complex128 x);
    bool OverflowFloat(struct Value v, double x);
    bool overflowFloat32(double x);
    bool OverflowInt(struct Value v, int64_t x);
    bool OverflowUint(struct Value v, uint64_t x);
    uintptr_t Pointer(struct Value v);
    std::tuple<Value, bool> Recv(struct Value v);
    std::tuple<Value, bool> recv(struct Value v, bool nb);
    void Send(struct Value v, Value x);
    bool send(struct Value v, Value x, bool nb);
    void Set(struct Value v, Value x);
    void SetBool(struct Value v, bool x);
    void SetBytes(struct Value v, gocpp::slice<unsigned char> x);
    void setRunes(struct Value v, gocpp::slice<gocpp::rune> x);
    void SetComplex(struct Value v, gocpp::complex128 x);
    void SetFloat(struct Value v, double x);
    void SetInt(struct Value v, int64_t x);
    void SetLen(struct Value v, int n);
    void SetCap(struct Value v, int n);
    void SetMapIndex(struct Value v, Value key, Value elem);
    void SetUint(struct Value v, uint64_t x);
    void SetPointer(struct Value v, unsafe::Pointer x);
    void SetString(struct Value v, std::string x);
    Value Slice(struct Value v, int i, int j);
    Value Slice3(struct Value v, int i, int j, int k);
    std::string String(struct Value v);
    std::string stringNonString(struct Value v);
    std::tuple<Value, bool> TryRecv(struct Value v);
    bool TrySend(struct Value v, Value x);
    Type Type(struct Value v);
    Type typeSlow(struct Value v);
    bool CanUint(struct Value v);
    uint64_t Uint(struct Value v);
    uintptr_t UnsafeAddr(struct Value v);
    unsafe::Pointer UnsafePointer(struct Value v);
    struct StringHeader
    {
        uintptr_t Data;
        int Len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StringHeader& value);
    struct SliceHeader
    {
        uintptr_t Data;
        int Len;
        int Cap;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SliceHeader& value);
    void typesMustMatch(std::string what, Type t1, Type t2);
    unsafe::Pointer arrayAt(unsafe::Pointer p, int i, uintptr_t eltSize, std::string whySafe);
    void Grow(struct Value v, int n);
    void grow(struct Value v, int n);
    Value extendSlice(struct Value v, int n);
    void Clear(struct Value v);
    Value Append(Value s, gocpp::slice<Value> x);

    template<typename... Args>
    Value Append(Value s, Args... x)
    {
        return Append(s, gocpp::ToSlice<Value>(x...));
    }

    Value AppendSlice(Value s, Value t);
    int Copy(Value dst, Value src);
    struct runtimeSelect
    {
        SelectDir dir;
        rtype* typ;
        unsafe::Pointer ch;
        unsafe::Pointer val;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct runtimeSelect& value);
    std::tuple<int, bool> rselect(gocpp::slice<runtimeSelect>);
    struct SelectCase
    {
        SelectDir Dir;
        Value Chan;
        Value Send;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SelectCase& value);
    std::tuple<int, Value, bool> Select(gocpp::slice<SelectCase> cases);
    unsafe::Pointer unsafe_New(abi::Type*);
    unsafe::Pointer unsafe_NewArray(abi::Type*, int);
    Value MakeSlice(Type typ, int len, int cap);
    Value MakeChan(Type typ, int buffer);
    Value MakeMap(Type typ);
    Value MakeMapWithSize(Type typ, int n);
    Value Indirect(Value v);
    Value ValueOf(go_any i);
    Value Zero(Type typ);
    Value New(Type typ);
    Value NewAt(Type typ, unsafe::Pointer p);
    Value assignTo(struct Value v, std::string context, abi::Type* dst, unsafe::Pointer target);
    Value Convert(struct Value v, Type t);
    bool CanConvert(struct Value v, Type t);
    bool Comparable(struct Value v);
    bool Equal(struct Value v, Value u);
    std::function<Value (Value, Type)> convertOp(abi::Type* dst, abi::Type* src);
    Value makeInt(flag f, uint64_t bits, Type t);
    Value makeFloat(flag f, double v, Type t);
    Value makeFloat32(flag f, double v, Type t);
    Value makeComplex(flag f, gocpp::complex128 v, Type t);
    Value makeString(flag f, std::string v, Type t);
    Value makeBytes(flag f, gocpp::slice<unsigned char> v, Type t);
    Value makeRunes(flag f, gocpp::slice<gocpp::rune> v, Type t);
    Value cvtInt(Value v, Type t);
    Value cvtUint(Value v, Type t);
    Value cvtFloatInt(Value v, Type t);
    Value cvtFloatUint(Value v, Type t);
    Value cvtIntFloat(Value v, Type t);
    Value cvtUintFloat(Value v, Type t);
    Value cvtFloat(Value v, Type t);
    Value cvtComplex(Value v, Type t);
    Value cvtIntString(Value v, Type t);
    Value cvtUintString(Value v, Type t);
    Value cvtBytesString(Value v, Type t);
    Value cvtStringBytes(Value v, Type t);
    Value cvtRunesString(Value v, Type t);
    Value cvtStringRunes(Value v, Type t);
    Value cvtSliceArrayPtr(Value v, Type t);
    Value cvtSliceArray(Value v, Type t);
    Value cvtDirect(Value v, Type typ);
    Value cvtT2I(Value v, Type typ);
    Value cvtI2I(Value v, Type typ);
    int chancap(unsafe::Pointer ch);
    void chanclose(unsafe::Pointer ch);
    int chanlen(unsafe::Pointer ch);
    std::tuple<bool, bool> chanrecv(unsafe::Pointer ch, bool nb, unsafe::Pointer val);
    bool chansend0(unsafe::Pointer ch, unsafe::Pointer val, bool nb);
    bool chansend(unsafe::Pointer ch, unsafe::Pointer val, bool nb);
    unsafe::Pointer makechan(abi::Type* typ, int size);
    unsafe::Pointer makemap(abi::Type* t, int cap);
    unsafe::Pointer mapaccess(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key);
    unsafe::Pointer mapaccess_faststr(abi::Type* t, unsafe::Pointer m, std::string key);
    void mapassign0(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key, unsafe::Pointer val);
    void mapassign(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key, unsafe::Pointer val);
    void mapassign_faststr0(abi::Type* t, unsafe::Pointer m, std::string key, unsafe::Pointer val);
    void mapassign_faststr(abi::Type* t, unsafe::Pointer m, std::string key, unsafe::Pointer val);
    void mapdelete(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key);
    void mapdelete_faststr(abi::Type* t, unsafe::Pointer m, std::string key);
    void mapiterinit(abi::Type* t, unsafe::Pointer m, hiter* it);
    unsafe::Pointer mapiterkey(hiter* it);
    unsafe::Pointer mapiterelem(hiter* it);
    void mapiternext(hiter* it);
    int maplen(unsafe::Pointer m);
    void mapclear(abi::Type* t, unsafe::Pointer m);
    void call(abi::Type* stackArgsType, unsafe::Pointer f, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs);
    void ifaceE2I(abi::Type* t, go_any src, unsafe::Pointer dst);
    void memmove(unsafe::Pointer dst, unsafe::Pointer src, uintptr_t size);
    void typedmemmove(abi::Type* t, unsafe::Pointer dst, unsafe::Pointer src);
    void typedmemclr(abi::Type* t, unsafe::Pointer ptr);
    void typedmemclrpartial(abi::Type* t, unsafe::Pointer ptr, uintptr_t off, uintptr_t size);
    int typedslicecopy(abi::Type* t, unsafeheader::Slice dst, unsafeheader::Slice src);
    void typedarrayclear(abi::Type* elemType, unsafe::Pointer ptr, int len);
    uintptr_t typehash(abi::Type* t, unsafe::Pointer p, uintptr_t h);
    bool verifyNotInHeapPtr(uintptr_t p);
    unsafeheader::Slice growslice(abi::Type* t, unsafeheader::Slice old, int num);
    void escapes(go_any x);
    void contentEscapes(unsafe::Pointer x);
    unsafe::Pointer noescape(unsafe::Pointer p);
}

