// generated by GoCpp from file '$(ImportDir)/runtime/trace2region.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2region.h"
#include "gocpp/support.h"

#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace atomic::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceRegionAlloc::operator T()
    {
        T result;
        result.head = this->head;
        result.off = this->off;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceRegionAlloc::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        if (off != ref.off) return false;
        return true;
    }

    std::ostream& traceRegionAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << off;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceRegionAlloc& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceRegionAllocBlock::operator T()
    {
        T result;
        result._1 = this->_1;
        result.next = this->next;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceRegionAllocBlock::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (next != ref.next) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& traceRegionAllocBlock::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << next;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceRegionAllocBlock& value)
    {
        return value.PrintTo(os);
    }

    struct notInHeap* rec::alloc(struct traceRegionAlloc* a, uintptr_t n)
    {
        n = alignUp(n, goarch::PtrSize);
        if(a->head == nullptr || a->off + n > uintptr_t(len(a->head->data)))
        {
            if(n > uintptr_t(len(a->head->data)))
            {
                go_throw("traceRegion: alloc too large");
            }
            auto block = (traceRegionAllocBlock*)(sysAlloc(gocpp::Sizeof<traceRegionAllocBlock>(), & memstats.other_sys));
            if(block == nullptr)
            {
                go_throw("traceRegion: out of memory");
            }
            block->next = a->head;
            a->head = block;
            a->off = 0;
        }
        auto p = & a->head->data[a->off];
        a->off += n;
        return (notInHeap*)(unsafe::Pointer(p));
    }

    void rec::drop(struct traceRegionAlloc* a)
    {
        for(; a->head != nullptr; )
        {
            auto block = a->head;
            a->head = block->next;
            sysFree(unsafe::Pointer(block), gocpp::Sizeof<traceRegionAllocBlock>(), & memstats.other_sys);
        }
    }

}

