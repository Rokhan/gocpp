// generated by GoCpp from file '$(ImportDir)/runtime/stubs.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/stubs.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/abi_amd64.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/map.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Should be a built-in for unsafe.Pointer?
    //
    //go:nosplit
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    // getg returns the pointer to the current g.
    // The compiler rewrites calls to this function into instructions
    // that fetch the g directly (from TLS or from the dedicated register).
    struct g* getg()
    /* convertBlockStmt, nil block */;

    // mcall switches from the g to the g0 stack and invokes fn(g),
    // where g is the goroutine that made the call.
    // mcall saves g's current PC/SP in g->sched so that it can be restored later.
    // It is up to fn to arrange for that later execution, typically by recording
    // g in a data structure, causing something to call ready(g) later.
    // mcall returns to the original goroutine g later, when g has been rescheduled.
    // fn must not return at all; typically it ends by calling schedule, to let the m
    // run other goroutines.
    //
    // mcall can only be called from g stacks (not g0, not gsignal).
    //
    // This must NOT be go:noescape: if fn is a stack-allocated closure,
    // fn puts g on a run queue, and g executes before fn returns, the
    // closure will be invalidated while it is still executing.
    void mcall(std::function<void (g*)> fn)
    /* convertBlockStmt, nil block */;

    // systemstack runs fn on a system stack.
    // If systemstack is called from the per-OS-thread (g0) stack, or
    // if systemstack is called from the signal handling (gsignal) stack,
    // systemstack calls fn directly and returns.
    // Otherwise, systemstack is being called from the limited stack
    // of an ordinary goroutine. In this case, systemstack switches
    // to the per-OS-thread stack, calls fn, and switches back.
    // It is common to use a func literal as the argument, in order
    // to share inputs and outputs with the code around the call
    // to system stack:
    //
    //	... set up y ...
    //	systemstack(func() {
    //		x = bigcall(y)
    //	})
    //	... use x ...
    //
    //go:noescape
    void systemstack(std::function<void ()> fn)
    /* convertBlockStmt, nil block */;

    //go:nosplit
    //go:nowritebarrierrec
    void badsystemstack()
    {
        writeErrStr("fatal: systemstack called from unexpected goroutine"s);
    }

    // memclrNoHeapPointers clears n bytes starting at ptr.
    //
    // Usually you should use typedmemclr. memclrNoHeapPointers should be
    // used only when the caller knows that *ptr contains no heap pointers
    // because either:
    //
    // *ptr is initialized memory and its type is pointer-free, or
    //
    // *ptr is uninitialized memory (e.g., memory that's being reused
    // for a new allocation) and hence contains only "junk".
    //
    // memclrNoHeapPointers ensures that if ptr is pointer-aligned, and n
    // is a multiple of the pointer size, then any pointer-aligned,
    // pointer-sized portion is cleared atomically. Despite the function
    // name, this is necessary because this function is the underlying
    // implementation of typedmemclr and memclrHasPointers. See the doc of
    // memmove for more details.
    //
    // The (CPU-specific) implementations of this function are in memclr_*.s.
    //
    //go:noescape
    void memclrNoHeapPointers(unsafe::Pointer ptr, uintptr_t n)
    /* convertBlockStmt, nil block */;

    //go:linkname reflect_memclrNoHeapPointers reflect.memclrNoHeapPointers
    void reflect_memclrNoHeapPointers(unsafe::Pointer ptr, uintptr_t n)
    {
        memclrNoHeapPointers(ptr, n);
    }

    // memmove copies n bytes from "from" to "to".
    //
    // memmove ensures that any pointer in "from" is written to "to" with
    // an indivisible write, so that racy reads cannot observe a
    // half-written pointer. This is necessary to prevent the garbage
    // collector from observing invalid pointers, and differs from memmove
    // in unmanaged languages. However, memmove is only required to do
    // this if "from" and "to" may contain pointers, which can only be the
    // case if "from", "to", and "n" are all be word-aligned.
    //
    // Implementations are in memmove_*.s.
    //
    //go:noescape
    void memmove(unsafe::Pointer to, unsafe::Pointer from, uintptr_t n)
    /* convertBlockStmt, nil block */;

    //go:linkname reflect_memmove reflect.memmove
    void reflect_memmove(unsafe::Pointer to, unsafe::Pointer from, uintptr_t n)
    {
        memmove(to, from, n);
    }

    // exported value for testing
    // in internal/bytealg/equal_*.s
    //
    //go:noescape
    bool memequal(unsafe::Pointer a, unsafe::Pointer b, uintptr_t size)
    /* convertBlockStmt, nil block */;

    // noescape hides a pointer from escape analysis.  noescape is
    // the identity function but escape analysis doesn't think the
    // output depends on the input.  noescape is inlined and currently
    // compiles down to zero instructions.
    // USE CAREFULLY!
    //
    //go:nosplit
    unsafe::Pointer noescape(unsafe::Pointer p)
    {
        auto x = uintptr_t(p);
        return unsafe::Pointer(x ^ 0);
    }

    // noEscapePtr hides a pointer from escape analysis. See noescape.
    // USE CAREFULLY!
    //
    //go:nosplit

    template<typename T>
    T* noEscapePtr(T* p)
    {
        auto x = uintptr_t(unsafe::Pointer(p));
        return (T*)(unsafe::Pointer(x ^ 0));
    }

    // Not all cgocallback frames are actually cgocallback,
    // so not all have these arguments. Mark them uintptr so that the GC
    // does not misinterpret memory when the arguments are not present.
    // cgocallback is not called from Go, only from crosscall2.
    // This in turn calls cgocallbackg, which is where we'll find
    // pointer-declared arguments.
    //
    // When fn is nil (frame is saved g), call dropm instead,
    // this is used when the C thread is exiting.
    void cgocallback(uintptr_t fn, uintptr_t frame, uintptr_t ctxt)
    /* convertBlockStmt, nil block */;

    void gogo(struct gobuf* buf)
    /* convertBlockStmt, nil block */;

    void asminit()
    /* convertBlockStmt, nil block */;

    void setg(struct g* gg)
    /* convertBlockStmt, nil block */;

    void breakpoint()
    /* convertBlockStmt, nil block */;

    // reflectcall calls fn with arguments described by stackArgs, stackArgsSize,
    // frameSize, and regArgs.
    //
    // Arguments passed on the stack and space for return values passed on the stack
    // must be laid out at the space pointed to by stackArgs (with total length
    // stackArgsSize) according to the ABI.
    //
    // stackRetOffset must be some value <= stackArgsSize that indicates the
    // offset within stackArgs where the return value space begins.
    //
    // frameSize is the total size of the argument frame at stackArgs and must
    // therefore be >= stackArgsSize. It must include additional space for spilling
    // register arguments for stack growth and preemption.
    //
    // TODO(mknyszek): Once we don't need the additional spill space, remove frameSize,
    // since frameSize will be redundant with stackArgsSize.
    //
    // Arguments passed in registers must be laid out in regArgs according to the ABI.
    // regArgs will hold any return values passed in registers after the call.
    //
    // reflectcall copies stack arguments from stackArgs to the goroutine stack, and
    // then copies back stackArgsSize-stackRetOffset bytes back to the return space
    // in stackArgs once fn has completed. It also "unspills" argument registers from
    // regArgs before calling fn, and spills them back into regArgs immediately
    // following the call to fn. If there are results being returned on the stack,
    // the caller should pass the argument frame type as stackArgsType so that
    // reflectcall can execute appropriate write barriers during the copy.
    //
    // reflectcall expects regArgs.ReturnIsPtr to be populated indicating which
    // registers on the return path will contain Go pointers. It will then store
    // these pointers in regArgs.Ptrs such that they are visible to the GC.
    //
    // Package reflect passes a frame type. In package runtime, there is only
    // one call that copies results back, in callbackWrap in syscall_windows.go, and it
    // does NOT pass a frame type, meaning there are no write barriers invoked. See that
    // call site for justification.
    //
    // Package reflect accesses this symbol through a linkname.
    //
    // Arguments passed through to reflectcall do not escape. The type is used
    // only in a very limited callee of reflectcall, the stackArgs are copied, and
    // regArgs is only used in the reflectcall frame.
    //
    //go:noescape
    void reflectcall(golang::runtime::_type* stackArgsType, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void procyield(uint32_t cycles)
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    neverCallThisFunction::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool neverCallThisFunction::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& neverCallThisFunction::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct neverCallThisFunction& value)
    {
        return value.PrintTo(os);
    }

    // goexit is the return stub at the top of every goroutine call stack.
    // Each goroutine stack is constructed as if goexit called the
    // goroutine's entry point function, so that when the entry point
    // function returns, it will return to goexit, which will call goexit1
    // to perform the actual exit.
    //
    // This function must never be called directly. Call goexit1 instead.
    // gentraceback assumes that goexit terminates the stack. A direct
    // call on the stack will cause gentraceback to stop walking the stack
    // prematurely and if there is leftover state it may panic.
    void goexit(neverCallThisFunction)
    /* convertBlockStmt, nil block */;

    // publicationBarrier performs a store/store barrier (a "publication"
    // or "export" barrier). Some form of synchronization is required
    // between initializing an object and making that object accessible to
    // another processor. Without synchronization, the initialization
    // writes and the "publication" write may be reordered, allowing the
    // other processor to follow the pointer and observe an uninitialized
    // object. In general, higher-level synchronization should be used,
    // such as locking or an atomic pointer write. publicationBarrier is
    // for when those aren't an option, such as in the implementation of
    // the memory manager.
    //
    // There's no corresponding barrier for the read side because the read
    // side naturally has a data dependency order. All architectures that
    // Go supports or seems likely to ever support automatically enforce
    // data dependency ordering.
    void publicationBarrier()
    /* convertBlockStmt, nil block */;

    //go:noescape
    uintptr_t getcallerpc()
    /* convertBlockStmt, nil block */;

    //go:noescape
    uintptr_t getcallersp()
    /* convertBlockStmt, nil block */;

    // getclosureptr returns the pointer to the current closure.
    // getclosureptr can only be used in an assignment statement
    // at the entry of a function. Moreover, go:nosplit directive
    // must be specified at the declaration of caller function,
    // so that the function prolog does not clobber the closure register.
    // for example:
    //
    //	//go:nosplit
    //	func f(arg1, arg2, arg3 int) {
    //		dx := getclosureptr()
    //	}
    //
    // The compiler rewrites calls to this function into instructions that fetch the
    // pointer from a well-known register (DX on x86 architecture, etc.) directly.
    //
    // WARNING: PGO-based devirtualization cannot detect that caller of
    // getclosureptr require closure context, and thus must maintain a list of
    // these functions, which is in
    // cmd/compile/internal/devirtualize/pgo.maybeDevirtualizeFunctionCall.
    uintptr_t getclosureptr()
    /* convertBlockStmt, nil block */;

    //go:noescape
    int32_t asmcgocall(unsafe::Pointer fn, unsafe::Pointer arg)
    /* convertBlockStmt, nil block */;

    void morestack()
    /* convertBlockStmt, nil block */;

    void morestack_noctxt()
    /* convertBlockStmt, nil block */;

    void rt0_go()
    /* convertBlockStmt, nil block */;

    // return0 is a stub used to return 0 from deferproc.
    // It is called at the very end of deferproc to signal
    // the calling Go function that it should not jump
    // to deferreturn.
    // in asm_*.s
    void return0()
    /* convertBlockStmt, nil block */;

    // in asm_*.s
    // not called directly; definitions here supply type information for traceback.
    // These must have the same signature (arg pointer map) as reflectcall.
    void call16(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call32(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call64(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call128(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call256(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call512(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call1024(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call2048(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call4096(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call8192(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call16384(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call32768(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call65536(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call131072(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call262144(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call524288(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call1048576(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call2097152(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call4194304(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call8388608(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call16777216(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call33554432(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call67108864(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call134217728(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call268435456(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call536870912(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void call1073741824(unsafe::Pointer typ, unsafe::Pointer fn, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void systemstack_switch()
    /* convertBlockStmt, nil block */;

    // alignUp rounds n up to a multiple of a. a must be a power of 2.
    //
    //go:nosplit
    uintptr_t alignUp(uintptr_t n, uintptr_t a)
    {
        return (n + a - 1) &^ (a - 1);
    }

    // alignDown rounds n down to a multiple of a. a must be a power of 2.
    //
    //go:nosplit
    uintptr_t alignDown(uintptr_t n, uintptr_t a)
    {
        return n &^ (a - 1);
    }

    // divRoundUp returns ceil(n / a).
    uintptr_t divRoundUp(uintptr_t n, uintptr_t a)
    {
        return (n + a - 1) / a;
    }

    // checkASM reports whether assembly runtime checks have passed.
    bool checkASM()
    /* convertBlockStmt, nil block */;

    bool memequal_varlen(unsafe::Pointer a, unsafe::Pointer b)
    /* convertBlockStmt, nil block */;

    // bool2int returns 0 if x is false or 1 if x is true.
    int bool2int(bool x)
    {
        return int(*(uint8_t*)(unsafe::Pointer(& x)));
    }

    // abort crashes the runtime in situations where even throw might not
    // work. In general it should do something a debugger will recognize
    // (e.g., an INT3 on x86). A crash in abort is recognized by the
    // signal handler, which will attempt to tear down the runtime
    // immediately.
    void abort()
    /* convertBlockStmt, nil block */;

    // Called from compiled code; declared for vet; do NOT call from Go.
    void gcWriteBarrier1()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier2()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier3()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier4()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier5()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier6()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier7()
    /* convertBlockStmt, nil block */;

    void gcWriteBarrier8()
    /* convertBlockStmt, nil block */;

    void duffzero()
    /* convertBlockStmt, nil block */;

    void duffcopy()
    /* convertBlockStmt, nil block */;

    // Called from linker-generated .initarray; declared for go vet; do NOT call from Go.
    void addmoduledata()
    /* convertBlockStmt, nil block */;

    // Injected by the signal handler for panicking signals.
    // Initializes any registers that have fixed meaning at calls but
    // are scratch in bodies and calls sigpanic.
    // On many platforms it just jumps to sigpanic.
    void sigpanic0()
    /* convertBlockStmt, nil block */;

    // intArgRegs is used by the various register assignment
    // algorithm implementations in the runtime. These include:.
    // - Finalizers (mfinal.go)
    // - Windows callbacks (syscall_windows.go)
    //
    // Both are stripped-down versions of the algorithm since they
    // only have to deal with a subset of cases (finalizers only
    // take a pointer or interface argument, Go Windows callbacks
    // don't support floating point).
    //
    // It should be modified with care and are generally only
    // modified when testing this package.
    //
    // It should never be set higher than its internal/abi
    // constant counterparts, because the system relies on a
    // structure that is at least large enough to hold the
    // registers the system supports.
    //
    // Protected by finlock.
    int intArgRegs = abi::IntArgRegs;
}

