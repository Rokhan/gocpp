// generated by GoCpp from file '$(ImportDir)/strings/reader.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strings/reader.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/io/io.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::strings
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Reader implements the [io.Reader], [io.ReaderAt], [io.ByteReader], [io.ByteScanner],
    // [io.RuneReader], [io.RuneScanner], [io.Seeker], and [io.WriterTo] interfaces by reading
    // from a string.
    // The zero value for Reader operates like a Reader of an empty string.
    
    template<typename T> requires gocpp::GoStruct<T>
    Reader::operator T()
    {
        T result;
        result.s = this->s;
        result.i = this->i;
        result.prevRune = this->prevRune;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Reader::operator==(const T& ref) const
    {
        if (s != ref.s) return false;
        if (i != ref.i) return false;
        if (prevRune != ref.prevRune) return false;
        return true;
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << s;
        os << " " << i;
        os << " " << prevRune;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    // Len returns the number of bytes of the unread portion of the
    // string.
    int rec::Len(struct Reader* r)
    {
        if(r->i >= int64_t(len(r->s)))
        {
            return 0;
        }
        return int(int64_t(len(r->s)) - r->i);
    }

    // Size returns the original length of the underlying string.
    // Size is the number of bytes available for reading via [Reader.ReadAt].
    // The returned value is always the same and is not affected by calls
    // to any other method.
    int64_t rec::Size(struct Reader* r)
    {
        return int64_t(len(r->s));
    }

    // Read implements the [io.Reader] interface.
    std::tuple<int, struct gocpp::error> rec::Read(struct Reader* r, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        if(r->i >= int64_t(len(r->s)))
        {
            return {0, io::go_EOF};
        }
        r->prevRune = - 1;
        n = copy(b, r->s.make_slice(r->i));
        r->i += int64_t(n);
        return {n, err};
    }

    // ReadAt implements the [io.ReaderAt] interface.
    std::tuple<int, struct gocpp::error> rec::ReadAt(struct Reader* r, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(off < 0)
        {
            return {0, errors::New("strings.Reader.ReadAt: negative offset"s)};
        }
        if(off >= int64_t(len(r->s)))
        {
            return {0, io::go_EOF};
        }
        n = copy(b, r->s.make_slice(off));
        if(n < len(b))
        {
            err = io::go_EOF;
        }
        return {n, err};
    }

    // ReadByte implements the [io.ByteReader] interface.
    std::tuple<unsigned char, struct gocpp::error> rec::ReadByte(struct Reader* r)
    {
        r->prevRune = - 1;
        if(r->i >= int64_t(len(r->s)))
        {
            return {0, io::go_EOF};
        }
        auto b = r->s[r->i];
        r->i++;
        return {b, nullptr};
    }

    // UnreadByte implements the [io.ByteScanner] interface.
    struct gocpp::error rec::UnreadByte(struct Reader* r)
    {
        if(r->i <= 0)
        {
            return errors::New("strings.Reader.UnreadByte: at beginning of string"s);
        }
        r->prevRune = - 1;
        r->i--;
        return nullptr;
    }

    // ReadRune implements the [io.RuneReader] interface.
    std::tuple<gocpp::rune, int, struct gocpp::error> rec::ReadRune(struct Reader* r)
    {
        gocpp::rune ch;
        int size;
        struct gocpp::error err;
        if(r->i >= int64_t(len(r->s)))
        {
            r->prevRune = - 1;
            return {0, 0, io::go_EOF};
        }
        r->prevRune = int(r->i);
        if(auto c = r->s[r->i]; c < utf8::RuneSelf)
        {
            r->i++;
            return {gocpp::rune(c), 1, nullptr};
        }
        std::tie(ch, size) = utf8::DecodeRuneInString(r->s.make_slice(r->i));
        r->i += int64_t(size);
        return {ch, size, err};
    }

    // UnreadRune implements the [io.RuneScanner] interface.
    struct gocpp::error rec::UnreadRune(struct Reader* r)
    {
        if(r->i <= 0)
        {
            return errors::New("strings.Reader.UnreadRune: at beginning of string"s);
        }
        if(r->prevRune < 0)
        {
            return errors::New("strings.Reader.UnreadRune: previous operation was not ReadRune"s);
        }
        r->i = int64_t(r->prevRune);
        r->prevRune = - 1;
        return nullptr;
    }

    // Seek implements the [io.Seeker] interface.
    std::tuple<int64_t, struct gocpp::error> rec::Seek(struct Reader* r, int64_t offset, int whence)
    {
        r->prevRune = - 1;
        int64_t abs = {};
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            if(condition == io::SeekStart) { conditionId = 0; }
            else if(condition == io::SeekCurrent) { conditionId = 1; }
            else if(condition == io::SeekEnd) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    abs = offset;
                    break;
                case 1:
                    abs = r->i + offset;
                    break;
                case 2:
                    abs = int64_t(len(r->s)) + offset;
                    break;
                default:
                    return {0, errors::New("strings.Reader.Seek: invalid whence"s)};
                    break;
            }
        }
        if(abs < 0)
        {
            return {0, errors::New("strings.Reader.Seek: negative position"s)};
        }
        r->i = abs;
        return {abs, nullptr};
    }

    // WriteTo implements the [io.WriterTo] interface.
    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct Reader* r, io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        r->prevRune = - 1;
        if(r->i >= int64_t(len(r->s)))
        {
            return {0, nullptr};
        }
        auto s = r->s.make_slice(r->i);
        auto [m, err] = io::WriteString(w, s);
        if(m > len(s))
        {
            gocpp::panic("strings.Reader.WriteTo: invalid WriteString count"s);
        }
        r->i += int64_t(m);
        n = int64_t(m);
        if(m != len(s) && err == nullptr)
        {
            err = io::ErrShortWrite;
        }
        return {n, err};
    }

    // Reset resets the [Reader] to be reading from s.
    void rec::Reset(struct Reader* r, std::string s)
    {
        *r = Reader {s, 0, - 1};
    }

    // NewReader returns a new [Reader] reading from s.
    // It is similar to [bytes.NewBufferString] but more efficient and non-writable.
    struct Reader* NewReader(std::string s)
    {
        return new Reader {s, 0, - 1};
    }

}

