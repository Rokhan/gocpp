// generated by GoCpp from file '$(ImportDir)/math/rand/rand.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/math/rand/rand.h"
#include "gocpp/support.h"

#include "golang/internal/bisect/bisect.h"
#include "golang/internal/godebug/godebug.h"
#include "golang/internal/godebugs/table.h"
#include "golang/math/rand/exp.h"
#include "golang/math/rand/normal.h"
#include "golang/math/rand/rng.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

namespace golang::rand
{
    
    template<typename T>
    Source::Source(T& ref)
    {
        value.reset(new SourceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source::Source(const T& ref)
    {
        value.reset(new SourceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source::Source(T* ptr)
    {
        value.reset(new SourceImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Source::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    int64_t Source::SourceImpl<T, StoreT>::vInt63()
    {
        return Int63(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void Source::SourceImpl<T, StoreT>::vSeed(int64_t seed)
    {
        return Seed(gocpp::PtrRecv<T, false>(value.get()), seed);
    }

    int64_t Int63(const gocpp::PtrRecv<Source, false>& self)
    {
        return self.ptr->value->vInt63();
    }

    int64_t Int63(const gocpp::ObjRecv<Source>& self)
    {
        return self.obj.value->vInt63();
    }

    void Seed(const gocpp::PtrRecv<Source, false>& self, int64_t seed)
    {
        return self.ptr->value->vSeed(seed);
    }

    void Seed(const gocpp::ObjRecv<Source>& self, int64_t seed)
    {
        return self.obj.value->vSeed(seed);
    }

    std::ostream& operator<<(std::ostream& os, const struct Source& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Source64::Source64(T& ref)
    {
        value.reset(new Source64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source64::Source64(const T& ref)
    {
        value.reset(new Source64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source64::Source64(T* ptr)
    {
        value.reset(new Source64Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Source64::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint64_t Source64::Source64Impl<T, StoreT>::vUint64()
    {
        return Uint64(gocpp::PtrRecv<T, false>(value.get()));
    }

    uint64_t Uint64(const gocpp::PtrRecv<Source64, false>& self)
    {
        return self.ptr->value->vUint64();
    }

    uint64_t Uint64(const gocpp::ObjRecv<Source64>& self)
    {
        return self.obj.value->vUint64();
    }

    std::ostream& operator<<(std::ostream& os, const struct Source64& value)
    {
        return value.PrintTo(os);
    }

    struct Source NewSource(int64_t seed)
    {
        return newSource(seed);
    }

    struct rngSource* newSource(int64_t seed)
    {
        rngSource rng = {};
        Seed(gocpp::recv(rng), seed);
        return & rng;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Rand::operator T()
    {
        T result;
        result.src = this->src;
        result.s64 = this->s64;
        result.readVal = this->readVal;
        result.readPos = this->readPos;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rand::operator==(const T& ref) const
    {
        if (src != ref.src) return false;
        if (s64 != ref.s64) return false;
        if (readVal != ref.readVal) return false;
        if (readPos != ref.readPos) return false;
        return true;
    }

    std::ostream& Rand::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << src;
        os << " " << s64;
        os << " " << readVal;
        os << " " << readPos;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rand& value)
    {
        return value.PrintTo(os);
    }

    struct Rand* New(struct Source src)
    {
        auto [s64, gocpp_id_1] = gocpp::getValue<Source64>(src);
        return gocpp::InitPtr<Rand>([](Rand& x) { x.src = src; x.s64 = s64; });
    }

    void Seed(struct Rand* r, int64_t seed)
    {
        if(auto [lk, ok] = gocpp::getValue<lockedSource*>(r->src); ok)
        {
            seedPos(gocpp::recv(lk), seed, & r->readPos);
            return;
        }
        Seed(gocpp::recv(r->src), seed);
        r->readPos = 0;
    }

    int64_t Int63(struct Rand* r)
    {
        return Int63(gocpp::recv(r->src));
    }

    uint32_t Uint32(struct Rand* r)
    {
        return uint32_t(Int63(gocpp::recv(r)) >> 31);
    }

    uint64_t Uint64(struct Rand* r)
    {
        if(r->s64 != nullptr)
        {
            return Uint64(gocpp::recv(r->s64));
        }
        return (uint64_t(Int63(gocpp::recv(r))) >> 31) | (uint64_t(Int63(gocpp::recv(r))) << 32);
    }

    int32_t Int31(struct Rand* r)
    {
        return int32_t(Int63(gocpp::recv(r)) >> 32);
    }

    int Int(struct Rand* r)
    {
        auto u = (unsigned int)(Int63(gocpp::recv(r)));
        return int((u << 1) >> 1);
    }

    int64_t Int63n(struct Rand* r, int64_t n)
    {
        if(n <= 0)
        {
            gocpp::panic("invalid argument to Int63n");
        }
        if(n & (n - 1) == 0)
        {
            return Int63(gocpp::recv(r)) & (n - 1);
        }
        auto max = int64_t((1 << 63) - 1 - (1 << 63) % uint64_t(n));
        auto v = Int63(gocpp::recv(r));
        for(; v > max; )
        {
            v = Int63(gocpp::recv(r));
        }
        return v % n;
    }

    int32_t Int31n(struct Rand* r, int32_t n)
    {
        if(n <= 0)
        {
            gocpp::panic("invalid argument to Int31n");
        }
        if(n & (n - 1) == 0)
        {
            return Int31(gocpp::recv(r)) & (n - 1);
        }
        auto max = int32_t((1 << 31) - 1 - (1 << 31) % uint32_t(n));
        auto v = Int31(gocpp::recv(r));
        for(; v > max; )
        {
            v = Int31(gocpp::recv(r));
        }
        return v % n;
    }

    int32_t int31n(struct Rand* r, int32_t n)
    {
        auto v = Uint32(gocpp::recv(r));
        auto prod = uint64_t(v) * uint64_t(n);
        auto low = uint32_t(prod);
        if(low < uint32_t(n))
        {
            auto thresh = uint32_t(- n) % uint32_t(n);
            for(; low < thresh; )
            {
                v = Uint32(gocpp::recv(r));
                prod = uint64_t(v) * uint64_t(n);
                low = uint32_t(prod);
            }
        }
        return int32_t(prod >> 32);
    }

    int Intn(struct Rand* r, int n)
    {
        if(n <= 0)
        {
            gocpp::panic("invalid argument to Intn");
        }
        if(n <= (1 << 31) - 1)
        {
            return int(Int31n(gocpp::recv(r), int32_t(n)));
        }
        return int(Int63n(gocpp::recv(r), int64_t(n)));
    }

    double Float64(struct Rand* r)
    {
        again:
        auto f = double(Int63(gocpp::recv(r))) / (1 << 63);
        if(f == 1)
        {
            goto again;
        }
        return f;
    }

    double Float32(struct Rand* r)
    {
        again:
        auto f = float(Float64(gocpp::recv(r)));
        if(f == 1)
        {
            goto again;
        }
        return f;
    }

    gocpp::slice<int> Perm(struct Rand* r, int n)
    {
        auto m = gocpp::make(gocpp::Tag<gocpp::slice<int>>(), n);
        for(auto i = 0; i < n; i++)
        {
            auto j = Intn(gocpp::recv(r), i + 1);
            m[i] = m[j];
            m[j] = i;
        }
        return m;
    }

    void Shuffle(struct Rand* r, int n, std::function<void (int i, int j)> swap)
    {
        if(n < 0)
        {
            gocpp::panic("invalid argument to Shuffle");
        }
        auto i = n - 1;
        for(; i > (1 << 31) - 1 - 1; i--)
        {
            auto j = int(Int63n(gocpp::recv(r), int64_t(i + 1)));
            swap(i, j);
        }
        for(; i > 0; i--)
        {
            auto j = int(int31n(gocpp::recv(r), int32_t(i + 1)));
            swap(i, j);
        }
    }

    std::tuple<int, struct gocpp::error> Read(struct Rand* r, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        //Go type switch emulation
        {
            const auto& gocpp_id_2 = gocpp::type_info(r->src);
            int conditionId = -1;
            if(gocpp_id_2 == typeid(lockedSource*)) { conditionId = 0; }
            else if(gocpp_id_2 == typeid(runtimeSource*)) { conditionId = 1; }
            switch(conditionId)
            {
                int n;
                struct gocpp::error err;
                case 0:
                {
                    lockedSource* src = gocpp::any_cast<lockedSource*>(r->src);
                    return read(gocpp::recv(src), p, & r->readVal, & r->readPos);
                    break;
                }
                case 1:
                {
                    runtimeSource* src = gocpp::any_cast<runtimeSource*>(r->src);
                    return read(gocpp::recv(src), p, & r->readVal, & r->readPos);
                    break;
                }
            }
        }
        return read(p, r->src, & r->readVal, & r->readPos);
    }

    std::tuple<int, struct gocpp::error> read(gocpp::slice<unsigned char> p, struct Source src, int64_t* readVal, int8_t* readPos)
    {
        int n;
        struct gocpp::error err;
        auto pos = *readPos;
        auto val = *readVal;
        auto [rng, gocpp_id_4] = gocpp::getValue<rngSource*>(src);
        for(n = 0; n < len(p); n++)
        {
            int n;
            struct gocpp::error err;
            if(pos == 0)
            {
                int n;
                struct gocpp::error err;
                if(rng != nullptr)
                {
                    int n;
                    struct gocpp::error err;
                    val = Int63(gocpp::recv(rng));
                }
                else
                {
                    int n;
                    struct gocpp::error err;
                    val = Int63(gocpp::recv(src));
                }
                pos = 7;
            }
            p[n] = unsigned char(val);
            val >>= 8;
            pos--;
        }
        *readPos = pos;
        *readVal = val;
        return {n, err};
    }

    atomic::Pointer<Rand> globalRandGenerator;
    godebug::Setting* randautoseed = godebug::New("randautoseed");
    struct Rand* globalRand()
    {
        if(auto r = Load(gocpp::recv(globalRandGenerator)); r != nullptr)
        {
            return r;
        }
        Rand* r = {};
        if(Value(gocpp::recv(randautoseed)) == "0")
        {
            IncNonDefault(gocpp::recv(randautoseed));
            r = New(go_new(lockedSource));
            Seed(gocpp::recv(r), 1);
        }
        else
        {
            r = gocpp::InitPtr<Rand>([](Rand& x) { x.src = new runtimeSource {}; x.s64 = new runtimeSource {}; });
        }
        if(! CompareAndSwap(gocpp::recv(globalRandGenerator), nullptr, r))
        {
            return Load(gocpp::recv(globalRandGenerator));
        }
        return r;
    }

    uint64_t runtime_rand()
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeSource::operator T()
    {
        T result;
        result.mu = this->mu;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeSource::operator==(const T& ref) const
    {
        if (mu != ref.mu) return false;
        return true;
    }

    std::ostream& runtimeSource::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeSource& value)
    {
        return value.PrintTo(os);
    }

    int64_t Int63(runtimeSource*)
    {
        return int64_t(runtime_rand() & rngMask);
    }

    void Seed(runtimeSource*, int64_t)
    {
        gocpp::panic("internal error: call to runtimeSource.Seed");
    }

    uint64_t Uint64(runtimeSource*)
    {
        return runtime_rand();
    }

    std::tuple<int, struct gocpp::error> read(struct runtimeSource* fs, gocpp::slice<unsigned char> p, int64_t* readVal, int8_t* readPos)
    {
        int n;
        struct gocpp::error err;
        Lock(gocpp::recv(fs->mu));
        std::tie(n, err) = read(p, fs, readVal, readPos);
        Unlock(gocpp::recv(fs->mu));
        return {n, err};
    }

    void Seed(int64_t seed)
    {
        auto orig = Load(gocpp::recv(globalRandGenerator));
        if(orig != nullptr)
        {
            if(auto [gocpp_id_6, ok] = gocpp::getValue<lockedSource*>(orig->src); ok)
            {
                Seed(gocpp::recv(orig), seed);
                return;
            }
        }
        auto r = New(go_new(lockedSource));
        Seed(gocpp::recv(r), seed);
        if(! CompareAndSwap(gocpp::recv(globalRandGenerator), orig, r))
        {
            Seed(seed);
        }
    }

    int64_t Int63()
    {
        return Int63(gocpp::recv(globalRand()));
    }

    uint32_t Uint32()
    {
        return Uint32(gocpp::recv(globalRand()));
    }

    uint64_t Uint64()
    {
        return Uint64(gocpp::recv(globalRand()));
    }

    int32_t Int31()
    {
        return Int31(gocpp::recv(globalRand()));
    }

    int Int()
    {
        return Int(gocpp::recv(globalRand()));
    }

    int64_t Int63n(int64_t n)
    {
        return Int63n(gocpp::recv(globalRand()), n);
    }

    int32_t Int31n(int32_t n)
    {
        return Int31n(gocpp::recv(globalRand()), n);
    }

    int Intn(int n)
    {
        return Intn(gocpp::recv(globalRand()), n);
    }

    double Float64()
    {
        return Float64(gocpp::recv(globalRand()));
    }

    double Float32()
    {
        return Float32(gocpp::recv(globalRand()));
    }

    gocpp::slice<int> Perm(int n)
    {
        return Perm(gocpp::recv(globalRand()), n);
    }

    void Shuffle(int n, std::function<void (int i, int j)> swap)
    {
        Shuffle(gocpp::recv(globalRand()), n, swap);
    }

    std::tuple<int, struct gocpp::error> Read(gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        return Read(gocpp::recv(globalRand()), p);
    }

    double NormFloat64()
    {
        return NormFloat64(gocpp::recv(globalRand()));
    }

    double ExpFloat64()
    {
        return ExpFloat64(gocpp::recv(globalRand()));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    lockedSource::operator T()
    {
        T result;
        result.lk = this->lk;
        result.s = this->s;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool lockedSource::operator==(const T& ref) const
    {
        if (lk != ref.lk) return false;
        if (s != ref.s) return false;
        return true;
    }

    std::ostream& lockedSource::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lk;
        os << " " << s;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct lockedSource& value)
    {
        return value.PrintTo(os);
    }

    int64_t Int63(struct lockedSource* r)
    {
        int64_t n;
        Lock(gocpp::recv(r->lk));
        n = Int63(gocpp::recv(r->s));
        Unlock(gocpp::recv(r->lk));
        return n;
    }

    uint64_t Uint64(struct lockedSource* r)
    {
        uint64_t n;
        Lock(gocpp::recv(r->lk));
        n = Uint64(gocpp::recv(r->s));
        Unlock(gocpp::recv(r->lk));
        return n;
    }

    void Seed(struct lockedSource* r, int64_t seed)
    {
        Lock(gocpp::recv(r->lk));
        seed(gocpp::recv(r), seed);
        Unlock(gocpp::recv(r->lk));
    }

    void seedPos(struct lockedSource* r, int64_t seed, int8_t* readPos)
    {
        Lock(gocpp::recv(r->lk));
        seed(gocpp::recv(r), seed);
        *readPos = 0;
        Unlock(gocpp::recv(r->lk));
    }

    void seed(struct lockedSource* r, int64_t seed)
    {
        if(r->s == nullptr)
        {
            r->s = newSource(seed);
        }
        else
        {
            Seed(gocpp::recv(r->s), seed);
        }
    }

    std::tuple<int, struct gocpp::error> read(struct lockedSource* r, gocpp::slice<unsigned char> p, int64_t* readVal, int8_t* readPos)
    {
        int n;
        struct gocpp::error err;
        Lock(gocpp::recv(r->lk));
        std::tie(n, err) = read(p, r->s, readVal, readPos);
        Unlock(gocpp::recv(r->lk));
        return {n, err};
    }

}

