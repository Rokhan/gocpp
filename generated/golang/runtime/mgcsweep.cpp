// generated by GoCpp from file '$(ImportDir)/runtime/mgcsweep.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcsweep.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mem.h"
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    sweepdata sweep;
    
    std::ostream& sweepdata::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << g;
        os << " " << parked;
        os << " " << active;
        os << " " << centralIndex;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sweepdata& value)
    {
        return value.PrintTo(os);
    }

    sweepClass load(sweepClass* s)
    {
        return sweepClass(atomic::Load((uint32_t*)(s)));
    }

    void update(sweepClass* s, sweepClass sNew)
    {
        auto sOld = load(gocpp::recv(s));
        for(; sOld < sNew && ! atomic::Cas((uint32_t*)(s), uint32_t(sOld), uint32_t(sNew)); )
        {
            sOld = load(gocpp::recv(s));
        }
    }

    void clear(sweepClass* s)
    {
        atomic::Store((uint32_t*)(s), 0);
    }

    std::tuple<spanClass, bool> split(sweepClass s)
    {
        spanClass spc;
        bool full;
        return {spanClass(s >> 1), s & 1 == 0};
    }

    mspan* nextSpanForSweep(struct mheap* h)
    {
        auto sg = h->sweepgen;
        for(auto sc = load(gocpp::recv(sweep.centralIndex)); sc < numSweepClasses; sc++)
        {
            auto [spc, full] = split(gocpp::recv(sc));
            auto c = & h->central[spc].mcentral;
            mspan* s = {};
            if(full)
            {
                s = pop(gocpp::recv(fullUnswept(gocpp::recv(c), sg)));
            }
            else
            {
                s = pop(gocpp::recv(partialUnswept(gocpp::recv(c), sg)));
            }
            if(s != nullptr)
            {
                update(gocpp::recv(sweep.centralIndex), sc);
                return s;
            }
        }
        update(gocpp::recv(sweep.centralIndex), sweepClassDone);
        return nullptr;
    }

    
    std::ostream& activeSweep::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << state;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct activeSweep& value)
    {
        return value.PrintTo(os);
    }

    sweepLocker begin(struct activeSweep* a)
    {
        for(; ; )
        {
            auto state = Load(gocpp::recv(a->state));
            if(state & sweepDrainedMask != 0)
            {
                return sweepLocker {mheap_.sweepgen, false};
            }
            if(CompareAndSwap(gocpp::recv(a->state), state, state + 1))
            {
                return sweepLocker {mheap_.sweepgen, true};
            }
        }
    }

    void end(struct activeSweep* a, sweepLocker sl)
    {
        if(sl.sweepGen != mheap_.sweepgen)
        {
            go_throw("sweeper left outstanding across sweep generations");
        }
        for(; ; )
        {
            auto state = Load(gocpp::recv(a->state));
            if((state &^ sweepDrainedMask) - 1 >= sweepDrainedMask)
            {
                go_throw("mismatched begin/end of activeSweep");
            }
            if(CompareAndSwap(gocpp::recv(a->state), state, state - 1))
            {
                if(state != sweepDrainedMask)
                {
                    return;
                }
                if(debug.gcpacertrace > 0)
                {
                    auto live = Load(gocpp::recv(gcController.heapLive));
                    print("pacer: sweep done at heap size ", live >> 20, "MB; allocated ", (live - mheap_.sweepHeapLiveBasis) >> 20, "MB during sweep; swept ", Load(gocpp::recv(mheap_.pagesSwept)), " pages at ", mheap_.sweepPagesPerByte, " pages/byte\n");
                }
                return;
            }
        }
    }

    bool markDrained(struct activeSweep* a)
    {
        for(; ; )
        {
            auto state = Load(gocpp::recv(a->state));
            if(state & sweepDrainedMask != 0)
            {
                return false;
            }
            if(CompareAndSwap(gocpp::recv(a->state), state, state | sweepDrainedMask))
            {
                return true;
            }
        }
    }

    uint32_t sweepers(struct activeSweep* a)
    {
        return Load(gocpp::recv(a->state)) &^ sweepDrainedMask;
    }

    bool isDone(struct activeSweep* a)
    {
        return Load(gocpp::recv(a->state)) == sweepDrainedMask;
    }

    void reset(struct activeSweep* a)
    {
        assertWorldStopped();
        Store(gocpp::recv(a->state), 0);
    }

    void finishsweep_m()
    {
        assertWorldStopped();
        for(; sweepone() != ~ uintptr_t(0); )
        {
        }
        if(sweepers(gocpp::recv(sweep.active)) != 0)
        {
            go_throw("active sweepers found at start of mark phase");
        }
        auto sg = mheap_.sweepgen;
        for(auto [i, gocpp_ignored] : mheap_.central)
        {
            auto c = & mheap_.central[i].mcentral;
            reset(gocpp::recv(partialUnswept(gocpp::recv(c), sg)));
            reset(gocpp::recv(fullUnswept(gocpp::recv(c), sg)));
        }
        wake(gocpp::recv(scavenger));
        nextMarkBitArenaEpoch();
    }

    void bgsweep(gocpp::channel<int> c)
    {
        sweep.g = getg();
        lockInit(& sweep.lock, lockRankSweep);
        lock(& sweep.lock);
        sweep.parked = true;
        c.send(1);
        goparkunlock(& sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, 1);
        for(; ; )
        {
            auto sweepBatchSize = 10;
            auto nSwept = 0;
            for(; sweepone() != ~ uintptr_t(0); )
            {
                nSwept++;
                if(nSwept % sweepBatchSize == 0)
                {
                    goschedIfBusy();
                }
            }
            for(; freeSomeWbufs(true); )
            {
                goschedIfBusy();
            }
            lock(& sweep.lock);
            if(! isSweepDone())
            {
                unlock(& sweep.lock);
                continue;
            }
            sweep.parked = true;
            goparkunlock(& sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, 1);
        }
    }

    
    std::ostream& sweepLocker::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << sweepGen;
        os << " " << valid;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sweepLocker& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& sweepLocked::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sweepLocked& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<sweepLocked, bool> tryAcquire(struct sweepLocker* l, mspan* s)
    {
        if(! l->valid)
        {
            go_throw("use of invalid sweepLocker");
        }
        if(atomic::Load(& s->sweepgen) != l->sweepGen - 2)
        {
            return {sweepLocked {}, false};
        }
        if(! atomic::Cas(& s->sweepgen, l->sweepGen - 2, l->sweepGen - 1))
        {
            return {sweepLocked {}, false};
        }
        return {sweepLocked {s}, true};
    }

    uintptr_t sweepone()
    {
        auto gp = getg();
        gp->m->locks++;
        auto sl = begin(gocpp::recv(sweep.active));
        if(! sl.valid)
        {
            gp->m->locks--;
            return ~ uintptr_t(0);
        }
        auto npages = ~ uintptr_t(0);
        bool noMoreWork = {};
        for(; ; )
        {
            auto s = nextSpanForSweep(gocpp::recv(mheap_));
            if(s == nullptr)
            {
                noMoreWork = markDrained(gocpp::recv(sweep.active));
                break;
            }
            if(auto state = get(gocpp::recv(s->state)); state != mSpanInUse)
            {
                if(! (s->sweepgen == sl.sweepGen || s->sweepgen == sl.sweepGen + 3))
                {
                    print("runtime: bad span s.state=", state, " s.sweepgen=", s->sweepgen, " sweepgen=", sl.sweepGen, "\n");
                    go_throw("non in-use span in unswept list");
                }
                continue;
            }
            if(auto [s, ok] = tryAcquire(gocpp::recv(sl), s); ok)
            {
                npages = s->npages;
                if(sweep(gocpp::recv(s), false))
                {
                    Add(gocpp::recv(mheap_.reclaimCredit), npages);
                }
                else
                {
                    npages = 0;
                }
                break;
            }
        }
        end(gocpp::recv(sweep.active), sl);
        if(noMoreWork)
        {
            if(debug.scavtrace > 0)
            {
                systemstack([=]() mutable -> void
                {
                    lock(& mheap_.lock);
                    auto releasedBg = Load(gocpp::recv(mheap_.pages.scav.releasedBg));
                    auto releasedEager = Load(gocpp::recv(mheap_.pages.scav.releasedEager));
                    printScavTrace(releasedBg, releasedEager, false);
                    Add(gocpp::recv(mheap_.pages.scav.releasedBg), - releasedBg);
                    Add(gocpp::recv(mheap_.pages.scav.releasedEager), - releasedEager);
                    unlock(& mheap_.lock);
                }
);
            }
            ready(gocpp::recv(scavenger));
        }
        gp->m->locks--;
        return npages;
    }

    bool isSweepDone()
    {
        return isDone(gocpp::recv(sweep.active));
    }

    void ensureSwept(struct mspan* s)
    {
        auto gp = getg();
        if(gp->m->locks == 0 && gp->m->mallocing == 0 && gp != gp->m->g0)
        {
            go_throw("mspan.ensureSwept: m is not locked");
        }
        auto sl = begin(gocpp::recv(sweep.active));
        if(sl.valid)
        {
            if(auto [s, ok] = tryAcquire(gocpp::recv(sl), s); ok)
            {
                sweep(gocpp::recv(s), false);
                end(gocpp::recv(sweep.active), sl);
                return;
            }
            end(gocpp::recv(sweep.active), sl);
        }
        for(; ; )
        {
            auto spangen = atomic::Load(& s->sweepgen);
            if(spangen == sl.sweepGen || spangen == sl.sweepGen + 3)
            {
                break;
            }
            osyield();
        }
    }

    bool sweep(struct sweepLocked* sl, bool preserve)
    {
        auto gp = getg();
        if(gp->m->locks == 0 && gp->m->mallocing == 0 && gp != gp->m->g0)
        {
            go_throw("mspan.sweep: m is not locked");
        }
        auto s = sl->mspan;
        if(! preserve)
        {
            sl->mspan = nullptr;
        }
        auto sweepgen = mheap_.sweepgen;
        if(auto state = get(gocpp::recv(s->state)); state != mSpanInUse || s->sweepgen != sweepgen - 1)
        {
            print("mspan.sweep: state=", state, " sweepgen=", s->sweepgen, " mheap.sweepgen=", sweepgen, "\n");
            go_throw("mspan.sweep: bad span state");
        }
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepSpan(gocpp::recv(trace), s->npages * _PageSize);
            traceRelease(trace);
        }
        Add(gocpp::recv(mheap_.pagesSwept), int64_t(s->npages));
        auto spc = s->spanclass;
        auto size = s->elemsize;
        auto hadSpecials = s->specials != nullptr;
        auto siter = newSpecialsIter(s);
        for(; valid(gocpp::recv(siter)); )
        {
            auto objIndex = uintptr_t(siter.s->offset) / size;
            auto p = base(gocpp::recv(s)) + objIndex * size;
            auto mbits = markBitsForIndex(gocpp::recv(s), objIndex);
            if(! isMarked(gocpp::recv(mbits)))
            {
                auto hasFin = false;
                auto endOffset = p - base(gocpp::recv(s)) + size;
                for(auto tmp = siter.s; tmp != nullptr && uintptr_t(tmp->offset) < endOffset; tmp = tmp->next)
                {
                    if(tmp->kind == _KindSpecialFinalizer)
                    {
                        setMarkedNonAtomic(gocpp::recv(mbits));
                        hasFin = true;
                        break;
                    }
                }
                for(; valid(gocpp::recv(siter)) && uintptr_t(siter.s->offset) < endOffset; )
                {
                    auto special = siter.s;
                    auto p = base(gocpp::recv(s)) + uintptr_t(special->offset);
                    if(special->kind == _KindSpecialFinalizer || ! hasFin)
                    {
                        unlinkAndNext(gocpp::recv(siter));
                        freeSpecial(special, unsafe::Pointer(p), size);
                    }
                    else
                    {
                        next(gocpp::recv(siter));
                    }
                }
            }
            else
            {
                if(siter.s->kind == _KindSpecialReachable)
                {
                    auto special = unlinkAndNext(gocpp::recv(siter));
                    (specialReachable*)(unsafe::Pointer(special))->reachable = true;
                    freeSpecial(special, unsafe::Pointer(p), size);
                }
                else
                {
                    next(gocpp::recv(siter));
                }
            }
        }
        if(hadSpecials && s->specials == nullptr)
        {
            spanHasNoSpecials(s);
        }
        if(debug.allocfreetrace != 0 || debug.clobberfree != 0 || raceenabled || msanenabled || asanenabled)
        {
            auto mbits = markBitsForBase(gocpp::recv(s));
            auto abits = allocBitsForIndex(gocpp::recv(s), 0);
            for(auto i = uintptr_t(0); i < uintptr_t(s->nelems); i++)
            {
                if(! isMarked(gocpp::recv(mbits)) && (abits.index < uintptr_t(s->freeindex) || isMarked(gocpp::recv(abits))))
                {
                    auto x = base(gocpp::recv(s)) + i * s->elemsize;
                    if(debug.allocfreetrace != 0)
                    {
                        tracefree(unsafe::Pointer(x), size);
                    }
                    if(debug.clobberfree != 0)
                    {
                        clobberfree(unsafe::Pointer(x), size);
                    }
                    if(raceenabled && ! s->isUserArenaChunk)
                    {
                        racefree(unsafe::Pointer(x), size);
                    }
                    if(msanenabled && ! s->isUserArenaChunk)
                    {
                        msanfree(unsafe::Pointer(x), size);
                    }
                    if(asanenabled && ! s->isUserArenaChunk)
                    {
                        asanpoison(unsafe::Pointer(x), size);
                    }
                }
                advance(gocpp::recv(mbits));
                advance(gocpp::recv(abits));
            }
        }
        if(s->freeindex < s->nelems)
        {
            auto obj = uintptr_t(s->freeindex);
            if(((*bytep(gocpp::recv(s->gcmarkBits), obj / 8) &^ *bytep(gocpp::recv(s->allocBits), obj / 8)) >> (obj % 8)) != 0)
            {
                reportZombies(gocpp::recv(s));
            }
            for(auto i = obj / 8 + 1; i < divRoundUp(uintptr_t(s->nelems), 8); i++)
            {
                if(*bytep(gocpp::recv(s->gcmarkBits), i) &^ *bytep(gocpp::recv(s->allocBits), i) != 0)
                {
                    reportZombies(gocpp::recv(s));
                }
            }
        }
        auto nalloc = uint16_t(countAlloc(gocpp::recv(s)));
        auto nfreed = s->allocCount - nalloc;
        if(nalloc > s->allocCount)
        {
            print("runtime: nelems=", s->nelems, " nalloc=", nalloc, " previous allocCount=", s->allocCount, " nfreed=", nfreed, "\n");
            go_throw("sweep increased allocation count");
        }
        s->allocCount = nalloc;
        s->freeindex = 0;
        s->freeIndexForScan = 0;
        if(traceEnabled())
        {
            ptr(gocpp::recv(getg()->m->p))->trace.reclaimed += uintptr_t(nfreed) * s->elemsize;
        }
        s->allocBits = s->gcmarkBits;
        s->gcmarkBits = newMarkBits(uintptr_t(s->nelems));
        if(s->pinnerBits != nullptr)
        {
            refreshPinnerBits(gocpp::recv(s));
        }
        refillAllocCache(gocpp::recv(s), 0);
        if(auto state = get(gocpp::recv(s->state)); state != mSpanInUse || s->sweepgen != sweepgen - 1)
        {
            print("mspan.sweep: state=", state, " sweepgen=", s->sweepgen, " mheap.sweepgen=", sweepgen, "\n");
            go_throw("mspan.sweep: bad span state after sweep");
        }
        if(s->sweepgen == sweepgen + 1 || s->sweepgen == sweepgen + 3)
        {
            go_throw("swept cached span");
        }
        atomic::Store(& s->sweepgen, sweepgen);
        if(s->isUserArenaChunk)
        {
            if(preserve)
            {
                go_throw("sweep: tried to preserve a user arena span");
            }
            if(nalloc > 0)
            {
                push(gocpp::recv(fullSwept(gocpp::recv(mheap_.central[spc].mcentral), sweepgen)), s);
                return false;
            }
            Add(gocpp::recv(mheap_.pagesInUse), - s->npages);
            set(gocpp::recv(s->state), mSpanDead);
            systemstack([=]() mutable -> void
            {
                if(s->list != & mheap_.userArena.quarantineList)
                {
                    go_throw("user arena span is on the wrong list");
                }
                lock(& mheap_.lock);
                remove(gocpp::recv(mheap_.userArena.quarantineList), s);
                insert(gocpp::recv(mheap_.userArena.readyList), s);
                unlock(& mheap_.lock);
            }
);
            return false;
        }
        if(sizeclass(gocpp::recv(spc)) != 0)
        {
            if(nfreed > 0)
            {
                s->needzero = 1;
                auto stats = acquire(gocpp::recv(memstats.heapStats));
                atomic::Xadd64(& stats->smallFreeCount[sizeclass(gocpp::recv(spc))], int64_t(nfreed));
                release(gocpp::recv(memstats.heapStats));
                Add(gocpp::recv(gcController.totalFree), int64_t(nfreed) * int64_t(s->elemsize));
            }
            if(! preserve)
            {
                if(nalloc == 0)
                {
                    freeSpan(gocpp::recv(mheap_), s);
                    return true;
                }
                if(nalloc == s->nelems)
                {
                    push(gocpp::recv(fullSwept(gocpp::recv(mheap_.central[spc].mcentral), sweepgen)), s);
                }
                else
                {
                    push(gocpp::recv(partialSwept(gocpp::recv(mheap_.central[spc].mcentral), sweepgen)), s);
                }
            }
        }
        else
        if(! preserve)
        {
            if(nfreed != 0)
            {
                if(debug.efence > 0)
                {
                    s->limit = 0;
                    sysFault(unsafe::Pointer(base(gocpp::recv(s))), size);
                }
                else
                {
                    freeSpan(gocpp::recv(mheap_), s);
                }
                if(goexperiment::AllocHeaders && s->largeType != nullptr && s->largeType->TFlag & abi::TFlagUnrolledBitmap != 0)
                {
                    systemstack([=]() mutable -> void
                    {
                        auto s = spanOf(uintptr_t(unsafe::Pointer(s->largeType)));
                        freeManual(gocpp::recv(mheap_), s, spanAllocPtrScalarBits);
                    }
);
                    *(uintptr_t*)(unsafe::Pointer(& s->largeType)) = 0;
                }
                auto stats = acquire(gocpp::recv(memstats.heapStats));
                atomic::Xadd64(& stats->largeFreeCount, 1);
                atomic::Xadd64(& stats->largeFree, int64_t(size));
                release(gocpp::recv(memstats.heapStats));
                Add(gocpp::recv(gcController.totalFree), int64_t(size));
                return true;
            }
            push(gocpp::recv(fullSwept(gocpp::recv(mheap_.central[spc].mcentral), sweepgen)), s);
        }
        return false;
    }

    void reportZombies(struct mspan* s)
    {
        printlock();
        print("runtime: marked free object in span ", s, ", elemsize=", s->elemsize, " freeindex=", s->freeindex, " (bad use of unsafe.Pointer? try -d=checkptr)\n");
        auto mbits = markBitsForBase(gocpp::recv(s));
        auto abits = allocBitsForIndex(gocpp::recv(s), 0);
        for(auto i = uintptr_t(0); i < uintptr_t(s->nelems); i++)
        {
            auto addr = base(gocpp::recv(s)) + i * s->elemsize;
            print(hex(addr));
            auto alloc = i < uintptr_t(s->freeindex) || isMarked(gocpp::recv(abits));
            if(alloc)
            {
                print(" alloc");
            }
            else
            {
                print(" free ");
            }
            if(isMarked(gocpp::recv(mbits)))
            {
                print(" marked  ");
            }
            else
            {
                print(" unmarked");
            }
            auto zombie = isMarked(gocpp::recv(mbits)) && ! alloc;
            if(zombie)
            {
                print(" zombie");
            }
            print("\n");
            if(zombie)
            {
                auto length = s->elemsize;
                if(length > 1024)
                {
                    length = 1024;
                }
                hexdumpWords(addr, addr + length, nullptr);
            }
            advance(gocpp::recv(mbits));
            advance(gocpp::recv(abits));
        }
        go_throw("found pointer to free object");
    }

    void deductSweepCredit(uintptr_t spanBytes, uintptr_t callerSweepPages)
    {
        if(mheap_.sweepPagesPerByte == 0)
        {
            return;
        }
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepStart(gocpp::recv(trace));
            traceRelease(trace);
        }
        retry:
        auto sweptBasis = Load(gocpp::recv(mheap_.pagesSweptBasis));
        auto live = Load(gocpp::recv(gcController.heapLive));
        auto liveBasis = mheap_.sweepHeapLiveBasis;
        auto newHeapLive = spanBytes;
        if(liveBasis < live)
        {
            newHeapLive += uintptr_t(live - liveBasis);
        }
        auto pagesTarget = int64_t(mheap_.sweepPagesPerByte * double(newHeapLive)) - int64_t(callerSweepPages);
        for(; pagesTarget > int64_t(Load(gocpp::recv(mheap_.pagesSwept)) - sweptBasis); )
        {
            if(sweepone() == ~ uintptr_t(0))
            {
                mheap_.sweepPagesPerByte = 0;
                break;
            }
            if(Load(gocpp::recv(mheap_.pagesSweptBasis)) != sweptBasis)
            {
                goto retry;
            }
        }
        trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepDone(gocpp::recv(trace));
            traceRelease(trace);
        }
    }

    void clobberfree(unsafe::Pointer x, uintptr_t size)
    {
        for(auto i = uintptr_t(0); i < size; i += 4)
        {
            *(uint32_t*)(add(x, i)) = 0xdeadbeef;
        }
    }

    void gcPaceSweeper(uint64_t trigger)
    {
        assertWorldStoppedOrLockHeld(& mheap_.lock);
        if(isSweepDone())
        {
            mheap_.sweepPagesPerByte = 0;
        }
        else
        {
            auto heapLiveBasis = Load(gocpp::recv(gcController.heapLive));
            auto heapDistance = int64_t(trigger) - int64_t(heapLiveBasis);
            heapDistance -= 1024 * 1024;
            if(heapDistance < _PageSize)
            {
                heapDistance = _PageSize;
            }
            auto pagesSwept = Load(gocpp::recv(mheap_.pagesSwept));
            auto pagesInUse = Load(gocpp::recv(mheap_.pagesInUse));
            auto sweepDistancePages = int64_t(pagesInUse) - int64_t(pagesSwept);
            if(sweepDistancePages <= 0)
            {
                mheap_.sweepPagesPerByte = 0;
            }
            else
            {
                mheap_.sweepPagesPerByte = double(sweepDistancePages) / double(heapDistance);
                mheap_.sweepHeapLiveBasis = heapLiveBasis;
                Store(gocpp::recv(mheap_.pagesSweptBasis), pagesSwept);
            }
        }
    }

}

