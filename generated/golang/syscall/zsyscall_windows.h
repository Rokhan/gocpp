// generated by GoCpp from file '$(ImportDir)/syscall/zsyscall_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/zsyscall_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/sysdll/sysdll.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    extern std::string errERROR_IO_PENDING;
    extern std::string errERROR_EINVAL;
    std::string errnoErr(Errno e);
    extern LazyDLL* modadvapi32;
    extern LazyDLL* modcrypt32;
    extern LazyDLL* moddnsapi;
    extern LazyDLL* modiphlpapi;
    extern LazyDLL* modkernel32;
    extern LazyDLL* modmswsock;
    extern LazyDLL* modnetapi32;
    extern LazyDLL* modntdll;
    extern LazyDLL* modsecur32;
    extern LazyDLL* modshell32;
    extern LazyDLL* moduserenv;
    extern LazyDLL* modws2_32;
    extern LazyProc* procConvertSidToStringSidW;
    extern LazyProc* procConvertStringSidToSidW;
    extern LazyProc* procCopySid;
    extern LazyProc* procCreateProcessAsUserW;
    extern LazyProc* procCryptAcquireContextW;
    extern LazyProc* procCryptGenRandom;
    extern LazyProc* procCryptReleaseContext;
    extern LazyProc* procGetLengthSid;
    extern LazyProc* procGetTokenInformation;
    extern LazyProc* procLookupAccountNameW;
    extern LazyProc* procLookupAccountSidW;
    extern LazyProc* procOpenProcessToken;
    extern LazyProc* procRegCloseKey;
    extern LazyProc* procRegEnumKeyExW;
    extern LazyProc* procRegOpenKeyExW;
    extern LazyProc* procRegQueryInfoKeyW;
    extern LazyProc* procRegQueryValueExW;
    extern LazyProc* procCertAddCertificateContextToStore;
    extern LazyProc* procCertCloseStore;
    extern LazyProc* procCertCreateCertificateContext;
    extern LazyProc* procCertEnumCertificatesInStore;
    extern LazyProc* procCertFreeCertificateChain;
    extern LazyProc* procCertFreeCertificateContext;
    extern LazyProc* procCertGetCertificateChain;
    extern LazyProc* procCertOpenStore;
    extern LazyProc* procCertOpenSystemStoreW;
    extern LazyProc* procCertVerifyCertificateChainPolicy;
    extern LazyProc* procDnsNameCompare_W;
    extern LazyProc* procDnsQuery_W;
    extern LazyProc* procDnsRecordListFree;
    extern LazyProc* procGetAdaptersInfo;
    extern LazyProc* procGetIfEntry;
    extern LazyProc* procCancelIo;
    extern LazyProc* procCancelIoEx;
    extern LazyProc* procCloseHandle;
    extern LazyProc* procCreateDirectoryW;
    extern LazyProc* procCreateFileMappingW;
    extern LazyProc* procCreateFileW;
    extern LazyProc* procCreateHardLinkW;
    extern LazyProc* procCreateIoCompletionPort;
    extern LazyProc* procCreatePipe;
    extern LazyProc* procCreateProcessW;
    extern LazyProc* procCreateSymbolicLinkW;
    extern LazyProc* procCreateToolhelp32Snapshot;
    extern LazyProc* procDeleteFileW;
    extern LazyProc* procDeleteProcThreadAttributeList;
    extern LazyProc* procDeviceIoControl;
    extern LazyProc* procDuplicateHandle;
    extern LazyProc* procExitProcess;
    extern LazyProc* procFindClose;
    extern LazyProc* procFindFirstFileW;
    extern LazyProc* procFindNextFileW;
    extern LazyProc* procFlushFileBuffers;
    extern LazyProc* procFlushViewOfFile;
    extern LazyProc* procFormatMessageW;
    extern LazyProc* procFreeEnvironmentStringsW;
    extern LazyProc* procFreeLibrary;
    extern LazyProc* procGetCommandLineW;
    extern LazyProc* procGetComputerNameW;
    extern LazyProc* procGetConsoleMode;
    extern LazyProc* procGetCurrentDirectoryW;
    extern LazyProc* procGetCurrentProcess;
    extern LazyProc* procGetCurrentProcessId;
    extern LazyProc* procGetEnvironmentStringsW;
    extern LazyProc* procGetEnvironmentVariableW;
    extern LazyProc* procGetExitCodeProcess;
    extern LazyProc* procGetFileAttributesExW;
    extern LazyProc* procGetFileAttributesW;
    extern LazyProc* procGetFileInformationByHandle;
    extern LazyProc* procGetFileType;
    extern LazyProc* procGetFinalPathNameByHandleW;
    extern LazyProc* procGetFullPathNameW;
    extern LazyProc* procGetLastError;
    extern LazyProc* procGetLongPathNameW;
    extern LazyProc* procGetProcAddress;
    extern LazyProc* procGetProcessTimes;
    extern LazyProc* procGetQueuedCompletionStatus;
    extern LazyProc* procGetShortPathNameW;
    extern LazyProc* procGetStartupInfoW;
    extern LazyProc* procGetStdHandle;
    extern LazyProc* procGetSystemTimeAsFileTime;
    extern LazyProc* procGetTempPathW;
    extern LazyProc* procGetTimeZoneInformation;
    extern LazyProc* procGetVersion;
    extern LazyProc* procInitializeProcThreadAttributeList;
    extern LazyProc* procLoadLibraryW;
    extern LazyProc* procLocalFree;
    extern LazyProc* procMapViewOfFile;
    extern LazyProc* procMoveFileW;
    extern LazyProc* procOpenProcess;
    extern LazyProc* procPostQueuedCompletionStatus;
    extern LazyProc* procProcess32FirstW;
    extern LazyProc* procProcess32NextW;
    extern LazyProc* procReadConsoleW;
    extern LazyProc* procReadDirectoryChangesW;
    extern LazyProc* procReadFile;
    extern LazyProc* procRemoveDirectoryW;
    extern LazyProc* procSetCurrentDirectoryW;
    extern LazyProc* procSetEndOfFile;
    extern LazyProc* procSetEnvironmentVariableW;
    extern LazyProc* procSetFileAttributesW;
    extern LazyProc* procSetFileCompletionNotificationModes;
    extern LazyProc* procSetFilePointer;
    extern LazyProc* procSetFileTime;
    extern LazyProc* procSetHandleInformation;
    extern LazyProc* procTerminateProcess;
    extern LazyProc* procUnmapViewOfFile;
    extern LazyProc* procUpdateProcThreadAttribute;
    extern LazyProc* procVirtualLock;
    extern LazyProc* procVirtualUnlock;
    extern LazyProc* procWaitForSingleObject;
    extern LazyProc* procWriteConsoleW;
    extern LazyProc* procWriteFile;
    extern LazyProc* procAcceptEx;
    extern LazyProc* procGetAcceptExSockaddrs;
    extern LazyProc* procTransmitFile;
    extern LazyProc* procNetApiBufferFree;
    extern LazyProc* procNetGetJoinInformation;
    extern LazyProc* procNetUserGetInfo;
    extern LazyProc* procRtlGetNtVersionNumbers;
    extern LazyProc* procGetUserNameExW;
    extern LazyProc* procTranslateNameW;
    extern LazyProc* procCommandLineToArgvW;
    extern LazyProc* procGetUserProfileDirectoryW;
    extern LazyProc* procFreeAddrInfoW;
    extern LazyProc* procGetAddrInfoW;
    extern LazyProc* procWSACleanup;
    extern LazyProc* procWSAEnumProtocolsW;
    extern LazyProc* procWSAIoctl;
    extern LazyProc* procWSARecv;
    extern LazyProc* procWSARecvFrom;
    extern LazyProc* procWSASend;
    extern LazyProc* procWSASendTo;
    extern LazyProc* procWSAStartup;
    extern LazyProc* procbind;
    extern LazyProc* procclosesocket;
    extern LazyProc* procconnect;
    extern LazyProc* procgethostbyname;
    extern LazyProc* procgetpeername;
    extern LazyProc* procgetprotobyname;
    extern LazyProc* procgetservbyname;
    extern LazyProc* procgetsockname;
    extern LazyProc* procgetsockopt;
    extern LazyProc* proclisten;
    extern LazyProc* procntohs;
    extern LazyProc* procsetsockopt;
    extern LazyProc* procshutdown;
    extern LazyProc* procsocket;
    std::string ConvertSidToStringSid(SID* sid, uint16_t** stringSid);
    std::string ConvertStringSidToSid(uint16_t* stringSid, SID** sid);
    std::string CopySid(uint32_t destSidLen, SID* destSid, SID* srcSid);
    std::string CreateProcessAsUser(Token token, uint16_t* appName, uint16_t* commandLine, SecurityAttributes* procSecurity, SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, StartupInfo* startupInfo, ProcessInformation* outProcInfo);
    std::string CryptAcquireContext(Handle* provhandle, uint16_t* container, uint16_t* provider, uint32_t provtype, uint32_t flags);
    std::string CryptGenRandom(Handle provhandle, uint32_t buflen, unsigned char* buf);
    std::string CryptReleaseContext(Handle provhandle, uint32_t flags);
    uint32_t GetLengthSid(SID* sid);
    std::string GetTokenInformation(Token t, uint32_t infoClass, unsigned char* info, uint32_t infoLen, uint32_t* returnedLen);
    std::string LookupAccountName(uint16_t* systemName, uint16_t* accountName, SID* sid, uint32_t* sidLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use);
    std::string LookupAccountSid(uint16_t* systemName, SID* sid, uint16_t* name, uint32_t* nameLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use);
    std::string OpenProcessToken(Handle h, uint32_t access, Token* token);
    std::string RegCloseKey(Handle key);
    std::string regEnumKeyEx(Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, Filetime* lastWriteTime);
    std::string RegOpenKeyEx(Handle key, uint16_t* subkey, uint32_t options, uint32_t desiredAccess, Handle* result);
    std::string RegQueryInfoKey(Handle key, uint16_t* go_class, uint32_t* classLen, uint32_t* reserved, uint32_t* subkeysLen, uint32_t* maxSubkeyLen, uint32_t* maxClassLen, uint32_t* valuesLen, uint32_t* maxValueNameLen, uint32_t* maxValueLen, uint32_t* saLen, Filetime* lastWriteTime);
    std::string RegQueryValueEx(Handle key, uint16_t* name, uint32_t* reserved, uint32_t* valtype, unsigned char* buf, uint32_t* buflen);
    std::string CertAddCertificateContextToStore(Handle store, CertContext* certContext, uint32_t addDisposition, CertContext** storeContext);
    std::string CertCloseStore(Handle store, uint32_t flags);
    std::tuple<CertContext*, std::string> CertCreateCertificateContext(uint32_t certEncodingType, unsigned char* certEncoded, uint32_t encodedLen);
    std::tuple<CertContext*, std::string> CertEnumCertificatesInStore(Handle store, CertContext* prevContext);
    void CertFreeCertificateChain(CertChainContext* ctx);
    std::string CertFreeCertificateContext(CertContext* ctx);
    std::string CertGetCertificateChain(Handle engine, CertContext* leaf, Filetime* time, Handle additionalStore, CertChainPara* para, uint32_t flags, uintptr_t reserved, CertChainContext** chainCtx);
    std::tuple<Handle, std::string> CertOpenStore(uintptr_t storeProvider, uint32_t msgAndCertEncodingType, uintptr_t cryptProv, uint32_t flags, uintptr_t para);
    std::tuple<Handle, std::string> CertOpenSystemStore(Handle hprov, uint16_t* name);
    std::string CertVerifyCertificateChainPolicy(uintptr_t policyOID, CertChainContext* chain, CertChainPolicyPara* para, CertChainPolicyStatus* status);
    bool DnsNameCompare(uint16_t* name1, uint16_t* name2);
    std::string DnsQuery(std::string name, uint16_t qtype, uint32_t options, unsigned char* extra, DNSRecord** qrs, unsigned char* pr);
    std::string _DnsQuery(uint16_t* name, uint16_t qtype, uint32_t options, unsigned char* extra, DNSRecord** qrs, unsigned char* pr);
    void DnsRecordListFree(DNSRecord* rl, uint32_t freetype);
    std::string GetAdaptersInfo(IpAdapterInfo* ai, uint32_t* ol);
    std::string GetIfEntry(MibIfRow* pIfRow);
    std::string CancelIo(Handle s);
    std::string CancelIoEx(Handle s, Overlapped* o);
    std::string CloseHandle(Handle handle);
    std::string CreateDirectory(uint16_t* path, SecurityAttributes* sa);
    std::tuple<Handle, std::string> CreateFileMapping(Handle fhandle, SecurityAttributes* sa, uint32_t prot, uint32_t maxSizeHigh, uint32_t maxSizeLow, uint16_t* name);
    std::tuple<Handle, std::string> CreateFile(uint16_t* name, uint32_t access, uint32_t mode, SecurityAttributes* sa, uint32_t createmode, uint32_t attrs, int32_t templatefile);
    std::string CreateHardLink(uint16_t* filename, uint16_t* existingfilename, uintptr_t reserved);
    std::tuple<Handle, std::string> createIoCompletionPort(Handle filehandle, Handle cphandle, uintptr_t key, uint32_t threadcnt);
    std::string CreatePipe(Handle* readhandle, Handle* writehandle, SecurityAttributes* sa, uint32_t size);
    std::string CreateProcess(uint16_t* appName, uint16_t* commandLine, SecurityAttributes* procSecurity, SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, StartupInfo* startupInfo, ProcessInformation* outProcInfo);
    std::string CreateSymbolicLink(uint16_t* symlinkfilename, uint16_t* targetfilename, uint32_t flags);
    std::tuple<Handle, std::string> CreateToolhelp32Snapshot(uint32_t flags, uint32_t processId);
    std::string DeleteFile(uint16_t* path);
    void deleteProcThreadAttributeList(_PROC_THREAD_ATTRIBUTE_LIST* attrlist);
    std::string DeviceIoControl(Handle handle, uint32_t ioControlCode, unsigned char* inBuffer, uint32_t inBufferSize, unsigned char* outBuffer, uint32_t outBufferSize, uint32_t* bytesReturned, Overlapped* overlapped);
    std::string DuplicateHandle(Handle hSourceProcessHandle, Handle hSourceHandle, Handle hTargetProcessHandle, Handle* lpTargetHandle, uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwOptions);
    void ExitProcess(uint32_t exitcode);
    std::string FindClose(Handle handle);
    std::tuple<Handle, std::string> findFirstFile1(uint16_t* name, win32finddata1* data);
    std::string findNextFile1(Handle handle, win32finddata1* data);
    std::string FlushFileBuffers(Handle handle);
    std::string FlushViewOfFile(uintptr_t addr, uintptr_t length);
    std::tuple<uint32_t, std::string> formatMessage(uint32_t flags, uintptr_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args);
    std::string FreeEnvironmentStrings(uint16_t* envs);
    std::string FreeLibrary(Handle handle);
    uint16_t* GetCommandLine();
    std::string GetComputerName(uint16_t* buf, uint32_t* n);
    std::string GetConsoleMode(Handle console, uint32_t* mode);
    std::tuple<uint32_t, std::string> GetCurrentDirectory(uint32_t buflen, uint16_t* buf);
    std::tuple<Handle, std::string> GetCurrentProcess();
    uint32_t getCurrentProcessId();
    std::tuple<uint16_t*, std::string> GetEnvironmentStrings();
    std::tuple<uint32_t, std::string> GetEnvironmentVariable(uint16_t* name, uint16_t* buffer, uint32_t size);
    std::string GetExitCodeProcess(Handle handle, uint32_t* exitcode);
    std::string GetFileAttributesEx(uint16_t* name, uint32_t level, unsigned char* info);
    std::tuple<uint32_t, std::string> GetFileAttributes(uint16_t* name);
    std::string GetFileInformationByHandle(Handle handle, ByHandleFileInformation* data);
    std::tuple<uint32_t, std::string> GetFileType(Handle filehandle);
    std::tuple<uint32_t, std::string> getFinalPathNameByHandle(Handle file, uint16_t* filePath, uint32_t filePathSize, uint32_t flags);
    std::tuple<uint32_t, std::string> GetFullPathName(uint16_t* path, uint32_t buflen, uint16_t* buf, uint16_t** fname);
    std::string GetLastError();
    std::tuple<uint32_t, std::string> GetLongPathName(uint16_t* path, uint16_t* buf, uint32_t buflen);
    std::tuple<uintptr_t, std::string> GetProcAddress(Handle module, std::string procname);
    std::tuple<uintptr_t, std::string> _GetProcAddress(Handle module, unsigned char* procname);
    std::string GetProcessTimes(Handle handle, Filetime* creationTime, Filetime* exitTime, Filetime* kernelTime, Filetime* userTime);
    std::string getQueuedCompletionStatus(Handle cphandle, uint32_t* qty, uintptr_t* key, Overlapped** overlapped, uint32_t timeout);
    std::tuple<uint32_t, std::string> GetShortPathName(uint16_t* longpath, uint16_t* shortpath, uint32_t buflen);
    void getStartupInfo(StartupInfo* startupInfo);
    std::tuple<Handle, std::string> GetStdHandle(int stdhandle);
    void GetSystemTimeAsFileTime(Filetime* time);
    std::tuple<uint32_t, std::string> GetTempPath(uint32_t buflen, uint16_t* buf);
    std::tuple<uint32_t, std::string> GetTimeZoneInformation(Timezoneinformation* tzi);
    std::tuple<uint32_t, std::string> GetVersion();
    std::string initializeProcThreadAttributeList(_PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t attrcount, uint32_t flags, uintptr_t* size);
    std::tuple<Handle, std::string> LoadLibrary(std::string libname);
    std::tuple<Handle, std::string> _LoadLibrary(uint16_t* libname);
    std::tuple<Handle, std::string> LocalFree(Handle hmem);
    std::tuple<uintptr_t, std::string> MapViewOfFile(Handle handle, uint32_t access, uint32_t offsetHigh, uint32_t offsetLow, uintptr_t length);
    std::string MoveFile(uint16_t* from, uint16_t* to);
    std::tuple<Handle, std::string> OpenProcess(uint32_t da, bool inheritHandle, uint32_t pid);
    std::string postQueuedCompletionStatus(Handle cphandle, uint32_t qty, uintptr_t key, Overlapped* overlapped);
    std::string Process32First(Handle snapshot, ProcessEntry32* procEntry);
    std::string Process32Next(Handle snapshot, ProcessEntry32* procEntry);
    std::string ReadConsole(Handle console, uint16_t* buf, uint32_t toread, uint32_t* read, unsigned char* inputControl);
    std::string ReadDirectoryChanges(Handle handle, unsigned char* buf, uint32_t buflen, bool watchSubTree, uint32_t mask, uint32_t* retlen, Overlapped* overlapped, uintptr_t completionRoutine);
    std::string readFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, Overlapped* overlapped);
    std::string RemoveDirectory(uint16_t* path);
    std::string SetCurrentDirectory(uint16_t* path);
    std::string SetEndOfFile(Handle handle);
    std::string SetEnvironmentVariable(uint16_t* name, uint16_t* value);
    std::string SetFileAttributes(uint16_t* name, uint32_t attrs);
    std::string SetFileCompletionNotificationModes(Handle handle, uint8_t flags);
    std::tuple<uint32_t, std::string> SetFilePointer(Handle handle, int32_t lowoffset, int32_t* highoffsetptr, uint32_t whence);
    std::string SetFileTime(Handle handle, Filetime* ctime, Filetime* atime, Filetime* wtime);
    std::string SetHandleInformation(Handle handle, uint32_t mask, uint32_t flags);
    std::string TerminateProcess(Handle handle, uint32_t exitcode);
    std::string UnmapViewOfFile(uintptr_t addr);
    std::string updateProcThreadAttribute(_PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t flags, uintptr_t attr, unsafe::Pointer value, uintptr_t size, unsafe::Pointer prevvalue, uintptr_t* returnedsize);
    std::string VirtualLock(uintptr_t addr, uintptr_t length);
    std::string VirtualUnlock(uintptr_t addr, uintptr_t length);
    std::tuple<uint32_t, std::string> WaitForSingleObject(Handle handle, uint32_t waitMilliseconds);
    std::string WriteConsole(Handle console, uint16_t* buf, uint32_t towrite, uint32_t* written, unsigned char* reserved);
    std::string writeFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, Overlapped* overlapped);
    std::string AcceptEx(Handle ls, Handle as, unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, uint32_t* recvd, Overlapped* overlapped);
    void GetAcceptExSockaddrs(unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, RawSockaddrAny** lrsa, int32_t* lrsalen, RawSockaddrAny** rrsa, int32_t* rrsalen);
    std::string TransmitFile(Handle s, Handle handle, uint32_t bytesToWrite, uint32_t bytsPerSend, Overlapped* overlapped, TransmitFileBuffers* transmitFileBuf, uint32_t flags);
    std::string NetApiBufferFree(unsigned char* buf);
    std::string NetGetJoinInformation(uint16_t* server, uint16_t** name, uint32_t* bufType);
    std::string NetUserGetInfo(uint16_t* serverName, uint16_t* userName, uint32_t level, unsigned char** buf);
    void rtlGetNtVersionNumbers(uint32_t* majorVersion, uint32_t* minorVersion, uint32_t* buildNumber);
    std::string GetUserNameEx(uint32_t nameFormat, uint16_t* nameBuffre, uint32_t* nSize);
    std::string TranslateName(uint16_t* accName, uint32_t accNameFormat, uint32_t desiredNameFormat, uint16_t* translatedName, uint32_t* nSize);
    std::tuple<gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*, std::string> CommandLineToArgv(uint16_t* cmd, int32_t* argc);
    std::string GetUserProfileDirectory(Token t, uint16_t* dir, uint32_t* dirLen);
    void FreeAddrInfoW(AddrinfoW* addrinfo);
    std::string GetAddrInfoW(uint16_t* nodename, uint16_t* servicename, AddrinfoW* hints, AddrinfoW** result);
    std::string WSACleanup();
    std::tuple<int32_t, std::string> WSAEnumProtocols(int32_t* protocols, WSAProtocolInfo* protocolBuffer, uint32_t* bufferLength);
    std::string WSAIoctl(Handle s, uint32_t iocc, unsigned char* inbuf, uint32_t cbif, unsigned char* outbuf, uint32_t cbob, uint32_t* cbbr, Overlapped* overlapped, uintptr_t completionRoutine);
    std::string WSARecv(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, Overlapped* overlapped, unsigned char* croutine);
    std::string WSARecvFrom(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, RawSockaddrAny* from, int32_t* fromlen, Overlapped* overlapped, unsigned char* croutine);
    std::string WSASend(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, Overlapped* overlapped, unsigned char* croutine);
    std::string WSASendTo(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, RawSockaddrAny* to, int32_t tolen, Overlapped* overlapped, unsigned char* croutine);
    std::string WSAStartup(uint32_t verreq, WSAData* data);
    std::string bind(Handle s, unsafe::Pointer name, int32_t namelen);
    std::string Closesocket(Handle s);
    std::string connect(Handle s, unsafe::Pointer name, int32_t namelen);
    std::tuple<Hostent*, std::string> GetHostByName(std::string name);
    std::tuple<Hostent*, std::string> _GetHostByName(unsigned char* name);
    std::string getpeername(Handle s, RawSockaddrAny* rsa, int32_t* addrlen);
    std::tuple<Protoent*, std::string> GetProtoByName(std::string name);
    std::tuple<Protoent*, std::string> _GetProtoByName(unsigned char* name);
    std::tuple<Servent*, std::string> GetServByName(std::string name, std::string proto);
    std::tuple<Servent*, std::string> _GetServByName(unsigned char* name, unsigned char* proto);
    std::string getsockname(Handle s, RawSockaddrAny* rsa, int32_t* addrlen);
    std::string Getsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t* optlen);
    std::string listen(Handle s, int32_t backlog);
    uint16_t Ntohs(uint16_t netshort);
    std::string Setsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t optlen);
    std::string shutdown(Handle s, int32_t how);
    std::tuple<Handle, std::string> socket(int32_t af, int32_t typ, int32_t protocol);
}

