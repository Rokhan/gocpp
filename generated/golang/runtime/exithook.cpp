// generated by GoCpp from file '$(ImportDir)/runtime/exithook.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/exithook.h"
#include "gocpp/support.h"

#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    void addExitHook(std::function<void ()> f, bool runOnNonZeroExit)
    {
        exitHooks.hooks = append(exitHooks.hooks, gocpp::Init<exitHook>([=](auto& x) {
            x.f = f;
            x.runOnNonZeroExit = runOnNonZeroExit;
        }));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    exitHook::operator T()
    {
        T result;
        result.f = this->f;
        result.runOnNonZeroExit = this->runOnNonZeroExit;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool exitHook::operator==(const T& ref) const
    {
        if (f != ref.f) return false;
        if (runOnNonZeroExit != ref.runOnNonZeroExit) return false;
        return true;
    }

    std::ostream& exitHook::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << f;
        os << " " << runOnNonZeroExit;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct exitHook& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {
        gocpp::slice<exitHook> hooks;
        bool runningExitHooks;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.hooks = this->hooks;
            result.runningExitHooks = this->runningExitHooks;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (hooks != ref.hooks) return false;
            if (runningExitHooks != ref.runningExitHooks) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << hooks;
            os << " " << runningExitHooks;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 exitHooks;
    void runExitHooks(int exitCode)
    {
        if(exitHooks.runningExitHooks)
        {
            go_throw("internal error: exit hook invoked exit");
        }
        exitHooks.runningExitHooks = true;
        auto runExitHook = [=](std::function<void ()> f) mutable -> bool
        {
            gocpp::Defer defer;
            try
            {
                bool caughtPanic;
                defer.push_back([=]{ [=]() mutable -> void
                {
                    if(auto x = gocpp::recover(); x != nullptr)
                    {
                        caughtPanic = true;
                    }
                }(); });
                f();
                return caughtPanic;
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        };
        finishPageTrace();
        for(auto [i, gocpp_ignored] : exitHooks.hooks)
        {
            auto h = exitHooks.hooks[len(exitHooks.hooks) - i - 1];
            if(exitCode != 0 && ! h.runOnNonZeroExit)
            {
                continue;
            }
            if(auto caughtPanic = runExitHook(h.f); caughtPanic)
            {
                go_throw("internal error: exit hook invoked panic");
            }
        }
        exitHooks.hooks = nullptr;
        exitHooks.runningExitHooks = false;
    }

}

