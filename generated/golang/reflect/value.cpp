// generated by GoCpp from file '$(ImportDir)/reflect/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/value.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
// #include "golang/internal/abi/abi.h"  [Ignored, known errors]
#include "golang/internal/abi/map.h"
#include "golang/internal/abi/type.h"
// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]
#include "golang/internal/itoa/itoa.h"
#include "golang/internal/unsafeheader/unsafeheader.h"
#include "golang/math/const.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/makefunc.h"
#include "golang/reflect/type.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/sync/pool.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    
    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ_;
        os << " " << ptr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Value& value)
    {
        return value.PrintTo(os);
    }

    int flagKindWidth = 5;
    flag flagKindMask = (1 << flagKindWidth) - 1;
    flag flagStickyRO = 1 << 5;
    flag flagEmbedRO = 1 << 6;
    flag flagIndir = 1 << 7;
    flag flagAddr = 1 << 8;
    flag flagMethod = 1 << 9;
    int flagMethodShift = 10;
    flag flagRO = flagStickyRO | flagEmbedRO;
    Kind kind(flag f)
    {
        return Kind(f & flagKindMask);
    }

    flag ro(flag f)
    {
        if(f & flagRO != 0)
        {
            return flagStickyRO;
        }
        return 0;
    }

    abi::Type* typ(struct Value v)
    {
        return (*abi.Type)(noescape(Pointer(gocpp::recv(unsafe), v.typ_)));
    }

    unsafe::Pointer pointer(struct Value v)
    {
        if(Size(gocpp::recv(typ(gocpp::recv(v)))) != goarch.PtrSize || ! Pointers(gocpp::recv(typ(gocpp::recv(v)))))
        {
            gocpp::panic("can't call pointer on a non-pointer Value");
        }
        if(v.flag & flagIndir != 0)
        {
            return *(*unsafe.Pointer)(v.ptr);
        }
        return v.ptr;
    }

    go_any packEface(Value v)
    {
        auto t = typ(gocpp::recv(v));
        go_any i = {};
        auto e = (*emptyInterface)(Pointer(gocpp::recv(unsafe), & i));
        //Go switch emulation
        {
            int conditionId = -1;
            if(IfaceIndir(gocpp::recv(t))) { conditionId = 0; }
            else if(v.flag & flagIndir != 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(v.flag & flagIndir == 0)
                    {
                        gocpp::panic("bad indir");
                    }
                    auto ptr = v.ptr;
                    if(v.flag & flagAddr != 0)
                    {
                        auto c = unsafe_New(t);
                        typedmemmove(t, c, ptr);
                        ptr = c;
                    }
                    e->word = ptr;
                    break;
                case 1:
                    e->word = *(*unsafe.Pointer)(v.ptr);
                    break;
                default:
                    e->word = v.ptr;
                    break;
            }
        }
        e->typ = t;
        return i;
    }

    Value unpackEface(go_any i)
    {
        auto e = (*emptyInterface)(Pointer(gocpp::recv(unsafe), & i));
        auto t = e->typ;
        if(t == nullptr)
        {
            return Value {};
        }
        auto f = flag(Kind(gocpp::recv(t)));
        if(IfaceIndir(gocpp::recv(t)))
        {
            f |= flagIndir;
        }
        return Value {t, e->word, f};
    }

    
    std::ostream& ValueError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Method;
        os << " " << Kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value)
    {
        return value.PrintTo(os);
    }

    std::string Error(struct ValueError* e)
    {
        if(e->Kind == 0)
        {
            return "reflect: call of " + e->Method + " on zero Value";
        }
        return "reflect: call of " + e->Method + " on " + String(gocpp::recv(e->Kind)) + " Value";
    }

    std::string valueMethodName()
    {
        gocpp::array<uintptr_t, 5> pc = {};
        auto n = runtime::Callers(1, pc.make_slice(0, ));
        auto frames = runtime::CallersFrames(pc.make_slice(0, n));
        runtime::Frame frame = {};
        for(auto more = true; more; )
        {
            auto prefix = "reflect.Value.";
            std::tie(frame, more) = Next(gocpp::recv(frames));
            auto name = frame.Function;
            if(len(name) > len(prefix) && name.make_slice(0, len(prefix)) == prefix)
            {
                auto methodName = name.make_slice(len(prefix));
                if(len(methodName) > 0 && 'A' <= methodName[0] && methodName[0] <= 'Z')
                {
                    return name;
                }
            }
        }
        return "unknown method";
    }

    
    std::ostream& emptyInterface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << word;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& nonEmptyInterface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << itab;
        os << " " << word;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nonEmptyInterface& value)
    {
        return value.PrintTo(os);
    }

    void mustBe(flag f, Kind expected)
    {
        if(Kind(f & flagKindMask) != expected)
        {
            gocpp::panic(new ValueError {valueMethodName(), kind(gocpp::recv(f))});
        }
    }

    void mustBeExported(flag f)
    {
        if(f == 0 || f & flagRO != 0)
        {
            mustBeExportedSlow(gocpp::recv(f));
        }
    }

    void mustBeExportedSlow(flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {valueMethodName(), Invalid});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: " + valueMethodName() + " using value obtained using unexported field");
        }
    }

    void mustBeAssignable(flag f)
    {
        if(f & flagRO != 0 || f & flagAddr == 0)
        {
            mustBeAssignableSlow(gocpp::recv(f));
        }
    }

    void mustBeAssignableSlow(flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {valueMethodName(), Invalid});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: " + valueMethodName() + " using value obtained using unexported field");
        }
        if(f & flagAddr == 0)
        {
            gocpp::panic("reflect: " + valueMethodName() + " using unaddressable value");
        }
    }

    Value Addr(struct Value v)
    {
        if(v.flag & flagAddr == 0)
        {
            gocpp::panic("reflect.Value.Addr of unaddressable value");
        }
        auto fl = v.flag & flagRO;
        return Value {ptrTo(typ(gocpp::recv(v))), v.ptr, fl | flag(Pointer)};
    }

    bool Bool(struct Value v)
    {
        if(kind(gocpp::recv(v)) != Bool)
        {
            panicNotBool(gocpp::recv(v));
        }
        return *(*bool)(v.ptr);
    }

    void panicNotBool(struct Value v)
    {
        mustBe(gocpp::recv(v), Bool);
    }

    internal/abi.Type* bytesType = rtypeOf((gocpp::Tag<gocpp::slice<unsigned char>>())(nullptr));
    gocpp::slice<unsigned char> Bytes(struct Value v)
    {
        if(v.typ_ == bytesType)
        {
            return *(*gocpp::Tag<gocpp::slice<unsigned char>>())(v.ptr);
        }
        return bytesSlow(gocpp::recv(v));
    }

    gocpp::slice<unsigned char> bytesSlow(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Slice) { conditionId = 0; }
            else if(condition == Array) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(Kind(gocpp::recv(Elem(gocpp::recv(typ(gocpp::recv(v)))))) != abi.Uint8)
                    {
                        gocpp::panic("reflect.Value.Bytes of non-byte slice");
                    }
                    return *(*gocpp::Tag<gocpp::slice<unsigned char>>())(v.ptr);
                    break;
                case 1:
                    if(Kind(gocpp::recv(Elem(gocpp::recv(typ(gocpp::recv(v)))))) != abi.Uint8)
                    {
                        gocpp::panic("reflect.Value.Bytes of non-byte array");
                    }
                    if(! CanAddr(gocpp::recv(v)))
                    {
                        gocpp::panic("reflect.Value.Bytes of unaddressable byte array");
                    }
                    auto p = (*byte)(v.ptr);
                    auto n = int((*arrayType)(Pointer(gocpp::recv(unsafe), typ(gocpp::recv(v))))->Len);
                    return Slice(gocpp::recv(unsafe), p, n);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Bytes", kind(gocpp::recv(v))});
    }

    gocpp::slice<gocpp::rune> runes(struct Value v)
    {
        mustBe(gocpp::recv(v), Slice);
        if(Kind(gocpp::recv(Elem(gocpp::recv(typ(gocpp::recv(v)))))) != abi.Int32)
        {
            gocpp::panic("reflect.Value.Bytes of non-rune slice");
        }
        return *(*gocpp::Tag<gocpp::slice<gocpp::rune>>())(v.ptr);
    }

    bool CanAddr(struct Value v)
    {
        return v.flag & flagAddr != 0;
    }

    bool CanSet(struct Value v)
    {
        return v.flag & (flagAddr | flagRO) == flagAddr;
    }

    gocpp::slice<Value> Call(struct Value v, gocpp::slice<Value> in)
    {
        mustBe(gocpp::recv(v), Func);
        mustBeExported(gocpp::recv(v));
        return call(gocpp::recv(v), "Call", in);
    }

    gocpp::slice<Value> CallSlice(struct Value v, gocpp::slice<Value> in)
    {
        mustBe(gocpp::recv(v), Func);
        mustBeExported(gocpp::recv(v));
        return call(gocpp::recv(v), "CallSlice", in);
    }

    bool callGC;
    bool debugReflectCall = false;
    gocpp::slice<Value> call(struct Value v, std::string op, gocpp::slice<Value> in)
    {
        auto t = (*funcType)(Pointer(gocpp::recv(unsafe), typ(gocpp::recv(v))));
        unsafe::Pointer fn = {};
        Value rcvr = {};
        abi::Type* rcvrtype = {};
        if(v.flag & flagMethod != 0)
        {
            rcvr = v;
            std::tie(rcvrtype, t, fn) = methodReceiver(op, v, int(v.flag) >> flagMethodShift);
        }
        else
        if(v.flag & flagIndir != 0)
        {
            fn = *(*unsafe.Pointer)(v.ptr);
        }
        else
        {
            fn = v.ptr;
        }
        if(fn == nullptr)
        {
            gocpp::panic("reflect.Value.Call: call of nil function");
        }
        auto isSlice = op == "CallSlice";
        auto n = NumIn(gocpp::recv(t));
        auto isVariadic = IsVariadic(gocpp::recv(t));
        if(isSlice)
        {
            if(! isVariadic)
            {
                gocpp::panic("reflect: CallSlice of non-variadic function");
            }
            if(len(in) < n)
            {
                gocpp::panic("reflect: CallSlice with too few input arguments");
            }
            if(len(in) > n)
            {
                gocpp::panic("reflect: CallSlice with too many input arguments");
            }
        }
        else
        {
            if(isVariadic)
            {
                n--;
            }
            if(len(in) < n)
            {
                gocpp::panic("reflect: Call with too few input arguments");
            }
            if(! isVariadic && len(in) > n)
            {
                gocpp::panic("reflect: Call with too many input arguments");
            }
        }
        for(auto [_, x] : in)
        {
            if(Kind(gocpp::recv(x)) == Invalid)
            {
                gocpp::panic("reflect: " + op + " using zero Value argument");
            }
        }
        for(auto i = 0; i < n; i++)
        {
            if(auto [xt, targ] = std::tuple{Type(gocpp::recv(in[i])), In(gocpp::recv(t), i)}; ! AssignableTo(gocpp::recv(xt), toRType(targ)))
            {
                gocpp::panic("reflect: " + op + " using " + String(gocpp::recv(xt)) + " as type " + stringFor(targ));
            }
        }
        if(! isSlice && isVariadic)
        {
            auto m = len(in) - n;
            auto slice = MakeSlice(toRType(In(gocpp::recv(t), n)), m, m);
            auto elem = Elem(gocpp::recv(toRType(In(gocpp::recv(t), n))));
            for(auto i = 0; i < m; i++)
            {
                auto x = in[n + i];
                if(auto xt = Type(gocpp::recv(x)); ! AssignableTo(gocpp::recv(xt), elem))
                {
                    gocpp::panic("reflect: cannot use " + String(gocpp::recv(xt)) + " as type " + String(gocpp::recv(elem)) + " in " + op);
                }
                Set(gocpp::recv(Index(gocpp::recv(slice), i)), x);
            }
            auto origIn = in;
            in = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), n + 1);
            copy(in.make_slice(0, n), origIn);
            in[n] = slice;
        }
        auto nin = len(in);
        if(nin != NumIn(gocpp::recv(t)))
        {
            gocpp::panic("reflect.Value.Call: wrong argument count");
        }
        auto nout = NumOut(gocpp::recv(t));
        abi::RegArgs regArgs = {};
        auto [frametype, framePool, abid] = funcLayout(t, rcvrtype);
        unsafe::Pointer stackArgs = {};
        if(Size(gocpp::recv(frametype)) != 0)
        {
            if(nout == 0)
            {
                stackArgs = gocpp::getValue<unsafe.Pointer>(Get(gocpp::recv(framePool)));
            }
            else
            {
                stackArgs = unsafe_New(frametype);
            }
        }
        auto frameSize = Size(gocpp::recv(frametype));
        if(debugReflectCall)
        {
            println("reflect.call", stringFor(& t->Type));
            dump(gocpp::recv(abid));
        }
        auto inStart = 0;
        if(rcvrtype != nullptr)
        {
            //Go switch emulation
            {
                auto st = abid.call.steps[0];
                auto condition = st.kind;
                int conditionId = -1;
                if(condition == abiStepStack) { conditionId = 0; }
                else if(condition == abiStepPointer) { conditionId = 1; }
                else if(condition == abiStepIntReg) { conditionId = 2; }
                else if(condition == abiStepFloatReg) { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        storeRcvr(rcvr, stackArgs);
                        break;
                    case 1:
                        storeRcvr(rcvr, Pointer(gocpp::recv(unsafe), & regArgs.Ptrs[st.ireg]));
                    case 2:
                        storeRcvr(rcvr, Pointer(gocpp::recv(unsafe), & regArgs.Ints[st.ireg]));
                        break;
                    case 3:
                        storeRcvr(rcvr, Pointer(gocpp::recv(unsafe), & regArgs.Floats[st.freg]));
                        break;
                    default:
                        gocpp::panic("unknown ABI parameter kind");
                        break;
                }
            }
            inStart = 1;
        }
        for(auto [i, v] : in)
        {
            mustBeExported(gocpp::recv(v));
            auto targ = toRType(In(gocpp::recv(t), i));
            v = assignTo(gocpp::recv(v), "reflect.Value.Call", & targ->t, nullptr);
            for(auto [_, st] : stepsForValue(gocpp::recv(abid.call), i + inStart))
            {
                //Go switch emulation
                {
                    auto condition = st.kind;
                    int conditionId = -1;
                    if(condition == abiStepStack) { conditionId = 0; }
                    else if(condition == abiStepIntReg) { conditionId = 1; }
                    else if(condition == abiStepPointer) { conditionId = 2; }
                    else if(condition == abiStepFloatReg) { conditionId = 3; }
                    switch(conditionId)
                    {
                        case 0:
                            auto addr = add(stackArgs, st.stkOff, "precomputed stack arg offset");
                            if(v.flag & flagIndir != 0)
                            {
                                typedmemmove(& targ->t, addr, v.ptr);
                            }
                            else
                            {
                                *(*unsafe.Pointer)(addr) = v.ptr;
                            }
                            goto stepsLoop_break;
                            break;
                        case 1:
                        case 2:
                            if(v.flag & flagIndir != 0)
                            {
                                auto offset = add(v.ptr, st.offset, "precomputed value offset");
                                if(st.kind == abiStepPointer)
                                {
                                    regArgs.Ptrs[st.ireg] = *(*unsafe.Pointer)(offset);
                                }
                                intToReg(& regArgs, st.ireg, st.size, offset);
                            }
                            else
                            {
                                if(st.kind == abiStepPointer)
                                {
                                    regArgs.Ptrs[st.ireg] = v.ptr;
                                }
                                regArgs.Ints[st.ireg] = uintptr(v.ptr);
                            }
                            break;
                        case 3:
                            if(v.flag & flagIndir == 0)
                            {
                                gocpp::panic("attempted to copy pointer to FP register");
                            }
                            auto offset = add(v.ptr, st.offset, "precomputed value offset");
                            floatToReg(& regArgs, st.freg, st.size, offset);
                            break;
                        default:
                            gocpp::panic("unknown ABI part kind");
                            break;
                    }
                }
                if(false) {
                stepsLoop_continue:
                    continue;
                stepsLoop_break:
                    break;
                }
            }
        }
        frameSize = align(frameSize, goarch.PtrSize);
        frameSize += abid.spill;
        regArgs.ReturnIsPtr = abid.outRegPtrs;
        if(debugReflectCall)
        {
            Dump(gocpp::recv(regArgs));
        }
        if(callGC)
        {
            runtime::GC();
        }
        call(frametype, fn, stackArgs, uint32_t(Size(gocpp::recv(frametype))), uint32_t(abid.retOffset), uint32_t(frameSize), & regArgs);
        if(callGC)
        {
            runtime::GC();
        }
        gocpp::slice<Value> ret = {};
        if(nout == 0)
        {
            if(stackArgs != nullptr)
            {
                typedmemclr(frametype, stackArgs);
                Put(gocpp::recv(framePool), stackArgs);
            }
        }
        else
        {
            if(stackArgs != nullptr)
            {
                typedmemclrpartial(frametype, stackArgs, 0, abid.retOffset);
            }
            ret = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), nout);
            for(auto i = 0; i < nout; i++)
            {
                auto tv = Out(gocpp::recv(t), i);
                if(Size(gocpp::recv(tv)) == 0)
                {
                    ret[i] = Zero(toRType(tv));
                    continue;
                }
                auto steps = stepsForValue(gocpp::recv(abid.ret), i);
                if(auto st = steps[0]; st.kind == abiStepStack)
                {
                    auto fl = flagIndir | flag(Kind(gocpp::recv(tv)));
                    ret[i] = Value {tv, add(stackArgs, st.stkOff, "tv.Size() != 0"), fl};
                    continue;
                }
                if(! ifaceIndir(tv))
                {
                    if(steps[0].kind != abiStepPointer)
                    {
                        print("kind=", steps[0].kind, ", type=", stringFor(tv), "\n");
                        gocpp::panic("mismatch between ABI description and types");
                    }
                    ret[i] = Value {tv, regArgs.Ptrs[steps[0].ireg], flag(Kind(gocpp::recv(tv)))};
                    continue;
                }
                auto s = unsafe_New(tv);
                for(auto [_, st] : steps)
                {
                    //Go switch emulation
                    {
                        auto condition = st.kind;
                        int conditionId = -1;
                        if(condition == abiStepIntReg) { conditionId = 0; }
                        else if(condition == abiStepPointer) { conditionId = 1; }
                        else if(condition == abiStepFloatReg) { conditionId = 2; }
                        else if(condition == abiStepStack) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                auto offset = add(s, st.offset, "precomputed value offset");
                                intFromReg(& regArgs, st.ireg, st.size, offset);
                                break;
                            case 1:
                                auto s = add(s, st.offset, "precomputed value offset");
                                *((*unsafe.Pointer)(s)) = regArgs.Ptrs[st.ireg];
                                break;
                            case 2:
                                auto offset = add(s, st.offset, "precomputed value offset");
                                floatFromReg(& regArgs, st.freg, st.size, offset);
                                break;
                            case 3:
                                gocpp::panic("register-based return value has stack component");
                                break;
                            default:
                                gocpp::panic("unknown ABI part kind");
                                break;
                        }
                    }
                }
                ret[i] = Value {tv, s, flagIndir | flag(Kind(gocpp::recv(tv)))};
            }
        }
        return ret;
    }

    void callReflect(makeFuncImpl* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs)
    {
        if(callGC)
        {
            runtime::GC();
        }
        auto ftyp = ctxt->ftyp;
        auto f = ctxt->fn;
        internal/abi.Type* _;
        sync.Pool* _;
        reflect.abiDesc abid;
        std::tie(_, _, abid) = funcLayout(ftyp, nullptr);
        auto ptr = frame;
        auto in = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), 0, int(ftyp->InCount));
        for(auto [i, typ] : InSlice(gocpp::recv(ftyp)))
        {
            if(Size(gocpp::recv(typ)) == 0)
            {
                in = append(in, Zero(toRType(typ)));
                continue;
            }
            auto v = Value {typ, nullptr, flag(Kind(gocpp::recv(typ)))};
            auto steps = stepsForValue(gocpp::recv(abid.call), i);
            if(auto st = steps[0]; st.kind == abiStepStack)
            {
                if(ifaceIndir(typ))
                {
                    v.ptr = unsafe_New(typ);
                    if(Size(gocpp::recv(typ)) > 0)
                    {
                        typedmemmove(typ, v.ptr, add(ptr, st.stkOff, "typ.size > 0"));
                    }
                    v.flag |= flagIndir;
                }
                else
                {
                    v.ptr = *(*unsafe.Pointer)(add(ptr, st.stkOff, "1-ptr"));
                }
            }
            else
            {
                if(ifaceIndir(typ))
                {
                    v.flag |= flagIndir;
                    v.ptr = unsafe_New(typ);
                    for(auto [_, st] : steps)
                    {
                        //Go switch emulation
                        {
                            auto condition = st.kind;
                            int conditionId = -1;
                            if(condition == abiStepIntReg) { conditionId = 0; }
                            else if(condition == abiStepPointer) { conditionId = 1; }
                            else if(condition == abiStepFloatReg) { conditionId = 2; }
                            else if(condition == abiStepStack) { conditionId = 3; }
                            switch(conditionId)
                            {
                                case 0:
                                    auto offset = add(v.ptr, st.offset, "precomputed value offset");
                                    intFromReg(regs, st.ireg, st.size, offset);
                                    break;
                                case 1:
                                    auto s = add(v.ptr, st.offset, "precomputed value offset");
                                    *((*unsafe.Pointer)(s)) = regs->Ptrs[st.ireg];
                                    break;
                                case 2:
                                    auto offset = add(v.ptr, st.offset, "precomputed value offset");
                                    floatFromReg(regs, st.freg, st.size, offset);
                                    break;
                                case 3:
                                    gocpp::panic("register-based return value has stack component");
                                    break;
                                default:
                                    gocpp::panic("unknown ABI part kind");
                                    break;
                            }
                        }
                    }
                }
                else
                {
                    if(steps[0].kind != abiStepPointer)
                    {
                        print("kind=", steps[0].kind, ", type=", stringFor(typ), "\n");
                        gocpp::panic("mismatch between ABI description and types");
                    }
                    v.ptr = regs->Ptrs[steps[0].ireg];
                }
            }
            in = append(in, v);
        }
        auto out = f(in);
        auto numOut = NumOut(gocpp::recv(ftyp));
        if(len(out) != numOut)
        {
            gocpp::panic("reflect: wrong return count from function created by MakeFunc");
        }
        if(numOut > 0)
        {
            for(auto [i, typ] : OutSlice(gocpp::recv(ftyp)))
            {
                auto v = out[i];
                if(typ(gocpp::recv(v)) == nullptr)
                {
                    gocpp::panic("reflect: function created by MakeFunc using " + funcName(f) + " returned zero Value");
                }
                if(v.flag & flagRO != 0)
                {
                    gocpp::panic("reflect: function created by MakeFunc using " + funcName(f) + " returned value obtained from unexported field");
                }
                if(Size(gocpp::recv(typ)) == 0)
                {
                    continue;
                }
                v = assignTo(gocpp::recv(v), "reflect.MakeFunc", typ, nullptr);
                for(auto [_, st] : stepsForValue(gocpp::recv(abid.ret), i))
                {
                    //Go switch emulation
                    {
                        auto condition = st.kind;
                        int conditionId = -1;
                        if(condition == abiStepStack) { conditionId = 0; }
                        else if(condition == abiStepIntReg) { conditionId = 1; }
                        else if(condition == abiStepPointer) { conditionId = 2; }
                        else if(condition == abiStepFloatReg) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                auto addr = add(ptr, st.stkOff, "precomputed stack arg offset");
                                if(v.flag & flagIndir != 0)
                                {
                                    memmove(addr, v.ptr, st.size);
                                }
                                else
                                {
                                    *(*uintptr)(addr) = uintptr(v.ptr);
                                }
                                goto stepsLoop_break;
                                break;
                            case 1:
                            case 2:
                                if(v.flag & flagIndir != 0)
                                {
                                    auto offset = add(v.ptr, st.offset, "precomputed value offset");
                                    intToReg(regs, st.ireg, st.size, offset);
                                }
                                else
                                {
                                    regs->Ints[st.ireg] = uintptr(v.ptr);
                                }
                                break;
                            case 3:
                                if(v.flag & flagIndir == 0)
                                {
                                    gocpp::panic("attempted to copy pointer to FP register");
                                }
                                auto offset = add(v.ptr, st.offset, "precomputed value offset");
                                floatToReg(regs, st.freg, st.size, offset);
                                break;
                            default:
                                gocpp::panic("unknown ABI part kind");
                                break;
                        }
                    }
                    if(false) {
                    stepsLoop_continue:
                        continue;
                    stepsLoop_break:
                        break;
                    }
                }
            }
        }
        *retValid = true;
        runtime::KeepAlive(out);
        runtime::KeepAlive(ctxt);
    }

    std::tuple<abi::Type*, funcType*, unsafe::Pointer> methodReceiver(std::string op, Value v, int methodIndex)
    {
        abi::Type* rcvrtype;
        funcType* t;
        unsafe::Pointer fn;
        auto i = methodIndex;
        if(Kind(gocpp::recv(typ(gocpp::recv(v)))) == abi.Interface)
        {
            abi::Type* rcvrtype;
            funcType* t;
            unsafe::Pointer fn;
            auto tt = (*interfaceType)(Pointer(gocpp::recv(unsafe), typ(gocpp::recv(v))));
            if((unsigned int)(i) >= (unsigned int)(len(tt->Methods)))
            {
                abi::Type* rcvrtype;
                funcType* t;
                unsafe::Pointer fn;
                gocpp::panic("reflect: internal error: invalid method index");
            }
            auto m = & tt->Methods[i];
            if(! IsExported(gocpp::recv(nameOff(gocpp::recv(tt), m->Name))))
            {
                abi::Type* rcvrtype;
                funcType* t;
                unsafe::Pointer fn;
                gocpp::panic("reflect: " + op + " of unexported method");
            }
            auto iface = (*nonEmptyInterface)(v.ptr);
            if(iface->itab == nullptr)
            {
                abi::Type* rcvrtype;
                funcType* t;
                unsafe::Pointer fn;
                gocpp::panic("reflect: " + op + " of method on nil interface value");
            }
            rcvrtype = iface->itab->typ;
            fn = Pointer(gocpp::recv(unsafe), & iface->itab->fun[i]);
            t = (*funcType)(Pointer(gocpp::recv(unsafe), typeOff(gocpp::recv(tt), m->Typ)));
        }
        else
        {
            abi::Type* rcvrtype;
            funcType* t;
            unsafe::Pointer fn;
            rcvrtype = typ(gocpp::recv(v));
            auto ms = ExportedMethods(gocpp::recv(typ(gocpp::recv(v))));
            if((unsigned int)(i) >= (unsigned int)(len(ms)))
            {
                abi::Type* rcvrtype;
                funcType* t;
                unsafe::Pointer fn;
                gocpp::panic("reflect: internal error: invalid method index");
            }
            auto m = ms[i];
            if(! IsExported(gocpp::recv(nameOffFor(typ(gocpp::recv(v)), m.Name))))
            {
                abi::Type* rcvrtype;
                funcType* t;
                unsafe::Pointer fn;
                gocpp::panic("reflect: " + op + " of unexported method");
            }
            auto ifn = textOffFor(typ(gocpp::recv(v)), m.Ifn);
            fn = Pointer(gocpp::recv(unsafe), & ifn);
            t = (*funcType)(Pointer(gocpp::recv(unsafe), typeOffFor(typ(gocpp::recv(v)), m.Mtyp)));
        }
        return {rcvrtype, t, fn};
    }

    void storeRcvr(Value v, unsafe::Pointer p)
    {
        auto t = typ(gocpp::recv(v));
        if(Kind(gocpp::recv(t)) == abi.Interface)
        {
            auto iface = (*nonEmptyInterface)(v.ptr);
            *(*unsafe.Pointer)(p) = iface->word;
        }
        else
        if(v.flag & flagIndir != 0 && ! ifaceIndir(t))
        {
            *(*unsafe.Pointer)(p) = *(*unsafe.Pointer)(v.ptr);
        }
        else
        {
            *(*unsafe.Pointer)(p) = v.ptr;
        }
    }

    uintptr_t align(uintptr_t x, uintptr_t n)
    {
        return (x + n - 1) &^ (n - 1);
    }

    void callMethod(methodValue* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs)
    {
        auto rcvr = ctxt->rcvr;
        auto [rcvrType, valueFuncType, methodFn] = methodReceiver("call", rcvr, ctxt->method);
        internal/abi.Type* _;
        sync.Pool* _;
        reflect.abiDesc valueABI;
        std::tie(_, _, valueABI) = funcLayout(valueFuncType, nullptr);
        auto [valueFrame, valueRegs] = std::tuple{frame, regs};
        auto [methodFrameType, methodFramePool, methodABI] = funcLayout(valueFuncType, rcvrType);
        auto methodFrame = gocpp::getValue<unsafe.Pointer>(Get(gocpp::recv(methodFramePool)));
        abi::RegArgs methodRegs = {};
        //Go switch emulation
        {
            auto st = methodABI.call.steps[0];
            auto condition = st.kind;
            int conditionId = -1;
            if(condition == abiStepStack) { conditionId = 0; }
            else if(condition == abiStepPointer) { conditionId = 1; }
            else if(condition == abiStepIntReg) { conditionId = 2; }
            else if(condition == abiStepFloatReg) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    storeRcvr(rcvr, methodFrame);
                    break;
                case 1:
                    storeRcvr(rcvr, Pointer(gocpp::recv(unsafe), & methodRegs.Ptrs[st.ireg]));
                case 2:
                    storeRcvr(rcvr, Pointer(gocpp::recv(unsafe), & methodRegs.Ints[st.ireg]));
                    break;
                case 3:
                    storeRcvr(rcvr, Pointer(gocpp::recv(unsafe), & methodRegs.Floats[st.freg]));
                    break;
                default:
                    gocpp::panic("unknown ABI parameter kind");
                    break;
            }
        }
        for(auto [i, t] : InSlice(gocpp::recv(valueFuncType)))
        {
            auto valueSteps = stepsForValue(gocpp::recv(valueABI.call), i);
            auto methodSteps = stepsForValue(gocpp::recv(methodABI.call), i + 1);
            if(len(valueSteps) == 0)
            {
                if(len(methodSteps) != 0)
                {
                    gocpp::panic("method ABI and value ABI do not align");
                }
                continue;
            }
            if(auto vStep = valueSteps[0]; vStep.kind == abiStepStack)
            {
                auto mStep = methodSteps[0];
                if(mStep.kind == abiStepStack)
                {
                    if(vStep.size != mStep.size)
                    {
                        gocpp::panic("method ABI and value ABI do not align");
                    }
                    typedmemmove(t, add(methodFrame, mStep.stkOff, "precomputed stack offset"), add(valueFrame, vStep.stkOff, "precomputed stack offset"));
                    continue;
                }
                for(auto [_, mStep] : methodSteps)
                {
                    auto from = add(valueFrame, vStep.stkOff + mStep.offset, "precomputed stack offset");
                    //Go switch emulation
                    {
                        auto condition = mStep.kind;
                        int conditionId = -1;
                        if(condition == abiStepPointer) { conditionId = 0; }
                        else if(condition == abiStepIntReg) { conditionId = 1; }
                        else if(condition == abiStepFloatReg) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                methodRegs.Ptrs[mStep.ireg] = *(*unsafe.Pointer)(from);
                            case 1:
                                intToReg(& methodRegs, mStep.ireg, mStep.size, from);
                                break;
                            case 2:
                                floatToReg(& methodRegs, mStep.freg, mStep.size, from);
                                break;
                            default:
                                gocpp::panic("unexpected method step");
                                break;
                        }
                    }
                }
                continue;
            }
            if(auto mStep = methodSteps[0]; mStep.kind == abiStepStack)
            {
                for(auto [_, vStep] : valueSteps)
                {
                    auto to = add(methodFrame, mStep.stkOff + vStep.offset, "precomputed stack offset");
                    //Go switch emulation
                    {
                        auto condition = vStep.kind;
                        int conditionId = -1;
                        if(condition == abiStepPointer) { conditionId = 0; }
                        else if(condition == abiStepIntReg) { conditionId = 1; }
                        else if(condition == abiStepFloatReg) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                *(*unsafe.Pointer)(to) = valueRegs->Ptrs[vStep.ireg];
                                break;
                            case 1:
                                intFromReg(valueRegs, vStep.ireg, vStep.size, to);
                                break;
                            case 2:
                                floatFromReg(valueRegs, vStep.freg, vStep.size, to);
                                break;
                            default:
                                gocpp::panic("unexpected value step");
                                break;
                        }
                    }
                }
                continue;
            }
            if(len(valueSteps) != len(methodSteps))
            {
                gocpp::panic("method ABI and value ABI don't align");
            }
            for(auto [i, vStep] : valueSteps)
            {
                auto mStep = methodSteps[i];
                if(mStep.kind != vStep.kind)
                {
                    gocpp::panic("method ABI and value ABI don't align");
                }
                //Go switch emulation
                {
                    auto condition = vStep.kind;
                    int conditionId = -1;
                    if(condition == abiStepPointer) { conditionId = 0; }
                    else if(condition == abiStepIntReg) { conditionId = 1; }
                    else if(condition == abiStepFloatReg) { conditionId = 2; }
                    switch(conditionId)
                    {
                        case 0:
                            methodRegs.Ptrs[mStep.ireg] = valueRegs->Ptrs[vStep.ireg];
                        case 1:
                            methodRegs.Ints[mStep.ireg] = valueRegs->Ints[vStep.ireg];
                            break;
                        case 2:
                            methodRegs.Floats[mStep.freg] = valueRegs->Floats[vStep.freg];
                            break;
                        default:
                            gocpp::panic("unexpected value step");
                            break;
                    }
                }
            }
        }
        auto methodFrameSize = Size(gocpp::recv(methodFrameType));
        methodFrameSize = align(methodFrameSize, goarch.PtrSize);
        methodFrameSize += methodABI.spill;
        methodRegs.ReturnIsPtr = methodABI.outRegPtrs;
        call(methodFrameType, methodFn, methodFrame, uint32_t(Size(gocpp::recv(methodFrameType))), uint32_t(methodABI.retOffset), uint32_t(methodFrameSize), & methodRegs);
        if(valueRegs != nullptr)
        {
            *valueRegs = methodRegs;
        }
        if(auto retSize = Size(gocpp::recv(methodFrameType)) - methodABI.retOffset; retSize > 0)
        {
            auto valueRet = add(valueFrame, valueABI.retOffset, "valueFrame's size > retOffset");
            auto methodRet = add(methodFrame, methodABI.retOffset, "methodFrame's size > retOffset");
            memmove(valueRet, methodRet, retSize);
        }
        *retValid = true;
        typedmemclr(methodFrameType, methodFrame);
        Put(gocpp::recv(methodFramePool), methodFrame);
        runtime::KeepAlive(ctxt);
        runtime::KeepAlive(valueRegs);
    }

