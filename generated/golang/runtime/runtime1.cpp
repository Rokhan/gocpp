// generated by GoCpp from file '$(ImportDir)/runtime/runtime1.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime1.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/auxv_none.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Store;
    }

    uint32_t traceback_cache = 2 << tracebackShift;
    uint32_t traceback_env;
    std::tuple<int32_t, bool, bool> gotraceback()
    {
        int32_t level;
        bool all;
        bool crash;
        auto gp = getg();
        auto t = atomic::Load(& traceback_cache);
        crash = t & tracebackCrash != 0;
        all = gp->m->throwing >= throwTypeUser || t & tracebackAll != 0;
        if(gp->m->traceback != 0)
        {
            level = int32_t(gp->m->traceback);
        }
        else
        if(gp->m->throwing >= throwTypeRuntime)
        {
            level = 2;
        }
        else
        {
            level = int32_t(t >> tracebackShift);
        }
        return {level, all, crash};
    }

    int32_t argc;
    unsigned char** argv;
    unsigned char* argv_index(unsigned char** argv, int32_t i)
    {
        return *(unsigned char**)(add(unsafe::Pointer(argv), uintptr_t(i) * goarch::PtrSize));
    }

    void args(int32_t c, unsigned char** v)
    {
        argc = c;
        argv = v;
        sysargs(c, v);
    }

    void goargs()
    {
        if(GOOS == "windows"s)
        {
            return;
        }
        argslice = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), argc);
        for(auto i = int32_t(0); i < argc; i++)
        {
            argslice[i] = gostringnocopy(argv_index(argv, i));
        }
    }

    void goenvs_unix()
    {
        auto n = int32_t(0);
        for(; argv_index(argv, argc + 1 + n) != nullptr; )
        {
            n++;
        }
        envs = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        for(auto i = int32_t(0); i < n; i++)
        {
            envs[i] = gostring(argv_index(argv, argc + 1 + i));
        }
    }

    gocpp::slice<std::string> environ()
    {
        return envs;
    }

    uint64_t test_z64;
    uint64_t test_x64;
    void testAtomic64()
    {
        test_z64 = 42;
        test_x64 = 0;
        if(atomic::Cas64(& test_z64, test_x64, 1))
        {
            go_throw("cas64 failed"s);
        }
        if(test_x64 != 0)
        {
            go_throw("cas64 failed"s);
        }
        test_x64 = 42;
        if(! atomic::Cas64(& test_z64, test_x64, 1))
        {
            go_throw("cas64 failed"s);
        }
        if(test_x64 != 42 || test_z64 != 1)
        {
            go_throw("cas64 failed"s);
        }
        if(atomic::Load64(& test_z64) != 1)
        {
            go_throw("load64 failed"s);
        }
        atomic::Store64(& test_z64, (1 << 40) + 1);
        if(atomic::Load64(& test_z64) != (1 << 40) + 1)
        {
            go_throw("store64 failed"s);
        }
        if(atomic::Xadd64(& test_z64, (1 << 40) + 1) != (2 << 40) + 2)
        {
            go_throw("xadd64 failed"s);
        }
        if(atomic::Load64(& test_z64) != (2 << 40) + 2)
        {
            go_throw("xadd64 failed"s);
        }
        if(atomic::Xchg64(& test_z64, (3 << 40) + 3) != (2 << 40) + 2)
        {
            go_throw("xchg64 failed"s);
        }
        if(atomic::Load64(& test_z64) != (3 << 40) + 3)
        {
            go_throw("xchg64 failed"s);
        }
    }

    void check()
    {
        int8_t a = {};
        uint8_t b = {};
        int16_t c = {};
        uint16_t d = {};
        int32_t e = {};
        uint32_t f = {};
        int64_t g = {};
        uint64_t h = {};
        float i = {};
        float i1 = {};
        double j = {};
        double j1 = {};
        unsafe::Pointer k = {};
        uint16_t* l = {};
        gocpp::array<unsigned char, 4> m = {};
        
        template<typename T> requires gocpp::GoStruct<T>
        x1t::operator T()
        {
            T result;
            result.x = this->x;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool x1t::operator==(const T& ref) const
        {
            if (x != ref.x) return false;
            return true;
        }

        std::ostream& x1t::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << x;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct x1t& value)
        {
            return value.PrintTo(os);
        }

        
        template<typename T> requires gocpp::GoStruct<T>
        y1t::operator T()
        {
            T result;
            result.x1 = this->x1;
            result.y = this->y;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool y1t::operator==(const T& ref) const
        {
            if (x1 != ref.x1) return false;
            if (y != ref.y) return false;
            return true;
        }

        std::ostream& y1t::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << x1;
            os << " " << y;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct y1t& value)
        {
            return value.PrintTo(os);
        }

        x1t x1 = {};
        y1t y1 = {};
        if(gocpp::Sizeof<int8_t>() != 1)
        {
            go_throw("bad a"s);
        }
        if(gocpp::Sizeof<uint8_t>() != 1)
        {
            go_throw("bad b"s);
        }
        if(gocpp::Sizeof<int16_t>() != 2)
        {
            go_throw("bad c"s);
        }
        if(gocpp::Sizeof<uint16_t>() != 2)
        {
            go_throw("bad d"s);
        }
        if(gocpp::Sizeof<int32_t>() != 4)
        {
            go_throw("bad e"s);
        }
        if(gocpp::Sizeof<uint32_t>() != 4)
        {
            go_throw("bad f"s);
        }
        if(gocpp::Sizeof<int64_t>() != 8)
        {
            go_throw("bad g"s);
        }
        if(gocpp::Sizeof<uint64_t>() != 8)
        {
            go_throw("bad h"s);
        }
        if(gocpp::Sizeof<float>() != 4)
        {
            go_throw("bad i"s);
        }
        if(gocpp::Sizeof<double>() != 8)
        {
            go_throw("bad j"s);
        }
        if(gocpp::Sizeof<unsafe::Pointer>() != goarch::PtrSize)
        {
            go_throw("bad k"s);
        }
        if(gocpp::Sizeof<uint16_t*>() != goarch::PtrSize)
        {
            go_throw("bad l"s);
        }
        if(gocpp::Sizeof<x1t>() != 1)
        {
            go_throw("bad unsafe.Sizeof x1"s);
        }
        if(unsafe::Offsetof(y1.y) != 1)
        {
            go_throw("bad offsetof y1.y"s);
        }
        if(gocpp::Sizeof<y1t>() != 2)
        {
            go_throw("bad unsafe.Sizeof y1"s);
        }
        if(timediv(12345 * 1000000000 + 54321, 1000000000, & e) != 12345 || e != 54321)
        {
            go_throw("bad timediv"s);
        }
        uint32_t z = {};
        z = 1;
        if(! atomic::Cas(& z, 1, 2))
        {
            go_throw("cas1"s);
        }
        if(z != 2)
        {
            go_throw("cas2"s);
        }
        z = 4;
        if(atomic::Cas(& z, 5, 6))
        {
            go_throw("cas3"s);
        }
        if(z != 4)
        {
            go_throw("cas4"s);
        }
        z = 0xffffffff;
        if(! atomic::Cas(& z, 0xffffffff, 0xfffffffe))
        {
            go_throw("cas5"s);
        }
        if(z != 0xfffffffe)
        {
            go_throw("cas6"s);
        }
        m = gocpp::array<unsigned char, 4> {1, 1, 1, 1};
        atomic::Or8(& m[1], 0xf0);
        if(m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1)
        {
            go_throw("atomicor8"s);
        }
        m = gocpp::array<unsigned char, 4> {0xff, 0xff, 0xff, 0xff};
        atomic::And8(& m[1], 0x1);
        if(m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff)
        {
            go_throw("atomicand8"s);
        }
        *(uint64_t*)(unsafe::Pointer(& j)) = ~ uint64_t(0);
        if(j == j)
        {
            go_throw("float64nan"s);
        }
        if(! (j != j))
        {
            go_throw("float64nan1"s);
        }
        *(uint64_t*)(unsafe::Pointer(& j1)) = ~ uint64_t(1);
        if(j == j1)
        {
            go_throw("float64nan2"s);
        }
        if(! (j != j1))
        {
            go_throw("float64nan3"s);
        }
        *(uint32_t*)(unsafe::Pointer(& i)) = ~ uint32_t(0);
        if(i == i)
        {
            go_throw("float32nan"s);
        }
        if(i == i)
        {
            go_throw("float32nan1"s);
        }
        *(uint32_t*)(unsafe::Pointer(& i1)) = ~ uint32_t(1);
        if(i == i1)
        {
            go_throw("float32nan2"s);
        }
        if(i == i1)
        {
            go_throw("float32nan3"s);
        }
        testAtomic64();
        if(fixedStack != round2(fixedStack))
        {
            go_throw("FixedStack is not power-of-2"s);
        }
        if(! checkASM())
        {
            go_throw("assembly checks failed"s);
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dbgVar::operator T()
    {
        T result;
        result.name = this->name;
        result.value = this->value;
        result.atomic = this->atomic;
        result.def = this->def;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dbgVar::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (value != ref.value) return false;
        if (atomic != ref.atomic) return false;
        if (def != ref.def) return false;
        return true;
    }

    std::ostream& dbgVar::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << value;
        os << " " << atomic;
        os << " " << def;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dbgVar& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {
        int32_t cgocheck;
        int32_t clobberfree;
        int32_t disablethp;
        int32_t dontfreezetheworld;
        int32_t efence;
        int32_t gccheckmark;
        int32_t gcpacertrace;
        int32_t gcshrinkstackoff;
        int32_t gcstoptheworld;
        int32_t gctrace;
        int32_t invalidptr;
        int32_t madvdontneed;
        atomic::Int32 runtimeContentionStacks;
        int32_t scavtrace;
        int32_t scheddetail;
        int32_t schedtrace;
        int32_t tracebackancestors;
        int32_t asyncpreemptoff;
        int32_t harddecommit;
        int32_t adaptivestackstart;
        int32_t tracefpunwindoff;
        int32_t traceadvanceperiod;
        bool malloc;
        int32_t allocfreetrace;
        int32_t inittrace;
        int32_t sbrk;
        atomic::Int32 panicnil;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.cgocheck = this->cgocheck;
            result.clobberfree = this->clobberfree;
            result.disablethp = this->disablethp;
            result.dontfreezetheworld = this->dontfreezetheworld;
            result.efence = this->efence;
            result.gccheckmark = this->gccheckmark;
            result.gcpacertrace = this->gcpacertrace;
            result.gcshrinkstackoff = this->gcshrinkstackoff;
            result.gcstoptheworld = this->gcstoptheworld;
            result.gctrace = this->gctrace;
            result.invalidptr = this->invalidptr;
            result.madvdontneed = this->madvdontneed;
            result.runtimeContentionStacks = this->runtimeContentionStacks;
            result.scavtrace = this->scavtrace;
            result.scheddetail = this->scheddetail;
            result.schedtrace = this->schedtrace;
            result.tracebackancestors = this->tracebackancestors;
            result.asyncpreemptoff = this->asyncpreemptoff;
            result.harddecommit = this->harddecommit;
            result.adaptivestackstart = this->adaptivestackstart;
            result.tracefpunwindoff = this->tracefpunwindoff;
            result.traceadvanceperiod = this->traceadvanceperiod;
            result.malloc = this->malloc;
            result.allocfreetrace = this->allocfreetrace;
            result.inittrace = this->inittrace;
            result.sbrk = this->sbrk;
            result.panicnil = this->panicnil;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (cgocheck != ref.cgocheck) return false;
            if (clobberfree != ref.clobberfree) return false;
            if (disablethp != ref.disablethp) return false;
            if (dontfreezetheworld != ref.dontfreezetheworld) return false;
            if (efence != ref.efence) return false;
            if (gccheckmark != ref.gccheckmark) return false;
            if (gcpacertrace != ref.gcpacertrace) return false;
            if (gcshrinkstackoff != ref.gcshrinkstackoff) return false;
            if (gcstoptheworld != ref.gcstoptheworld) return false;
            if (gctrace != ref.gctrace) return false;
            if (invalidptr != ref.invalidptr) return false;
            if (madvdontneed != ref.madvdontneed) return false;
            if (runtimeContentionStacks != ref.runtimeContentionStacks) return false;
            if (scavtrace != ref.scavtrace) return false;
            if (scheddetail != ref.scheddetail) return false;
            if (schedtrace != ref.schedtrace) return false;
            if (tracebackancestors != ref.tracebackancestors) return false;
            if (asyncpreemptoff != ref.asyncpreemptoff) return false;
            if (harddecommit != ref.harddecommit) return false;
            if (adaptivestackstart != ref.adaptivestackstart) return false;
            if (tracefpunwindoff != ref.tracefpunwindoff) return false;
            if (traceadvanceperiod != ref.traceadvanceperiod) return false;
            if (malloc != ref.malloc) return false;
            if (allocfreetrace != ref.allocfreetrace) return false;
            if (inittrace != ref.inittrace) return false;
            if (sbrk != ref.sbrk) return false;
            if (panicnil != ref.panicnil) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << cgocheck;
            os << " " << clobberfree;
            os << " " << disablethp;
            os << " " << dontfreezetheworld;
            os << " " << efence;
            os << " " << gccheckmark;
            os << " " << gcpacertrace;
            os << " " << gcshrinkstackoff;
            os << " " << gcstoptheworld;
            os << " " << gctrace;
            os << " " << invalidptr;
            os << " " << madvdontneed;
            os << " " << runtimeContentionStacks;
            os << " " << scavtrace;
            os << " " << scheddetail;
            os << " " << schedtrace;
            os << " " << tracebackancestors;
            os << " " << asyncpreemptoff;
            os << " " << harddecommit;
            os << " " << adaptivestackstart;
            os << " " << tracefpunwindoff;
            os << " " << traceadvanceperiod;
            os << " " << malloc;
            os << " " << allocfreetrace;
            os << " " << inittrace;
            os << " " << sbrk;
            os << " " << panicnil;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 debug;
    gocpp::slice<dbgVar*> dbgvars = gocpp::slice<dbgVar*> {gocpp::Init<>([](auto& x) {
        x.name = "allocfreetrace"s;
        x.value = & debug.allocfreetrace;
    }), gocpp::Init<>([](auto& x) {
        x.name = "clobberfree"s;
        x.value = & debug.clobberfree;
    }), gocpp::Init<>([](auto& x) {
        x.name = "cgocheck"s;
        x.value = & debug.cgocheck;
    }), gocpp::Init<>([](auto& x) {
        x.name = "disablethp"s;
        x.value = & debug.disablethp;
    }), gocpp::Init<>([](auto& x) {
        x.name = "dontfreezetheworld"s;
        x.value = & debug.dontfreezetheworld;
    }), gocpp::Init<>([](auto& x) {
        x.name = "efence"s;
        x.value = & debug.efence;
    }), gocpp::Init<>([](auto& x) {
        x.name = "gccheckmark"s;
        x.value = & debug.gccheckmark;
    }), gocpp::Init<>([](auto& x) {
        x.name = "gcpacertrace"s;
        x.value = & debug.gcpacertrace;
    }), gocpp::Init<>([](auto& x) {
        x.name = "gcshrinkstackoff"s;
        x.value = & debug.gcshrinkstackoff;
    }), gocpp::Init<>([](auto& x) {
        x.name = "gcstoptheworld"s;
        x.value = & debug.gcstoptheworld;
    }), gocpp::Init<>([](auto& x) {
        x.name = "gctrace"s;
        x.value = & debug.gctrace;
    }), gocpp::Init<>([](auto& x) {
        x.name = "invalidptr"s;
        x.value = & debug.invalidptr;
    }), gocpp::Init<>([](auto& x) {
        x.name = "madvdontneed"s;
        x.value = & debug.madvdontneed;
    }), gocpp::Init<>([](auto& x) {
        x.name = "runtimecontentionstacks"s;
        x.atomic = & debug.runtimeContentionStacks;
    }), gocpp::Init<>([](auto& x) {
        x.name = "sbrk"s;
        x.value = & debug.sbrk;
    }), gocpp::Init<>([](auto& x) {
        x.name = "scavtrace"s;
        x.value = & debug.scavtrace;
    }), gocpp::Init<>([](auto& x) {
        x.name = "scheddetail"s;
        x.value = & debug.scheddetail;
    }), gocpp::Init<>([](auto& x) {
        x.name = "schedtrace"s;
        x.value = & debug.schedtrace;
    }), gocpp::Init<>([](auto& x) {
        x.name = "tracebackancestors"s;
        x.value = & debug.tracebackancestors;
    }), gocpp::Init<>([](auto& x) {
        x.name = "asyncpreemptoff"s;
        x.value = & debug.asyncpreemptoff;
    }), gocpp::Init<>([](auto& x) {
        x.name = "inittrace"s;
        x.value = & debug.inittrace;
    }), gocpp::Init<>([](auto& x) {
        x.name = "harddecommit"s;
        x.value = & debug.harddecommit;
    }), gocpp::Init<>([](auto& x) {
        x.name = "adaptivestackstart"s;
        x.value = & debug.adaptivestackstart;
    }), gocpp::Init<>([](auto& x) {
        x.name = "tracefpunwindoff"s;
        x.value = & debug.tracefpunwindoff;
    }), gocpp::Init<>([](auto& x) {
        x.name = "panicnil"s;
        x.atomic = & debug.panicnil;
    }), gocpp::Init<>([](auto& x) {
        x.name = "traceadvanceperiod"s;
        x.value = & debug.traceadvanceperiod;
    })};
    void parsedebugvars()
    {
        debug.cgocheck = 1;
        debug.invalidptr = 1;
        debug.adaptivestackstart = 1;
        if(GOOS == "linux"s)
        {
            debug.madvdontneed = 1;
        }
        debug.traceadvanceperiod = defaultTraceAdvancePeriod;
        auto godebug = gogetenv("GODEBUG"s);
        auto p = new(string);
        *p = godebug;
        rec::Store(gocpp::recv(godebugEnv), p);
        for(auto [gocpp_ignored, v] : dbgvars)
        {
            if(v->def != 0)
            {
                if(v->value != nullptr)
                {
                    *v->value = v->def;
                }
                else
                if(v->atomic != nullptr)
                {
                    rec::Store(gocpp::recv(v->atomic), v->def);
                }
            }
        }
        parsegodebug(godebugDefault, nullptr);
        parsegodebug(godebug, nullptr);
        debug.malloc = (debug.allocfreetrace | debug.inittrace | debug.sbrk) != 0;
        setTraceback(gogetenv("GOTRACEBACK"s));
        traceback_env = traceback_cache;
    }

    void reparsedebugvars(std::string env)
    {
        auto seen = gocpp::make(gocpp::Tag<gocpp::map<std::string, bool>>());
        parsegodebug(env, seen);
        parsegodebug(godebugDefault, seen);
        for(auto [gocpp_ignored, v] : dbgvars)
        {
            if(v->atomic != nullptr && ! seen[v->name])
            {
                rec::Store(gocpp::recv(v->atomic), 0);
            }
        }
    }

    void parsegodebug(std::string godebug, gocpp::map<std::string, bool> seen)
    {
        for(auto p = godebug; p != ""s; )
        {
            std::string field = {};
            if(seen == nullptr)
            {
                auto i = bytealg::IndexByteString(p, ',');
                if(i < 0)
                {
                    std::tie(field, p) = std::tuple{p, ""s};
                }
                else
                {
                    std::tie(field, p) = std::tuple{p.make_slice(0, i), p.make_slice(i + 1)};
                }
            }
            else
            {
                auto i = len(p) - 1;
                for(; i >= 0 && p[i] != ','; )
                {
                    i--;
                }
                if(i < 0)
                {
                    std::tie(p, field) = std::tuple{""s, p};
                }
                else
                {
                    std::tie(p, field) = std::tuple{p.make_slice(0, i), p.make_slice(i + 1)};
                }
            }
            auto i = bytealg::IndexByteString(field, '=');
            if(i < 0)
            {
                continue;
            }
            auto [key, value] = std::tuple{field.make_slice(0, i), field.make_slice(i + 1)};
            if(seen[key])
            {
                continue;
            }
            if(seen != nullptr)
            {
                seen[key] = true;
            }
            if(seen == nullptr && key == "memprofilerate"s)
            {
                if(auto [n, ok] = atoi(value); ok)
                {
                    MemProfileRate = n;
                }
            }
            else
            {
                for(auto [gocpp_ignored, v] : dbgvars)
                {
                    if(v->name == key)
                    {
                        if(auto [n, ok] = atoi32(value); ok)
                        {
                            if(seen == nullptr && v->value != nullptr)
                            {
                                *v->value = n;
                            }
                            else
                            if(v->atomic != nullptr)
                            {
                                rec::Store(gocpp::recv(v->atomic), n);
                            }
                        }
                    }
                }
            }
        }
        if(debug.cgocheck > 1)
        {
            go_throw("cgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead."s);
        }
    }

    void setTraceback(std::string level)
    {
        uint32_t t = {};
        //Go switch emulation
        {
            auto condition = level;
            int conditionId = -1;
            if(condition == "none"s) { conditionId = 0; }
            else if(condition == "single"s) { conditionId = 1; }
            else if(condition == ""s) { conditionId = 2; }
            else if(condition == "all"s) { conditionId = 3; }
            else if(condition == "system"s) { conditionId = 4; }
            else if(condition == "crash"s) { conditionId = 5; }
            else if(condition == "wer"s) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    t = 0;
                    break;
                case 1:
                case 2:
                    t = 1 << tracebackShift;
                    break;
                case 3:
                    t = (1 << tracebackShift) | tracebackAll;
                    break;
                case 4:
                    t = (2 << tracebackShift) | tracebackAll;
                    break;
                case 5:
                    t = (2 << tracebackShift) | tracebackAll | tracebackCrash;
                    break;
                case 6:
                    if(GOOS == "windows"s)
                    {
                        t = (2 << tracebackShift) | tracebackAll | tracebackCrash;
                        enableWER();
                        break;
                    }
                default:
                    t = tracebackAll;
                    if(auto [n, ok] = atoi(level); ok && n == int(uint32_t(n)))
                    {
                        t |= uint32_t(n) << tracebackShift;
                    }
                    break;
            }
        }
        if(islibrary || isarchive)
        {
            t |= tracebackCrash;
        }
        t |= traceback_env;
        atomic::Store(& traceback_cache, t);
    }

    int32_t timediv(int64_t v, int32_t div, int32_t* rem)
    {
        auto res = int32_t(0);
        for(auto bit = 30; bit >= 0; bit--)
        {
            if(v >= (int64_t(div) << (unsigned int)(bit)))
            {
                v = v - (int64_t(div) << (unsigned int)(bit));
                res |= 1 << (unsigned int)(bit);
            }
        }
        if(v >= int64_t(div))
        {
            if(rem != nullptr)
            {
                *rem = 0;
            }
            return 0x7fffffff;
        }
        if(rem != nullptr)
        {
            *rem = int32_t(v);
        }
        return res;
    }

    struct m* acquirem()
    {
        auto gp = getg();
        gp->m->locks++;
        return gp->m;
    }

    void releasem(struct m* mp)
    {
        auto gp = getg();
        mp->locks--;
        if(mp->locks == 0 && gp->preempt)
        {
            gp->stackguard0 = stackPreempt;
        }
    }

    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> reflect_typelinks()
    {
        auto modules = activeModules();
        auto sections = gocpp::slice<unsafe::Pointer> {unsafe::Pointer(modules[0]->types)};
        auto ret = gocpp::slice<gocpp::slice<int32_t>> {modules[0]->typelinks};
        for(auto [gocpp_ignored, md] : modules.make_slice(1))
        {
            sections = append(sections, unsafe::Pointer(md->types));
            ret = append(ret, md->typelinks);
        }
        return {sections, ret};
    }

    unsafe::Pointer reflect_resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    {
        return unsafe::Pointer(resolveNameOff(ptrInModule, nameOff(off)).Bytes);
    }

    unsafe::Pointer reflect_resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    {
        return unsafe::Pointer(rec::typeOff(gocpp::recv(toRType((runtime::_type*)(rtype))), typeOff(off)));
    }

    unsafe::Pointer reflect_resolveTextOff(unsafe::Pointer rtype, int32_t off)
    {
        return rec::textOff(gocpp::recv(toRType((runtime::_type*)(rtype))), textOff(off));
    }

    unsafe::Pointer reflectlite_resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    {
        return unsafe::Pointer(resolveNameOff(ptrInModule, nameOff(off)).Bytes);
    }

    unsafe::Pointer reflectlite_resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    {
        return unsafe::Pointer(rec::typeOff(gocpp::recv(toRType((runtime::_type*)(rtype))), typeOff(off)));
    }

    int32_t reflect_addReflectOff(unsafe::Pointer ptr)
    {
        reflectOffsLock();
        if(reflectOffs.m == nullptr)
        {
            reflectOffs.m = gocpp::make(gocpp::Tag<gocpp::map<int32_t, unsafe::Pointer>>());
            reflectOffs.minv = gocpp::make(gocpp::Tag<gocpp::map<unsafe::Pointer, int32_t>>());
            reflectOffs.next = - 1;
        }
        auto [id, found] = reflectOffs.minv[ptr];
        if(! found)
        {
            id = reflectOffs.next;
            reflectOffs.next--;
            reflectOffs.m[id] = ptr;
            reflectOffs.minv[ptr] = id;
        }
        reflectOffsUnlock();
        return id;
    }

}

