// generated by GoCpp from file '$(ImportDir)/sync/cond.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/cond.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/doc.h"
#include "golang/sync/mutex.h"
#include "golang/sync/runtime.h"
#include "golang/sync/runtime2.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Cond implements a condition variable, a rendezvous point
    // for goroutines waiting for or announcing the occurrence
    // of an event.
    //
    // Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
    // which must be held when changing the condition and
    // when calling the Wait method.
    //
    // A Cond must not be copied after first use.
    //
    // In the terminology of the Go memory model, Cond arranges that
    // a call to Broadcast or Signal “synchronizes before” any Wait call
    // that it unblocks.
    //
    // For many simple use cases, users will be better off using channels than a
    // Cond (Broadcast corresponds to closing a channel, and Signal corresponds to
    // sending on a channel).
    //
    // For more on replacements for sync.Cond, see [Roberto Clapis's series on
    // advanced concurrency patterns], as well as [Bryan Mills's talk on concurrency
    // patterns].
    //
    // [Roberto Clapis's series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/
    // [Bryan Mills's talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view
    
    template<typename T> requires gocpp::GoStruct<T>
    Cond::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.L = this->L;
        result.notify = this->notify;
        result.checker = this->checker;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Cond::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (L != ref.L) return false;
        if (notify != ref.notify) return false;
        if (checker != ref.checker) return false;
        return true;
    }

    std::ostream& Cond::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << L;
        os << " " << notify;
        os << " " << checker;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Cond& value)
    {
        return value.PrintTo(os);
    }

    // NewCond returns a new Cond with Locker l.
    struct Cond* NewCond(struct Locker l)
    {
        return gocpp::InitPtr<Cond>([=](auto& x) {
            x.L = l;
        });
    }

    // Wait atomically unlocks c.L and suspends execution
    // of the calling goroutine. After later resuming execution,
    // Wait locks c.L before returning. Unlike in other systems,
    // Wait cannot return unless awoken by Broadcast or Signal.
    //
    // Because c.L is not locked while Wait is waiting, the caller
    // typically cannot assume that the condition is true when
    // Wait returns. Instead, the caller should Wait in a loop:
    //
    //	c.L.Lock()
    //	for !condition() {
    //	    c.Wait()
    //	}
    //	... make use of condition ...
    //	c.L.Unlock()
    void rec::Wait(golang::sync::Cond* c)
    {
        rec::check(gocpp::recv(c->checker));
        auto t = runtime_notifyListAdd(& c->notify);
        rec::Unlock(gocpp::recv(c->L));
        runtime_notifyListWait(& c->notify, t);
        rec::Lock(gocpp::recv(c->L));
    }

    // Signal wakes one goroutine waiting on c, if there is any.
    //
    // It is allowed but not required for the caller to hold c.L
    // during the call.
    //
    // Signal() does not affect goroutine scheduling priority; if other goroutines
    // are attempting to lock c.L, they may be awoken before a "waiting" goroutine.
    void rec::Signal(golang::sync::Cond* c)
    {
        rec::check(gocpp::recv(c->checker));
        runtime_notifyListNotifyOne(& c->notify);
    }

    // Broadcast wakes all goroutines waiting on c.
    //
    // It is allowed but not required for the caller to hold c.L
    // during the call.
    void rec::Broadcast(golang::sync::Cond* c)
    {
        rec::check(gocpp::recv(c->checker));
        runtime_notifyListNotifyAll(& c->notify);
    }

    // copyChecker holds back pointer to itself to detect object copying.
    void rec::check(golang::sync::copyChecker* c)
    {
        if(uintptr_t(*c) != uintptr_t(unsafe::Pointer(c)) && ! atomic::CompareAndSwapUintptr((uintptr_t*)(c), 0, uintptr_t(unsafe::Pointer(c))) && uintptr_t(*c) != uintptr_t(unsafe::Pointer(c)))
        {
            gocpp::panic("sync.Cond is copied"_s);
        }
    }

    // noCopy may be added to structs which must not be copied
    // after the first use.
    //
    // See https://golang.org/issues/8005#issuecomment-190753527
    // for details.
    //
    // Note that it must not be embedded, due to the Lock and Unlock methods.
    
    template<typename T> requires gocpp::GoStruct<T>
    noCopy::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noCopy::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noCopy::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value)
    {
        return value.PrintTo(os);
    }

    // Lock is a no-op used by -copylocks checker from `go vet`.
    void rec::Lock(golang::sync::noCopy*)
    {
    }

    void rec::Unlock(golang::sync::noCopy*)
    {
    }

}

