// generated by GoCpp from file '$(ImportDir)/strconv/itoa.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/itoa.h"
#include "gocpp/support.h"

#include "golang/math/bits/bits.h"

namespace golang::strconv
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // FormatUint returns the string representation of i in the given base,
    // for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
    // for digit values >= 10.
    gocpp::string FormatUint(uint64_t i, int base)
    {
        if(fastSmalls && i < nSmalls && base == 10)
        {
            return small(int(i));
        }
        auto [gocpp_id_0, s] = formatBits(nullptr, i, base, false, false);
        return s;
    }

    // FormatInt returns the string representation of i in the given base,
    // for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
    // for digit values >= 10.
    gocpp::string FormatInt(int64_t i, int base)
    {
        if(fastSmalls && 0 <= i && i < nSmalls && base == 10)
        {
            return small(int(i));
        }
        auto [gocpp_id_1, s] = formatBits(nullptr, uint64_t(i), base, i < 0, false);
        return s;
    }

    // Itoa is equivalent to FormatInt(int64(i), 10).
    gocpp::string Itoa(int i)
    {
        return FormatInt(int64_t(i), 10);
    }

    // AppendInt appends the string form of the integer i,
    // as generated by FormatInt, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendInt(gocpp::slice<unsigned char> dst, int64_t i, int base)
    {
        if(fastSmalls && 0 <= i && i < nSmalls && base == 10)
        {
            return append(dst, small(int(i)));
        }
        std::tie(dst, gocpp_id_2) = formatBits(dst, uint64_t(i), base, i < 0, true);
        return dst;
    }

    // AppendUint appends the string form of the unsigned integer i,
    // as generated by FormatUint, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendUint(gocpp::slice<unsigned char> dst, uint64_t i, int base)
    {
        if(fastSmalls && i < nSmalls && base == 10)
        {
            return append(dst, small(int(i)));
        }
        std::tie(dst, gocpp_id_3) = formatBits(dst, i, base, false, true);
        return dst;
    }

    // small returns the string for an i with 0 <= i < nSmalls.
    gocpp::string small(int i)
    {
        if(i < 10)
        {
            return digits.make_slice(i, i + 1);
        }
        return smallsString.make_slice(i * 2, i * 2 + 2);
    }

    gocpp::string smallsString = "00010203040506070809"_s + "10111213141516171819"_s + "20212223242526272829"_s + "30313233343536373839"_s + "40414243444546474849"_s + "50515253545556575859"_s + "60616263646566676869"_s + "70717273747576777879"_s + "80818283848586878889"_s + "90919293949596979899"_s;
    gocpp::string digits = "0123456789abcdefghijklmnopqrstuvwxyz"_s;
    // formatBits computes the string representation of u in the given base.
    // If neg is set, u is treated as negative int64 value. If append_ is
    // set, the string is appended to dst and the resulting byte slice is
    // returned as the first result value; otherwise the string is returned
    // as the second result value.
    std::tuple<gocpp::slice<unsigned char>, gocpp::string> formatBits(gocpp::slice<unsigned char> dst, uint64_t u, int base, bool neg, bool append_)
    {
        gocpp::slice<unsigned char> d;
        gocpp::string s;
        if(base < 2 || base > len(digits))
        {
            gocpp::panic("strconv: illegal AppendInt/FormatInt base"_s);
        }
        gocpp::array<unsigned char, 64 + 1> a = {};
        auto i = len(a);
        if(neg)
        {
            u = - u;
        }
        if(base == 10)
        {
            if(host32bit)
            {
                for(; u >= 1e9; )
                {
                    auto q = u / 1e9;
                    auto us = (unsigned int)(u - q * 1e9);
                    for(auto j = 4; j > 0; j--)
                    {
                        auto is = us % 100 * 2;
                        us /= 100;
                        i -= 2;
                        a[i + 1] = smallsString[is + 1];
                        a[i + 0] = smallsString[is + 0];
                    }
                    i--;
                    a[i] = smallsString[us * 2 + 1];
                    u = q;
                }
            }
            auto us = (unsigned int)(u);
            for(; us >= 100; )
            {
                auto is = us % 100 * 2;
                us /= 100;
                i -= 2;
                a[i + 1] = smallsString[is + 1];
                a[i + 0] = smallsString[is + 0];
            }
            auto is = us * 2;
            i--;
            a[i] = smallsString[is + 1];
            if(us >= 10)
            {
                i--;
                a[i] = smallsString[is];
            }
        }
        else
        if(isPowerOfTwo(base))
        {
            auto shift = (unsigned int)(bits::TrailingZeros((unsigned int)(base))) & 7;
            auto b = uint64_t(base);
            auto m = (unsigned int)(base) - 1;
            for(; u >= b; )
            {
                i--;
                a[i] = digits[(unsigned int)(u) & m];
                u >>= shift;
            }
            i--;
            a[i] = digits[(unsigned int)(u)];
        }
        else
        {
            auto b = uint64_t(base);
            for(; u >= b; )
            {
                i--;
                auto q = u / b;
                a[i] = digits[(unsigned int)(u - q * b)];
                u = q;
            }
            i--;
            a[i] = digits[(unsigned int)(u)];
        }
        if(neg)
        {
            i--;
            a[i] = '-';
        }
        if(append_)
        {
            d = append(dst, a.make_slice(i));
            return {d, s};
        }
        s = gocpp::string(a.make_slice(i));
        return {d, s};
    }

    bool isPowerOfTwo(int x)
    {
        return x & (x - 1) == 0;
    }

}

