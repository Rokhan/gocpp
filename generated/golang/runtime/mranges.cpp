// generated by GoCpp from file '$(ImportDir)/runtime/mranges.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mranges.h"
#include "gocpp/support.h"

#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/print.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // addrRange represents a region of address space.
    //
    // An addrRange must never span a gap in the address space.
    
    template<typename T> requires gocpp::GoStruct<T>
    addrRange::operator T()
    {
        T result;
        result.base = this->base;
        result.limit = this->limit;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool addrRange::operator==(const T& ref) const
    {
        if (base != ref.base) return false;
        if (limit != ref.limit) return false;
        return true;
    }

    std::ostream& addrRange::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << base;
        os << " " << limit;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct addrRange& value)
    {
        return value.PrintTo(os);
    }

    // makeAddrRange creates a new address range from two virtual addresses.
    //
    // Throws if the base and limit are not in the same memory segment.
    struct addrRange makeAddrRange(uintptr_t base, uintptr_t limit)
    {
        auto r = addrRange {offAddr {base}, offAddr {limit}};
        if((base - arenaBaseOffset >= base) != (limit - arenaBaseOffset >= limit))
        {
            go_throw("addr range base and limit are not in the same memory segment"s);
        }
        return r;
    }

    // size returns the size of the range represented in bytes.
    uintptr_t rec::size(struct addrRange a)
    {
        if(! rec::lessThan(gocpp::recv(a.base), a.limit))
        {
            return 0;
        }
        return rec::diff(gocpp::recv(a.limit), a.base);
    }

    // contains returns whether or not the range contains a given address.
    bool rec::contains(struct addrRange a, uintptr_t addr)
    {
        return rec::lessEqual(gocpp::recv(a.base), offAddr {addr}) && rec::lessThan(gocpp::recv((offAddr {addr})), a.limit);
    }

    // subtract takes the addrRange toPrune and cuts out any overlap with
    // from, then returns the new range. subtract assumes that a and b
    // either don't overlap at all, only overlap on one side, or are equal.
    // If b is strictly contained in a, thus forcing a split, it will throw.
    struct addrRange rec::subtract(struct addrRange a, struct addrRange b)
    {
        if(rec::lessEqual(gocpp::recv(b.base), a.base) && rec::lessEqual(gocpp::recv(a.limit), b.limit))
        {
            return addrRange {};
        }
        else
        if(rec::lessThan(gocpp::recv(a.base), b.base) && rec::lessThan(gocpp::recv(b.limit), a.limit))
        {
            go_throw("bad prune"s);
        }
        else
        if(rec::lessThan(gocpp::recv(b.limit), a.limit) && rec::lessThan(gocpp::recv(a.base), b.limit))
        {
            a.base = b.limit;
        }
        else
        if(rec::lessThan(gocpp::recv(a.base), b.base) && rec::lessThan(gocpp::recv(b.base), a.limit))
        {
            a.limit = b.base;
        }
        return a;
    }

    // takeFromFront takes len bytes from the front of the address range, aligning
    // the base to align first. On success, returns the aligned start of the region
    // taken and true.
    std::tuple<uintptr_t, bool> rec::takeFromFront(struct addrRange* a, uintptr_t len, uint8_t align)
    {
        auto base = alignUp(rec::addr(gocpp::recv(a->base)), uintptr_t(align)) + len;
        if(base > rec::addr(gocpp::recv(a->limit)))
        {
            return {0, false};
        }
        a->base = offAddr {base};
        return {base - len, true};
    }

    // takeFromBack takes len bytes from the end of the address range, aligning
    // the limit to align after subtracting len. On success, returns the aligned
    // start of the region taken and true.
    std::tuple<uintptr_t, bool> rec::takeFromBack(struct addrRange* a, uintptr_t len, uint8_t align)
    {
        auto limit = alignDown(rec::addr(gocpp::recv(a->limit)) - len, uintptr_t(align));
        if(rec::addr(gocpp::recv(a->base)) > limit)
        {
            return {0, false};
        }
        a->limit = offAddr {limit};
        return {limit, true};
    }

    // removeGreaterEqual removes all addresses in a greater than or equal
    // to addr and returns the new range.
    struct addrRange rec::removeGreaterEqual(struct addrRange a, uintptr_t addr)
    {
        if(rec::lessEqual(gocpp::recv((offAddr {addr})), a.base))
        {
            return addrRange {};
        }
        if(rec::lessEqual(gocpp::recv(a.limit), offAddr {addr}))
        {
            return a;
        }
        return makeAddrRange(rec::addr(gocpp::recv(a.base)), addr);
    }

    // minOffAddr is the minimum address in the offset space, and
    // it corresponds to the virtual address arenaBaseOffset.
    // maxOffAddr is the maximum address in the offset address
    // space. It corresponds to the highest virtual address representable
    // by the page alloc chunk and heap arena maps.
    offAddr minOffAddr = offAddr {arenaBaseOffset};
    offAddr maxOffAddr = offAddr {(((1 << heapAddrBits) - 1) + arenaBaseOffset) & uintptrMask};
    // offAddr represents an address in a contiguous view
    // of the address space on systems where the address space is
    // segmented. On other systems, it's just a normal address.
    
    template<typename T> requires gocpp::GoStruct<T>
    offAddr::operator T()
    {
        T result;
        result.a = this->a;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool offAddr::operator==(const T& ref) const
    {
        if (a != ref.a) return false;
        return true;
    }

    std::ostream& offAddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct offAddr& value)
    {
        return value.PrintTo(os);
    }

    // add adds a uintptr offset to the offAddr.
    struct offAddr rec::add(struct offAddr l, uintptr_t bytes)
    {
        return gocpp::Init<offAddr>([=](auto& x) {
            x.a = l.a + bytes;
        });
    }

    // sub subtracts a uintptr offset from the offAddr.
    struct offAddr rec::sub(struct offAddr l, uintptr_t bytes)
    {
        return gocpp::Init<offAddr>([=](auto& x) {
            x.a = l.a - bytes;
        });
    }

    // diff returns the amount of bytes in between the
    // two offAddrs.
    uintptr_t rec::diff(struct offAddr l1, struct offAddr l2)
    {
        return l1.a - l2.a;
    }

    // lessThan returns true if l1 is less than l2 in the offset
    // address space.
    bool rec::lessThan(struct offAddr l1, struct offAddr l2)
    {
        return (l1.a - arenaBaseOffset) < (l2.a - arenaBaseOffset);
    }

    // lessEqual returns true if l1 is less than or equal to l2 in
    // the offset address space.
    bool rec::lessEqual(struct offAddr l1, struct offAddr l2)
    {
        return (l1.a - arenaBaseOffset) <= (l2.a - arenaBaseOffset);
    }

    // equal returns true if the two offAddr values are equal.
    bool rec::equal(struct offAddr l1, struct offAddr l2)
    {
        return l1 == l2;
    }

    // addr returns the virtual address for this offset address.
    uintptr_t rec::addr(struct offAddr l)
    {
        return l.a;
    }

    // atomicOffAddr is like offAddr, but operations on it are atomic.
    // It also contains operations to be able to store marked addresses
    // to ensure that they're not overridden until they've been seen.
    
    template<typename T> requires gocpp::GoStruct<T>
    atomicOffAddr::operator T()
    {
        T result;
        result.a = this->a;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicOffAddr::operator==(const T& ref) const
    {
        if (a != ref.a) return false;
        return true;
    }

    std::ostream& atomicOffAddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicOffAddr& value)
    {
        return value.PrintTo(os);
    }

    // Clear attempts to store minOffAddr in atomicOffAddr. It may fail
    // if a marked value is placed in the box in the meanwhile.
    void rec::Clear(struct atomicOffAddr* b)
    {
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(b->a));
            if(old < 0)
            {
                return;
            }
            if(rec::CompareAndSwap(gocpp::recv(b->a), old, int64_t(rec::addr(gocpp::recv(minOffAddr)) - arenaBaseOffset)))
            {
                return;
            }
        }
    }

    // StoreMin stores addr if it's less than the current value in the
    // offset address space if the current value is not marked.
    void rec::StoreMin(struct atomicOffAddr* b, uintptr_t addr)
    {
        auto go_new = int64_t(addr - arenaBaseOffset);
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(b->a));
            if(old < go_new)
            {
                return;
            }
            if(rec::CompareAndSwap(gocpp::recv(b->a), old, go_new))
            {
                return;
            }
        }
    }

    // StoreUnmark attempts to unmark the value in atomicOffAddr and
    // replace it with newAddr. markedAddr must be a marked address
    // returned by Load. This function will not store newAddr if the
    // box no longer contains markedAddr.
    void rec::StoreUnmark(struct atomicOffAddr* b, uintptr_t markedAddr, uintptr_t newAddr)
    {
        rec::CompareAndSwap(gocpp::recv(b->a), - int64_t(markedAddr - arenaBaseOffset), int64_t(newAddr - arenaBaseOffset));
    }

    // StoreMarked stores addr but first converted to the offset address
    // space and then negated.
    void rec::StoreMarked(struct atomicOffAddr* b, uintptr_t addr)
    {
        rec::Store(gocpp::recv(b->a), - int64_t(addr - arenaBaseOffset));
    }

    // Load returns the address in the box as a virtual address. It also
    // returns if the value was marked or not.
    std::tuple<uintptr_t, bool> rec::Load(struct atomicOffAddr* b)
    {
        auto v = rec::Load(gocpp::recv(b->a));
        auto wasMarked = false;
        if(v < 0)
        {
            wasMarked = true;
            v = - v;
        }
        return {uintptr_t(v) + arenaBaseOffset, wasMarked};
    }

    // addrRanges is a data structure holding a collection of ranges of
    // address space.
    //
    // The ranges are coalesced eagerly to reduce the
    // number ranges it holds.
    //
    // The slice backing store for this field is persistentalloc'd
    // and thus there is no way to free it.
    //
    // addrRanges is not thread-safe.
    
    template<typename T> requires gocpp::GoStruct<T>
    addrRanges::operator T()
    {
        T result;
        result.ranges = this->ranges;
        result.totalBytes = this->totalBytes;
        result.sysStat = this->sysStat;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool addrRanges::operator==(const T& ref) const
    {
        if (ranges != ref.ranges) return false;
        if (totalBytes != ref.totalBytes) return false;
        if (sysStat != ref.sysStat) return false;
        return true;
    }

    std::ostream& addrRanges::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ranges;
        os << " " << totalBytes;
        os << " " << sysStat;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct addrRanges& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct addrRanges* a, golang::runtime::sysMemStat* sysStat)
    {
        auto ranges = (notInHeapSlice*)(unsafe::Pointer(& a->ranges));
        ranges->len = 0;
        ranges->cap = 16;
        ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, sysStat));
        a->sysStat = sysStat;
        a->totalBytes = 0;
    }

    // findSucc returns the first index in a such that addr is
    // less than the base of the addrRange at that index.
    int rec::findSucc(struct addrRanges* a, uintptr_t addr)
    {
        auto base = offAddr {addr};
        // Narrow down the search space via a binary search
        // for large addrRanges until we have at most iterMax
        // candidates left.
        auto iterMax = 8;
        auto [bot, top] = std::tuple{0, len(a->ranges)};
        for(; top - bot > iterMax; )
        {
            auto i = int((unsigned int)(bot + top) >> 1);
            if(rec::contains(gocpp::recv(a->ranges[i]), rec::addr(gocpp::recv(base))))
            {
                return i + 1;
            }
            if(rec::lessThan(gocpp::recv(base), a->ranges[i].base))
            {
                top = i;
            }
            else
            {
                bot = i + 1;
            }
        }
        for(auto i = bot; i < top; i++)
        {
            if(rec::lessThan(gocpp::recv(base), a->ranges[i].base))
            {
                return i;
            }
        }
        return top;
    }

    // findAddrGreaterEqual returns the smallest address represented by a
    // that is >= addr. Thus, if the address is represented by a,
    // then it returns addr. The second return value indicates whether
    // such an address exists for addr in a. That is, if addr is larger than
    // any address known to a, the second return value will be false.
    std::tuple<uintptr_t, bool> rec::findAddrGreaterEqual(struct addrRanges* a, uintptr_t addr)
    {
        auto i = rec::findSucc(gocpp::recv(a), addr);
        if(i == 0)
        {
            return {rec::addr(gocpp::recv(a->ranges[0].base)), true};
        }
        if(rec::contains(gocpp::recv(a->ranges[i - 1]), addr))
        {
            return {addr, true};
        }
        if(i < len(a->ranges))
        {
            return {rec::addr(gocpp::recv(a->ranges[i].base)), true};
        }
        return {0, false};
    }

    // contains returns true if a covers the address addr.
    bool rec::contains(struct addrRanges* a, uintptr_t addr)
    {
        auto i = rec::findSucc(gocpp::recv(a), addr);
        if(i == 0)
        {
            return false;
        }
        return rec::contains(gocpp::recv(a->ranges[i - 1]), addr);
    }

    // add inserts a new address range to a.
    //
    // r must not overlap with any address range in a and r.size() must be > 0.
    void rec::add(struct addrRanges* a, struct addrRange r)
    {
        if(rec::size(gocpp::recv(r)) == 0)
        {
            print("runtime: range = {"s, hex(rec::addr(gocpp::recv(r.base))), ", "s, hex(rec::addr(gocpp::recv(r.limit))), "}\n"s);
            go_throw("attempted to add zero-sized address range"s);
        }
        auto i = rec::findSucc(gocpp::recv(a), rec::addr(gocpp::recv(r.base)));
        auto coalescesDown = i > 0 && rec::equal(gocpp::recv(a->ranges[i - 1].limit), r.base);
        auto coalescesUp = i < len(a->ranges) && rec::equal(gocpp::recv(r.limit), a->ranges[i].base);
        if(coalescesUp && coalescesDown)
        {
            a->ranges[i - 1].limit = a->ranges[i].limit;
            copy(a->ranges.make_slice(i), a->ranges.make_slice(i + 1));
            a->ranges = a->ranges.make_slice(0, len(a->ranges) - 1);
        }
        else
        if(coalescesDown)
        {
            a->ranges[i - 1].limit = r.limit;
        }
        else
        if(coalescesUp)
        {
            a->ranges[i].base = r.base;
        }
        else
        {
            if(len(a->ranges) + 1 > cap(a->ranges))
            {
                auto oldRanges = a->ranges;
                auto ranges = (notInHeapSlice*)(unsafe::Pointer(& a->ranges));
                ranges->len = len(oldRanges) + 1;
                ranges->cap = cap(oldRanges) * 2;
                ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, a->sysStat));
                copy(a->ranges.make_slice(0, i), oldRanges.make_slice(0, i));
                copy(a->ranges.make_slice(i + 1), oldRanges.make_slice(i));
            }
            else
            {
                a->ranges = a->ranges.make_slice(0, len(a->ranges) + 1);
                copy(a->ranges.make_slice(i + 1), a->ranges.make_slice(i));
            }
            a->ranges[i] = r;
        }
        a->totalBytes += rec::size(gocpp::recv(r));
    }

    // removeLast removes and returns the highest-addressed contiguous range
    // of a, or the last nBytes of that range, whichever is smaller. If a is
    // empty, it returns an empty range.
    struct addrRange rec::removeLast(struct addrRanges* a, uintptr_t nBytes)
    {
        if(len(a->ranges) == 0)
        {
            return addrRange {};
        }
        auto r = a->ranges[len(a->ranges) - 1];
        auto size = rec::size(gocpp::recv(r));
        if(size > nBytes)
        {
            auto newEnd = rec::sub(gocpp::recv(r.limit), nBytes);
            a->ranges[len(a->ranges) - 1].limit = newEnd;
            a->totalBytes -= nBytes;
            return addrRange {newEnd, r.limit};
        }
        a->ranges = a->ranges.make_slice(0, len(a->ranges) - 1);
        a->totalBytes -= size;
        return r;
    }

    // removeGreaterEqual removes the ranges of a which are above addr, and additionally
    // splits any range containing addr.
    void rec::removeGreaterEqual(struct addrRanges* a, uintptr_t addr)
    {
        auto pivot = rec::findSucc(gocpp::recv(a), addr);
        if(pivot == 0)
        {
            a->totalBytes = 0;
            a->ranges = a->ranges.make_slice(0, 0);
            return;
        }
        auto removed = uintptr_t(0);
        for(auto [gocpp_ignored, r] : a->ranges.make_slice(pivot))
        {
            removed += rec::size(gocpp::recv(r));
        }
        if(auto r = a->ranges[pivot - 1]; rec::contains(gocpp::recv(r), addr))
        {
            removed += rec::size(gocpp::recv(r));
            r = rec::removeGreaterEqual(gocpp::recv(r), addr);
            if(rec::size(gocpp::recv(r)) == 0)
            {
                pivot--;
            }
            else
            {
                removed -= rec::size(gocpp::recv(r));
                a->ranges[pivot - 1] = r;
            }
        }
        a->ranges = a->ranges.make_slice(0, pivot);
        a->totalBytes -= removed;
    }

    // cloneInto makes a deep clone of a's state into b, re-using
    // b's ranges if able.
    void rec::cloneInto(struct addrRanges* a, struct addrRanges* b)
    {
        if(len(a->ranges) > cap(b->ranges))
        {
            auto ranges = (notInHeapSlice*)(unsafe::Pointer(& b->ranges));
            ranges->len = 0;
            ranges->cap = cap(a->ranges);
            ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, b->sysStat));
        }
        b->ranges = b->ranges.make_slice(0, len(a->ranges));
        b->totalBytes = a->totalBytes;
        copy(b->ranges, a->ranges);
    }

}

