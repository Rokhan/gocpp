// generated by GoCpp from file '$(ImportDir)/syscall/zsyscall_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/zsyscall_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/sync/mutex.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"

namespace golang::syscall
{
    extern gocpp::error errERROR_IO_PENDING;
    extern gocpp::error errERROR_EINVAL;
    gocpp::error errnoErr(Errno e);
    extern LazyDLL* modadvapi32;
    extern LazyDLL* modcrypt32;
    extern LazyDLL* moddnsapi;
    extern LazyDLL* modiphlpapi;
    extern LazyDLL* modkernel32;
    extern LazyDLL* modmswsock;
    extern LazyDLL* modnetapi32;
    extern LazyDLL* modntdll;
    extern LazyDLL* modsecur32;
    extern LazyDLL* modshell32;
    extern LazyDLL* moduserenv;
    extern LazyDLL* modws2_32;
    extern LazyProc* procConvertSidToStringSidW;
    extern LazyProc* procConvertStringSidToSidW;
    extern LazyProc* procCopySid;
    extern LazyProc* procCreateProcessAsUserW;
    extern LazyProc* procCryptAcquireContextW;
    extern LazyProc* procCryptGenRandom;
    extern LazyProc* procCryptReleaseContext;
    extern LazyProc* procGetLengthSid;
    extern LazyProc* procGetTokenInformation;
    extern LazyProc* procLookupAccountNameW;
    extern LazyProc* procLookupAccountSidW;
    extern LazyProc* procOpenProcessToken;
    extern LazyProc* procRegCloseKey;
    extern LazyProc* procRegEnumKeyExW;
    extern LazyProc* procRegOpenKeyExW;
    extern LazyProc* procRegQueryInfoKeyW;
    extern LazyProc* procRegQueryValueExW;
    extern LazyProc* procCertAddCertificateContextToStore;
    extern LazyProc* procCertCloseStore;
    extern LazyProc* procCertCreateCertificateContext;
    extern LazyProc* procCertEnumCertificatesInStore;
    extern LazyProc* procCertFreeCertificateChain;
    extern LazyProc* procCertFreeCertificateContext;
    extern LazyProc* procCertGetCertificateChain;
    extern LazyProc* procCertOpenStore;
    extern LazyProc* procCertOpenSystemStoreW;
    extern LazyProc* procCertVerifyCertificateChainPolicy;
    extern LazyProc* procDnsNameCompare_W;
    extern LazyProc* procDnsQuery_W;
    extern LazyProc* procDnsRecordListFree;
    extern LazyProc* procGetAdaptersInfo;
    extern LazyProc* procGetIfEntry;
    extern LazyProc* procCancelIo;
    extern LazyProc* procCancelIoEx;
    extern LazyProc* procCloseHandle;
    extern LazyProc* procCreateDirectoryW;
    extern LazyProc* procCreateFileMappingW;
    extern LazyProc* procCreateFileW;
    extern LazyProc* procCreateHardLinkW;
    extern LazyProc* procCreateIoCompletionPort;
    extern LazyProc* procCreatePipe;
    extern LazyProc* procCreateProcessW;
    extern LazyProc* procCreateSymbolicLinkW;
    extern LazyProc* procCreateToolhelp32Snapshot;
    extern LazyProc* procDeleteFileW;
    extern LazyProc* procDeleteProcThreadAttributeList;
    extern LazyProc* procDeviceIoControl;
    extern LazyProc* procDuplicateHandle;
    extern LazyProc* procExitProcess;
    extern LazyProc* procFindClose;
    extern LazyProc* procFindFirstFileW;
    extern LazyProc* procFindNextFileW;
    extern LazyProc* procFlushFileBuffers;
    extern LazyProc* procFlushViewOfFile;
    extern LazyProc* procFormatMessageW;
    extern LazyProc* procFreeEnvironmentStringsW;
    extern LazyProc* procFreeLibrary;
    extern LazyProc* procGetCommandLineW;
    extern LazyProc* procGetComputerNameW;
    extern LazyProc* procGetConsoleMode;
    extern LazyProc* procGetCurrentDirectoryW;
    extern LazyProc* procGetCurrentProcess;
    extern LazyProc* procGetCurrentProcessId;
    extern LazyProc* procGetEnvironmentStringsW;
    extern LazyProc* procGetEnvironmentVariableW;
    extern LazyProc* procGetExitCodeProcess;
    extern LazyProc* procGetFileAttributesExW;
    extern LazyProc* procGetFileAttributesW;
    extern LazyProc* procGetFileInformationByHandle;
    extern LazyProc* procGetFileType;
    extern LazyProc* procGetFinalPathNameByHandleW;
    extern LazyProc* procGetFullPathNameW;
    extern LazyProc* procGetLastError;
    extern LazyProc* procGetLongPathNameW;
    extern LazyProc* procGetProcAddress;
    extern LazyProc* procGetProcessTimes;
    extern LazyProc* procGetQueuedCompletionStatus;
    extern LazyProc* procGetShortPathNameW;
    extern LazyProc* procGetStartupInfoW;
    extern LazyProc* procGetStdHandle;
    extern LazyProc* procGetSystemTimeAsFileTime;
    extern LazyProc* procGetTempPathW;
    extern LazyProc* procGetTimeZoneInformation;
    extern LazyProc* procGetVersion;
    extern LazyProc* procInitializeProcThreadAttributeList;
    extern LazyProc* procLoadLibraryW;
    extern LazyProc* procLocalFree;
    extern LazyProc* procMapViewOfFile;
    extern LazyProc* procMoveFileW;
    extern LazyProc* procOpenProcess;
    extern LazyProc* procPostQueuedCompletionStatus;
    extern LazyProc* procProcess32FirstW;
    extern LazyProc* procProcess32NextW;
    extern LazyProc* procReadConsoleW;
    extern LazyProc* procReadDirectoryChangesW;
    extern LazyProc* procReadFile;
    extern LazyProc* procRemoveDirectoryW;
    extern LazyProc* procSetCurrentDirectoryW;
    extern LazyProc* procSetEndOfFile;
    extern LazyProc* procSetEnvironmentVariableW;
    extern LazyProc* procSetFileAttributesW;
    extern LazyProc* procSetFileCompletionNotificationModes;
    extern LazyProc* procSetFilePointer;
    extern LazyProc* procSetFileTime;
    extern LazyProc* procSetHandleInformation;
    extern LazyProc* procTerminateProcess;
    extern LazyProc* procUnmapViewOfFile;
    extern LazyProc* procUpdateProcThreadAttribute;
    extern LazyProc* procVirtualLock;
    extern LazyProc* procVirtualUnlock;
    extern LazyProc* procWaitForSingleObject;
    extern LazyProc* procWriteConsoleW;
    extern LazyProc* procWriteFile;
    extern LazyProc* procAcceptEx;
    extern LazyProc* procGetAcceptExSockaddrs;
    extern LazyProc* procTransmitFile;
    extern LazyProc* procNetApiBufferFree;
    extern LazyProc* procNetGetJoinInformation;
    extern LazyProc* procNetUserGetInfo;
    extern LazyProc* procRtlGetNtVersionNumbers;
    extern LazyProc* procGetUserNameExW;
    extern LazyProc* procTranslateNameW;
    extern LazyProc* procCommandLineToArgvW;
    extern LazyProc* procGetUserProfileDirectoryW;
    extern LazyProc* procFreeAddrInfoW;
    extern LazyProc* procGetAddrInfoW;
    extern LazyProc* procWSACleanup;
    extern LazyProc* procWSAEnumProtocolsW;
    extern LazyProc* procWSAIoctl;
    extern LazyProc* procWSARecv;
    extern LazyProc* procWSARecvFrom;
    extern LazyProc* procWSASend;
    extern LazyProc* procWSASendTo;
    extern LazyProc* procWSAStartup;
    extern LazyProc* procbind;
    extern LazyProc* procclosesocket;
    extern LazyProc* procconnect;
    extern LazyProc* procgethostbyname;
    extern LazyProc* procgetpeername;
    extern LazyProc* procgetprotobyname;
    extern LazyProc* procgetservbyname;
    extern LazyProc* procgetsockname;
    extern LazyProc* procgetsockopt;
    extern LazyProc* proclisten;
    extern LazyProc* procntohs;
    extern LazyProc* procsetsockopt;
    extern LazyProc* procshutdown;
    extern LazyProc* procsocket;
    gocpp::error ConvertSidToStringSid(SID* sid, uint16_t** stringSid);
    gocpp::error ConvertStringSidToSid(uint16_t* stringSid, SID** sid);
    gocpp::error CopySid(uint32_t destSidLen, SID* destSid, SID* srcSid);
    gocpp::error CreateProcessAsUser(Token token, uint16_t* appName, uint16_t* commandLine, SecurityAttributes* procSecurity, SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, StartupInfo* startupInfo, ProcessInformation* outProcInfo);
    gocpp::error CryptAcquireContext(Handle* provhandle, uint16_t* container, uint16_t* provider, uint32_t provtype, uint32_t flags);
    gocpp::error CryptGenRandom(Handle provhandle, uint32_t buflen, unsigned char* buf);
    gocpp::error CryptReleaseContext(Handle provhandle, uint32_t flags);
    uint32_t GetLengthSid(SID* sid);
    gocpp::error GetTokenInformation(Token t, uint32_t infoClass, unsigned char* info, uint32_t infoLen, uint32_t* returnedLen);
    gocpp::error LookupAccountName(uint16_t* systemName, uint16_t* accountName, SID* sid, uint32_t* sidLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use);
    gocpp::error LookupAccountSid(uint16_t* systemName, SID* sid, uint16_t* name, uint32_t* nameLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use);
    gocpp::error OpenProcessToken(Handle h, uint32_t access, Token* token);
    gocpp::error RegCloseKey(Handle key);
    gocpp::error regEnumKeyEx(Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, Filetime* lastWriteTime);
    gocpp::error RegOpenKeyEx(Handle key, uint16_t* subkey, uint32_t options, uint32_t desiredAccess, Handle* result);
    gocpp::error RegQueryInfoKey(Handle key, uint16_t* go_class, uint32_t* classLen, uint32_t* reserved, uint32_t* subkeysLen, uint32_t* maxSubkeyLen, uint32_t* maxClassLen, uint32_t* valuesLen, uint32_t* maxValueNameLen, uint32_t* maxValueLen, uint32_t* saLen, Filetime* lastWriteTime);
    gocpp::error RegQueryValueEx(Handle key, uint16_t* name, uint32_t* reserved, uint32_t* valtype, unsigned char* buf, uint32_t* buflen);
    gocpp::error CertAddCertificateContextToStore(Handle store, CertContext* certContext, uint32_t addDisposition, CertContext** storeContext);
    gocpp::error CertCloseStore(Handle store, uint32_t flags);
    std::tuple<CertContext*, gocpp::error> CertCreateCertificateContext(uint32_t certEncodingType, unsigned char* certEncoded, uint32_t encodedLen);
    std::tuple<CertContext*, gocpp::error> CertEnumCertificatesInStore(Handle store, CertContext* prevContext);
    void CertFreeCertificateChain(CertChainContext* ctx);
    gocpp::error CertFreeCertificateContext(CertContext* ctx);
    gocpp::error CertGetCertificateChain(Handle engine, CertContext* leaf, Filetime* time, Handle additionalStore, CertChainPara* para, uint32_t flags, uintptr_t reserved, CertChainContext** chainCtx);
    std::tuple<Handle, gocpp::error> CertOpenStore(uintptr_t storeProvider, uint32_t msgAndCertEncodingType, uintptr_t cryptProv, uint32_t flags, uintptr_t para);
    std::tuple<Handle, gocpp::error> CertOpenSystemStore(Handle hprov, uint16_t* name);
    gocpp::error CertVerifyCertificateChainPolicy(uintptr_t policyOID, CertChainContext* chain, CertChainPolicyPara* para, CertChainPolicyStatus* status);
    bool DnsNameCompare(uint16_t* name1, uint16_t* name2);
    gocpp::error DnsQuery(std::string name, uint16_t qtype, uint32_t options, unsigned char* extra, DNSRecord** qrs, unsigned char* pr);
    gocpp::error _DnsQuery(uint16_t* name, uint16_t qtype, uint32_t options, unsigned char* extra, DNSRecord** qrs, unsigned char* pr);
    void DnsRecordListFree(DNSRecord* rl, uint32_t freetype);
    gocpp::error GetAdaptersInfo(IpAdapterInfo* ai, uint32_t* ol);
    gocpp::error GetIfEntry(MibIfRow* pIfRow);
    gocpp::error CancelIo(Handle s);
    gocpp::error CancelIoEx(Handle s, Overlapped* o);
    gocpp::error CloseHandle(Handle handle);
    gocpp::error CreateDirectory(uint16_t* path, SecurityAttributes* sa);
    std::tuple<Handle, gocpp::error> CreateFileMapping(Handle fhandle, SecurityAttributes* sa, uint32_t prot, uint32_t maxSizeHigh, uint32_t maxSizeLow, uint16_t* name);
    std::tuple<Handle, gocpp::error> CreateFile(uint16_t* name, uint32_t access, uint32_t mode, SecurityAttributes* sa, uint32_t createmode, uint32_t attrs, int32_t templatefile);
    gocpp::error CreateHardLink(uint16_t* filename, uint16_t* existingfilename, uintptr_t reserved);
    std::tuple<Handle, gocpp::error> createIoCompletionPort(Handle filehandle, Handle cphandle, uintptr_t key, uint32_t threadcnt);
    gocpp::error CreatePipe(Handle* readhandle, Handle* writehandle, SecurityAttributes* sa, uint32_t size);
    gocpp::error CreateProcess(uint16_t* appName, uint16_t* commandLine, SecurityAttributes* procSecurity, SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, StartupInfo* startupInfo, ProcessInformation* outProcInfo);
    gocpp::error CreateSymbolicLink(uint16_t* symlinkfilename, uint16_t* targetfilename, uint32_t flags);
    std::tuple<Handle, gocpp::error> CreateToolhelp32Snapshot(uint32_t flags, uint32_t processId);
    gocpp::error DeleteFile(uint16_t* path);
    void deleteProcThreadAttributeList(_PROC_THREAD_ATTRIBUTE_LIST* attrlist);
    gocpp::error DeviceIoControl(Handle handle, uint32_t ioControlCode, unsigned char* inBuffer, uint32_t inBufferSize, unsigned char* outBuffer, uint32_t outBufferSize, uint32_t* bytesReturned, Overlapped* overlapped);
    gocpp::error DuplicateHandle(Handle hSourceProcessHandle, Handle hSourceHandle, Handle hTargetProcessHandle, Handle* lpTargetHandle, uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwOptions);
    void ExitProcess(uint32_t exitcode);
    gocpp::error FindClose(Handle handle);
    std::tuple<Handle, gocpp::error> findFirstFile1(uint16_t* name, win32finddata1* data);
    gocpp::error findNextFile1(Handle handle, win32finddata1* data);
    gocpp::error FlushFileBuffers(Handle handle);
    gocpp::error FlushViewOfFile(uintptr_t addr, uintptr_t length);
    std::tuple<uint32_t, gocpp::error> formatMessage(uint32_t flags, uintptr_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args);
    gocpp::error FreeEnvironmentStrings(uint16_t* envs);
    gocpp::error FreeLibrary(Handle handle);
    uint16_t* GetCommandLine();
    gocpp::error GetComputerName(uint16_t* buf, uint32_t* n);
    gocpp::error GetConsoleMode(Handle console, uint32_t* mode);
    std::tuple<uint32_t, gocpp::error> GetCurrentDirectory(uint32_t buflen, uint16_t* buf);
    std::tuple<Handle, gocpp::error> GetCurrentProcess();
    uint32_t getCurrentProcessId();
    std::tuple<uint16_t*, gocpp::error> GetEnvironmentStrings();
    std::tuple<uint32_t, gocpp::error> GetEnvironmentVariable(uint16_t* name, uint16_t* buffer, uint32_t size);
    gocpp::error GetExitCodeProcess(Handle handle, uint32_t* exitcode);
    gocpp::error GetFileAttributesEx(uint16_t* name, uint32_t level, unsigned char* info);
    std::tuple<uint32_t, gocpp::error> GetFileAttributes(uint16_t* name);
    gocpp::error GetFileInformationByHandle(Handle handle, ByHandleFileInformation* data);
    std::tuple<uint32_t, gocpp::error> GetFileType(Handle filehandle);
    std::tuple<uint32_t, gocpp::error> getFinalPathNameByHandle(Handle file, uint16_t* filePath, uint32_t filePathSize, uint32_t flags);
    std::tuple<uint32_t, gocpp::error> GetFullPathName(uint16_t* path, uint32_t buflen, uint16_t* buf, uint16_t** fname);
    gocpp::error GetLastError();
    std::tuple<uint32_t, gocpp::error> GetLongPathName(uint16_t* path, uint16_t* buf, uint32_t buflen);
    std::tuple<uintptr_t, gocpp::error> GetProcAddress(Handle module, std::string procname);
    std::tuple<uintptr_t, gocpp::error> _GetProcAddress(Handle module, unsigned char* procname);
    gocpp::error GetProcessTimes(Handle handle, Filetime* creationTime, Filetime* exitTime, Filetime* kernelTime, Filetime* userTime);
    gocpp::error getQueuedCompletionStatus(Handle cphandle, uint32_t* qty, uintptr_t* key, Overlapped** overlapped, uint32_t timeout);
    std::tuple<uint32_t, gocpp::error> GetShortPathName(uint16_t* longpath, uint16_t* shortpath, uint32_t buflen);
    void getStartupInfo(StartupInfo* startupInfo);
    std::tuple<Handle, gocpp::error> GetStdHandle(int stdhandle);
    void GetSystemTimeAsFileTime(Filetime* time);
    std::tuple<uint32_t, gocpp::error> GetTempPath(uint32_t buflen, uint16_t* buf);
    std::tuple<uint32_t, gocpp::error> GetTimeZoneInformation(Timezoneinformation* tzi);
    std::tuple<uint32_t, gocpp::error> GetVersion();
    gocpp::error initializeProcThreadAttributeList(_PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t attrcount, uint32_t flags, uintptr_t* size);
    std::tuple<Handle, gocpp::error> LoadLibrary(std::string libname);
    std::tuple<Handle, gocpp::error> _LoadLibrary(uint16_t* libname);
    std::tuple<Handle, gocpp::error> LocalFree(Handle hmem);
    std::tuple<uintptr_t, gocpp::error> MapViewOfFile(Handle handle, uint32_t access, uint32_t offsetHigh, uint32_t offsetLow, uintptr_t length);
    gocpp::error MoveFile(uint16_t* from, uint16_t* to);
    std::tuple<Handle, gocpp::error> OpenProcess(uint32_t da, bool inheritHandle, uint32_t pid);
    gocpp::error postQueuedCompletionStatus(Handle cphandle, uint32_t qty, uintptr_t key, Overlapped* overlapped);
    gocpp::error Process32First(Handle snapshot, ProcessEntry32* procEntry);
    gocpp::error Process32Next(Handle snapshot, ProcessEntry32* procEntry);
    gocpp::error ReadConsole(Handle console, uint16_t* buf, uint32_t toread, uint32_t* read, unsigned char* inputControl);
    gocpp::error ReadDirectoryChanges(Handle handle, unsigned char* buf, uint32_t buflen, bool watchSubTree, uint32_t mask, uint32_t* retlen, Overlapped* overlapped, uintptr_t completionRoutine);
    gocpp::error readFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, Overlapped* overlapped);
    gocpp::error RemoveDirectory(uint16_t* path);
    gocpp::error SetCurrentDirectory(uint16_t* path);
    gocpp::error SetEndOfFile(Handle handle);
    gocpp::error SetEnvironmentVariable(uint16_t* name, uint16_t* value);
    gocpp::error SetFileAttributes(uint16_t* name, uint32_t attrs);
    gocpp::error SetFileCompletionNotificationModes(Handle handle, uint8_t flags);
    std::tuple<uint32_t, gocpp::error> SetFilePointer(Handle handle, int32_t lowoffset, int32_t* highoffsetptr, uint32_t whence);
    gocpp::error SetFileTime(Handle handle, Filetime* ctime, Filetime* atime, Filetime* wtime);
    gocpp::error SetHandleInformation(Handle handle, uint32_t mask, uint32_t flags);
    gocpp::error TerminateProcess(Handle handle, uint32_t exitcode);
    gocpp::error UnmapViewOfFile(uintptr_t addr);
    gocpp::error updateProcThreadAttribute(_PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t flags, uintptr_t attr, unsafe::Pointer value, uintptr_t size, unsafe::Pointer prevvalue, uintptr_t* returnedsize);
    gocpp::error VirtualLock(uintptr_t addr, uintptr_t length);
    gocpp::error VirtualUnlock(uintptr_t addr, uintptr_t length);
    std::tuple<uint32_t, gocpp::error> WaitForSingleObject(Handle handle, uint32_t waitMilliseconds);
    gocpp::error WriteConsole(Handle console, uint16_t* buf, uint32_t towrite, uint32_t* written, unsigned char* reserved);
    gocpp::error writeFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, Overlapped* overlapped);
    gocpp::error AcceptEx(Handle ls, Handle as, unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, uint32_t* recvd, Overlapped* overlapped);
    void GetAcceptExSockaddrs(unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, RawSockaddrAny** lrsa, int32_t* lrsalen, RawSockaddrAny** rrsa, int32_t* rrsalen);
    gocpp::error TransmitFile(Handle s, Handle handle, uint32_t bytesToWrite, uint32_t bytsPerSend, Overlapped* overlapped, TransmitFileBuffers* transmitFileBuf, uint32_t flags);
    gocpp::error NetApiBufferFree(unsigned char* buf);
    gocpp::error NetGetJoinInformation(uint16_t* server, uint16_t** name, uint32_t* bufType);
    gocpp::error NetUserGetInfo(uint16_t* serverName, uint16_t* userName, uint32_t level, unsigned char** buf);
    void rtlGetNtVersionNumbers(uint32_t* majorVersion, uint32_t* minorVersion, uint32_t* buildNumber);
    gocpp::error GetUserNameEx(uint32_t nameFormat, uint16_t* nameBuffre, uint32_t* nSize);
    gocpp::error TranslateName(uint16_t* accName, uint32_t accNameFormat, uint32_t desiredNameFormat, uint16_t* translatedName, uint32_t* nSize);
    std::tuple<gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*, gocpp::error> CommandLineToArgv(uint16_t* cmd, int32_t* argc);
    gocpp::error GetUserProfileDirectory(Token t, uint16_t* dir, uint32_t* dirLen);
    void FreeAddrInfoW(AddrinfoW* addrinfo);
    gocpp::error GetAddrInfoW(uint16_t* nodename, uint16_t* servicename, AddrinfoW* hints, AddrinfoW** result);
    gocpp::error WSACleanup();
    std::tuple<int32_t, gocpp::error> WSAEnumProtocols(int32_t* protocols, WSAProtocolInfo* protocolBuffer, uint32_t* bufferLength);
    gocpp::error WSAIoctl(Handle s, uint32_t iocc, unsigned char* inbuf, uint32_t cbif, unsigned char* outbuf, uint32_t cbob, uint32_t* cbbr, Overlapped* overlapped, uintptr_t completionRoutine);
    gocpp::error WSARecv(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error WSARecvFrom(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, RawSockaddrAny* from, int32_t* fromlen, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error WSASend(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error WSASendTo(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, RawSockaddrAny* to, int32_t tolen, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error WSAStartup(uint32_t verreq, WSAData* data);
    gocpp::error bind(Handle s, unsafe::Pointer name, int32_t namelen);
    gocpp::error Closesocket(Handle s);
    gocpp::error connect(Handle s, unsafe::Pointer name, int32_t namelen);
    std::tuple<Hostent*, gocpp::error> GetHostByName(std::string name);
    std::tuple<Hostent*, gocpp::error> _GetHostByName(unsigned char* name);
    gocpp::error getpeername(Handle s, RawSockaddrAny* rsa, int32_t* addrlen);
    std::tuple<Protoent*, gocpp::error> GetProtoByName(std::string name);
    std::tuple<Protoent*, gocpp::error> _GetProtoByName(unsigned char* name);
    std::tuple<Servent*, gocpp::error> GetServByName(std::string name, std::string proto);
    std::tuple<Servent*, gocpp::error> _GetServByName(unsigned char* name, unsigned char* proto);
    gocpp::error getsockname(Handle s, RawSockaddrAny* rsa, int32_t* addrlen);
    gocpp::error Getsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t* optlen);
    gocpp::error listen(Handle s, int32_t backlog);
    uint16_t Ntohs(uint16_t netshort);
    gocpp::error Setsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t optlen);
    gocpp::error shutdown(Handle s, int32_t how);
    std::tuple<Handle, gocpp::error> socket(int32_t af, int32_t typ, int32_t protocol);
}

