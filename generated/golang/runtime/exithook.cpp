// generated by GoCpp from file '$(ImportDir)/runtime/exithook.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/exithook.h"
#include "gocpp/support.h"

// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"

namespace golang::runtime
{
    void addExitHook(std::function<void ()> f, bool runOnNonZeroExit)
    {
        exitHooks.hooks = append(exitHooks.hooks, gocpp::Init<exitHook>([](exitHook& x) { x.f = f; x.runOnNonZeroExit = runOnNonZeroExit; }));
    }

    
    std::ostream& exitHook::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << f;
        os << " " << runOnNonZeroExit;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct exitHook& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {
        gocpp::slice<exitHook> hooks;
        bool runningExitHooks;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << hooks;
            os << " " << runningExitHooks;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 exitHooks;
    void runExitHooks(int exitCode)
    {
        if(exitHooks.runningExitHooks)
        {
            go_throw("internal error: exit hook invoked exit");
        }
        exitHooks.runningExitHooks = true;
        auto runExitHook = [=](std::function<void ()> f) mutable -> bool
        {
            gocpp::Defer defer;
            bool caughtPanic;
            defer.push_back([=]{ [=]() mutable -> void
            {
                if(auto x = recover(); x != nullptr)
                {
                    caughtPanic = true;
                }
            }(); });
            f();
            return caughtPanic;
        };
        finishPageTrace();
        for(auto [i, gocpp_ignored] : exitHooks.hooks)
        {
            auto h = exitHooks.hooks[len(exitHooks.hooks) - i - 1];
            if(exitCode != 0 && ! h.runOnNonZeroExit)
            {
                continue;
            }
            if(auto caughtPanic = runExitHook(h.f); caughtPanic)
            {
                go_throw("internal error: exit hook invoked panic");
            }
        }
        exitHooks.hooks = nullptr;
        exitHooks.runningExitHooks = false;
    }

}

