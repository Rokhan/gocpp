// generated by GoCpp from file '$(ImportDir)/runtime/mprof.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mprof.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/cputicks.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/sema.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    mutex profInsertLock;
    mutex profBlockLock;
    mutex profMemActiveLock;
    gocpp::array<mutex, len(memRecord {}.future)> profMemFutureLock;
    
    template<typename T> requires gocpp::GoStruct<T>
    bucket::operator T()
    {
        T result;
        result._ = this->_;
        result.next = this->next;
        result.allnext = this->allnext;
        result.typ = this->typ;
        result.hash = this->hash;
        result.size = this->size;
        result.nstk = this->nstk;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool bucket::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (next != ref.next) return false;
        if (allnext != ref.allnext) return false;
        if (typ != ref.typ) return false;
        if (hash != ref.hash) return false;
        if (size != ref.size) return false;
        if (nstk != ref.nstk) return false;
        return true;
    }

    std::ostream& bucket::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << next;
        os << " " << allnext;
        os << " " << typ;
        os << " " << hash;
        os << " " << size;
        os << " " << nstk;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct bucket& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    memRecord::operator T()
    {
        T result;
        result.active = this->active;
        result.future = this->future;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool memRecord::operator==(const T& ref) const
    {
        if (active != ref.active) return false;
        if (future != ref.future) return false;
        return true;
    }

    std::ostream& memRecord::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << active;
        os << " " << future;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct memRecord& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    memRecordCycle::operator T()
    {
        T result;
        result.allocs = this->allocs;
        result.frees = this->frees;
        result.alloc_bytes = this->alloc_bytes;
        result.free_bytes = this->free_bytes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool memRecordCycle::operator==(const T& ref) const
    {
        if (allocs != ref.allocs) return false;
        if (frees != ref.frees) return false;
        if (alloc_bytes != ref.alloc_bytes) return false;
        if (free_bytes != ref.free_bytes) return false;
        return true;
    }

    std::ostream& memRecordCycle::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << allocs;
        os << " " << frees;
        os << " " << alloc_bytes;
        os << " " << free_bytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct memRecordCycle& value)
    {
        return value.PrintTo(os);
    }

    void rec::add(struct memRecordCycle* a, struct memRecordCycle* b)
    {
        a->allocs += b->allocs;
        a->frees += b->frees;
        a->alloc_bytes += b->alloc_bytes;
        a->free_bytes += b->free_bytes;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    blockRecord::operator T()
    {
        T result;
        result.count = this->count;
        result.cycles = this->cycles;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool blockRecord::operator==(const T& ref) const
    {
        if (count != ref.count) return false;
        if (cycles != ref.cycles) return false;
        return true;
    }

    std::ostream& blockRecord::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << count;
        os << " " << cycles;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct blockRecord& value)
    {
        return value.PrintTo(os);
    }

    atomic::UnsafePointer mbuckets;
    atomic::UnsafePointer bbuckets;
    atomic::UnsafePointer xbuckets;
    atomic::UnsafePointer buckhash;
    mProfCycleHolder mProfCycle;
    // // *bucket
    
    template<typename T> requires gocpp::GoStruct<T>
    mProfCycleHolder::operator T()
    {
        T result;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mProfCycleHolder::operator==(const T& ref) const
    {
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& mProfCycleHolder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mProfCycleHolder& value)
    {
        return value.PrintTo(os);
    }

    uint32_t rec::read(struct mProfCycleHolder* c)
    {
        uint32_t cycle;
        auto v = rec::Load(gocpp::recv(c->value));
        cycle = v >> 1;
        return cycle;
    }

    std::tuple<uint32_t, bool> rec::setFlushed(struct mProfCycleHolder* c)
    {
        uint32_t cycle;
        bool alreadyFlushed;
        for(; ; )
        {
            uint32_t cycle;
            bool alreadyFlushed;
            auto prev = rec::Load(gocpp::recv(c->value));
            cycle = prev >> 1;
            alreadyFlushed = (prev & 0x1) != 0;
            auto next = prev | 0x1;
            if(rec::CompareAndSwap(gocpp::recv(c->value), prev, next))
            {
                uint32_t cycle;
                bool alreadyFlushed;
                return {cycle, alreadyFlushed};
            }
        }
    }

    void rec::increment(struct mProfCycleHolder* c)
    {
        for(; ; )
        {
            auto prev = rec::Load(gocpp::recv(c->value));
            auto cycle = prev >> 1;
            cycle = (cycle + 1) % mProfCycleWrap;
            auto next = cycle << 1;
            if(rec::CompareAndSwap(gocpp::recv(c->value), prev, next))
            {
                break;
            }
        }
    }

    struct bucket* newBucket(golang::runtime::bucketType typ, int nstk)
    {
        auto size = gocpp::Sizeof<bucket>() + uintptr_t(nstk) * gocpp::Sizeof<uintptr_t>();
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            else if(condition == memProfile) { conditionId = 0; }
            else if(condition == blockProfile) { conditionId = 1; }
            else if(condition == mutexProfile) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    go_throw("invalid profile bucket type");
                    break;
                case 0:
                    size += gocpp::Sizeof<memRecord>();
                    break;
                case 1:
                case 2:
                    size += gocpp::Sizeof<blockRecord>();
                    break;
            }
        }
        auto b = (bucket*)(persistentalloc(size, 0, & memstats.buckhash_sys));
        b->typ = typ;
        b->nstk = uintptr_t(nstk);
        return b;
    }

    gocpp::slice<uintptr_t> rec::stk(struct bucket* b)
    {
        auto stk = (gocpp::array<uintptr_t, maxStack>*)(add(unsafe::Pointer(b), gocpp::Sizeof<bucket>()));
        if(b->nstk > maxStack)
        {
            go_throw("bad profile stack count");
        }
        return stk.make_slice(, b->nstk, b->nstk);
    }

    struct memRecord* rec::mp(struct bucket* b)
    {
        if(b->typ != memProfile)
        {
            go_throw("bad use of bucket.mp");
        }
        auto data = add(unsafe::Pointer(b), gocpp::Sizeof<bucket>() + b->nstk * gocpp::Sizeof<uintptr_t>());
        return (memRecord*)(data);
    }

    struct blockRecord* rec::bp(struct bucket* b)
    {
        if(b->typ != blockProfile && b->typ != mutexProfile)
        {
            go_throw("bad use of bucket.bp");
        }
        auto data = add(unsafe::Pointer(b), gocpp::Sizeof<bucket>() + b->nstk * gocpp::Sizeof<uintptr_t>());
        return (blockRecord*)(data);
    }

    struct bucket* stkbucket(golang::runtime::bucketType typ, uintptr_t size, gocpp::slice<uintptr_t> stk, bool alloc)
    {
        auto bh = (runtime::buckhashArray*)(rec::Load(gocpp::recv(buckhash)));
        if(bh == nullptr)
        {
            lock(& profInsertLock);
            bh = (runtime::buckhashArray*)(rec::Load(gocpp::recv(buckhash)));
            if(bh == nullptr)
            {
                bh = (runtime::buckhashArray*)(sysAlloc(gocpp::Sizeof<runtime::buckhashArray>(), & memstats.buckhash_sys));
                if(bh == nullptr)
                {
                    go_throw("runtime: cannot allocate memory");
                }
                rec::StoreNoWB(gocpp::recv(buckhash), unsafe::Pointer(bh));
            }
            unlock(& profInsertLock);
        }
        uintptr_t h = {};
        for(auto [gocpp_ignored, pc] : stk)
        {
            h += pc;
            h += h << 10;
            h ^= h >> 6;
        }
        h += size;
        h += h << 10;
        h ^= h >> 6;
        h += h << 3;
        h ^= h >> 11;
        auto i = int(h % buckHashSize);
        for(auto b = (bucket*)(rec::Load(gocpp::recv(bh[i]))); b != nullptr; b = b->next)
        {
            if(b->typ == typ && b->hash == h && b->size == size && eqslice(rec::stk(gocpp::recv(b)), stk))
            {
                return b;
            }
        }
        if(! alloc)
        {
            return nullptr;
        }
        lock(& profInsertLock);
        for(auto b = (bucket*)(rec::Load(gocpp::recv(bh[i]))); b != nullptr; b = b->next)
        {
            if(b->typ == typ && b->hash == h && b->size == size && eqslice(rec::stk(gocpp::recv(b)), stk))
            {
                unlock(& profInsertLock);
                return b;
            }
        }
        auto b = newBucket(typ, len(stk));
        copy(rec::stk(gocpp::recv(b)), stk);
        b->hash = h;
        b->size = size;
        atomic::UnsafePointer* allnext = {};
        if(typ == memProfile)
        {
            allnext = & mbuckets;
        }
        else
        if(typ == mutexProfile)
        {
            allnext = & xbuckets;
        }
        else
        {
            allnext = & bbuckets;
        }
        b->next = (bucket*)(rec::Load(gocpp::recv(bh[i])));
        b->allnext = (bucket*)(rec::Load(gocpp::recv(allnext)));
        rec::StoreNoWB(gocpp::recv(bh[i]), unsafe::Pointer(b));
        rec::StoreNoWB(gocpp::recv(allnext), unsafe::Pointer(b));
        unlock(& profInsertLock);
        return b;
    }

    bool eqslice(gocpp::slice<uintptr_t> x, gocpp::slice<uintptr_t> y)
    {
        if(len(x) != len(y))
        {
            return false;
        }
        for(auto [i, xi] : x)
        {
            if(xi != y[i])
            {
                return false;
            }
        }
        return true;
    }

    void mProf_NextCycle()
    {
        rec::increment(gocpp::recv(mProfCycle));
    }

    void mProf_Flush()
    {
        auto [cycle, alreadyFlushed] = rec::setFlushed(gocpp::recv(mProfCycle));
        if(alreadyFlushed)
        {
            return;
        }
        auto index = cycle % uint32_t(len(memRecord {}.future));
        lock(& profMemActiveLock);
        lock(& profMemFutureLock[index]);
        mProf_FlushLocked(index);
        unlock(& profMemFutureLock[index]);
        unlock(& profMemActiveLock);
    }

    void mProf_FlushLocked(uint32_t index)
    {
        assertLockHeld(& profMemActiveLock);
        assertLockHeld(& profMemFutureLock[index]);
        auto head = (bucket*)(rec::Load(gocpp::recv(mbuckets)));
        for(auto b = head; b != nullptr; b = b->allnext)
        {
            auto mp = rec::mp(gocpp::recv(b));
            auto mpc = & mp->future[index];
            rec::add(gocpp::recv(mp->active), mpc);
            *mpc = memRecordCycle {};
        }
    }

    void mProf_PostSweep()
    {
        auto cycle = rec::read(gocpp::recv(mProfCycle)) + 1;
        auto index = cycle % uint32_t(len(memRecord {}.future));
        lock(& profMemActiveLock);
        lock(& profMemFutureLock[index]);
        mProf_FlushLocked(index);
        unlock(& profMemFutureLock[index]);
        unlock(& profMemActiveLock);
    }

    void mProf_Malloc(unsafe::Pointer p, uintptr_t size)
    {
        gocpp::array<uintptr_t, maxStack> stk = {};
        auto nstk = callers(4, stk.make_slice(0, ));
        auto index = (rec::read(gocpp::recv(mProfCycle)) + 2) % uint32_t(len(memRecord {}.future));
        auto b = stkbucket(memProfile, size, stk.make_slice(0, nstk), true);
        auto mp = rec::mp(gocpp::recv(b));
        auto mpc = & mp->future[index];
        lock(& profMemFutureLock[index]);
        mpc->allocs++;
        mpc->alloc_bytes += size;
        unlock(& profMemFutureLock[index]);
        systemstack([=]() mutable -> void
        {
            setprofilebucket(p, b);
        });
    }

    void mProf_Free(struct bucket* b, uintptr_t size)
    {
        auto index = (rec::read(gocpp::recv(mProfCycle)) + 1) % uint32_t(len(memRecord {}.future));
        auto mp = rec::mp(gocpp::recv(b));
        auto mpc = & mp->future[index];
        lock(& profMemFutureLock[index]);
        mpc->frees++;
        mpc->free_bytes += size;
        unlock(& profMemFutureLock[index]);
    }

    uint64_t blockprofilerate;
    void SetBlockProfileRate(int rate)
    {
        int64_t r = {};
        if(rate <= 0)
        {
            r = 0;
        }
        else
        if(rate == 1)
        {
            r = 1;
        }
        else
        {
            r = int64_t(double(rate) * double(ticksPerSecond()) / (1000 * 1000 * 1000));
            if(r == 0)
            {
                r = 1;
            }
        }
        atomic::Store64(& blockprofilerate, uint64_t(r));
    }

    void blockevent(int64_t cycles, int skip)
    {
        if(cycles <= 0)
        {
            cycles = 1;
        }
        auto rate = int64_t(atomic::Load64(& blockprofilerate));
        if(blocksampled(cycles, rate))
        {
            saveblockevent(cycles, rate, skip + 1, blockProfile);
        }
    }

    bool blocksampled(int64_t cycles, int64_t rate)
    {
        if(rate <= 0 || (rate > cycles && cheaprand64() % rate > cycles))
        {
            return false;
        }
        return true;
    }

    void saveblockevent(int64_t cycles, int64_t rate, int skip, golang::runtime::bucketType which)
    {
        auto gp = getg();
        int nstk = {};
        gocpp::array<uintptr_t, maxStack> stk = {};
        if(gp->m->curg == nullptr || gp->m->curg == gp)
        {
            nstk = callers(skip, stk.make_slice(0, ));
        }
        else
        {
            nstk = gcallers(gp->m->curg, skip, stk.make_slice(0, ));
        }
        saveBlockEventStack(cycles, rate, stk.make_slice(0, nstk), which);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    lockTimer::operator T()
    {
        T result;
        result.lock = this->lock;
        result.timeRate = this->timeRate;
        result.timeStart = this->timeStart;
        result.tickStart = this->tickStart;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool lockTimer::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (timeRate != ref.timeRate) return false;
        if (timeStart != ref.timeStart) return false;
        if (tickStart != ref.tickStart) return false;
        return true;
    }

    std::ostream& lockTimer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << timeRate;
        os << " " << timeStart;
        os << " " << tickStart;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct lockTimer& value)
    {
        return value.PrintTo(os);
    }

    void rec::begin(struct lockTimer* lt)
    {
        auto rate = int64_t(atomic::Load64(& mutexprofilerate));
        lt->timeRate = gTrackingPeriod;
        if(rate != 0 && rate < lt->timeRate)
        {
            lt->timeRate = rate;
        }
        if(int64_t(cheaprand()) % lt->timeRate == 0)
        {
            lt->timeStart = nanotime();
        }
        if(rate > 0 && int64_t(cheaprand()) % rate == 0)
        {
            lt->tickStart = cputicks();
        }
    }

    void rec::end(struct lockTimer* lt)
    {
        auto gp = getg();
        if(lt->timeStart != 0)
        {
            auto nowTime = nanotime();
            rec::Add(gocpp::recv(gp->m->mLockProfile.waitTime), (nowTime - lt->timeStart) * lt->timeRate);
        }
        if(lt->tickStart != 0)
        {
            auto nowTick = cputicks();
            rec::recordLock(gocpp::recv(gp->m->mLockProfile), nowTick - lt->tickStart, lt->lock);
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mLockProfile::operator T()
    {
        T result;
        result.waitTime = this->waitTime;
        result.stack = this->stack;
        result.pending = this->pending;
        result.cycles = this->cycles;
        result.cyclesLost = this->cyclesLost;
        result.disabled = this->disabled;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mLockProfile::operator==(const T& ref) const
    {
        if (waitTime != ref.waitTime) return false;
        if (stack != ref.stack) return false;
        if (pending != ref.pending) return false;
        if (cycles != ref.cycles) return false;
        if (cyclesLost != ref.cyclesLost) return false;
        if (disabled != ref.disabled) return false;
        return true;
    }

    std::ostream& mLockProfile::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << waitTime;
        os << " " << stack;
        os << " " << pending;
        os << " " << cycles;
        os << " " << cyclesLost;
        os << " " << disabled;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mLockProfile& value)
    {
        return value.PrintTo(os);
    }

    void rec::recordLock(struct mLockProfile* prof, int64_t cycles, struct mutex* l)
    {
        if(cycles <= 0)
        {
            return;
        }
        if(prof->disabled)
        {
            prof->cyclesLost += cycles;
            return;
        }
        if(uintptr_t(unsafe::Pointer(l)) == prof->pending)
        {
            prof->cycles += cycles;
            return;
        }
        if(auto prev = prof->cycles; prev > 0)
        {
            auto prevScore = uint64_t(cheaprand64()) % uint64_t(prev);
            auto thisScore = uint64_t(cheaprand64()) % uint64_t(cycles);
            if(prevScore > thisScore)
            {
                prof->cyclesLost += cycles;
                return;
            }
            else
            {
                prof->cyclesLost += prev;
            }
        }
        prof->pending = uintptr_t(unsafe::Pointer(l));
        prof->cycles = cycles;
    }

    void rec::recordUnlock(struct mLockProfile* prof, struct mutex* l)
    {
        if(uintptr_t(unsafe::Pointer(l)) == prof->pending)
        {
            rec::captureStack(gocpp::recv(prof));
        }
        if(auto gp = getg(); gp->m->locks == 1 && gp->m->mLockProfile.cycles != 0)
        {
            rec::store(gocpp::recv(prof));
        }
    }

    void rec::captureStack(struct mLockProfile* prof)
    {
        auto skip = 3;
        if(staticLockRanking)
        {
            skip += 1;
        }
        prof->pending = 0;
        if(rec::Load(gocpp::recv(debug.runtimeContentionStacks)) == 0)
        {
            prof->stack[0] = abi::FuncPCABIInternal(_LostContendedRuntimeLock) + sys::PCQuantum;
            prof->stack[1] = 0;
            return;
        }
        int nstk = {};
        auto gp = getg();
        auto sp = getcallersp();
        auto pc = getcallerpc();
        systemstack([=]() mutable -> void
        {
            unwinder u = {};
            rec::initAt(gocpp::recv(u), pc, sp, 0, gp, unwindSilentErrors | unwindJumpStack);
            nstk = tracebackPCs(& u, skip, prof->stack.make_slice(0, ));
        });
        if(nstk < len(prof->stack))
        {
            prof->stack[nstk] = 0;
        }
    }

    void rec::store(struct mLockProfile* prof)
    {
        auto mp = acquirem();
        prof->disabled = true;
        auto nstk = maxStack;
        for(auto i = 0; i < nstk; i++)
        {
            if(auto pc = prof->stack[i]; pc == 0)
            {
                nstk = i;
                break;
            }
        }
        auto [cycles, lost] = std::tuple{prof->cycles, prof->cyclesLost};
        std::tie(prof->cycles, prof->cyclesLost) = std::tuple{0, 0};
        auto rate = int64_t(atomic::Load64(& mutexprofilerate));
        saveBlockEventStack(cycles, rate, prof->stack.make_slice(0, nstk), mutexProfile);
        if(lost > 0)
        {
            auto lostStk = gocpp::array_base<uintptr_t> {abi::FuncPCABIInternal(_LostContendedRuntimeLock) + sys::PCQuantum};
            saveBlockEventStack(lost, rate, lostStk.make_slice(0, ), mutexProfile);
        }
        prof->disabled = false;
        releasem(mp);
    }

    void saveBlockEventStack(int64_t cycles, int64_t rate, gocpp::slice<uintptr_t> stk, golang::runtime::bucketType which)
    {
        auto b = stkbucket(which, 0, stk, true);
        auto bp = rec::bp(gocpp::recv(b));
        lock(& profBlockLock);
        if(which == blockProfile && cycles < rate)
        {
            bp->count += double(rate) / double(cycles);
            bp->cycles += rate;
        }
        else
        if(which == mutexProfile)
        {
            bp->count += double(rate);
            bp->cycles += rate * cycles;
        }
        else
        {
            bp->count++;
            bp->cycles += cycles;
        }
        unlock(& profBlockLock);
    }

    uint64_t mutexprofilerate;
    int SetMutexProfileFraction(int rate)
    {
        if(rate < 0)
        {
            return int(mutexprofilerate);
        }
        auto old = mutexprofilerate;
        atomic::Store64(& mutexprofilerate, uint64_t(rate));
        return int(old);
    }

    void mutexevent(int64_t cycles, int skip)
    {
        if(cycles < 0)
        {
            cycles = 0;
        }
        auto rate = int64_t(atomic::Load64(& mutexprofilerate));
        if(rate > 0 && cheaprand64() % rate == 0)
        {
            saveblockevent(cycles, rate, skip + 1, mutexProfile);
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    StackRecord::operator T()
    {
        T result;
        result.Stack0 = this->Stack0;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StackRecord::operator==(const T& ref) const
    {
        if (Stack0 != ref.Stack0) return false;
        return true;
    }

    std::ostream& StackRecord::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Stack0;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StackRecord& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<uintptr_t> rec::Stack(struct StackRecord* r)
    {
        for(auto [i, v] : r->Stack0)
        {
            if(v == 0)
            {
                return r->Stack0.make_slice(0, i);
            }
        }
        return r->Stack0.make_slice(0);
    }

    int MemProfileRate = 512 * 1024;
    bool disableMemoryProfiling;
    
    template<typename T> requires gocpp::GoStruct<T>
    MemProfileRecord::operator T()
    {
        T result;
        result.AllocBytes = this->AllocBytes;
        result.FreeBytes = this->FreeBytes;
        result.AllocObjects = this->AllocObjects;
        result.FreeObjects = this->FreeObjects;
        result.Stack0 = this->Stack0;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool MemProfileRecord::operator==(const T& ref) const
    {
        if (AllocBytes != ref.AllocBytes) return false;
        if (FreeBytes != ref.FreeBytes) return false;
        if (AllocObjects != ref.AllocObjects) return false;
        if (FreeObjects != ref.FreeObjects) return false;
        if (Stack0 != ref.Stack0) return false;
        return true;
    }

    std::ostream& MemProfileRecord::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << AllocBytes;
        os << " " << FreeBytes;
        os << " " << AllocObjects;
        os << " " << FreeObjects;
        os << " " << Stack0;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MemProfileRecord& value)
    {
        return value.PrintTo(os);
    }

    int64_t rec::InUseBytes(struct MemProfileRecord* r)
    {
        return r->AllocBytes - r->FreeBytes;
    }

    int64_t rec::InUseObjects(struct MemProfileRecord* r)
    {
        return r->AllocObjects - r->FreeObjects;
    }

    gocpp::slice<uintptr_t> rec::Stack(struct MemProfileRecord* r)
    {
        for(auto [i, v] : r->Stack0)
        {
            if(v == 0)
            {
                return r->Stack0.make_slice(0, i);
            }
        }
        return r->Stack0.make_slice(0);
    }

    std::tuple<int, bool> MemProfile(gocpp::slice<MemProfileRecord> p, bool inuseZero)
    {
        int n;
        bool ok;
        auto cycle = rec::read(gocpp::recv(mProfCycle));
        auto index = cycle % uint32_t(len(memRecord {}.future));
        lock(& profMemActiveLock);
        lock(& profMemFutureLock[index]);
        mProf_FlushLocked(index);
        unlock(& profMemFutureLock[index]);
        auto clear = true;
        auto head = (bucket*)(rec::Load(gocpp::recv(mbuckets)));
        for(auto b = head; b != nullptr; b = b->allnext)
        {
            int n;
            bool ok;
            auto mp = rec::mp(gocpp::recv(b));
            if(inuseZero || mp->active.alloc_bytes != mp->active.free_bytes)
            {
                int n;
                bool ok;
                n++;
            }
            if(mp->active.allocs != 0 || mp->active.frees != 0)
            {
                int n;
                bool ok;
                clear = false;
            }
        }
        if(clear)
        {
            int n;
            bool ok;
            n = 0;
            for(auto b = head; b != nullptr; b = b->allnext)
            {
                int n;
                bool ok;
                auto mp = rec::mp(gocpp::recv(b));
                for(auto [c, gocpp_ignored] : mp->future)
                {
                    int n;
                    bool ok;
                    lock(& profMemFutureLock[c]);
                    rec::add(gocpp::recv(mp->active), & mp->future[c]);
                    mp->future[c] = memRecordCycle {};
                    unlock(& profMemFutureLock[c]);
                }
                if(inuseZero || mp->active.alloc_bytes != mp->active.free_bytes)
                {
                    int n;
                    bool ok;
                    n++;
                }
            }
        }
        if(n <= len(p))
        {
            int n;
            bool ok;
            ok = true;
            auto idx = 0;
            for(auto b = head; b != nullptr; b = b->allnext)
            {
                int n;
                bool ok;
                auto mp = rec::mp(gocpp::recv(b));
                if(inuseZero || mp->active.alloc_bytes != mp->active.free_bytes)
                {
                    int n;
                    bool ok;
                    record(& p[idx], b);
                    idx++;
                }
            }
        }
        unlock(& profMemActiveLock);
        return {n, ok};
    }

    void record(struct MemProfileRecord* r, struct bucket* b)
    {
        auto mp = rec::mp(gocpp::recv(b));
        r->AllocBytes = int64_t(mp->active.alloc_bytes);
        r->FreeBytes = int64_t(mp->active.free_bytes);
        r->AllocObjects = int64_t(mp->active.allocs);
        r->FreeObjects = int64_t(mp->active.frees);
        if(raceenabled)
        {
            racewriterangepc(unsafe::Pointer(& r->Stack0[0]), gocpp::Sizeof<gocpp::array<uintptr_t, 32>>(), getcallerpc(), abi::FuncPCABIInternal(MemProfile));
        }
        if(msanenabled)
        {
            msanwrite(unsafe::Pointer(& r->Stack0[0]), gocpp::Sizeof<gocpp::array<uintptr_t, 32>>());
        }
        if(asanenabled)
        {
            asanwrite(unsafe::Pointer(& r->Stack0[0]), gocpp::Sizeof<gocpp::array<uintptr_t, 32>>());
        }
        copy(r->Stack0.make_slice(0, ), rec::stk(gocpp::recv(b)));
        for(auto i = int(b->nstk); i < len(r->Stack0); i++)
        {
            r->Stack0[i] = 0;
        }
    }

    void iterate_memprof(std::function<void (bucket*, uintptr_t, uintptr_t*, uintptr_t, uintptr_t, uintptr_t)> fn)
    {
        lock(& profMemActiveLock);
        auto head = (bucket*)(rec::Load(gocpp::recv(mbuckets)));
        for(auto b = head; b != nullptr; b = b->allnext)
        {
            auto mp = rec::mp(gocpp::recv(b));
            fn(b, b->nstk, & rec::stk(gocpp::recv(b))[0], b->size, mp->active.allocs, mp->active.frees);
        }
        unlock(& profMemActiveLock);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    BlockProfileRecord::operator T()
    {
        T result;
        result.Count = this->Count;
        result.Cycles = this->Cycles;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool BlockProfileRecord::operator==(const T& ref) const
    {
        if (Count != ref.Count) return false;
        if (Cycles != ref.Cycles) return false;
        return true;
    }

    std::ostream& BlockProfileRecord::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Count;
        os << " " << Cycles;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct BlockProfileRecord& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, bool> BlockProfile(gocpp::slice<BlockProfileRecord> p)
    {
        int n;
        bool ok;
        lock(& profBlockLock);
        auto head = (bucket*)(rec::Load(gocpp::recv(bbuckets)));
        for(auto b = head; b != nullptr; b = b->allnext)
        {
            int n;
            bool ok;
            n++;
        }
        if(n <= len(p))
        {
            int n;
            bool ok;
            ok = true;
            for(auto b = head; b != nullptr; b = b->allnext)
            {
                int n;
                bool ok;
                auto bp = rec::bp(gocpp::recv(b));
                auto r = & p[0];
                r->Count = int64_t(bp->count);
                if(r->Count == 0)
                {
                    int n;
                    bool ok;
                    r->Count = 1;
                }
                r->Cycles = bp->cycles;
                if(raceenabled)
                {
                    int n;
                    bool ok;
                    racewriterangepc(unsafe::Pointer(& r->Stack0[0]), gocpp::Sizeof<gocpp::array<uintptr_t, 32>>(), getcallerpc(), abi::FuncPCABIInternal(BlockProfile));
                }
                if(msanenabled)
                {
                    int n;
                    bool ok;
                    msanwrite(unsafe::Pointer(& r->Stack0[0]), gocpp::Sizeof<gocpp::array<uintptr_t, 32>>());
                }
                if(asanenabled)
                {
                    int n;
                    bool ok;
                    asanwrite(unsafe::Pointer(& r->Stack0[0]), gocpp::Sizeof<gocpp::array<uintptr_t, 32>>());
                }
                auto i = copy(r->Stack0.make_slice(0, ), rec::stk(gocpp::recv(b)));
                for(; i < len(r->Stack0); i++)
                {
                    int n;
                    bool ok;
                    r->Stack0[i] = 0;
                }
                p = p.make_slice(1);
            }
        }
        unlock(& profBlockLock);
        return {n, ok};
    }

    std::tuple<int, bool> MutexProfile(gocpp::slice<BlockProfileRecord> p)
    {
        int n;
        bool ok;
        lock(& profBlockLock);
        auto head = (bucket*)(rec::Load(gocpp::recv(xbuckets)));
        for(auto b = head; b != nullptr; b = b->allnext)
        {
            int n;
            bool ok;
            n++;
        }
        if(n <= len(p))
        {
            int n;
            bool ok;
            ok = true;
            for(auto b = head; b != nullptr; b = b->allnext)
            {
                int n;
                bool ok;
                auto bp = rec::bp(gocpp::recv(b));
                auto r = & p[0];
                r->Count = int64_t(bp->count);
                r->Cycles = bp->cycles;
                auto i = copy(r->Stack0.make_slice(0, ), rec::stk(gocpp::recv(b)));
                for(; i < len(r->Stack0); i++)
                {
                    int n;
                    bool ok;
                    r->Stack0[i] = 0;
                }
                p = p.make_slice(1);
            }
        }
        unlock(& profBlockLock);
        return {n, ok};
    }

    std::tuple<int, bool> ThreadCreateProfile(gocpp::slice<StackRecord> p)
    {
        int n;
        bool ok;
        auto first = (m*)(atomic::Loadp(unsafe::Pointer(& allm)));
        for(auto mp = first; mp != nullptr; mp = mp->alllink)
        {
            int n;
            bool ok;
            n++;
        }
        if(n <= len(p))
        {
            int n;
            bool ok;
            ok = true;
            auto i = 0;
            for(auto mp = first; mp != nullptr; mp = mp->alllink)
            {
                int n;
                bool ok;
                p[i].Stack0 = mp->createstack;
                i++;
            }
        }
        return {n, ok};
    }

    std::tuple<int, bool> runtime_goroutineProfileWithLabels(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels)
    {
        int n;
        bool ok;
        return goroutineProfileWithLabels(p, labels);
    }

    std::tuple<int, bool> goroutineProfileWithLabels(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels)
    {
        int n;
        bool ok;
        if(labels != nullptr && len(labels) != len(p))
        {
            int n;
            bool ok;
            labels = nullptr;
        }
        return goroutineProfileWithLabelsConcurrent(p, labels);
    }

    struct gocpp_id_0
    {
        uint32_t sema;
        bool active;
        atomic::Int64 offset;
        gocpp::slice<StackRecord> records;
        gocpp::slice<unsafe::Pointer> labels;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.sema = this->sema;
            result.active = this->active;
            result.offset = this->offset;
            result.records = this->records;
            result.labels = this->labels;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (sema != ref.sema) return false;
            if (active != ref.active) return false;
            if (offset != ref.offset) return false;
            if (records != ref.records) return false;
            if (labels != ref.labels) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << sema;
            os << " " << active;
            os << " " << offset;
            os << " " << records;
            os << " " << labels;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    struct gocpp_id_0
    {
        uint32_t sema;
        bool active;
        atomic::Int64 offset;
        gocpp::slice<StackRecord> records;
        gocpp::slice<unsafe::Pointer> labels;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.sema = this->sema;
            result.active = this->active;
            result.offset = this->offset;
            result.records = this->records;
            result.labels = this->labels;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (sema != ref.sema) return false;
            if (active != ref.active) return false;
            if (offset != ref.offset) return false;
            if (records != ref.records) return false;
            if (labels != ref.labels) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << sema;
            os << " " << active;
            os << " " << offset;
            os << " " << records;
            os << " " << labels;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 goroutineProfile = gocpp::Init<gocpp_id_0>([](gocpp_id_0& x) { x.sema = 1; });
    runtime::goroutineProfileState rec::Load(golang::runtime::goroutineProfileStateHolder* p)
    {
        return goroutineProfileState(rec::Load(gocpp::recv((atomic::Uint32*)(p))));
    }

    void rec::Store(golang::runtime::goroutineProfileStateHolder* p, golang::runtime::goroutineProfileState value)
    {
        rec::Store(gocpp::recv((atomic::Uint32*)(p)), uint32_t(value));
    }

    bool rec::CompareAndSwap(golang::runtime::goroutineProfileStateHolder* p, golang::runtime::goroutineProfileState old, golang::runtime::goroutineProfileState go_new)
    {
        return rec::CompareAndSwap(gocpp::recv((atomic::Uint32*)(p)), uint32_t(old), uint32_t(go_new));
    }

    std::tuple<int, bool> goroutineProfileWithLabelsConcurrent(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels)
    {
        int n;
        bool ok;
        semacquire(& goroutineProfile.sema);
        auto ourg = getg();
        auto stw = stopTheWorld(stwGoroutineProfile);
        n = int(gcount());
        if(rec::Load(gocpp::recv(fingStatus)) & fingRunningFinalizer != 0)
        {
            int n;
            bool ok;
            n++;
        }
        if(n > len(p))
        {
            int n;
            bool ok;
            startTheWorld(stw);
            semrelease(& goroutineProfile.sema);
            return {n, false};
        }
        auto sp = getcallersp();
        auto pc = getcallerpc();
        systemstack([=]() mutable -> void
        {
            saveg(pc, sp, ourg, & p[0]);
        });
        if(labels != nullptr)
        {
            int n;
            bool ok;
            labels[0] = ourg->labels;
        }
        rec::Store(gocpp::recv(ourg->goroutineProfiled), goroutineProfileSatisfied);
        rec::Store(gocpp::recv(goroutineProfile.offset), 1);
        goroutineProfile.active = true;
        goroutineProfile.records = p;
        goroutineProfile.labels = labels;
        if(fing != nullptr)
        {
            int n;
            bool ok;
            rec::Store(gocpp::recv(fing->goroutineProfiled), goroutineProfileSatisfied);
            if(readgstatus(fing) != _Gdead && ! isSystemGoroutine(fing, false))
            {
                int n;
                bool ok;
                doRecordGoroutineProfile(fing);
            }
        }
        startTheWorld(stw);
        forEachGRace([=](struct g* gp1) mutable -> void
        {
            tryRecordGoroutineProfile(gp1, Gosched);
        });
        stw = stopTheWorld(stwGoroutineProfileCleanup);
        auto endOffset = rec::Swap(gocpp::recv(goroutineProfile.offset), 0);
        goroutineProfile.active = false;
        goroutineProfile.records = nullptr;
        goroutineProfile.labels = nullptr;
        startTheWorld(stw);
        forEachGRace([=](struct g* gp1) mutable -> void
        {
            rec::Store(gocpp::recv(gp1->goroutineProfiled), goroutineProfileAbsent);
        });
        if(raceenabled)
        {
            int n;
            bool ok;
            raceacquire(unsafe::Pointer(& labelSync));
        }
        if(n != int(endOffset))
        {
            int n;
            bool ok;
        }
        semrelease(& goroutineProfile.sema);
        return {n, true};
    }

    void tryRecordGoroutineProfileWB(struct g* gp1)
    {
        if(rec::ptr(gocpp::recv(getg()->m->p)) == nullptr)
        {
            go_throw("no P available, write barriers are forbidden");
        }
        tryRecordGoroutineProfile(gp1, osyield);
    }

    void tryRecordGoroutineProfile(struct g* gp1, std::function<void ()> yield)
    {
        if(readgstatus(gp1) == _Gdead)
        {
            return;
        }
        if(isSystemGoroutine(gp1, true))
        {
            return;
        }
        for(; ; )
        {
            auto prev = rec::Load(gocpp::recv(gp1->goroutineProfiled));
            if(prev == goroutineProfileSatisfied)
            {
                break;
            }
            if(prev == goroutineProfileInProgress)
            {
                yield();
                continue;
            }
            auto mp = acquirem();
            if(rec::CompareAndSwap(gocpp::recv(gp1->goroutineProfiled), goroutineProfileAbsent, goroutineProfileInProgress))
            {
                doRecordGoroutineProfile(gp1);
                rec::Store(gocpp::recv(gp1->goroutineProfiled), goroutineProfileSatisfied);
            }
            releasem(mp);
        }
    }

    void doRecordGoroutineProfile(struct g* gp1)
    {
        if(readgstatus(gp1) == _Grunning)
        {
            print("doRecordGoroutineProfile gp1=", gp1->goid, "\n");
            go_throw("cannot read stack of running goroutine");
        }
        auto offset = int(rec::Add(gocpp::recv(goroutineProfile.offset), 1)) - 1;
        if(offset >= len(goroutineProfile.records))
        {
            return;
        }
        systemstack([=]() mutable -> void
        {
            saveg(~ uintptr_t(0), ~ uintptr_t(0), gp1, & goroutineProfile.records[offset]);
        });
        if(goroutineProfile.labels != nullptr)
        {
            goroutineProfile.labels[offset] = gp1->labels;
        }
    }

    std::tuple<int, bool> goroutineProfileWithLabelsSync(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels)
    {
        int n;
        bool ok;
        auto gp = getg();
        auto isOK = [=](struct g* gp1) mutable -> bool
        {
            return gp1 != gp && readgstatus(gp1) != _Gdead && ! isSystemGoroutine(gp1, false);
        };
        auto stw = stopTheWorld(stwGoroutineProfile);
        n = 1;
        forEachGRace([=](struct g* gp1) mutable -> void
        {
            if(isOK(gp1))
            {
                n++;
            }
        });
        if(n <= len(p))
        {
            int n;
            bool ok;
            ok = true;
            auto [r, lbl] = std::tuple{p, labels};
            auto sp = getcallersp();
            auto pc = getcallerpc();
            systemstack([=]() mutable -> void
            {
                saveg(pc, sp, gp, & r[0]);
            });
            r = r.make_slice(1);
            if(labels != nullptr)
            {
                int n;
                bool ok;
                lbl[0] = gp->labels;
                lbl = lbl.make_slice(1);
            }
            forEachGRace([=](struct g* gp1) mutable -> void
            {
                if(! isOK(gp1))
                {
                    return;
                }
                if(len(r) == 0)
                {
                    return;
                }
                systemstack([=]() mutable -> void
                {
                    saveg(~ uintptr_t(0), ~ uintptr_t(0), gp1, & r[0]);
                });
                if(labels != nullptr)
                {
                    lbl[0] = gp1->labels;
                    lbl = lbl.make_slice(1);
                }
                r = r.make_slice(1);
            });
        }
        if(raceenabled)
        {
            int n;
            bool ok;
            raceacquire(unsafe::Pointer(& labelSync));
        }
        startTheWorld(stw);
        return {n, ok};
    }

    std::tuple<int, bool> GoroutineProfile(gocpp::slice<StackRecord> p)
    {
        int n;
        bool ok;
        return goroutineProfileWithLabels(p, nullptr);
    }

    void saveg(uintptr_t pc, uintptr_t sp, struct g* gp, struct StackRecord* r)
    {
        unwinder u = {};
        rec::initAt(gocpp::recv(u), pc, sp, 0, gp, unwindSilentErrors);
        auto n = tracebackPCs(& u, 0, r->Stack0.make_slice(0, ));
        if(n < len(r->Stack0))
        {
            r->Stack0[n] = 0;
        }
    }

    int Stack(gocpp::slice<unsigned char> buf, bool all)
    {
        worldStop stw = {};
        if(all)
        {
            stw = stopTheWorld(stwAllGoroutinesStack);
        }
        auto n = 0;
        if(len(buf) > 0)
        {
            auto gp = getg();
            auto sp = getcallersp();
            auto pc = getcallerpc();
            systemstack([=]() mutable -> void
            {
                auto g0 = getg();
                g0->m->traceback = 1;
                g0->writebuf = buf.make_slice(0, 0, len(buf));
                goroutineheader(gp);
                traceback(pc, sp, 0, gp);
                if(all)
                {
                    tracebackothers(gp);
                }
                g0->m->traceback = 0;
                n = len(g0->writebuf);
                g0->writebuf = nullptr;
            });
        }
        if(all)
        {
            startTheWorld(stw);
        }
        return n;
    }

    mutex tracelock;
    void tracealloc(unsafe::Pointer p, uintptr_t size, golang::runtime::_type* typ)
    {
        lock(& tracelock);
        auto gp = getg();
        gp->m->traceback = 2;
        if(typ == nullptr)
        {
            print("tracealloc(", p, ", ", hex(size), ")\n");
        }
        else
        {
            print("tracealloc(", p, ", ", hex(size), ", ", rec::string(gocpp::recv(toRType(typ))), ")\n");
        }
        if(gp->m->curg == nullptr || gp == gp->m->curg)
        {
            goroutineheader(gp);
            auto pc = getcallerpc();
            auto sp = getcallersp();
            systemstack([=]() mutable -> void
            {
                traceback(pc, sp, 0, gp);
            });
        }
        else
        {
            goroutineheader(gp->m->curg);
            traceback(~ uintptr_t(0), ~ uintptr_t(0), 0, gp->m->curg);
        }
        print("\n");
        gp->m->traceback = 0;
        unlock(& tracelock);
    }

    void tracefree(unsafe::Pointer p, uintptr_t size)
    {
        lock(& tracelock);
        auto gp = getg();
        gp->m->traceback = 2;
        print("tracefree(", p, ", ", hex(size), ")\n");
        goroutineheader(gp);
        auto pc = getcallerpc();
        auto sp = getcallersp();
        systemstack([=]() mutable -> void
        {
            traceback(pc, sp, 0, gp);
        });
        print("\n");
        gp->m->traceback = 0;
        unlock(& tracelock);
    }

    void tracegc()
    {
        lock(& tracelock);
        auto gp = getg();
        gp->m->traceback = 2;
        print("tracegc()\n");
        tracebackothers(gp);
        print("end tracegc\n");
        print("\n");
        gp->m->traceback = 0;
        unlock(& tracelock);
    }

}

