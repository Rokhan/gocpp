// generated by GoCpp from file '$(ImportDir)/runtime/mem_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mem_windows.h"
#include "gocpp/support.h"

#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Don't split the stack as this function may be invoked without a valid G,
    // which prevents us from allocating more stack.
    //
    //go:nosplit
    gocpp::unsafe_pointer sysAllocOS(uintptr_t n)
    {
        return gocpp::unsafe_pointer(stdcall4(_VirtualAlloc, 0, n, _MEM_COMMIT | _MEM_RESERVE, _PAGE_READWRITE));
    }

    void sysUnusedOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
        auto r = stdcall3(_VirtualFree, uintptr_t(v), n, _MEM_DECOMMIT);
        if(r != 0)
        {
            return;
        }
        for(; n > 0; )
        {
            auto small = n;
            for(; small >= 4096 && stdcall3(_VirtualFree, uintptr_t(v), small, _MEM_DECOMMIT) == 0; )
            {
                small /= 2;
                small &^= 4096 - 1;
            }
            if(small < 4096)
            {
                print("runtime: VirtualFree of "_s, small, " bytes failed with errno="_s, getlasterror(), "\n"_s);
                go_throw("runtime: failed to decommit pages"_s);
            }
            v = add(v, small);
            n -= small;
        }
    }

    void sysUsedOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
        auto p = stdcall4(_VirtualAlloc, uintptr_t(v), n, _MEM_COMMIT, _PAGE_READWRITE);
        if(p == uintptr_t(v))
        {
            return;
        }
        auto k = n;
        for(; k > 0; )
        {
            auto small = k;
            for(; small >= 4096 && stdcall4(_VirtualAlloc, uintptr_t(v), small, _MEM_COMMIT, _PAGE_READWRITE) == 0; )
            {
                small /= 2;
                small &^= 4096 - 1;
            }
            if(small < 4096)
            {
                auto errno = getlasterror();
                //Go switch emulation
                {
                    auto condition = errno;
                    int conditionId = -1;
                    if(condition == _ERROR_NOT_ENOUGH_MEMORY) { conditionId = 0; }
                    else if(condition == _ERROR_COMMITMENT_LIMIT) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                            print("runtime: VirtualAlloc of "_s, n, " bytes failed with errno="_s, errno, "\n"_s);
                            go_throw("out of memory"_s);
                            break;
                        default:
                            print("runtime: VirtualAlloc of "_s, small, " bytes failed with errno="_s, errno, "\n"_s);
                            go_throw("runtime: failed to commit pages"_s);
                            break;
                    }
                }
            }
            v = add(v, small);
            k -= small;
        }
    }

    void sysHugePageOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
    }

    void sysNoHugePageOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
    }

    void sysHugePageCollapseOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
    }

    // Don't split the stack as this function may be invoked without a valid G,
    // which prevents us from allocating more stack.
    //
    //go:nosplit
    void sysFreeOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
        auto r = stdcall3(_VirtualFree, uintptr_t(v), 0, _MEM_RELEASE);
        if(r == 0)
        {
            print("runtime: VirtualFree of "_s, n, " bytes failed with errno="_s, getlasterror(), "\n"_s);
            go_throw("runtime: failed to release pages"_s);
        }
    }

    void sysFaultOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
        sysUnusedOS(v, n);
    }

    gocpp::unsafe_pointer sysReserveOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
        v = gocpp::unsafe_pointer(stdcall4(_VirtualAlloc, uintptr_t(v), n, _MEM_RESERVE, _PAGE_READWRITE));
        if(v != nullptr)
        {
            return v;
        }
        return gocpp::unsafe_pointer(stdcall4(_VirtualAlloc, 0, n, _MEM_RESERVE, _PAGE_READWRITE));
    }

    void sysMapOS(gocpp::unsafe_pointer v, uintptr_t n)
    {
    }

}

