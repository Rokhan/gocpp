// generated by GoCpp from file '$(ImportDir)/internal/syscall/windows/registry/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/syscall/windows/registry/value.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/syscall/windows/registry/key.h"
#include "golang/internal/syscall/windows/registry/syscall.h"
#include "golang/internal/syscall/windows/registry/zsyscall_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unicode/utf16/utf16.h"
#include "golang/unsafe/unsafe.h"

namespace golang::registry
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Registry value types.
    // ErrShortBuffer is returned when the buffer was too short for the operation.
    // ErrNotExist is returned when a registry key or value does not exist.
    // ErrUnexpectedType is returned by Get*Value when the value's type was unexpected.
    syscall::Errno ErrShortBuffer = syscall::ERROR_MORE_DATA;
    syscall::Errno ErrNotExist = syscall::ERROR_FILE_NOT_FOUND;
    gocpp::error ErrUnexpectedType = errors::New("unexpected key value type"s);
    // GetValue retrieves the type and data for the specified value associated
    // with an open key k. It fills up buffer buf and returns the retrieved
    // byte count n. If buf is too small to fit the stored value it returns
    // ErrShortBuffer error along with the required buffer size n.
    // If no buffer is provided, it returns true and actual buffer size n.
    // If no buffer is provided, GetValue returns the value's type only.
    // If the value does not exist, the error returned is ErrNotExist.
    //
    // GetValue is a low level function. If value's type is known, use the appropriate
    // Get*Value function instead.
    std::tuple<int, uint32_t, struct gocpp::error> rec::GetValue(golang::registry::Key k, std::string name, gocpp::slice<unsigned char> buf)
    {
        int n;
        uint32_t valtype;
        struct gocpp::error err;
        uint16_t* pname;
        std::tie(pname, err) = syscall::UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return {0, 0, err};
        }
        unsigned char* pbuf = {};
        if(len(buf) > 0)
        {
            pbuf = (unsigned char*)(unsafe::Pointer(& buf[0]));
        }
        auto l = uint32_t(len(buf));
        err = syscall::RegQueryValueEx(syscall::Handle(k), pname, nullptr, & valtype, pbuf, & l);
        if(err != nullptr)
        {
            return {int(l), valtype, err};
        }
        return {int(l), valtype, nullptr};
    }

    std::tuple<gocpp::slice<unsigned char>, uint32_t, struct gocpp::error> rec::getValue(golang::registry::Key k, std::string name, gocpp::slice<unsigned char> buf)
    {
        gocpp::slice<unsigned char> date;
        uint32_t valtype;
        struct gocpp::error err;
        uint16_t* p;
        std::tie(p, err) = syscall::UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return {nullptr, 0, err};
        }
        uint32_t t = {};
        auto n = uint32_t(len(buf));
        for(; ; )
        {
            err = syscall::RegQueryValueEx(syscall::Handle(k), p, nullptr, & t, (unsigned char*)(unsafe::Pointer(& buf[0])), & n);
            if(err == nullptr)
            {
                return {buf.make_slice(0, n), t, nullptr};
            }
            if(err != syscall::ERROR_MORE_DATA)
            {
                return {nullptr, 0, err};
            }
            if(n <= uint32_t(len(buf)))
            {
                return {nullptr, 0, err};
            }
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
        }
    }

    // GetStringValue retrieves the string value for the specified
    // value name associated with an open key k. It also returns the value's type.
    // If value does not exist, GetStringValue returns ErrNotExist.
    // If value is not SZ or EXPAND_SZ, it will return the correct value
    // type and ErrUnexpectedType.
    std::tuple<std::string, uint32_t, struct gocpp::error> rec::GetStringValue(golang::registry::Key k, std::string name)
    {
        std::string val;
        uint32_t valtype;
        struct gocpp::error err;
        auto [data, typ, err2] = rec::getValue(gocpp::recv(k), name, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 64));
        if(err2 != nullptr)
        {
            return {""s, typ, err2};
        }
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == SZ) { conditionId = 0; }
            else if(condition == EXPAND_SZ) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    break;
                default:
                    return {""s, typ, ErrUnexpectedType};
                    break;
            }
        }
        if(len(data) == 0)
        {
            return {""s, typ, nullptr};
        }
        auto u = (gocpp::array<uint16_t, 1 << 29>*)(unsafe::Pointer(& data[0])).make_slice(0, len(data) / 2, len(data) / 2);
        return {syscall::UTF16ToString(u), typ, nullptr};
    }

    // GetMUIStringValue retrieves the localized string value for
    // the specified value name associated with an open key k.
    // If the value name doesn't exist or the localized string value
    // can't be resolved, GetMUIStringValue returns ErrNotExist.
    std::tuple<std::string, struct gocpp::error> rec::GetMUIStringValue(golang::registry::Key k, std::string name)
    {
        auto [pname, err] = syscall::UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return {""s, err};
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 1024);
        uint32_t buflen = {};
        uint16_t* pdir = {};
        err = regLoadMUIString(syscall::Handle(k), pname, & buf[0], uint32_t(len(buf)), & buflen, 0, pdir);
        if(err == syscall::ERROR_FILE_NOT_FOUND)
        {
            std::string s = {};
            std::tie(s, err) = ExpandString("%SystemRoot%\\system32\\"s);
            if(err != nullptr)
            {
                return {""s, err};
            }
            std::tie(pdir, err) = syscall::UTF16PtrFromString(s);
            if(err != nullptr)
            {
                return {""s, err};
            }
            err = regLoadMUIString(syscall::Handle(k), pname, & buf[0], uint32_t(len(buf)), & buflen, 0, pdir);
        }
        for(; err == syscall::ERROR_MORE_DATA; )
        {
            if(buflen <= uint32_t(len(buf)))
            {
                break;
            }
            buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), buflen);
            err = regLoadMUIString(syscall::Handle(k), pname, & buf[0], uint32_t(len(buf)), & buflen, 0, pdir);
        }
        if(err != nullptr)
        {
            return {""s, err};
        }
        return {syscall::UTF16ToString(buf), nullptr};
    }

    // ExpandString expands environment-variable strings and replaces
    // them with the values defined for the current user.
    // Use ExpandString to expand EXPAND_SZ strings.
    std::tuple<std::string, struct gocpp::error> ExpandString(std::string value)
    {
        if(value == ""s)
        {
            return {""s, nullptr};
        }
        auto [p, err] = syscall::UTF16PtrFromString(value);
        if(err != nullptr)
        {
            return {""s, err};
        }
        auto r = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 100);
        for(; ; )
        {
            auto [n, err] = expandEnvironmentStrings(p, & r[0], uint32_t(len(r)));
            if(err != nullptr)
            {
                return {""s, err};
            }
            if(n <= uint32_t(len(r)))
            {
                return {syscall::UTF16ToString(r.make_slice(0, n)), nullptr};
            }
            r = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
        }
    }

    // GetStringsValue retrieves the []string value for the specified
    // value name associated with an open key k. It also returns the value's type.
    // If value does not exist, GetStringsValue returns ErrNotExist.
    // If value is not MULTI_SZ, it will return the correct value
    // type and ErrUnexpectedType.
    std::tuple<gocpp::slice<std::string>, uint32_t, struct gocpp::error> rec::GetStringsValue(golang::registry::Key k, std::string name)
    {
        gocpp::slice<std::string> val;
        uint32_t valtype;
        struct gocpp::error err;
        auto [data, typ, err2] = rec::getValue(gocpp::recv(k), name, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 64));
        if(err2 != nullptr)
        {
            return {nullptr, typ, err2};
        }
        if(typ != MULTI_SZ)
        {
            return {nullptr, typ, ErrUnexpectedType};
        }
        if(len(data) == 0)
        {
            return {nullptr, typ, nullptr};
        }
        auto p = (gocpp::array<uint16_t, 1 << 29>*)(unsafe::Pointer(& data[0])).make_slice(0, len(data) / 2, len(data) / 2);
        if(len(p) == 0)
        {
            return {nullptr, typ, nullptr};
        }
        if(p[len(p) - 1] == 0)
        {
            p = p.make_slice(0, len(p) - 1);
        }
        val = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0, 5);
        auto from = 0;
        for(auto [i, c] : p)
        {
            if(c == 0)
            {
                val = append(val, syscall::UTF16ToString(p.make_slice(from, i)));
                from = i + 1;
            }
        }
        return {val, typ, nullptr};
    }

    // GetIntegerValue retrieves the integer value for the specified
    // value name associated with an open key k. It also returns the value's type.
    // If value does not exist, GetIntegerValue returns ErrNotExist.
    // If value is not DWORD or QWORD, it will return the correct value
    // type and ErrUnexpectedType.
    std::tuple<uint64_t, uint32_t, struct gocpp::error> rec::GetIntegerValue(golang::registry::Key k, std::string name)
    {
        uint64_t val;
        uint32_t valtype;
        struct gocpp::error err;
        auto [data, typ, err2] = rec::getValue(gocpp::recv(k), name, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 8));
        if(err2 != nullptr)
        {
            return {0, typ, err2};
        }
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == DWORD) { conditionId = 0; }
            else if(condition == QWORD) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(len(data) != 4)
                    {
                        return {0, typ, errors::New("DWORD value is not 4 bytes long"s)};
                    }
                    return {uint64_t(*(uint32_t*)(unsafe::Pointer(& data[0]))), DWORD, nullptr};
                    break;
                case 1:
                    if(len(data) != 8)
                    {
                        return {0, typ, errors::New("QWORD value is not 8 bytes long"s)};
                    }
                    return {*(uint64_t*)(unsafe::Pointer(& data[0])), QWORD, nullptr};
                    break;
                default:
                    return {0, typ, ErrUnexpectedType};
                    break;
            }
        }
    }

    // GetBinaryValue retrieves the binary value for the specified
    // value name associated with an open key k. It also returns the value's type.
    // If value does not exist, GetBinaryValue returns ErrNotExist.
    // If value is not BINARY, it will return the correct value
    // type and ErrUnexpectedType.
    std::tuple<gocpp::slice<unsigned char>, uint32_t, struct gocpp::error> rec::GetBinaryValue(golang::registry::Key k, std::string name)
    {
        gocpp::slice<unsigned char> val;
        uint32_t valtype;
        struct gocpp::error err;
        auto [data, typ, err2] = rec::getValue(gocpp::recv(k), name, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 64));
        if(err2 != nullptr)
        {
            return {nullptr, typ, err2};
        }
        if(typ != BINARY)
        {
            return {nullptr, typ, ErrUnexpectedType};
        }
        return {data, typ, nullptr};
    }

    struct gocpp::error rec::setValue(golang::registry::Key k, std::string name, uint32_t valtype, gocpp::slice<unsigned char> data)
    {
        auto [p, err] = syscall::UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return err;
        }
        if(len(data) == 0)
        {
            return regSetValueEx(syscall::Handle(k), p, 0, valtype, nullptr, 0);
        }
        return regSetValueEx(syscall::Handle(k), p, 0, valtype, & data[0], uint32_t(len(data)));
    }

    // SetDWordValue sets the data and type of a name value
    // under key k to value and DWORD.
    struct gocpp::error rec::SetDWordValue(golang::registry::Key k, std::string name, uint32_t value)
    {
        return rec::setValue(gocpp::recv(k), name, DWORD, (gocpp::array<unsigned char, 4>*)(unsafe::Pointer(& value)).make_slice(0));
    }

    // SetQWordValue sets the data and type of a name value
    // under key k to value and QWORD.
    struct gocpp::error rec::SetQWordValue(golang::registry::Key k, std::string name, uint64_t value)
    {
        return rec::setValue(gocpp::recv(k), name, QWORD, (gocpp::array<unsigned char, 8>*)(unsafe::Pointer(& value)).make_slice(0));
    }

    struct gocpp::error rec::setStringValue(golang::registry::Key k, std::string name, uint32_t valtype, std::string value)
    {
        auto [v, err] = syscall::UTF16FromString(value);
        if(err != nullptr)
        {
            return err;
        }
        auto buf = (gocpp::array<unsigned char, 1 << 29>*)(unsafe::Pointer(& v[0])).make_slice(0, len(v) * 2, len(v) * 2);
        return rec::setValue(gocpp::recv(k), name, valtype, buf);
    }

    // SetStringValue sets the data and type of a name value
    // under key k to value and SZ. The value must not contain a zero byte.
    struct gocpp::error rec::SetStringValue(golang::registry::Key k, std::string name, std::string value)
    {
        return rec::setStringValue(gocpp::recv(k), name, SZ, value);
    }

    // SetExpandStringValue sets the data and type of a name value
    // under key k to value and EXPAND_SZ. The value must not contain a zero byte.
    struct gocpp::error rec::SetExpandStringValue(golang::registry::Key k, std::string name, std::string value)
    {
        return rec::setStringValue(gocpp::recv(k), name, EXPAND_SZ, value);
    }

    // SetStringsValue sets the data and type of a name value
    // under key k to value and MULTI_SZ. The value strings
    // must not contain a zero byte.
    struct gocpp::error rec::SetStringsValue(golang::registry::Key k, std::string name, gocpp::slice<std::string> value)
    {
        auto ss = ""s;
        for(auto [gocpp_ignored, s] : value)
        {
            for(auto i = 0; i < len(s); i++)
            {
                if(s[i] == 0)
                {
                    return errors::New("string cannot have 0 inside"s);
                }
            }
            ss += s + "\x00"s;
        }
        auto v = utf16::Encode(gocpp::slice<gocpp::rune>(ss + "\x00"s));
        auto buf = (gocpp::array<unsigned char, 1 << 29>*)(unsafe::Pointer(& v[0])).make_slice(0, len(v) * 2, len(v) * 2);
        return rec::setValue(gocpp::recv(k), name, MULTI_SZ, buf);
    }

    // SetBinaryValue sets the data and type of a name value
    // under key k to value and BINARY.
    struct gocpp::error rec::SetBinaryValue(golang::registry::Key k, std::string name, gocpp::slice<unsigned char> value)
    {
        return rec::setValue(gocpp::recv(k), name, BINARY, value);
    }

    // DeleteValue removes a named value from the key k.
    struct gocpp::error rec::DeleteValue(golang::registry::Key k, std::string name)
    {
        return regDeleteValue(syscall::Handle(k), syscall::StringToUTF16Ptr(name));
    }

    // ReadValueNames returns the value names of key k.
    std::tuple<gocpp::slice<std::string>, struct gocpp::error> rec::ReadValueNames(golang::registry::Key k)
    {
        auto [ki, err] = rec::Stat(gocpp::recv(k));
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        auto names = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0, ki->ValueCount);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), ki->MaxValueNameLen + 1);
        loopItems:
        for(auto i = uint32_t(0); ; i++)
        {
            auto l = uint32_t(len(buf));
            for(; ; )
            {
                auto err = regEnumValue(syscall::Handle(k), i, & buf[0], & l, nullptr, nullptr, nullptr, nullptr);
                if(err == nullptr)
                {
                    break;
                }
                if(err == syscall::ERROR_MORE_DATA)
                {
                    l = uint32_t(2 * len(buf));
                    buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), l);
                    continue;
                }
                if(err == _ERROR_NO_MORE_ITEMS)
                {
                    goto loopItems_break;
                }
                return {names, err};
            }
            names = append(names, syscall::UTF16ToString(buf.make_slice(0, l)));
            if(false) {
            loopItems_continue:
                continue;
            loopItems_break:
                break;
            }
        }
        return {names, nullptr};
    }

}

