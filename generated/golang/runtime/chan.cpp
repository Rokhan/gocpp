// generated by GoCpp from file '$(ImportDir)/runtime/chan.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/chan.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/cputicks.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/math/math.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbarrier.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Store;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    hchan::operator T()
    {
        T result;
        result.qcount = this->qcount;
        result.dataqsiz = this->dataqsiz;
        result.buf = this->buf;
        result.elemsize = this->elemsize;
        result.closed = this->closed;
        result.elemtype = this->elemtype;
        result.sendx = this->sendx;
        result.recvx = this->recvx;
        result.recvq = this->recvq;
        result.sendq = this->sendq;
        result.lock = this->lock;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool hchan::operator==(const T& ref) const
    {
        if (qcount != ref.qcount) return false;
        if (dataqsiz != ref.dataqsiz) return false;
        if (buf != ref.buf) return false;
        if (elemsize != ref.elemsize) return false;
        if (closed != ref.closed) return false;
        if (elemtype != ref.elemtype) return false;
        if (sendx != ref.sendx) return false;
        if (recvx != ref.recvx) return false;
        if (recvq != ref.recvq) return false;
        if (sendq != ref.sendq) return false;
        if (lock != ref.lock) return false;
        return true;
    }

    std::ostream& hchan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << qcount;
        os << " " << dataqsiz;
        os << " " << buf;
        os << " " << elemsize;
        os << " " << closed;
        os << " " << elemtype;
        os << " " << sendx;
        os << " " << recvx;
        os << " " << recvq;
        os << " " << sendq;
        os << " " << lock;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct hchan& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    waitq::operator T()
    {
        T result;
        result.first = this->first;
        result.last = this->last;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool waitq::operator==(const T& ref) const
    {
        if (first != ref.first) return false;
        if (last != ref.last) return false;
        return true;
    }

    std::ostream& waitq::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << first;
        os << " " << last;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct waitq& value)
    {
        return value.PrintTo(os);
    }

    //go:linkname reflect_makechan reflect.makechan
    struct hchan* reflect_makechan(golang::runtime::chantype* t, int size)
    {
        return makechan(t, size);
    }

    struct hchan* makechan64(golang::runtime::chantype* t, int64_t size)
    {
        if(int64_t(int(size)) != size)
        {
            gocpp::panic(plainError("makechan: size out of range"_s));
        }
        return makechan(t, int(size));
    }

    struct hchan* makechan(golang::runtime::chantype* t, int size)
    {
        auto elem = t->Elem;
        if(elem->Size_ >= (1 << 16))
        {
            go_throw("makechan: invalid channel element type"_s);
        }
        if(hchanSize % maxAlign != 0 || elem->Align_ > maxAlign)
        {
            go_throw("makechan: bad alignment"_s);
        }
        auto [mem, overflow] = math::MulUintptr(elem->Size_, uintptr_t(size));
        if(overflow || mem > maxAlloc - hchanSize || size < 0)
        {
            gocpp::panic(plainError("makechan: size out of range"_s));
        }
        // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
        // buf points into the same allocation, elemtype is persistent.
        // SudoG's are referenced from their owning thread so they can't be collected.
        // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
        hchan* c = {};
        //Go switch emulation
        {
            int conditionId = -1;
            if(mem == 0) { conditionId = 0; }
            else if(elem->PtrBytes == 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    c = (hchan*)(mallocgc(hchanSize, nullptr, true));
                    c->buf = rec::raceaddr(gocpp::recv(c));
                    break;
                case 1:
                    c = (hchan*)(mallocgc(hchanSize + mem, nullptr, true));
                    c->buf = add(gocpp::unsafe_pointer(c), hchanSize);
                    break;
                default:
                    c = new(hchan);
                    c->buf = mallocgc(mem, elem, true);
                    break;
            }
        }
        c->elemsize = uint16_t(elem->Size_);
        c->elemtype = elem;
        c->dataqsiz = (unsigned int)(size);
        lockInit(& c->lock, lockRankHchan);
        if(debugChan)
        {
            print("makechan: chan="_s, c, "; elemsize="_s, elem->Size_, "; dataqsiz="_s, size, "\n"_s);
        }
        return c;
    }

    // chanbuf(c, i) is pointer to the i'th slot in the buffer.
    gocpp::unsafe_pointer chanbuf(struct hchan* c, unsigned int i)
    {
        return add(c->buf, uintptr_t(i) * uintptr_t(c->elemsize));
    }

    // full reports whether a send on c would block (that is, the channel is full).
    // It uses a single word-sized read of mutable state, so although
    // the answer is instantaneously true, the correct answer may have changed
    // by the time the calling function receives the return value.
    bool full(struct hchan* c)
    {
        if(c->dataqsiz == 0)
        {
            return c->recvq.first == nullptr;
        }
        return c->qcount == c->dataqsiz;
    }

    // entry point for c <- x from compiled code.
    //
    //go:nosplit
    void chansend1(struct hchan* c, gocpp::unsafe_pointer elem)
    {
        chansend(c, elem, true, getcallerpc());
    }

    /*
 * generic single channel send/recv
 * If block is not nil,
 * then the protocol will not
 * sleep but return if it could
 * not complete.
 *
 * sleep can wake up with g.param == nil
 * when a channel involved in the sleep has
 * been closed.  it is easiest to loop and re-run
 * the operation; we'll see that it's now closed.
 */
    bool chansend(struct hchan* c, gocpp::unsafe_pointer ep, bool block, uintptr_t callerpc)
    {
        if(c == nullptr)
        {
            if(! block)
            {
                return false;
            }
            gopark(nullptr, nullptr, waitReasonChanSendNilChan, traceBlockForever, 2);
            go_throw("unreachable"_s);
        }
        if(debugChan)
        {
            print("chansend: chan="_s, c, "\n"_s);
        }
        if(raceenabled)
        {
            racereadpc(rec::raceaddr(gocpp::recv(c)), callerpc, abi::FuncPCABIInternal(chansend));
        }
        if(! block && c->closed == 0 && full(c))
        {
            return false;
        }
        int64_t t0 = {};
        if(blockprofilerate > 0)
        {
            t0 = cputicks();
        }
        lock(& c->lock);
        if(c->closed != 0)
        {
            unlock(& c->lock);
            gocpp::panic(plainError("send on closed channel"_s));
        }
        if(auto sg = rec::dequeue(gocpp::recv(c->recvq)); sg != nullptr)
        {
            send(c, sg, ep, [=]() mutable -> void
            {
                unlock(& c->lock);
            }, 3);
            return true;
        }
        if(c->qcount < c->dataqsiz)
        {
            auto qp = chanbuf(c, c->sendx);
            if(raceenabled)
            {
                racenotify(c, c->sendx, nullptr);
            }
            typedmemmove(c->elemtype, qp, ep);
            c->sendx++;
            if(c->sendx == c->dataqsiz)
            {
                c->sendx = 0;
            }
            c->qcount++;
            unlock(& c->lock);
            return true;
        }
        if(! block)
        {
            unlock(& c->lock);
            return false;
        }
        auto gp = getg();
        auto mysg = acquireSudog();
        mysg->releasetime = 0;
        if(t0 != 0)
        {
            mysg->releasetime = - 1;
        }
        mysg->elem = ep;
        mysg->waitlink = nullptr;
        mysg->g = gp;
        mysg->isSelect = false;
        mysg->c = c;
        gp->waiting = mysg;
        gp->param = nullptr;
        rec::enqueue(gocpp::recv(c->sendq), mysg);
        rec::Store(gocpp::recv(gp->parkingOnChan), true);
        gopark(chanparkcommit, gocpp::unsafe_pointer(& c->lock), waitReasonChanSend, traceBlockChanSend, 2);
        KeepAlive(ep);
        if(mysg != gp->waiting)
        {
            go_throw("G waiting list is corrupted"_s);
        }
        gp->waiting = nullptr;
        gp->activeStackChans = false;
        auto closed = ! mysg->success;
        gp->param = nullptr;
        if(mysg->releasetime > 0)
        {
            blockevent(mysg->releasetime - t0, 2);
        }
        mysg->c = nullptr;
        releaseSudog(mysg);
        if(closed)
        {
            if(c->closed == 0)
            {
                go_throw("chansend: spurious wakeup"_s);
            }
            gocpp::panic(plainError("send on closed channel"_s));
        }
        return true;
    }

    // send processes a send operation on an empty channel c.
    // The value ep sent by the sender is copied to the receiver sg.
    // The receiver is then woken up to go on its merry way.
    // Channel c must be empty and locked.  send unlocks c with unlockf.
    // sg must already be dequeued from c.
    // ep must be non-nil and point to the heap or the caller's stack.
    void send(struct hchan* c, struct sudog* sg, gocpp::unsafe_pointer ep, std::function<void ()> unlockf, int skip)
    {
        if(raceenabled)
        {
            if(c->dataqsiz == 0)
            {
                racesync(c, sg);
            }
            else
            {
                racenotify(c, c->recvx, nullptr);
                racenotify(c, c->recvx, sg);
                c->recvx++;
                if(c->recvx == c->dataqsiz)
                {
                    c->recvx = 0;
                }
                c->sendx = c->recvx;
            }
        }
        if(sg->elem != nullptr)
        {
            sendDirect(c->elemtype, sg, ep);
            sg->elem = nullptr;
        }
        auto gp = sg->g;
        unlockf();
        gp->param = gocpp::unsafe_pointer(sg);
        sg->success = true;
        if(sg->releasetime != 0)
        {
            sg->releasetime = cputicks();
        }
        goready(gp, skip + 1);
    }

    void sendDirect(golang::runtime::_type* t, struct sudog* sg, gocpp::unsafe_pointer src)
    {
        auto dst = sg->elem;
        typeBitsBulkBarrier(t, uintptr_t(dst), uintptr_t(src), t->Size_);
        memmove(dst, src, t->Size_);
    }

    void recvDirect(golang::runtime::_type* t, struct sudog* sg, gocpp::unsafe_pointer dst)
    {
        auto src = sg->elem;
        typeBitsBulkBarrier(t, uintptr_t(dst), uintptr_t(src), t->Size_);
        memmove(dst, src, t->Size_);
    }

    void closechan(struct hchan* c)
    {
        if(c == nullptr)
        {
            gocpp::panic(plainError("close of nil channel"_s));
        }
        lock(& c->lock);
        if(c->closed != 0)
        {
            unlock(& c->lock);
            gocpp::panic(plainError("close of closed channel"_s));
        }
        if(raceenabled)
        {
            auto callerpc = getcallerpc();
            racewritepc(rec::raceaddr(gocpp::recv(c)), callerpc, abi::FuncPCABIInternal(closechan));
            racerelease(rec::raceaddr(gocpp::recv(c)));
        }
        c->closed = 1;
        gList glist = {};
        for(; ; )
        {
            auto sg = rec::dequeue(gocpp::recv(c->recvq));
            if(sg == nullptr)
            {
                break;
            }
            if(sg->elem != nullptr)
            {
                typedmemclr(c->elemtype, sg->elem);
                sg->elem = nullptr;
            }
            if(sg->releasetime != 0)
            {
                sg->releasetime = cputicks();
            }
            auto gp = sg->g;
            gp->param = gocpp::unsafe_pointer(sg);
            sg->success = false;
            if(raceenabled)
            {
                raceacquireg(gp, rec::raceaddr(gocpp::recv(c)));
            }
            rec::push(gocpp::recv(glist), gp);
        }
        for(; ; )
        {
            auto sg = rec::dequeue(gocpp::recv(c->sendq));
            if(sg == nullptr)
            {
                break;
            }
            sg->elem = nullptr;
            if(sg->releasetime != 0)
            {
                sg->releasetime = cputicks();
            }
            auto gp = sg->g;
            gp->param = gocpp::unsafe_pointer(sg);
            sg->success = false;
            if(raceenabled)
            {
                raceacquireg(gp, rec::raceaddr(gocpp::recv(c)));
            }
            rec::push(gocpp::recv(glist), gp);
        }
        unlock(& c->lock);
        for(; ! rec::empty(gocpp::recv(glist)); )
        {
            auto gp = rec::pop(gocpp::recv(glist));
            gp->schedlink = 0;
            goready(gp, 3);
        }
    }

    // empty reports whether a read from c would block (that is, the channel is
    // empty).  It uses a single atomic read of mutable state.
    bool empty(struct hchan* c)
    {
        if(c->dataqsiz == 0)
        {
            return atomic::Loadp(gocpp::unsafe_pointer(& c->sendq.first)) == nullptr;
        }
        return atomic::Loaduint(& c->qcount) == 0;
    }

    // entry points for <- c from compiled code.
    //
    //go:nosplit
    void chanrecv1(struct hchan* c, gocpp::unsafe_pointer elem)
    {
        chanrecv(c, elem, true);
    }

    //go:nosplit
    bool chanrecv2(struct hchan* c, gocpp::unsafe_pointer elem)
    {
        bool received;
        std::tie(std::ignore, received) = chanrecv(c, elem, true);
        return received;
    }

    // chanrecv receives on channel c and writes the received data to ep.
    // ep may be nil, in which case received data is ignored.
    // If block == false and no elements are available, returns (false, false).
    // Otherwise, if c is closed, zeros *ep and returns (true, false).
    // Otherwise, fills in *ep with an element and returns (true, true).
    // A non-nil ep must point to the heap or the caller's stack.
    std::tuple<bool, bool> chanrecv(struct hchan* c, gocpp::unsafe_pointer ep, bool block)
    {
        bool selected;
        bool received;
        if(debugChan)
        {
            print("chanrecv: chan="_s, c, "\n"_s);
        }
        if(c == nullptr)
        {
            if(! block)
            {
                return {selected, received};
            }
            gopark(nullptr, nullptr, waitReasonChanReceiveNilChan, traceBlockForever, 2);
            go_throw("unreachable"_s);
        }
        if(! block && empty(c))
        {
            if(atomic::Load(& c->closed) == 0)
            {
                return {selected, received};
            }
            if(empty(c))
            {
                if(raceenabled)
                {
                    raceacquire(rec::raceaddr(gocpp::recv(c)));
                }
                if(ep != nullptr)
                {
                    typedmemclr(c->elemtype, ep);
                }
                return {true, false};
            }
        }
        int64_t t0 = {};
        if(blockprofilerate > 0)
        {
            t0 = cputicks();
        }
        lock(& c->lock);
        if(c->closed != 0)
        {
            if(c->qcount == 0)
            {
                if(raceenabled)
                {
                    raceacquire(rec::raceaddr(gocpp::recv(c)));
                }
                unlock(& c->lock);
                if(ep != nullptr)
                {
                    typedmemclr(c->elemtype, ep);
                }
                return {true, false};
            }
        }
        else
        {
            if(auto sg = rec::dequeue(gocpp::recv(c->sendq)); sg != nullptr)
            {
                recv(c, sg, ep, [=]() mutable -> void
                {
                    unlock(& c->lock);
                }, 3);
                return {true, true};
            }
        }
        if(c->qcount > 0)
        {
            auto qp = chanbuf(c, c->recvx);
            if(raceenabled)
            {
                racenotify(c, c->recvx, nullptr);
            }
            if(ep != nullptr)
            {
                typedmemmove(c->elemtype, ep, qp);
            }
            typedmemclr(c->elemtype, qp);
            c->recvx++;
            if(c->recvx == c->dataqsiz)
            {
                c->recvx = 0;
            }
            c->qcount--;
            unlock(& c->lock);
            return {true, true};
        }
        if(! block)
        {
            unlock(& c->lock);
            return {false, false};
        }
        auto gp = getg();
        auto mysg = acquireSudog();
        mysg->releasetime = 0;
        if(t0 != 0)
        {
            mysg->releasetime = - 1;
        }
        mysg->elem = ep;
        mysg->waitlink = nullptr;
        gp->waiting = mysg;
        mysg->g = gp;
        mysg->isSelect = false;
        mysg->c = c;
        gp->param = nullptr;
        rec::enqueue(gocpp::recv(c->recvq), mysg);
        rec::Store(gocpp::recv(gp->parkingOnChan), true);
        gopark(chanparkcommit, gocpp::unsafe_pointer(& c->lock), waitReasonChanReceive, traceBlockChanRecv, 2);
        if(mysg != gp->waiting)
        {
            go_throw("G waiting list is corrupted"_s);
        }
        gp->waiting = nullptr;
        gp->activeStackChans = false;
        if(mysg->releasetime > 0)
        {
            blockevent(mysg->releasetime - t0, 2);
        }
        auto success = mysg->success;
        gp->param = nullptr;
        mysg->c = nullptr;
        releaseSudog(mysg);
        return {true, success};
    }

    // recv processes a receive operation on a full channel c.
    // There are 2 parts:
    //  1. The value sent by the sender sg is put into the channel
    //     and the sender is woken up to go on its merry way.
    //  2. The value received by the receiver (the current G) is
    //     written to ep.
    //
    // For synchronous channels, both values are the same.
    // For asynchronous channels, the receiver gets its data from
    // the channel buffer and the sender's data is put in the
    // channel buffer.
    // Channel c must be full and locked. recv unlocks c with unlockf.
    // sg must already be dequeued from c.
    // A non-nil ep must point to the heap or the caller's stack.
    void recv(struct hchan* c, struct sudog* sg, gocpp::unsafe_pointer ep, std::function<void ()> unlockf, int skip)
    {
        if(c->dataqsiz == 0)
        {
            if(raceenabled)
            {
                racesync(c, sg);
            }
            if(ep != nullptr)
            {
                recvDirect(c->elemtype, sg, ep);
            }
        }
        else
        {
            auto qp = chanbuf(c, c->recvx);
            if(raceenabled)
            {
                racenotify(c, c->recvx, nullptr);
                racenotify(c, c->recvx, sg);
            }
            if(ep != nullptr)
            {
                typedmemmove(c->elemtype, ep, qp);
            }
            typedmemmove(c->elemtype, qp, sg->elem);
            c->recvx++;
            if(c->recvx == c->dataqsiz)
            {
                c->recvx = 0;
            }
            c->sendx = c->recvx;
        }
        sg->elem = nullptr;
        auto gp = sg->g;
        unlockf();
        gp->param = gocpp::unsafe_pointer(sg);
        sg->success = true;
        if(sg->releasetime != 0)
        {
            sg->releasetime = cputicks();
        }
        goready(gp, skip + 1);
    }

    bool chanparkcommit(struct g* gp, gocpp::unsafe_pointer chanLock)
    {
        gp->activeStackChans = true;
        rec::Store(gocpp::recv(gp->parkingOnChan), false);
        unlock((mutex*)(chanLock));
        return true;
    }

    // compiler implements
    //
    //	select {
    //	case c <- v:
    //		... foo
    //	default:
    //		... bar
    //	}
    //
    // as
    //
    //	if selectnbsend(c, v) {
    //		... foo
    //	} else {
    //		... bar
    //	}
    bool selectnbsend(struct hchan* c, gocpp::unsafe_pointer elem)
    {
        bool selected;
        return chansend(c, elem, false, getcallerpc());
    }

    // compiler implements
    //
    //	select {
    //	case v, ok = <-c:
    //		... foo
    //	default:
    //		... bar
    //	}
    //
    // as
    //
    //	if selected, ok = selectnbrecv(&v, c); selected {
    //		... foo
    //	} else {
    //		... bar
    //	}
    std::tuple<bool, bool> selectnbrecv(gocpp::unsafe_pointer elem, struct hchan* c)
    {
        bool selected;
        bool received;
        return chanrecv(c, elem, false);
    }

    //go:linkname reflect_chansend reflect.chansend0
    bool reflect_chansend(struct hchan* c, gocpp::unsafe_pointer elem, bool nb)
    {
        bool selected;
        return chansend(c, elem, ! nb, getcallerpc());
    }

    //go:linkname reflect_chanrecv reflect.chanrecv
    std::tuple<bool, bool> reflect_chanrecv(struct hchan* c, bool nb, gocpp::unsafe_pointer elem)
    {
        bool selected;
        bool received;
        return chanrecv(c, elem, ! nb);
    }

    //go:linkname reflect_chanlen reflect.chanlen
    int reflect_chanlen(struct hchan* c)
    {
        if(c == nullptr)
        {
            return 0;
        }
        return int(c->qcount);
    }

    //go:linkname reflectlite_chanlen internal/reflectlite.chanlen
    int reflectlite_chanlen(struct hchan* c)
    {
        if(c == nullptr)
        {
            return 0;
        }
        return int(c->qcount);
    }

    //go:linkname reflect_chancap reflect.chancap
    int reflect_chancap(struct hchan* c)
    {
        if(c == nullptr)
        {
            return 0;
        }
        return int(c->dataqsiz);
    }

    //go:linkname reflect_chanclose reflect.chanclose
    void reflect_chanclose(struct hchan* c)
    {
        closechan(c);
    }

    void rec::enqueue(golang::runtime::waitq* q, struct sudog* sgp)
    {
        sgp->next = nullptr;
        auto x = q->last;
        if(x == nullptr)
        {
            sgp->prev = nullptr;
            q->first = sgp;
            q->last = sgp;
            return;
        }
        sgp->prev = x;
        x->next = sgp;
        q->last = sgp;
    }

    struct sudog* rec::dequeue(golang::runtime::waitq* q)
    {
        for(; ; )
        {
            auto sgp = q->first;
            if(sgp == nullptr)
            {
                return nullptr;
            }
            auto y = sgp->next;
            if(y == nullptr)
            {
                q->first = nullptr;
                q->last = nullptr;
            }
            else
            {
                y->prev = nullptr;
                q->first = y;
                sgp->next = nullptr;
            }
            if(sgp->isSelect && ! rec::CompareAndSwap(gocpp::recv(sgp->g->selectDone), 0, 1))
            {
                continue;
            }
            return sgp;
        }
    }

    gocpp::unsafe_pointer rec::raceaddr(golang::runtime::hchan* c)
    {
        return gocpp::unsafe_pointer(& c->buf);
    }

    void racesync(struct hchan* c, struct sudog* sg)
    {
        racerelease(chanbuf(c, 0));
        raceacquireg(sg->g, chanbuf(c, 0));
        racereleaseg(sg->g, chanbuf(c, 0));
        raceacquire(chanbuf(c, 0));
    }

    // Notify the race detector of a send or receive involving buffer entry idx
    // and a channel c or its communicating partner sg.
    // This function handles the special case of c.elemsize==0.
    void racenotify(struct hchan* c, unsigned int idx, struct sudog* sg)
    {
        auto qp = chanbuf(c, idx);
        if(c->elemsize == 0)
        {
            if(sg == nullptr)
            {
                raceacquire(qp);
                racerelease(qp);
            }
            else
            {
                raceacquireg(sg->g, qp);
                racereleaseg(sg->g, qp);
            }
        }
        else
        {
            if(sg == nullptr)
            {
                racereleaseacquire(qp);
            }
            else
            {
                racereleaseacquireg(sg->g, qp);
            }
        }
    }

}

