// generated by GoCpp from file '$(ImportDir)/sort/zsortinterface.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sort/zsortinterface.h"
#include "gocpp/support.h"

#include "golang/sort/sort.h"

namespace golang::sort
{
    void insertionSort(struct Interface data, int a, int b)
    {
        for(auto i = a + 1; i < b; i++)
        {
            for(auto j = i; j > a && Less(gocpp::recv(data), j, j - 1); j--)
            {
                Swap(gocpp::recv(data), j, j - 1);
            }
        }
    }

    void siftDown(struct Interface data, int lo, int hi, int first)
    {
        auto root = lo;
        for(; ; )
        {
            auto child = 2 * root + 1;
            if(child >= hi)
            {
                break;
            }
            if(child + 1 < hi && Less(gocpp::recv(data), first + child, first + child + 1))
            {
                child++;
            }
            if(! Less(gocpp::recv(data), first + root, first + child))
            {
                return;
            }
            Swap(gocpp::recv(data), first + root, first + child);
            root = child;
        }
    }

    void heapSort(struct Interface data, int a, int b)
    {
        auto first = a;
        auto lo = 0;
        auto hi = b - a;
        for(auto i = (hi - 1) / 2; i >= 0; i--)
        {
            siftDown(data, i, hi, first);
        }
        for(auto i = hi - 1; i >= 0; i--)
        {
            Swap(gocpp::recv(data), first, first + i);
            siftDown(data, lo, i, first);
        }
    }

    void pdqsort(struct Interface data, int a, int b, int limit)
    {
        auto maxInsertion = 12;
        auto wasBalanced = true;
        auto wasPartitioned = true;
        for(; ; )
        {
            auto length = b - a;
            if(length <= maxInsertion)
            {
                insertionSort(data, a, b);
                return;
            }
            if(limit == 0)
            {
                heapSort(data, a, b);
                return;
            }
            if(! wasBalanced)
            {
                breakPatterns(data, a, b);
                limit--;
            }
            auto [pivot, hint] = choosePivot(data, a, b);
            if(hint == decreasingHint)
            {
                reverseRange(data, a, b);
                pivot = (b - 1) - (pivot - a);
                hint = increasingHint;
            }
            if(wasBalanced && wasPartitioned && hint == increasingHint)
            {
                if(partialInsertionSort(data, a, b))
                {
                    return;
                }
            }
            if(a > 0 && ! Less(gocpp::recv(data), a - 1, pivot))
            {
                auto mid = partitionEqual(data, a, b, pivot);
                a = mid;
                continue;
            }
            auto [mid, alreadyPartitioned] = partition(data, a, b, pivot);
            wasPartitioned = alreadyPartitioned;
            auto [leftLen, rightLen] = std::tuple{mid - a, b - mid};
            auto balanceThreshold = length / 8;
            if(leftLen < rightLen)
            {
                wasBalanced = leftLen >= balanceThreshold;
                pdqsort(data, a, mid, limit);
                a = mid + 1;
            }
            else
            {
                wasBalanced = rightLen >= balanceThreshold;
                pdqsort(data, mid + 1, b, limit);
                b = mid;
            }
        }
    }

    std::tuple<int, bool> partition(struct Interface data, int a, int b, int pivot)
    {
        int newpivot;
        bool alreadyPartitioned;
        Swap(gocpp::recv(data), a, pivot);
        auto [i, j] = std::tuple{a + 1, b - 1};
        for(; i <= j && Less(gocpp::recv(data), i, a); )
        {
            int newpivot;
            bool alreadyPartitioned;
            i++;
        }
        for(; i <= j && ! Less(gocpp::recv(data), j, a); )
        {
            int newpivot;
            bool alreadyPartitioned;
            j--;
        }
        if(i > j)
        {
            int newpivot;
            bool alreadyPartitioned;
            Swap(gocpp::recv(data), j, a);
            return {j, true};
        }
        Swap(gocpp::recv(data), i, j);
        i++;
        j--;
        for(; ; )
        {
            int newpivot;
            bool alreadyPartitioned;
            for(; i <= j && Less(gocpp::recv(data), i, a); )
            {
                int newpivot;
                bool alreadyPartitioned;
                i++;
            }
            for(; i <= j && ! Less(gocpp::recv(data), j, a); )
            {
                int newpivot;
                bool alreadyPartitioned;
                j--;
            }
            if(i > j)
            {
                int newpivot;
                bool alreadyPartitioned;
                break;
            }
            Swap(gocpp::recv(data), i, j);
            i++;
            j--;
        }
        Swap(gocpp::recv(data), j, a);
        return {j, false};
    }

    int partitionEqual(struct Interface data, int a, int b, int pivot)
    {
        int newpivot;
        Swap(gocpp::recv(data), a, pivot);
        auto [i, j] = std::tuple{a + 1, b - 1};
        for(; ; )
        {
            int newpivot;
            for(; i <= j && ! Less(gocpp::recv(data), a, i); )
            {
                int newpivot;
                i++;
            }
            for(; i <= j && Less(gocpp::recv(data), a, j); )
            {
                int newpivot;
                j--;
            }
            if(i > j)
            {
                int newpivot;
                break;
            }
            Swap(gocpp::recv(data), i, j);
            i++;
            j--;
        }
        return i;
    }

    bool partialInsertionSort(struct Interface data, int a, int b)
    {
        auto maxSteps = 5;
        auto shortestShifting = 50;
        auto i = a + 1;
        for(auto j = 0; j < maxSteps; j++)
        {
            for(; i < b && ! Less(gocpp::recv(data), i, i - 1); )
            {
                i++;
            }
            if(i == b)
            {
                return true;
            }
            if(b - a < shortestShifting)
            {
                return false;
            }
            Swap(gocpp::recv(data), i, i - 1);
            if(i - a >= 2)
            {
                for(auto j = i - 1; j >= 1; j--)
                {
                    if(! Less(gocpp::recv(data), j, j - 1))
                    {
                        break;
                    }
                    Swap(gocpp::recv(data), j, j - 1);
                }
            }
            if(b - i >= 2)
            {
                for(auto j = i + 1; j < b; j++)
                {
                    if(! Less(gocpp::recv(data), j, j - 1))
                    {
                        break;
                    }
                    Swap(gocpp::recv(data), j, j - 1);
                }
            }
        }
        return false;
    }

    void breakPatterns(struct Interface data, int a, int b)
    {
        auto length = b - a;
        if(length >= 8)
        {
            auto random = xorshift(length);
            auto modulus = nextPowerOfTwo(length);
            for(auto idx = a + (length / 4) * 2 - 1; idx <= a + (length / 4) * 2 + 1; idx++)
            {
                auto other = int((unsigned int)(Next(gocpp::recv(random))) & (modulus - 1));
                if(other >= length)
                {
                    other -= length;
                }
                Swap(gocpp::recv(data), idx, a + other);
            }
        }
    }

    std::tuple<int, sortedHint> choosePivot(struct Interface data, int a, int b)
    {
        int pivot;
        sortedHint hint;
        auto shortestNinther = 50;
        auto maxSwaps = 4 * 3;
        auto l = b - a;
        int swaps = {};
        auto i = a + l / 4 * 1;
        auto j = a + l / 4 * 2;
        auto k = a + l / 4 * 3;
        if(l >= 8)
        {
            int pivot;
            sortedHint hint;
            if(l >= shortestNinther)
            {
                int pivot;
                sortedHint hint;
                i = medianAdjacent(data, i, & swaps);
                j = medianAdjacent(data, j, & swaps);
                k = medianAdjacent(data, k, & swaps);
            }
            j = median(data, i, j, k, & swaps);
        }
        //Go switch emulation
        {
            auto condition = swaps;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == maxSwaps) { conditionId = 1; }
            switch(conditionId)
            {
                int pivot;
                sortedHint hint;
                case 0:
                    return {j, increasingHint};
                    break;
                case 1:
                    return {j, decreasingHint};
                    break;
                default:
                    return {j, unknownHint};
                    break;
            }
        }
    }

    std::tuple<int, int> order2(struct Interface data, int a, int b, int* swaps)
    {
        if(Less(gocpp::recv(data), b, a))
        {
            *swaps++;
            return {b, a};
        }
        return {a, b};
    }

    int median(struct Interface data, int a, int b, int c, int* swaps)
    {
        std::tie(a, b) = order2(data, a, b, swaps);
        std::tie(b, c) = order2(data, b, c, swaps);
        std::tie(a, b) = order2(data, a, b, swaps);
        return b;
    }

    int medianAdjacent(struct Interface data, int a, int* swaps)
    {
        return median(data, a - 1, a, a + 1, swaps);
    }

    void reverseRange(struct Interface data, int a, int b)
    {
        auto i = a;
        auto j = b - 1;
        for(; i < j; )
        {
            Swap(gocpp::recv(data), i, j);
            i++;
            j--;
        }
    }

    void swapRange(struct Interface data, int a, int b, int n)
    {
        for(auto i = 0; i < n; i++)
        {
            Swap(gocpp::recv(data), a + i, b + i);
        }
    }

    void stable(struct Interface data, int n)
    {
        auto blockSize = 20;
        auto [a, b] = std::tuple{0, blockSize};
        for(; b <= n; )
        {
            insertionSort(data, a, b);
            a = b;
            b += blockSize;
        }
        insertionSort(data, a, n);
        for(; blockSize < n; )
        {
            std::tie(a, b) = std::tuple{0, 2 * blockSize};
            for(; b <= n; )
            {
                symMerge(data, a, a + blockSize, b);
                a = b;
                b += 2 * blockSize;
            }
            if(auto m = a + blockSize; m < n)
            {
                symMerge(data, a, m, n);
            }
            blockSize *= 2;
        }
    }

    void symMerge(struct Interface data, int a, int m, int b)
    {
        if(m - a == 1)
        {
            auto i = m;
            auto j = b;
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(Less(gocpp::recv(data), h, a))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto k = a; k < i - 1; k++)
            {
                Swap(gocpp::recv(data), k, k + 1);
            }
            return;
        }
        if(b - m == 1)
        {
            auto i = a;
            auto j = m;
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(! Less(gocpp::recv(data), m, h))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto k = m; k > i; k--)
            {
                Swap(gocpp::recv(data), k, k - 1);
            }
            return;
        }
        auto mid = int((unsigned int)(a + b) >> 1);
        auto n = mid + m;
        int start = {};
        int r = {};
        if(m > mid)
        {
            start = n - b;
            r = mid;
        }
        else
        {
            start = a;
            r = m;
        }
        auto p = n - 1;
        for(; start < r; )
        {
            auto c = int((unsigned int)(start + r) >> 1);
            if(! Less(gocpp::recv(data), p - c, c))
            {
                start = c + 1;
            }
            else
            {
                r = c;
            }
        }
        auto end = n - start;
        if(start < m && m < end)
        {
            rotate(data, start, m, end);
        }
        if(a < start && start < mid)
        {
            symMerge(data, a, start, mid);
        }
        if(mid < end && end < b)
        {
            symMerge(data, mid, end, b);
        }
    }

    void rotate(struct Interface data, int a, int m, int b)
    {
        auto i = m - a;
        auto j = b - m;
        for(; i != j; )
        {
            if(i > j)
            {
                swapRange(data, m - i, m, j);
                i -= j;
            }
            else
            {
                swapRange(data, m - i, m + j - i, i);
                j -= i;
            }
        }
        swapRange(data, m - i, m, i);
    }

}

