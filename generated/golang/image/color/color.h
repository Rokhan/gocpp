// generated by GoCpp from file '$(ImportDir)/image/color/color.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/color/color.fwd.h"
#include "gocpp/support.h"

namespace golang::color
{
    struct Color : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        Color(){}
        Color(Color& i) = default;
        Color(const Color& i) = default;
        Color& operator=(Color& i) = default;
        Color& operator=(const Color& i) = default;

        template<typename T>
        Color(T& ref);

        template<typename T>
        Color(const T& ref);

        template<typename T>
        Color(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IColor
        {
            virtual std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> vRGBA() = 0;
        };

        template<typename T, typename StoreT>
        struct ColorImpl : IColor
        {
            explicit ColorImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> vRGBA() override;

            StoreT value;
        };

        std::shared_ptr<IColor> value;
    };

    namespace rec
    {
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(const gocpp::PtrRecv<struct Color, false>& self);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(const gocpp::ObjRecv<struct Color>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct Color& value);
    struct RGBA
    {
        uint8_t R;
        uint8_t G;
        uint8_t B;
        uint8_t A;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value);
    struct RGBA64
    {
        uint16_t R;
        uint16_t G;
        uint16_t B;
        uint16_t A;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value);
    struct NRGBA
    {
        uint8_t R;
        uint8_t G;
        uint8_t B;
        uint8_t A;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value);
    struct NRGBA64
    {
        uint16_t R;
        uint16_t G;
        uint16_t B;
        uint16_t A;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value);
    struct Alpha
    {
        uint8_t A;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value);
    struct Alpha16
    {
        uint16_t A;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value);
    struct Gray
    {
        uint8_t Y;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Gray& value);
    struct Gray16
    {
        uint16_t Y;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value);
    struct Model : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        Model(){}
        Model(Model& i) = default;
        Model(const Model& i) = default;
        Model& operator=(Model& i) = default;
        Model& operator=(const Model& i) = default;

        template<typename T>
        Model(T& ref);

        template<typename T>
        Model(const T& ref);

        template<typename T>
        Model(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IModel
        {
            virtual struct Color vConvert(struct Color c) = 0;
        };

        template<typename T, typename StoreT>
        struct ModelImpl : IModel
        {
            explicit ModelImpl(T* ptr)
            {
                value.reset(ptr);
            }

            struct Color vConvert(struct Color c) override;

            StoreT value;
        };

        std::shared_ptr<IModel> value;
    };

    namespace rec
    {
        struct Color Convert(const gocpp::PtrRecv<struct Model, false>& self, struct Color c);
        struct Color Convert(const gocpp::ObjRecv<struct Model>& self, struct Color c);
    }

    std::ostream& operator<<(std::ostream& os, const struct Model& value);
    struct Model ModelFunc(std::function<struct Color (struct Color _1)> f);
    struct Color rgbaModel(struct Color c);
    struct Color rgba64Model(struct Color c);
    struct Color nrgbaModel(struct Color c);
    struct Color nrgba64Model(struct Color c);
    struct Color alphaModel(struct Color c);
    struct Color alpha16Model(struct Color c);
    struct Color grayModel(struct Color c);
    struct Color gray16Model(struct Color c);
    uint32_t sqDiff(uint32_t x, uint32_t y);
    struct modelFunc
    {
        std::function<struct Color (struct Color _1)> f;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct modelFunc& value);
    extern Model RGBAModel;
    extern Model RGBA64Model;
    extern Model NRGBAModel;
    extern Model NRGBA64Model;
    extern Model AlphaModel;
    extern Model Alpha16Model;
    extern Model GrayModel;
    extern Model Gray16Model;
    extern Gray16 Black;
    extern Gray16 White;
    extern Alpha16 Transparent;
    extern Alpha16 Opaque;

    namespace rec
    {
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct RGBA c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct RGBA64 c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct NRGBA c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct NRGBA64 c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Alpha c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Alpha16 c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Gray c);
        std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Gray16 c);
        struct Color Convert(struct modelFunc* m, struct Color c);
        struct Color Convert(golang::color::Palette p, struct Color c);
        int Index(golang::color::Palette p, struct Color c);
    }
}

