// generated by GoCpp from file '$(ImportDir)/internal/chacha8rand/chacha8.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/chacha8rand/chacha8.h"
#include "gocpp/support.h"

// Package chacha8rand implements a pseudorandom generator
// based on ChaCha8. It is used by both runtime and math/rand/v2
// and must have no dependencies.
namespace golang::chacha8rand
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // block is the chacha8rand block function.
    void block(gocpp::array<uint64_t, 4>* seed, gocpp::array<uint64_t, 32>* blocks, uint32_t counter)
    /* convertBlockStmt, nil block */;

    // A State holds the state for a single random generator.
    // It must be used from one goroutine at a time.
    // If used by multiple goroutines at a time, the goroutines
    // may see the same random values, but the code will not
    // crash or cause out-of-bounds memory accesses.
    
    template<typename T> requires gocpp::GoStruct<T>
    State::operator T()
    {
        T result;
        result.buf = this->buf;
        result.seed = this->seed;
        result.i = this->i;
        result.n = this->n;
        result.c = this->c;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool State::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (seed != ref.seed) return false;
        if (i != ref.i) return false;
        if (n != ref.n) return false;
        if (c != ref.c) return false;
        return true;
    }

    std::ostream& State::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << seed;
        os << " " << i;
        os << " " << n;
        os << " " << c;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct State& value)
    {
        return value.PrintTo(os);
    }

    // Next returns the next random value, along with a boolean
    // indicating whether one was available.
    // If one is not available, the caller should call Refill
    // and then repeat the call to Next.
    //
    // Next is //go:nosplit to allow its use in the runtime
    // with per-m data without holding the per-m lock.
    //go:nosplit
    std::tuple<uint64_t, bool> rec::Next(struct State* s)
    {
        auto i = s->i;
        if(i >= s->n)
        {
            return {0, false};
        }
        s->i = i + 1;
        return {s->buf[i & 31], true};
    }

    // Init seeds the State with the given seed value.
    void rec::Init(struct State* s, gocpp::array<unsigned char, 32> seed)
    {
        rec::Init64(gocpp::recv(s), gocpp::array<uint64_t, 4> {leUint64(seed.make_slice(0 * 8)), leUint64(seed.make_slice(1 * 8)), leUint64(seed.make_slice(2 * 8)), leUint64(seed.make_slice(3 * 8))});
    }

    // Init64 seeds the state with the given seed value.
    void rec::Init64(struct State* s, gocpp::array<uint64_t, 4> seed)
    {
        s->seed = seed;
        block(& s->seed, & s->buf, 0);
        s->c = 0;
        s->i = 0;
        s->n = chunk;
    }

    // Refill refills the state with more random values.
    // After a call to Refill, an immediate call to Next will succeed
    // (unless multiple goroutines are incorrectly sharing a state).
    void rec::Refill(struct State* s)
    {
        s->c += ctrInc;
        if(s->c == ctrMax)
        {
            s->seed[0] = s->buf[len(s->buf) - reseed + 0];
            s->seed[1] = s->buf[len(s->buf) - reseed + 1];
            s->seed[2] = s->buf[len(s->buf) - reseed + 2];
            s->seed[3] = s->buf[len(s->buf) - reseed + 3];
            s->c = 0;
        }
        block(& s->seed, & s->buf, s->c);
        s->i = 0;
        s->n = uint32_t(len(s->buf));
        if(s->c == ctrMax - ctrInc)
        {
            s->n = uint32_t(len(s->buf)) - reseed;
        }
    }

    // Reseed reseeds the state with new random values.
    // After a call to Reseed, any previously returned random values
    // have been erased from the memory of the state and cannot be
    // recovered.
    void rec::Reseed(struct State* s)
    {
        gocpp::array<uint64_t, 4> seed = {};
        for(auto [i, gocpp_ignored] : seed)
        {
            for(; ; )
            {
                auto [x, ok] = rec::Next(gocpp::recv(s));
                if(ok)
                {
                    seed[i] = x;
                    break;
                }
                rec::Refill(gocpp::recv(s));
            }
        }
        rec::Init64(gocpp::recv(s), seed);
    }

    // Marshal marshals the state into a byte slice.
    // Marshal and Unmarshal are functions, not methods,
    // so that they will not be linked into the runtime
    // when it uses the State struct, since the runtime
    // does not need these.
    gocpp::slice<unsigned char> Marshal(struct State* s)
    {
        auto data = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 6 * 8);
        copy(data, "chacha8:"s);
        auto used = (s->c / ctrInc) * chunk + s->i;
        bePutUint64(data.make_slice(1 * 8), uint64_t(used));
        for(auto [i, seed] : s->seed)
        {
            lePutUint64(data.make_slice((2 + i) * 8), seed);
        }
        return data;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    errUnmarshalChaCha8::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool errUnmarshalChaCha8::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& errUnmarshalChaCha8::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct errUnmarshalChaCha8& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(errUnmarshalChaCha8*)
    {
        return "invalid ChaCha8 encoding"s;
    }

    // Unmarshal unmarshals the state from a byte slice.
    struct gocpp::error Unmarshal(struct State* s, gocpp::slice<unsigned char> data)
    {
        if(len(data) != 6 * 8 || std::string(data.make_slice(0, 8)) != "chacha8:"s)
        {
            return new(errUnmarshalChaCha8);
        }
        auto used = beUint64(data.make_slice(1 * 8));
        if(used > (ctrMax / ctrInc) * chunk - reseed)
        {
            return new(errUnmarshalChaCha8);
        }
        for(auto [i, gocpp_ignored] : s->seed)
        {
            s->seed[i] = leUint64(data.make_slice((2 + i) * 8));
        }
        s->c = ctrInc * (uint32_t(used) / chunk);
        block(& s->seed, & s->buf, s->c);
        s->i = uint32_t(used) % chunk;
        s->n = chunk;
        if(s->c == ctrMax - ctrInc)
        {
            s->n = chunk - reseed;
        }
        return nullptr;
    }

    // binary.bigEndian.Uint64, copied to avoid dependency
    uint64_t beUint64(gocpp::slice<unsigned char> b)
    {
        _ = b[7];
        return uint64_t(b[7]) | (uint64_t(b[6]) << 8) | (uint64_t(b[5]) << 16) | (uint64_t(b[4]) << 24) | (uint64_t(b[3]) << 32) | (uint64_t(b[2]) << 40) | (uint64_t(b[1]) << 48) | (uint64_t(b[0]) << 56);
    }

    // binary.bigEndian.PutUint64, copied to avoid dependency
    void bePutUint64(gocpp::slice<unsigned char> b, uint64_t v)
    {
        _ = b[7];
        b[0] = (unsigned char)(v >> 56);
        b[1] = (unsigned char)(v >> 48);
        b[2] = (unsigned char)(v >> 40);
        b[3] = (unsigned char)(v >> 32);
        b[4] = (unsigned char)(v >> 24);
        b[5] = (unsigned char)(v >> 16);
        b[6] = (unsigned char)(v >> 8);
        b[7] = (unsigned char)(v);
    }

    // binary.littleEndian.Uint64, copied to avoid dependency
    uint64_t leUint64(gocpp::slice<unsigned char> b)
    {
        _ = b[7];
        return uint64_t(b[0]) | (uint64_t(b[1]) << 8) | (uint64_t(b[2]) << 16) | (uint64_t(b[3]) << 24) | (uint64_t(b[4]) << 32) | (uint64_t(b[5]) << 40) | (uint64_t(b[6]) << 48) | (uint64_t(b[7]) << 56);
    }

    // binary.littleEndian.PutUint64, copied to avoid dependency
    void lePutUint64(gocpp::slice<unsigned char> b, uint64_t v)
    {
        _ = b[7];
        b[0] = (unsigned char)(v);
        b[1] = (unsigned char)(v >> 8);
        b[2] = (unsigned char)(v >> 16);
        b[3] = (unsigned char)(v >> 24);
        b[4] = (unsigned char)(v >> 32);
        b[5] = (unsigned char)(v >> 40);
        b[6] = (unsigned char)(v >> 48);
        b[7] = (unsigned char)(v >> 56);
    }

}

