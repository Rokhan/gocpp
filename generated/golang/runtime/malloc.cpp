// generated by GoCpp from file '$(ImportDir)/runtime/malloc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/malloc.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goarch/zgoarch_amd64.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/internal/goos/zgoos_windows.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/fastlog2.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/math/math.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mem_windows.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcmark.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/stubs_nonlinux.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/tagptr.h"
#include "golang/runtime/tagptr_64bit.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Store;
    }

    uintptr_t physPageSize;
    uintptr_t physHugePageSize;
    unsigned int physHugePageShift;
    void mallocinit()
    {
        if(class_to_size[_TinySizeClass] != _TinySize)
        {
            go_throw("bad TinySizeClass"s);
        }
        if(heapArenaBitmapWords & (heapArenaBitmapWords - 1) != 0)
        {
            go_throw("heapArenaBitmapWords not a power of 2"s);
        }
        if(physPageSize == 0)
        {
            go_throw("failed to get system page size"s);
        }
        if(physPageSize > maxPhysPageSize)
        {
            print("system page size ("s, physPageSize, ") is larger than maximum page size ("s, maxPhysPageSize, ")\n"s);
            go_throw("bad system page size"s);
        }
        if(physPageSize < minPhysPageSize)
        {
            print("system page size ("s, physPageSize, ") is smaller than minimum page size ("s, minPhysPageSize, ")\n"s);
            go_throw("bad system page size"s);
        }
        if(physPageSize & (physPageSize - 1) != 0)
        {
            print("system page size ("s, physPageSize, ") must be a power of 2\n"s);
            go_throw("bad system page size"s);
        }
        if(physHugePageSize & (physHugePageSize - 1) != 0)
        {
            print("system huge page size ("s, physHugePageSize, ") must be a power of 2\n"s);
            go_throw("bad system huge page size"s);
        }
        if(physHugePageSize > maxPhysHugePageSize)
        {
            physHugePageSize = 0;
        }
        if(physHugePageSize != 0)
        {
            for(; (1 << physHugePageShift) != physHugePageSize; )
            {
                physHugePageShift++;
            }
        }
        if(pagesPerArena % pagesPerSpanRoot != 0)
        {
            print("pagesPerArena ("s, pagesPerArena, ") is not divisible by pagesPerSpanRoot ("s, pagesPerSpanRoot, ")\n"s);
            go_throw("bad pagesPerSpanRoot"s);
        }
        if(pagesPerArena % pagesPerReclaimerChunk != 0)
        {
            print("pagesPerArena ("s, pagesPerArena, ") is not divisible by pagesPerReclaimerChunk ("s, pagesPerReclaimerChunk, ")\n"s);
            go_throw("bad pagesPerReclaimerChunk"s);
        }
        if(goexperiment::AllocHeaders)
        {
            auto minSizeForMallocHeaderIsSizeClass = false;
            for(auto i = 0; i < len(class_to_size); i++)
            {
                if(minSizeForMallocHeader == uintptr_t(class_to_size[i]))
                {
                    minSizeForMallocHeaderIsSizeClass = true;
                    break;
                }
            }
            if(! minSizeForMallocHeaderIsSizeClass)
            {
                go_throw("min size of malloc header is not a size class boundary"s);
            }
            if(minSizeForMallocHeader / goarch::PtrSize > 8 * goarch::PtrSize)
            {
                go_throw("max pointer/scan bitmap size for headerless objects is too large"s);
            }
        }
        if(minTagBits > taggedPointerBits)
        {
            go_throw("taggedPointerbits too small"s);
        }
        rec::init(gocpp::recv(mheap_));
        mcache0 = allocmcache();
        lockInit(& gcBitsArenas.lock, lockRankGcBitsArenas);
        lockInit(& profInsertLock, lockRankProfInsert);
        lockInit(& profBlockLock, lockRankProfBlock);
        lockInit(& profMemActiveLock, lockRankProfMemActive);
        for(auto [i, gocpp_ignored] : profMemFutureLock)
        {
            lockInit(& profMemFutureLock[i], lockRankProfMemFuture);
        }
        lockInit(& globalAlloc.mutex, lockRankGlobalAlloc);
        if(goarch::PtrSize == 8)
        {
            for(auto i = 0x7f; i >= 0; i--)
            {
                uintptr_t p = {};
                //Go switch emulation
                {
                    int conditionId = -1;
                    if(raceenabled) { conditionId = 0; }
                    else if(GOARCH == "arm64"s && GOOS == "ios"s) { conditionId = 1; }
                    else if(GOARCH == "arm64"s) { conditionId = 2; }
                    else if(GOOS == "aix"s) { conditionId = 3; }
                    switch(conditionId)
                    {
                        case 0:
                            p = (uintptr_t(i) << 32) | uintptrMask & (0x00c0 << 32);
                            if(p >= uintptrMask & 0x00e000000000)
                            {
                                continue;
                            }
                            break;
                        case 1:
                            p = (uintptr_t(i) << 40) | uintptrMask & (0x0013 << 28);
                            break;
                        case 2:
                            p = (uintptr_t(i) << 40) | uintptrMask & (0x0040 << 32);
                            break;
                        case 3:
                            if(i == 0)
                            {
                                continue;
                            }
                            p = (uintptr_t(i) << 40) | uintptrMask & (0xa0 << 52);
                            break;
                        default:
                            p = (uintptr_t(i) << 40) | uintptrMask & (0x00c0 << 32);
                            break;
                    }
                }
                auto hintList = & mheap_.arenaHints;
                if((! raceenabled && i > 0x3f) || (raceenabled && i > 0x5f))
                {
                    hintList = & mheap_.userArena.arenaHints;
                }
                auto hint = (arenaHint*)(rec::alloc(gocpp::recv(mheap_.arenaHintAlloc)));
                hint->addr = p;
                std::tie(hint->next, *hintList) = std::tuple{*hintList, hint};
            }
        }
        else
        {
            auto arenaMetaSize = (1 << arenaBits) * gocpp::Sizeof<heapArena>();
            auto meta = uintptr_t(sysReserve(nullptr, arenaMetaSize));
            if(meta != 0)
            {
                rec::init(gocpp::recv(mheap_.heapArenaAlloc), meta, arenaMetaSize, true);
            }
            auto procBrk = sbrk0();
            auto p = firstmoduledata.end;
            if(p < procBrk)
            {
                p = procBrk;
            }
            if(mheap_.heapArenaAlloc.next <= p && p < mheap_.heapArenaAlloc.end)
            {
                p = mheap_.heapArenaAlloc.end;
            }
            p = alignUp(p + (256 << 10), heapArenaBytes);
            auto arenaSizes = gocpp::slice<uintptr_t> {512 << 20, 256 << 20, 128 << 20};
            for(auto [gocpp_ignored, arenaSize] : arenaSizes)
            {
                auto [a, size] = sysReserveAligned(unsafe::Pointer(p), arenaSize, heapArenaBytes);
                if(a != nullptr)
                {
                    rec::init(gocpp::recv(mheap_.arena), uintptr_t(a), size, false);
                    p = mheap_.arena.end;
                    break;
                }
            }
            auto hint = (arenaHint*)(rec::alloc(gocpp::recv(mheap_.arenaHintAlloc)));
            hint->addr = p;
            std::tie(hint->next, mheap_.arenaHints) = std::tuple{mheap_.arenaHints, hint};
            auto userArenaHint = (arenaHint*)(rec::alloc(gocpp::recv(mheap_.arenaHintAlloc)));
            userArenaHint->addr = p;
            std::tie(userArenaHint->next, mheap_.userArena.arenaHints) = std::tuple{mheap_.userArena.arenaHints, userArenaHint};
        }
        rec::Store(gocpp::recv(gcController.memoryLimit), maxInt64);
    }

    std::tuple<unsafe::Pointer, uintptr_t> rec::sysAlloc(struct mheap* h, uintptr_t n, struct arenaHint** hintList, bool go_register)
    {
        unsafe::Pointer v;
        uintptr_t size;
        assertLockHeld(& h->lock);
        n = alignUp(n, heapArenaBytes);
        if(hintList == & h->arenaHints)
        {
            v = rec::alloc(gocpp::recv(h->arena), n, heapArenaBytes, & gcController.heapReleased);
            if(v != nullptr)
            {
                size = n;
                goto mapped;
            }
        }
        for(; *hintList != nullptr; )
        {
            auto hint = *hintList;
            auto p = hint->addr;
            if(hint->down)
            {
                p -= n;
            }
            if(p + n < p)
            {
                v = nullptr;
            }
            else
            if(arenaIndex(p + n - 1) >= (1 << arenaBits))
            {
                v = nullptr;
            }
            else
            {
                v = sysReserve(unsafe::Pointer(p), n);
            }
            if(p == uintptr_t(v))
            {
                if(! hint->down)
                {
                    p += n;
                }
                hint->addr = p;
                size = n;
                break;
            }
            if(v != nullptr)
            {
                sysFreeOS(v, n);
            }
            *hintList = hint->next;
            rec::free(gocpp::recv(h->arenaHintAlloc), unsafe::Pointer(hint));
        }
        if(size == 0)
        {
            if(raceenabled)
            {
                go_throw("too many address space collisions for -race mode"s);
            }
            std::tie(v, size) = sysReserveAligned(nullptr, n, heapArenaBytes);
            if(v == nullptr)
            {
                return {nullptr, 0};
            }
            auto hint = (arenaHint*)(rec::alloc(gocpp::recv(h->arenaHintAlloc)));
            std::tie(hint->addr, hint->down) = std::tuple{uintptr_t(v), true};
            std::tie(hint->next, mheap_.arenaHints) = std::tuple{mheap_.arenaHints, hint};
            hint = (arenaHint*)(rec::alloc(gocpp::recv(h->arenaHintAlloc)));
            hint->addr = uintptr_t(v) + size;
            std::tie(hint->next, mheap_.arenaHints) = std::tuple{mheap_.arenaHints, hint};
        }
        {
            std::string bad = {};
            auto p = uintptr_t(v);
            if(p + size < p)
            {
                bad = "region exceeds uintptr range"s;
            }
            else
            if(arenaIndex(p) >= (1 << arenaBits))
            {
                bad = "base outside usable address space"s;
            }
            else
            if(arenaIndex(p + size - 1) >= (1 << arenaBits))
            {
                bad = "end outside usable address space"s;
            }
            if(bad != ""s)
            {
                print("runtime: memory allocated by OS ["s, hex(p), ", "s, hex(p + size), ") not in usable address space: "s, bad, "\n"s);
                go_throw("memory reservation exceeds address space limit"s);
            }
        }
        if(uintptr_t(v) & (heapArenaBytes - 1) != 0)
        {
            go_throw("misrounded allocation in sysAlloc"s);
        }
        mapped:
        for(auto ri = arenaIndex(uintptr_t(v)); ri <= arenaIndex(uintptr_t(v) + size - 1); ri++)
        {
            auto l2 = h->arenas[rec::l1(gocpp::recv(ri))];
            if(l2 == nullptr)
            {
                l2 = (gocpp::array<heapArena*, 1 << arenaL2Bits>*)(sysAllocOS(gocpp::Sizeof<gocpp::array<*runtime::heapArena, 1048576>>()));
                if(l2 == nullptr)
                {
                    go_throw("out of memory allocating heap arena map"s);
                }
                if(h->arenasHugePages)
                {
                    sysHugePage(unsafe::Pointer(l2), gocpp::Sizeof<gocpp::array<*runtime::heapArena, 1048576>>());
                }
                else
                {
                    sysNoHugePage(unsafe::Pointer(l2), gocpp::Sizeof<gocpp::array<*runtime::heapArena, 1048576>>());
                }
                atomic::StorepNoWB(unsafe::Pointer(& h->arenas[rec::l1(gocpp::recv(ri))]), unsafe::Pointer(l2));
            }
            if(l2[rec::l2(gocpp::recv(ri))] != nullptr)
            {
                go_throw("arena already initialized"s);
            }
            heapArena* r = {};
            r = (heapArena*)(rec::alloc(gocpp::recv(h->heapArenaAlloc), gocpp::Sizeof<heapArena>(), goarch::PtrSize, & memstats.gcMiscSys));
            if(r == nullptr)
            {
                r = (heapArena*)(persistentalloc(gocpp::Sizeof<heapArena>(), goarch::PtrSize, & memstats.gcMiscSys));
                if(r == nullptr)
                {
                    go_throw("out of memory allocating heap arena metadata"s);
                }
            }
            if(go_register)
            {
                if(len(h->allArenas) == cap(h->allArenas))
                {
                    auto size = 2 * uintptr_t(cap(h->allArenas)) * goarch::PtrSize;
                    if(size == 0)
                    {
                        size = physPageSize;
                    }
                    auto newArray = (notInHeap*)(persistentalloc(size, goarch::PtrSize, & memstats.gcMiscSys));
                    if(newArray == nullptr)
                    {
                        go_throw("out of memory allocating allArenas"s);
                    }
                    auto oldSlice = h->allArenas;
                    *(notInHeapSlice*)(unsafe::Pointer(& h->allArenas)) = notInHeapSlice {newArray, len(h->allArenas), int(size / goarch::PtrSize)};
                    copy(h->allArenas, oldSlice);
                }
                h->allArenas = h->allArenas.make_slice(0, len(h->allArenas) + 1);
                h->allArenas[len(h->allArenas) - 1] = ri;
            }
            atomic::StorepNoWB(unsafe::Pointer(& l2[rec::l2(gocpp::recv(ri))]), unsafe::Pointer(r));
            if(false) {
            mapped_continue:
                continue;
            mapped_break:
                break;
            }
        }
        if(raceenabled)
        {
            racemapshadow(v, size);
        }
        return {v, size};
    }

    std::tuple<unsafe::Pointer, uintptr_t> sysReserveAligned(unsafe::Pointer v, uintptr_t size, uintptr_t align)
    {
        auto retries = 0;
        retry:
        auto p = uintptr_t(sysReserve(v, size + align));
        //Go switch emulation
        {
            int conditionId = -1;
            if(p == 0) { conditionId = 0; }
            else if(p & (align - 1) == 0) { conditionId = 1; }
            else if(GOOS == "windows"s) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return {nullptr, 0};
                    break;
                case 1:
                    return {unsafe::Pointer(p), size + align};
                    break;
                case 2:
                    sysFreeOS(unsafe::Pointer(p), size + align);
                    p = alignUp(p, align);
                    auto p2 = sysReserve(unsafe::Pointer(p), size);
                    if(p != uintptr_t(p2))
                    {
                        sysFreeOS(p2, size);
                        if(retries++; retries == 100)
                        {
                            go_throw("failed to allocate aligned heap memory; too many retries"s);
                        }
                        goto retry;
                    }
                    return {p2, size};
                    break;
                default:
                    auto pAligned = alignUp(p, align);
                    sysFreeOS(unsafe::Pointer(p), pAligned - p);
                    auto end = pAligned + size;
                    auto endLen = (p + size + align) - end;
                    if(endLen > 0)
                    {
                        sysFreeOS(unsafe::Pointer(end), endLen);
                    }
                    return {unsafe::Pointer(pAligned), size};
                    break;
            }
        }
    }

    void rec::enableMetadataHugePages(struct mheap* h)
    {
        rec::enableChunkHugePages(gocpp::recv(h->pages));
        lock(& h->lock);
        if(h->arenasHugePages)
        {
            unlock(& h->lock);
            return;
        }
        h->arenasHugePages = true;
        unlock(& h->lock);
        for(auto [i, gocpp_ignored] : h->arenas)
        {
            auto l2 = (gocpp::array<heapArena*, 1 << arenaL2Bits>*)(atomic::Loadp(unsafe::Pointer(& h->arenas[i])));
            if(l2 == nullptr)
            {
                continue;
            }
            sysHugePage(unsafe::Pointer(l2), gocpp::Sizeof<gocpp::array<*runtime::heapArena, 1048576>>());
        }
    }

    uintptr_t zerobase;
    runtime::gclinkptr nextFreeFast(struct mspan* s)
    {
        auto theBit = sys::TrailingZeros64(s->allocCache);
        if(theBit < 64)
        {
            auto result = s->freeindex + uint16_t(theBit);
            if(result < s->nelems)
            {
                auto freeidx = result + 1;
                if(freeidx % 64 == 0 && freeidx != s->nelems)
                {
                    return 0;
                }
                s->allocCache >>= (unsigned int)(theBit + 1);
                s->freeindex = freeidx;
                s->allocCount++;
                return gclinkptr(uintptr_t(result) * s->elemsize + rec::base(gocpp::recv(s)));
            }
        }
        return 0;
    }

    std::tuple<runtime::gclinkptr, struct mspan*, bool> rec::nextFree(struct mcache* c, golang::runtime::spanClass spc)
    {
        runtime::gclinkptr v;
        struct mspan* s;
        bool shouldhelpgc;
        s = c->alloc[spc];
        shouldhelpgc = false;
        auto freeIndex = rec::nextFreeIndex(gocpp::recv(s));
        if(freeIndex == s->nelems)
        {
            if(s->allocCount != s->nelems)
            {
                println("runtime: s.allocCount="s, s->allocCount, "s.nelems="s, s->nelems);
                go_throw("s.allocCount != s.nelems && freeIndex == s.nelems"s);
            }
            rec::refill(gocpp::recv(c), spc);
            shouldhelpgc = true;
            s = c->alloc[spc];
            freeIndex = rec::nextFreeIndex(gocpp::recv(s));
        }
        if(freeIndex >= s->nelems)
        {
            go_throw("freeIndex is not valid"s);
        }
        v = gclinkptr(uintptr_t(freeIndex) * s->elemsize + rec::base(gocpp::recv(s)));
        s->allocCount++;
        if(s->allocCount > s->nelems)
        {
            println("s.allocCount="s, s->allocCount, "s.nelems="s, s->nelems);
            go_throw("s.allocCount > s.nelems"s);
        }
        return {v, s, shouldhelpgc};
    }

    unsafe::Pointer mallocgc(uintptr_t size, golang::runtime::_type* typ, bool needzero)
    {
        if(gcphase == _GCmarktermination)
        {
            go_throw("mallocgc called with gcphase == _GCmarktermination"s);
        }
        if(size == 0)
        {
            return unsafe::Pointer(& zerobase);
        }
        lockRankMayQueueFinalizer();
        auto userSize = size;
        if(asanenabled)
        {
            size += computeRZlog(size);
        }
        if(debug.malloc)
        {
            if(debug.sbrk != 0)
            {
                auto align = uintptr_t(16);
                if(typ != nullptr)
                {
                    if(size & 7 == 0)
                    {
                        align = 8;
                    }
                    else
                    if(size & 3 == 0)
                    {
                        align = 4;
                    }
                    else
                    if(size & 1 == 0)
                    {
                        align = 2;
                    }
                    else
                    {
                        align = 1;
                    }
                }
                return persistentalloc(size, align, & memstats.other_sys);
            }
            if(inittrace.active && inittrace.id == getg()->goid)
            {
                inittrace.allocs += 1;
            }
        }
        auto assistG = deductAssistCredit(size);
        auto mp = acquirem();
        if(mp->mallocing != 0)
        {
            go_throw("malloc deadlock"s);
        }
        if(mp->gsignal == getg())
        {
            go_throw("malloc during signal"s);
        }
        mp->mallocing = 1;
        auto shouldhelpgc = false;
        auto dataSize = userSize;
        auto c = getMCache(mp);
        if(c == nullptr)
        {
            go_throw("mallocgc called without a P or outside bootstrapping"s);
        }
        mspan* span = {};
        runtime::_type** header = {};
        unsafe::Pointer x = {};
        auto noscan = typ == nullptr || typ->PtrBytes == 0;
        auto delayedZeroing = false;
        if(size <= maxSmallSize - mallocHeaderSize)
        {
            if(noscan && size < maxTinySize)
            {
                auto off = c->tinyoffset;
                if(size & 7 == 0)
                {
                    off = alignUp(off, 8);
                }
                else
                if(goarch::PtrSize == 4 && size == 12)
                {
                    off = alignUp(off, 8);
                }
                else
                if(size & 3 == 0)
                {
                    off = alignUp(off, 4);
                }
                else
                if(size & 1 == 0)
                {
                    off = alignUp(off, 2);
                }
                if(off + size <= maxTinySize && c->tiny != 0)
                {
                    x = unsafe::Pointer(c->tiny + off);
                    c->tinyoffset = off + size;
                    c->tinyAllocs++;
                    mp->mallocing = 0;
                    releasem(mp);
                    return x;
                }
                span = c->alloc[tinySpanClass];
                auto v = nextFreeFast(span);
                if(v == 0)
                {
                    std::tie(v, span, shouldhelpgc) = rec::nextFree(gocpp::recv(c), tinySpanClass);
                }
                x = unsafe::Pointer(v);
                (gocpp::array<uint64_t, 2>*)(x)[0] = 0;
                (gocpp::array<uint64_t, 2>*)(x)[1] = 0;
                if(! raceenabled && (size < c->tinyoffset || c->tiny == 0))
                {
                    c->tiny = uintptr_t(x);
                    c->tinyoffset = size;
                }
                size = maxTinySize;
            }
            else
            {
                auto hasHeader = ! noscan && ! heapBitsInSpan(size);
                if(goexperiment::AllocHeaders && hasHeader)
                {
                    size += mallocHeaderSize;
                }
                uint8_t sizeclass = {};
                if(size <= smallSizeMax - 8)
                {
                    sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)];
                }
                else
                {
                    sizeclass = size_to_class128[divRoundUp(size - smallSizeMax, largeSizeDiv)];
                }
                size = uintptr_t(class_to_size[sizeclass]);
                auto spc = makeSpanClass(sizeclass, noscan);
                span = c->alloc[spc];
                auto v = nextFreeFast(span);
                if(v == 0)
                {
                    std::tie(v, span, shouldhelpgc) = rec::nextFree(gocpp::recv(c), spc);
                }
                x = unsafe::Pointer(v);
                if(needzero && span->needzero != 0)
                {
                    memclrNoHeapPointers(x, size);
                }
                if(goexperiment::AllocHeaders && hasHeader)
                {
                    header = (runtime::_type**)(x);
                    x = add(x, mallocHeaderSize);
                    size -= mallocHeaderSize;
                }
            }
        }
        else
        {
            shouldhelpgc = true;
            span = rec::allocLarge(gocpp::recv(c), size, noscan);
            span->freeindex = 1;
            span->allocCount = 1;
            size = span->elemsize;
            x = unsafe::Pointer(rec::base(gocpp::recv(span)));
            if(needzero && span->needzero != 0)
            {
                if(noscan)
                {
                    delayedZeroing = true;
                }
                else
                {
                    memclrNoHeapPointers(x, size);
                }
            }
            if(goexperiment::AllocHeaders && ! noscan)
            {
                header = & span->largeType;
            }
        }
        if(! noscan)
        {
            if(goexperiment::AllocHeaders)
            {
                c->scanAlloc += heapSetType(uintptr_t(x), dataSize, typ, header, span);
            }
            else
            {
                uintptr_t scanSize = {};
                heapBitsSetType(uintptr_t(x), size, dataSize, typ);
                if(dataSize > typ->Size_)
                {
                    if(typ->PtrBytes != 0)
                    {
                        scanSize = dataSize - typ->Size_ + typ->PtrBytes;
                    }
                }
                else
                {
                    scanSize = typ->PtrBytes;
                }
                c->scanAlloc += scanSize;
            }
        }
        publicationBarrier();
        span->freeIndexForScan = span->freeindex;
        if(gcphase != _GCoff)
        {
            gcmarknewobject(span, uintptr_t(x));
        }
        if(raceenabled)
        {
            racemalloc(x, size);
        }
        if(msanenabled)
        {
            msanmalloc(x, size);
        }
        if(asanenabled)
        {
            auto rzBeg = unsafe::Add(x, userSize);
            asanpoison(rzBeg, size - userSize);
            asanunpoison(x, userSize);
        }
        auto fullSize = size;
        if(goexperiment::AllocHeaders)
        {
            fullSize = span->elemsize;
        }
        if(auto rate = MemProfileRate; rate > 0)
        {
            if(rate != 1 && fullSize < c->nextSample)
            {
                c->nextSample -= fullSize;
            }
            else
            {
                profilealloc(mp, x, fullSize);
            }
        }
        mp->mallocing = 0;
        releasem(mp);
        if(delayedZeroing)
        {
            if(! noscan)
            {
                go_throw("delayed zeroing on data that may contain pointers"s);
            }
            if(goexperiment::AllocHeaders && header != nullptr)
            {
                go_throw("unexpected malloc header in delayed zeroing of large object"s);
            }
            memclrNoHeapPointersChunked(size, x);
        }
        if(debug.malloc)
        {
            if(debug.allocfreetrace != 0)
            {
                tracealloc(x, size, typ);
            }
            if(inittrace.active && inittrace.id == getg()->goid)
            {
                inittrace.bytes += uint64_t(fullSize);
            }
        }
        if(assistG != nullptr)
        {
            assistG->gcAssistBytes -= int64_t(fullSize - dataSize);
        }
        if(shouldhelpgc)
        {
            if(auto t = (gocpp::Init<gcTrigger>([=](auto& x) {
                x.kind = gcTriggerHeap;
            })); rec::test(gocpp::recv(t)))
            {
                gcStart(t);
            }
        }
        if(raceenabled && noscan && dataSize < maxTinySize)
        {
            x = add(x, size - dataSize);
        }
        return x;
    }

    struct g* deductAssistCredit(uintptr_t size)
    {
        g* assistG = {};
        if(gcBlackenEnabled != 0)
        {
            assistG = getg();
            if(assistG->m->curg != nullptr)
            {
                assistG = assistG->m->curg;
            }
            assistG->gcAssistBytes -= int64_t(size);
            if(assistG->gcAssistBytes < 0)
            {
                gcAssistAlloc(assistG);
            }
        }
        return assistG;
    }

    void memclrNoHeapPointersChunked(uintptr_t size, unsafe::Pointer x)
    {
        auto v = uintptr_t(x);
        auto chunkBytes = 256 * 1024;
        auto vsize = v + size;
        for(auto voff = v; voff < vsize; voff = voff + chunkBytes)
        {
            if(getg()->preempt)
            {
                goschedguarded();
            }
            auto n = vsize - voff;
            if(n > chunkBytes)
            {
                n = chunkBytes;
            }
            memclrNoHeapPointers(unsafe::Pointer(voff), n);
        }
    }

    unsafe::Pointer newobject(golang::runtime::_type* typ)
    {
        return mallocgc(typ->Size_, typ, true);
    }

    unsafe::Pointer reflect_unsafe_New(golang::runtime::_type* typ)
    {
        return mallocgc(typ->Size_, typ, true);
    }

    unsafe::Pointer reflectlite_unsafe_New(golang::runtime::_type* typ)
    {
        return mallocgc(typ->Size_, typ, true);
    }

    unsafe::Pointer newarray(golang::runtime::_type* typ, int n)
    {
        if(n == 1)
        {
            return mallocgc(typ->Size_, typ, true);
        }
        auto [mem, overflow] = math::MulUintptr(typ->Size_, uintptr_t(n));
        if(overflow || mem > maxAlloc || n < 0)
        {
            gocpp::panic(plainError("runtime: allocation size out of range"s));
        }
        return mallocgc(mem, typ, true);
    }

    unsafe::Pointer reflect_unsafe_NewArray(golang::runtime::_type* typ, int n)
    {
        return newarray(typ, n);
    }

    void profilealloc(struct m* mp, unsafe::Pointer x, uintptr_t size)
    {
        auto c = getMCache(mp);
        if(c == nullptr)
        {
            go_throw("profilealloc called without a P or outside bootstrapping"s);
        }
        c->nextSample = nextSample();
        mProf_Malloc(x, size);
    }

    uintptr_t nextSample()
    {
        if(MemProfileRate == 1)
        {
            return 0;
        }
        if(GOOS == "plan9"s)
        {
            if(auto gp = getg(); gp == gp->m->gsignal)
            {
                return nextSampleNoFP();
            }
        }
        return uintptr_t(fastexprand(MemProfileRate));
    }

    int32_t fastexprand(int mean)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(mean > 0x7000000) { conditionId = 0; }
            else if(mean == 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    mean = 0x7000000;
                    break;
                case 1:
                    return 0;
                    break;
            }
        }
        auto randomBitCount = 26;
        auto q = cheaprandn(1 << randomBitCount) + 1;
        auto qlog = fastlog2(double(q)) - randomBitCount;
        if(qlog > 0)
        {
            qlog = 0;
        }
        auto minusLog2 = - 0.6931471805599453;
        return int32_t(qlog * (minusLog2 * double(mean))) + 1;
    }

    uintptr_t nextSampleNoFP()
    {
        auto rate = MemProfileRate;
        if(rate > 0x3fffffff)
        {
            rate = 0x3fffffff;
        }
        if(rate != 0)
        {
            return uintptr_t(cheaprandn(uint32_t(2 * rate)));
        }
        return 0;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    persistentAlloc::operator T()
    {
        T result;
        result.base = this->base;
        result.off = this->off;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool persistentAlloc::operator==(const T& ref) const
    {
        if (base != ref.base) return false;
        if (off != ref.off) return false;
        return true;
    }

    std::ostream& persistentAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << base;
        os << " " << off;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct persistentAlloc& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 globalAlloc;
    notInHeap* persistentChunks;
    unsafe::Pointer persistentalloc(uintptr_t size, uintptr_t align, golang::runtime::sysMemStat* sysStat)
    {
        notInHeap* p = {};
        systemstack([=]() mutable -> void
        {
            p = persistentalloc1(size, align, sysStat);
        });
        return unsafe::Pointer(p);
    }

    struct notInHeap* persistentalloc1(uintptr_t size, uintptr_t align, golang::runtime::sysMemStat* sysStat)
    {
        auto maxBlock = 64 << 10;
        if(size == 0)
        {
            go_throw("persistentalloc: size == 0"s);
        }
        if(align != 0)
        {
            if(align & (align - 1) != 0)
            {
                go_throw("persistentalloc: align is not a power of 2"s);
            }
            if(align > _PageSize)
            {
                go_throw("persistentalloc: align is too large"s);
            }
        }
        else
        {
            align = 8;
        }
        if(size >= maxBlock)
        {
            return (notInHeap*)(sysAlloc(size, sysStat));
        }
        auto mp = acquirem();
        persistentAlloc* persistent = {};
        if(mp != nullptr && mp->p != 0)
        {
            persistent = & rec::ptr(gocpp::recv(mp->p))->palloc;
        }
        else
        {
            lock(& globalAlloc.mutex);
            persistent = & globalAlloc.persistentAlloc;
        }
        persistent->off = alignUp(persistent->off, align);
        if(persistent->off + size > persistentChunkSize || persistent->base == nullptr)
        {
            persistent->base = (notInHeap*)(sysAlloc(persistentChunkSize, & memstats.other_sys));
            if(persistent->base == nullptr)
            {
                if(persistent == & globalAlloc.persistentAlloc)
                {
                    unlock(& globalAlloc.mutex);
                }
                go_throw("runtime: cannot allocate memory"s);
            }
            for(; ; )
            {
                auto chunks = uintptr_t(unsafe::Pointer(persistentChunks));
                *(uintptr_t*)(unsafe::Pointer(persistent->base)) = chunks;
                if(atomic::Casuintptr((uintptr_t*)(unsafe::Pointer(& persistentChunks)), chunks, uintptr_t(unsafe::Pointer(persistent->base))))
                {
                    break;
                }
            }
            persistent->off = alignUp(goarch::PtrSize, align);
        }
        auto p = rec::add(gocpp::recv(persistent->base), persistent->off);
        persistent->off += size;
        releasem(mp);
        if(persistent == & globalAlloc.persistentAlloc)
        {
            unlock(& globalAlloc.mutex);
        }
        if(sysStat != & memstats.other_sys)
        {
            rec::add(gocpp::recv(sysStat), int64_t(size));
            rec::add(gocpp::recv(memstats.other_sys), - int64_t(size));
        }
        return p;
    }

    bool inPersistentAlloc(uintptr_t p)
    {
        auto chunk = atomic::Loaduintptr((uintptr_t*)(unsafe::Pointer(& persistentChunks)));
        for(; chunk != 0; )
        {
            if(p >= chunk && p < chunk + persistentChunkSize)
            {
                return true;
            }
            chunk = *(uintptr_t*)(unsafe::Pointer(chunk));
        }
        return false;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    linearAlloc::operator T()
    {
        T result;
        result.next = this->next;
        result.mapped = this->mapped;
        result.end = this->end;
        result.mapMemory = this->mapMemory;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool linearAlloc::operator==(const T& ref) const
    {
        if (next != ref.next) return false;
        if (mapped != ref.mapped) return false;
        if (end != ref.end) return false;
        if (mapMemory != ref.mapMemory) return false;
        return true;
    }

    std::ostream& linearAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << " " << mapped;
        os << " " << end;
        os << " " << mapMemory;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct linearAlloc& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct linearAlloc* l, uintptr_t base, uintptr_t size, bool mapMemory)
    {
        if(base + size < base)
        {
            size -= 1;
        }
        std::tie(l->next, l->mapped) = std::tuple{base, base};
        l->end = base + size;
        l->mapMemory = mapMemory;
    }

    unsafe::Pointer rec::alloc(struct linearAlloc* l, uintptr_t size, uintptr_t align, golang::runtime::sysMemStat* sysStat)
    {
        auto p = alignUp(l->next, align);
        if(p + size > l->end)
        {
            return nullptr;
        }
        l->next = p + size;
        if(auto pEnd = alignUp(l->next - 1, physPageSize); pEnd > l->mapped)
        {
            if(l->mapMemory)
            {
                auto n = pEnd - l->mapped;
                sysMap(unsafe::Pointer(l->mapped), n, sysStat);
                sysUsed(unsafe::Pointer(l->mapped), n, n);
            }
            l->mapped = pEnd;
        }
        return unsafe::Pointer(p);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    notInHeap::operator T()
    {
        T result;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool notInHeap::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& notInHeap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct notInHeap& value)
    {
        return value.PrintTo(os);
    }

    struct notInHeap* rec::add(struct notInHeap* p, uintptr_t bytes)
    {
        return (notInHeap*)(unsafe::Pointer(uintptr_t(unsafe::Pointer(p)) + bytes));
    }

    uintptr_t computeRZlog(uintptr_t userSize)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(userSize <= (64 - 16)) { conditionId = 0; }
            else if(userSize <= (128 - 32)) { conditionId = 1; }
            else if(userSize <= (512 - 64)) { conditionId = 2; }
            else if(userSize <= (4096 - 128)) { conditionId = 3; }
            else if(userSize <= (1 << 14) - 256) { conditionId = 4; }
            else if(userSize <= (1 << 15) - 512) { conditionId = 5; }
            else if(userSize <= (1 << 16) - 1024) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    return 16 << 0;
                    break;
                case 1:
                    return 16 << 1;
                    break;
                case 2:
                    return 16 << 2;
                    break;
                case 3:
                    return 16 << 3;
                    break;
                case 4:
                    return 16 << 4;
                    break;
                case 5:
                    return 16 << 5;
                    break;
                case 6:
                    return 16 << 6;
                    break;
                default:
                    return 16 << 7;
                    break;
            }
        }
    }

}

