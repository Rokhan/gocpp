// generated by GoCpp from file '$(ImportDir)/runtime/mbitmap_allocheaders.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mbitmap_allocheaders.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"

namespace golang::runtime
{
    bool heapBitsInSpan(uintptr_t userSize);
    struct heapArenaPtrScalar
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heapArenaPtrScalar& value);
    struct typePointers
    {
        uintptr_t elem;
        uintptr_t addr;
        uintptr_t mask;
        _type* typ;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct typePointers& value);
    void bulkBarrierPreWrite(uintptr_t dst, uintptr_t src, uintptr_t size, struct abi::Type* typ);
    void bulkBarrierPreWriteSrcOnly(uintptr_t dst, uintptr_t src, uintptr_t size, struct abi::Type* typ);
    uintptr_t bswapIfBigEndian(uintptr_t x);
    struct writeUserArenaHeapBits
    {
        uintptr_t offset;
        uintptr_t mask;
        uintptr_t valid;
        uintptr_t low;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct writeUserArenaHeapBits& value);
    gocpp::slice<uintptr_t> heapBitsSlice(uintptr_t spanBase, uintptr_t spanSize);
    void heapBitsSetType(uintptr_t x, uintptr_t size, uintptr_t dataSize, struct _type* typ);
    uintptr_t heapSetType(uintptr_t x, uintptr_t dataSize, struct _type* typ, struct _type** header, struct mspan* span);
    void doubleCheckHeapPointers(uintptr_t x, uintptr_t dataSize, struct _type* typ, struct _type** header, struct mspan* span);
    void doubleCheckHeapPointersInterior(uintptr_t x, uintptr_t interior, uintptr_t size, uintptr_t dataSize, struct _type* typ, struct _type** header, struct mspan* span);
    void doubleCheckTypePointersOfType(struct mspan* s, struct _type* typ, uintptr_t addr, uintptr_t size);
    void dumpTypePointers(struct typePointers tp);
    gocpp::slice<unsigned char> getgcmask(go_any ep);
    void userArenaHeapBitsSetType(struct _type* typ, unsafe::Pointer ptr, struct mspan* s);
    void writeHeapBitsForAddr();
    struct heapBits
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heapBits& value);
    struct heapBits heapBitsForAddr(uintptr_t addr, uintptr_t size);

    namespace rec
    {
        struct typePointers typePointersOf(struct mspan* span, uintptr_t addr, uintptr_t size);
        struct typePointers typePointersOfUnchecked(struct mspan* span, uintptr_t addr);
        struct typePointers typePointersOfType(struct mspan* span, struct abi::Type* typ, uintptr_t addr);
        std::tuple<struct typePointers, uintptr_t> nextFast(struct typePointers tp);
        std::tuple<struct typePointers, uintptr_t> next(struct typePointers tp, uintptr_t limit);
        struct typePointers fastForward(struct typePointers tp, uintptr_t n, uintptr_t limit);
        uintptr_t objBase(struct mspan* span, uintptr_t addr);
        void initHeapBits(struct mspan* s, bool forceClear);
        struct writeUserArenaHeapBits writeUserArenaHeapBits(struct mspan* s, uintptr_t addr);
        struct writeUserArenaHeapBits write(struct writeUserArenaHeapBits h, struct mspan* s, uintptr_t bits, uintptr_t valid);
        struct writeUserArenaHeapBits pad(struct writeUserArenaHeapBits h, struct mspan* s, uintptr_t size);
        void flush(struct writeUserArenaHeapBits h, struct mspan* s, uintptr_t addr, uintptr_t size);
        gocpp::slice<uintptr_t> heapBits(struct mspan* span);
        uintptr_t heapBitsSmallForAddr(struct mspan* span, uintptr_t addr);
        uintptr_t writeHeapBitsSmall(struct mspan* span, uintptr_t x, uintptr_t dataSize, struct _type* typ);
        std::tuple<struct heapBits, uintptr_t> next(struct heapBits h);
        std::tuple<struct heapBits, uintptr_t> nextFast(struct heapBits h);
    }
}

