// generated by GoCpp from file '$(ImportDir)/runtime/error.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/error.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace bytealg::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
    }

    
    template<typename T>
    Error::Error(T& ref)
    {
        value.reset(new ErrorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Error::Error(const T& ref)
    {
        value.reset(new ErrorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Error::Error(T* ptr)
    {
        value.reset(new ErrorImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Error::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Error::ErrorImpl<T, StoreT>::vRuntimeError()
    {
        return rec::RuntimeError(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        void RuntimeError(const gocpp::PtrRecv<struct Error, false>& self)
        {
            return self.ptr->value->vRuntimeError();
        }

        void RuntimeError(const gocpp::ObjRecv<struct Error>& self)
        {
            return self.obj.value->vRuntimeError();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Error& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    TypeAssertionError::operator T()
    {
        T result;
        result._interface = this->_interface;
        result.concrete = this->concrete;
        result.asserted = this->asserted;
        result.missingMethod = this->missingMethod;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool TypeAssertionError::operator==(const T& ref) const
    {
        if (_interface != ref._interface) return false;
        if (concrete != ref.concrete) return false;
        if (asserted != ref.asserted) return false;
        if (missingMethod != ref.missingMethod) return false;
        return true;
    }

    std::ostream& TypeAssertionError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _interface;
        os << " " << concrete;
        os << " " << asserted;
        os << " " << missingMethod;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct TypeAssertionError& value)
    {
        return value.PrintTo(os);
    }

    void rec::RuntimeError(TypeAssertionError*)
    {
    }

    std::string rec::Error(struct TypeAssertionError* e)
    {
        auto inter = "interface";
        if(e->_interface != nullptr)
        {
            inter = rec::string(gocpp::recv(toRType(e->_interface)));
        }
        auto as = rec::string(gocpp::recv(toRType(e->asserted)));
        if(e->concrete == nullptr)
        {
            return "interface conversion: " + inter + " is nil, not " + as;
        }
        auto cs = rec::string(gocpp::recv(toRType(e->concrete)));
        if(e->missingMethod == "")
        {
            auto msg = "interface conversion: " + inter + " is " + cs + ", not " + as;
            if(cs == as)
            {
                if(rec::pkgpath(gocpp::recv(toRType(e->concrete))) != rec::pkgpath(gocpp::recv(toRType(e->asserted))))
                {
                    msg += " (types from different packages)";
                }
                else
                {
                    msg += " (types from different scopes)";
                }
            }
            return msg;
        }
        return "interface conversion: " + cs + " is not " + as + ": missing method " + e->missingMethod;
    }

    gocpp::slice<unsigned char> itoa(gocpp::slice<unsigned char> buf, uint64_t val)
    {
        auto i = len(buf) - 1;
        for(; val >= 10; )
        {
            buf[i] = unsigned char(val % 10 + '0');
            i--;
            val /= 10;
        }
        buf[i] = unsigned char(val + '0');
        return buf.make_slice(i);
    }

    void rec::RuntimeError(golang::runtime::errorString e)
    {
    }

    std::string rec::Error(golang::runtime::errorString e)
    {
        return "runtime error: " + string(e);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    errorAddressString::operator T()
    {
        T result;
        result.msg = this->msg;
        result.addr = this->addr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool errorAddressString::operator==(const T& ref) const
    {
        if (msg != ref.msg) return false;
        if (addr != ref.addr) return false;
        return true;
    }

    std::ostream& errorAddressString::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << msg;
        os << " " << addr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct errorAddressString& value)
    {
        return value.PrintTo(os);
    }

    void rec::RuntimeError(struct errorAddressString e)
    {
    }

    std::string rec::Error(struct errorAddressString e)
    {
        return "runtime error: " + e.msg;
    }

    uintptr_t rec::Addr(struct errorAddressString e)
    {
        return e.addr;
    }

    void rec::RuntimeError(golang::runtime::plainError e)
    {
    }

    std::string rec::Error(golang::runtime::plainError e)
    {
        return string(e);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    boundsError::operator T()
    {
        T result;
        result.x = this->x;
        result.y = this->y;
        result.go_signed = this->go_signed;
        result.code = this->code;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool boundsError::operator==(const T& ref) const
    {
        if (x != ref.x) return false;
        if (y != ref.y) return false;
        if (go_signed != ref.go_signed) return false;
        if (code != ref.code) return false;
        return true;
    }

    std::ostream& boundsError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << x;
        os << " " << y;
        os << " " << go_signed;
        os << " " << code;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct boundsError& value)
    {
        return value.PrintTo(os);
    }

    gocpp::array_base<std::string> boundsErrorFmts = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.boundsIndex = "index out of range [%x] with length %y"; x.boundsSliceAlen = "slice bounds out of range [:%x] with length %y"; x.boundsSliceAcap = "slice bounds out of range [:%x] with capacity %y"; x.boundsSliceB = "slice bounds out of range [%x:%y]"; x.boundsSlice3Alen = "slice bounds out of range [::%x] with length %y"; x.boundsSlice3Acap = "slice bounds out of range [::%x] with capacity %y"; x.boundsSlice3B = "slice bounds out of range [:%x:%y]"; x.boundsSlice3C = "slice bounds out of range [%x:%y:]"; x.boundsConvert = "cannot convert slice with length %y to array or pointer to array with length %x"; });
    gocpp::array_base<std::string> boundsNegErrorFmts = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.boundsIndex = "index out of range [%x]"; x.boundsSliceAlen = "slice bounds out of range [:%x]"; x.boundsSliceAcap = "slice bounds out of range [:%x]"; x.boundsSliceB = "slice bounds out of range [%x:]"; x.boundsSlice3Alen = "slice bounds out of range [::%x]"; x.boundsSlice3Acap = "slice bounds out of range [::%x]"; x.boundsSlice3B = "slice bounds out of range [:%x:]"; x.boundsSlice3C = "slice bounds out of range [%x::]"; });
    void rec::RuntimeError(struct boundsError e)
    {
    }

    gocpp::slice<unsigned char> appendIntStr(gocpp::slice<unsigned char> b, int64_t v, bool go_signed)
    {
        if(go_signed && v < 0)
        {
            b = append(b, '-');
            v = - v;
        }
        gocpp::array<unsigned char, 20> buf = {};
        b = append(b, itoa(buf.make_slice(0, ), uint64_t(v)));
        return b;
    }

    std::string rec::Error(struct boundsError e)
    {
        auto fmt = boundsErrorFmts[e.code];
        if(e.go_signed && e.x < 0)
        {
            fmt = boundsNegErrorFmts[e.code];
        }
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 100);
        b = append(b, "runtime error: ");
        for(auto i = 0; i < len(fmt); i++)
        {
            auto c = fmt[i];
            if(c != '%')
            {
                b = append(b, c);
                continue;
            }
            i++;
            //Go switch emulation
            {
                auto condition = fmt[i];
                int conditionId = -1;
                if(condition == 'x') { conditionId = 0; }
                else if(condition == 'y') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        b = appendIntStr(b, e.x, e.go_signed);
                        break;
                    case 1:
                        b = appendIntStr(b, int64_t(e.y), true);
                        break;
                }
            }
        }
        return string(b);
    }

    
    template<typename T>
    stringer::stringer(T& ref)
    {
        value.reset(new stringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    stringer::stringer(const T& ref)
    {
        value.reset(new stringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    stringer::stringer(T* ptr)
    {
        value.reset(new stringerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& stringer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string stringer::stringerImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::string String(const gocpp::PtrRecv<struct stringer, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<struct stringer>& self)
        {
            return self.obj.value->vString();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct stringer& value)
    {
        return value.PrintTo(os);
    }

    void printany(go_any i)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_0 = gocpp::type_info(i);
            int conditionId = -1;
            if(gocpp_id_0 == typeid(untyped nil)) { conditionId = 0; }
            else if(gocpp_id_0 == typeid(bool)) { conditionId = 1; }
            else if(gocpp_id_0 == typeid(int)) { conditionId = 2; }
            else if(gocpp_id_0 == typeid(int8_t)) { conditionId = 3; }
            else if(gocpp_id_0 == typeid(int16_t)) { conditionId = 4; }
            else if(gocpp_id_0 == typeid(int32_t)) { conditionId = 5; }
            else if(gocpp_id_0 == typeid(int64_t)) { conditionId = 6; }
            else if(gocpp_id_0 == typeid(unsigned int)) { conditionId = 7; }
            else if(gocpp_id_0 == typeid(uint8_t)) { conditionId = 8; }
            else if(gocpp_id_0 == typeid(uint16_t)) { conditionId = 9; }
            else if(gocpp_id_0 == typeid(uint32_t)) { conditionId = 10; }
            else if(gocpp_id_0 == typeid(uint64_t)) { conditionId = 11; }
            else if(gocpp_id_0 == typeid(uintptr_t)) { conditionId = 12; }
            else if(gocpp_id_0 == typeid(float)) { conditionId = 13; }
            else if(gocpp_id_0 == typeid(double)) { conditionId = 14; }
            else if(gocpp_id_0 == typeid(gocpp::complex64)) { conditionId = 15; }
            else if(gocpp_id_0 == typeid(gocpp::complex128)) { conditionId = 16; }
            else if(gocpp_id_0 == typeid(std::string)) { conditionId = 17; }
            switch(conditionId)
            {
                case 0:
                {
                    untyped nil v = gocpp::any_cast<untyped nil>(i);
                    print("nil");
                    break;
                }
                case 1:
                {
                    bool v = gocpp::any_cast<bool>(i);
                    print(v);
                    break;
                }
                case 2:
                {
                    int v = gocpp::any_cast<int>(i);
                    print(v);
                    break;
                }
                case 3:
                {
                    int8_t v = gocpp::any_cast<int8_t>(i);
                    print(v);
                    break;
                }
                case 4:
                {
                    int16_t v = gocpp::any_cast<int16_t>(i);
                    print(v);
                    break;
                }
                case 5:
                {
                    int32_t v = gocpp::any_cast<int32_t>(i);
                    print(v);
                    break;
                }
                case 6:
                {
                    int64_t v = gocpp::any_cast<int64_t>(i);
                    print(v);
                    break;
                }
                case 7:
                {
                    unsigned int v = gocpp::any_cast<unsigned int>(i);
                    print(v);
                    break;
                }
                case 8:
                {
                    uint8_t v = gocpp::any_cast<uint8_t>(i);
                    print(v);
                    break;
                }
                case 9:
                {
                    uint16_t v = gocpp::any_cast<uint16_t>(i);
                    print(v);
                    break;
                }
                case 10:
                {
                    uint32_t v = gocpp::any_cast<uint32_t>(i);
                    print(v);
                    break;
                }
                case 11:
                {
                    uint64_t v = gocpp::any_cast<uint64_t>(i);
                    print(v);
                    break;
                }
                case 12:
                {
                    uintptr_t v = gocpp::any_cast<uintptr_t>(i);
                    print(v);
                    break;
                }
                case 13:
                {
                    float v = gocpp::any_cast<float>(i);
                    print(v);
                    break;
                }
                case 14:
                {
                    double v = gocpp::any_cast<double>(i);
                    print(v);
                    break;
                }
                case 15:
                {
                    gocpp::complex64 v = gocpp::any_cast<gocpp::complex64>(i);
                    print(v);
                    break;
                }
                case 16:
                {
                    gocpp::complex128 v = gocpp::any_cast<gocpp::complex128>(i);
                    print(v);
                    break;
                }
                case 17:
                {
                    std::string v = gocpp::any_cast<std::string>(i);
                    print(v);
                    break;
                }
                default:
                {
                    auto v = i;
                    printanycustomtype(i);
                    break;
                }
            }
        }
    }

    void printanycustomtype(go_any i)
    {
        auto eface = efaceOf(& i);
        auto typestring = rec::string(gocpp::recv(toRType(eface->_type)));
        //Go switch emulation
        {
            auto condition = eface->_type->Kind_;
            int conditionId = -1;
            if(condition == kindString) { conditionId = 0; }
            else if(condition == kindBool) { conditionId = 1; }
            else if(condition == kindInt) { conditionId = 2; }
            else if(condition == kindInt8) { conditionId = 3; }
            else if(condition == kindInt16) { conditionId = 4; }
            else if(condition == kindInt32) { conditionId = 5; }
            else if(condition == kindInt64) { conditionId = 6; }
            else if(condition == kindUint) { conditionId = 7; }
            else if(condition == kindUint8) { conditionId = 8; }
            else if(condition == kindUint16) { conditionId = 9; }
            else if(condition == kindUint32) { conditionId = 10; }
            else if(condition == kindUint64) { conditionId = 11; }
            else if(condition == kindUintptr) { conditionId = 12; }
            else if(condition == kindFloat32) { conditionId = 13; }
            else if(condition == kindFloat64) { conditionId = 14; }
            else if(condition == kindComplex64) { conditionId = 15; }
            else if(condition == kindComplex128) { conditionId = 16; }
            switch(conditionId)
            {
                case 0:
                    print(typestring, "("", *(std::string*)(eface->data), "")");
                    break;
                case 1:
                    print(typestring, "(", *(bool*)(eface->data), ")");
                    break;
                case 2:
                    print(typestring, "(", *(int*)(eface->data), ")");
                    break;
                case 3:
                    print(typestring, "(", *(int8_t*)(eface->data), ")");
                    break;
                case 4:
                    print(typestring, "(", *(int16_t*)(eface->data), ")");
                    break;
                case 5:
                    print(typestring, "(", *(int32_t*)(eface->data), ")");
                    break;
                case 6:
                    print(typestring, "(", *(int64_t*)(eface->data), ")");
                    break;
                case 7:
                    print(typestring, "(", *(unsigned int*)(eface->data), ")");
                    break;
                case 8:
                    print(typestring, "(", *(uint8_t*)(eface->data), ")");
                    break;
                case 9:
                    print(typestring, "(", *(uint16_t*)(eface->data), ")");
                    break;
                case 10:
                    print(typestring, "(", *(uint32_t*)(eface->data), ")");
                    break;
                case 11:
                    print(typestring, "(", *(uint64_t*)(eface->data), ")");
                    break;
                case 12:
                    print(typestring, "(", *(uintptr_t*)(eface->data), ")");
                    break;
                case 13:
                    print(typestring, "(", *(float*)(eface->data), ")");
                    break;
                case 14:
                    print(typestring, "(", *(double*)(eface->data), ")");
                    break;
                case 15:
                    print(typestring, *(gocpp::complex64*)(eface->data));
                    break;
                case 16:
                    print(typestring, *(gocpp::complex128*)(eface->data));
                    break;
                default:
                    print("(", typestring, ") ", eface->data);
                    break;
            }
        }
    }

    void panicwrap()
    {
        auto pc = getcallerpc();
        auto name = funcNameForPrint(funcname(findfunc(pc)));
        auto i = bytealg::IndexByteString(name, '(');
        if(i < 0)
        {
            go_throw("panicwrap: no ( in " + name);
        }
        auto pkg = name.make_slice(0, i - 1);
        if(i + 2 >= len(name) || name.make_slice(i - 1, i + 2) != ".(*")
        {
            go_throw("panicwrap: unexpected string after package name: " + name);
        }
        name = name.make_slice(i + 2);
        i = bytealg::IndexByteString(name, ')');
        if(i < 0)
        {
            go_throw("panicwrap: no ) in " + name);
        }
        if(i + 2 >= len(name) || name.make_slice(i, i + 2) != ").")
        {
            go_throw("panicwrap: unexpected string after type name: " + name);
        }
        auto typ = name.make_slice(0, i);
        auto meth = name.make_slice(i + 2);
        gocpp::panic(plainError("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"));
    }

}

