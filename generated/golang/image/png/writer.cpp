// generated by GoCpp from file '$(ImportDir)/image/png/writer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/png/writer.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/compress/zlib/writer.h"
#include "golang/encoding/binary/binary.h"
#include "golang/hash/crc32/crc32.h"
#include "golang/hash/hash.h"
#include "golang/image/color/color.h"
#include "golang/image/geom.h"
#include "golang/image/image.h"
#include "golang/image/png/paeth.h"
#include "golang/image/png/reader.h"
#include "golang/io/io.h"
#include "golang/strconv/itoa.h"

namespace golang::png
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Encoder::operator T()
    {
        T result;
        result.CompressionLevel = this->CompressionLevel;
        result.BufferPool = this->BufferPool;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Encoder::operator==(const T& ref) const
    {
        if (CompressionLevel != ref.CompressionLevel) return false;
        if (BufferPool != ref.BufferPool) return false;
        return true;
    }

    std::ostream& Encoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << CompressionLevel;
        os << " " << BufferPool;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Encoder& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    EncoderBufferPool::EncoderBufferPool(T& ref)
    {
        value.reset(new EncoderBufferPoolImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    EncoderBufferPool::EncoderBufferPool(const T& ref)
    {
        value.reset(new EncoderBufferPoolImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    EncoderBufferPool::EncoderBufferPool(T* ptr)
    {
        value.reset(new EncoderBufferPoolImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& EncoderBufferPool::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct EncoderBuffer* EncoderBufferPool::EncoderBufferPoolImpl<T, StoreT>::vGet()
    {
        return Get(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void EncoderBufferPool::EncoderBufferPoolImpl<T, StoreT>::vPut(EncoderBuffer*)
    {
        return Put(gocpp::PtrRecv<T, false>(value.get()));
    }

    struct EncoderBuffer* Get(const gocpp::PtrRecv<EncoderBufferPool, false>& self)
    {
        return self.ptr->value->vGet();
    }

    struct EncoderBuffer* Get(const gocpp::ObjRecv<EncoderBufferPool>& self)
    {
        return self.obj.value->vGet();
    }

    void Put(const gocpp::PtrRecv<EncoderBufferPool, false>& self, EncoderBuffer*)
    {
        return self.ptr->value->vPut();
    }

    void Put(const gocpp::ObjRecv<EncoderBufferPool>& self, EncoderBuffer*)
    {
        return self.obj.value->vPut();
    }

    std::ostream& operator<<(std::ostream& os, const struct EncoderBufferPool& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    encoder::operator T()
    {
        T result;
        result.enc = this->enc;
        result.w = this->w;
        result.m = this->m;
        result.cb = this->cb;
        result.err = this->err;
        result.header = this->header;
        result.footer = this->footer;
        result.tmp = this->tmp;
        result.cr = this->cr;
        result.pr = this->pr;
        result.zw = this->zw;
        result.zwLevel = this->zwLevel;
        result.bw = this->bw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool encoder::operator==(const T& ref) const
    {
        if (enc != ref.enc) return false;
        if (w != ref.w) return false;
        if (m != ref.m) return false;
        if (cb != ref.cb) return false;
        if (err != ref.err) return false;
        if (header != ref.header) return false;
        if (footer != ref.footer) return false;
        if (tmp != ref.tmp) return false;
        if (cr != ref.cr) return false;
        if (pr != ref.pr) return false;
        if (zw != ref.zw) return false;
        if (zwLevel != ref.zwLevel) return false;
        if (bw != ref.bw) return false;
        return true;
    }

    std::ostream& encoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << enc;
        os << " " << w;
        os << " " << m;
        os << " " << cb;
        os << " " << err;
        os << " " << header;
        os << " " << footer;
        os << " " << tmp;
        os << " " << cr;
        os << " " << pr;
        os << " " << zw;
        os << " " << zwLevel;
        os << " " << bw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct encoder& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    opaquer::opaquer(T& ref)
    {
        value.reset(new opaquerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    opaquer::opaquer(const T& ref)
    {
        value.reset(new opaquerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    opaquer::opaquer(T* ptr)
    {
        value.reset(new opaquerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& opaquer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    bool opaquer::opaquerImpl<T, StoreT>::vOpaque()
    {
        return Opaque(gocpp::PtrRecv<T, false>(value.get()));
    }

    bool Opaque(const gocpp::PtrRecv<opaquer, false>& self)
    {
        return self.ptr->value->vOpaque();
    }

    bool Opaque(const gocpp::ObjRecv<opaquer>& self)
    {
        return self.obj.value->vOpaque();
    }

    std::ostream& operator<<(std::ostream& os, const struct opaquer& value)
    {
        return value.PrintTo(os);
    }

    bool opaque(struct image::Image m)
    {
        if(auto [o, ok] = gocpp::getValue<opaquer>(m); ok)
        {
            return Opaque(gocpp::recv(o));
        }
        auto b = Bounds(gocpp::recv(m));
        for(auto y = b.Min.Y; y < b.Max.Y; y++)
        {
            for(auto x = b.Min.X; x < b.Max.X; x++)
            {
                auto [gocpp_id_3, gocpp_id_4, gocpp_id_5, a] = RGBA(gocpp::recv(At(gocpp::recv(m), x, y)));
                if(a != 0xffff)
                {
                    return false;
                }
            }
        }
        return true;
    }

    int abs8(uint8_t d)
    {
        if(d < 128)
        {
            return int(d);
        }
        return 256 - int(d);
    }

    void writeChunk(struct encoder* e, gocpp::slice<unsigned char> b, std::string name)
    {
        if(e->err != nullptr)
        {
            return;
        }
        auto n = uint32_t(len(b));
        if(int(n) != len(b))
        {
            e->err = UnsupportedError(name + " chunk is too large: " + strconv::Itoa(len(b)));
            return;
        }
        PutUint32(gocpp::recv(binary::BigEndian), e->header.make_slice(0, 4), n);
        e->header[4] = name[0];
        e->header[5] = name[1];
        e->header[6] = name[2];
        e->header[7] = name[3];
        auto crc = crc32::NewIEEE();
        Write(gocpp::recv(crc), e->header.make_slice(4, 8));
        Write(gocpp::recv(crc), b);
        PutUint32(gocpp::recv(binary::BigEndian), e->footer.make_slice(0, 4), Sum32(gocpp::recv(crc)));
        std::tie(gocpp_id_6, e->err) = Write(gocpp::recv(e->w), e->header.make_slice(0, 8));
        if(e->err != nullptr)
        {
            return;
        }
        std::tie(gocpp_id_7, e->err) = Write(gocpp::recv(e->w), b);
        if(e->err != nullptr)
        {
            return;
        }
        std::tie(gocpp_id_8, e->err) = Write(gocpp::recv(e->w), e->footer.make_slice(0, 4));
    }

    void writeIHDR(struct encoder* e)
    {
        auto b = Bounds(gocpp::recv(e->m));
        PutUint32(gocpp::recv(binary::BigEndian), e->tmp.make_slice(0, 4), uint32_t(Dx(gocpp::recv(b))));
        PutUint32(gocpp::recv(binary::BigEndian), e->tmp.make_slice(4, 8), uint32_t(Dy(gocpp::recv(b))));
        //Go switch emulation
        {
            auto condition = e->cb;
            int conditionId = -1;
            if(condition == cbG8) { conditionId = 0; }
            else if(condition == cbTC8) { conditionId = 1; }
            else if(condition == cbP8) { conditionId = 2; }
            else if(condition == cbP4) { conditionId = 3; }
            else if(condition == cbP2) { conditionId = 4; }
            else if(condition == cbP1) { conditionId = 5; }
            else if(condition == cbTCA8) { conditionId = 6; }
            else if(condition == cbG16) { conditionId = 7; }
            else if(condition == cbTC16) { conditionId = 8; }
            else if(condition == cbTCA16) { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                    e->tmp[8] = 8;
                    e->tmp[9] = ctGrayscale;
                    break;
                case 1:
                    e->tmp[8] = 8;
                    e->tmp[9] = ctTrueColor;
                    break;
                case 2:
                    e->tmp[8] = 8;
                    e->tmp[9] = ctPaletted;
                    break;
                case 3:
                    e->tmp[8] = 4;
                    e->tmp[9] = ctPaletted;
                    break;
                case 4:
                    e->tmp[8] = 2;
                    e->tmp[9] = ctPaletted;
                    break;
                case 5:
                    e->tmp[8] = 1;
                    e->tmp[9] = ctPaletted;
                    break;
                case 6:
                    e->tmp[8] = 8;
                    e->tmp[9] = ctTrueColorAlpha;
                    break;
                case 7:
                    e->tmp[8] = 16;
                    e->tmp[9] = ctGrayscale;
                    break;
                case 8:
                    e->tmp[8] = 16;
                    e->tmp[9] = ctTrueColor;
                    break;
                case 9:
                    e->tmp[8] = 16;
                    e->tmp[9] = ctTrueColorAlpha;
                    break;
            }
        }
        e->tmp[10] = 0;
        e->tmp[11] = 0;
        e->tmp[12] = 0;
        writeChunk(gocpp::recv(e), e->tmp.make_slice(0, 13), "IHDR");
    }

    void writePLTEAndTRNS(struct encoder* e, color::Palette p)
    {
        if(len(p) < 1 || len(p) > 256)
        {
            e->err = FormatError("bad palette length: " + strconv::Itoa(len(p)));
            return;
        }
        auto last = - 1;
        for(auto [i, c] : p)
        {
            auto c1 = gocpp::getValue<color::NRGBA>(Convert(gocpp::recv(color::NRGBAModel), c));
            e->tmp[3 * i + 0] = c1.R;
            e->tmp[3 * i + 1] = c1.G;
            e->tmp[3 * i + 2] = c1.B;
            if(c1.A != 0xff)
            {
                last = i;
            }
            e->tmp[3 * 256 + i] = c1.A;
        }
        writeChunk(gocpp::recv(e), e->tmp.make_slice(0, 3 * len(p)), "PLTE");
        if(last != - 1)
        {
            writeChunk(gocpp::recv(e), e->tmp.make_slice(3 * 256, 3 * 256 + 1 + last), "tRNS");
        }
    }

    std::tuple<int, struct gocpp::error> Write(struct encoder* e, gocpp::slice<unsigned char> b)
    {
        writeChunk(gocpp::recv(e), b, "IDAT");
        if(e->err != nullptr)
        {
            return {0, e->err};
        }
        return {len(b), nullptr};
    }

    int filter(gocpp::array<gocpp::slice<unsigned char>, nFilter>* cr, gocpp::slice<unsigned char> pr, int bpp)
    {
        auto cdat0 = cr[0].make_slice(1);
        auto cdat1 = cr[1].make_slice(1);
        auto cdat2 = cr[2].make_slice(1);
        auto cdat3 = cr[3].make_slice(1);
        auto cdat4 = cr[4].make_slice(1);
        auto pdat = pr.make_slice(1);
        auto n = len(cdat0);
        auto sum = 0;
        for(auto i = 0; i < n; i++)
        {
            cdat2[i] = cdat0[i] - pdat[i];
            sum += abs8(cdat2[i]);
        }
        auto best = sum;
        auto filter = ftUp;
        sum = 0;
        for(auto i = 0; i < bpp; i++)
        {
            cdat4[i] = cdat0[i] - pdat[i];
            sum += abs8(cdat4[i]);
        }
        for(auto i = bpp; i < n; i++)
        {
            cdat4[i] = cdat0[i] - paeth(cdat0[i - bpp], pdat[i], pdat[i - bpp]);
            sum += abs8(cdat4[i]);
            if(sum >= best)
            {
                break;
            }
        }
        if(sum < best)
        {
            best = sum;
            filter = ftPaeth;
        }
        sum = 0;
        for(auto i = 0; i < n; i++)
        {
            sum += abs8(cdat0[i]);
            if(sum >= best)
            {
                break;
            }
        }
        if(sum < best)
        {
            best = sum;
            filter = ftNone;
        }
        sum = 0;
        for(auto i = 0; i < bpp; i++)
        {
            cdat1[i] = cdat0[i];
            sum += abs8(cdat1[i]);
        }
        for(auto i = bpp; i < n; i++)
        {
            cdat1[i] = cdat0[i] - cdat0[i - bpp];
            sum += abs8(cdat1[i]);
            if(sum >= best)
            {
                break;
            }
        }
        if(sum < best)
        {
            best = sum;
            filter = ftSub;
        }
        sum = 0;
        for(auto i = 0; i < bpp; i++)
        {
            cdat3[i] = cdat0[i] - pdat[i] / 2;
            sum += abs8(cdat3[i]);
        }
        for(auto i = bpp; i < n; i++)
        {
            cdat3[i] = cdat0[i] - uint8_t((int(cdat0[i - bpp]) + int(pdat[i])) / 2);
            sum += abs8(cdat3[i]);
            if(sum >= best)
            {
                break;
            }
        }
        if(sum < best)
        {
            filter = ftAverage;
        }
        return filter;
    }

    void zeroMemory(gocpp::slice<uint8_t> v)
    {
        for(auto [i, gocpp_ignored] : v)
        {
            v[i] = 0;
        }
    }

    struct gocpp::error writeImage(struct encoder* e, struct io::Writer w, struct image::Image m, int cb, int level)
    {
        gocpp::Defer defer;
        try
        {
            if(e->zw == nullptr || e->zwLevel != level)
            {
                auto [zw, err] = zlib::NewWriterLevel(w, level);
                if(err != nullptr)
                {
                    return err;
                }
                e->zw = zw;
                e->zwLevel = level;
            }
            else
            {
                Reset(gocpp::recv(e->zw), w);
            }
            defer.push_back([=]{ Close(gocpp::recv(e->zw)); });
            auto bitsPerPixel = 0;
            //Go switch emulation
            {
                auto condition = cb;
                int conditionId = -1;
                if(condition == cbG8) { conditionId = 0; }
                else if(condition == cbTC8) { conditionId = 1; }
                else if(condition == cbP8) { conditionId = 2; }
                else if(condition == cbP4) { conditionId = 3; }
                else if(condition == cbP2) { conditionId = 4; }
                else if(condition == cbP1) { conditionId = 5; }
                else if(condition == cbTCA8) { conditionId = 6; }
                else if(condition == cbTC16) { conditionId = 7; }
                else if(condition == cbTCA16) { conditionId = 8; }
                else if(condition == cbG16) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                        bitsPerPixel = 8;
                        break;
                    case 1:
                        bitsPerPixel = 24;
                        break;
                    case 2:
                        bitsPerPixel = 8;
                        break;
                    case 3:
                        bitsPerPixel = 4;
                        break;
                    case 4:
                        bitsPerPixel = 2;
                        break;
                    case 5:
                        bitsPerPixel = 1;
                        break;
                    case 6:
                        bitsPerPixel = 32;
                        break;
                    case 7:
                        bitsPerPixel = 48;
                        break;
                    case 8:
                        bitsPerPixel = 64;
                        break;
                    case 9:
                        bitsPerPixel = 16;
                        break;
                }
            }
            auto b = Bounds(gocpp::recv(m));
            auto sz = 1 + (bitsPerPixel * Dx(gocpp::recv(b)) + 7) / 8;
            for(auto [i, gocpp_ignored] : e->cr)
            {
                if(cap(e->cr[i]) < sz)
                {
                    e->cr[i] = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), sz);
                }
                else
                {
                    e->cr[i] = e->cr[i].make_slice(0, sz);
                }
                e->cr[i][0] = uint8_t(i);
            }
            auto cr = e->cr;
            if(cap(e->pr) < sz)
            {
                e->pr = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), sz);
            }
            else
            {
                e->pr = e->pr.make_slice(0, sz);
                zeroMemory(e->pr);
            }
            auto pr = e->pr;
            auto [gray, gocpp_id_10] = gocpp::getValue<image::Gray*>(m);
            auto [rgba, gocpp_id_12] = gocpp::getValue<image::RGBA*>(m);
            auto [paletted, gocpp_id_14] = gocpp::getValue<image::Paletted*>(m);
            auto [nrgba, gocpp_id_16] = gocpp::getValue<image::NRGBA*>(m);
            for(auto y = b.Min.Y; y < b.Max.Y; y++)
            {
                auto i = 1;
                //Go switch emulation
                {
                    auto condition = cb;
                    int conditionId = -1;
                    if(condition == cbG8) { conditionId = 0; }
                    else if(condition == cbTC8) { conditionId = 1; }
                    else if(condition == cbP8) { conditionId = 2; }
                    else if(condition == cbP4) { conditionId = 3; }
                    else if(condition == cbP2) { conditionId = 4; }
                    else if(condition == cbP1) { conditionId = 5; }
                    else if(condition == cbTCA8) { conditionId = 6; }
                    else if(condition == cbG16) { conditionId = 7; }
                    else if(condition == cbTC16) { conditionId = 8; }
                    else if(condition == cbTCA16) { conditionId = 9; }
                    switch(conditionId)
                    {
                        case 0:
                            if(gray != nullptr)
                            {
                                auto offset = (y - b.Min.Y) * gray->Stride;
                                copy(cr[0].make_slice(1), gray->Pix.make_slice(offset, offset + Dx(gocpp::recv(b))));
                            }
                            else
                            {
                                for(auto x = b.Min.X; x < b.Max.X; x++)
                                {
                                    auto c = gocpp::getValue<color::Gray>(Convert(gocpp::recv(color::GrayModel), At(gocpp::recv(m), x, y)));
                                    cr[0][i] = c.Y;
                                    i++;
                                }
                            }
                            break;
                        case 1:
                            auto cr0 = cr[0];
                            auto [stride, pix] = std::tuple{0, gocpp::Tag<gocpp::slice<unsigned char>>()(nullptr)};
                            if(rgba != nullptr)
                            {
                                std::tie(stride, pix) = std::tuple{rgba->Stride, rgba->Pix};
                            }
                            else
                            if(nrgba != nullptr)
                            {
                                std::tie(stride, pix) = std::tuple{nrgba->Stride, nrgba->Pix};
                            }
                            if(stride != 0)
                            {
                                auto j0 = (y - b.Min.Y) * stride;
                                auto j1 = j0 + Dx(gocpp::recv(b)) * 4;
                                for(auto j = j0; j < j1; j += 4)
                                {
                                    cr0[i + 0] = pix[j + 0];
                                    cr0[i + 1] = pix[j + 1];
                                    cr0[i + 2] = pix[j + 2];
                                    i += 3;
                                }
                            }
                            else
                            {
                                for(auto x = b.Min.X; x < b.Max.X; x++)
                                {
                                    auto [r, g, b, gocpp_id_18] = RGBA(gocpp::recv(At(gocpp::recv(m), x, y)));
                                    cr0[i + 0] = uint8_t(r >> 8);
                                    cr0[i + 1] = uint8_t(g >> 8);
                                    cr0[i + 2] = uint8_t(b >> 8);
                                    i += 3;
                                }
                            }
                            break;
                        case 2:
                            if(paletted != nullptr)
                            {
                                auto offset = (y - b.Min.Y) * paletted->Stride;
                                copy(cr[0].make_slice(1), paletted->Pix.make_slice(offset, offset + Dx(gocpp::recv(b))));
                            }
                            else
                            {
                                auto pi = gocpp::getValue<image::PalettedImage>(m);
                                for(auto x = b.Min.X; x < b.Max.X; x++)
                                {
                                    cr[0][i] = ColorIndexAt(gocpp::recv(pi), x, y);
                                    i += 1;
                                }
                            }
                            break;
                        case 3:
                        case 4:
                        case 5:
                            auto pi = gocpp::getValue<image::PalettedImage>(m);
                            uint8_t a = {};
                            int c = {};
                            auto pixelsPerByte = 8 / bitsPerPixel;
                            for(auto x = b.Min.X; x < b.Max.X; x++)
                            {
                                a = (a << (unsigned int)(bitsPerPixel)) | ColorIndexAt(gocpp::recv(pi), x, y);
                                c++;
                                if(c == pixelsPerByte)
                                {
                                    cr[0][i] = a;
                                    i += 1;
                                    a = 0;
                                    c = 0;
                                }
                            }
                            if(c != 0)
                            {
                                for(; c != pixelsPerByte; )
                                {
                                    a = a << (unsigned int)(bitsPerPixel);
                                    c++;
                                }
                                cr[0][i] = a;
                            }
                            break;
                        case 6:
                            if(nrgba != nullptr)
                            {
                                auto offset = (y - b.Min.Y) * nrgba->Stride;
                                copy(cr[0].make_slice(1), nrgba->Pix.make_slice(offset, offset + Dx(gocpp::recv(b)) * 4));
                            }
                            else
                            if(rgba != nullptr)
                            {
                                auto dst = cr[0].make_slice(1);
                                auto src = rgba->Pix.make_slice(PixOffset(gocpp::recv(rgba), b.Min.X, y), PixOffset(gocpp::recv(rgba), b.Max.X, y));
                                for(; len(src) >= 4; std::tie(dst, src) = std::tuple{dst.make_slice(4), src.make_slice(4)})
                                {
                                    auto d = (gocpp::array<unsigned char, 4>*)(dst);
                                    auto s = (gocpp::array<unsigned char, 4>*)(src);
                                    if(s[3] == 0x00)
                                    {
                                        d[0] = 0;
                                        d[1] = 0;
                                        d[2] = 0;
                                        d[3] = 0;
                                    }
                                    else
                                    if(s[3] == 0xff)
                                    {
                                        copy(d.make_slice(0, ), s.make_slice(0, ));
                                    }
                                    else
                                    {
                                        auto m = 0x101 * 0xffff;
                                        auto a = uint32_t(s[3]) * 0x101;
                                        d[0] = uint8_t((uint32_t(s[0]) * m / a) >> 8);
                                        d[1] = uint8_t((uint32_t(s[1]) * m / a) >> 8);
                                        d[2] = uint8_t((uint32_t(s[2]) * m / a) >> 8);
                                        d[3] = s[3];
                                    }
                                }
                            }
                            else
                            {
                                for(auto x = b.Min.X; x < b.Max.X; x++)
                                {
                                    auto c = gocpp::getValue<color::NRGBA>(Convert(gocpp::recv(color::NRGBAModel), At(gocpp::recv(m), x, y)));
                                    cr[0][i + 0] = c.R;
                                    cr[0][i + 1] = c.G;
                                    cr[0][i + 2] = c.B;
                                    cr[0][i + 3] = c.A;
                                    i += 4;
                                }
                            }
                            break;
                        case 7:
                            for(auto x = b.Min.X; x < b.Max.X; x++)
                            {
                                auto c = gocpp::getValue<color::Gray16>(Convert(gocpp::recv(color::Gray16Model), At(gocpp::recv(m), x, y)));
                                cr[0][i + 0] = uint8_t(c.Y >> 8);
                                cr[0][i + 1] = uint8_t(c.Y);
                                i += 2;
                            }
                            break;
                        case 8:
                            for(auto x = b.Min.X; x < b.Max.X; x++)
                            {
                                auto [r, g, b, gocpp_id_20] = RGBA(gocpp::recv(At(gocpp::recv(m), x, y)));
                                cr[0][i + 0] = uint8_t(r >> 8);
                                cr[0][i + 1] = uint8_t(r);
                                cr[0][i + 2] = uint8_t(g >> 8);
                                cr[0][i + 3] = uint8_t(g);
                                cr[0][i + 4] = uint8_t(b >> 8);
                                cr[0][i + 5] = uint8_t(b);
                                i += 6;
                            }
                            break;
                        case 9:
                            for(auto x = b.Min.X; x < b.Max.X; x++)
                            {
                                auto c = gocpp::getValue<color::NRGBA64>(Convert(gocpp::recv(color::NRGBA64Model), At(gocpp::recv(m), x, y)));
                                cr[0][i + 0] = uint8_t(c.R >> 8);
                                cr[0][i + 1] = uint8_t(c.R);
                                cr[0][i + 2] = uint8_t(c.G >> 8);
                                cr[0][i + 3] = uint8_t(c.G);
                                cr[0][i + 4] = uint8_t(c.B >> 8);
                                cr[0][i + 5] = uint8_t(c.B);
                                cr[0][i + 6] = uint8_t(c.A >> 8);
                                cr[0][i + 7] = uint8_t(c.A);
                                i += 8;
                            }
                            break;
                    }
                }
                auto f = ftNone;
                if(level != zlib::NoCompression && cb != cbP8 && cb != cbP4 && cb != cbP2 && cb != cbP1)
                {
                    auto bpp = bitsPerPixel / 8;
                    f = filter(& cr, pr, bpp);
                }
                if(auto [gocpp_id_22, err] = Write(gocpp::recv(e->zw), cr[f]); err != nullptr)
                {
                    return err;
                }
                std::tie(pr, cr[0]) = std::tuple{cr[0], pr};
            }
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void writeIDATs(struct encoder* e)
    {
        if(e->err != nullptr)
        {
            return;
        }
        if(e->bw == nullptr)
        {
            e->bw = bufio::NewWriterSize(e, 1 << 15);
        }
        else
        {
            Reset(gocpp::recv(e->bw), e);
        }
        e->err = writeImage(gocpp::recv(e), e->bw, e->m, e->cb, levelToZlib(e->enc->CompressionLevel));
        if(e->err != nullptr)
        {
            return;
        }
        e->err = Flush(gocpp::recv(e->bw));
    }

    int levelToZlib(CompressionLevel l)
    {
        //Go switch emulation
        {
            auto condition = l;
            int conditionId = -1;
            if(condition == DefaultCompression) { conditionId = 0; }
            else if(condition == NoCompression) { conditionId = 1; }
            else if(condition == BestSpeed) { conditionId = 2; }
            else if(condition == BestCompression) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return zlib::DefaultCompression;
                    break;
                case 1:
                    return zlib::NoCompression;
                    break;
                case 2:
                    return zlib::BestSpeed;
                    break;
                case 3:
                    return zlib::BestCompression;
                    break;
                default:
                    return zlib::DefaultCompression;
                    break;
            }
        }
    }

    void writeIEND(struct encoder* e)
    {
        writeChunk(gocpp::recv(e), nullptr, "IEND");
    }

    struct gocpp::error Encode(struct io::Writer w, struct image::Image m)
    {
        Encoder e = {};
        return Encode(gocpp::recv(e), w, m);
    }

    struct gocpp::error Encode(struct Encoder* enc, struct io::Writer w, struct image::Image m)
    {
        gocpp::Defer defer;
        try
        {
            auto [mw, mh] = std::tuple{int64_t(Dx(gocpp::recv(Bounds(gocpp::recv(m))))), int64_t(Dy(gocpp::recv(Bounds(gocpp::recv(m)))))};
            if(mw <= 0 || mh <= 0 || mw >= (1 << 32) || mh >= (1 << 32))
            {
                return FormatError("invalid image size: " + strconv::FormatInt(mw, 10) + "x" + strconv::FormatInt(mh, 10));
            }
            encoder* e = {};
            if(enc->BufferPool != nullptr)
            {
                auto buffer = Get(gocpp::recv(enc->BufferPool));
                e = (encoder*)(buffer);
            }
            if(e == nullptr)
            {
                e = new encoder {};
            }
            if(enc->BufferPool != nullptr)
            {
                defer.push_back([=]{ Put(gocpp::recv(enc->BufferPool), (EncoderBuffer*)(e)); });
            }
            e->enc = enc;
            e->w = w;
            e->m = m;
            color::Palette pal = {};
            if(auto [gocpp_id_24, ok] = gocpp::getValue<image::PalettedImage>(m); ok)
            {
                std::tie(pal, gocpp_id_25) = gocpp::getValue<color::Palette>(ColorModel(gocpp::recv(m)));
            }
            if(pal != nullptr)
            {
                if(len(pal) <= 2)
                {
                    e->cb = cbP1;
                }
                else
                if(len(pal) <= 4)
                {
                    e->cb = cbP2;
                }
                else
                if(len(pal) <= 16)
                {
                    e->cb = cbP4;
                }
                else
                {
                    e->cb = cbP8;
                }
            }
            else
            {
                //Go switch emulation
                {
                    auto condition = ColorModel(gocpp::recv(m));
                    int conditionId = -1;
                    if(condition == color::GrayModel) { conditionId = 0; }
                    else if(condition == color::Gray16Model) { conditionId = 1; }
                    else if(condition == color::RGBAModel) { conditionId = 2; }
                    else if(condition == color::NRGBAModel) { conditionId = 3; }
                    else if(condition == color::AlphaModel) { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                            e->cb = cbG8;
                            break;
                        case 1:
                            e->cb = cbG16;
                            break;
                        case 2:
                        case 3:
                        case 4:
                            if(opaque(m))
                            {
                                e->cb = cbTC8;
                            }
                            else
                            {
                                e->cb = cbTCA8;
                            }
                            break;
                        default:
                            if(opaque(m))
                            {
                                e->cb = cbTC16;
                            }
                            else
                            {
                                e->cb = cbTCA16;
                            }
                            break;
                    }
                }
            }
            std::tie(gocpp_id_26, e->err) = io::WriteString(w, pngHeader);
            writeIHDR(gocpp::recv(e));
            if(pal != nullptr)
            {
                writePLTEAndTRNS(gocpp::recv(e), pal);
            }
            writeIDATs(gocpp::recv(e));
            writeIEND(gocpp::recv(e));
            return e->err;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

