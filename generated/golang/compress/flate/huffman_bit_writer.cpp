// generated by GoCpp from file '$(ImportDir)/compress/flate/huffman_bit_writer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/huffman_bit_writer.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/inflate.h"
#include "golang/compress/flate/token.h"
#include "golang/io/io.h"

namespace golang::flate
{
    gocpp::slice<int8_t> lengthExtraBits = gocpp::slice<int8_t> {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
    gocpp::slice<uint32_t> lengthBase = gocpp::slice<uint32_t> {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 255};
    gocpp::slice<int8_t> offsetExtraBits = gocpp::slice<int8_t> {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
    gocpp::slice<uint32_t> offsetBase = gocpp::slice<uint32_t> {0x000000, 0x000001, 0x000002, 0x000003, 0x000004, 0x000006, 0x000008, 0x00000c, 0x000010, 0x000018, 0x000020, 0x000030, 0x000040, 0x000060, 0x000080, 0x0000c0, 0x000100, 0x000180, 0x000200, 0x000300, 0x000400, 0x000600, 0x000800, 0x000c00, 0x001000, 0x001800, 0x002000, 0x003000, 0x004000, 0x006000};
    gocpp::slice<uint32_t> codegenOrder = gocpp::slice<uint32_t> {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
    
    template<typename T>
    huffmanBitWriter::operator T()
    {
        T result;
        result.writer = this->writer;
        result.bits = this->bits;
        result.nbits = this->nbits;
        result.bytes = this->bytes;
        result.codegenFreq = this->codegenFreq;
        result.nbytes = this->nbytes;
        result.literalFreq = this->literalFreq;
        result.offsetFreq = this->offsetFreq;
        result.codegen = this->codegen;
        result.literalEncoding = this->literalEncoding;
        result.offsetEncoding = this->offsetEncoding;
        result.codegenEncoding = this->codegenEncoding;
        result.err = this->err;
        return result;
    }

    template<typename T>
    bool huffmanBitWriter::operator==(const T& ref) const
    {
        if (writer != ref.writer) return false;
        if (bits != ref.bits) return false;
        if (nbits != ref.nbits) return false;
        if (bytes != ref.bytes) return false;
        if (codegenFreq != ref.codegenFreq) return false;
        if (nbytes != ref.nbytes) return false;
        if (literalFreq != ref.literalFreq) return false;
        if (offsetFreq != ref.offsetFreq) return false;
        if (codegen != ref.codegen) return false;
        if (literalEncoding != ref.literalEncoding) return false;
        if (offsetEncoding != ref.offsetEncoding) return false;
        if (codegenEncoding != ref.codegenEncoding) return false;
        if (err != ref.err) return false;
        return true;
    }

    std::ostream& huffmanBitWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << writer;
        os << " " << bits;
        os << " " << nbits;
        os << " " << bytes;
        os << " " << codegenFreq;
        os << " " << nbytes;
        os << " " << literalFreq;
        os << " " << offsetFreq;
        os << " " << codegen;
        os << " " << literalEncoding;
        os << " " << offsetEncoding;
        os << " " << codegenEncoding;
        os << " " << err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct huffmanBitWriter& value)
    {
        return value.PrintTo(os);
    }

    huffmanBitWriter* newHuffmanBitWriter(io::Writer w)
    {
        return gocpp::InitPtr<huffmanBitWriter>([](huffmanBitWriter& x) { x.writer = w; x.literalFreq = gocpp::make(gocpp::Tag<gocpp::slice<int32_t>>(), maxNumLit); x.offsetFreq = gocpp::make(gocpp::Tag<gocpp::slice<int32_t>>(), offsetCodeCount); x.codegen = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), maxNumLit + offsetCodeCount + 1); x.literalEncoding = newHuffmanEncoder(maxNumLit); x.codegenEncoding = newHuffmanEncoder(codegenCodeCount); x.offsetEncoding = newHuffmanEncoder(offsetCodeCount); });
    }

    void reset(struct huffmanBitWriter* w, io::Writer writer)
    {
        w->writer = writer;
        std::tie(w->bits, w->nbits, w->nbytes, w->err) = std::tuple{0, 0, 0, nullptr};
    }

    void flush(struct huffmanBitWriter* w)
    {
        if(w->err != nullptr)
        {
            w->nbits = 0;
            return;
        }
        auto n = w->nbytes;
        for(; w->nbits != 0; )
        {
            w->bytes[n] = unsigned char(w->bits);
            w->bits >>= 8;
            if(w->nbits > 8)
            {
                w->nbits -= 8;
            }
            else
            {
                w->nbits = 0;
            }
            n++;
        }
        w->bits = 0;
        write(gocpp::recv(w), w->bytes.make_slice(0, n));
        w->nbytes = 0;
    }

    void write(struct huffmanBitWriter* w, gocpp::slice<unsigned char> b)
    {
        if(w->err != nullptr)
        {
            return;
        }
        std::tie(gocpp_id_0, w->err) = Write(gocpp::recv(w->writer), b);
    }

    void writeBits(struct huffmanBitWriter* w, int32_t b, unsigned int nb)
    {
        if(w->err != nullptr)
        {
            return;
        }
        w->bits |= uint64_t(b) << w->nbits;
        w->nbits += nb;
        if(w->nbits >= 48)
        {
            auto bits = w->bits;
            w->bits >>= 48;
            w->nbits -= 48;
            auto n = w->nbytes;
            auto bytes = w->bytes.make_slice(n, n + 6);
            bytes[0] = unsigned char(bits);
            bytes[1] = unsigned char(bits >> 8);
            bytes[2] = unsigned char(bits >> 16);
            bytes[3] = unsigned char(bits >> 24);
            bytes[4] = unsigned char(bits >> 32);
            bytes[5] = unsigned char(bits >> 40);
            n += 6;
            if(n >= bufferFlushSize)
            {
                write(gocpp::recv(w), w->bytes.make_slice(0, n));
                n = 0;
            }
            w->nbytes = n;
        }
    }

    void writeBytes(struct huffmanBitWriter* w, gocpp::slice<unsigned char> bytes)
    {
        if(w->err != nullptr)
        {
            return;
        }
        auto n = w->nbytes;
        if(w->nbits & 7 != 0)
        {
            w->err = InternalError("writeBytes with unfinished bits");
            return;
        }
        for(; w->nbits != 0; )
        {
            w->bytes[n] = unsigned char(w->bits);
            w->bits >>= 8;
            w->nbits -= 8;
            n++;
        }
        if(n != 0)
        {
            write(gocpp::recv(w), w->bytes.make_slice(0, n));
        }
        w->nbytes = 0;
        write(gocpp::recv(w), bytes);
    }

    void generateCodegen(struct huffmanBitWriter* w, int numLiterals, int numOffsets, huffmanEncoder* litEnc, huffmanEncoder* offEnc)
    {
        for(auto [i, gocpp_ignored] : w->codegenFreq)
        {
            w->codegenFreq[i] = 0;
        }
        auto codegen = w->codegen;
        auto cgnl = codegen.make_slice(0, numLiterals);
        for(auto [i, gocpp_ignored] : cgnl)
        {
            cgnl[i] = uint8_t(litEnc->codes[i].len);
        }
        cgnl = codegen.make_slice(numLiterals, numLiterals + numOffsets);
        for(auto [i, gocpp_ignored] : cgnl)
        {
            cgnl[i] = uint8_t(offEnc->codes[i].len);
        }
        codegen[numLiterals + numOffsets] = badCode;
        auto size = codegen[0];
        auto count = 1;
        auto outIndex = 0;
        for(auto inIndex = 1; size != badCode; inIndex++)
        {
            auto nextSize = codegen[inIndex];
            if(nextSize == size)
            {
                count++;
                continue;
            }
            if(size != 0)
            {
                codegen[outIndex] = size;
                outIndex++;
                w->codegenFreq[size]++;
                count--;
                for(; count >= 3; )
                {
                    auto n = 6;
                    if(n > count)
                    {
                        n = count;
                    }
                    codegen[outIndex] = 16;
                    outIndex++;
                    codegen[outIndex] = uint8_t(n - 3);
                    outIndex++;
                    w->codegenFreq[16]++;
                    count -= n;
                }
            }
            else
            {
                for(; count >= 11; )
                {
                    auto n = 138;
                    if(n > count)
                    {
                        n = count;
                    }
                    codegen[outIndex] = 18;
                    outIndex++;
                    codegen[outIndex] = uint8_t(n - 11);
                    outIndex++;
                    w->codegenFreq[18]++;
                    count -= n;
                }
                if(count >= 3)
                {
                    codegen[outIndex] = 17;
                    outIndex++;
                    codegen[outIndex] = uint8_t(count - 3);
                    outIndex++;
                    w->codegenFreq[17]++;
                    count = 0;
                }
            }
            count--;
            for(; count >= 0; count--)
            {
                codegen[outIndex] = size;
                outIndex++;
                w->codegenFreq[size]++;
            }
            size = nextSize;
            count = 1;
        }
        codegen[outIndex] = badCode;
    }

    std::tuple<int, int> dynamicSize(struct huffmanBitWriter* w, huffmanEncoder* litEnc, huffmanEncoder* offEnc, int extraBits)
    {
        int size;
        int numCodegens;
        numCodegens = len(w->codegenFreq);
        for(; numCodegens > 4 && w->codegenFreq[codegenOrder[numCodegens - 1]] == 0; )
        {
            int size;
            int numCodegens;
            numCodegens--;
        }
        auto header = 3 + 5 + 5 + 4 + (3 * numCodegens) + bitLength(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0, )) + int(w->codegenFreq[16]) * 2 + int(w->codegenFreq[17]) * 3 + int(w->codegenFreq[18]) * 7;
        size = header + bitLength(gocpp::recv(litEnc), w->literalFreq) + bitLength(gocpp::recv(offEnc), w->offsetFreq) + extraBits;
        return {size, numCodegens};
    }

    int fixedSize(struct huffmanBitWriter* w, int extraBits)
    {
        return 3 + bitLength(gocpp::recv(fixedLiteralEncoding), w->literalFreq) + bitLength(gocpp::recv(fixedOffsetEncoding), w->offsetFreq) + extraBits;
    }

    std::tuple<int, bool> storedSize(struct huffmanBitWriter* w, gocpp::slice<unsigned char> in)
    {
        if(in == nullptr)
        {
            return {0, false};
        }
        if(len(in) <= maxStoreBlockSize)
        {
            return {(len(in) + 5) * 8, true};
        }
        return {0, false};
    }

    void writeCode(struct huffmanBitWriter* w, hcode c)
    {
        if(w->err != nullptr)
        {
            return;
        }
        w->bits |= uint64_t(c.code) << w->nbits;
        w->nbits += (unsigned int)(c.len);
        if(w->nbits >= 48)
        {
            auto bits = w->bits;
            w->bits >>= 48;
            w->nbits -= 48;
            auto n = w->nbytes;
            auto bytes = w->bytes.make_slice(n, n + 6);
            bytes[0] = unsigned char(bits);
            bytes[1] = unsigned char(bits >> 8);
            bytes[2] = unsigned char(bits >> 16);
            bytes[3] = unsigned char(bits >> 24);
            bytes[4] = unsigned char(bits >> 32);
            bytes[5] = unsigned char(bits >> 40);
            n += 6;
            if(n >= bufferFlushSize)
            {
                write(gocpp::recv(w), w->bytes.make_slice(0, n));
                n = 0;
            }
            w->nbytes = n;
        }
    }

    void writeDynamicHeader(struct huffmanBitWriter* w, int numLiterals, int numOffsets, int numCodegens, bool isEof)
    {
        if(w->err != nullptr)
        {
            return;
        }
        int32_t firstBits = 4;
        if(isEof)
        {
            firstBits = 5;
        }
        writeBits(gocpp::recv(w), firstBits, 3);
        writeBits(gocpp::recv(w), int32_t(numLiterals - 257), 5);
        writeBits(gocpp::recv(w), int32_t(numOffsets - 1), 5);
        writeBits(gocpp::recv(w), int32_t(numCodegens - 4), 4);
        for(auto i = 0; i < numCodegens; i++)
        {
            auto value = (unsigned int)(w->codegenEncoding->codes[codegenOrder[i]].len);
            writeBits(gocpp::recv(w), int32_t(value), 3);
        }
        auto i = 0;
        for(; ; )
        {
            int codeWord = int(w->codegen[i]);
            i++;
            if(codeWord == badCode)
            {
                break;
            }
            writeCode(gocpp::recv(w), w->codegenEncoding->codes[uint32_t(codeWord)]);
            //Go switch emulation
            {
                auto condition = codeWord;
                int conditionId = -1;
                if(condition == 16) { conditionId = 0; }
                else if(condition == 17) { conditionId = 1; }
                else if(condition == 18) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        writeBits(gocpp::recv(w), int32_t(w->codegen[i]), 2);
                        i++;
                        break;
                    case 1:
                        writeBits(gocpp::recv(w), int32_t(w->codegen[i]), 3);
                        i++;
                        break;
                    case 2:
                        writeBits(gocpp::recv(w), int32_t(w->codegen[i]), 7);
                        i++;
                        break;
                }
            }
        }
    }

    void writeStoredHeader(struct huffmanBitWriter* w, int length, bool isEof)
    {
        if(w->err != nullptr)
        {
            return;
        }
        int32_t flag = {};
        if(isEof)
        {
            flag = 1;
        }
        writeBits(gocpp::recv(w), flag, 3);
        flush(gocpp::recv(w));
        writeBits(gocpp::recv(w), int32_t(length), 16);
        writeBits(gocpp::recv(w), int32_t(~ uint16_t(length)), 16);
    }

    void writeFixedHeader(struct huffmanBitWriter* w, bool isEof)
    {
        if(w->err != nullptr)
        {
            return;
        }
        int32_t value = 2;
        if(isEof)
        {
            value = 3;
        }
        writeBits(gocpp::recv(w), value, 3);
    }

    void writeBlock(struct huffmanBitWriter* w, gocpp::slice<token> tokens, bool eof, gocpp::slice<unsigned char> input)
    {
        if(w->err != nullptr)
        {
            return;
        }
        tokens = append(tokens, endBlockMarker);
        auto [numLiterals, numOffsets] = indexTokens(gocpp::recv(w), tokens);
        int extraBits = {};
        auto [storedSize, storable] = storedSize(gocpp::recv(w), input);
        if(storable)
        {
            for(auto lengthCode = lengthCodesStart + 8; lengthCode < numLiterals; lengthCode++)
            {
                extraBits += int(w->literalFreq[lengthCode]) * int(lengthExtraBits[lengthCode - lengthCodesStart]);
            }
            for(auto offsetCode = 4; offsetCode < numOffsets; offsetCode++)
            {
                extraBits += int(w->offsetFreq[offsetCode]) * int(offsetExtraBits[offsetCode]);
            }
        }
        auto literalEncoding = fixedLiteralEncoding;
        auto offsetEncoding = fixedOffsetEncoding;
        auto size = fixedSize(gocpp::recv(w), extraBits);
        int numCodegens = {};
        generateCodegen(gocpp::recv(w), numLiterals, numOffsets, w->literalEncoding, w->offsetEncoding);
        generate(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0, ), 7);
        auto [dynamicSize, numCodegens] = dynamicSize(gocpp::recv(w), w->literalEncoding, w->offsetEncoding, extraBits);
        if(dynamicSize < size)
        {
            size = dynamicSize;
            literalEncoding = w->literalEncoding;
            offsetEncoding = w->offsetEncoding;
        }
        if(storable && storedSize < size)
        {
            writeStoredHeader(gocpp::recv(w), len(input), eof);
            writeBytes(gocpp::recv(w), input);
            return;
        }
        if(literalEncoding == fixedLiteralEncoding)
        {
            writeFixedHeader(gocpp::recv(w), eof);
        }
        else
        {
            writeDynamicHeader(gocpp::recv(w), numLiterals, numOffsets, numCodegens, eof);
        }
        writeTokens(gocpp::recv(w), tokens, literalEncoding->codes, offsetEncoding->codes);
    }

    void writeBlockDynamic(struct huffmanBitWriter* w, gocpp::slice<token> tokens, bool eof, gocpp::slice<unsigned char> input)
    {
        if(w->err != nullptr)
        {
            return;
        }
        tokens = append(tokens, endBlockMarker);
        auto [numLiterals, numOffsets] = indexTokens(gocpp::recv(w), tokens);
        generateCodegen(gocpp::recv(w), numLiterals, numOffsets, w->literalEncoding, w->offsetEncoding);
        generate(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0, ), 7);
        auto [size, numCodegens] = dynamicSize(gocpp::recv(w), w->literalEncoding, w->offsetEncoding, 0);
        if(auto [ssize, storable] = storedSize(gocpp::recv(w), input); storable && ssize < (size + (size >> 4)))
        {
            writeStoredHeader(gocpp::recv(w), len(input), eof);
            writeBytes(gocpp::recv(w), input);
            return;
        }
        writeDynamicHeader(gocpp::recv(w), numLiterals, numOffsets, numCodegens, eof);
        writeTokens(gocpp::recv(w), tokens, w->literalEncoding->codes, w->offsetEncoding->codes);
    }

    std::tuple<int, int> indexTokens(struct huffmanBitWriter* w, gocpp::slice<token> tokens)
    {
        int numLiterals;
        int numOffsets;
        for(auto [i, gocpp_ignored] : w->literalFreq)
        {
            int numLiterals;
            int numOffsets;
            w->literalFreq[i] = 0;
        }
        for(auto [i, gocpp_ignored] : w->offsetFreq)
        {
            int numLiterals;
            int numOffsets;
            w->offsetFreq[i] = 0;
        }
        for(auto [_, t] : tokens)
        {
            int numLiterals;
            int numOffsets;
            if(t < matchType)
            {
                int numLiterals;
                int numOffsets;
                w->literalFreq[literal(gocpp::recv(t))]++;
                continue;
            }
            auto length = length(gocpp::recv(t));
            auto offset = offset(gocpp::recv(t));
            w->literalFreq[lengthCodesStart + lengthCode(length)]++;
            w->offsetFreq[offsetCode(offset)]++;
        }
        numLiterals = len(w->literalFreq);
        for(; w->literalFreq[numLiterals - 1] == 0; )
        {
            int numLiterals;
            int numOffsets;
            numLiterals--;
        }
        numOffsets = len(w->offsetFreq);
        for(; numOffsets > 0 && w->offsetFreq[numOffsets - 1] == 0; )
        {
            int numLiterals;
            int numOffsets;
            numOffsets--;
        }
        if(numOffsets == 0)
        {
            int numLiterals;
            int numOffsets;
            w->offsetFreq[0] = 1;
            numOffsets = 1;
        }
        generate(gocpp::recv(w->literalEncoding), w->literalFreq, 15);
        generate(gocpp::recv(w->offsetEncoding), w->offsetFreq, 15);
        return {numLiterals, numOffsets};
    }

    void writeTokens(struct huffmanBitWriter* w, gocpp::slice<token> tokens, gocpp::slice<hcode> leCodes, gocpp::slice<hcode> oeCodes)
    {
        if(w->err != nullptr)
        {
            return;
        }
        for(auto [_, t] : tokens)
        {
            if(t < matchType)
            {
                writeCode(gocpp::recv(w), leCodes[literal(gocpp::recv(t))]);
                continue;
            }
            auto length = length(gocpp::recv(t));
            auto lengthCode = lengthCode(length);
            writeCode(gocpp::recv(w), leCodes[lengthCode + lengthCodesStart]);
            auto extraLengthBits = (unsigned int)(lengthExtraBits[lengthCode]);
            if(extraLengthBits > 0)
            {
                auto extraLength = int32_t(length - lengthBase[lengthCode]);
                writeBits(gocpp::recv(w), extraLength, extraLengthBits);
            }
            auto offset = offset(gocpp::recv(t));
            auto offsetCode = offsetCode(offset);
            writeCode(gocpp::recv(w), oeCodes[offsetCode]);
            auto extraOffsetBits = (unsigned int)(offsetExtraBits[offsetCode]);
            if(extraOffsetBits > 0)
            {
                auto extraOffset = int32_t(offset - offsetBase[offsetCode]);
                writeBits(gocpp::recv(w), extraOffset, extraOffsetBits);
            }
        }
    }

    huffmanEncoder* huffOffset;
    void init()
    {
        auto offsetFreq = gocpp::make(gocpp::Tag<gocpp::slice<int32_t>>(), offsetCodeCount);
        offsetFreq[0] = 1;
        huffOffset = newHuffmanEncoder(offsetCodeCount);
        generate(gocpp::recv(huffOffset), offsetFreq, 15);
    }

    void writeBlockHuff(struct huffmanBitWriter* w, bool eof, gocpp::slice<unsigned char> input)
    {
        if(w->err != nullptr)
        {
            return;
        }
        for(auto [i, gocpp_ignored] : w->literalFreq)
        {
            w->literalFreq[i] = 0;
        }
        histogram(input, w->literalFreq);
        w->literalFreq[endBlockMarker] = 1;
        auto numLiterals = endBlockMarker + 1;
        w->offsetFreq[0] = 1;
        auto numOffsets = 1;
        generate(gocpp::recv(w->literalEncoding), w->literalFreq, 15);
        int numCodegens = {};
        generateCodegen(gocpp::recv(w), numLiterals, numOffsets, w->literalEncoding, huffOffset);
        generate(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0, ), 7);
        auto [size, numCodegens] = dynamicSize(gocpp::recv(w), w->literalEncoding, huffOffset, 0);
        if(auto [ssize, storable] = storedSize(gocpp::recv(w), input); storable && ssize < (size + (size >> 4)))
        {
            writeStoredHeader(gocpp::recv(w), len(input), eof);
            writeBytes(gocpp::recv(w), input);
            return;
        }
        writeDynamicHeader(gocpp::recv(w), numLiterals, numOffsets, numCodegens, eof);
        auto encoding = w->literalEncoding->codes.make_slice(0, 257);
        auto n = w->nbytes;
        for(auto [_, t] : input)
        {
            auto c = encoding[t];
            w->bits |= uint64_t(c.code) << w->nbits;
            w->nbits += (unsigned int)(c.len);
            if(w->nbits < 48)
            {
                continue;
            }
            auto bits = w->bits;
            w->bits >>= 48;
            w->nbits -= 48;
            auto bytes = w->bytes.make_slice(n, n + 6);
            bytes[0] = unsigned char(bits);
            bytes[1] = unsigned char(bits >> 8);
            bytes[2] = unsigned char(bits >> 16);
            bytes[3] = unsigned char(bits >> 24);
            bytes[4] = unsigned char(bits >> 32);
            bytes[5] = unsigned char(bits >> 40);
            n += 6;
            if(n < bufferFlushSize)
            {
                continue;
            }
            write(gocpp::recv(w), w->bytes.make_slice(0, n));
            if(w->err != nullptr)
            {
                return;
            }
            n = 0;
        }
        w->nbytes = n;
        writeCode(gocpp::recv(w), encoding[endBlockMarker]);
    }

    void histogram(gocpp::slice<unsigned char> b, gocpp::slice<int32_t> h)
    {
        h = h.make_slice(0, 256);
        for(auto [_, t] : b)
        {
            h[t]++;
        }
    }

}

