// generated by GoCpp from file '$(ImportDir)/syscall/dll_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/dll_windows.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/doc.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
        using mocklib::rec::Lock;
        using mocklib::rec::Unlock;
    }

    // DLLError describes reasons for DLL load failures.
    
    template<typename T> requires gocpp::GoStruct<T>
    DLLError::operator T()
    {
        T result;
        result.Err = this->Err;
        result.ObjName = this->ObjName;
        result.Msg = this->Msg;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DLLError::operator==(const T& ref) const
    {
        if (Err != ref.Err) return false;
        if (ObjName != ref.ObjName) return false;
        if (Msg != ref.Msg) return false;
        return true;
    }

    std::ostream& DLLError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Err;
        os << " " << ObjName;
        os << " " << Msg;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DLLError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct DLLError* e)
    {
        return e->Msg;
    }

    struct gocpp::error rec::Unwrap(struct DLLError* e)
    {
        return e->Err;
    }

    // Deprecated: Use SyscallN instead.
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3)
    /* convertBlockStmt, nil block */;

    // Deprecated: Use SyscallN instead.
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall6(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
    /* convertBlockStmt, nil block */;

    // Deprecated: Use SyscallN instead.
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall9(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9)
    /* convertBlockStmt, nil block */;

    // Deprecated: Use SyscallN instead.
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall12(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12)
    /* convertBlockStmt, nil block */;

    // Deprecated: Use SyscallN instead.
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall15(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15)
    /* convertBlockStmt, nil block */;

    // Deprecated: Use SyscallN instead.
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall18(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15, uintptr_t a16, uintptr_t a17, uintptr_t a18)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, syscall::Errno> SyscallN(uintptr_t trap, gocpp::slice<uintptr_t> args)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, syscall::Errno> loadlibrary(uint16_t* filename)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, syscall::Errno> loadsystemlibrary(uint16_t* filename)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, syscall::Errno> getprocaddress(uintptr_t handle, uint8_t* procname)
    /* convertBlockStmt, nil block */;

    // A DLL implements access to a single DLL.
    
    template<typename T> requires gocpp::GoStruct<T>
    DLL::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Handle = this->Handle;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DLL::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Handle != ref.Handle) return false;
        return true;
    }

    std::ostream& DLL::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Handle;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DLL& value)
    {
        return value.PrintTo(os);
    }

    // LoadDLL loads the named DLL file into memory.
    //
    // If name is not an absolute path and is not a known system DLL used by
    // Go, Windows will search for the named DLL in many locations, causing
    // potential DLL preloading attacks.
    //
    // Use LazyDLL in golang.org/x/sys/windows for a secure way to
    // load system DLLs.
    std::tuple<struct DLL*, struct gocpp::error> LoadDLL(std::string name)
    {
        auto [namep, err] = UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        uintptr_t h = {};
        syscall::Errno e = {};
        if(sysdll::IsSystemDLL[name])
        {
            std::tie(h, e) = loadsystemlibrary(namep);
        }
        else
        {
            std::tie(h, e) = loadlibrary(namep);
        }
        if(e != 0)
        {
            return {nullptr, gocpp::InitPtr<DLLError>([=](auto& x) {
                x.Err = e;
                x.ObjName = name;
                x.Msg = "Failed to load "s + name + ": "s + rec::Error(gocpp::recv(e));
            })};
        }
        auto d = gocpp::InitPtr<DLL>([=](auto& x) {
            x.Name = name;
            x.Handle = Handle(h);
        });
        return {d, nullptr};
    }

    // MustLoadDLL is like LoadDLL but panics if load operation fails.
    struct DLL* MustLoadDLL(std::string name)
    {
        auto [d, e] = LoadDLL(name);
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
        return d;
    }

    // FindProc searches DLL d for procedure named name and returns *Proc
    // if found. It returns an error if search fails.
    std::tuple<struct Proc*, struct gocpp::error> rec::FindProc(struct DLL* d, std::string name)
    {
        struct Proc* proc;
        struct gocpp::error err;
        auto [namep, err] = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        auto [a, e] = getprocaddress(uintptr_t(d->Handle), namep);
        if(e != 0)
        {
            return {nullptr, gocpp::InitPtr<DLLError>([=](auto& x) {
                x.Err = e;
                x.ObjName = name;
                x.Msg = "Failed to find "s + name + " procedure in "s + d->Name + ": "s + rec::Error(gocpp::recv(e));
            })};
        }
        auto p = gocpp::InitPtr<Proc>([=](auto& x) {
            x.Dll = d;
            x.Name = name;
            x.addr = a;
        });
        return {p, nullptr};
    }

    // MustFindProc is like FindProc but panics if search fails.
    struct Proc* rec::MustFindProc(struct DLL* d, std::string name)
    {
        auto [p, e] = rec::FindProc(gocpp::recv(d), name);
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
        return p;
    }

    // Release unloads DLL d from memory.
    struct gocpp::error rec::Release(struct DLL* d)
    {
        struct gocpp::error err;
        return FreeLibrary(d->Handle);
    }

    // A Proc implements access to a procedure inside a DLL.
    
    template<typename T> requires gocpp::GoStruct<T>
    Proc::operator T()
    {
        T result;
        result.Dll = this->Dll;
        result.Name = this->Name;
        result.addr = this->addr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Proc::operator==(const T& ref) const
    {
        if (Dll != ref.Dll) return false;
        if (Name != ref.Name) return false;
        if (addr != ref.addr) return false;
        return true;
    }

    std::ostream& Proc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Dll;
        os << " " << Name;
        os << " " << addr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Proc& value)
    {
        return value.PrintTo(os);
    }

    // Addr returns the address of the procedure represented by p.
    // The return value can be passed to Syscall to run the procedure.
    uintptr_t rec::Addr(struct Proc* p)
    {
        return p->addr;
    }

    // Call executes procedure p with arguments a.
    //
    // The returned error is always non-nil, constructed from the result of GetLastError.
    // Callers must inspect the primary return value to decide whether an error occurred
    // (according to the semantics of the specific function being called) before consulting
    // the error. The error always has type syscall.Errno.
    //
    // On amd64, Call can pass and return floating-point values. To pass
    // an argument x with C type "float", use
    // uintptr(math.Float32bits(x)). To pass an argument with C type
    // "double", use uintptr(math.Float64bits(x)). Floating-point return
    // values are returned in r2. The return value for C type "float" is
    // math.Float32frombits(uint32(r2)). For C type "double", it is
    // math.Float64frombits(uint64(r2)).
    //
    //go:uintptrescapes
    std::tuple<uintptr_t, uintptr_t, struct gocpp::error> rec::Call(struct Proc* p, gocpp::slice<uintptr_t> a)
    {
        return SyscallN(rec::Addr(gocpp::recv(p)), a);
    }

    // A LazyDLL implements access to a single DLL.
    // It will delay the load of the DLL until the first
    // call to its Handle method or to one of its
    // LazyProc's Addr method.
    //
    // LazyDLL is subject to the same DLL preloading attacks as documented
    // on LoadDLL.
    //
    // Use LazyDLL in golang.org/x/sys/windows for a secure way to
    // load system DLLs.
    
    template<typename T> requires gocpp::GoStruct<T>
    LazyDLL::operator T()
    {
        T result;
        result.mu = this->mu;
        result.dll = this->dll;
        result.Name = this->Name;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool LazyDLL::operator==(const T& ref) const
    {
        if (mu != ref.mu) return false;
        if (dll != ref.dll) return false;
        if (Name != ref.Name) return false;
        return true;
    }

    std::ostream& LazyDLL::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << " " << dll;
        os << " " << Name;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LazyDLL& value)
    {
        return value.PrintTo(os);
    }

    // Load loads DLL file d.Name into memory. It returns an error if fails.
    // Load will not try to load DLL, if it is already loaded into memory.
    struct gocpp::error rec::Load(struct LazyDLL* d)
    {
        gocpp::Defer defer;
        try
        {
            if(atomic::LoadPointer((unsafe::Pointer*)(unsafe::Pointer(& d->dll))) == nullptr)
            {
                rec::Lock(gocpp::recv(d->mu));
                defer.push_back([=]{ rec::Unlock(gocpp::recv(d->mu)); });
                if(d->dll == nullptr)
                {
                    auto [dll, e] = LoadDLL(d->Name);
                    if(e != nullptr)
                    {
                        return e;
                    }
                    atomic::StorePointer((unsafe::Pointer*)(unsafe::Pointer(& d->dll)), unsafe::Pointer(dll));
                }
            }
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // mustLoad is like Load but panics if search fails.
    void rec::mustLoad(struct LazyDLL* d)
    {
        auto e = rec::Load(gocpp::recv(d));
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
    }

    // Handle returns d's module handle.
    uintptr_t rec::Handle(struct LazyDLL* d)
    {
        rec::mustLoad(gocpp::recv(d));
        return uintptr_t(d->dll->Handle);
    }

    // NewProc returns a LazyProc for accessing the named procedure in the DLL d.
    struct LazyProc* rec::NewProc(struct LazyDLL* d, std::string name)
    {
        return gocpp::InitPtr<LazyProc>([=](auto& x) {
            x.l = d;
            x.Name = name;
        });
    }

    // NewLazyDLL creates new LazyDLL associated with DLL file.
    struct LazyDLL* NewLazyDLL(std::string name)
    {
        return gocpp::InitPtr<LazyDLL>([=](auto& x) {
            x.Name = name;
        });
    }

    // A LazyProc implements access to a procedure inside a LazyDLL.
    // It delays the lookup until the Addr, Call, or Find method is called.
    
    template<typename T> requires gocpp::GoStruct<T>
    LazyProc::operator T()
    {
        T result;
        result.mu = this->mu;
        result.Name = this->Name;
        result.l = this->l;
        result.proc = this->proc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool LazyProc::operator==(const T& ref) const
    {
        if (mu != ref.mu) return false;
        if (Name != ref.Name) return false;
        if (l != ref.l) return false;
        if (proc != ref.proc) return false;
        return true;
    }

    std::ostream& LazyProc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << " " << Name;
        os << " " << l;
        os << " " << proc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LazyProc& value)
    {
        return value.PrintTo(os);
    }

    // Find searches DLL for procedure named p.Name. It returns
    // an error if search fails. Find will not search procedure,
    // if it is already found and loaded into memory.
    struct gocpp::error rec::Find(struct LazyProc* p)
    {
        gocpp::Defer defer;
        try
        {
            if(atomic::LoadPointer((unsafe::Pointer*)(unsafe::Pointer(& p->proc))) == nullptr)
            {
                rec::Lock(gocpp::recv(p->mu));
                defer.push_back([=]{ rec::Unlock(gocpp::recv(p->mu)); });
                if(p->proc == nullptr)
                {
                    auto e = rec::Load(gocpp::recv(p->l));
                    if(e != nullptr)
                    {
                        return e;
                    }
                    Proc* proc;
                    std::tie(proc, e) = rec::FindProc(gocpp::recv(p->l->dll), p->Name);
                    if(e != nullptr)
                    {
                        return e;
                    }
                    atomic::StorePointer((unsafe::Pointer*)(unsafe::Pointer(& p->proc)), unsafe::Pointer(proc));
                }
            }
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // mustFind is like Find but panics if search fails.
    void rec::mustFind(struct LazyProc* p)
    {
        auto e = rec::Find(gocpp::recv(p));
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
    }

    // Addr returns the address of the procedure represented by p.
    // The return value can be passed to Syscall to run the procedure.
    uintptr_t rec::Addr(struct LazyProc* p)
    {
        rec::mustFind(gocpp::recv(p));
        return rec::Addr(gocpp::recv(p->proc));
    }

    // Call executes procedure p with arguments a. See the documentation of
    // Proc.Call for more information.
    //
    //go:uintptrescapes
    std::tuple<uintptr_t, uintptr_t, struct gocpp::error> rec::Call(struct LazyProc* p, gocpp::slice<uintptr_t> a)
    {
        uintptr_t r1;
        uintptr_t r2;
        struct gocpp::error lastErr;
        rec::mustFind(gocpp::recv(p));
        return rec::Call(gocpp::recv(p->proc), a);
    }

}

