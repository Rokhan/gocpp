// generated by GoCpp from file '$(ImportDir)/runtime/mstats.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mstats.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]

namespace golang::runtime
{
    
    std::ostream& mstats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heapStats;
        os << " " << stacks_sys;
        os << " " << mspan_sys;
        os << " " << mcache_sys;
        os << " " << buckhash_sys;
        os << " " << gcMiscSys;
        os << " " << other_sys;
        os << " " << last_gc_unix;
        os << " " << pause_total_ns;
        os << " " << pause_ns;
        os << " " << pause_end;
        os << " " << numgc;
        os << " " << numforcedgc;
        os << " " << gc_cpu_fraction;
        os << " " << last_gc_nanotime;
        os << " " << lastHeapInUse;
        os << " " << enablegc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mstats& value)
    {
        return value.PrintTo(os);
    }

    mstats memstats;
    
    std::ostream& MemStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Alloc;
        os << " " << TotalAlloc;
        os << " " << Sys;
        os << " " << Lookups;
        os << " " << Mallocs;
        os << " " << Frees;
        os << " " << HeapAlloc;
        os << " " << HeapSys;
        os << " " << HeapIdle;
        os << " " << HeapInuse;
        os << " " << HeapReleased;
        os << " " << HeapObjects;
        os << " " << StackInuse;
        os << " " << StackSys;
        os << " " << MSpanInuse;
        os << " " << MSpanSys;
        os << " " << MCacheInuse;
        os << " " << MCacheSys;
        os << " " << BuckHashSys;
        os << " " << GCSys;
        os << " " << OtherSys;
        os << " " << NextGC;
        os << " " << LastGC;
        os << " " << PauseTotalNs;
        os << " " << PauseNs;
        os << " " << PauseEnd;
        os << " " << NumGC;
        os << " " << NumForcedGC;
        os << " " << GCCPUFraction;
        os << " " << EnableGC;
        os << " " << DebugGC;
        os << " " << BySize;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MemStats& value)
    {
        return value.PrintTo(os);
    }

    void init()
    {
        if(auto offset = unsafe::Offsetof(memstats.heapStats); offset % 8 != 0)
        {
            println(offset);
            go_throw("memstats.heapStats not aligned to 8 bytes");
        }
        if(auto size = unsafe::Sizeof(heapStatsDelta {}); size % 8 != 0)
        {
            println(size);
            go_throw("heapStatsDelta not a multiple of 8 bytes in size");
        }
    }

    void ReadMemStats(MemStats* m)
    {
        _ = m->Alloc;
        auto stw = stopTheWorld(stwReadMemStats);
        systemstack([=]() mutable -> void
        {
            readmemstats_m(m);
        }
);
        startTheWorld(stw);
    }

    bool doubleCheckReadMemStats = false;
    struct gocpp_id_1
        {
            uint32_t Size;
            uint64_t Mallocs;
            uint64_t Frees;

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << Size;
                os << " " << Mallocs;
                os << " " << Frees;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    void readmemstats_m(MemStats* stats)
    {
        assertWorldStopped();
        systemstack(flushallmcaches);
        heapStatsDelta consStats = {};
        unsafeRead(gocpp::recv(memstats.heapStats), & consStats);
        auto totalAlloc = consStats.largeAlloc;
        auto nMalloc = consStats.largeAllocCount;
        auto totalFree = consStats.largeFree;
        auto nFree = consStats.largeFreeCount;
        gocpp::array<gocpp_id_1, _NumSizeClasses> bySize = {};
        for(auto [i, gocpp_ignored] : bySize)
        {
            bySize[i].Size = uint32_t(class_to_size[i]);
            auto a = consStats.smallAllocCount[i];
            totalAlloc += a * uint64_t(class_to_size[i]);
            nMalloc += a;
            bySize[i].Mallocs = a;
            auto f = consStats.smallFreeCount[i];
            totalFree += f * uint64_t(class_to_size[i]);
            nFree += f;
            bySize[i].Frees = f;
        }
        nFree += consStats.tinyAllocCount;
        nMalloc += consStats.tinyAllocCount;
        auto stackInUse = uint64_t(consStats.inStacks);
        auto gcWorkBufInUse = uint64_t(consStats.inWorkBufs);
        auto gcProgPtrScalarBitsInUse = uint64_t(consStats.inPtrScalarBits);
        auto totalMapped = load(gocpp::recv(gcController.heapInUse)) + load(gocpp::recv(gcController.heapFree)) + load(gocpp::recv(gcController.heapReleased)) + load(gocpp::recv(memstats.stacks_sys)) + load(gocpp::recv(memstats.mspan_sys)) + load(gocpp::recv(memstats.mcache_sys)) + load(gocpp::recv(memstats.buckhash_sys)) + load(gocpp::recv(memstats.gcMiscSys)) + load(gocpp::recv(memstats.other_sys)) + stackInUse + gcWorkBufInUse + gcProgPtrScalarBitsInUse;
        auto heapGoal = heapGoal(gocpp::recv(gcController));
        if(doubleCheckReadMemStats)
        {
            lock(& sched.sysmonlock);
            lock(& trace.lock);
            if(load(gocpp::recv(gcController.heapInUse)) != uint64_t(consStats.inHeap))
            {
                print("runtime: heapInUse=", load(gocpp::recv(gcController.heapInUse)), "\n");
                print("runtime: consistent value=", consStats.inHeap, "\n");
                go_throw("heapInUse and consistent stats are not equal");
            }
            if(load(gocpp::recv(gcController.heapReleased)) != uint64_t(consStats.released))
            {
                print("runtime: heapReleased=", load(gocpp::recv(gcController.heapReleased)), "\n");
                print("runtime: consistent value=", consStats.released, "\n");
                go_throw("heapReleased and consistent stats are not equal");
            }
            auto heapRetained = load(gocpp::recv(gcController.heapInUse)) + load(gocpp::recv(gcController.heapFree));
            auto consRetained = uint64_t(consStats.committed - consStats.inStacks - consStats.inWorkBufs - consStats.inPtrScalarBits);
            if(heapRetained != consRetained)
            {
                print("runtime: global value=", heapRetained, "\n");
                print("runtime: consistent value=", consRetained, "\n");
                go_throw("measures of the retained heap are not equal");
            }
            if(Load(gocpp::recv(gcController.totalAlloc)) != totalAlloc)
            {
                print("runtime: totalAlloc=", Load(gocpp::recv(gcController.totalAlloc)), "\n");
                print("runtime: consistent value=", totalAlloc, "\n");
                go_throw("totalAlloc and consistent stats are not equal");
            }
            if(Load(gocpp::recv(gcController.totalFree)) != totalFree)
            {
                print("runtime: totalFree=", Load(gocpp::recv(gcController.totalFree)), "\n");
                print("runtime: consistent value=", totalFree, "\n");
                go_throw("totalFree and consistent stats are not equal");
            }
            if(Load(gocpp::recv(gcController.mappedReady)) != totalMapped - uint64_t(consStats.released))
            {
                print("runtime: mappedReady=", Load(gocpp::recv(gcController.mappedReady)), "\n");
                print("runtime: totalMapped=", totalMapped, "\n");
                print("runtime: released=", uint64_t(consStats.released), "\n");
                print("runtime: totalMapped-released=", totalMapped - uint64_t(consStats.released), "\n");
                go_throw("mappedReady and other memstats are not equal");
            }
            unlock(& trace.lock);
            unlock(& sched.sysmonlock);
        }
        stats->Alloc = totalAlloc - totalFree;
        stats->TotalAlloc = totalAlloc;
        stats->Sys = totalMapped;
        stats->Mallocs = nMalloc;
        stats->Frees = nFree;
        stats->HeapAlloc = totalAlloc - totalFree;
        stats->HeapSys = load(gocpp::recv(gcController.heapInUse)) + load(gocpp::recv(gcController.heapFree)) + load(gocpp::recv(gcController.heapReleased));
        stats->HeapIdle = load(gocpp::recv(gcController.heapFree)) + load(gocpp::recv(gcController.heapReleased));
        stats->HeapInuse = load(gocpp::recv(gcController.heapInUse));
        stats->HeapReleased = load(gocpp::recv(gcController.heapReleased));
        stats->HeapObjects = nMalloc - nFree;
        stats->StackInuse = stackInUse;
        stats->StackSys = stackInUse + load(gocpp::recv(memstats.stacks_sys));
        stats->MSpanInuse = uint64_t(mheap_.spanalloc.inuse);
        stats->MSpanSys = load(gocpp::recv(memstats.mspan_sys));
        stats->MCacheInuse = uint64_t(mheap_.cachealloc.inuse);
        stats->MCacheSys = load(gocpp::recv(memstats.mcache_sys));
        stats->BuckHashSys = load(gocpp::recv(memstats.buckhash_sys));
        stats->GCSys = load(gocpp::recv(memstats.gcMiscSys)) + gcWorkBufInUse + gcProgPtrScalarBitsInUse;
        stats->OtherSys = load(gocpp::recv(memstats.other_sys));
        stats->NextGC = heapGoal;
        stats->LastGC = memstats.last_gc_unix;
        stats->PauseTotalNs = memstats.pause_total_ns;
        stats->PauseNs = memstats.pause_ns;
        stats->PauseEnd = memstats.pause_end;
        stats->NumGC = memstats.numgc;
        stats->NumForcedGC = memstats.numforcedgc;
        stats->GCCPUFraction = memstats.gc_cpu_fraction;
        stats->EnableGC = true;
        copy(stats->BySize.make_slice(0, ), bySize.make_slice(0, ));
    }

    void readGCStats(gocpp::slice<uint64_t>* pauses)
    {
        systemstack([=]() mutable -> void
        {
            readGCStats_m(pauses);
        }
);
    }

    void readGCStats_m(gocpp::slice<uint64_t>* pauses)
    {
        auto p = *pauses;
        if(cap(p) < len(memstats.pause_ns) + 3)
        {
            go_throw("short slice passed to readGCStats");
        }
        lock(& mheap_.lock);
        auto n = memstats.numgc;
        if(n > uint32_t(len(memstats.pause_ns)))
        {
            n = uint32_t(len(memstats.pause_ns));
        }
        p = p.make_slice(0, cap(p));
        for(auto i = uint32_t(0); i < n; i++)
        {
            auto j = (memstats.numgc - 1 - i) % uint32_t(len(memstats.pause_ns));
            p[i] = memstats.pause_ns[j];
            p[n + i] = memstats.pause_end[j];
        }
        p[n + n] = memstats.last_gc_unix;
        p[n + n + 1] = uint64_t(memstats.numgc);
        p[n + n + 2] = memstats.pause_total_ns;
        unlock(& mheap_.lock);
        *pauses = p.make_slice(0, n + n + 3);
    }

    void flushmcache(int i)
    {
        assertWorldStopped();
        auto p = allp[i];
        auto c = p->mcache;
        if(c == nullptr)
        {
            return;
        }
        releaseAll(gocpp::recv(c));
        stackcache_clear(c);
    }

    void flushallmcaches()
    {
        assertWorldStopped();
        for(auto i = 0; i < int(gomaxprocs); i++)
        {
            flushmcache(i);
        }
    }

    uint64_t load(sysMemStat* s)
    {
        return atomic::Load64((uint64_t*)(s));
    }

    void add(sysMemStat* s, int64_t n)
    {
        auto val = atomic::Xadd64((uint64_t*)(s), n);
        if((n > 0 && int64_t(val) < n) || (n < 0 && int64_t(val) + n < n))
        {
            print("runtime: val=", val, " n=", n, "\n");
            go_throw("sysMemStat overflow");
        }
    }

    
    std::ostream& heapStatsDelta::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << committed;
        os << " " << released;
        os << " " << inHeap;
        os << " " << inStacks;
        os << " " << inWorkBufs;
        os << " " << inPtrScalarBits;
        os << " " << tinyAllocCount;
        os << " " << largeAlloc;
        os << " " << largeAllocCount;
        os << " " << smallAllocCount;
        os << " " << largeFree;
        os << " " << largeFreeCount;
        os << " " << smallFreeCount;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapStatsDelta& value)
    {
        return value.PrintTo(os);
    }

    void merge(struct heapStatsDelta* a, heapStatsDelta* b)
    {
        a->committed += b->committed;
        a->released += b->released;
        a->inHeap += b->inHeap;
        a->inStacks += b->inStacks;
        a->inWorkBufs += b->inWorkBufs;
        a->inPtrScalarBits += b->inPtrScalarBits;
        a->tinyAllocCount += b->tinyAllocCount;
        a->largeAlloc += b->largeAlloc;
        a->largeAllocCount += b->largeAllocCount;
        for(auto [i, gocpp_ignored] : b->smallAllocCount)
        {
            a->smallAllocCount[i] += b->smallAllocCount[i];
        }
        a->largeFree += b->largeFree;
        a->largeFreeCount += b->largeFreeCount;
        for(auto [i, gocpp_ignored] : b->smallFreeCount)
        {
            a->smallFreeCount[i] += b->smallFreeCount[i];
        }
    }

    
    std::ostream& consistentHeapStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stats;
        os << " " << gen;
        os << " " << noPLock;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct consistentHeapStats& value)
    {
        return value.PrintTo(os);
    }

    heapStatsDelta* acquire(struct consistentHeapStats* m)
    {
        if(auto pp = ptr(gocpp::recv(getg()->m->p)); pp != nullptr)
        {
            auto seq = Add(gocpp::recv(pp->statsSeq), 1);
            if(seq % 2 == 0)
            {
                print("runtime: seq=", seq, "\n");
                go_throw("bad sequence number");
            }
        }
        else
        {
            lock(& m->noPLock);
        }
        auto gen = Load(gocpp::recv(m->gen)) % 3;
        return & m->stats[gen];
    }

    void release(struct consistentHeapStats* m)
    {
        if(auto pp = ptr(gocpp::recv(getg()->m->p)); pp != nullptr)
        {
            auto seq = Add(gocpp::recv(pp->statsSeq), 1);
            if(seq % 2 != 0)
            {
                print("runtime: seq=", seq, "\n");
                go_throw("bad sequence number");
            }
        }
        else
        {
            unlock(& m->noPLock);
        }
    }

    void unsafeRead(struct consistentHeapStats* m, heapStatsDelta* out)
    {
        assertWorldStopped();
        for(auto [i, gocpp_ignored] : m->stats)
        {
            merge(gocpp::recv(out), & m->stats[i]);
        }
    }

    void unsafeClear(struct consistentHeapStats* m)
    {
        assertWorldStopped();
        for(auto [i, gocpp_ignored] : m->stats)
        {
            m->stats[i] = heapStatsDelta {};
        }
    }

    void read(struct consistentHeapStats* m, heapStatsDelta* out)
    {
        auto mp = acquirem();
        auto currGen = Load(gocpp::recv(m->gen));
        auto prevGen = currGen - 1;
        if(currGen == 0)
        {
            prevGen = 2;
        }
        lock(& m->noPLock);
        Swap(gocpp::recv(m->gen), (currGen + 1) % 3);
        unlock(& m->noPLock);
        for(auto [_, p] : allp)
        {
            for(; Load(gocpp::recv(p->statsSeq)) % 2 != 0; )
            {
            }
        }
        merge(gocpp::recv(m->stats[currGen]), & m->stats[prevGen]);
        m->stats[prevGen] = heapStatsDelta {};
        *out = m->stats[currGen];
        releasem(mp);
    }

    
    std::ostream& cpuStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << gcAssistTime;
        os << " " << gcDedicatedTime;
        os << " " << gcIdleTime;
        os << " " << gcPauseTime;
        os << " " << gcTotalTime;
        os << " " << scavengeAssistTime;
        os << " " << scavengeBgTime;
        os << " " << scavengeTotalTime;
        os << " " << idleTime;
        os << " " << userTime;
        os << " " << totalTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuStats& value)
    {
        return value.PrintTo(os);
    }

    void accumulate(struct cpuStats* s, int64_t now, bool gcMarkPhase)
    {
        int64_t markAssistCpu = {};
        int64_t markDedicatedCpu = {};
        int64_t markFractionalCpu = {};
        int64_t markIdleCpu = {};
        if(gcMarkPhase)
        {
            markAssistCpu = Load(gocpp::recv(gcController.assistTime));
            markDedicatedCpu = Load(gocpp::recv(gcController.dedicatedMarkTime));
            markFractionalCpu = Load(gocpp::recv(gcController.fractionalMarkTime));
            markIdleCpu = Load(gocpp::recv(gcController.idleMarkTime));
        }
        auto scavAssistCpu = Load(gocpp::recv(scavenge.assistTime));
        auto scavBgCpu = Load(gocpp::recv(scavenge.backgroundTime));
        s->gcAssistTime += markAssistCpu;
        s->gcDedicatedTime += markDedicatedCpu + markFractionalCpu;
        s->gcIdleTime += markIdleCpu;
        s->gcTotalTime += markAssistCpu + markDedicatedCpu + markFractionalCpu + markIdleCpu;
        s->scavengeAssistTime += scavAssistCpu;
        s->scavengeBgTime += scavBgCpu;
        s->scavengeTotalTime += scavAssistCpu + scavBgCpu;
        s->totalTime = sched.totaltime + (now - sched.procresizetime) * int64_t(gomaxprocs);
        s->idleTime += Load(gocpp::recv(sched.idleTime));
        s->userTime = s->totalTime - (s->gcTotalTime + s->scavengeTotalTime + s->idleTime);
    }

}

