// generated by GoCpp from file '$(ImportDir)/runtime/pinner.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/pinner.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    struct Pinner
    {
        pinner* pinner;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Pinner& value);
    struct pinner
    {
        gocpp::slice<gocpp::unsafe_pointer> refs;
        gocpp::array<gocpp::unsafe_pointer, pinnerRefStoreSize> refStore;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pinner& value);
    gocpp::unsafe_pointer pinnerGetPtr(go_any* i);
    bool isPinned(gocpp::unsafe_pointer ptr);
    bool setPinned(gocpp::unsafe_pointer ptr, bool pin);
    struct pinState
    {
        uint8_t* bytep;
        uint8_t byteVal;
        uint8_t mask;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pinState& value);
    uintptr_t* pinnerGetPinCounter(gocpp::unsafe_pointer addr);
    extern std::function<void (void)> pinnerLeakPanic;

    namespace rec
    {
        void Pin(golang::runtime::Pinner* p, go_any pointer);
        void Unpin(golang::runtime::Pinner* p);
        void unpin(golang::runtime::pinner* p);
        bool isPinned(golang::runtime::pinState* v);
        bool isMultiPinned(golang::runtime::pinState* v);
        void setPinned(golang::runtime::pinState* v, bool val);
        void setMultiPinned(golang::runtime::pinState* v, bool val);
        void set(golang::runtime::pinState* v, bool val, bool multipin);
        struct pinState ofObject(golang::runtime::pinnerBits* p, uintptr_t n);
        uintptr_t pinnerBitSize(golang::runtime::mspan* s);
        runtime::pinnerBits* newPinnerBits(golang::runtime::mspan* s);
        runtime::pinnerBits* getPinnerBits(golang::runtime::mspan* s);
        void setPinnerBits(golang::runtime::mspan* s, golang::runtime::pinnerBits* p);
        void refreshPinnerBits(golang::runtime::mspan* s);
        void incPinCounter(golang::runtime::mspan* span, uintptr_t offset);
        bool decPinCounter(golang::runtime::mspan* span, uintptr_t offset);
    }
}

