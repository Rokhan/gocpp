// generated by GoCpp from file '$(ImportDir)/runtime/panic.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/panic.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goarch/zgoarch_amd64.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/security_nonunix.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace cpu::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    void panicCheck1(uintptr_t pc, std::string msg)
    {
        if(goarch::IsWasm == 0 && hasPrefix(funcname(findfunc(pc)), "runtime."))
        {
            go_throw(msg);
        }
        auto gp = getg();
        if(gp != nullptr && gp->m != nullptr && gp->m->mallocing != 0)
        {
            go_throw(msg);
        }
    }

    void panicCheck2(std::string err)
    {
        auto gp = getg();
        if(gp != nullptr && gp->m != nullptr && gp->m->mallocing != 0)
        {
            go_throw(err);
        }
    }

    void goPanicIndex(int x, int y)
    {
        panicCheck1(getcallerpc(), "index out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsIndex;
        }));
    }

    void goPanicIndexU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "index out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsIndex;
        }));
    }

    void goPanicSliceAlen(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSliceAlen;
        }));
    }

    void goPanicSliceAlenU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSliceAlen;
        }));
    }

    void goPanicSliceAcap(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSliceAcap;
        }));
    }

    void goPanicSliceAcapU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSliceAcap;
        }));
    }

    void goPanicSliceB(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSliceB;
        }));
    }

    void goPanicSliceBU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSliceB;
        }));
    }

    void goPanicSlice3Alen(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3Alen;
        }));
    }

    void goPanicSlice3AlenU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3Alen;
        }));
    }

    void goPanicSlice3Acap(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3Acap;
        }));
    }

    void goPanicSlice3AcapU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3Acap;
        }));
    }

    void goPanicSlice3B(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3B;
        }));
    }

    void goPanicSlice3BU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3B;
        }));
    }

    void goPanicSlice3C(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3C;
        }));
    }

    void goPanicSlice3CU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3C;
        }));
    }

    void goPanicSliceConvert(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice length too short to convert to array or pointer to array");
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsConvert;
        }));
    }

    void panicIndex(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicIndexU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAlen(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAlenU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAcap(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAcapU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceB(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceBU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3Alen(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3AlenU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3Acap(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3AcapU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3B(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3BU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3C(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3CU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceConvert(int x, int y)
    /* convertBlockStmt, nil block */;

    gocpp::error shiftError = error(errorString("negative shift amount"));
    void panicshift()
    {
        panicCheck1(getcallerpc(), "negative shift amount");
        gocpp::panic(shiftError);
    }

    gocpp::error divideError = error(errorString("integer divide by zero"));
    void panicdivide()
    {
        panicCheck2("integer divide by zero");
        gocpp::panic(divideError);
    }

    gocpp::error overflowError = error(errorString("integer overflow"));
    void panicoverflow()
    {
        panicCheck2("integer overflow");
        gocpp::panic(overflowError);
    }

    gocpp::error floatError = error(errorString("floating point error"));
    void panicfloat()
    {
        panicCheck2("floating point error");
        gocpp::panic(floatError);
    }

    gocpp::error memoryError = error(errorString("invalid memory address or nil pointer dereference"));
    void panicmem()
    {
        panicCheck2("invalid memory address or nil pointer dereference");
        gocpp::panic(memoryError);
    }

    void panicmemAddr(uintptr_t addr)
    {
        panicCheck2("invalid memory address or nil pointer dereference");
        gocpp::panic(gocpp::Init<errorAddressString>([=](auto& x) {
            x.msg = "invalid memory address or nil pointer dereference";
            x.addr = addr;
        }));
    }

    void deferproc(std::function<void ()> fn)
    {
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            go_throw("defer on system stack");
        }
        auto d = newdefer();
        d->link = gp->_defer;
        gp->_defer = d;
        d->fn = fn;
        d->pc = getcallerpc();
        d->sp = getcallersp();
        return0();
    }

    gocpp::error rangeExitError = error(errorString("range function continued iteration after exit"));
    void panicrangeexit()
    {
        gocpp::panic(rangeExitError);
    }

    go_any deferrangefunc()
    {
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            go_throw("defer on system stack");
        }
        auto d = newdefer();
        d->link = gp->_defer;
        gp->_defer = d;
        d->pc = getcallerpc();
        d->sp = getcallersp();
        d->rangefunc = true;
        d->head = new(atomic::Pointer[_defer]);
        return d->head;
    }

    struct _defer* badDefer()
    {
        return (_defer*)(unsafe::Pointer(uintptr_t(1)));
    }

    void deferprocat(std::function<void ()> fn, go_any frame)
    {
        auto head = gocpp::getValue<atomic::Pointer[runtime::_defer]*>(frame);
        if(raceenabled)
        {
            racewritepc(unsafe::Pointer(head), getcallerpc(), abi::FuncPCABIInternal(deferprocat));
        }
        auto d1 = newdefer();
        d1->fn = fn;
        for(; ; )
        {
            d1->link = rec::Load(gocpp::recv(head));
            if(d1->link == badDefer())
            {
                go_throw("defer after range func returned");
            }
            if(rec::CompareAndSwap(gocpp::recv(head), d1->link, d1))
            {
                break;
            }
        }
        return0();
    }

    struct _defer* deferconvert(struct _defer* d)
    {
        auto head = d->head;
        if(raceenabled)
        {
            racereadpc(unsafe::Pointer(head), getcallerpc(), abi::FuncPCABIInternal(deferconvert));
        }
        auto tail = d->link;
        d->rangefunc = false;
        auto d0 = d;
        for(; ; )
        {
            d = rec::Load(gocpp::recv(head));
            if(rec::CompareAndSwap(gocpp::recv(head), d, badDefer()))
            {
                break;
            }
        }
        if(d == nullptr)
        {
            freedefer(d0);
            return tail;
        }
        for(auto d1 = d; ; d1 = d1->link)
        {
            d1->sp = d0->sp;
            d1->pc = d0->pc;
            if(d1->link == nullptr)
            {
                d1->link = tail;
                break;
            }
        }
        freedefer(d0);
        return d;
    }

    void deferprocStack(struct _defer* d)
    {
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            go_throw("defer on system stack");
        }
        d->heap = false;
        d->rangefunc = false;
        d->sp = getcallersp();
        d->pc = getcallerpc();
        *(uintptr_t*)(unsafe::Pointer(& d->link)) = uintptr_t(unsafe::Pointer(gp->_defer));
        *(uintptr_t*)(unsafe::Pointer(& d->head)) = 0;
        *(uintptr_t*)(unsafe::Pointer(& gp->_defer)) = uintptr_t(unsafe::Pointer(d));
        return0();
    }

    struct _defer* newdefer()
    {
        _defer* d = {};
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(len(pp->deferpool) == 0 && sched.deferpool != nullptr)
        {
            lock(& sched.deferlock);
            for(; len(pp->deferpool) < cap(pp->deferpool) / 2 && sched.deferpool != nullptr; )
            {
                auto d = sched.deferpool;
                sched.deferpool = d->link;
                d->link = nullptr;
                pp->deferpool = append(pp->deferpool, d);
            }
            unlock(& sched.deferlock);
        }
        if(auto n = len(pp->deferpool); n > 0)
        {
            d = pp->deferpool[n - 1];
            pp->deferpool[n - 1] = nullptr;
            pp->deferpool = pp->deferpool.make_slice(0, n - 1);
        }
        releasem(mp);
        std::tie(mp, pp) = std::tuple{nullptr, nullptr};
        if(d == nullptr)
        {
            d = new(_defer);
        }
        d->heap = true;
        return d;
    }

    void freedefer(struct _defer* d)
    {
        d->link = nullptr;
        if(d->fn != nullptr)
        {
            freedeferfn();
        }
        if(! d->heap)
        {
            return;
        }
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(len(pp->deferpool) == cap(pp->deferpool))
        {
            _defer* first = {};
            _defer* last = {};
            for(; len(pp->deferpool) > cap(pp->deferpool) / 2; )
            {
                auto n = len(pp->deferpool);
                auto d = pp->deferpool[n - 1];
                pp->deferpool[n - 1] = nullptr;
                pp->deferpool = pp->deferpool.make_slice(0, n - 1);
                if(first == nullptr)
                {
                    first = d;
                }
                else
                {
                    last->link = d;
                }
                last = d;
            }
            lock(& sched.deferlock);
            last->link = sched.deferpool;
            sched.deferpool = first;
            unlock(& sched.deferlock);
        }
        *d = _defer {};
        pp->deferpool = append(pp->deferpool, d);
        releasem(mp);
        std::tie(mp, pp) = std::tuple{nullptr, nullptr};
    }

    void freedeferfn()
    {
        go_throw("freedefer with d.fn != nil");
    }

    void deferreturn()
    {
        _panic p = {};
        p.deferreturn = true;
        rec::start(gocpp::recv(p), getcallerpc(), unsafe::Pointer(getcallersp()));
        for(; ; )
        {
            auto [fn, ok] = rec::nextDefer(gocpp::recv(p));
            if(! ok)
            {
                break;
            }
            fn();
        }
    }

    void Goexit()
    {
        _panic p = {};
        p.goexit = true;
        rec::start(gocpp::recv(p), getcallerpc(), unsafe::Pointer(getcallersp()));
        for(; ; )
        {
            auto [fn, ok] = rec::nextDefer(gocpp::recv(p));
            if(! ok)
            {
                break;
            }
            fn();
        }
        goexit1();
    }

    void preprintpanics(struct _panic* p)
    {
        gocpp::Defer defer;
        try
        {
            defer.push_back([=]{ [=]() mutable -> void
            {
                auto text = "panic while printing panic value";
                //Go type switch emulation
                {
                    const auto& gocpp_id_0 = gocpp::type_info(gocpp::recover());
                    int conditionId = -1;
                    if(gocpp_id_0 == typeid(untyped nil)) { conditionId = 0; }
                    else if(gocpp_id_0 == typeid(std::string)) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                        {
                            untyped nil r = gocpp::any_cast<untyped nil>(gocpp::recover());
                            break;
                        }
                        case 1:
                        {
                            std::string r = gocpp::any_cast<std::string>(gocpp::recover());
                            go_throw(text + ": " + r);
                            break;
                        }
                        default:
                        {
                            auto r = gocpp::recover();
                            go_throw(text + ": type " + rec::string(gocpp::recv(toRType(efaceOf(& r)->_type))));
                            break;
                        }
                    }
                }
            }(); });
            for(; p != nullptr; )
            {
                //Go type switch emulation
                {
                    const auto& gocpp_id_1 = gocpp::type_info(p->arg);
                    int conditionId = -1;
                    if(gocpp_id_1 == typeid(gocpp::error)) { conditionId = 0; }
                    else if(gocpp_id_1 == typeid(stringer)) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                        {
                            gocpp::error v = gocpp::any_cast<gocpp::error>(p->arg);
                            p->arg = rec::Error(gocpp::recv(v));
                            break;
                        }
                        case 1:
                        {
                            stringer v = gocpp::any_cast<stringer>(p->arg);
                            p->arg = rec::String(gocpp::recv(v));
                            break;
                        }
                    }
                }
                p = p->link;
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void printpanics(struct _panic* p)
    {
        if(p->link != nullptr)
        {
            printpanics(p->link);
            if(! p->link->goexit)
            {
                print("\t");
            }
        }
        if(p->goexit)
        {
            return;
        }
        print("panic: ");
        printany(p->arg);
        if(p->recovered)
        {
            print(" [recovered]");
        }
        print("\n");
    }

    std::tuple<uint32_t, unsafe::Pointer> readvarintUnsafe(unsafe::Pointer fd)
    {
        uint32_t r = {};
        int shift = {};
        for(; ; )
        {
            auto b = *(uint8_t*)(fd);
            fd = add(fd, gocpp::Sizeof<uint8_t>());
            if(b < 128)
            {
                return {r + (uint32_t(b) << shift), fd};
            }
            r += uint32_t(b & 0x7F) << (shift & 31);
            shift += 7;
            if(shift > 28)
            {
                gocpp::panic("Bad varint");
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    PanicNilError::operator T()
    {
        T result;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool PanicNilError::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& PanicNilError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct PanicNilError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(PanicNilError*)
    {
        return "panic called with nil argument";
    }

    void rec::RuntimeError(PanicNilError*)
    {
    }

    godebugInc* panicnil = gocpp::InitPtr<godebugInc>([](auto& x) {
        x.name = "panicnil";
    });
    void gopanic(go_any e)
    {
        if(e == nullptr)
        {
            if(rec::Load(gocpp::recv(debug.panicnil)) != 1)
            {
                e = new(PanicNilError);
            }
            else
            {
                rec::IncNonDefault(gocpp::recv(panicnil));
            }
        }
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            print("panic: ");
            printany(e);
            print("\n");
            go_throw("panic on system stack");
        }
        if(gp->m->mallocing != 0)
        {
            print("panic: ");
            printany(e);
            print("\n");
            go_throw("panic during malloc");
        }
        if(gp->m->preemptoff != "")
        {
            print("panic: ");
            printany(e);
            print("\n");
            print("preempt off reason: ");
            print(gp->m->preemptoff);
            print("\n");
            go_throw("panic during preemptoff");
        }
        if(gp->m->locks != 0)
        {
            print("panic: ");
            printany(e);
            print("\n");
            go_throw("panic holding locks");
        }
        _panic p = {};
        p->arg = e;
        rec::Add(gocpp::recv(runningPanicDefers), 1);
        rec::start(gocpp::recv(p), getcallerpc(), unsafe::Pointer(getcallersp()));
        for(; ; )
        {
            auto [fn, ok] = rec::nextDefer(gocpp::recv(p));
            if(! ok)
            {
                break;
            }
            fn();
        }
        preprintpanics(& p);
        fatalpanic(& p);
        *(int*)(nullptr) = 0;
    }

    void rec::start(struct _panic* p, uintptr_t pc, unsafe::Pointer sp)
    {
        auto gp = getg();
        p->startPC = getcallerpc();
        p->startSP = unsafe::Pointer(getcallersp());
        if(p->deferreturn)
        {
            p->sp = sp;
            if(auto s = (savedOpenDeferState*)(gp->param); s != nullptr)
            {
                gp->param = nullptr;
                p->retpc = s->retpc;
                p->deferBitsPtr = (unsigned char*)(add(sp, s->deferBitsOffset));
                p->slotsPtr = add(sp, s->slotsOffset);
            }
            return;
        }
        p->link = gp->_panic;
        gp->_panic = (_panic*)(noescape(unsafe::Pointer(p)));
        std::tie(p->lr, p->fp) = std::tuple{pc, sp};
        rec::nextFrame(gocpp::recv(p));
    }

    std::tuple<std::function<void ()>, bool> rec::nextDefer(struct _panic* p)
    {
        auto gp = getg();
        if(! p->deferreturn)
        {
            if(gp->_panic != p)
            {
                go_throw("bad panic stack");
            }
            if(p->recovered)
            {
                mcall(recovery);
                go_throw("recovery failed");
            }
        }
        p->argp = add(p->startSP, sys::MinFrameSize);
        for(; ; )
        {
            for(; p->deferBitsPtr != nullptr; )
            {
                auto bits = *p->deferBitsPtr;
                if(bits == 0)
                {
                    p->deferBitsPtr = nullptr;
                    break;
                }
                auto i = 7 - uintptr_t(sys::LeadingZeros8(bits));
                bits &^= 1 << i;
                *p->deferBitsPtr = bits;
                return {*(std::function<void ()>*)(add(p->slotsPtr, i * goarch::PtrSize)), true};
            }
            Recheck:
            if(auto d = gp->_defer; d != nullptr && d->sp == uintptr_t(p->sp))
            {
                if(d->rangefunc)
                {
                    gp->_defer = deferconvert(d);
                    goto Recheck;
                }
                auto fn = d->fn;
                d->fn = nullptr;
                p->retpc = d->pc;
                gp->_defer = d->link;
                freedefer(d);
                return {fn, true};
            }
            if(! rec::nextFrame(gocpp::recv(p)))
            {
                return {nullptr, false};
            }
        }
    }

    bool rec::nextFrame(struct _panic* p)
    {
        bool ok;
        if(p->lr == 0)
        {
            bool ok;
            return false;
        }
        auto gp = getg();
        systemstack([=]() mutable -> void
        {
            uintptr_t limit = {};
            if(auto d = gp->_defer; d != nullptr)
            {
                limit = d->sp;
            }
            unwinder u = {};
            rec::initAt(gocpp::recv(u), p->lr, uintptr_t(p->fp), 0, gp, 0);
            for(; ; )
            {
                if(! rec::valid(gocpp::recv(u)))
                {
                    p->lr = 0;
                    return;
                }
                if(u.frame.sp == limit)
                {
                    break;
                }
                if(rec::initOpenCodedDefers(gocpp::recv(p), u.frame.fn, unsafe::Pointer(u.frame.varp)))
                {
                    break;
                }
                rec::next(gocpp::recv(u));
            }
            p->lr = u.frame.lr;
            p->sp = unsafe::Pointer(u.frame.sp);
            p->fp = unsafe::Pointer(u.frame.fp);
            ok = true;
        });
        return ok;
    }

    bool rec::initOpenCodedDefers(struct _panic* p, struct funcInfo fn, unsafe::Pointer varp)
    {
        auto fd = funcdata(fn, abi::FUNCDATA_OpenCodedDeferInfo);
        if(fd == nullptr)
        {
            return false;
        }
        if(fn.deferreturn == 0)
        {
            go_throw("missing deferreturn");
        }
        uint32_t deferBitsOffset;
        std::tie(deferBitsOffset, fd) = readvarintUnsafe(fd);
        auto deferBitsPtr = (uint8_t*)(add(varp, - uintptr_t(deferBitsOffset)));
        if(*deferBitsPtr == 0)
        {
            return false;
        }
        uint32_t slotsOffset;
        std::tie(slotsOffset, fd) = readvarintUnsafe(fd);
        p->retpc = rec::entry(gocpp::recv(fn)) + uintptr_t(fn.deferreturn);
        p->deferBitsPtr = deferBitsPtr;
        p->slotsPtr = add(varp, - uintptr_t(slotsOffset));
        return true;
    }

    go_any gorecover(uintptr_t argp)
    {
        auto gp = getg();
        auto p = gp->_panic;
        if(p != nullptr && ! p->goexit && ! p->recovered && argp == uintptr_t(p->argp))
        {
            p->recovered = true;
            return p->arg;
        }
        return nullptr;
    }

    void sync_throw(std::string s)
    {
        go_throw(s);
    }

    void sync_fatal(std::string s)
    {
        fatal(s);
    }

    void go_throw(std::string s)
    {
        systemstack([=]() mutable -> void
        {
            print("fatal error: ", s, "\n");
        });
        fatalthrow(throwTypeRuntime);
    }

    void fatal(std::string s)
    {
        systemstack([=]() mutable -> void
        {
            print("fatal error: ", s, "\n");
        });
        fatalthrow(throwTypeUser);
    }

    atomic::Uint32 runningPanicDefers;
    atomic::Uint32 panicking;
    mutex paniclk;
    void recovery(struct g* gp)
    {
        auto p = gp->_panic;
        auto [pc, sp, fp] = std::tuple{p->retpc, uintptr_t(p->sp), uintptr_t(p->fp)};
        auto [p0, saveOpenDeferState] = std::tuple{p, p->deferBitsPtr != nullptr && *p->deferBitsPtr != 0};
        for(; p != nullptr && uintptr_t(p->startSP) < sp; p = p->link)
        {
            if(p->goexit)
            {
                std::tie(pc, sp) = std::tuple{p->startPC, uintptr_t(p->startSP)};
                saveOpenDeferState = false;
                break;
            }
            rec::Add(gocpp::recv(runningPanicDefers), - 1);
        }
        gp->_panic = p;
        if(p == nullptr)
        {
            gp->sig = 0;
        }
        if(gp->param != nullptr)
        {
            go_throw("unexpected gp.param");
        }
        if(saveOpenDeferState)
        {
            gp->param = unsafe::Pointer(gocpp::InitPtr<savedOpenDeferState>([=](auto& x) {
                x.retpc = p0->retpc;
                x.deferBitsOffset = uintptr_t(unsafe::Pointer(p0->deferBitsPtr)) - uintptr_t(p0->sp);
                x.slotsOffset = uintptr_t(p0->slotsPtr) - uintptr_t(p0->sp);
            }));
        }
        if(sp != 0 && (sp < gp->stack.lo || gp->stack.hi < sp))
        {
            print("recover: ", hex(sp), " not in [", hex(gp->stack.lo), ", ", hex(gp->stack.hi), "]\n");
            go_throw("bad recovery");
        }
        gp->sched.sp = sp;
        gp->sched.pc = pc;
        gp->sched.lr = 0;
        //Go switch emulation
        {
            int conditionId = -1;
            if(goarch::IsAmd64 != 0) { conditionId = 0; }
            else if(goarch::IsArm64 != 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    gp->sched.bp = fp - 2 * goarch::PtrSize;
                    break;
                case 1:
                    gp->sched.bp = sp - goarch::PtrSize;
                    break;
            }
        }
        gp->sched.ret = 1;
        gogo(& gp->sched);
    }

    void fatalthrow(golang::runtime::throwType t)
    {
        auto pc = getcallerpc();
        auto sp = getcallersp();
        auto gp = getg();
        if(gp->m->throwing == throwTypeNone)
        {
            gp->m->throwing = t;
        }
        systemstack([=]() mutable -> void
        {
            if(isSecureMode())
            {
                exit(2);
            }
            startpanic_m();
            if(dopanic_m(gp, pc, sp))
            {
                crash();
            }
            exit(2);
        });
        *(int*)(nullptr) = 0;
    }

    void fatalpanic(struct _panic* msgs)
    {
        auto pc = getcallerpc();
        auto sp = getcallersp();
        auto gp = getg();
        bool docrash = {};
        systemstack([=]() mutable -> void
        {
            if(startpanic_m() && msgs != nullptr)
            {
                rec::Add(gocpp::recv(runningPanicDefers), - 1);
                printpanics(msgs);
            }
            docrash = dopanic_m(gp, pc, sp);
        });
        if(docrash)
        {
            crash();
        }
        systemstack([=]() mutable -> void
        {
            exit(2);
        });
        *(int*)(nullptr) = 0;
    }

    bool startpanic_m()
    {
        auto gp = getg();
        if(mheap_.cachealloc.size == 0)
        {
            print("runtime: panic before malloc heap initialized\n");
        }
        gp->m->mallocing++;
        if(gp->m->locks < 0)
        {
            gp->m->locks = 1;
        }
        //Go switch emulation
        {
            auto condition = gp->m->dying;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    gp->m->dying = 1;
                    rec::Add(gocpp::recv(panicking), 1);
                    lock(& paniclk);
                    if(debug.schedtrace > 0 || debug.scheddetail > 0)
                    {
                        schedtrace(true);
                    }
                    freezetheworld();
                    return true;
                    break;
                case 1:
                    gp->m->dying = 2;
                    print("panic during panic\n");
                    return false;
                    break;
                case 2:
                    gp->m->dying = 3;
                    print("stack trace unavailable\n");
                    exit(4);
                default:
                    exit(5);
                    return false;
                    break;
            }
        }
    }

    bool didothers;
    mutex deadlock;
    bool dopanic_m(struct g* gp, uintptr_t pc, uintptr_t sp)
    {
        if(gp->sig != 0)
        {
            auto signame = signame(gp->sig);
            if(signame != "")
            {
                print("[signal ", signame);
            }
            else
            {
                print("[signal ", hex(gp->sig));
            }
            print(" code=", hex(gp->sigcode0), " addr=", hex(gp->sigcode1), " pc=", hex(gp->sigpc), "]\n");
        }
        auto [level, all, docrash] = gotraceback();
        if(level > 0)
        {
            if(gp != gp->m->curg)
            {
                all = true;
            }
            if(gp != gp->m->g0)
            {
                print("\n");
                goroutineheader(gp);
                traceback(pc, sp, 0, gp);
            }
            else
            if(level >= 2 || gp->m->throwing >= throwTypeRuntime)
            {
                print("\nruntime stack:\n");
                traceback(pc, sp, 0, gp);
            }
            if(! didothers && all)
            {
                didothers = true;
                tracebackothers(gp);
            }
        }
        unlock(& paniclk);
        if(rec::Add(gocpp::recv(panicking), - 1) != 0)
        {
            lock(& deadlock);
            lock(& deadlock);
        }
        printDebugLog();
        return docrash;
    }

    bool canpanic()
    {
        auto gp = getg();
        auto mp = acquirem();
        if(gp != mp->curg)
        {
            releasem(mp);
            return false;
        }
        if(mp->locks != 1 || mp->mallocing != 0 || mp->throwing != throwTypeNone || mp->preemptoff != "" || mp->dying != 0)
        {
            releasem(mp);
            return false;
        }
        auto status = readgstatus(gp);
        if(status &^ _Gscan != _Grunning || gp->syscallsp != 0)
        {
            releasem(mp);
            return false;
        }
        if(GOOS == "windows" && mp->libcallsp != 0)
        {
            releasem(mp);
            return false;
        }
        releasem(mp);
        return true;
    }

    bool shouldPushSigpanic(struct g* gp, uintptr_t pc, uintptr_t lr)
    {
        if(pc == 0)
        {
            return false;
        }
        if(gp->m->incgo || rec::valid(gocpp::recv(findfunc(pc))))
        {
            return true;
        }
        if(rec::valid(gocpp::recv(findfunc(lr))))
        {
            return false;
        }
        return true;
    }

    bool isAbortPC(uintptr_t pc)
    {
        auto f = findfunc(pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return false;
        }
        return f.funcID == abi::FuncID_abort;
    }

}

