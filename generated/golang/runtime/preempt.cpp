// generated by GoCpp from file '$(ImportDir)/runtime/preempt.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/preempt.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/symtabinl.h"
#include "golang/runtime/time_nofake.h"

namespace golang::runtime
{
    
    std::ostream& suspendGState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g;
        os << " " << dead;
        os << " " << stopped;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const suspendGState& value)
    {
        return value.PrintTo(os);
    }

    suspendGState suspendG(g* gp)
    {
        if(auto mp = getg()->m; mp->curg != nullptr && readgstatus(mp->curg) == _Grunning)
        {
            go_throw("suspendG from non-preemptible goroutine");
        }
        auto yieldDelay = 10 * 1000;
        int64_t nextYield = {};
        auto stopped = false;
        m* asyncM = {};
        uint32_t asyncGen = {};
        int64_t nextPreemptM = {};
        for(auto i = 0; ; i++)
        {
            //Go switch emulation
            {
                auto s = readgstatus(gp);
                auto condition = s;
                int conditionId = -1;
                else if(condition == _Gdead) { conditionId = 0; }
                else if(condition == _Gcopystack) { conditionId = 1; }
                else if(condition == _Gpreempted) { conditionId = 2; }
                else if(condition == _Grunnable) { conditionId = 3; }
                else if(condition == _Gsyscall) { conditionId = 4; }
                else if(condition == _Gwaiting) { conditionId = 5; }
                else if(condition == _Grunning) { conditionId = 6; }
                switch(conditionId)
                {
                    default:
                        if(s & _Gscan != 0)
                        {
                            break;
                        }
                        dumpgstatus(gp);
                        go_throw("invalid g status");
                        break;
                    case 0:
                        return gocpp::Init<suspendGState>([](suspendGState& x) { x.dead = true; });
                        break;
                    case 1:
                        break;
                    case 2:
                        if(! casGFromPreempted(gp, _Gpreempted, _Gwaiting))
                        {
                            break;
                        }
                        stopped = true;
                        s = _Gwaiting;
                    case 3:
                    case 4:
                    case 5:
                        if(! castogscanstatus(gp, s, s | _Gscan))
                        {
                            break;
                        }
                        gp->preemptStop = false;
                        gp->preempt = false;
                        gp->stackguard0 = gp->stack.lo + stackGuard;
                        return gocpp::Init<suspendGState>([](suspendGState& x) { x.g = gp; x.stopped = stopped; });
                        break;
                    case 6:
                        if(gp->preemptStop && gp->preempt && gp->stackguard0 == stackPreempt && asyncM == gp->m && Load(gocpp::recv(asyncM->preemptGen)) == asyncGen)
                        {
                            break;
                        }
                        if(! castogscanstatus(gp, _Grunning, _Gscanrunning))
                        {
                            break;
                        }
                        gp->preemptStop = true;
                        gp->preempt = true;
                        gp->stackguard0 = stackPreempt;
                        auto asyncM2 = gp->m;
                        auto asyncGen2 = Load(gocpp::recv(asyncM2->preemptGen));
                        auto needAsync = asyncM != asyncM2 || asyncGen != asyncGen2;
                        asyncM = asyncM2;
                        asyncGen = asyncGen2;
                        casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning);
                        if(preemptMSupported && debug.asyncpreemptoff == 0 && needAsync)
                        {
                            auto now = nanotime();
                            if(now >= nextPreemptM)
                            {
                                nextPreemptM = now + yieldDelay / 2;
                                preemptM(asyncM);
                            }
                        }
                        break;
                }
            }
            if(i == 0)
            {
                nextYield = nanotime() + yieldDelay;
            }
            if(nanotime() < nextYield)
            {
                procyield(10);
            }
            else
            {
                osyield();
                nextYield = nanotime() + yieldDelay / 2;
            }
        }
    }

    void resumeG(suspendGState state)
    {
        if(state.dead)
        {
            return;
        }
        auto gp = state.g;
        //Go switch emulation
        {
            auto s = readgstatus(gp);
            auto condition = s;
            int conditionId = -1;
            else if(condition == _Grunnable | _Gscan) { conditionId = 0; }
            else if(condition == _Gwaiting | _Gscan) { conditionId = 1; }
            else if(condition == _Gsyscall | _Gscan) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    dumpgstatus(gp);
                    go_throw("unexpected g status");
                    break;
                case 0:
                case 1:
                case 2:
                    casfrom_Gscanstatus(gp, s, s &^ _Gscan);
                    break;
            }
        }
        if(state.stopped)
        {
            ready(gp, 0, true);
        }
    }

    bool canPreemptM(m* mp)
    {
        return mp->locks == 0 && mp->mallocing == 0 && mp->preemptoff == "" && ptr(gocpp::recv(mp->p))->status == _Prunning;
    }

    void asyncPreempt()
    /* convertBlockStmt, nil block */;

    void asyncPreempt2()
    {
        auto gp = getg();
        gp->asyncSafePoint = true;
        if(gp->preemptStop)
        {
            mcall(preemptPark);
        }
        else
        {
            mcall(gopreempt_m);
        }
        gp->asyncSafePoint = false;
    }

    uintptr_t asyncPreemptStack = ^ uintptr(0);
    void init()
    {
        auto f = findfunc(FuncPCABI0(gocpp::recv(abi), asyncPreempt));
        auto total = funcMaxSPDelta(f);
        f = findfunc(FuncPCABIInternal(gocpp::recv(abi), asyncPreempt2));
        total += funcMaxSPDelta(f);
        asyncPreemptStack = uintptr(total) + 8 * goarch.PtrSize;
        if(asyncPreemptStack > stackNosplit)
        {
            print("runtime: asyncPreemptStack=", asyncPreemptStack, "\n");
            go_throw("async stack too large");
        }
    }

    bool wantAsyncPreempt(g* gp)
    {
        return (gp->preempt || gp->m->p != 0 && ptr(gocpp::recv(gp->m->p))->preempt) && readgstatus(gp) &^ _Gscan == _Grunning;
    }

    std::tuple<bool, uintptr_t> isAsyncSafePoint(g* gp, uintptr_t pc, uintptr_t sp, uintptr_t lr)
    {
        auto mp = gp->m;
        if(mp->curg != gp)
        {
            return {false, 0};
        }
        if(mp->p == 0 || ! canPreemptM(mp))
        {
            return {false, 0};
        }
        if(sp < gp->stack.lo || sp - gp->stack.lo < asyncPreemptStack)
        {
            return {false, 0};
        }
        auto f = findfunc(pc);
        if(! valid(gocpp::recv(f)))
        {
            return {false, 0};
        }
        if((GOARCH == "mips" || GOARCH == "mipsle" || GOARCH == "mips64" || GOARCH == "mips64le") && lr == pc + 8 && funcspdelta(f, pc) == 0)
        {
            return {false, 0};
        }
        auto [up, startpc] = pcdatavalue2(f, abi.PCDATA_UnsafePoint, pc);
        if(up == abi.UnsafePointUnsafe)
        {
            return {false, 0};
        }
        if(auto fd = funcdata(f, abi.FUNCDATA_LocalsPointerMaps); fd == nullptr || f.flag & abi.FuncFlagAsm != 0)
        {
            return {false, 0};
        }
        auto [u, uf] = newInlineUnwinder(f, pc);
        auto name = name(gocpp::recv(srcFunc(gocpp::recv(u), uf)));
        if(hasPrefix(name, "runtime.") || hasPrefix(name, "runtime/internal/") || hasPrefix(name, "reflect."))
        {
            return {false, 0};
        }
        //Go switch emulation
        {
            auto condition = up;
            int conditionId = -1;
            if(condition == abi.UnsafePointRestart1) { conditionId = 0; }
            if(condition == abi.UnsafePointRestart2) { conditionId = 1; }
            else if(condition == abi.UnsafePointRestartAtEntry) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    if(startpc == 0 || startpc > pc || pc - startpc > 20)
                    {
                        go_throw("bad restart PC");
                    }
                    return {true, startpc};
                    break;
                case 2:
                    return {true, entry(gocpp::recv(f))};
                    break;
            }
        }
        return {true, pc};
    }

}

