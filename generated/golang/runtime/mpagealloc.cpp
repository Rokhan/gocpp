// generated by GoCpp from file '$(ImportDir)/runtime/mpagealloc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mpagealloc.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc_64bit.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/print.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace cpu::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    struct offAddr maxSearchAddr()
    {
        return maxOffAddr;
    }

    runtime::chunkIdx chunkIndex(uintptr_t p)
    {
        return chunkIdx((p - arenaBaseOffset) / pallocChunkBytes);
    }

    uintptr_t chunkBase(golang::runtime::chunkIdx ci)
    {
        return uintptr_t(ci) * pallocChunkBytes + arenaBaseOffset;
    }

    unsigned int chunkPageIndex(uintptr_t p)
    {
        return (unsigned int)(p % pallocChunkBytes / pageSize);
    }

    unsigned int rec::l1(golang::runtime::chunkIdx i)
    {
        if(pallocChunksL1Bits == 0)
        {
            return 0;
        }
        else
        {
            return (unsigned int)(i) >> pallocChunksL1Shift;
        }
    }

    unsigned int rec::l2(golang::runtime::chunkIdx i)
    {
        if(pallocChunksL1Bits == 0)
        {
            return (unsigned int)(i);
        }
        else
        {
            return (unsigned int)(i) & ((1 << pallocChunksL2Bits) - 1);
        }
    }

    int offAddrToLevelIndex(int level, struct offAddr addr)
    {
        return int((addr.a - arenaBaseOffset) >> levelShift[level]);
    }

    struct offAddr levelIndexToOffAddr(int level, int idx)
    {
        return offAddr {(uintptr_t(idx) << levelShift[level]) + arenaBaseOffset};
    }

    std::tuple<int, int> addrsToSummaryRange(int level, uintptr_t base, uintptr_t limit)
    {
        int lo;
        int hi;
        lo = int((base - arenaBaseOffset) >> levelShift[level]);
        hi = int(((limit - 1) - arenaBaseOffset) >> levelShift[level]) + 1;
        return {lo, hi};
    }

    std::tuple<int, int> blockAlignSummaryRange(int level, int lo, int hi)
    {
        auto e = uintptr_t(1) << levelBits[level];
        return {int(alignDown(uintptr_t(lo), e)), int(alignUp(uintptr_t(hi), e))};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.index = this->index;
        result.releasedBg = this->releasedBg;
        result.releasedEager = this->releasedEager;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (index != ref.index) return false;
        if (releasedBg != ref.releasedBg) return false;
        if (releasedEager != ref.releasedEager) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << index;
        os << " " << releasedBg;
        os << " " << releasedEager;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    pageAlloc::operator T()
    {
        T result;
        result.summary = this->summary;
        result.chunks = this->chunks;
        result.searchAddr = this->searchAddr;
        result.start = this->start;
        result.end = this->end;
        result.inUse = this->inUse;
        result.scav = this->scav;
        result.mheapLock = this->mheapLock;
        result.sysStat = this->sysStat;
        result.summaryMappedReady = this->summaryMappedReady;
        result.chunkHugePages = this->chunkHugePages;
        result.test = this->test;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pageAlloc::operator==(const T& ref) const
    {
        if (summary != ref.summary) return false;
        if (chunks != ref.chunks) return false;
        if (searchAddr != ref.searchAddr) return false;
        if (start != ref.start) return false;
        if (end != ref.end) return false;
        if (inUse != ref.inUse) return false;
        if (scav != ref.scav) return false;
        if (mheapLock != ref.mheapLock) return false;
        if (sysStat != ref.sysStat) return false;
        if (summaryMappedReady != ref.summaryMappedReady) return false;
        if (chunkHugePages != ref.chunkHugePages) return false;
        if (test != ref.test) return false;
        return true;
    }

    std::ostream& pageAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << summary;
        os << " " << chunks;
        os << " " << searchAddr;
        os << " " << start;
        os << " " << end;
        os << " " << inUse;
        os << " " << scav;
        os << " " << mheapLock;
        os << " " << sysStat;
        os << " " << summaryMappedReady;
        os << " " << chunkHugePages;
        os << " " << test;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pageAlloc& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct pageAlloc* p, struct mutex* mheapLock, golang::runtime::sysMemStat* sysStat, bool test)
    {
        if(levelLogPages[0] > logMaxPackedValue)
        {
            print("runtime: root level max pages = ", 1 << levelLogPages[0], "\n");
            print("runtime: summary max pages = ", maxPackedValue, "\n");
            go_throw("root level max pages doesn't fit in summary");
        }
        p->sysStat = sysStat;
        rec::init(gocpp::recv(p->inUse), sysStat);
        rec::sysInit(gocpp::recv(p), test);
        p->searchAddr = maxSearchAddr();
        p->mheapLock = mheapLock;
        p->summaryMappedReady += rec::init(gocpp::recv(p->scav.index), test, sysStat);
        p->test = test;
    }

    struct pallocData* rec::tryChunkOf(struct pageAlloc* p, golang::runtime::chunkIdx ci)
    {
        auto l2 = p->chunks[rec::l1(gocpp::recv(ci))];
        if(l2 == nullptr)
        {
            return nullptr;
        }
        return & l2[rec::l2(gocpp::recv(ci))];
    }

    struct pallocData* rec::chunkOf(struct pageAlloc* p, golang::runtime::chunkIdx ci)
    {
        return & p->chunks[rec::l1(gocpp::recv(ci))][rec::l2(gocpp::recv(ci))];
    }

    void rec::grow(struct pageAlloc* p, uintptr_t base, uintptr_t size)
    {
        assertLockHeld(p->mheapLock);
        auto limit = alignUp(base + size, pallocChunkBytes);
        base = alignDown(base, pallocChunkBytes);
        rec::sysGrow(gocpp::recv(p), base, limit);
        p->summaryMappedReady += rec::grow(gocpp::recv(p->scav.index), base, limit, p->sysStat);
        auto firstGrowth = p->start == 0;
        auto [start, end] = std::tuple{chunkIndex(base), chunkIndex(limit)};
        if(firstGrowth || start < p->start)
        {
            p->start = start;
        }
        if(end > p->end)
        {
            p->end = end;
        }
        rec::add(gocpp::recv(p->inUse), makeAddrRange(base, limit));
        if(auto b = (offAddr {base}); rec::lessThan(gocpp::recv(b), p->searchAddr))
        {
            p->searchAddr = b;
        }
        for(auto c = chunkIndex(base); c < chunkIndex(limit); c++)
        {
            if(p->chunks[rec::l1(gocpp::recv(c))] == nullptr)
            {
                auto l2Size = gocpp::Sizeof<gocpp::array<runtime::pallocData, 8192>>();
                auto r = sysAlloc(l2Size, p->sysStat);
                if(r == nullptr)
                {
                    go_throw("pageAlloc: out of memory");
                }
                if(! p->test)
                {
                    if(p->chunkHugePages)
                    {
                        sysHugePage(r, l2Size);
                    }
                    else
                    {
                        sysNoHugePage(r, l2Size);
                    }
                }
                *(uintptr_t*)(unsafe::Pointer(& p->chunks[rec::l1(gocpp::recv(c))])) = uintptr_t(r);
            }
            rec::setRange(gocpp::recv(rec::chunkOf(gocpp::recv(p), c)->scavenged), 0, pallocChunkPages);
        }
        rec::update(gocpp::recv(p), base, size / pageSize, true, false);
    }

    void rec::enableChunkHugePages(struct pageAlloc* p)
    {
        lock(& mheap_.lock);
        if(p->chunkHugePages)
        {
            unlock(& mheap_.lock);
            return;
        }
        p->chunkHugePages = true;
        addrRanges inUse = {};
        inUse.sysStat = p->sysStat;
        rec::cloneInto(gocpp::recv(p->inUse), & inUse);
        unlock(& mheap_.lock);
        for(auto [gocpp_ignored, r] : p->inUse.ranges)
        {
            for(auto i = rec::l1(gocpp::recv(chunkIndex(rec::addr(gocpp::recv(r.base))))); i < rec::l1(gocpp::recv(chunkIndex(rec::addr(gocpp::recv(r.limit)) - 1))); i++)
            {
                sysHugePage(unsafe::Pointer(p->chunks[i]), gocpp::Sizeof<gocpp::array<runtime::pallocData, 8192>>());
            }
        }
    }

    void rec::update(struct pageAlloc* p, uintptr_t base, uintptr_t npages, bool contig, bool alloc)
    {
        assertLockHeld(p->mheapLock);
        auto limit = base + npages * pageSize - 1;
        auto [sc, ec] = std::tuple{chunkIndex(base), chunkIndex(limit)};
        if(sc == ec)
        {
            auto x = p->summary[len(p->summary) - 1][sc];
            auto y = rec::summarize(gocpp::recv(rec::chunkOf(gocpp::recv(p), sc)));
            if(x == y)
            {
                return;
            }
            p->summary[len(p->summary) - 1][sc] = y;
        }
        else
        if(contig)
        {
            auto summary = p->summary[len(p->summary) - 1];
            summary[sc] = rec::summarize(gocpp::recv(rec::chunkOf(gocpp::recv(p), sc)));
            auto whole = p->summary[len(p->summary) - 1].make_slice(sc + 1, ec);
            if(alloc)
            {
                for(auto [i, gocpp_ignored] : whole)
                {
                    whole[i] = 0;
                }
            }
            else
            {
                for(auto [i, gocpp_ignored] : whole)
                {
                    whole[i] = freeChunkSum;
                }
            }
            summary[ec] = rec::summarize(gocpp::recv(rec::chunkOf(gocpp::recv(p), ec)));
        }
        else
        {
            auto summary = p->summary[len(p->summary) - 1];
            for(auto c = sc; c <= ec; c++)
            {
                summary[c] = rec::summarize(gocpp::recv(rec::chunkOf(gocpp::recv(p), c)));
            }
        }
        auto changed = true;
        for(auto l = len(p->summary) - 2; l >= 0 && changed; l--)
        {
            changed = false;
            auto logEntriesPerBlock = levelBits[l + 1];
            auto logMaxPages = levelLogPages[l + 1];
            auto [lo, hi] = addrsToSummaryRange(l, base, limit + 1);
            for(auto i = lo; i < hi; i++)
            {
                auto children = p->summary[l + 1].make_slice(i << logEntriesPerBlock, (i + 1) << logEntriesPerBlock);
                auto sum = mergeSummaries(children, logMaxPages);
                auto old = p->summary[l][i];
                if(old != sum)
                {
                    changed = true;
                    p->summary[l][i] = sum;
                }
            }
        }
    }

    uintptr_t rec::allocRange(struct pageAlloc* p, uintptr_t base, uintptr_t npages)
    {
        assertLockHeld(p->mheapLock);
        auto limit = base + npages * pageSize - 1;
        auto [sc, ec] = std::tuple{chunkIndex(base), chunkIndex(limit)};
        auto [si, ei] = std::tuple{chunkPageIndex(base), chunkPageIndex(limit)};
        auto scav = (unsigned int)(0);
        if(sc == ec)
        {
            auto chunk = rec::chunkOf(gocpp::recv(p), sc);
            scav += rec::popcntRange(gocpp::recv(chunk->scavenged), si, ei + 1 - si);
            rec::allocRange(gocpp::recv(chunk), si, ei + 1 - si);
            rec::alloc(gocpp::recv(p->scav.index), sc, ei + 1 - si);
        }
        else
        {
            auto chunk = rec::chunkOf(gocpp::recv(p), sc);
            scav += rec::popcntRange(gocpp::recv(chunk->scavenged), si, pallocChunkPages - si);
            rec::allocRange(gocpp::recv(chunk), si, pallocChunkPages - si);
            rec::alloc(gocpp::recv(p->scav.index), sc, pallocChunkPages - si);
            for(auto c = sc + 1; c < ec; c++)
            {
                auto chunk = rec::chunkOf(gocpp::recv(p), c);
                scav += rec::popcntRange(gocpp::recv(chunk->scavenged), 0, pallocChunkPages);
                rec::allocAll(gocpp::recv(chunk));
                rec::alloc(gocpp::recv(p->scav.index), c, pallocChunkPages);
            }
            chunk = rec::chunkOf(gocpp::recv(p), ec);
            scav += rec::popcntRange(gocpp::recv(chunk->scavenged), 0, ei + 1);
            rec::allocRange(gocpp::recv(chunk), 0, ei + 1);
            rec::alloc(gocpp::recv(p->scav.index), ec, ei + 1);
        }
        rec::update(gocpp::recv(p), base, npages, true, true);
        return uintptr_t(scav) * pageSize;
    }

    struct offAddr rec::findMappedAddr(struct pageAlloc* p, struct offAddr addr)
    {
        assertLockHeld(p->mheapLock);
        auto ai = arenaIndex(rec::addr(gocpp::recv(addr)));
        if(p->test || mheap_.arenas[rec::l1(gocpp::recv(ai))] == nullptr || mheap_.arenas[rec::l1(gocpp::recv(ai))][rec::l2(gocpp::recv(ai))] == nullptr)
        {
            auto [vAddr, ok] = rec::findAddrGreaterEqual(gocpp::recv(p->inUse), rec::addr(gocpp::recv(addr)));
            if(ok)
            {
                return offAddr {vAddr};
            }
            else
            {
                return maxOffAddr;
            }
        }
        return addr;
    }

    struct gocpp_id_1
        {
            offAddr base;
            offAddr bound;

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                result.base = this->base;
                result.bound = this->bound;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                if (base != ref.base) return false;
                if (bound != ref.bound) return false;
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << base;
                os << " " << bound;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    std::tuple<uintptr_t, struct offAddr> rec::find(struct pageAlloc* p, uintptr_t npages)
    {
        assertLockHeld(p->mheapLock);
        auto i = 0;
        auto firstFree = gocpp::Init<gocpp_id_1>([](auto& x) {
            x.base = minOffAddr;
            x.bound = maxOffAddr;
        });
        auto foundFree = [=](struct offAddr addr, uintptr_t size) mutable -> void
        {
            if(rec::lessEqual(gocpp::recv(firstFree.base), addr) && rec::lessEqual(gocpp::recv(rec::add(gocpp::recv(addr), size - 1)), firstFree.bound))
            {
                firstFree.base = addr;
                firstFree.bound = rec::add(gocpp::recv(addr), size - 1);
            }
            else
            if(! (rec::lessThan(gocpp::recv(rec::add(gocpp::recv(addr), size - 1)), firstFree.base) || rec::lessThan(gocpp::recv(firstFree.bound), addr)))
            {
                print("runtime: addr = ", hex(rec::addr(gocpp::recv(addr))), ", size = ", size, "\n");
                print("runtime: base = ", hex(rec::addr(gocpp::recv(firstFree.base))), ", bound = ", hex(rec::addr(gocpp::recv(firstFree.bound))), "\n");
                go_throw("range partially overlaps");
            }
        };
        auto lastSum = packPallocSum(0, 0, 0);
        auto lastSumIdx = - 1;
        nextLevel:
        for(auto l = 0; l < len(p->summary); l++)
        {
            auto entriesPerBlock = 1 << levelBits[l];
            auto logMaxPages = levelLogPages[l];
            i <<= levelBits[l];
            auto entries = p->summary[l].make_slice(i, i + entriesPerBlock);
            auto j0 = 0;
            if(auto searchIdx = offAddrToLevelIndex(l, p->searchAddr); searchIdx &^ (entriesPerBlock - 1) == i)
            {
                j0 = searchIdx & (entriesPerBlock - 1);
            }
            unsigned int base = {};
            unsigned int size = {};
            for(auto j = j0; j < len(entries); j++)
            {
                auto sum = entries[j];
                if(sum == 0)
                {
                    size = 0;
                    continue;
                }
                foundFree(levelIndexToOffAddr(l, i + j), (uintptr_t(1) << logMaxPages) * pageSize);
                auto s = rec::start(gocpp::recv(sum));
                if(size + s >= (unsigned int)(npages))
                {
                    if(size == 0)
                    {
                        base = (unsigned int)(j) << logMaxPages;
                    }
                    size += s;
                    break;
                }
                if(rec::max(gocpp::recv(sum)) >= (unsigned int)(npages))
                {
                    i += j;
                    lastSumIdx = i;
                    lastSum = sum;
                    goto nextLevel_continue;
                }
                if(size == 0 || s < (1 << logMaxPages))
                {
                    size = rec::end(gocpp::recv(sum));
                    base = ((unsigned int)(j + 1) << logMaxPages) - size;
                    continue;
                }
                size += 1 << logMaxPages;
            }
            if(size >= (unsigned int)(npages))
            {
                auto addr = rec::addr(gocpp::recv(rec::add(gocpp::recv(levelIndexToOffAddr(l, i)), uintptr_t(base) * pageSize)));
                return {addr, rec::findMappedAddr(gocpp::recv(p), firstFree.base)};
            }
            if(l == 0)
            {
                return {0, maxSearchAddr()};
            }
            print("runtime: summary[", l - 1, "][", lastSumIdx, "] = ", rec::start(gocpp::recv(lastSum)), ", ", rec::max(gocpp::recv(lastSum)), ", ", rec::end(gocpp::recv(lastSum)), "\n");
            print("runtime: level = ", l, ", npages = ", npages, ", j0 = ", j0, "\n");
            print("runtime: p.searchAddr = ", hex(rec::addr(gocpp::recv(p->searchAddr))), ", i = ", i, "\n");
            print("runtime: levelShift[level] = ", levelShift[l], ", levelBits[level] = ", levelBits[l], "\n");
            for(auto j = 0; j < len(entries); j++)
            {
                auto sum = entries[j];
                print("runtime: summary[", l, "][", i + j, "] = (", rec::start(gocpp::recv(sum)), ", ", rec::max(gocpp::recv(sum)), ", ", rec::end(gocpp::recv(sum)), ")\n");
            }
            go_throw("bad summary data");
            if(false) {
            nextLevel_continue:
                continue;
            nextLevel_break:
                break;
            }
        }
        auto ci = chunkIdx(i);
        auto [j, searchIdx] = rec::find(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)), npages, 0);
        if(j == ~ (unsigned int)(0))
        {
            auto sum = p->summary[len(p->summary) - 1][i];
            print("runtime: summary[", len(p->summary) - 1, "][", i, "] = (", rec::start(gocpp::recv(sum)), ", ", rec::max(gocpp::recv(sum)), ", ", rec::end(gocpp::recv(sum)), ")\n");
            print("runtime: npages = ", npages, "\n");
            go_throw("bad summary data");
        }
        auto addr = chunkBase(ci) + uintptr_t(j) * pageSize;
        auto searchAddr = chunkBase(ci) + uintptr_t(searchIdx) * pageSize;
        foundFree(offAddr {searchAddr}, chunkBase(ci + 1) - searchAddr);
        return {addr, rec::findMappedAddr(gocpp::recv(p), firstFree.base)};
    }

    std::tuple<uintptr_t, uintptr_t> rec::alloc(struct pageAlloc* p, uintptr_t npages)
    {
        uintptr_t addr;
        uintptr_t scav;
        assertLockHeld(p->mheapLock);
        if(chunkIndex(rec::addr(gocpp::recv(p->searchAddr))) >= p->end)
        {
            uintptr_t addr;
            uintptr_t scav;
            return {0, 0};
        }
        auto searchAddr = minOffAddr;
        if(pallocChunkPages - chunkPageIndex(rec::addr(gocpp::recv(p->searchAddr))) >= (unsigned int)(npages))
        {
            uintptr_t addr;
            uintptr_t scav;
            auto i = chunkIndex(rec::addr(gocpp::recv(p->searchAddr)));
            if(auto max = rec::max(gocpp::recv(p->summary[len(p->summary) - 1][i])); max >= (unsigned int)(npages))
            {
                uintptr_t addr;
                uintptr_t scav;
                auto [j, searchIdx] = rec::find(gocpp::recv(rec::chunkOf(gocpp::recv(p), i)), npages, chunkPageIndex(rec::addr(gocpp::recv(p->searchAddr))));
                if(j == ~ (unsigned int)(0))
                {
                    uintptr_t addr;
                    uintptr_t scav;
                    print("runtime: max = ", max, ", npages = ", npages, "\n");
                    print("runtime: searchIdx = ", chunkPageIndex(rec::addr(gocpp::recv(p->searchAddr))), ", p.searchAddr = ", hex(rec::addr(gocpp::recv(p->searchAddr))), "\n");
                    go_throw("bad summary data");
                }
                addr = chunkBase(i) + uintptr_t(j) * pageSize;
                searchAddr = offAddr {chunkBase(i) + uintptr_t(searchIdx) * pageSize};
                goto Found;
            }
        }
        std::tie(addr, searchAddr) = rec::find(gocpp::recv(p), npages);
        if(addr == 0)
        {
            uintptr_t addr;
            uintptr_t scav;
            if(npages == 1)
            {
                uintptr_t addr;
                uintptr_t scav;
                p->searchAddr = maxSearchAddr();
            }
            return {0, 0};
        }
        Found:
        scav = rec::allocRange(gocpp::recv(p), addr, npages);
        if(rec::lessThan(gocpp::recv(p->searchAddr), searchAddr))
        {
            uintptr_t addr;
            uintptr_t scav;
            p->searchAddr = searchAddr;
        }
        return {addr, scav};
    }

    void rec::free(struct pageAlloc* p, uintptr_t base, uintptr_t npages)
    {
        assertLockHeld(p->mheapLock);
        if(auto b = (offAddr {base}); rec::lessThan(gocpp::recv(b), p->searchAddr))
        {
            p->searchAddr = b;
        }
        auto limit = base + npages * pageSize - 1;
        if(npages == 1)
        {
            auto i = chunkIndex(base);
            auto pi = chunkPageIndex(base);
            rec::free1(gocpp::recv(rec::chunkOf(gocpp::recv(p), i)), pi);
            rec::free(gocpp::recv(p->scav.index), i, pi, 1);
        }
        else
        {
            auto [sc, ec] = std::tuple{chunkIndex(base), chunkIndex(limit)};
            auto [si, ei] = std::tuple{chunkPageIndex(base), chunkPageIndex(limit)};
            if(sc == ec)
            {
                rec::free(gocpp::recv(rec::chunkOf(gocpp::recv(p), sc)), si, ei + 1 - si);
                rec::free(gocpp::recv(p->scav.index), sc, si, ei + 1 - si);
            }
            else
            {
                rec::free(gocpp::recv(rec::chunkOf(gocpp::recv(p), sc)), si, pallocChunkPages - si);
                rec::free(gocpp::recv(p->scav.index), sc, si, pallocChunkPages - si);
                for(auto c = sc + 1; c < ec; c++)
                {
                    rec::freeAll(gocpp::recv(rec::chunkOf(gocpp::recv(p), c)));
                    rec::free(gocpp::recv(p->scav.index), c, 0, pallocChunkPages);
                }
                rec::free(gocpp::recv(rec::chunkOf(gocpp::recv(p), ec)), 0, ei + 1);
                rec::free(gocpp::recv(p->scav.index), ec, 0, ei + 1);
            }
        }
        rec::update(gocpp::recv(p), base, npages, true, false);
    }

    runtime::pallocSum packPallocSum(unsigned int start, unsigned int max, unsigned int end)
    {
        if(max == maxPackedValue)
        {
            return pallocSum(uint64_t(1 << 63));
        }
        return pallocSum((uint64_t(start) & (maxPackedValue - 1)) | ((uint64_t(max) & (maxPackedValue - 1)) << logMaxPackedValue) | ((uint64_t(end) & (maxPackedValue - 1)) << (2 * logMaxPackedValue)));
    }

    unsigned int rec::start(golang::runtime::pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return maxPackedValue;
        }
        return (unsigned int)(uint64_t(p) & (maxPackedValue - 1));
    }

    unsigned int rec::max(golang::runtime::pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return maxPackedValue;
        }
        return (unsigned int)((uint64_t(p) >> logMaxPackedValue) & (maxPackedValue - 1));
    }

    unsigned int rec::end(golang::runtime::pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return maxPackedValue;
        }
        return (unsigned int)((uint64_t(p) >> (2 * logMaxPackedValue)) & (maxPackedValue - 1));
    }

    std::tuple<unsigned int, unsigned int, unsigned int> rec::unpack(golang::runtime::pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return {maxPackedValue, maxPackedValue, maxPackedValue};
        }
        return {(unsigned int)(uint64_t(p) & (maxPackedValue - 1)), (unsigned int)((uint64_t(p) >> logMaxPackedValue) & (maxPackedValue - 1)), (unsigned int)((uint64_t(p) >> (2 * logMaxPackedValue)) & (maxPackedValue - 1))};
    }

    runtime::pallocSum mergeSummaries(gocpp::slice<golang::runtime::pallocSum> sums, unsigned int logMaxPagesPerSum)
    {
        auto [start, most, end] = rec::unpack(gocpp::recv(sums[0]));
        for(auto i = 1; i < len(sums); i++)
        {
            auto [si, mi, ei] = rec::unpack(gocpp::recv(sums[i]));
            if(start == ((unsigned int)(i) << logMaxPagesPerSum))
            {
                start += si;
            }
            most = max(most, end + si, mi);
            if(ei == (1 << logMaxPagesPerSum))
            {
                end += 1 << logMaxPagesPerSum;
            }
            else
            {
                end = ei;
            }
        }
        return packPallocSum(start, most, end);
    }

}

