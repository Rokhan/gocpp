// generated by GoCpp from file '$(ImportDir)/sync/atomic/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/atomic/type.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/doc.h"
#include "golang/unsafe/unsafe.h"

namespace golang::atomic
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Bool is an atomic boolean value.
    // The zero value is false.
    
    template<typename T> requires gocpp::GoStruct<T>
    Bool::operator T()
    {
        T result;
        result._1 = this->_1;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Bool::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Bool::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Bool& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    bool rec::Load(struct Bool* x)
    {
        return LoadUint32(& x->v) != 0;
    }

    // Store atomically stores val into x.
    void rec::Store(struct Bool* x, bool val)
    {
        StoreUint32(& x->v, b32(val));
    }

    // Swap atomically stores new into x and returns the previous value.
    bool rec::Swap(struct Bool* x, bool go_new)
    {
        bool old;
        return SwapUint32(& x->v, b32(go_new)) != 0;
    }

    // CompareAndSwap executes the compare-and-swap operation for the boolean value x.
    bool rec::CompareAndSwap(struct Bool* x, bool old, bool go_new)
    {
        bool swapped;
        return CompareAndSwapUint32(& x->v, b32(old), b32(go_new));
    }

    // b32 returns a uint32 0 or 1 representing b.
    uint32_t b32(bool b)
    {
        if(b)
        {
            return 1;
        }
        return 0;
    }

    // For testing *Pointer[T]'s methods can be inlined.
    // Keep in sync with cmd/compile/internal/test/inl_test.go:TestIntendedInlining.
    atomic::Pointer<int>* gocpp_id_0 = new atomic::Pointer<int> {};
    // A Pointer is an atomic pointer of type *T. The zero value is a nil *T.
    
    template<typename T>
    template<typename U> requires gocpp::GoStruct<U>
    Pointer<T>::operator U()
    {
        U result;
        result._1 = this->_1;
        result._2 = this->_2;
        result.v = this->v;
        return result;
    }

    template<typename T>
    template<typename U> requires gocpp::GoStruct<U>
    bool Pointer<T>::operator==(const U& ref) const
    {
        if (_1 != ref._1) return false;
        if (_2 != ref._2) return false;
        if (v != ref.v) return false;
        return true;
    }

    template<typename T>
    std::ostream& Pointer<T>::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << _2;
        os << " " << v;
        os << '}';
        return os;
    }

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const struct Pointer<T>& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    template<typename T>
    T* rec::Load(golang::atomic::Pointer<T>* x)
    {
        return (T*)(LoadPointer(& x->v));
    }

    // Store atomically stores val into x.
    template<typename T>
    void rec::Store(golang::atomic::Pointer<T>* x, T* val)
    {
        StorePointer(& x->v, unsafe::Pointer(val));
    }

    // Swap atomically stores new into x and returns the previous value.
    template<typename T>
    T* rec::Swap(golang::atomic::Pointer<T>* x, T* go_new)
    {
        T* old;
        return (T*)(SwapPointer(& x->v, unsafe::Pointer(go_new)));
    }

    // CompareAndSwap executes the compare-and-swap operation for x.
    template<typename T>
    bool rec::CompareAndSwap(golang::atomic::Pointer<T>* x, T* old, T* go_new)
    {
        bool swapped;
        return CompareAndSwapPointer(& x->v, unsafe::Pointer(old), unsafe::Pointer(go_new));
    }

    // An Int32 is an atomic int32. The zero value is zero.
    
    template<typename T> requires gocpp::GoStruct<T>
    Int32::operator T()
    {
        T result;
        result._1 = this->_1;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Int32::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Int32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Int32& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    int32_t rec::Load(struct Int32* x)
    {
        return LoadInt32(& x->v);
    }

    // Store atomically stores val into x.
    void rec::Store(struct Int32* x, int32_t val)
    {
        StoreInt32(& x->v, val);
    }

    // Swap atomically stores new into x and returns the previous value.
    int32_t rec::Swap(struct Int32* x, int32_t go_new)
    {
        int32_t old;
        return SwapInt32(& x->v, go_new);
    }

    // CompareAndSwap executes the compare-and-swap operation for x.
    bool rec::CompareAndSwap(struct Int32* x, int32_t old, int32_t go_new)
    {
        bool swapped;
        return CompareAndSwapInt32(& x->v, old, go_new);
    }

    // Add atomically adds delta to x and returns the new value.
    int32_t rec::Add(struct Int32* x, int32_t delta)
    {
        int32_t go_new;
        return AddInt32(& x->v, delta);
    }

    // An Int64 is an atomic int64. The zero value is zero.
    
    template<typename T> requires gocpp::GoStruct<T>
    Int64::operator T()
    {
        T result;
        result._1 = this->_1;
        result._2 = this->_2;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Int64::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (_2 != ref._2) return false;
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Int64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << _2;
        os << " " << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Int64& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    int64_t rec::Load(struct Int64* x)
    {
        return LoadInt64(& x->v);
    }

    // Store atomically stores val into x.
    void rec::Store(struct Int64* x, int64_t val)
    {
        StoreInt64(& x->v, val);
    }

    // Swap atomically stores new into x and returns the previous value.
    int64_t rec::Swap(struct Int64* x, int64_t go_new)
    {
        int64_t old;
        return SwapInt64(& x->v, go_new);
    }

    // CompareAndSwap executes the compare-and-swap operation for x.
    bool rec::CompareAndSwap(struct Int64* x, int64_t old, int64_t go_new)
    {
        bool swapped;
        return CompareAndSwapInt64(& x->v, old, go_new);
    }

    // Add atomically adds delta to x and returns the new value.
    int64_t rec::Add(struct Int64* x, int64_t delta)
    {
        int64_t go_new;
        return AddInt64(& x->v, delta);
    }

    // A Uint32 is an atomic uint32. The zero value is zero.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uint32::operator T()
    {
        T result;
        result._1 = this->_1;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uint32::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Uint32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint32& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    uint32_t rec::Load(struct Uint32* x)
    {
        return LoadUint32(& x->v);
    }

    // Store atomically stores val into x.
    void rec::Store(struct Uint32* x, uint32_t val)
    {
        StoreUint32(& x->v, val);
    }

    // Swap atomically stores new into x and returns the previous value.
    uint32_t rec::Swap(struct Uint32* x, uint32_t go_new)
    {
        uint32_t old;
        return SwapUint32(& x->v, go_new);
    }

    // CompareAndSwap executes the compare-and-swap operation for x.
    bool rec::CompareAndSwap(struct Uint32* x, uint32_t old, uint32_t go_new)
    {
        bool swapped;
        return CompareAndSwapUint32(& x->v, old, go_new);
    }

    // Add atomically adds delta to x and returns the new value.
    uint32_t rec::Add(struct Uint32* x, uint32_t delta)
    {
        uint32_t go_new;
        return AddUint32(& x->v, delta);
    }

    // A Uint64 is an atomic uint64. The zero value is zero.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uint64::operator T()
    {
        T result;
        result._1 = this->_1;
        result._2 = this->_2;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uint64::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (_2 != ref._2) return false;
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Uint64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << _2;
        os << " " << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint64& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    uint64_t rec::Load(struct Uint64* x)
    {
        return LoadUint64(& x->v);
    }

    // Store atomically stores val into x.
    void rec::Store(struct Uint64* x, uint64_t val)
    {
        StoreUint64(& x->v, val);
    }

    // Swap atomically stores new into x and returns the previous value.
    uint64_t rec::Swap(struct Uint64* x, uint64_t go_new)
    {
        uint64_t old;
        return SwapUint64(& x->v, go_new);
    }

    // CompareAndSwap executes the compare-and-swap operation for x.
    bool rec::CompareAndSwap(struct Uint64* x, uint64_t old, uint64_t go_new)
    {
        bool swapped;
        return CompareAndSwapUint64(& x->v, old, go_new);
    }

    // Add atomically adds delta to x and returns the new value.
    uint64_t rec::Add(struct Uint64* x, uint64_t delta)
    {
        uint64_t go_new;
        return AddUint64(& x->v, delta);
    }

    // A Uintptr is an atomic uintptr. The zero value is zero.
    
    template<typename T> requires gocpp::GoStruct<T>
    Uintptr::operator T()
    {
        T result;
        result._1 = this->_1;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Uintptr::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Uintptr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uintptr& value)
    {
        return value.PrintTo(os);
    }

    // Load atomically loads and returns the value stored in x.
    uintptr_t rec::Load(struct Uintptr* x)
    {
        return LoadUintptr(& x->v);
    }

    // Store atomically stores val into x.
    void rec::Store(struct Uintptr* x, uintptr_t val)
    {
        StoreUintptr(& x->v, val);
    }

    // Swap atomically stores new into x and returns the previous value.
    uintptr_t rec::Swap(struct Uintptr* x, uintptr_t go_new)
    {
        uintptr_t old;
        return SwapUintptr(& x->v, go_new);
    }

    // CompareAndSwap executes the compare-and-swap operation for x.
    bool rec::CompareAndSwap(struct Uintptr* x, uintptr_t old, uintptr_t go_new)
    {
        bool swapped;
        return CompareAndSwapUintptr(& x->v, old, go_new);
    }

    // Add atomically adds delta to x and returns the new value.
    uintptr_t rec::Add(struct Uintptr* x, uintptr_t delta)
    {
        uintptr_t go_new;
        return AddUintptr(& x->v, delta);
    }

    // noCopy may be added to structs which must not be copied
    // after the first use.
    //
    // See https://golang.org/issues/8005#issuecomment-190753527
    // for details.
    //
    // Note that it must not be embedded, due to the Lock and Unlock methods.
    
    template<typename T> requires gocpp::GoStruct<T>
    noCopy::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noCopy::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noCopy::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value)
    {
        return value.PrintTo(os);
    }

    // Lock is a no-op used by -copylocks checker from `go vet`.
    void rec::Lock(noCopy*)
    {
    }

    void rec::Unlock(noCopy*)
    {
    }

    // align64 may be added to structs that must be 64-bit aligned.
    // This struct is recognized by a special case in the compiler
    // and will not work if copied to any other package.
    
    template<typename T> requires gocpp::GoStruct<T>
    align64::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool align64::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& align64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct align64& value)
    {
        return value.PrintTo(os);
    }

}

