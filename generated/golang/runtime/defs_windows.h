// generated by GoCpp from file '$(ImportDir)/runtime/defs_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/defs_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/defs_windows_amd64.h"

namespace golang::runtime
{
    struct systeminfo
    {
        gocpp::array<unsigned char, 4> anon0;
        uint32_t dwpagesize;
        unsigned char* lpminimumapplicationaddress;
        unsigned char* lpmaximumapplicationaddress;
        uintptr_t dwactiveprocessormask;
        uint32_t dwnumberofprocessors;
        uint32_t dwprocessortype;
        uint32_t dwallocationgranularity;
        uint16_t wprocessorlevel;
        uint16_t wprocessorrevision;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct systeminfo& value);
    struct exceptionpointers
    {
        exceptionrecord* record;
        context* context;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct exceptionpointers& value);
    struct exceptionrecord
    {
        uint32_t exceptioncode;
        uint32_t exceptionflags;
        exceptionrecord* exceptionrecord;
        uintptr_t exceptionaddress;
        uint32_t numberparameters;
        gocpp::array<uintptr_t, 15> exceptioninformation;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct exceptionrecord& value);
    struct overlapped
    {
        uintptr_t internal;
        uintptr_t internalhigh;
        gocpp::array<unsigned char, 8> anon0;
        unsigned char* hevent;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct overlapped& value);
    struct memoryBasicInformation
    {
        uintptr_t baseAddress;
        uintptr_t allocationBase;
        uint32_t allocationProtect;
        uintptr_t regionSize;
        uint32_t state;
        uint32_t protect;
        uint32_t type_;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct memoryBasicInformation& value);
}

