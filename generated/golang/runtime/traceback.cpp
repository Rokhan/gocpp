// generated by GoCpp from file '$(ImportDir)/runtime/traceback.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/traceback.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/alg.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/symtabinl.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // tracebackInnerFrames is the number of innermost frames to print in a
    // stack trace. The total maximum frames is tracebackInnerFrames +
    // tracebackOuterFrames.
    // tracebackOuterFrames is the number of outermost frames to print in a
    // stack trace.
    // unwindFlags control the behavior of various unwinders.
    // unwindPrintErrors indicates that if unwinding encounters an error, it
    // should print a message and stop without throwing. This is used for things
    // like stack printing, where it's better to get incomplete information than
    // to crash. This is also used in situations where everything may not be
    // stopped nicely and the stack walk may not be able to complete, such as
    // during profiling signals or during a crash.
    //
    // If neither unwindPrintErrors or unwindSilentErrors are set, unwinding
    // performs extra consistency checks and throws on any error.
    //
    // Note that there are a small number of fatal situations that will throw
    // regardless of unwindPrintErrors or unwindSilentErrors.
    // unwindSilentErrors silently ignores errors during unwinding.
    // unwindTrap indicates that the initial PC and SP are from a trap, not a
    // return PC from a call.
    //
    // The unwindTrap flag is updated during unwinding. If set, frame.pc is the
    // address of a faulting instruction instead of the return address of a
    // call. It also means the liveness at pc may not be known.
    //
    // TODO: Distinguish frame.continpc, which is really the stack map PC, from
    // the actual continuation PC, which is computed differently depending on
    // this flag and a few other things.
    // unwindJumpStack indicates that, if the traceback is on a system stack, it
    // should resume tracing at the user stack when the system stack is
    // exhausted.
    // An unwinder iterates the physical stack frames of a Go sack.
    //
    // Typical use of an unwinder looks like:
    //
    //	var u unwinder
    //	for u.init(gp, 0); u.valid(); u.next() {
    //		// ... use frame info in u ...
    //	}
    //
    // Implementation note: This is carefully structured to be pointer-free because
    // tracebacks happen in places that disallow write barriers (e.g., signals).
    // Even if this is stack-allocated, its pointer-receiver methods don't know that
    // their receiver is on the stack, so they still emit write barriers. Here we
    // address that by carefully avoiding any pointers in this type. Another
    // approach would be to split this into a mutable part that's passed by pointer
    // but contains no pointers itself and an immutable part that's passed and
    // returned by value and can contain pointers. We could potentially hide that
    // we're doing that in trivial methods that are inlined into the caller that has
    // the stack allocation, but that's fragile.
    
    template<typename T> requires gocpp::GoStruct<T>
    unwinder::operator T()
    {
        T result;
        result.frame = this->frame;
        result.g = this->g;
        result.cgoCtxt = this->cgoCtxt;
        result.calleeFuncID = this->calleeFuncID;
        result.flags = this->flags;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool unwinder::operator==(const T& ref) const
    {
        if (frame != ref.frame) return false;
        if (g != ref.g) return false;
        if (cgoCtxt != ref.cgoCtxt) return false;
        if (calleeFuncID != ref.calleeFuncID) return false;
        if (flags != ref.flags) return false;
        return true;
    }

    std::ostream& unwinder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << frame;
        os << " " << g;
        os << " " << cgoCtxt;
        os << " " << calleeFuncID;
        os << " " << flags;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct unwinder& value)
    {
        return value.PrintTo(os);
    }

    // init initializes u to start unwinding gp's stack and positions the
    // iterator on gp's innermost frame. gp must not be the current G.
    //
    // A single unwinder can be reused for multiple unwinds.
    void rec::init(struct unwinder* u, struct g* gp, golang::runtime::unwindFlags flags)
    {
        rec::initAt(gocpp::recv(u), ~ uintptr_t(0), ~ uintptr_t(0), ~ uintptr_t(0), gp, flags);
    }

    void rec::initAt(struct unwinder* u, uintptr_t pc0, uintptr_t sp0, uintptr_t lr0, struct g* gp, golang::runtime::unwindFlags flags)
    {
        if(auto ourg = getg(); ourg == gp && ourg == ourg->m->curg)
        {
            go_throw("cannot trace user goroutine on its own stack"s);
        }
        if(pc0 == ~ uintptr_t(0) && sp0 == ~ uintptr_t(0))
        {
            if(gp->syscallsp != 0)
            {
                pc0 = gp->syscallpc;
                sp0 = gp->syscallsp;
                if(usesLR)
                {
                    lr0 = 0;
                }
            }
            else
            {
                pc0 = gp->sched.pc;
                sp0 = gp->sched.sp;
                if(usesLR)
                {
                    lr0 = gp->sched.lr;
                }
            }
        }
        stkframe frame = {};
        frame.pc = pc0;
        frame.sp = sp0;
        if(usesLR)
        {
            frame.lr = lr0;
        }
        if(frame.pc == 0)
        {
            if(usesLR)
            {
                frame.pc = *(uintptr_t*)(unsafe::Pointer(frame.sp));
                frame.lr = 0;
            }
            else
            {
                frame.pc = *(uintptr_t*)(unsafe::Pointer(frame.sp));
                frame.sp += goarch::PtrSize;
            }
        }
        if(GOARCH == "arm"s && goarm < 7 && GOOS == "linux"s && frame.pc & 0xffff0000 == 0xffff0000)
        {
            frame.pc = frame.lr;
            frame.lr = 0;
        }
        auto f = findfunc(frame.pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            if(flags & unwindSilentErrors == 0)
            {
                print("runtime: g "s, gp->goid, " gp="s, gp, ": unknown pc "s, hex(frame.pc), "\n"s);
                tracebackHexdump(gp->stack, & frame, 0);
            }
            if(flags & (unwindPrintErrors | unwindSilentErrors) == 0)
            {
                go_throw("unknown pc"s);
            }
            *u = unwinder {};
            return;
        }
        frame.fn = f;
        *u = gocpp::Init<unwinder>([=](auto& x) {
            x.frame = frame;
            x.g = rec::guintptr(gocpp::recv(gp));
            x.cgoCtxt = len(gp->cgoCtxt) - 1;
            x.calleeFuncID = abi::FuncIDNormal;
            x.flags = flags;
        });
        auto isSyscall = frame.pc == pc0 && frame.sp == sp0 && pc0 == gp->syscallpc && sp0 == gp->syscallsp;
        rec::resolveInternal(gocpp::recv(u), true, isSyscall);
    }

    bool rec::valid(struct unwinder* u)
    {
        return u->frame.pc != 0;
    }

    // resolveInternal fills in u.frame based on u.frame.fn, pc, and sp.
    //
    // innermost indicates that this is the first resolve on this stack. If
    // innermost is set, isSyscall indicates that the PC/SP was retrieved from
    // gp.syscall*; this is otherwise ignored.
    //
    // On entry, u.frame contains:
    //   - fn is the running function.
    //   - pc is the PC in the running function.
    //   - sp is the stack pointer at that program counter.
    //   - For the innermost frame on LR machines, lr is the program counter that called fn.
    //
    // On return, u.frame contains:
    //   - fp is the stack pointer of the caller.
    //   - lr is the program counter that called fn.
    //   - varp, argp, and continpc are populated for the current frame.
    //
    // If fn is a stack-jumping function, resolveInternal can change the entire
    // frame state to follow that stack jump.
    //
    // This is internal to unwinder.
    void rec::resolveInternal(struct unwinder* u, bool innermost, bool isSyscall)
    {
        auto frame = & u->frame;
        auto gp = rec::ptr(gocpp::recv(u->g));
        auto f = frame->fn;
        if(f.pcsp == 0)
        {
            rec::finishInternal(gocpp::recv(u));
            return;
        }
        auto flag = f.flag;
        if(f.funcID == abi::FuncID_cgocallback)
        {
            flag &^= abi::FuncFlagSPWrite;
        }
        if(isSyscall)
        {
            flag &^= abi::FuncFlagSPWrite;
        }
        if(frame->fp == 0)
        {
            if(u->flags & unwindJumpStack != 0 && gp == gp->m->g0 && gp->m->curg != nullptr && gp->m->curg->m == gp->m)
            {
                //Go switch emulation
                {
                    auto condition = f.funcID;
                    int conditionId = -1;
                    if(condition == abi::FuncID_morestack) { conditionId = 0; }
                    else if(condition == abi::FuncID_systemstack) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                            gp = gp->m->curg;
                            rec::set(gocpp::recv(u->g), gp);
                            frame->pc = gp->sched.pc;
                            frame->fn = findfunc(frame->pc);
                            f = frame->fn;
                            flag = f.flag;
                            frame->lr = gp->sched.lr;
                            frame->sp = gp->sched.sp;
                            u->cgoCtxt = len(gp->cgoCtxt) - 1;
                            break;
                        case 1:
                            if(usesLR && funcspdelta(f, frame->pc) == 0)
                            {
                                flag &^= abi::FuncFlagSPWrite;
                                break;
                            }
                            gp = gp->m->curg;
                            rec::set(gocpp::recv(u->g), gp);
                            frame->sp = gp->sched.sp;
                            u->cgoCtxt = len(gp->cgoCtxt) - 1;
                            flag &^= abi::FuncFlagSPWrite;
                            break;
                    }
                }
            }
            frame->fp = frame->sp + uintptr_t(funcspdelta(f, frame->pc));
            if(! usesLR)
            {
                frame->fp += goarch::PtrSize;
            }
        }
        if(flag & abi::FuncFlagTopFrame != 0)
        {
            frame->lr = 0;
        }
        else
        if(flag & abi::FuncFlagSPWrite != 0 && (! innermost || u->flags & (unwindPrintErrors | unwindSilentErrors) != 0))
        {
            if(u->flags & (unwindPrintErrors | unwindSilentErrors) == 0 && ! innermost)
            {
                println("traceback: unexpected SPWRITE function"s, funcname(f));
                go_throw("traceback"s);
            }
            frame->lr = 0;
        }
        else
        {
            uintptr_t lrPtr = {};
            if(usesLR)
            {
                if(innermost && frame->sp < frame->fp || frame->lr == 0)
                {
                    lrPtr = frame->sp;
                    frame->lr = *(uintptr_t*)(unsafe::Pointer(lrPtr));
                }
            }
            else
            {
                if(frame->lr == 0)
                {
                    lrPtr = frame->fp - goarch::PtrSize;
                    frame->lr = *(uintptr_t*)(unsafe::Pointer(lrPtr));
                }
            }
        }
        frame->varp = frame->fp;
        if(! usesLR)
        {
            frame->varp -= goarch::PtrSize;
        }
        if(frame->varp > frame->sp && framepointer_enabled)
        {
            frame->varp -= goarch::PtrSize;
        }
        frame->argp = frame->fp + sys::MinFrameSize;
        frame->continpc = frame->pc;
        if(u->calleeFuncID == abi::FuncID_sigpanic)
        {
            if(frame->fn.deferreturn != 0)
            {
                frame->continpc = rec::entry(gocpp::recv(frame->fn)) + uintptr_t(frame->fn.deferreturn) + 1;
            }
            else
            {
                frame->continpc = 0;
            }
        }
    }

    void rec::next(struct unwinder* u)
    {
        auto frame = & u->frame;
        auto f = frame->fn;
        auto gp = rec::ptr(gocpp::recv(u->g));
        if(frame->lr == 0)
        {
            rec::finishInternal(gocpp::recv(u));
            return;
        }
        auto flr = findfunc(frame->lr);
        if(! rec::valid(gocpp::recv(flr)))
        {
            auto fail = u->flags & (unwindPrintErrors | unwindSilentErrors) == 0;
            auto doPrint = u->flags & unwindSilentErrors == 0;
            if(doPrint && gp->m->incgo && f.funcID == abi::FuncID_sigpanic)
            {
                doPrint = false;
            }
            if(fail || doPrint)
            {
                print("runtime: g "s, gp->goid, ": unexpected return pc for "s, funcname(f), " called from "s, hex(frame->lr), "\n"s);
                tracebackHexdump(gp->stack, frame, 0);
            }
            if(fail)
            {
                go_throw("unknown caller pc"s);
            }
            frame->lr = 0;
            rec::finishInternal(gocpp::recv(u));
            return;
        }
        if(frame->pc == frame->lr && frame->sp == frame->fp)
        {
            print("runtime: traceback stuck. pc="s, hex(frame->pc), " sp="s, hex(frame->sp), "\n"s);
            tracebackHexdump(gp->stack, frame, frame->sp);
            go_throw("traceback stuck"s);
        }
        auto injectedCall = f.funcID == abi::FuncID_sigpanic || f.funcID == abi::FuncID_asyncPreempt || f.funcID == abi::FuncID_debugCallV2;
        if(injectedCall)
        {
            u->flags |= unwindTrap;
        }
        else
        {
            u->flags &^= unwindTrap;
        }
        u->calleeFuncID = f.funcID;
        frame->fn = flr;
        frame->pc = frame->lr;
        frame->lr = 0;
        frame->sp = frame->fp;
        frame->fp = 0;
        if(usesLR && injectedCall)
        {
            auto x = *(uintptr_t*)(unsafe::Pointer(frame->sp));
            frame->sp += alignUp(sys::MinFrameSize, sys::StackAlign);
            f = findfunc(frame->pc);
            frame->fn = f;
            if(! rec::valid(gocpp::recv(f)))
            {
                frame->pc = x;
            }
            else
            if(funcspdelta(f, frame->pc) == 0)
            {
                frame->lr = x;
            }
        }
        rec::resolveInternal(gocpp::recv(u), false, false);
    }

    // finishInternal is an unwinder-internal helper called after the stack has been
    // exhausted. It sets the unwinder to an invalid state and checks that it
    // successfully unwound the entire stack.
    void rec::finishInternal(struct unwinder* u)
    {
        u->frame.pc = 0;
        auto gp = rec::ptr(gocpp::recv(u->g));
        if(u->flags & (unwindPrintErrors | unwindSilentErrors) == 0 && u->frame.sp != gp->stktopsp)
        {
            print("runtime: g"s, gp->goid, ": frame.sp="s, hex(u->frame.sp), " top="s, hex(gp->stktopsp), "\n"s);
            print("\tstack=["s, hex(gp->stack.lo), "-"s, hex(gp->stack.hi), "\n"s);
            go_throw("traceback did not unwind completely"s);
        }
    }

    // symPC returns the PC that should be used for symbolizing the current frame.
    // Specifically, this is the PC of the last instruction executed in this frame.
    //
    // If this frame did a normal call, then frame.pc is a return PC, so this will
    // return frame.pc-1, which points into the CALL instruction. If the frame was
    // interrupted by a signal (e.g., profiler, segv, etc) then frame.pc is for the
    // trapped instruction, so this returns frame.pc. See issue #34123. Finally,
    // frame.pc can be at function entry when the frame is initialized without
    // actually running code, like in runtime.mstart, in which case this returns
    // frame.pc because that's the best we can do.
    uintptr_t rec::symPC(struct unwinder* u)
    {
        if(u->flags & unwindTrap == 0 && u->frame.pc > rec::entry(gocpp::recv(u->frame.fn)))
        {
            return u->frame.pc - 1;
        }
        return u->frame.pc;
    }

    // cgoCallers populates pcBuf with the cgo callers of the current frame using
    // the registered cgo unwinder. It returns the number of PCs written to pcBuf.
    // If the current frame is not a cgo frame or if there's no registered cgo
    // unwinder, it returns 0.
    int rec::cgoCallers(struct unwinder* u, gocpp::slice<uintptr_t> pcBuf)
    {
        if(cgoTraceback == nullptr || u->frame.fn.funcID != abi::FuncID_cgocallback || u->cgoCtxt < 0)
        {
            return 0;
        }
        auto ctxt = rec::ptr(gocpp::recv(u->g))->cgoCtxt[u->cgoCtxt];
        u->cgoCtxt--;
        cgoContextPCs(ctxt, pcBuf);
        for(auto [i, pc] : pcBuf)
        {
            if(pc == 0)
            {
                return i;
            }
        }
        return len(pcBuf);
    }

    // tracebackPCs populates pcBuf with the return addresses for each frame from u
    // and returns the number of PCs written to pcBuf. The returned PCs correspond
    // to "logical frames" rather than "physical frames"; that is if A is inlined
    // into B, this will still return a PCs for both A and B. This also includes PCs
    // generated by the cgo unwinder, if one is registered.
    //
    // If skip != 0, this skips this many logical frames.
    //
    // Callers should set the unwindSilentErrors flag on u.
    int tracebackPCs(struct unwinder* u, int skip, gocpp::slice<uintptr_t> pcBuf)
    {
        gocpp::array<uintptr_t, 32> cgoBuf = {};
        auto n = 0;
        for(; n < len(pcBuf) && rec::valid(gocpp::recv(u)); rec::next(gocpp::recv(u)))
        {
            auto f = u->frame.fn;
            auto cgoN = rec::cgoCallers(gocpp::recv(u), cgoBuf.make_slice(0));
            for(auto [iu, uf] = newInlineUnwinder(f, rec::symPC(gocpp::recv(u))); n < len(pcBuf) && rec::valid(gocpp::recv(uf)); uf = rec::next(gocpp::recv(iu), uf))
            {
                auto sf = rec::srcFunc(gocpp::recv(iu), uf);
                if(sf.funcID == abi::FuncIDWrapper && elideWrapperCalling(u->calleeFuncID))
                {
                }
                else
                if(skip > 0)
                {
                    skip--;
                }
                else
                {
                    pcBuf[n] = uf.pc + 1;
                    n++;
                }
                u->calleeFuncID = sf.funcID;
            }
            if(skip == 0)
            {
                n += copy(pcBuf.make_slice(n), cgoBuf.make_slice(0, cgoN));
            }
        }
        return n;
    }

    // printArgs prints function arguments in traceback.
    void printArgs(struct funcInfo f, unsafe::Pointer argp, uintptr_t pc)
    {
        // The "instruction" of argument printing is encoded in _FUNCDATA_ArgInfo.
        // See cmd/compile/internal/ssagen.emitArgInfo for the description of the
        // encoding.
        // These constants need to be in sync with the compiler.
        auto _endSeq = 0xff;
        auto _startAgg = 0xfe;
        auto _endAgg = 0xfd;
        auto _dotdotdot = 0xfc;
        auto _offsetTooLarge = 0xfb;
        auto limit = 10;
        auto maxDepth = 5;
        auto maxLen = (maxDepth * 3 + 2) * limit + 1;
        auto p = (gocpp::array<uint8_t, maxLen>*)(funcdata(f, abi::FUNCDATA_ArgInfo));
        if(p == nullptr)
        {
            return;
        }
        auto liveInfo = funcdata(f, abi::FUNCDATA_ArgLiveInfo);
        auto liveIdx = pcdatavalue(f, abi::PCDATA_ArgLiveIndex, pc);
        auto startOffset = uint8_t(0xff);
        if(liveInfo != nullptr)
        {
            startOffset = *(uint8_t*)(liveInfo);
        }
        auto isLive = [=](uint8_t off, uint8_t slotIdx) mutable -> bool
        {
            if(liveInfo == nullptr || liveIdx <= 0)
            {
                return true;
            }
            if(off < startOffset)
            {
                return true;
            }
            auto bits = *(uint8_t*)(add(liveInfo, uintptr_t(liveIdx) + uintptr_t(slotIdx / 8)));
            return bits & (1 << (slotIdx % 8)) != 0;
        };
        auto print1 = [=](uint8_t off, uint8_t sz, uint8_t slotIdx) mutable -> void
        {
            auto x = readUnaligned64(add(argp, uintptr_t(off)));
            if(sz < 8)
            {
                auto shift = 64 - sz * 8;
                if(goarch::BigEndian)
                {
                    x = x >> shift;
                }
                else
                {
                    x = (x << shift) >> shift;
                }
            }
            print(hex(x));
            if(! isLive(off, slotIdx))
            {
                print("?"s);
            }
        };
        auto start = true;
        auto printcomma = [=]() mutable -> void
        {
            if(! start)
            {
                print(", "s);
            }
        };
        auto pi = 0;
        auto slotIdx = uint8_t(0);
        printloop:
        for(; ; )
        {
            auto o = p[pi];
            pi++;
            //Go switch emulation
            {
                auto condition = o;
                int conditionId = -1;
                if(condition == _endSeq) { conditionId = 0; }
                else if(condition == _startAgg) { conditionId = 1; }
                else if(condition == _endAgg) { conditionId = 2; }
                else if(condition == _dotdotdot) { conditionId = 3; }
                else if(condition == _offsetTooLarge) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                        goto printloop_break;
                        break;
                    case 1:
                        printcomma();
                        print("{"s);
                        start = true;
                        continue;
                        break;
                    case 2:
                        print("}"s);
                        break;
                    case 3:
                        printcomma();
                        print("..."s);
                        break;
                    case 4:
                        printcomma();
                        print("_"s);
                        break;
                    default:
                        printcomma();
                        auto sz = p[pi];
                        pi++;
                        print1(o, sz, slotIdx);
                        if(o >= startOffset)
                        {
                            slotIdx++;
                        }
                        break;
                }
            }
            start = false;
            if(false) {
            printloop_continue:
                continue;
            printloop_break:
                break;
            }
        }
    }

    // funcNamePiecesForPrint returns the function name for printing to the user.
    // It returns three pieces so it doesn't need an allocation for string
    // concatenation.
    std::tuple<std::string, std::string, std::string> funcNamePiecesForPrint(std::string name)
    {
        auto i = bytealg::IndexByteString(name, '[');
        if(i < 0)
        {
            return {name, ""s, ""s};
        }
        auto j = len(name) - 1;
        for(; name[j] != ']'; )
        {
            j--;
        }
        if(j <= i)
        {
            return {name, ""s, ""s};
        }
        return {name.make_slice(0, i), "[...]"s, name.make_slice(j + 1)};
    }

    // funcNameForPrint returns the function name for printing to the user.
    std::string funcNameForPrint(std::string name)
    {
        auto [a, b, c] = funcNamePiecesForPrint(name);
        return a + b + c;
    }

    // printFuncName prints a function name. name is the function name in
    // the binary's func data table.
    void printFuncName(std::string name)
    {
        if(name == "runtime.gopanic"s)
        {
            print("panic"s);
            return;
        }
        auto [a, b, c] = funcNamePiecesForPrint(name);
        print(a, b, c);
    }

    void printcreatedby(struct g* gp)
    {
        auto pc = gp->gopc;
        auto f = findfunc(pc);
        if(rec::valid(gocpp::recv(f)) && showframe(rec::srcFunc(gocpp::recv(f)), gp, false, abi::FuncIDNormal) && gp->goid != 1)
        {
            printcreatedby1(f, pc, gp->parentGoid);
        }
    }

    void printcreatedby1(struct funcInfo f, uintptr_t pc, uint64_t goid)
    {
        print("created by "s);
        printFuncName(funcname(f));
        if(goid != 0)
        {
            print(" in goroutine "s, goid);
        }
        print("\n"s);
        auto tracepc = pc;
        if(pc > rec::entry(gocpp::recv(f)))
        {
            tracepc -= sys::PCQuantum;
        }
        auto [file, line] = funcline(f, tracepc);
        print("\t"s, file, ":"s, line);
        if(pc > rec::entry(gocpp::recv(f)))
        {
            print(" +"s, hex(pc - rec::entry(gocpp::recv(f))));
        }
        print("\n"s);
    }

    void traceback(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp)
    {
        traceback1(pc, sp, lr, gp, 0);
    }

    // tracebacktrap is like traceback but expects that the PC and SP were obtained
    // from a trap, not from gp->sched or gp->syscallpc/gp->syscallsp or getcallerpc/getcallersp.
    // Because they are from a trap instead of from a saved pair,
    // the initial PC must not be rewound to the previous instruction.
    // (All the saved pairs record a PC that is a return address, so we
    // rewind it into the CALL instruction.)
    // If gp.m.libcall{g,pc,sp} information is available, it uses that information in preference to
    // the pc/sp/lr passed in.
    void tracebacktrap(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp)
    {
        if(gp->m->libcallsp != 0)
        {
            traceback1(gp->m->libcallpc, gp->m->libcallsp, 0, rec::ptr(gocpp::recv(gp->m->libcallg)), 0);
            return;
        }
        traceback1(pc, sp, lr, gp, unwindTrap);
    }

    void traceback1(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp, golang::runtime::unwindFlags flags)
    {
        if(iscgo && gp->m != nullptr && gp->m->ncgo > 0 && gp->syscallsp != 0 && gp->m->cgoCallers != nullptr && gp->m->cgoCallers[0] != 0)
        {
            rec::Store(gocpp::recv(gp->m->cgoCallersUse), 1);
            auto cgoCallers = *gp->m->cgoCallers;
            gp->m->cgoCallers[0] = 0;
            rec::Store(gocpp::recv(gp->m->cgoCallersUse), 0);
            printCgoTraceback(& cgoCallers);
        }
        if(readgstatus(gp) &^ _Gscan == _Gsyscall)
        {
            pc = gp->syscallpc;
            sp = gp->syscallsp;
            flags &^= unwindTrap;
        }
        if(gp->m != nullptr && gp->m->vdsoSP != 0)
        {
            pc = gp->m->vdsoPC;
            sp = gp->m->vdsoSP;
            flags &^= unwindTrap;
        }
        flags |= unwindPrintErrors;
        unwinder u = {};
        auto tracebackWithRuntime = [=](bool showRuntime) mutable -> int
        {
            int maxInt = 0x7fffffff;
            rec::initAt(gocpp::recv(u), pc, sp, lr, gp, flags);
            auto [n, lastN] = traceback2(& u, showRuntime, 0, tracebackInnerFrames);
            if(n < tracebackInnerFrames)
            {
                return n;
            }
            auto u2 = u;
            auto [remaining, gocpp_id_1] = traceback2(& u, showRuntime, maxInt, 0);
            auto elide = remaining - lastN - tracebackOuterFrames;
            if(elide > 0)
            {
                print("..."s, elide, " frames elided...\n"s);
                traceback2(& u2, showRuntime, lastN + elide, tracebackOuterFrames);
            }
            else
            if(elide <= 0)
            {
                traceback2(& u2, showRuntime, lastN, tracebackOuterFrames);
            }
            return n;
        };
        if(tracebackWithRuntime(false) == 0)
        {
            tracebackWithRuntime(true);
        }
        printcreatedby(gp);
        if(gp->ancestors == nullptr)
        {
            return;
        }
        for(auto [gocpp_ignored, ancestor] : *gp->ancestors)
        {
            printAncestorTraceback(ancestor);
        }
    }

    // traceback2 prints a stack trace starting at u. It skips the first "skip"
    // logical frames, after which it prints at most "max" logical frames. It
    // returns n, which is the number of logical frames skipped and printed, and
    // lastN, which is the number of logical frames skipped or printed just in the
    // physical frame that u references.
    std::tuple<int, int> traceback2(struct unwinder* u, bool showRuntime, int skip, int max)
    {
        int n;
        int lastN;
        auto commitFrame = [=]() mutable -> std::tuple<bool, bool>
        {
            bool pr;
            bool stop;
            if(skip == 0 && max == 0)
            {
                return {false, true};
            }
            n++;
            lastN++;
            if(skip > 0)
            {
                skip--;
                return {false, false};
            }
            max--;
            return {true, false};
        };
        auto gp = rec::ptr(gocpp::recv(u->g));
        auto [level, gocpp_id_4, gocpp_id_5] = gotraceback();
        gocpp::array<uintptr_t, 32> cgoBuf = {};
        for(; rec::valid(gocpp::recv(u)); rec::next(gocpp::recv(u)))
        {
            lastN = 0;
            auto f = u->frame.fn;
            for(auto [iu, uf] = newInlineUnwinder(f, rec::symPC(gocpp::recv(u))); rec::valid(gocpp::recv(uf)); uf = rec::next(gocpp::recv(iu), uf))
            {
                auto sf = rec::srcFunc(gocpp::recv(iu), uf);
                auto callee = u->calleeFuncID;
                u->calleeFuncID = sf.funcID;
                if(! (showRuntime || showframe(sf, gp, n == 0, callee)))
                {
                    continue;
                }
                if(auto [pr, stop] = commitFrame(); stop)
                {
                    return {n, lastN};
                }
                else
                if(! pr)
                {
                    continue;
                }
                auto name = rec::name(gocpp::recv(sf));
                auto [file, line] = rec::fileLine(gocpp::recv(iu), uf);
                printFuncName(name);
                print("("s);
                if(rec::isInlined(gocpp::recv(iu), uf))
                {
                    print("..."s);
                }
                else
                {
                    auto argp = unsafe::Pointer(u->frame.argp);
                    printArgs(f, argp, rec::symPC(gocpp::recv(u)));
                }
                print(")\n"s);
                print("\t"s, file, ":"s, line);
                if(! rec::isInlined(gocpp::recv(iu), uf))
                {
                    if(u->frame.pc > rec::entry(gocpp::recv(f)))
                    {
                        print(" +"s, hex(u->frame.pc - rec::entry(gocpp::recv(f))));
                    }
                    if(gp->m != nullptr && gp->m->throwing >= throwTypeRuntime && gp == gp->m->curg || level >= 2)
                    {
                        print(" fp="s, hex(u->frame.fp), " sp="s, hex(u->frame.sp), " pc="s, hex(u->frame.pc));
                    }
                }
                print("\n"s);
            }
            if(auto cgoN = rec::cgoCallers(gocpp::recv(u), cgoBuf.make_slice(0)); cgoN > 0)
            {
                cgoSymbolizerArg arg = {};
                auto anySymbolized = false;
                auto stop = false;
                for(auto [gocpp_ignored, pc] : cgoBuf.make_slice(0, cgoN))
                {
                    if(cgoSymbolizer == nullptr)
                    {
                        if(auto [pr, stop] = commitFrame(); stop)
                        {
                            break;
                        }
                        else
                        if(pr)
                        {
                            print("non-Go function at pc="s, hex(pc), "\n"s);
                        }
                    }
                    else
                    {
                        stop = printOneCgoTraceback(pc, commitFrame, & arg);
                        anySymbolized = true;
                        if(stop)
                        {
                            break;
                        }
                    }
                }
                if(anySymbolized)
                {
                    arg.pc = 0;
                    callCgoSymbolizer(& arg);
                }
                if(stop)
                {
                    return {n, lastN};
                }
            }
        }
        return {n, 0};
    }

    // printAncestorTraceback prints the traceback of the given ancestor.
    // TODO: Unify this with gentraceback and CallersFrames.
    void printAncestorTraceback(struct ancestorInfo ancestor)
    {
        print("[originating from goroutine "s, ancestor.goid, "]:\n"s);
        for(auto [fidx, pc] : ancestor.pcs)
        {
            auto f = findfunc(pc);
            if(showfuncinfo(rec::srcFunc(gocpp::recv(f)), fidx == 0, abi::FuncIDNormal))
            {
                printAncestorTracebackFuncInfo(f, pc);
            }
        }
        if(len(ancestor.pcs) == tracebackInnerFrames)
        {
            print("...additional frames elided...\n"s);
        }
        auto f = findfunc(ancestor.gopc);
        if(rec::valid(gocpp::recv(f)) && showfuncinfo(rec::srcFunc(gocpp::recv(f)), false, abi::FuncIDNormal) && ancestor.goid != 1)
        {
            printcreatedby1(f, ancestor.gopc, 0);
        }
    }

    // printAncestorTracebackFuncInfo prints the given function info at a given pc
    // within an ancestor traceback. The precision of this info is reduced
    // due to only have access to the pcs at the time of the caller
    // goroutine being created.
    void printAncestorTracebackFuncInfo(struct funcInfo f, uintptr_t pc)
    {
        auto [u, uf] = newInlineUnwinder(f, pc);
        auto [file, line] = rec::fileLine(gocpp::recv(u), uf);
        printFuncName(rec::name(gocpp::recv(rec::srcFunc(gocpp::recv(u), uf))));
        print("(...)\n"s);
        print("\t"s, file, ":"s, line);
        if(pc > rec::entry(gocpp::recv(f)))
        {
            print(" +"s, hex(pc - rec::entry(gocpp::recv(f))));
        }
        print("\n"s);
    }

    int callers(int skip, gocpp::slice<uintptr_t> pcbuf)
    {
        auto sp = getcallersp();
        auto pc = getcallerpc();
        auto gp = getg();
        int n = {};
        systemstack([=]() mutable -> void
        {
            unwinder u = {};
            rec::initAt(gocpp::recv(u), pc, sp, 0, gp, unwindSilentErrors);
            n = tracebackPCs(& u, skip, pcbuf);
        });
        return n;
    }

    int gcallers(struct g* gp, int skip, gocpp::slice<uintptr_t> pcbuf)
    {
        unwinder u = {};
        rec::init(gocpp::recv(u), gp, unwindSilentErrors);
        return tracebackPCs(& u, skip, pcbuf);
    }

    // showframe reports whether the frame with the given characteristics should
    // be printed during a traceback.
    bool showframe(struct srcFunc sf, struct g* gp, bool firstFrame, abi::FuncID calleeID)
    {
        auto mp = getg()->m;
        if(mp->throwing >= throwTypeRuntime && gp != nullptr && (gp == mp->curg || gp == rec::ptr(gocpp::recv(mp->caughtsig))))
        {
            return true;
        }
        return showfuncinfo(sf, firstFrame, calleeID);
    }

    // showfuncinfo reports whether a function with the given characteristics should
    // be printed during a traceback.
    bool showfuncinfo(struct srcFunc sf, bool firstFrame, abi::FuncID calleeID)
    {
        auto [level, gocpp_id_8, gocpp_id_9] = gotraceback();
        if(level > 1)
        {
            return true;
        }
        if(sf.funcID == abi::FuncIDWrapper && elideWrapperCalling(calleeID))
        {
            return false;
        }
        auto name = rec::name(gocpp::recv(sf));
        if(name == "runtime.gopanic"s && ! firstFrame)
        {
            return true;
        }
        return bytealg::IndexByteString(name, '.') >= 0 && (! hasPrefix(name, "runtime."s) || isExportedRuntime(name));
    }

    // isExportedRuntime reports whether name is an exported runtime function.
    // It is only for runtime functions, so ASCII A-Z is fine.
    // TODO: this handles exported functions but not exported methods.
    bool isExportedRuntime(std::string name)
    {
        auto n = len("runtime."s);
        return len(name) > n && name.make_slice(0, n) == "runtime."s && 'A' <= name[n] && name[n] <= 'Z';
    }

    // elideWrapperCalling reports whether a wrapper function that called
    // function id should be elided from stack traces.
    bool elideWrapperCalling(abi::FuncID id)
    {
        return ! (id == abi::FuncID_gopanic || id == abi::FuncID_sigpanic || id == abi::FuncID_panicwrap);
    }

    gocpp::array<std::string, 10> gStatusStrings = gocpp::Init<gocpp::array<std::string, 10>>([](auto& x) {
        x[_Gidle] = "idle"s;
        x[_Grunnable] = "runnable"s;
        x[_Grunning] = "running"s;
        x[_Gsyscall] = "syscall"s;
        x[_Gwaiting] = "waiting"s;
        x[_Gdead] = "dead"s;
        x[_Gcopystack] = "copystack"s;
        x[_Gpreempted] = "preempted"s;
    });
    void goroutineheader(struct g* gp)
    {
        auto [level, gocpp_id_12, gocpp_id_13] = gotraceback();
        auto gpstatus = readgstatus(gp);
        auto isScan = gpstatus & _Gscan != 0;
        gpstatus &^= _Gscan;
        // Basic string status
        std::string status = {};
        if(0 <= gpstatus && gpstatus < uint32_t(len(gStatusStrings)))
        {
            status = gStatusStrings[gpstatus];
        }
        else
        {
            status = "???"s;
        }
        if(gpstatus == _Gwaiting && gp->waitreason != waitReasonZero)
        {
            status = rec::String(gocpp::recv(gp->waitreason));
        }
        // approx time the G is blocked, in minutes
        int64_t waitfor = {};
        if((gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp->waitsince != 0)
        {
            waitfor = (nanotime() - gp->waitsince) / 60e9;
        }
        print("goroutine "s, gp->goid);
        if(gp->m != nullptr && gp->m->throwing >= throwTypeRuntime && gp == gp->m->curg || level >= 2)
        {
            print(" gp="s, gp);
            if(gp->m != nullptr)
            {
                print(" m="s, gp->m->id, " mp="s, gp->m);
            }
            else
            {
                print(" m=nil"s);
            }
        }
        print(" ["s, status);
        if(isScan)
        {
            print(" (scan)"s);
        }
        if(waitfor >= 1)
        {
            print(", "s, waitfor, " minutes"s);
        }
        if(gp->lockedm != 0)
        {
            print(", locked to thread"s);
        }
        print("]:\n"s);
    }

    void tracebackothers(struct g* me)
    {
        auto [level, gocpp_id_16, gocpp_id_17] = gotraceback();
        auto curgp = getg()->m->curg;
        if(curgp != nullptr && curgp != me)
        {
            print("\n"s);
            goroutineheader(curgp);
            traceback(~ uintptr_t(0), ~ uintptr_t(0), 0, curgp);
        }
        forEachGRace([=](struct g* gp) mutable -> void
        {
            if(gp == me || gp == curgp || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2)
            {
                return;
            }
            print("\n"s);
            goroutineheader(gp);
            if(gp->m != getg()->m && readgstatus(gp) &^ _Gscan == _Grunning)
            {
                print("\tgoroutine running on other thread; stack unavailable\n"s);
                printcreatedby(gp);
            }
            else
            {
                traceback(~ uintptr_t(0), ~ uintptr_t(0), 0, gp);
            }
        });
    }

    // tracebackHexdump hexdumps part of stk around frame.sp and frame.fp
    // for debugging purposes. If the address bad is included in the
    // hexdumped range, it will mark it as well.
    void tracebackHexdump(struct stack stk, struct stkframe* frame, uintptr_t bad)
    {
        auto expand = 32 * goarch::PtrSize;
        auto maxExpand = 256 * goarch::PtrSize;
        auto [lo, hi] = std::tuple{frame->sp, frame->sp};
        if(frame->fp != 0 && frame->fp < lo)
        {
            lo = frame->fp;
        }
        if(frame->fp != 0 && frame->fp > hi)
        {
            hi = frame->fp;
        }
        std::tie(lo, hi) = std::tuple{lo - expand, hi + expand};
        if(lo < frame->sp - maxExpand)
        {
            lo = frame->sp - maxExpand;
        }
        if(hi > frame->sp + maxExpand)
        {
            hi = frame->sp + maxExpand;
        }
        if(lo < stk.lo)
        {
            lo = stk.lo;
        }
        if(hi > stk.hi)
        {
            hi = stk.hi;
        }
        print("stack: frame={sp:"s, hex(frame->sp), ", fp:"s, hex(frame->fp), "} stack=["s, hex(stk.lo), ","s, hex(stk.hi), ")\n"s);
        hexdumpWords(lo, hi, [=](uintptr_t p) mutable -> unsigned char
        {
            //Go switch emulation
            {
                auto condition = p;
                int conditionId = -1;
                if(condition == frame->fp) { conditionId = 0; }
                else if(condition == frame->sp) { conditionId = 1; }
                else if(condition == bad) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        return '>';
                        break;
                    case 1:
                        return '<';
                        break;
                    case 2:
                        return '!';
                        break;
                }
            }
            return 0;
        });
    }

    // isSystemGoroutine reports whether the goroutine g must be omitted
    // in stack dumps and deadlock detector. This is any goroutine that
    // starts at a runtime.* entry point, except for runtime.main,
    // runtime.handleAsyncEvent (wasm only) and sometimes runtime.runfinq.
    //
    // If fixed is true, any goroutine that can vary between user and
    // system (that is, the finalizer goroutine) is considered a user
    // goroutine.
    bool isSystemGoroutine(struct g* gp, bool fixed)
    {
        auto f = findfunc(gp->startpc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return false;
        }
        if(f.funcID == abi::FuncID_runtime_main || f.funcID == abi::FuncID_corostart || f.funcID == abi::FuncID_handleAsyncEvent)
        {
            return false;
        }
        if(f.funcID == abi::FuncID_runfinq)
        {
            if(fixed)
            {
                return false;
            }
            return rec::Load(gocpp::recv(fingStatus)) & fingRunningFinalizer == 0;
        }
        return hasPrefix(funcname(f), "runtime."s);
    }

    // SetCgoTraceback records three C functions to use to gather
    // traceback information from C code and to convert that traceback
    // information into symbolic information. These are used when printing
    // stack traces for a program that uses cgo.
    //
    // The traceback and context functions may be called from a signal
    // handler, and must therefore use only async-signal safe functions.
    // The symbolizer function may be called while the program is
    // crashing, and so must be cautious about using memory.  None of the
    // functions may call back into Go.
    //
    // The context function will be called with a single argument, a
    // pointer to a struct:
    //
    //	struct {
    //		Context uintptr
    //	}
    //
    // In C syntax, this struct will be
    //
    //	struct {
    //		uintptr_t Context;
    //	};
    //
    // If the Context field is 0, the context function is being called to
    // record the current traceback context. It should record in the
    // Context field whatever information is needed about the current
    // point of execution to later produce a stack trace, probably the
    // stack pointer and PC. In this case the context function will be
    // called from C code.
    //
    // If the Context field is not 0, then it is a value returned by a
    // previous call to the context function. This case is called when the
    // context is no longer needed; that is, when the Go code is returning
    // to its C code caller. This permits the context function to release
    // any associated resources.
    //
    // While it would be correct for the context function to record a
    // complete a stack trace whenever it is called, and simply copy that
    // out in the traceback function, in a typical program the context
    // function will be called many times without ever recording a
    // traceback for that context. Recording a complete stack trace in a
    // call to the context function is likely to be inefficient.
    //
    // The traceback function will be called with a single argument, a
    // pointer to a struct:
    //
    //	struct {
    //		Context    uintptr
    //		SigContext uintptr
    //		Buf        *uintptr
    //		Max        uintptr
    //	}
    //
    // In C syntax, this struct will be
    //
    //	struct {
    //		uintptr_t  Context;
    //		uintptr_t  SigContext;
    //		uintptr_t* Buf;
    //		uintptr_t  Max;
    //	};
    //
    // The Context field will be zero to gather a traceback from the
    // current program execution point. In this case, the traceback
    // function will be called from C code.
    //
    // Otherwise Context will be a value previously returned by a call to
    // the context function. The traceback function should gather a stack
    // trace from that saved point in the program execution. The traceback
    // function may be called from an execution thread other than the one
    // that recorded the context, but only when the context is known to be
    // valid and unchanging. The traceback function may also be called
    // deeper in the call stack on the same thread that recorded the
    // context. The traceback function may be called multiple times with
    // the same Context value; it will usually be appropriate to cache the
    // result, if possible, the first time this is called for a specific
    // context value.
    //
    // If the traceback function is called from a signal handler on a Unix
    // system, SigContext will be the signal context argument passed to
    // the signal handler (a C ucontext_t* cast to uintptr_t). This may be
    // used to start tracing at the point where the signal occurred. If
    // the traceback function is not called from a signal handler,
    // SigContext will be zero.
    //
    // Buf is where the traceback information should be stored. It should
    // be PC values, such that Buf[0] is the PC of the caller, Buf[1] is
    // the PC of that function's caller, and so on.  Max is the maximum
    // number of entries to store.  The function should store a zero to
    // indicate the top of the stack, or that the caller is on a different
    // stack, presumably a Go stack.
    //
    // Unlike runtime.Callers, the PC values returned should, when passed
    // to the symbolizer function, return the file/line of the call
    // instruction.  No additional subtraction is required or appropriate.
    //
    // On all platforms, the traceback function is invoked when a call from
    // Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,
    // linux/arm64, and freebsd/amd64, the traceback function is also invoked
    // when a signal is received by a thread that is executing a cgo call.
    // The traceback function should not make assumptions about when it is
    // called, as future versions of Go may make additional calls.
    //
    // The symbolizer function will be called with a single argument, a
    // pointer to a struct:
    //
    //	struct {
    //		PC      uintptr // program counter to fetch information for
    //		File    *byte   // file name (NUL terminated)
    //		Lineno  uintptr // line number
    //		Func    *byte   // function name (NUL terminated)
    //		Entry   uintptr // function entry point
    //		More    uintptr // set non-zero if more info for this PC
    //		Data    uintptr // unused by runtime, available for function
    //	}
    //
    // In C syntax, this struct will be
    //
    //	struct {
    //		uintptr_t PC;
    //		char*     File;
    //		uintptr_t Lineno;
    //		char*     Func;
    //		uintptr_t Entry;
    //		uintptr_t More;
    //		uintptr_t Data;
    //	};
    //
    // The PC field will be a value returned by a call to the traceback
    // function.
    //
    // The first time the function is called for a particular traceback,
    // all the fields except PC will be 0. The function should fill in the
    // other fields if possible, setting them to 0/nil if the information
    // is not available. The Data field may be used to store any useful
    // information across calls. The More field should be set to non-zero
    // if there is more information for this PC, zero otherwise. If More
    // is set non-zero, the function will be called again with the same
    // PC, and may return different information (this is intended for use
    // with inlined functions). If More is zero, the function will be
    // called with the next PC value in the traceback. When the traceback
    // is complete, the function will be called once more with PC set to
    // zero; this may be used to free any information. Each call will
    // leave the fields of the struct set to the same values they had upon
    // return, except for the PC field when the More field is zero. The
    // function must not keep a copy of the struct pointer between calls.
    //
    // When calling SetCgoTraceback, the version argument is the version
    // number of the structs that the functions expect to receive.
    // Currently this must be zero.
    //
    // The symbolizer function may be nil, in which case the results of
    // the traceback function will be displayed as numbers. If the
    // traceback function is nil, the symbolizer function will never be
    // called. The context function may be nil, in which case the
    // traceback function will only be called with the context field set
    // to zero.  If the context function is nil, then calls from Go to C
    // to Go will not show a traceback for the C portion of the call stack.
    //
    // SetCgoTraceback should be called only once, ideally from an init function.
    void SetCgoTraceback(int version, unsafe::Pointer traceback, unsafe::Pointer context, unsafe::Pointer symbolizer)
    {
        if(version != 0)
        {
            gocpp::panic("unsupported version"s);
        }
        if(cgoTraceback != nullptr && cgoTraceback != traceback || cgoContext != nullptr && cgoContext != context || cgoSymbolizer != nullptr && cgoSymbolizer != symbolizer)
        {
            gocpp::panic("call SetCgoTraceback only once"s);
        }
        cgoTraceback = traceback;
        cgoContext = context;
        cgoSymbolizer = symbolizer;
        if(_cgo_set_context_function != nullptr)
        {
            cgocall(_cgo_set_context_function, context);
        }
    }

    unsafe::Pointer cgoTraceback;
    unsafe::Pointer cgoContext;
    unsafe::Pointer cgoSymbolizer;
    // cgoTracebackArg is the type passed to cgoTraceback.
    
    template<typename T> requires gocpp::GoStruct<T>
    cgoTracebackArg::operator T()
    {
        T result;
        result.context = this->context;
        result.sigContext = this->sigContext;
        result.buf = this->buf;
        result.max = this->max;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgoTracebackArg::operator==(const T& ref) const
    {
        if (context != ref.context) return false;
        if (sigContext != ref.sigContext) return false;
        if (buf != ref.buf) return false;
        if (max != ref.max) return false;
        return true;
    }

    std::ostream& cgoTracebackArg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << context;
        os << " " << sigContext;
        os << " " << buf;
        os << " " << max;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgoTracebackArg& value)
    {
        return value.PrintTo(os);
    }

    // cgoContextArg is the type passed to the context function.
    
    template<typename T> requires gocpp::GoStruct<T>
    cgoContextArg::operator T()
    {
        T result;
        result.context = this->context;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgoContextArg::operator==(const T& ref) const
    {
        if (context != ref.context) return false;
        return true;
    }

    std::ostream& cgoContextArg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << context;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgoContextArg& value)
    {
        return value.PrintTo(os);
    }

    // cgoSymbolizerArg is the type passed to cgoSymbolizer.
    
    template<typename T> requires gocpp::GoStruct<T>
    cgoSymbolizerArg::operator T()
    {
        T result;
        result.pc = this->pc;
        result.file = this->file;
        result.lineno = this->lineno;
        result.funcName = this->funcName;
        result.entry = this->entry;
        result.more = this->more;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgoSymbolizerArg::operator==(const T& ref) const
    {
        if (pc != ref.pc) return false;
        if (file != ref.file) return false;
        if (lineno != ref.lineno) return false;
        if (funcName != ref.funcName) return false;
        if (entry != ref.entry) return false;
        if (more != ref.more) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& cgoSymbolizerArg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pc;
        os << " " << file;
        os << " " << lineno;
        os << " " << funcName;
        os << " " << entry;
        os << " " << more;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgoSymbolizerArg& value)
    {
        return value.PrintTo(os);
    }

    // printCgoTraceback prints a traceback of callers.
    void printCgoTraceback(cgoCallers* callers)
    {
        if(cgoSymbolizer == nullptr)
        {
            for(auto [gocpp_ignored, c] : callers)
            {
                if(c == 0)
                {
                    break;
                }
                print("non-Go function at pc="s, hex(c), "\n"s);
            }
            return;
        }
        auto commitFrame = [=]() mutable -> std::tuple<bool, bool>
        {
            bool pr;
            bool stop;
            return {true, false};
        };
        cgoSymbolizerArg arg = {};
        for(auto [gocpp_ignored, c] : callers)
        {
            if(c == 0)
            {
                break;
            }
            printOneCgoTraceback(c, commitFrame, & arg);
        }
        arg.pc = 0;
        callCgoSymbolizer(& arg);
    }

    // printOneCgoTraceback prints the traceback of a single cgo caller.
    // This can print more than one line because of inlining.
    // It returns the "stop" result of commitFrame.
    bool printOneCgoTraceback(uintptr_t pc, std::function<std::tuple<bool, bool> ()> commitFrame, struct cgoSymbolizerArg* arg)
    {
        arg->pc = pc;
        for(; ; )
        {
            if(auto [pr, stop] = commitFrame(); stop)
            {
                return true;
            }
            else
            if(! pr)
            {
                continue;
            }
            callCgoSymbolizer(arg);
            if(arg->funcName != nullptr)
            {
                println(gostringnocopy(arg->funcName));
            }
            else
            {
                println("non-Go function"s);
            }
            print("\t"s);
            if(arg->file != nullptr)
            {
                print(gostringnocopy(arg->file), ":"s, arg->lineno, " "s);
            }
            print("pc="s, hex(pc), "\n"s);
            if(arg->more == 0)
            {
                return false;
            }
        }
    }

    // callCgoSymbolizer calls the cgoSymbolizer function.
    void callCgoSymbolizer(struct cgoSymbolizerArg* arg)
    {
        auto call = cgocall;
        if(rec::Load(gocpp::recv(panicking)) > 0 || getg()->m->curg != getg())
        {
            call = asmcgocall;
        }
        if(msanenabled)
        {
            msanwrite(unsafe::Pointer(arg), gocpp::Sizeof<cgoSymbolizerArg>());
        }
        if(asanenabled)
        {
            asanwrite(unsafe::Pointer(arg), gocpp::Sizeof<cgoSymbolizerArg>());
        }
        call(cgoSymbolizer, noescape(unsafe::Pointer(arg)));
    }

    // cgoContextPCs gets the PC values from a cgo traceback.
    void cgoContextPCs(uintptr_t ctxt, gocpp::slice<uintptr_t> buf)
    {
        if(cgoTraceback == nullptr)
        {
            return;
        }
        auto call = cgocall;
        if(rec::Load(gocpp::recv(panicking)) > 0 || getg()->m->curg != getg())
        {
            call = asmcgocall;
        }
        auto arg = gocpp::Init<cgoTracebackArg>([=](auto& x) {
            x.context = ctxt;
            x.buf = (uintptr_t*)(noescape(unsafe::Pointer(& buf[0])));
            x.max = uintptr_t(len(buf));
        });
        if(msanenabled)
        {
            msanwrite(unsafe::Pointer(& arg), gocpp::Sizeof<cgoTracebackArg>());
        }
        if(asanenabled)
        {
            asanwrite(unsafe::Pointer(& arg), gocpp::Sizeof<cgoTracebackArg>());
        }
        call(cgoTraceback, noescape(unsafe::Pointer(& arg)));
    }

}

