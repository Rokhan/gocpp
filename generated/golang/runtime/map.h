// generated by GoCpp from file '$(ImportDir)/runtime/map.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/map.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/slice.h"

namespace golang::runtime
{
    bool isEmpty(uint8_t x);
    struct hmap
    {
        int count;
        uint8_t flags;
        uint8_t B;
        uint16_t noverflow;
        uint32_t hash0;
        unsafe::Pointer buckets;
        unsafe::Pointer oldbuckets;
        uintptr_t nevacuate;
        mapextra* extra;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hmap& value);
    struct mapextra
    {
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        bmap* nextOverflow;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapextra& value);
    struct bmap
    {
        gocpp::array<uint8_t, bucketCnt> tophash;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bmap& value);
    struct hiter
    {
        unsafe::Pointer key;
        unsafe::Pointer elem;
        maptype* t;
        hmap* h;
        unsafe::Pointer buckets;
        bmap* bptr;
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        uintptr_t startBucket;
        uint8_t offset;
        bool wrapped;
        uint8_t B;
        uint8_t i;
        uintptr_t bucket;
        uintptr_t checkBucket;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hiter& value);
    uintptr_t bucketShift(uint8_t b);
    uintptr_t bucketMask(uint8_t b);
    uint8_t tophash(uintptr_t hash);
    bool evacuated(bmap* b);
    bmap* overflow(struct bmap* b, maptype* t);
    void setoverflow(struct bmap* b, maptype* t, bmap* ovf);
    unsafe::Pointer keys(struct bmap* b);
    void incrnoverflow(struct hmap* h);
    bmap* newoverflow(struct hmap* h, maptype* t, bmap* b);
    void createOverflow(struct hmap* h);
    hmap* makemap64(maptype* t, int64_t hint, hmap* h);
    hmap* makemap_small();
    hmap* makemap(maptype* t, int hint, hmap* h);
    std::tuple<unsafe::Pointer, bmap*> makeBucketArray(maptype* t, uint8_t b, unsafe::Pointer dirtyalloc);
    unsafe::Pointer mapaccess1(maptype* t, hmap* h, unsafe::Pointer key);
    std::tuple<unsafe::Pointer, bool> mapaccess2(maptype* t, hmap* h, unsafe::Pointer key);
    std::tuple<unsafe::Pointer, unsafe::Pointer> mapaccessK(maptype* t, hmap* h, unsafe::Pointer key);
    unsafe::Pointer mapaccess1_fat(maptype* t, hmap* h, unsafe::Pointer key, unsafe::Pointer zero);
    std::tuple<unsafe::Pointer, bool> mapaccess2_fat(maptype* t, hmap* h, unsafe::Pointer key, unsafe::Pointer zero);
    unsafe::Pointer mapassign(maptype* t, hmap* h, unsafe::Pointer key);
    void mapdelete(maptype* t, hmap* h, unsafe::Pointer key);
    void mapiterinit(maptype* t, hmap* h, hiter* it);
    void mapiternext(hiter* it);
    void mapclear(maptype* t, hmap* h);
    void hashGrow(maptype* t, hmap* h);
    bool overLoadFactor(int count, uint8_t B);
    bool tooManyOverflowBuckets(uint16_t noverflow, uint8_t B);
    bool growing(struct hmap* h);
    bool sameSizeGrow(struct hmap* h);
    uintptr_t noldbuckets(struct hmap* h);
    uintptr_t oldbucketmask(struct hmap* h);
    void growWork(maptype* t, hmap* h, uintptr_t bucket);
    bool bucketEvacuated(maptype* t, hmap* h, uintptr_t bucket);
    struct evacDst
    {
        bmap* b;
        int i;
        unsafe::Pointer k;
        unsafe::Pointer e;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct evacDst& value);
    void evacuate(maptype* t, hmap* h, uintptr_t oldbucket);
    void advanceEvacuationMark(hmap* h, maptype* t, uintptr_t newbit);
    hmap* reflect_makemap(maptype* t, int cap);
    unsafe::Pointer reflect_mapaccess(maptype* t, hmap* h, unsafe::Pointer key);
    unsafe::Pointer reflect_mapaccess_faststr(maptype* t, hmap* h, std::string key);
    void reflect_mapassign(maptype* t, hmap* h, unsafe::Pointer key, unsafe::Pointer elem);
    void reflect_mapassign_faststr(maptype* t, hmap* h, std::string key, unsafe::Pointer elem);
    void reflect_mapdelete(maptype* t, hmap* h, unsafe::Pointer key);
    void reflect_mapdelete_faststr(maptype* t, hmap* h, std::string key);
    void reflect_mapiterinit(maptype* t, hmap* h, hiter* it);
    void reflect_mapiternext(hiter* it);
    unsafe::Pointer reflect_mapiterkey(hiter* it);
    unsafe::Pointer reflect_mapiterelem(hiter* it);
    int reflect_maplen(hmap* h);
    void reflect_mapclear(maptype* t, hmap* h);
    int reflectlite_maplen(hmap* h);
    void mapinitnoop();
    go_any mapclone(go_any m);
    std::tuple<bmap*, int> moveToBmap(maptype* t, hmap* h, bmap* dst, int pos, bmap* src);
    hmap* mapclone2(maptype* t, hmap* src);
    void keys(go_any m, unsafe::Pointer p);
    void copyKeys(maptype* t, hmap* h, bmap* b, slice* s, uint8_t offset);
    void values(go_any m, unsafe::Pointer p);
    void copyValues(maptype* t, hmap* h, bmap* b, slice* s, uint8_t offset);
}

