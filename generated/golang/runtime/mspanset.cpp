// generated by GoCpp from file '$(ImportDir)/runtime/mspanset.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mspanset.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& spanSet::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << spineLock;
        os << " " << spine;
        os << " " << spineLen;
        os << " " << spineCap;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSet& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& spanSetBlock::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << popped;
        os << " " << spans;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSetBlock& value)
    {
        return value.PrintTo(os);
    }

    void push(struct spanSet* b, mspan* s)
    {
        auto cursor = uintptr_t(tail(gocpp::recv(incTail(gocpp::recv(b->index)))) - 1);
        auto [top, bottom] = std::tuple{cursor / spanSetBlockEntries, cursor % spanSetBlockEntries};
        auto spineLen = Load(gocpp::recv(b->spineLen));
        spanSetBlock* block = {};
        retry:
        if(top < spineLen)
        {
            block = Load(gocpp::recv(lookup(gocpp::recv(Load(gocpp::recv(b->spine))), top)));
        }
        else
        {
            lock(& b->spineLock);
            spineLen = Load(gocpp::recv(b->spineLen));
            if(top < spineLen)
            {
                unlock(& b->spineLock);
                goto retry;
            }
            auto spine = Load(gocpp::recv(b->spine));
            if(spineLen == b->spineCap)
            {
                auto newCap = b->spineCap * 2;
                if(newCap == 0)
                {
                    newCap = spanSetInitSpineCap;
                }
                auto newSpine = persistentalloc(newCap * goarch::PtrSize, cpu::CacheLineSize, & memstats.gcMiscSys);
                if(b->spineCap != 0)
                {
                    memmove(newSpine, spine.p, b->spineCap * goarch::PtrSize);
                }
                spine = spanSetSpinePointer {newSpine};
                StoreNoWB(gocpp::recv(b->spine), spine);
                b->spineCap = newCap;
            }
            block = alloc(gocpp::recv(spanSetBlockPool));
            StoreNoWB(gocpp::recv(lookup(gocpp::recv(spine), top)), block);
            Store(gocpp::recv(b->spineLen), spineLen + 1);
            unlock(& b->spineLock);
        }
        StoreNoWB(gocpp::recv(block->spans[bottom]), s);
    }

    mspan* pop(struct spanSet* b)
    {
        uint32_t head = {};
        uint32_t tail = {};
        claimLoop:
        for(; ; )
        {
            auto headtail = load(gocpp::recv(b->index));
            std::tie(head, tail) = split(gocpp::recv(headtail));
            if(head >= tail)
            {
                return nullptr;
            }
            auto spineLen = Load(gocpp::recv(b->spineLen));
            if(spineLen <= uintptr_t(head) / spanSetBlockEntries)
            {
                return nullptr;
            }
            auto want = head;
            for(; want == head; )
            {
                if(cas(gocpp::recv(b->index), headtail, makeHeadTailIndex(want + 1, tail)))
                {
                    goto claimLoop_break;
                }
                headtail = load(gocpp::recv(b->index));
                std::tie(head, tail) = split(gocpp::recv(headtail));
            }
            if(false) {
            claimLoop_continue:
                continue;
            claimLoop_break:
                break;
            }
        }
        auto [top, bottom] = std::tuple{head / spanSetBlockEntries, head % spanSetBlockEntries};
        auto blockp = lookup(gocpp::recv(Load(gocpp::recv(b->spine))), uintptr_t(top));
        auto block = Load(gocpp::recv(blockp));
        auto s = Load(gocpp::recv(block->spans[bottom]));
        for(; s == nullptr; )
        {
            s = Load(gocpp::recv(block->spans[bottom]));
        }
        StoreNoWB(gocpp::recv(block->spans[bottom]), nullptr);
        if(Add(gocpp::recv(block->popped), 1) == spanSetBlockEntries)
        {
            StoreNoWB(gocpp::recv(blockp), nullptr);
            free(gocpp::recv(spanSetBlockPool), block);
        }
        return s;
    }

    void reset(struct spanSet* b)
    {
        auto [head, tail] = split(gocpp::recv(load(gocpp::recv(b->index))));
        if(head < tail)
        {
            print("head = ", head, ", tail = ", tail, "\n");
            go_throw("attempt to clear non-empty span set");
        }
        auto top = head / spanSetBlockEntries;
        if(uintptr_t(top) < Load(gocpp::recv(b->spineLen)))
        {
            auto blockp = lookup(gocpp::recv(Load(gocpp::recv(b->spine))), uintptr_t(top));
            auto block = Load(gocpp::recv(blockp));
            if(block != nullptr)
            {
                if(Load(gocpp::recv(block->popped)) == 0)
                {
                    go_throw("span set block with unpopped elements found in reset");
                }
                if(Load(gocpp::recv(block->popped)) == spanSetBlockEntries)
                {
                    go_throw("fully empty unfreed span set block found in reset");
                }
                StoreNoWB(gocpp::recv(blockp), nullptr);
                free(gocpp::recv(spanSetBlockPool), block);
            }
        }
        reset(gocpp::recv(b->index));
        Store(gocpp::recv(b->spineLen), 0);
    }

    
    std::ostream& atomicSpanSetSpinePointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicSpanSetSpinePointer& value)
    {
        return value.PrintTo(os);
    }

    spanSetSpinePointer Load(struct atomicSpanSetSpinePointer* s)
    {
        return spanSetSpinePointer {Load(gocpp::recv(s->a))};
    }

    void StoreNoWB(struct atomicSpanSetSpinePointer* s, spanSetSpinePointer p)
    {
        StoreNoWB(gocpp::recv(s->a), p.p);
    }

    
    std::ostream& spanSetSpinePointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSetSpinePointer& value)
    {
        return value.PrintTo(os);
    }

    atomic::Pointer<spanSetBlock>* lookup(struct spanSetSpinePointer s, uintptr_t idx)
    {
        return (atomic::Pointer<spanSetBlock>*)(add(s.p, goarch::PtrSize * idx));
    }

    spanSetBlockAlloc spanSetBlockPool;
    
    std::ostream& spanSetBlockAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stack;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSetBlockAlloc& value)
    {
        return value.PrintTo(os);
    }

    spanSetBlock* alloc(struct spanSetBlockAlloc* p)
    {
        if(auto s = (spanSetBlock*)(pop(gocpp::recv(p->stack))); s != nullptr)
        {
            return s;
        }
        return (spanSetBlock*)(persistentalloc(gocpp::Sizeof<spanSetBlock>(), cpu::CacheLineSize, & memstats.gcMiscSys));
    }

    void free(struct spanSetBlockAlloc* p, spanSetBlock* block)
    {
        Store(gocpp::recv(block->popped), 0);
        push(gocpp::recv(p->stack), & block->lfnode);
    }

    headTailIndex makeHeadTailIndex(uint32_t head, uint32_t tail)
    {
        return headTailIndex((uint64_t(head) << 32) | uint64_t(tail));
    }

    uint32_t head(headTailIndex h)
    {
        return uint32_t(h >> 32);
    }

    uint32_t tail(headTailIndex h)
    {
        return uint32_t(h);
    }

    std::tuple<uint32_t, uint32_t> split(headTailIndex h)
    {
        uint32_t head;
        uint32_t tail;
        return {head(gocpp::recv(h)), tail(gocpp::recv(h))};
    }

    
    std::ostream& atomicHeadTailIndex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicHeadTailIndex& value)
    {
        return value.PrintTo(os);
    }

    headTailIndex load(struct atomicHeadTailIndex* h)
    {
        return headTailIndex(Load(gocpp::recv(h->u)));
    }

    bool cas(struct atomicHeadTailIndex* h, headTailIndex old, headTailIndex go_new)
    {
        return CompareAndSwap(gocpp::recv(h->u), uint64_t(old), uint64_t(go_new));
    }

    headTailIndex incHead(struct atomicHeadTailIndex* h)
    {
        return headTailIndex(Add(gocpp::recv(h->u), 1 << 32));
    }

    headTailIndex decHead(struct atomicHeadTailIndex* h)
    {
        return headTailIndex(Add(gocpp::recv(h->u), - (1 << 32)));
    }

    headTailIndex incTail(struct atomicHeadTailIndex* h)
    {
        auto ht = headTailIndex(Add(gocpp::recv(h->u), 1));
        if(tail(gocpp::recv(ht)) == 0)
        {
            print("runtime: head = ", head(gocpp::recv(ht)), ", tail = ", tail(gocpp::recv(ht)), "\n");
            go_throw("headTailIndex overflow");
        }
        return ht;
    }

    void reset(struct atomicHeadTailIndex* h)
    {
        Store(gocpp::recv(h->u), 0);
    }

    
    std::ostream& atomicMSpanPointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicMSpanPointer& value)
    {
        return value.PrintTo(os);
    }

    mspan* Load(struct atomicMSpanPointer* p)
    {
        return (mspan*)(Load(gocpp::recv(p->p)));
    }

    void StoreNoWB(struct atomicMSpanPointer* p, mspan* s)
    {
        StoreNoWB(gocpp::recv(p->p), unsafe::Pointer(s));
    }

}

