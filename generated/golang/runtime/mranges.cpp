// generated by GoCpp from file '$(ImportDir)/runtime/mranges.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mranges.h"
#include "gocpp/support.h"

#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/print.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace atomic::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    addrRange::operator T()
    {
        T result;
        result.base = this->base;
        result.limit = this->limit;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool addrRange::operator==(const T& ref) const
    {
        if (base != ref.base) return false;
        if (limit != ref.limit) return false;
        return true;
    }

    std::ostream& addrRange::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << base;
        os << " " << limit;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct addrRange& value)
    {
        return value.PrintTo(os);
    }

    struct addrRange makeAddrRange(uintptr_t base, uintptr_t limit)
    {
        auto r = addrRange {offAddr {base}, offAddr {limit}};
        if((base - arenaBaseOffset >= base) != (limit - arenaBaseOffset >= limit))
        {
            go_throw("addr range base and limit are not in the same memory segment");
        }
        return r;
    }

    uintptr_t rec::size(struct addrRange a)
    {
        if(! rec::lessThan(gocpp::recv(a.base), a.limit))
        {
            return 0;
        }
        return rec::diff(gocpp::recv(a.limit), a.base);
    }

    bool rec::contains(struct addrRange a, uintptr_t addr)
    {
        return rec::lessEqual(gocpp::recv(a.base), offAddr {addr}) && rec::lessThan(gocpp::recv((offAddr {addr})), a.limit);
    }

    struct addrRange rec::subtract(struct addrRange a, struct addrRange b)
    {
        if(rec::lessEqual(gocpp::recv(b.base), a.base) && rec::lessEqual(gocpp::recv(a.limit), b.limit))
        {
            return addrRange {};
        }
        else
        if(rec::lessThan(gocpp::recv(a.base), b.base) && rec::lessThan(gocpp::recv(b.limit), a.limit))
        {
            go_throw("bad prune");
        }
        else
        if(rec::lessThan(gocpp::recv(b.limit), a.limit) && rec::lessThan(gocpp::recv(a.base), b.limit))
        {
            a.base = b.limit;
        }
        else
        if(rec::lessThan(gocpp::recv(a.base), b.base) && rec::lessThan(gocpp::recv(b.base), a.limit))
        {
            a.limit = b.base;
        }
        return a;
    }

    std::tuple<uintptr_t, bool> rec::takeFromFront(struct addrRange* a, uintptr_t len, uint8_t align)
    {
        auto base = alignUp(rec::addr(gocpp::recv(a->base)), uintptr_t(align)) + len;
        if(base > rec::addr(gocpp::recv(a->limit)))
        {
            return {0, false};
        }
        a->base = offAddr {base};
        return {base - len, true};
    }

    std::tuple<uintptr_t, bool> rec::takeFromBack(struct addrRange* a, uintptr_t len, uint8_t align)
    {
        auto limit = alignDown(rec::addr(gocpp::recv(a->limit)) - len, uintptr_t(align));
        if(rec::addr(gocpp::recv(a->base)) > limit)
        {
            return {0, false};
        }
        a->limit = offAddr {limit};
        return {limit, true};
    }

    struct addrRange rec::removeGreaterEqual(struct addrRange a, uintptr_t addr)
    {
        if(rec::lessEqual(gocpp::recv((offAddr {addr})), a.base))
        {
            return addrRange {};
        }
        if(rec::lessEqual(gocpp::recv(a.limit), offAddr {addr}))
        {
            return a;
        }
        return makeAddrRange(rec::addr(gocpp::recv(a.base)), addr);
    }

    offAddr minOffAddr = offAddr {arenaBaseOffset};
    offAddr maxOffAddr = offAddr {(((1 << heapAddrBits) - 1) + arenaBaseOffset) & uintptrMask};
    
    template<typename T> requires gocpp::GoStruct<T>
    offAddr::operator T()
    {
        T result;
        result.a = this->a;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool offAddr::operator==(const T& ref) const
    {
        if (a != ref.a) return false;
        return true;
    }

    std::ostream& offAddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct offAddr& value)
    {
        return value.PrintTo(os);
    }

    struct offAddr rec::add(struct offAddr l, uintptr_t bytes)
    {
        return gocpp::Init<offAddr>([](offAddr& x) { x.a = l.a + bytes; });
    }

    struct offAddr rec::sub(struct offAddr l, uintptr_t bytes)
    {
        return gocpp::Init<offAddr>([](offAddr& x) { x.a = l.a - bytes; });
    }

    uintptr_t rec::diff(struct offAddr l1, struct offAddr l2)
    {
        return l1.a - l2.a;
    }

    bool rec::lessThan(struct offAddr l1, struct offAddr l2)
    {
        return (l1.a - arenaBaseOffset) < (l2.a - arenaBaseOffset);
    }

    bool rec::lessEqual(struct offAddr l1, struct offAddr l2)
    {
        return (l1.a - arenaBaseOffset) <= (l2.a - arenaBaseOffset);
    }

    bool rec::equal(struct offAddr l1, struct offAddr l2)
    {
        return l1 == l2;
    }

    uintptr_t rec::addr(struct offAddr l)
    {
        return l.a;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    atomicOffAddr::operator T()
    {
        T result;
        result.a = this->a;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicOffAddr::operator==(const T& ref) const
    {
        if (a != ref.a) return false;
        return true;
    }

    std::ostream& atomicOffAddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicOffAddr& value)
    {
        return value.PrintTo(os);
    }

    void rec::Clear(struct atomicOffAddr* b)
    {
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(b->a));
            if(old < 0)
            {
                return;
            }
            if(rec::CompareAndSwap(gocpp::recv(b->a), old, int64_t(rec::addr(gocpp::recv(minOffAddr)) - arenaBaseOffset)))
            {
                return;
            }
        }
    }

    void rec::StoreMin(struct atomicOffAddr* b, uintptr_t addr)
    {
        auto go_new = int64_t(addr - arenaBaseOffset);
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(b->a));
            if(old < go_new)
            {
                return;
            }
            if(rec::CompareAndSwap(gocpp::recv(b->a), old, go_new))
            {
                return;
            }
        }
    }

    void rec::StoreUnmark(struct atomicOffAddr* b, uintptr_t markedAddr, uintptr_t newAddr)
    {
        rec::CompareAndSwap(gocpp::recv(b->a), - int64_t(markedAddr - arenaBaseOffset), int64_t(newAddr - arenaBaseOffset));
    }

    void rec::StoreMarked(struct atomicOffAddr* b, uintptr_t addr)
    {
        rec::Store(gocpp::recv(b->a), - int64_t(addr - arenaBaseOffset));
    }

    std::tuple<uintptr_t, bool> rec::Load(struct atomicOffAddr* b)
    {
        auto v = rec::Load(gocpp::recv(b->a));
        auto wasMarked = false;
        if(v < 0)
        {
            wasMarked = true;
            v = - v;
        }
        return {uintptr_t(v) + arenaBaseOffset, wasMarked};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    addrRanges::operator T()
    {
        T result;
        result.ranges = this->ranges;
        result.totalBytes = this->totalBytes;
        result.sysStat = this->sysStat;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool addrRanges::operator==(const T& ref) const
    {
        if (ranges != ref.ranges) return false;
        if (totalBytes != ref.totalBytes) return false;
        if (sysStat != ref.sysStat) return false;
        return true;
    }

    std::ostream& addrRanges::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ranges;
        os << " " << totalBytes;
        os << " " << sysStat;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct addrRanges& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct addrRanges* a, golang::runtime::sysMemStat* sysStat)
    {
        auto ranges = (notInHeapSlice*)(unsafe::Pointer(& a->ranges));
        ranges->len = 0;
        ranges->cap = 16;
        ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, sysStat));
        a->sysStat = sysStat;
        a->totalBytes = 0;
    }

    int rec::findSucc(struct addrRanges* a, uintptr_t addr)
    {
        auto base = offAddr {addr};
        auto iterMax = 8;
        auto [bot, top] = std::tuple{0, len(a->ranges)};
        for(; top - bot > iterMax; )
        {
            auto i = int((unsigned int)(bot + top) >> 1);
            if(rec::contains(gocpp::recv(a->ranges[i]), rec::addr(gocpp::recv(base))))
            {
                return i + 1;
            }
            if(rec::lessThan(gocpp::recv(base), a->ranges[i].base))
            {
                top = i;
            }
            else
            {
                bot = i + 1;
            }
        }
        for(auto i = bot; i < top; i++)
        {
            if(rec::lessThan(gocpp::recv(base), a->ranges[i].base))
            {
                return i;
            }
        }
        return top;
    }

    std::tuple<uintptr_t, bool> rec::findAddrGreaterEqual(struct addrRanges* a, uintptr_t addr)
    {
        auto i = rec::findSucc(gocpp::recv(a), addr);
        if(i == 0)
        {
            return {rec::addr(gocpp::recv(a->ranges[0].base)), true};
        }
        if(rec::contains(gocpp::recv(a->ranges[i - 1]), addr))
        {
            return {addr, true};
        }
        if(i < len(a->ranges))
        {
            return {rec::addr(gocpp::recv(a->ranges[i].base)), true};
        }
        return {0, false};
    }

    bool rec::contains(struct addrRanges* a, uintptr_t addr)
    {
        auto i = rec::findSucc(gocpp::recv(a), addr);
        if(i == 0)
        {
            return false;
        }
        return rec::contains(gocpp::recv(a->ranges[i - 1]), addr);
    }

    void rec::add(struct addrRanges* a, struct addrRange r)
    {
        if(rec::size(gocpp::recv(r)) == 0)
        {
            print("runtime: range = {", hex(rec::addr(gocpp::recv(r.base))), ", ", hex(rec::addr(gocpp::recv(r.limit))), "}\n");
            go_throw("attempted to add zero-sized address range");
        }
        auto i = rec::findSucc(gocpp::recv(a), rec::addr(gocpp::recv(r.base)));
        auto coalescesDown = i > 0 && rec::equal(gocpp::recv(a->ranges[i - 1].limit), r.base);
        auto coalescesUp = i < len(a->ranges) && rec::equal(gocpp::recv(r.limit), a->ranges[i].base);
        if(coalescesUp && coalescesDown)
        {
            a->ranges[i - 1].limit = a->ranges[i].limit;
            copy(a->ranges.make_slice(i), a->ranges.make_slice(i + 1));
            a->ranges = a->ranges.make_slice(0, len(a->ranges) - 1);
        }
        else
        if(coalescesDown)
        {
            a->ranges[i - 1].limit = r.limit;
        }
        else
        if(coalescesUp)
        {
            a->ranges[i].base = r.base;
        }
        else
        {
            if(len(a->ranges) + 1 > cap(a->ranges))
            {
                auto oldRanges = a->ranges;
                auto ranges = (notInHeapSlice*)(unsafe::Pointer(& a->ranges));
                ranges->len = len(oldRanges) + 1;
                ranges->cap = cap(oldRanges) * 2;
                ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, a->sysStat));
                copy(a->ranges.make_slice(0, i), oldRanges.make_slice(0, i));
                copy(a->ranges.make_slice(i + 1), oldRanges.make_slice(i));
            }
            else
            {
                a->ranges = a->ranges.make_slice(0, len(a->ranges) + 1);
                copy(a->ranges.make_slice(i + 1), a->ranges.make_slice(i));
            }
            a->ranges[i] = r;
        }
        a->totalBytes += rec::size(gocpp::recv(r));
    }

    struct addrRange rec::removeLast(struct addrRanges* a, uintptr_t nBytes)
    {
        if(len(a->ranges) == 0)
        {
            return addrRange {};
        }
        auto r = a->ranges[len(a->ranges) - 1];
        auto size = rec::size(gocpp::recv(r));
        if(size > nBytes)
        {
            auto newEnd = rec::sub(gocpp::recv(r.limit), nBytes);
            a->ranges[len(a->ranges) - 1].limit = newEnd;
            a->totalBytes -= nBytes;
            return addrRange {newEnd, r.limit};
        }
        a->ranges = a->ranges.make_slice(0, len(a->ranges) - 1);
        a->totalBytes -= size;
        return r;
    }

    void rec::removeGreaterEqual(struct addrRanges* a, uintptr_t addr)
    {
        auto pivot = rec::findSucc(gocpp::recv(a), addr);
        if(pivot == 0)
        {
            a->totalBytes = 0;
            a->ranges = a->ranges.make_slice(0, 0);
            return;
        }
        auto removed = uintptr_t(0);
        for(auto [gocpp_ignored, r] : a->ranges.make_slice(pivot))
        {
            removed += rec::size(gocpp::recv(r));
        }
        if(auto r = a->ranges[pivot - 1]; rec::contains(gocpp::recv(r), addr))
        {
            removed += rec::size(gocpp::recv(r));
            r = rec::removeGreaterEqual(gocpp::recv(r), addr);
            if(rec::size(gocpp::recv(r)) == 0)
            {
                pivot--;
            }
            else
            {
                removed -= rec::size(gocpp::recv(r));
                a->ranges[pivot - 1] = r;
            }
        }
        a->ranges = a->ranges.make_slice(0, pivot);
        a->totalBytes -= removed;
    }

    void rec::cloneInto(struct addrRanges* a, struct addrRanges* b)
    {
        if(len(a->ranges) > cap(b->ranges))
        {
            auto ranges = (notInHeapSlice*)(unsafe::Pointer(& b->ranges));
            ranges->len = 0;
            ranges->cap = cap(a->ranges);
            ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, b->sysStat));
        }
        b->ranges = b->ranges.make_slice(0, len(a->ranges));
        b->totalBytes = a->totalBytes;
        copy(b->ranges, a->ranges);
    }

}

