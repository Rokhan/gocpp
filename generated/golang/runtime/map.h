// generated by GoCpp from file '$(ImportDir)/runtime/map.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/map.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/slice.h"

namespace golang::runtime
{
    bool isEmpty(uint8_t x);
    struct hmap
    {
        int count;
        uint8_t flags;
        uint8_t B;
        uint16_t noverflow;
        uint32_t hash0;
        gocpp::unsafe_pointer buckets;
        gocpp::unsafe_pointer oldbuckets;
        uintptr_t nevacuate;
        mapextra* extra;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hmap& value);
    struct mapextra
    {
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        bmap* nextOverflow;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapextra& value);
    struct bmap
    {
        gocpp::array<uint8_t, bucketCnt> tophash;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bmap& value);
    struct hiter
    {
        gocpp::unsafe_pointer key;
        gocpp::unsafe_pointer elem;
        golang::runtime::maptype* t;
        hmap* h;
        gocpp::unsafe_pointer buckets;
        bmap* bptr;
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        uintptr_t startBucket;
        uint8_t offset;
        bool wrapped;
        uint8_t B;
        uint8_t i;
        uintptr_t bucket;
        uintptr_t checkBucket;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hiter& value);
    uintptr_t bucketShift(uint8_t b);
    uintptr_t bucketMask(uint8_t b);
    uint8_t tophash(uintptr_t hash);
    bool evacuated(struct bmap* b);
    struct hmap* makemap64(golang::runtime::maptype* t, int64_t hint, struct hmap* h);
    struct hmap* makemap_small();
    struct hmap* makemap(golang::runtime::maptype* t, int hint, struct hmap* h);
    std::tuple<gocpp::unsafe_pointer, struct bmap*> makeBucketArray(golang::runtime::maptype* t, uint8_t b, gocpp::unsafe_pointer dirtyalloc);
    gocpp::unsafe_pointer mapaccess1(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    std::tuple<gocpp::unsafe_pointer, bool> mapaccess2(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    std::tuple<gocpp::unsafe_pointer, gocpp::unsafe_pointer> mapaccessK(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    gocpp::unsafe_pointer mapaccess1_fat(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key, gocpp::unsafe_pointer zero);
    std::tuple<gocpp::unsafe_pointer, bool> mapaccess2_fat(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key, gocpp::unsafe_pointer zero);
    gocpp::unsafe_pointer mapassign(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    void mapdelete(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    void mapiterinit(golang::runtime::maptype* t, struct hmap* h, struct hiter* it);
    void mapiternext(struct hiter* it);
    void mapclear(golang::runtime::maptype* t, struct hmap* h);
    void hashGrow(golang::runtime::maptype* t, struct hmap* h);
    bool overLoadFactor(int count, uint8_t B);
    bool tooManyOverflowBuckets(uint16_t noverflow, uint8_t B);
    void growWork(golang::runtime::maptype* t, struct hmap* h, uintptr_t bucket);
    bool bucketEvacuated(golang::runtime::maptype* t, struct hmap* h, uintptr_t bucket);
    struct evacDst
    {
        bmap* b;
        int i;
        gocpp::unsafe_pointer k;
        gocpp::unsafe_pointer e;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct evacDst& value);
    void evacuate(golang::runtime::maptype* t, struct hmap* h, uintptr_t oldbucket);
    void advanceEvacuationMark(struct hmap* h, golang::runtime::maptype* t, uintptr_t newbit);
    struct hmap* reflect_makemap(golang::runtime::maptype* t, int cap);
    gocpp::unsafe_pointer reflect_mapaccess(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    gocpp::unsafe_pointer reflect_mapaccess_faststr(golang::runtime::maptype* t, struct hmap* h, gocpp::string key);
    void reflect_mapassign(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key, gocpp::unsafe_pointer elem);
    void reflect_mapassign_faststr(golang::runtime::maptype* t, struct hmap* h, gocpp::string key, gocpp::unsafe_pointer elem);
    void reflect_mapdelete(golang::runtime::maptype* t, struct hmap* h, gocpp::unsafe_pointer key);
    void reflect_mapdelete_faststr(golang::runtime::maptype* t, struct hmap* h, gocpp::string key);
    void reflect_mapiterinit(golang::runtime::maptype* t, struct hmap* h, struct hiter* it);
    void reflect_mapiternext(struct hiter* it);
    gocpp::unsafe_pointer reflect_mapiterkey(struct hiter* it);
    gocpp::unsafe_pointer reflect_mapiterelem(struct hiter* it);
    int reflect_maplen(struct hmap* h);
    void reflect_mapclear(golang::runtime::maptype* t, struct hmap* h);
    int reflectlite_maplen(struct hmap* h);
    extern gocpp::array<unsigned char, abi::ZeroValSize> zeroVal;
    void mapinitnoop();
    go_any mapclone(go_any m);
    std::tuple<struct bmap*, int> moveToBmap(golang::runtime::maptype* t, struct hmap* h, struct bmap* dst, int pos, struct bmap* src);
    struct hmap* mapclone2(golang::runtime::maptype* t, struct hmap* src);
    void keys(go_any m, gocpp::unsafe_pointer p);
    void copyKeys(golang::runtime::maptype* t, struct hmap* h, struct bmap* b, struct slice* s, uint8_t offset);
    void values(go_any m, gocpp::unsafe_pointer p);
    void copyValues(golang::runtime::maptype* t, struct hmap* h, struct bmap* b, struct slice* s, uint8_t offset);

    namespace rec
    {
        struct bmap* overflow(golang::runtime::bmap* b, golang::runtime::maptype* t);
        void setoverflow(golang::runtime::bmap* b, golang::runtime::maptype* t, struct bmap* ovf);
        gocpp::unsafe_pointer keys(golang::runtime::bmap* b);
        void incrnoverflow(golang::runtime::hmap* h);
        struct bmap* newoverflow(golang::runtime::hmap* h, golang::runtime::maptype* t, struct bmap* b);
        void createOverflow(golang::runtime::hmap* h);
        bool growing(golang::runtime::hmap* h);
        bool sameSizeGrow(golang::runtime::hmap* h);
        uintptr_t noldbuckets(golang::runtime::hmap* h);
        uintptr_t oldbucketmask(golang::runtime::hmap* h);
    }
}

