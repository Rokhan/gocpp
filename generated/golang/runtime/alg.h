// generated by GoCpp from file '$(ImportDir)/runtime/alg.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/alg.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    uintptr_t memhash0(unsafe::Pointer p, uintptr_t h);
    uintptr_t memhash8(unsafe::Pointer p, uintptr_t h);
    uintptr_t memhash16(unsafe::Pointer p, uintptr_t h);
    uintptr_t memhash128(unsafe::Pointer p, uintptr_t h);
    uintptr_t memhash_varlen(unsafe::Pointer p, uintptr_t h);
    uintptr_t memhash(unsafe::Pointer p, uintptr_t h, uintptr_t s);
    uintptr_t memhash32(unsafe::Pointer p, uintptr_t h);
    uintptr_t memhash64(unsafe::Pointer p, uintptr_t h);
    uintptr_t strhash(unsafe::Pointer p, uintptr_t h);
    uintptr_t strhashFallback(unsafe::Pointer a, uintptr_t h);
    uintptr_t f32hash(unsafe::Pointer p, uintptr_t h);
    uintptr_t f64hash(unsafe::Pointer p, uintptr_t h);
    uintptr_t c64hash(unsafe::Pointer p, uintptr_t h);
    uintptr_t c128hash(unsafe::Pointer p, uintptr_t h);
    uintptr_t interhash(unsafe::Pointer p, uintptr_t h);
    uintptr_t nilinterhash(unsafe::Pointer p, uintptr_t h);
    uintptr_t typehash(_type* t, unsafe::Pointer p, uintptr_t h);
    std::string mapKeyError(maptype* t, unsafe::Pointer p);
    std::string mapKeyError2(_type* t, unsafe::Pointer p);
    uintptr_t reflect_typehash(_type* t, unsafe::Pointer p, uintptr_t h);
    bool memequal0(unsafe::Pointer p, unsafe::Pointer q);
    bool memequal8(unsafe::Pointer p, unsafe::Pointer q);
    bool memequal16(unsafe::Pointer p, unsafe::Pointer q);
    bool memequal32(unsafe::Pointer p, unsafe::Pointer q);
    bool memequal64(unsafe::Pointer p, unsafe::Pointer q);
    bool memequal128(unsafe::Pointer p, unsafe::Pointer q);
    bool f32equal(unsafe::Pointer p, unsafe::Pointer q);
    bool f64equal(unsafe::Pointer p, unsafe::Pointer q);
    bool c64equal(unsafe::Pointer p, unsafe::Pointer q);
    bool c128equal(unsafe::Pointer p, unsafe::Pointer q);
    bool strequal(unsafe::Pointer p, unsafe::Pointer q);
    bool interequal(unsafe::Pointer p, unsafe::Pointer q);
    bool nilinterequal(unsafe::Pointer p, unsafe::Pointer q);
    bool efaceeq(_type* t, unsafe::Pointer x, unsafe::Pointer y);
    bool ifaceeq(itab* tab, unsafe::Pointer x, unsafe::Pointer y);
    uintptr_t stringHash(std::string s, uintptr_t seed);
    uintptr_t bytesHash(gocpp::slice<unsigned char> b, uintptr_t seed);
    uintptr_t int32Hash(uint32_t i, uintptr_t seed);
    uintptr_t int64Hash(uint64_t i, uintptr_t seed);
    uintptr_t efaceHash(go_any i, uintptr_t seed);
    struct gocpp_id_0 : gocpp::Interface
    {
        gocpp_id_0(){}
        gocpp_id_0(gocpp_id_0& i) = default;
        gocpp_id_0(const gocpp_id_0& i) = default;
        gocpp_id_0& operator=(gocpp_id_0& i) = default;
        gocpp_id_0& operator=(const gocpp_id_0& i) = default;

        template<typename T>
        gocpp_id_0(T& ref);

        template<typename T>
        gocpp_id_0(const T& ref);

        template<typename T>
        gocpp_id_0(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_0
        {
            virtual void vF() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_0Impl : Igocpp_id_0
        {
            explicit gocpp_id_0Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vF() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_0> value;
    };

    void F(const gocpp::PtrRecv<gocpp_id_0, false>& self);
    void F(const gocpp::ObjRecv<gocpp_id_0>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    uintptr_t ifaceHash(gocpp_id_0 i, uintptr_t seed);
    void alginit();
    void initAlgAES();
    uint32_t readUnaligned32(unsafe::Pointer p);
    uint64_t readUnaligned64(unsafe::Pointer p);
}

