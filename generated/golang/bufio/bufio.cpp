// generated by GoCpp from file '$(ImportDir)/bufio/bufio.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bufio/bufio.h"
#include "gocpp/support.h"

#include "golang/bytes/bytes.h"
#include "golang/errors/errors.h"
#include "golang/io/io.h"
#include "golang/strings/builder.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::bufio
{
    std::string ErrInvalidUnreadByte = errors::New("bufio: invalid use of UnreadByte");
    std::string ErrInvalidUnreadRune = errors::New("bufio: invalid use of UnreadRune");
    std::string ErrBufferFull = errors::New("bufio: buffer full");
    std::string ErrNegativeCount = errors::New("bufio: negative count");
    
    template<typename T>
    Reader::operator T()
    {
        T result;
        result.buf = this->buf;
        result.rd = this->rd;
        result.r = this->r;
        result.w = this->w;
        result.err = this->err;
        result.lastByte = this->lastByte;
        result.lastRuneSize = this->lastRuneSize;
        return result;
    }

    template<typename T>
    bool Reader::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (rd != ref.rd) return false;
        if (r != ref.r) return false;
        if (w != ref.w) return false;
        if (err != ref.err) return false;
        if (lastByte != ref.lastByte) return false;
        if (lastRuneSize != ref.lastRuneSize) return false;
        return true;
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << rd;
        os << " " << r;
        os << " " << w;
        os << " " << err;
        os << " " << lastByte;
        os << " " << lastRuneSize;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    Reader* NewReaderSize(io::Reader rd, int size)
    {
        auto [b, ok] = gocpp::getValue<Reader*>(rd);
        if(ok && len(b->buf) >= size)
        {
            return b;
        }
        auto r = go_new(Reader);
        reset(gocpp::recv(r), gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), max(size, minReadBufferSize)), rd);
        return r;
    }

    Reader* NewReader(io::Reader rd)
    {
        return NewReaderSize(rd, defaultBufSize);
    }

    int Size(struct Reader* b)
    {
        return len(b->buf);
    }

    void Reset(struct Reader* b, io::Reader r)
    {
        if(b == r)
        {
            return;
        }
        if(b->buf == nullptr)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), defaultBufSize);
        }
        reset(gocpp::recv(b), b->buf, r);
    }

    void reset(struct Reader* b, gocpp::slice<unsigned char> buf, io::Reader r)
    {
        *b = gocpp::Init<Reader>([](Reader& x) { x.buf = buf; x.rd = r; x.lastByte = - 1; x.lastRuneSize = - 1; });
    }

    std::string errNegativeRead = errors::New("bufio: reader returned negative count from Read");
    void fill(struct Reader* b)
    {
        if(b->r > 0)
        {
            copy(b->buf, b->buf.make_slice(b->r, b->w));
            b->w -= b->r;
            b->r = 0;
        }
        if(b->w >= len(b->buf))
        {
            gocpp::panic("bufio: tried to fill full buffer");
        }
        for(auto i = maxConsecutiveEmptyReads; i > 0; i--)
        {
            auto [n, err] = Read(gocpp::recv(b->rd), b->buf.make_slice(b->w));
            if(n < 0)
            {
                gocpp::panic(errNegativeRead);
            }
            b->w += n;
            if(err != nullptr)
            {
                b->err = err;
                return;
            }
            if(n > 0)
            {
                return;
            }
        }
        b->err = io::ErrNoProgress;
    }

    std::string readErr(struct Reader* b)
    {
        auto err = b->err;
        b->err = nullptr;
        return err;
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> Peek(struct Reader* b, int n)
    {
        if(n < 0)
        {
            return {nullptr, ErrNegativeCount};
        }
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        for(; b->w - b->r < n && b->w - b->r < len(b->buf) && b->err == nullptr; )
        {
            fill(gocpp::recv(b));
        }
        if(n > len(b->buf))
        {
            return {b->buf.make_slice(b->r, b->w), ErrBufferFull};
        }
        std::string err = {};
        if(auto avail = b->w - b->r; avail < n)
        {
            n = avail;
            err = readErr(gocpp::recv(b));
            if(err == nullptr)
            {
                err = ErrBufferFull;
            }
        }
        return {b->buf.make_slice(b->r, b->r + n), err};
    }

    std::tuple<int, std::string> Discard(struct Reader* b, int n)
    {
        int discarded;
        std::string err;
        if(n < 0)
        {
            int discarded;
            std::string err;
            return {0, ErrNegativeCount};
        }
        if(n == 0)
        {
            int discarded;
            std::string err;
            return {discarded, err};
        }
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        auto remain = n;
        for(; ; )
        {
            int discarded;
            std::string err;
            auto skip = Buffered(gocpp::recv(b));
            if(skip == 0)
            {
                int discarded;
                std::string err;
                fill(gocpp::recv(b));
                skip = Buffered(gocpp::recv(b));
            }
            if(skip > remain)
            {
                int discarded;
                std::string err;
                skip = remain;
            }
            b->r += skip;
            remain -= skip;
            if(remain == 0)
            {
                int discarded;
                std::string err;
                return {n, nullptr};
            }
            if(b->err != nullptr)
            {
                int discarded;
                std::string err;
                return {n - remain, readErr(gocpp::recv(b))};
            }
        }
    }

    std::tuple<int, std::string> Read(struct Reader* b, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        n = len(p);
        if(n == 0)
        {
            int n;
            std::string err;
            if(Buffered(gocpp::recv(b)) > 0)
            {
                int n;
                std::string err;
                return {0, nullptr};
            }
            return {0, readErr(gocpp::recv(b))};
        }
        if(b->r == b->w)
        {
            int n;
            std::string err;
            if(b->err != nullptr)
            {
                int n;
                std::string err;
                return {0, readErr(gocpp::recv(b))};
            }
            if(len(p) >= len(b->buf))
            {
                int n;
                std::string err;
                std::tie(n, b->err) = Read(gocpp::recv(b->rd), p);
                if(n < 0)
                {
                    int n;
                    std::string err;
                    gocpp::panic(errNegativeRead);
                }
                if(n > 0)
                {
                    int n;
                    std::string err;
                    b->lastByte = int(p[n - 1]);
                    b->lastRuneSize = - 1;
                }
                return {n, readErr(gocpp::recv(b))};
            }
            b->r = 0;
            b->w = 0;
            std::tie(n, b->err) = Read(gocpp::recv(b->rd), b->buf);
            if(n < 0)
            {
                int n;
                std::string err;
                gocpp::panic(errNegativeRead);
            }
            if(n == 0)
            {
                int n;
                std::string err;
                return {0, readErr(gocpp::recv(b))};
            }
            b->w += n;
        }
        n = copy(p, b->buf.make_slice(b->r, b->w));
        b->r += n;
        b->lastByte = int(b->buf[b->r - 1]);
        b->lastRuneSize = - 1;
        return {n, nullptr};
    }

    std::tuple<unsigned char, std::string> ReadByte(struct Reader* b)
    {
        b->lastRuneSize = - 1;
        for(; b->r == b->w; )
        {
            if(b->err != nullptr)
            {
                return {0, readErr(gocpp::recv(b))};
            }
            fill(gocpp::recv(b));
        }
        auto c = b->buf[b->r];
        b->r++;
        b->lastByte = int(c);
        return {c, nullptr};
    }

    std::string UnreadByte(struct Reader* b)
    {
        if(b->lastByte < 0 || b->r == 0 && b->w > 0)
        {
            return ErrInvalidUnreadByte;
        }
        if(b->r > 0)
        {
            b->r--;
        }
        else
        {
            b->w = 1;
        }
        b->buf[b->r] = unsigned char(b->lastByte);
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        return nullptr;
    }

    std::tuple<gocpp::rune, int, std::string> ReadRune(struct Reader* b)
    {
        gocpp::rune r;
        int size;
        std::string err;
        for(; b->r + utf8::UTFMax > b->w && ! utf8::FullRune(b->buf.make_slice(b->r, b->w)) && b->err == nullptr && b->w - b->r < len(b->buf); )
        {
            gocpp::rune r;
            int size;
            std::string err;
            fill(gocpp::recv(b));
        }
        b->lastRuneSize = - 1;
        if(b->r == b->w)
        {
            gocpp::rune r;
            int size;
            std::string err;
            return {0, 0, readErr(gocpp::recv(b))};
        }
        std::tie(r, size) = std::tuple{rune(b->buf[b->r]), 1};
        if(r >= utf8::RuneSelf)
        {
            gocpp::rune r;
            int size;
            std::string err;
            std::tie(r, size) = utf8::DecodeRune(b->buf.make_slice(b->r, b->w));
        }
        b->r += size;
        b->lastByte = int(b->buf[b->r - 1]);
        b->lastRuneSize = size;
        return {r, size, nullptr};
    }

    std::string UnreadRune(struct Reader* b)
    {
        if(b->lastRuneSize < 0 || b->r < b->lastRuneSize)
        {
            return ErrInvalidUnreadRune;
        }
        b->r -= b->lastRuneSize;
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        return nullptr;
    }

    int Buffered(struct Reader* b)
    {
        return b->w - b->r;
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> ReadSlice(struct Reader* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        std::string err;
        auto s = 0;
        for(; ; )
        {
            gocpp::slice<unsigned char> line;
            std::string err;
            if(auto i = bytes::IndexByte(b->buf.make_slice(b->r + s, b->w), delim); i >= 0)
            {
                gocpp::slice<unsigned char> line;
                std::string err;
                i += s;
                line = b->buf.make_slice(b->r, b->r + i + 1);
                b->r += i + 1;
                break;
            }
            if(b->err != nullptr)
            {
                gocpp::slice<unsigned char> line;
                std::string err;
                line = b->buf.make_slice(b->r, b->w);
                b->r = b->w;
                err = readErr(gocpp::recv(b));
                break;
            }
            if(Buffered(gocpp::recv(b)) >= len(b->buf))
            {
                gocpp::slice<unsigned char> line;
                std::string err;
                b->r = b->w;
                line = b->buf;
                err = ErrBufferFull;
                break;
            }
            s = b->w - b->r;
            fill(gocpp::recv(b));
        }
        if(auto i = len(line) - 1; i >= 0)
        {
            gocpp::slice<unsigned char> line;
            std::string err;
            b->lastByte = int(line[i]);
            b->lastRuneSize = - 1;
        }
        return {line, err};
    }

    std::tuple<gocpp::slice<unsigned char>, bool, std::string> ReadLine(struct Reader* b)
    {
        gocpp::slice<unsigned char> line;
        bool isPrefix;
        std::string err;
        std::tie(line, err) = ReadSlice(gocpp::recv(b), '\n');
        if(err == ErrBufferFull)
        {
            gocpp::slice<unsigned char> line;
            bool isPrefix;
            std::string err;
            if(len(line) > 0 && line[len(line) - 1] == '\r')
            {
                gocpp::slice<unsigned char> line;
                bool isPrefix;
                std::string err;
                if(b->r == 0)
                {
                    gocpp::slice<unsigned char> line;
                    bool isPrefix;
                    std::string err;
                    gocpp::panic("bufio: tried to rewind past start of buffer");
                }
                b->r--;
                line = line.make_slice(0, len(line) - 1);
            }
            return {line, true, nullptr};
        }
        if(len(line) == 0)
        {
            gocpp::slice<unsigned char> line;
            bool isPrefix;
            std::string err;
            if(err != nullptr)
            {
                gocpp::slice<unsigned char> line;
                bool isPrefix;
                std::string err;
                line = nullptr;
            }
            return {line, isPrefix, err};
        }
        err = nullptr;
        if(line[len(line) - 1] == '\n')
        {
            gocpp::slice<unsigned char> line;
            bool isPrefix;
            std::string err;
            auto drop = 1;
            if(len(line) > 1 && line[len(line) - 2] == '\r')
            {
                gocpp::slice<unsigned char> line;
                bool isPrefix;
                std::string err;
                drop = 2;
            }
            line = line.make_slice(0, len(line) - drop);
        }
        return {line, isPrefix, err};
    }

    std::tuple<gocpp::slice<gocpp::slice<unsigned char>>, gocpp::slice<unsigned char>, int, std::string> collectFragments(struct Reader* b, unsigned char delim)
    {
        gocpp::slice<gocpp::slice<unsigned char>> fullBuffers;
        gocpp::slice<unsigned char> finalFragment;
        int totalLen;
        std::string err;
        gocpp::slice<unsigned char> frag = {};
        for(; ; )
        {
            gocpp::slice<gocpp::slice<unsigned char>> fullBuffers;
            gocpp::slice<unsigned char> finalFragment;
            int totalLen;
            std::string err;
            std::string e = {};
            std::tie(frag, e) = ReadSlice(gocpp::recv(b), delim);
            if(e == nullptr)
            {
                gocpp::slice<gocpp::slice<unsigned char>> fullBuffers;
                gocpp::slice<unsigned char> finalFragment;
                int totalLen;
                std::string err;
                break;
            }
            if(e != ErrBufferFull)
            {
                gocpp::slice<gocpp::slice<unsigned char>> fullBuffers;
                gocpp::slice<unsigned char> finalFragment;
                int totalLen;
                std::string err;
                err = e;
                break;
            }
            auto buf = bytes::Clone(frag);
            fullBuffers = append(fullBuffers, buf);
            totalLen += len(buf);
        }
        totalLen += len(frag);
        return {fullBuffers, frag, totalLen, err};
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> ReadBytes(struct Reader* b, unsigned char delim)
    {
        auto [full, frag, n, err] = collectFragments(gocpp::recv(b), delim);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
        n = 0;
        for(auto [i, gocpp_ignored] : full)
        {
            n += copy(buf.make_slice(n), full[i]);
        }
        copy(buf.make_slice(n), frag);
        return {buf, err};
    }

    std::tuple<std::string, std::string> ReadString(struct Reader* b, unsigned char delim)
    {
        auto [full, frag, n, err] = collectFragments(gocpp::recv(b), delim);
        strings::Builder buf = {};
        Grow(gocpp::recv(buf), n);
        for(auto [_, fb] : full)
        {
            Write(gocpp::recv(buf), fb);
        }
        Write(gocpp::recv(buf), frag);
        return {String(gocpp::recv(buf)), err};
    }

    std::tuple<int64_t, std::string> WriteTo(struct Reader* b, io::Writer w)
    {
        int64_t n;
        std::string err;
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        std::tie(n, err) = writeBuf(gocpp::recv(b), w);
        if(err != nullptr)
        {
            int64_t n;
            std::string err;
            return {n, err};
        }
        if(auto [r, ok] = gocpp::getValue<io::WriterTo>(b->rd); ok)
        {
            int64_t n;
            std::string err;
            auto [m, err] = WriteTo(gocpp::recv(r), w);
            n += m;
            return {n, err};
        }
        if(auto [w, ok] = gocpp::getValue<io::ReaderFrom>(w); ok)
        {
            int64_t n;
            std::string err;
            auto [m, err] = ReadFrom(gocpp::recv(w), b->rd);
            n += m;
            return {n, err};
        }
        if(b->w - b->r < len(b->buf))
        {
            int64_t n;
            std::string err;
            fill(gocpp::recv(b));
        }
        for(; b->r < b->w; )
        {
            int64_t n;
            std::string err;
            auto [m, err] = writeBuf(gocpp::recv(b), w);
            n += m;
            if(err != nullptr)
            {
                int64_t n;
                std::string err;
                return {n, err};
            }
            fill(gocpp::recv(b));
        }
        if(b->err == io::go_EOF)
        {
            int64_t n;
            std::string err;
            b->err = nullptr;
        }
        return {n, readErr(gocpp::recv(b))};
    }

    std::string errNegativeWrite = errors::New("bufio: writer returned negative count from Write");
    std::tuple<int64_t, std::string> writeBuf(struct Reader* b, io::Writer w)
    {
        auto [n, err] = Write(gocpp::recv(w), b->buf.make_slice(b->r, b->w));
        if(n < 0)
        {
            gocpp::panic(errNegativeWrite);
        }
        b->r += n;
        return {int64_t(n), err};
    }

    
    template<typename T>
    Writer::operator T()
    {
        T result;
        result.err = this->err;
        result.buf = this->buf;
        result.n = this->n;
        result.wr = this->wr;
        return result;
    }

    template<typename T>
    bool Writer::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (buf != ref.buf) return false;
        if (n != ref.n) return false;
        if (wr != ref.wr) return false;
        return true;
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << buf;
        os << " " << n;
        os << " " << wr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    Writer* NewWriterSize(io::Writer w, int size)
    {
        auto [b, ok] = gocpp::getValue<Writer*>(w);
        if(ok && len(b->buf) >= size)
        {
            return b;
        }
        if(size <= 0)
        {
            size = defaultBufSize;
        }
        return gocpp::InitPtr<Writer>([](Writer& x) { x.buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size); x.wr = w; });
    }

    Writer* NewWriter(io::Writer w)
    {
        return NewWriterSize(w, defaultBufSize);
    }

    int Size(struct Writer* b)
    {
        return len(b->buf);
    }

    void Reset(struct Writer* b, io::Writer w)
    {
        if(b == w)
        {
            return;
        }
        if(b->buf == nullptr)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), defaultBufSize);
        }
        b->err = nullptr;
        b->n = 0;
        b->wr = w;
    }

    std::string Flush(struct Writer* b)
    {
        if(b->err != nullptr)
        {
            return b->err;
        }
        if(b->n == 0)
        {
            return nullptr;
        }
        auto [n, err] = Write(gocpp::recv(b->wr), b->buf.make_slice(0, b->n));
        if(n < b->n && err == nullptr)
        {
            err = io::ErrShortWrite;
        }
        if(err != nullptr)
        {
            if(n > 0 && n < b->n)
            {
                copy(b->buf.make_slice(0, b->n - n), b->buf.make_slice(n, b->n));
            }
            b->n -= n;
            b->err = err;
            return err;
        }
        b->n = 0;
        return nullptr;
    }

    int Available(struct Writer* b)
    {
        return len(b->buf) - b->n;
    }

    gocpp::slice<unsigned char> AvailableBuffer(struct Writer* b)
    {
        return b->buf.make_slice(b->n).make_slice(0, 0);
    }

    int Buffered(struct Writer* b)
    {
        return b->n;
    }

    std::tuple<int, std::string> Write(struct Writer* b, gocpp::slice<unsigned char> p)
    {
        int nn;
        std::string err;
        for(; len(p) > Available(gocpp::recv(b)) && b->err == nullptr; )
        {
            int nn;
            std::string err;
            int n = {};
            if(Buffered(gocpp::recv(b)) == 0)
            {
                int nn;
                std::string err;
                std::tie(n, b->err) = Write(gocpp::recv(b->wr), p);
            }
            else
            {
                int nn;
                std::string err;
                n = copy(b->buf.make_slice(b->n), p);
                b->n += n;
                Flush(gocpp::recv(b));
            }
            nn += n;
            p = p.make_slice(n);
        }
        if(b->err != nullptr)
        {
            int nn;
            std::string err;
            return {nn, b->err};
        }
        auto n = copy(b->buf.make_slice(b->n), p);
        b->n += n;
        nn += n;
        return {nn, nullptr};
    }

    std::string WriteByte(struct Writer* b, unsigned char c)
    {
        if(b->err != nullptr)
        {
            return b->err;
        }
        if(Available(gocpp::recv(b)) <= 0 && Flush(gocpp::recv(b)) != nullptr)
        {
            return b->err;
        }
        b->buf[b->n] = c;
        b->n++;
        return nullptr;
    }

    std::tuple<int, std::string> WriteRune(struct Writer* b, gocpp::rune r)
    {
        int size;
        std::string err;
        if(uint32_t(r) < utf8::RuneSelf)
        {
            int size;
            std::string err;
            err = WriteByte(gocpp::recv(b), unsigned char(r));
            if(err != nullptr)
            {
                int size;
                std::string err;
                return {0, err};
            }
            return {1, nullptr};
        }
        if(b->err != nullptr)
        {
            int size;
            std::string err;
            return {0, b->err};
        }
        auto n = Available(gocpp::recv(b));
        if(n < utf8::UTFMax)
        {
            int size;
            std::string err;
            if(Flush(gocpp::recv(b)); b->err != nullptr)
            {
                int size;
                std::string err;
                return {0, b->err};
            }
            n = Available(gocpp::recv(b));
            if(n < utf8::UTFMax)
            {
                int size;
                std::string err;
                return WriteString(gocpp::recv(b), string(r));
            }
        }
        size = utf8::EncodeRune(b->buf.make_slice(b->n), r);
        b->n += size;
        return {size, nullptr};
    }

    std::tuple<int, std::string> WriteString(struct Writer* b, std::string s)
    {
        io::StringWriter sw = {};
        auto tryStringWriter = true;
        auto nn = 0;
        for(; len(s) > Available(gocpp::recv(b)) && b->err == nullptr; )
        {
            int n = {};
            if(Buffered(gocpp::recv(b)) == 0 && sw == nullptr && tryStringWriter)
            {
                std::tie(sw, tryStringWriter) = gocpp::getValue<io::StringWriter>(b->wr);
            }
            if(Buffered(gocpp::recv(b)) == 0 && tryStringWriter)
            {
                std::tie(n, b->err) = WriteString(gocpp::recv(sw), s);
            }
            else
            {
                n = copy(b->buf.make_slice(b->n), s);
                b->n += n;
                Flush(gocpp::recv(b));
            }
            nn += n;
            s = s.make_slice(n);
        }
        if(b->err != nullptr)
        {
            return {nn, b->err};
        }
        auto n = copy(b->buf.make_slice(b->n), s);
        b->n += n;
        nn += n;
        return {nn, nullptr};
    }

    std::tuple<int64_t, std::string> ReadFrom(struct Writer* b, io::Reader r)
    {
        int64_t n;
        std::string err;
        if(b->err != nullptr)
        {
            int64_t n;
            std::string err;
            return {0, b->err};
        }
        auto [readerFrom, readerFromOK] = gocpp::getValue<io::ReaderFrom>(b->wr);
        int m = {};
        for(; ; )
        {
            int64_t n;
            std::string err;
            if(Available(gocpp::recv(b)) == 0)
            {
                int64_t n;
                std::string err;
                if(auto err1 = Flush(gocpp::recv(b)); err1 != nullptr)
                {
                    int64_t n;
                    std::string err;
                    return {n, err1};
                }
            }
            if(readerFromOK && Buffered(gocpp::recv(b)) == 0)
            {
                int64_t n;
                std::string err;
                auto [nn, err] = ReadFrom(gocpp::recv(readerFrom), r);
                b->err = err;
                n += nn;
                return {n, err};
            }
            auto nr = 0;
            for(; nr < maxConsecutiveEmptyReads; )
            {
                int64_t n;
                std::string err;
                std::tie(m, err) = Read(gocpp::recv(r), b->buf.make_slice(b->n));
                if(m != 0 || err != nullptr)
                {
                    int64_t n;
                    std::string err;
                    break;
                }
                nr++;
            }
            if(nr == maxConsecutiveEmptyReads)
            {
                int64_t n;
                std::string err;
                return {n, io::ErrNoProgress};
            }
            b->n += m;
            n += int64_t(m);
            if(err != nullptr)
            {
                int64_t n;
                std::string err;
                break;
            }
        }
        if(err == io::go_EOF)
        {
            int64_t n;
            std::string err;
            if(Available(gocpp::recv(b)) == 0)
            {
                int64_t n;
                std::string err;
                err = Flush(gocpp::recv(b));
            }
            else
            {
                int64_t n;
                std::string err;
                err = nullptr;
            }
        }
        return {n, err};
    }

    
    template<typename T>
    ReadWriter::operator T()
    {
        T result;
        return result;
    }

    template<typename T>
    bool ReadWriter::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& ReadWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriter& value)
    {
        return value.PrintTo(os);
    }

    ReadWriter* NewReadWriter(Reader* r, Writer* w)
    {
        return new ReadWriter {r, w};
    }

}

