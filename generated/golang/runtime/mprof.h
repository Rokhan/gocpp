// generated by GoCpp from file '$(ImportDir)/runtime/mprof.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mprof.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/cputicks.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/msan0.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/sema.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    struct bucket
    {
        sys::NotInHeap _;
        bucket* next;
        bucket* allnext;
        bucketType typ;
        uintptr_t hash;
        uintptr_t size;
        uintptr_t nstk;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bucket& value);
    struct memRecord
    {
        /* memRecordCycle active; [Known incomplete type] */
        gocpp::array<memRecordCycle, 3> future;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct memRecord& value);
    struct memRecordCycle
    {
        uintptr_t allocs;
        uintptr_t frees;
        uintptr_t alloc_bytes;
        uintptr_t free_bytes;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct memRecordCycle& value);
    void add(struct memRecordCycle* a, memRecordCycle* b);
    struct blockRecord
    {
        double count;
        int64_t cycles;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct blockRecord& value);
    struct mProfCycleHolder
    {
        /* atomic::Uint32 value; [Known incomplete type] */

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mProfCycleHolder& value);
    uint32_t read(struct mProfCycleHolder* c);
    std::tuple<uint32_t, bool> setFlushed(struct mProfCycleHolder* c);
    void increment(struct mProfCycleHolder* c);
    bucket* newBucket(bucketType typ, int nstk);
    gocpp::slice<uintptr_t> stk(struct bucket* b);
    memRecord* mp(struct bucket* b);
    blockRecord* bp(struct bucket* b);
    bucket* stkbucket(bucketType typ, uintptr_t size, gocpp::slice<uintptr_t> stk, bool alloc);
    bool eqslice(gocpp::slice<uintptr_t> x, gocpp::slice<uintptr_t> y);
    void mProf_NextCycle();
    void mProf_Flush();
    void mProf_FlushLocked(uint32_t index);
    void mProf_PostSweep();
    void mProf_Malloc(unsafe::Pointer p, uintptr_t size);
    void mProf_Free(bucket* b, uintptr_t size);
    void SetBlockProfileRate(int rate);
    void blockevent(int64_t cycles, int skip);
    bool blocksampled(int64_t cycles, int64_t rate);
    void saveblockevent(int64_t cycles, int64_t rate, int skip, bucketType which);
    struct lockTimer
    {
        /* mutex* lock; [Known incomplete type] */
        int64_t timeRate;
        int64_t timeStart;
        int64_t tickStart;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct lockTimer& value);
    void begin(struct lockTimer* lt);
    void end(struct lockTimer* lt);
    struct mLockProfile
    {
        /* atomic::Int64 waitTime; [Known incomplete type] */
        gocpp::array<uintptr_t, maxStack> stack;
        uintptr_t pending;
        int64_t cycles;
        int64_t cyclesLost;
        bool disabled;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mLockProfile& value);
    /* void recordLock(struct mLockProfile* prof, int64_t cycles, mutex* l); [Ignored, known name conflict] */ 
    /* void recordUnlock(struct mLockProfile* prof, mutex* l); [Ignored, known name conflict] */ 
    void captureStack(struct mLockProfile* prof);
    void store(struct mLockProfile* prof);
    void saveBlockEventStack(int64_t cycles, int64_t rate, gocpp::slice<uintptr_t> stk, bucketType which);
    int SetMutexProfileFraction(int rate);
    void mutexevent(int64_t cycles, int skip);
    struct StackRecord
    {
        gocpp::array<uintptr_t, 32> Stack0;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StackRecord& value);
    gocpp::slice<uintptr_t> Stack(struct StackRecord* r);
    extern int MemProfileRate;
    struct MemProfileRecord
    {
        int64_t AllocBytes;
        int64_t FreeBytes;
        int64_t AllocObjects;
        int64_t FreeObjects;
        gocpp::array<uintptr_t, 32> Stack0;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MemProfileRecord& value);
    int64_t InUseBytes(struct MemProfileRecord* r);
    int64_t InUseObjects(struct MemProfileRecord* r);
    gocpp::slice<uintptr_t> Stack(struct MemProfileRecord* r);
    std::tuple<int, bool> MemProfile(gocpp::slice<MemProfileRecord> p, bool inuseZero);
    void record(MemProfileRecord* r, bucket* b);
    void iterate_memprof(std::function<void (bucket*, uintptr_t, uintptr_t*, uintptr_t, uintptr_t, uintptr_t)> fn);
    struct BlockProfileRecord
    {
        int64_t Count;
        int64_t Cycles;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct BlockProfileRecord& value);
    std::tuple<int, bool> BlockProfile(gocpp::slice<BlockProfileRecord> p);
    std::tuple<int, bool> MutexProfile(gocpp::slice<BlockProfileRecord> p);
    std::tuple<int, bool> ThreadCreateProfile(gocpp::slice<StackRecord> p);
    std::tuple<int, bool> runtime_goroutineProfileWithLabels(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels);
    std::tuple<int, bool> goroutineProfileWithLabels(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels);
    extern gocpp_id_0 goroutineProfile;
    goroutineProfileState Load(struct goroutineProfileStateHolder* p);
    void Store(struct goroutineProfileStateHolder* p, goroutineProfileState value);
    bool CompareAndSwap(struct goroutineProfileStateHolder* p, goroutineProfileState old, goroutineProfileState go_new);
    std::tuple<int, bool> goroutineProfileWithLabelsConcurrent(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels);
    /* void tryRecordGoroutineProfileWB(g* gp1); [Ignored, known name conflict] */ 
    /* void tryRecordGoroutineProfile(g* gp1, std::function<void ()> yield); [Ignored, known name conflict] */ 
    /* void doRecordGoroutineProfile(g* gp1); [Ignored, known name conflict] */ 
    std::tuple<int, bool> goroutineProfileWithLabelsSync(gocpp::slice<StackRecord> p, gocpp::slice<unsafe::Pointer> labels);
    std::tuple<int, bool> GoroutineProfile(gocpp::slice<StackRecord> p);
    /* void saveg(uintptr_t pc, uintptr_t sp, g* gp, StackRecord* r); [Ignored, known name conflict] */ 
    int Stack(gocpp::slice<unsigned char> buf, bool all);
    void tracealloc(unsafe::Pointer p, uintptr_t size, _type* typ);
    void tracefree(unsafe::Pointer p, uintptr_t size);
    void tracegc();
}

