// generated by GoCpp from file '$(ImportDir)/runtime/symtabinl.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/symtabinl.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/symtab.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // inlinedCall is the encoding of entries in the FUNCDATA_InlTree table.
    
    template<typename T> requires gocpp::GoStruct<T>
    inlinedCall::operator T()
    {
        T result;
        result.funcID = this->funcID;
        result._1 = this->_1;
        result.nameOff = this->nameOff;
        result.parentPc = this->parentPc;
        result.startLine = this->startLine;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool inlinedCall::operator==(const T& ref) const
    {
        if (funcID != ref.funcID) return false;
        if (_1 != ref._1) return false;
        if (nameOff != ref.nameOff) return false;
        if (parentPc != ref.parentPc) return false;
        if (startLine != ref.startLine) return false;
        return true;
    }

    std::ostream& inlinedCall::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << funcID;
        os << " " << _1;
        os << " " << nameOff;
        os << " " << parentPc;
        os << " " << startLine;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct inlinedCall& value)
    {
        return value.PrintTo(os);
    }

    // An inlineUnwinder iterates over the stack of inlined calls at a PC by
    // decoding the inline table. The last step of iteration is always the frame of
    // the physical function, so there's always at least one frame.
    //
    // This is typically used as:
    //
    //	for u, uf := newInlineUnwinder(...); uf.valid(); uf = u.next(uf) { ... }
    //
    // Implementation note: This is used in contexts that disallow write barriers.
    // Hence, the constructor returns this by value and pointer receiver methods
    // must not mutate pointer fields. Also, we keep the mutable state in a separate
    // struct mostly to keep both structs SSA-able, which generates much better
    // code.
    
    template<typename T> requires gocpp::GoStruct<T>
    inlineUnwinder::operator T()
    {
        T result;
        result.f = this->f;
        result.inlTree = this->inlTree;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool inlineUnwinder::operator==(const T& ref) const
    {
        if (f != ref.f) return false;
        if (inlTree != ref.inlTree) return false;
        return true;
    }

    std::ostream& inlineUnwinder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << f;
        os << " " << inlTree;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct inlineUnwinder& value)
    {
        return value.PrintTo(os);
    }

    // An inlineFrame is a position in an inlineUnwinder.
    
    template<typename T> requires gocpp::GoStruct<T>
    inlineFrame::operator T()
    {
        T result;
        result.pc = this->pc;
        result.index = this->index;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool inlineFrame::operator==(const T& ref) const
    {
        if (pc != ref.pc) return false;
        if (index != ref.index) return false;
        return true;
    }

    std::ostream& inlineFrame::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pc;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct inlineFrame& value)
    {
        return value.PrintTo(os);
    }

    // newInlineUnwinder creates an inlineUnwinder initially set to the inner-most
    // inlined frame at PC. PC should be a "call PC" (not a "return PC").
    //
    // This unwinder uses non-strict handling of PC because it's assumed this is
    // only ever used for symbolic debugging. If things go really wrong, it'll just
    // fall back to the outermost frame.
    std::tuple<struct inlineUnwinder, struct inlineFrame> newInlineUnwinder(struct funcInfo f, uintptr_t pc)
    {
        auto inldata = funcdata(f, abi::FUNCDATA_InlTree);
        if(inldata == nullptr)
        {
            return {gocpp::Init<inlineUnwinder>([=](auto& x) {
                x.f = f;
            }), gocpp::Init<inlineFrame>([=](auto& x) {
                x.pc = pc;
                x.index = - 1;
            })};
        }
        auto inlTree = (gocpp::array<inlinedCall, 1 << 20>*)(inldata);
        auto u = gocpp::Init<inlineUnwinder>([=](auto& x) {
            x.f = f;
            x.inlTree = inlTree;
        });
        return {u, rec::resolveInternal(gocpp::recv(u), pc)};
    }

    struct inlineFrame rec::resolveInternal(struct inlineUnwinder* u, uintptr_t pc)
    {
        return gocpp::Init<inlineFrame>([=](auto& x) {
            x.pc = pc;
            x.index = pcdatavalue1(u->f, abi::PCDATA_InlTreeIndex, pc, false);
        });
    }

    bool rec::valid(struct inlineFrame uf)
    {
        return uf.pc != 0;
    }

    // next returns the frame representing uf's logical caller.
    struct inlineFrame rec::next(struct inlineUnwinder* u, struct inlineFrame uf)
    {
        if(uf.index < 0)
        {
            uf.pc = 0;
            return uf;
        }
        auto parentPc = u->inlTree[uf.index].parentPc;
        return rec::resolveInternal(gocpp::recv(u), rec::entry(gocpp::recv(u->f)) + uintptr_t(parentPc));
    }

    // isInlined returns whether uf is an inlined frame.
    bool rec::isInlined(struct inlineUnwinder* u, struct inlineFrame uf)
    {
        return uf.index >= 0;
    }

    // srcFunc returns the srcFunc representing the given frame.
    struct srcFunc rec::srcFunc(struct inlineUnwinder* u, struct inlineFrame uf)
    {
        if(uf.index < 0)
        {
            return rec::srcFunc(gocpp::recv(u->f));
        }
        auto t = & u->inlTree[uf.index];
        return srcFunc {u->f.datap, t->nameOff, t->startLine, t->funcID};
    }

    // fileLine returns the file name and line number of the call within the given
    // frame. As a convenience, for the innermost frame, it returns the file and
    // line of the PC this unwinder was started at (often this is a call to another
    // physical function).
    //
    // It returns "?", 0 if something goes wrong.
    std::tuple<std::string, int> rec::fileLine(struct inlineUnwinder* u, struct inlineFrame uf)
    {
        std::string file;
        int line;
        auto [file, line32] = funcline1(u->f, uf.pc, false);
        return {file, int(line32)};
    }

}

