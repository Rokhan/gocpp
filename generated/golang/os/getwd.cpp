// generated by GoCpp from file '$(ImportDir)/os/getwd.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/getwd.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir.h"
#include "golang/os/dir_windows.h"
#include "golang/os/env.h"
#include "golang/os/error.h"
#include "golang/os/file.h"
#include "golang/os/file_posix.h"
#include "golang/os/file_windows.h"
#include "golang/os/stat_windows.h"
#include "golang/os/types.h"
#include "golang/runtime/extern.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using mocklib::rec::Lock;
        using mocklib::rec::Unlock;
    }

    struct gocpp_id_0
    {
        mocklib::Mutex Mutex;
        gocpp::string dir;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.Mutex = this->Mutex;
            result.dir = this->dir;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (Mutex != ref.Mutex) return false;
            if (dir != ref.dir) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << Mutex;
            os << " " << dir;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 getwdCache;
    // Getwd returns a rooted path name corresponding to the
    // current directory. If the current directory can be
    // reached via multiple paths (due to symbolic links),
    // Getwd may return any one of them.
    std::tuple<gocpp::string, struct gocpp::error> Getwd()
    {
        gocpp::string dir;
        struct gocpp::error err;
        if(mocklib::GOOS == "windows"_s || mocklib::GOOS == "plan9"_s)
        {
            return syscall::Getwd();
        }
        fs::FileInfo dot;
        std::tie(dot, err) = statNolog("."_s);
        if(err != nullptr)
        {
            return {""_s, err};
        }
        dir = Getenv("PWD"_s);
        if(len(dir) > 0 && dir[0] == '/')
        {
            auto [d, err] = statNolog(dir);
            if(err == nullptr && SameFile(dot, d))
            {
                return {dir, nullptr};
            }
        }
        if(syscall::ImplementsGetwd)
        {
            gocpp::string s = {};
            gocpp::error e = {};
            for(; ; )
            {
                std::tie(s, e) = syscall::Getwd();
                if(e != syscall::go_EINTR)
                {
                    break;
                }
            }
            return {s, NewSyscallError("getwd"_s, e)};
        }
        rec::Lock(gocpp::recv(getwdCache));
        dir = getwdCache.dir;
        rec::Unlock(gocpp::recv(getwdCache));
        if(len(dir) > 0)
        {
            auto [d, err] = statNolog(dir);
            if(err == nullptr && SameFile(dot, d))
            {
                return {dir, nullptr};
            }
        }
        fs::FileInfo root;
        std::tie(root, err) = statNolog("/"_s);
        if(err != nullptr)
        {
            return {""_s, err};
        }
        if(SameFile(root, dot))
        {
            return {"/"_s, nullptr};
        }
        dir = ""_s;
        for(auto parent = ".."_s; ; parent = "../"_s + parent)
        {
            if(len(parent) >= 1024)
            {
                return {""_s, gocpp::error(syscall::go_ENAMETOOLONG)};
            }
            auto [fd, err] = openFileNolog(parent, O_RDONLY, 0);
            if(err != nullptr)
            {
                return {""_s, err};
            }
            for(; ; )
            {
                auto [names, err] = rec::Readdirnames(gocpp::recv(fd), 100);
                if(err != nullptr)
                {
                    rec::Close(gocpp::recv(fd));
                    return {""_s, err};
                }
                for(auto [gocpp_ignored, name] : names)
                {
                    auto [d, gocpp_id_1] = lstatNolog(parent + "/"_s + name);
                    if(SameFile(d, dot))
                    {
                        dir = "/"_s + name + dir;
                        goto Found;
                    }
                }
            }
            Found:
            fs::FileInfo pd;
            std::tie(pd, err) = rec::Stat(gocpp::recv(fd));
            rec::Close(gocpp::recv(fd));
            if(err != nullptr)
            {
                return {""_s, err};
            }
            if(SameFile(pd, root))
            {
                break;
            }
            dot = pd;
        }
        rec::Lock(gocpp::recv(getwdCache));
        getwdCache.dir = dir;
        rec::Unlock(gocpp::recv(getwdCache));
        return {dir, nullptr};
    }

}

