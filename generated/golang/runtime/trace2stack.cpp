// generated by GoCpp from file '$(ImportDir)/runtime/trace2stack.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2stack.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/stubs_amd64.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/symtabinl.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Maximum number of PCs in a single stack trace.
    // Since events contain only stack id rather than whole stack trace,
    // we can allow quite large values here.
    // logicalStackSentinel is a sentinel value at pcBuf[0] signifying that
    // pcBuf[1:] holds a logical stack requiring no further processing. Any other
    // value at pcBuf[0] represents a skip value to apply to the physical stack in
    // pcBuf[1:] after inline expansion.
    // traceStack captures a stack trace and registers it in the trace stack table.
    // It then returns its unique ID.
    //
    // skip controls the number of leaf frames to omit in order to hide tracer internals
    // from stack traces, see CL 5523.
    //
    // Avoid calling this function directly. gen needs to be the current generation
    // that this stack trace is being written out for, which needs to be synchronized with
    // generations moving forward. Prefer traceEventWriter.stack.
    uint64_t traceStack(int skip, struct m* mp, uintptr_t gen)
    {
        gocpp::array<uintptr_t, traceStackSize> pcBuf = {};
        auto gp = getg();
        auto curgp = gp->m->curg;
        auto nstk = 1;
        if(tracefpunwindoff() || rec::hasCgoOnStack(gocpp::recv(mp)))
        {
            pcBuf[0] = logicalStackSentinel;
            if(curgp == gp)
            {
                nstk += callers(skip + 1, pcBuf.make_slice(1));
            }
            else
            if(curgp != nullptr)
            {
                nstk += gcallers(curgp, skip, pcBuf.make_slice(1));
            }
        }
        else
        {
            pcBuf[0] = uintptr_t(skip);
            if(curgp == gp)
            {
                nstk += fpTracebackPCs(unsafe::Pointer(getfp()), pcBuf.make_slice(1));
            }
            else
            if(curgp != nullptr)
            {
                pcBuf[1] = curgp->sched.pc;
                nstk += 1 + fpTracebackPCs(unsafe::Pointer(curgp->sched.bp), pcBuf.make_slice(2));
            }
        }
        if(nstk > 0)
        {
            nstk--;
        }
        if(nstk > 0 && curgp->goid == 1)
        {
            nstk--;
        }
        auto id = rec::put(gocpp::recv(trace.stackTab[gen % 2]), pcBuf.make_slice(0, nstk));
        return id;
    }

    // traceStackTable maps stack traces (arrays of PC's) to unique uint32 ids.
    // It is lock-free for reading.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceStackTable::operator T()
    {
        T result;
        result.tab = this->tab;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceStackTable::operator==(const T& ref) const
    {
        if (tab != ref.tab) return false;
        return true;
    }

    std::ostream& traceStackTable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceStackTable& value)
    {
        return value.PrintTo(os);
    }

    // put returns a unique id for the stack trace pcs and caches it in the table,
    // if it sees the trace for the first time.
    uint64_t rec::put(struct traceStackTable* t, gocpp::slice<uintptr_t> pcs)
    {
        if(len(pcs) == 0)
        {
            return 0;
        }
        auto [id, gocpp_id_0] = rec::put(gocpp::recv(t->tab), noescape(unsafe::Pointer(& pcs[0])), uintptr_t(len(pcs)) * gocpp::Sizeof<uintptr_t>());
        return id;
    }

    // dump writes all previously cached stacks to trace buffers,
    // releases all memory and resets state. It must only be called once the caller
    // can guarantee that there are no more writers to the table.
    //
    // This must run on the system stack because it flushes buffers and thus
    // may acquire trace.lock.
    //
    //go:systemstack
    void rec::dump(struct traceStackTable* t, uintptr_t gen)
    {
        auto w = unsafeTraceWriter(gen, nullptr);
        for(auto [i, gocpp_ignored] : t->tab.tab)
        {
            auto stk = rec::bucket(gocpp::recv(t->tab), i);
            for(; stk != nullptr; stk = rec::next(gocpp::recv(stk)))
            {
                auto stack = unsafe::Slice((uintptr_t*)(unsafe::Pointer(& stk->data[0])), uintptr_t(len(stk->data)) / gocpp::Sizeof<uintptr_t>());
                auto frames = makeTraceFrames(gen, fpunwindExpand(stack));
                auto maxBytes = 1 + (2 + 4 * len(frames)) * traceBytesPerNumber;
                // Estimate the size of this record. This
                // bound is pretty loose, but avoids counting
                // lots of varint sizes.
                //
                // Add 1 because we might also write traceEvStacks.
                bool flushed = {};
                std::tie(w, flushed) = rec::ensure(gocpp::recv(w), 1 + maxBytes);
                if(flushed)
                {
                    rec::byte(gocpp::recv(w), (unsigned char)(traceEvStacks));
                }
                rec::byte(gocpp::recv(w), (unsigned char)(traceEvStack));
                rec::varint(gocpp::recv(w), uint64_t(stk->id));
                rec::varint(gocpp::recv(w), uint64_t(len(frames)));
                for(auto [gocpp_ignored, frame] : frames)
                {
                    rec::varint(gocpp::recv(w), uint64_t(frame.PC));
                    rec::varint(gocpp::recv(w), frame.funcID);
                    rec::varint(gocpp::recv(w), frame.fileID);
                    rec::varint(gocpp::recv(w), frame.line);
                }
            }
        }
        lock(& t->tab.lock);
        rec::reset(gocpp::recv(t->tab));
        unlock(& t->tab.lock);
        rec::end(gocpp::recv(rec::flush(gocpp::recv(w))));
    }

    // makeTraceFrames returns the frames corresponding to pcs. It may
    // allocate and may emit trace events.
    gocpp::slice<traceFrame> makeTraceFrames(uintptr_t gen, gocpp::slice<uintptr_t> pcs)
    {
        auto frames = gocpp::make(gocpp::Tag<gocpp::slice<traceFrame>>(), 0, len(pcs));
        auto ci = CallersFrames(pcs);
        for(; ; )
        {
            auto [f, more] = rec::Next(gocpp::recv(ci));
            frames = append(frames, makeTraceFrame(gen, f));
            if(! more)
            {
                return frames;
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceFrame::operator T()
    {
        T result;
        result.PC = this->PC;
        result.funcID = this->funcID;
        result.fileID = this->fileID;
        result.line = this->line;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceFrame::operator==(const T& ref) const
    {
        if (PC != ref.PC) return false;
        if (funcID != ref.funcID) return false;
        if (fileID != ref.fileID) return false;
        if (line != ref.line) return false;
        return true;
    }

    std::ostream& traceFrame::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PC;
        os << " " << funcID;
        os << " " << fileID;
        os << " " << line;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceFrame& value)
    {
        return value.PrintTo(os);
    }

    // makeTraceFrame sets up a traceFrame for a frame.
    struct traceFrame makeTraceFrame(uintptr_t gen, struct Frame f)
    {
        traceFrame frame = {};
        frame.PC = f.PC;
        auto fn = f.Function;
        auto maxLen = 1 << 10;
        if(len(fn) > maxLen)
        {
            fn = fn.make_slice(len(fn) - maxLen);
        }
        frame.funcID = rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, fn);
        frame.line = uint64_t(f.Line);
        auto file = f.File;
        if(len(file) > maxLen)
        {
            file = file.make_slice(len(file) - maxLen);
        }
        frame.fileID = rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, file);
        return frame;
    }

    // tracefpunwindoff returns true if frame pointer unwinding for the tracer is
    // disabled via GODEBUG or not supported by the architecture.
    bool tracefpunwindoff()
    {
        return debug.tracefpunwindoff != 0 || (goarch::ArchFamily != goarch::AMD64 && goarch::ArchFamily != goarch::ARM64);
    }

    // fpTracebackPCs populates pcBuf with the return addresses for each frame and
    // returns the number of PCs written to pcBuf. The returned PCs correspond to
    // "physical frames" rather than "logical frames"; that is if A is inlined into
    // B, this will return a PC for only B.
    int fpTracebackPCs(unsafe::Pointer fp, gocpp::slice<uintptr_t> pcBuf)
    {
        int i;
        for(i = 0; i < len(pcBuf) && fp != nullptr; i++)
        {
            pcBuf[i] = *(uintptr_t*)(unsafe::Pointer(uintptr_t(fp) + goarch::PtrSize));
            fp = unsafe::Pointer(*(uintptr_t*)(fp));
        }
        return i;
    }

    // fpunwindExpand checks if pcBuf contains logical frames (which include inlined
    // frames) or physical frames (produced by frame pointer unwinding) using a
    // sentinel value in pcBuf[0]. Logical frames are simply returned without the
    // sentinel. Physical frames are turned into logical frames via inline unwinding
    // and by applying the skip value that's stored in pcBuf[0].
    gocpp::slice<uintptr_t> fpunwindExpand(gocpp::slice<uintptr_t> pcBuf)
    {
        if(len(pcBuf) > 0 && pcBuf[0] == logicalStackSentinel)
        {
            return pcBuf.make_slice(1);
        }
        // skipOrAdd skips or appends retPC to newPCBuf and returns true if more
        // pcs can be added.
        auto lastFuncID = abi::FuncIDNormal;
        auto newPCBuf = gocpp::make(gocpp::Tag<gocpp::slice<uintptr_t>>(), 0, traceStackSize);
        auto skip = pcBuf[0];
        auto skipOrAdd = [=](uintptr_t retPC) mutable -> bool
        {
            if(skip > 0)
            {
                skip--;
            }
            else
            {
                newPCBuf = append(newPCBuf, retPC);
            }
            return len(newPCBuf) < cap(newPCBuf);
        };
        outer:
        for(auto [gocpp_ignored, retPC] : pcBuf.make_slice(1))
        {
            auto callPC = retPC - 1;
            auto fi = findfunc(callPC);
            if(! rec::valid(gocpp::recv(fi)))
            {
                if(auto more = skipOrAdd(retPC); ! more)
                {
                    goto outer_break;
                }
                continue;
            }
            auto [u, uf] = newInlineUnwinder(fi, callPC);
            for(; rec::valid(gocpp::recv(uf)); uf = rec::next(gocpp::recv(u), uf))
            {
                auto sf = rec::srcFunc(gocpp::recv(u), uf);
                if(sf.funcID == abi::FuncIDWrapper && elideWrapperCalling(lastFuncID))
                {
                }
                else
                if(auto more = skipOrAdd(uf.pc + 1); ! more)
                {
                    goto outer_break;
                }
                lastFuncID = sf.funcID;
            }
            if(false) {
            outer_continue:
                continue;
            outer_break:
                break;
            }
        }
        return newPCBuf;
    }

    // startPCForTrace returns the start PC of a goroutine for tracing purposes.
    // If pc is a wrapper, it returns the PC of the wrapped function. Otherwise it
    // returns pc.
    uintptr_t startPCForTrace(uintptr_t pc)
    {
        auto f = findfunc(pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return pc;
        }
        auto w = funcdata(f, abi::FUNCDATA_WrapInfo);
        if(w == nullptr)
        {
            return pc;
        }
        return rec::textAddr(gocpp::recv(f.datap), *(uint32_t*)(w));
    }

}

