// generated by GoCpp from file '$(ImportDir)/runtime/time.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/time.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct timer
    {
        golang::runtime::puintptr pp;
        int64_t when;
        int64_t period;
        std::function<void (go_any _1, uintptr_t _2)> f;
        go_any arg;
        uintptr_t seq;
        int64_t nextwhen;
        atomic::Uint32 status;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct timer& value);
    void timeSleep(int64_t ns);
    bool resetForSleep(struct g* gp, unsafe::Pointer ut);
    void startTimer(struct timer* t);
    bool stopTimer(struct timer* t);
    bool resetTimer(struct timer* t, int64_t when);
    void modTimer(struct timer* t, int64_t when, int64_t period, std::function<void (go_any _1, uintptr_t _2)> f, go_any arg, uintptr_t seq);
    void goroutineReady(go_any arg, uintptr_t seq);
    void addtimer(struct timer* t);
    void doaddtimer(struct p* pp, struct timer* t);
    bool deltimer(struct timer* t);
    int dodeltimer(struct p* pp, int i);
    void dodeltimer0(struct p* pp);
    bool modtimer(struct timer* t, int64_t when, int64_t period, std::function<void (go_any _1, uintptr_t _2)> f, go_any arg, uintptr_t seq);
    bool resettimer(struct timer* t, int64_t when);
    void cleantimers(struct p* pp);
    void moveTimers(struct p* pp, gocpp::slice<timer*> timers);
    void adjusttimers(struct p* pp, int64_t now);
    void addAdjustedTimers(struct p* pp, gocpp::slice<timer*> moved);
    int64_t nobarrierWakeTime(struct p* pp);
    int64_t runtimer(struct p* pp, int64_t now);
    void runOneTimer(struct p* pp, struct timer* t, int64_t now);
    void clearDeletedTimers(struct p* pp);
    void verifyTimerHeap(struct p* pp);
    void updateTimer0When(struct p* pp);
    void updateTimerModifiedEarliest(struct p* pp, int64_t nextwhen);
    int64_t timeSleepUntil();
    int siftupTimer(gocpp::slice<timer*> t, int i);
    void siftdownTimer(gocpp::slice<timer*> t, int i);
    void badTimer();

    namespace rec
    {
    }
}

