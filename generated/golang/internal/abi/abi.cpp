// generated by GoCpp from file '$(ImportDir)/internal/abi/abi.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/abi.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi_amd64.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/unsafe/unsafe.h"

namespace golang::abi
{
    
    template<typename T> requires gocpp::GoStruct<T>
    RegArgs::operator T()
    {
        T result;
        result.Ints = this->Ints;
        result.Floats = this->Floats;
        result.Ptrs = this->Ptrs;
        result.ReturnIsPtr = this->ReturnIsPtr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RegArgs::operator==(const T& ref) const
    {
        if (Ints != ref.Ints) return false;
        if (Floats != ref.Floats) return false;
        if (Ptrs != ref.Ptrs) return false;
        if (ReturnIsPtr != ref.ReturnIsPtr) return false;
        return true;
    }

    std::ostream& RegArgs::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Ints;
        os << " " << Floats;
        os << " " << Ptrs;
        os << " " << ReturnIsPtr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RegArgs& value)
    {
        return value.PrintTo(os);
    }

    void Dump(struct RegArgs* r)
    {
        print("Ints:");
        for(auto [_, x] : r->Ints)
        {
            print(" ", x);
        }
        println();
        print("Floats:");
        for(auto [_, x] : r->Floats)
        {
            print(" ", x);
        }
        println();
        print("Ptrs:");
        for(auto [_, x] : r->Ptrs)
        {
            print(" ", x);
        }
        println();
    }

    unsafe::Pointer IntRegArgAddr(struct RegArgs* r, int reg, uintptr_t argSize)
    {
        if(argSize > goarch::PtrSize || argSize == 0 || argSize & (argSize - 1) != 0)
        {
            gocpp::panic("invalid argSize");
        }
        auto offset = uintptr_t(0);
        if(goarch::BigEndian)
        {
            offset = goarch::PtrSize - argSize;
        }
        return unsafe::Pointer(uintptr_t(unsafe::Pointer(& r->Ints[reg])) + offset);
    }

    void Set(IntArgRegBitmap* b, int i)
    {
        b[i / 8] |= uint8_t(1) << (i % 8);
    }

    bool Get(IntArgRegBitmap* b, int i)
    {
        return b[i / 8] & (uint8_t(1) << (i % 8)) != 0;
    }

}

