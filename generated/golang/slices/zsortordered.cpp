// generated by GoCpp from file '$(ImportDir)/slices/zsortordered.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/slices/zsortordered.h"
#include "gocpp/support.h"

#include "golang/cmp/cmp.h"
#include "golang/slices/sort.h"

namespace golang::slices
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // insertionSortOrdered sorts data[a:b] using insertion sort.
    template<typename E>
    void insertionSortOrdered(gocpp::slice<E> data, int a, int b)
    {
        for(auto i = a + 1; i < b; i++)
        {
            for(auto j = i; j > a && cmp::Less(data[j], data[j - 1]); j--)
            {
                std::tie(data[j], data[j - 1]) = std::tuple{data[j - 1], data[j]};
            }
        }
    }

    // siftDownOrdered implements the heap property on data[lo:hi].
    // first is an offset into the array where the root of the heap lies.
    template<typename E>
    void siftDownOrdered(gocpp::slice<E> data, int lo, int hi, int first)
    {
        auto root = lo;
        for(; ; )
        {
            auto child = 2 * root + 1;
            if(child >= hi)
            {
                break;
            }
            if(child + 1 < hi && cmp::Less(data[first + child], data[first + child + 1]))
            {
                child++;
            }
            if(! cmp::Less(data[first + root], data[first + child]))
            {
                return;
            }
            std::tie(data[first + root], data[first + child]) = std::tuple{data[first + child], data[first + root]};
            root = child;
        }
    }

    template<typename E>
    void heapSortOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto first = a;
        auto lo = 0;
        auto hi = b - a;
        for(auto i = (hi - 1) / 2; i >= 0; i--)
        {
            siftDownOrdered(data, i, hi, first);
        }
        for(auto i = hi - 1; i >= 0; i--)
        {
            std::tie(data[first], data[first + i]) = std::tuple{data[first + i], data[first]};
            siftDownOrdered(data, lo, i, first);
        }
    }

    // pdqsortOrdered sorts data[a:b].
    // The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
    // pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
    // C++ implementation: https://github.com/orlp/pdqsort
    // Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
    // limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
    template<typename E>
    void pdqsortOrdered(gocpp::slice<E> data, int a, int b, int limit)
    {
        auto maxInsertion = 12;
        auto wasBalanced = true;
        auto wasPartitioned = true;
        for(; ; )
        {
            auto length = b - a;
            if(length <= maxInsertion)
            {
                insertionSortOrdered(data, a, b);
                return;
            }
            if(limit == 0)
            {
                heapSortOrdered(data, a, b);
                return;
            }
            if(! wasBalanced)
            {
                breakPatternsOrdered(data, a, b);
                limit--;
            }
            auto [pivot, hint] = choosePivotOrdered(data, a, b);
            if(hint == decreasingHint)
            {
                reverseRangeOrdered(data, a, b);
                pivot = (b - 1) - (pivot - a);
                hint = increasingHint;
            }
            if(wasBalanced && wasPartitioned && hint == increasingHint)
            {
                if(partialInsertionSortOrdered(data, a, b))
                {
                    return;
                }
            }
            if(a > 0 && ! cmp::Less(data[a - 1], data[pivot]))
            {
                auto mid = partitionEqualOrdered(data, a, b, pivot);
                a = mid;
                continue;
            }
            auto [mid, alreadyPartitioned] = partitionOrdered(data, a, b, pivot);
            wasPartitioned = alreadyPartitioned;
            auto [leftLen, rightLen] = std::tuple{mid - a, b - mid};
            auto balanceThreshold = length / 8;
            if(leftLen < rightLen)
            {
                wasBalanced = leftLen >= balanceThreshold;
                pdqsortOrdered(data, a, mid, limit);
                a = mid + 1;
            }
            else
            {
                wasBalanced = rightLen >= balanceThreshold;
                pdqsortOrdered(data, mid + 1, b, limit);
                b = mid;
            }
        }
    }

    // partitionOrdered does one quicksort partition.
    // Let p = data[pivot]
    // Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
    // On return, data[newpivot] = p
    template<typename E>
    std::tuple<int, bool> partitionOrdered(gocpp::slice<E> data, int a, int b, int pivot)
    {
        int newpivot;
        bool alreadyPartitioned;
        std::tie(data[a], data[pivot]) = std::tuple{data[pivot], data[a]};
        auto [i, j] = std::tuple{a + 1, b - 1};
        for(; i <= j && cmp::Less(data[i], data[a]); )
        {
            i++;
        }
        for(; i <= j && ! cmp::Less(data[j], data[a]); )
        {
            j--;
        }
        if(i > j)
        {
            std::tie(data[j], data[a]) = std::tuple{data[a], data[j]};
            return {j, true};
        }
        std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
        i++;
        j--;
        for(; ; )
        {
            for(; i <= j && cmp::Less(data[i], data[a]); )
            {
                i++;
            }
            for(; i <= j && ! cmp::Less(data[j], data[a]); )
            {
                j--;
            }
            if(i > j)
            {
                break;
            }
            std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
            i++;
            j--;
        }
        std::tie(data[j], data[a]) = std::tuple{data[a], data[j]};
        return {j, false};
    }

    // partitionEqualOrdered partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
    // It assumed that data[a:b] does not contain elements smaller than the data[pivot].
    template<typename E>
    int partitionEqualOrdered(gocpp::slice<E> data, int a, int b, int pivot)
    {
        int newpivot;
        std::tie(data[a], data[pivot]) = std::tuple{data[pivot], data[a]};
        auto [i, j] = std::tuple{a + 1, b - 1};
        for(; ; )
        {
            for(; i <= j && ! cmp::Less(data[a], data[i]); )
            {
                i++;
            }
            for(; i <= j && cmp::Less(data[a], data[j]); )
            {
                j--;
            }
            if(i > j)
            {
                break;
            }
            std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
            i++;
            j--;
        }
        return i;
    }

    // partialInsertionSortOrdered partially sorts a slice, returns true if the slice is sorted at the end.
    template<typename E>
    bool partialInsertionSortOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto maxSteps = 5;
        auto shortestShifting = 50;
        auto i = a + 1;
        for(auto j = 0; j < maxSteps; j++)
        {
            for(; i < b && ! cmp::Less(data[i], data[i - 1]); )
            {
                i++;
            }
            if(i == b)
            {
                return true;
            }
            if(b - a < shortestShifting)
            {
                return false;
            }
            std::tie(data[i], data[i - 1]) = std::tuple{data[i - 1], data[i]};
            if(i - a >= 2)
            {
                for(auto j = i - 1; j >= 1; j--)
                {
                    if(! cmp::Less(data[j], data[j - 1]))
                    {
                        break;
                    }
                    std::tie(data[j], data[j - 1]) = std::tuple{data[j - 1], data[j]};
                }
            }
            if(b - i >= 2)
            {
                for(auto j = i + 1; j < b; j++)
                {
                    if(! cmp::Less(data[j], data[j - 1]))
                    {
                        break;
                    }
                    std::tie(data[j], data[j - 1]) = std::tuple{data[j - 1], data[j]};
                }
            }
        }
        return false;
    }

    // breakPatternsOrdered scatters some elements around in an attempt to break some patterns
    // that might cause imbalanced partitions in quicksort.
    template<typename E>
    void breakPatternsOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto length = b - a;
        if(length >= 8)
        {
            auto random = xorshift(length);
            auto modulus = nextPowerOfTwo(length);
            for(auto idx = a + (length / 4) * 2 - 1; idx <= a + (length / 4) * 2 + 1; idx++)
            {
                auto other = int((unsigned int)(rec::Next(gocpp::recv(random))) & (modulus - 1));
                if(other >= length)
                {
                    other -= length;
                }
                std::tie(data[idx], data[a + other]) = std::tuple{data[a + other], data[idx]};
            }
        }
    }

    // choosePivotOrdered chooses a pivot in data[a:b].
    //
    // [0,8): chooses a static pivot.
    // [8,shortestNinther): uses the simple median-of-three method.
    // [shortestNinther,âˆž): uses the Tukey ninther method.
    template<typename E>
    std::tuple<int, slices::sortedHint> choosePivotOrdered(gocpp::slice<E> data, int a, int b)
    {
        int pivot;
        slices::sortedHint hint;
        auto shortestNinther = 50;
        auto maxSwaps = 4 * 3;
        auto l = b - a;
        int swaps = {};
        auto i = a + l / 4 * 1;
        auto j = a + l / 4 * 2;
        auto k = a + l / 4 * 3;
        if(l >= 8)
        {
            if(l >= shortestNinther)
            {
                i = medianAdjacentOrdered(data, i, & swaps);
                j = medianAdjacentOrdered(data, j, & swaps);
                k = medianAdjacentOrdered(data, k, & swaps);
            }
            j = medianOrdered(data, i, j, k, & swaps);
        }
        //Go switch emulation
        {
            auto condition = swaps;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == maxSwaps) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return {j, increasingHint};
                    break;
                case 1:
                    return {j, decreasingHint};
                    break;
                default:
                    return {j, unknownHint};
                    break;
            }
        }
    }

    // order2Ordered returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.
    template<typename E>
    std::tuple<int, int> order2Ordered(gocpp::slice<E> data, int a, int b, int* swaps)
    {
        if(cmp::Less(data[b], data[a]))
        {
            *swaps++;
            return {b, a};
        }
        return {a, b};
    }

    // medianOrdered returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.
    template<typename E>
    int medianOrdered(gocpp::slice<E> data, int a, int b, int c, int* swaps)
    {
        std::tie(a, b) = order2Ordered(data, a, b, swaps);
        std::tie(b, c) = order2Ordered(data, b, c, swaps);
        std::tie(a, b) = order2Ordered(data, a, b, swaps);
        return b;
    }

    // medianAdjacentOrdered finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.
    template<typename E>
    int medianAdjacentOrdered(gocpp::slice<E> data, int a, int* swaps)
    {
        return medianOrdered(data, a - 1, a, a + 1, swaps);
    }

    template<typename E>
    void reverseRangeOrdered(gocpp::slice<E> data, int a, int b)
    {
        auto i = a;
        auto j = b - 1;
        for(; i < j; )
        {
            std::tie(data[i], data[j]) = std::tuple{data[j], data[i]};
            i++;
            j--;
        }
    }

    template<typename E>
    void swapRangeOrdered(gocpp::slice<E> data, int a, int b, int n)
    {
        for(auto i = 0; i < n; i++)
        {
            std::tie(data[a + i], data[b + i]) = std::tuple{data[b + i], data[a + i]};
        }
    }

    template<typename E>
    void stableOrdered(gocpp::slice<E> data, int n)
    {
        auto blockSize = 20;
        auto [a, b] = std::tuple{0, blockSize};
        for(; b <= n; )
        {
            insertionSortOrdered(data, a, b);
            a = b;
            b += blockSize;
        }
        insertionSortOrdered(data, a, n);
        for(; blockSize < n; )
        {
            std::tie(a, b) = std::tuple{0, 2 * blockSize};
            for(; b <= n; )
            {
                symMergeOrdered(data, a, a + blockSize, b);
                a = b;
                b += 2 * blockSize;
            }
            if(auto m = a + blockSize; m < n)
            {
                symMergeOrdered(data, a, m, n);
            }
            blockSize *= 2;
        }
    }

    // symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
    // the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
    // Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
    // Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
    // Computer Science, pages 714-723. Springer, 2004.
    //
    // Let M = m-a and N = b-n. Wolog M < N.
    // The recursion depth is bound by ceil(log(N+M)).
    // The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
    // The algorithm needs O((M+N)*log(M)) calls to data.Swap.
    //
    // The paper gives O((M+N)*log(M)) as the number of assignments assuming a
    // rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
    // in the paper carries through for Swap operations, especially as the block
    // swapping rotate uses only O(M+N) Swaps.
    //
    // symMerge assumes non-degenerate arguments: a < m && m < b.
    // Having the caller check this condition eliminates many leaf recursion calls,
    // which improves performance.
    template<typename E>
    void symMergeOrdered(gocpp::slice<E> data, int a, int m, int b)
    {
        if(m - a == 1)
        {
            auto i = m;
            auto j = b;
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(cmp::Less(data[h], data[a]))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto k = a; k < i - 1; k++)
            {
                std::tie(data[k], data[k + 1]) = std::tuple{data[k + 1], data[k]};
            }
            return;
        }
        if(b - m == 1)
        {
            auto i = a;
            auto j = m;
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(! cmp::Less(data[m], data[h]))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto k = m; k > i; k--)
            {
                std::tie(data[k], data[k - 1]) = std::tuple{data[k - 1], data[k]};
            }
            return;
        }
        auto mid = int((unsigned int)(a + b) >> 1);
        auto n = mid + m;
        int start = {};
        int r = {};
        if(m > mid)
        {
            start = n - b;
            r = mid;
        }
        else
        {
            start = a;
            r = m;
        }
        auto p = n - 1;
        for(; start < r; )
        {
            auto c = int((unsigned int)(start + r) >> 1);
            if(! cmp::Less(data[p - c], data[c]))
            {
                start = c + 1;
            }
            else
            {
                r = c;
            }
        }
        auto end = n - start;
        if(start < m && m < end)
        {
            rotateOrdered(data, start, m, end);
        }
        if(a < start && start < mid)
        {
            symMergeOrdered(data, a, start, mid);
        }
        if(mid < end && end < b)
        {
            symMergeOrdered(data, mid, end, b);
        }
    }

    // rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
    // Data of the form 'x u v y' is changed to 'x v u y'.
    // rotate performs at most b-a many calls to data.Swap,
    // and it assumes non-degenerate arguments: a < m && m < b.
    template<typename E>
    void rotateOrdered(gocpp::slice<E> data, int a, int m, int b)
    {
        auto i = m - a;
        auto j = b - m;
        for(; i != j; )
        {
            if(i > j)
            {
                swapRangeOrdered(data, m - i, m, j);
                i -= j;
            }
            else
            {
                swapRangeOrdered(data, m - i, m + j - i, i);
                j -= i;
            }
        }
        swapRangeOrdered(data, m - i, m, i);
    }

}

