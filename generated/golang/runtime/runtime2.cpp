// generated by GoCpp from file '$(ImportDir)/runtime/runtime2.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime2.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& mutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << key;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mutex& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& note::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << key;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct note& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& funcval::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct funcval& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& iface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << tab;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct iface& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& eface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _type;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct eface& value)
    {
        return value.PrintTo(os);
    }

    eface* efaceOf(go_any* ep)
    {
        return (eface*)(unsafe::Pointer(ep));
    }

    g* ptr(guintptr gp)
    {
        return (g*)(unsafe::Pointer(gp));
    }

    void set(guintptr* gp, g* g)
    {
        *gp = guintptr(unsafe::Pointer(g));
    }

    bool cas(guintptr* gp, guintptr old, guintptr go_new)
    {
        return atomic::Casuintptr((uintptr_t*)(unsafe::Pointer(gp)), uintptr_t(old), uintptr_t(go_new));
    }

    guintptr guintptr(struct g* gp)
    {
        return guintptr(unsafe::Pointer(gp));
    }

    void setGNoWB(g** gp, g* go_new)
    {
        set(gocpp::recv((guintptr*)(unsafe::Pointer(gp))), go_new);
    }

    p* ptr(puintptr pp)
    {
        return (p*)(unsafe::Pointer(pp));
    }

    void set(puintptr* pp, p* p)
    {
        *pp = puintptr(unsafe::Pointer(p));
    }

    m* ptr(muintptr mp)
    {
        return (m*)(unsafe::Pointer(mp));
    }

    void set(muintptr* mp, m* m)
    {
        *mp = muintptr(unsafe::Pointer(m));
    }

    void setMNoWB(m** mp, m* go_new)
    {
        set(gocpp::recv((muintptr*)(unsafe::Pointer(mp))), go_new);
    }

    
    std::ostream& gobuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << sp;
        os << " " << pc;
        os << " " << g;
        os << " " << ctxt;
        os << " " << ret;
        os << " " << lr;
        os << " " << bp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gobuf& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& sudog::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g;
        os << " " << next;
        os << " " << prev;
        os << " " << elem;
        os << " " << acquiretime;
        os << " " << releasetime;
        os << " " << ticket;
        os << " " << isSelect;
        os << " " << success;
        os << " " << waiters;
        os << " " << parent;
        os << " " << waitlink;
        os << " " << waittail;
        os << " " << c;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sudog& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& libcall::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << n;
        os << " " << args;
        os << " " << r1;
        os << " " << r2;
        os << " " << err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct libcall& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& stack::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lo;
        os << " " << hi;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stack& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& heldLockInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lockAddr;
        os << " " << rank;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heldLockInfo& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& g::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stack;
        os << " " << stackguard0;
        os << " " << stackguard1;
        os << " " << _panic;
        os << " " << _defer;
        os << " " << m;
        os << " " << sched;
        os << " " << syscallsp;
        os << " " << syscallpc;
        os << " " << stktopsp;
        os << " " << param;
        os << " " << atomicstatus;
        os << " " << stackLock;
        os << " " << goid;
        os << " " << schedlink;
        os << " " << waitsince;
        os << " " << waitreason;
        os << " " << preempt;
        os << " " << preemptStop;
        os << " " << preemptShrink;
        os << " " << asyncSafePoint;
        os << " " << paniconfault;
        os << " " << gcscandone;
        os << " " << throwsplit;
        os << " " << activeStackChans;
        os << " " << parkingOnChan;
        os << " " << inMarkAssist;
        os << " " << coroexit;
        os << " " << raceignore;
        os << " " << nocgocallback;
        os << " " << tracking;
        os << " " << trackingSeq;
        os << " " << trackingStamp;
        os << " " << runnableTime;
        os << " " << lockedm;
        os << " " << sig;
        os << " " << writebuf;
        os << " " << sigcode0;
        os << " " << sigcode1;
        os << " " << sigpc;
        os << " " << parentGoid;
        os << " " << gopc;
        os << " " << ancestors;
        os << " " << startpc;
        os << " " << racectx;
        os << " " << waiting;
        os << " " << cgoCtxt;
        os << " " << labels;
        os << " " << timer;
        os << " " << selectDone;
        os << " " << coroarg;
        os << " " << goroutineProfiled;
        os << " " << trace;
        os << " " << gcAssistBytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct g& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& m::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g0;
        os << " " << morebuf;
        os << " " << divmod;
        os << " " << _;
        os << " " << procid;
        os << " " << gsignal;
        os << " " << goSigStack;
        os << " " << sigmask;
        os << " " << tls;
        os << " " << mstartfn;
        os << " " << curg;
        os << " " << caughtsig;
        os << " " << p;
        os << " " << nextp;
        os << " " << oldp;
        os << " " << id;
        os << " " << mallocing;
        os << " " << throwing;
        os << " " << preemptoff;
        os << " " << locks;
        os << " " << dying;
        os << " " << profilehz;
        os << " " << spinning;
        os << " " << blocked;
        os << " " << newSigstack;
        os << " " << printlock;
        os << " " << incgo;
        os << " " << isextra;
        os << " " << isExtraInC;
        os << " " << isExtraInSig;
        os << " " << freeWait;
        os << " " << needextram;
        os << " " << traceback;
        os << " " << ncgocall;
        os << " " << ncgo;
        os << " " << cgoCallersUse;
        os << " " << cgoCallers;
        os << " " << park;
        os << " " << alllink;
        os << " " << schedlink;
        os << " " << lockedg;
        os << " " << createstack;
        os << " " << lockedExt;
        os << " " << lockedInt;
        os << " " << nextwaitm;
        os << " " << mLockProfile;
        os << " " << waitunlockf;
        os << " " << waitlock;
        os << " " << waitTraceBlockReason;
        os << " " << waitTraceSkip;
        os << " " << syscalltick;
        os << " " << freelink;
        os << " " << trace;
        os << " " << libcall;
        os << " " << libcallpc;
        os << " " << libcallsp;
        os << " " << libcallg;
        os << " " << syscall;
        os << " " << vdsoSP;
        os << " " << vdsoPC;
        os << " " << preemptGen;
        os << " " << signalPending;
        os << " " << pcvalueCache;
        os << " " << chacha8;
        os << " " << cheaprand;
        os << " " << locksHeldLen;
        os << " " << locksHeld;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct m& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& p::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << id;
        os << " " << status;
        os << " " << link;
        os << " " << schedtick;
        os << " " << syscalltick;
        os << " " << sysmontick;
        os << " " << m;
        os << " " << mcache;
        os << " " << pcache;
        os << " " << raceprocctx;
        os << " " << deferpool;
        os << " " << deferpoolbuf;
        os << " " << goidcache;
        os << " " << goidcacheend;
        os << " " << runqhead;
        os << " " << runqtail;
        os << " " << runq;
        os << " " << runnext;
        os << " " << gFree;
        os << " " << sudogcache;
        os << " " << sudogbuf;
        os << " " << mspancache;
        os << " " << pinnerCache;
        os << " " << trace;
        os << " " << palloc;
        os << " " << timer0When;
        os << " " << timerModifiedEarliest;
        os << " " << gcAssistTime;
        os << " " << gcFractionalMarkTime;
        os << " " << limiterEvent;
        os << " " << gcMarkWorkerMode;
        os << " " << gcMarkWorkerStartTime;
        os << " " << gcw;
        os << " " << wbBuf;
        os << " " << runSafePointFn;
        os << " " << statsSeq;
        os << " " << timersLock;
        os << " " << timers;
        os << " " << numTimers;
        os << " " << deletedTimers;
        os << " " << timerRaceCtx;
        os << " " << maxStackScanDelta;
        os << " " << scannedStackSize;
        os << " " << scannedStacks;
        os << " " << preempt;
        os << " " << pageTraceBuf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct p& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& schedt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << goidgen;
        os << " " << lastpoll;
        os << " " << pollUntil;
        os << " " << lock;
        os << " " << midle;
        os << " " << nmidle;
        os << " " << nmidlelocked;
        os << " " << mnext;
        os << " " << maxmcount;
        os << " " << nmsys;
        os << " " << nmfreed;
        os << " " << ngsys;
        os << " " << pidle;
        os << " " << npidle;
        os << " " << nmspinning;
        os << " " << needspinning;
        os << " " << runq;
        os << " " << runqsize;
        os << " " << disable;
        os << " " << gFree;
        os << " " << sudoglock;
        os << " " << sudogcache;
        os << " " << deferlock;
        os << " " << deferpool;
        os << " " << freem;
        os << " " << gcwaiting;
        os << " " << stopwait;
        os << " " << stopnote;
        os << " " << sysmonwait;
        os << " " << sysmonnote;
        os << " " << safePointFn;
        os << " " << safePointWait;
        os << " " << safePointNote;
        os << " " << profilehz;
        os << " " << procresizetime;
        os << " " << totaltime;
        os << " " << sysmonlock;
        os << " " << timeToRun;
        os << " " << idleTime;
        os << " " << totalMutexWaitTime;
        os << " " << stwStoppingTimeGC;
        os << " " << stwStoppingTimeOther;
        os << " " << stwTotalTimeGC;
        os << " " << stwTotalTimeOther;
        os << " " << totalRuntimeLockWaitTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct schedt& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& _func::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << entryOff;
        os << " " << nameOff;
        os << " " << args;
        os << " " << deferreturn;
        os << " " << pcsp;
        os << " " << pcfile;
        os << " " << pcln;
        os << " " << npcdata;
        os << " " << cuOffset;
        os << " " << startLine;
        os << " " << funcID;
        os << " " << flag;
        os << " " << _;
        os << " " << nfuncdata;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _func& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& funcinl::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ones;
        os << " " << entry;
        os << " " << name;
        os << " " << file;
        os << " " << line;
        os << " " << startLine;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct funcinl& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& itab::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << inter;
        os << " " << _type;
        os << " " << hash;
        os << " " << _;
        os << " " << fun;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct itab& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& lfnode::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << " " << pushcnt;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct lfnode& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& forcegcstate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << g;
        os << " " << idle;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct forcegcstate& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& _defer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heap;
        os << " " << rangefunc;
        os << " " << sp;
        os << " " << pc;
        os << " " << fn;
        os << " " << link;
        os << " " << head;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _defer& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& _panic::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << argp;
        os << " " << arg;
        os << " " << link;
        os << " " << startPC;
        os << " " << startSP;
        os << " " << sp;
        os << " " << lr;
        os << " " << fp;
        os << " " << retpc;
        os << " " << deferBitsPtr;
        os << " " << slotsPtr;
        os << " " << recovered;
        os << " " << goexit;
        os << " " << deferreturn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _panic& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& savedOpenDeferState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << retpc;
        os << " " << deferBitsOffset;
        os << " " << slotsOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct savedOpenDeferState& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& ancestorInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pcs;
        os << " " << goid;
        os << " " << gopc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ancestorInfo& value)
    {
        return value.PrintTo(os);
    }

    gocpp::array_base<std::string> waitReasonStrings = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.waitReasonZero = ""; x.waitReasonGCAssistMarking = "GC assist marking"; x.waitReasonIOWait = "IO wait"; x.waitReasonChanReceiveNilChan = "chan receive (nil chan)"; x.waitReasonChanSendNilChan = "chan send (nil chan)"; x.waitReasonDumpingHeap = "dumping heap"; x.waitReasonGarbageCollection = "garbage collection"; x.waitReasonGarbageCollectionScan = "garbage collection scan"; x.waitReasonPanicWait = "panicwait"; x.waitReasonSelect = "select"; x.waitReasonSelectNoCases = "select (no cases)"; x.waitReasonGCAssistWait = "GC assist wait"; x.waitReasonGCSweepWait = "GC sweep wait"; x.waitReasonGCScavengeWait = "GC scavenge wait"; x.waitReasonChanReceive = "chan receive"; x.waitReasonChanSend = "chan send"; x.waitReasonFinalizerWait = "finalizer wait"; x.waitReasonForceGCIdle = "force gc (idle)"; x.waitReasonSemacquire = "semacquire"; x.waitReasonSleep = "sleep"; x.waitReasonSyncCondWait = "sync.Cond.Wait"; x.waitReasonSyncMutexLock = "sync.Mutex.Lock"; x.waitReasonSyncRWMutexRLock = "sync.RWMutex.RLock"; x.waitReasonSyncRWMutexLock = "sync.RWMutex.Lock"; x.waitReasonTraceReaderBlocked = "trace reader (blocked)"; x.waitReasonWaitForGCCycle = "wait for GC cycle"; x.waitReasonGCWorkerIdle = "GC worker (idle)"; x.waitReasonGCWorkerActive = "GC worker (active)"; x.waitReasonPreempted = "preempted"; x.waitReasonDebugCall = "debug call"; x.waitReasonGCMarkTermination = "GC mark termination"; x.waitReasonStoppingTheWorld = "stopping the world"; x.waitReasonFlushProcCaches = "flushing proc caches"; x.waitReasonTraceGoroutineStatus = "trace goroutine status"; x.waitReasonTraceProcStatus = "trace proc status"; x.waitReasonPageTraceFlush = "page trace flush"; x.waitReasonCoroutine = "coroutine"; });
    std::string String(waitReason w)
    {
        if(w < 0 || w >= waitReason(len(waitReasonStrings)))
        {
            return "unknown wait reason";
        }
        return waitReasonStrings[w];
    }

    bool isMutexWait(waitReason w)
    {
        return w == waitReasonSyncMutexLock || w == waitReasonSyncRWMutexRLock || w == waitReasonSyncRWMutexLock;
    }

    m* allm;
    int32_t gomaxprocs;
    int32_t ncpu;
    forcegcstate forcegc;
    schedt sched;
    int32_t newprocs;
    mutex allpLock;
    gocpp::slice<p*> allp;
    pMask idlepMask;
    pMask timerpMask;
    lfstack gcBgMarkWorkerPool;
    int32_t gcBgMarkWorkerCount;
    uint32_t processorVersionInfo;
    bool isIntel;
    uint8_t goarm;
    uint8_t goarmsoftfp;
    bool islibrary;
    bool isarchive;
    bool framepointer_enabled = GOARCH == "amd64" || GOARCH == "arm64";
}

