// generated by GoCpp from file '$(ImportDir)/reflect/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/type.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/map.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/value.h"
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
// #include "golang/sync/pool.h"  [Ignored, known errors]
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/utf8/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    struct Type : gocpp::Interface
    {
        Type(){}
        Type(Type& i) = default;
        Type(const Type& i) = default;
        Type& operator=(Type& i) = default;
        Type& operator=(const Type& i) = default;

        template<typename T>
        Type(T& ref);

        template<typename T>
        Type(const T& ref);

        template<typename T>
        Type(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IType
        {
            virtual int vAlign() = 0;
            virtual int vFieldAlign() = 0;
            virtual Method vMethod(int) = 0;
            virtual std::tuple<Method, bool> vMethodByName(std::string) = 0;
            virtual int vNumMethod() = 0;
            virtual std::string vName() = 0;
            virtual std::string vPkgPath() = 0;
            virtual uintptr_t vSize() = 0;
            virtual std::string vString() = 0;
            virtual Kind vKind() = 0;
            virtual bool vImplements(Type u) = 0;
            virtual bool vAssignableTo(Type u) = 0;
            virtual bool vConvertibleTo(Type u) = 0;
            virtual bool vComparable() = 0;
            virtual int vBits() = 0;
            virtual ChanDir vChanDir() = 0;
            virtual bool vIsVariadic() = 0;
            virtual Type vElem() = 0;
            virtual StructField vField(int i) = 0;
            virtual StructField vFieldByIndex(gocpp::slice<int> index) = 0;
            virtual std::tuple<StructField, bool> vFieldByName(std::string name) = 0;
            virtual std::tuple<StructField, bool> vFieldByNameFunc(std::function<bool (std::string)> match) = 0;
            virtual Type vIn(int i) = 0;
            virtual Type vKey() = 0;
            virtual int vLen() = 0;
            virtual int vNumField() = 0;
            virtual int vNumIn() = 0;
            virtual int vNumOut() = 0;
            virtual Type vOut(int i) = 0;
            virtual abi::Type* vcommon() = 0;
            virtual uncommonType* vuncommon() = 0;
        };

        template<typename T, typename StoreT>
        struct TypeImpl : IType
        {
            explicit TypeImpl(T* ptr)
            {
                value.reset(ptr);
            }

            int vAlign() override;

            int vFieldAlign() override;

            Method vMethod(int) override;

            std::tuple<Method, bool> vMethodByName(std::string) override;

            int vNumMethod() override;

            std::string vName() override;

            std::string vPkgPath() override;

            uintptr_t vSize() override;

            std::string vString() override;

            Kind vKind() override;

            bool vImplements(Type u) override;

            bool vAssignableTo(Type u) override;

            bool vConvertibleTo(Type u) override;

            bool vComparable() override;

            int vBits() override;

            ChanDir vChanDir() override;

            bool vIsVariadic() override;

            Type vElem() override;

            StructField vField(int i) override;

            StructField vFieldByIndex(gocpp::slice<int> index) override;

            std::tuple<StructField, bool> vFieldByName(std::string name) override;

            std::tuple<StructField, bool> vFieldByNameFunc(std::function<bool (std::string)> match) override;

            Type vIn(int i) override;

            Type vKey() override;

            int vLen() override;

            int vNumField() override;

            int vNumIn() override;

            int vNumOut() override;

            Type vOut(int i) override;

            abi::Type* vcommon() override;

            uncommonType* vuncommon() override;

            StoreT value;
        };

        std::shared_ptr<IType> value;
    };

    int Align(const gocpp::PtrRecv<Type, false>& self);
    int Align(const gocpp::ObjRecv<Type>& self);

    int FieldAlign(const gocpp::PtrRecv<Type, false>& self);
    int FieldAlign(const gocpp::ObjRecv<Type>& self);

    Method Method(const gocpp::PtrRecv<Type, false>& self, int);
    Method Method(const gocpp::ObjRecv<Type>& self, int);

    std::tuple<Method, bool> MethodByName(const gocpp::PtrRecv<Type, false>& self, std::string);
    std::tuple<Method, bool> MethodByName(const gocpp::ObjRecv<Type>& self, std::string);

    int NumMethod(const gocpp::PtrRecv<Type, false>& self);
    int NumMethod(const gocpp::ObjRecv<Type>& self);

    std::string Name(const gocpp::PtrRecv<Type, false>& self);
    std::string Name(const gocpp::ObjRecv<Type>& self);

    std::string PkgPath(const gocpp::PtrRecv<Type, false>& self);
    std::string PkgPath(const gocpp::ObjRecv<Type>& self);

    uintptr_t Size(const gocpp::PtrRecv<Type, false>& self);
    uintptr_t Size(const gocpp::ObjRecv<Type>& self);

    std::string String(const gocpp::PtrRecv<Type, false>& self);
    std::string String(const gocpp::ObjRecv<Type>& self);

    Kind Kind(const gocpp::PtrRecv<Type, false>& self);
    Kind Kind(const gocpp::ObjRecv<Type>& self);

    bool Implements(const gocpp::PtrRecv<Type, false>& self, Type u);
    bool Implements(const gocpp::ObjRecv<Type>& self, Type u);

    bool AssignableTo(const gocpp::PtrRecv<Type, false>& self, Type u);
    bool AssignableTo(const gocpp::ObjRecv<Type>& self, Type u);

    bool ConvertibleTo(const gocpp::PtrRecv<Type, false>& self, Type u);
    bool ConvertibleTo(const gocpp::ObjRecv<Type>& self, Type u);

    bool Comparable(const gocpp::PtrRecv<Type, false>& self);
    bool Comparable(const gocpp::ObjRecv<Type>& self);

    int Bits(const gocpp::PtrRecv<Type, false>& self);
    int Bits(const gocpp::ObjRecv<Type>& self);

    ChanDir ChanDir(const gocpp::PtrRecv<Type, false>& self);
    ChanDir ChanDir(const gocpp::ObjRecv<Type>& self);

    bool IsVariadic(const gocpp::PtrRecv<Type, false>& self);
    bool IsVariadic(const gocpp::ObjRecv<Type>& self);

    Type Elem(const gocpp::PtrRecv<Type, false>& self);
    Type Elem(const gocpp::ObjRecv<Type>& self);

    StructField Field(const gocpp::PtrRecv<Type, false>& self, int i);
    StructField Field(const gocpp::ObjRecv<Type>& self, int i);

    StructField FieldByIndex(const gocpp::PtrRecv<Type, false>& self, gocpp::slice<int> index);
    StructField FieldByIndex(const gocpp::ObjRecv<Type>& self, gocpp::slice<int> index);

    std::tuple<StructField, bool> FieldByName(const gocpp::PtrRecv<Type, false>& self, std::string name);
    std::tuple<StructField, bool> FieldByName(const gocpp::ObjRecv<Type>& self, std::string name);

    std::tuple<StructField, bool> FieldByNameFunc(const gocpp::PtrRecv<Type, false>& self, std::function<bool (std::string)> match);
    std::tuple<StructField, bool> FieldByNameFunc(const gocpp::ObjRecv<Type>& self, std::function<bool (std::string)> match);

    Type In(const gocpp::PtrRecv<Type, false>& self, int i);
    Type In(const gocpp::ObjRecv<Type>& self, int i);

    Type Key(const gocpp::PtrRecv<Type, false>& self);
    Type Key(const gocpp::ObjRecv<Type>& self);

    int Len(const gocpp::PtrRecv<Type, false>& self);
    int Len(const gocpp::ObjRecv<Type>& self);

    int NumField(const gocpp::PtrRecv<Type, false>& self);
    int NumField(const gocpp::ObjRecv<Type>& self);

    int NumIn(const gocpp::PtrRecv<Type, false>& self);
    int NumIn(const gocpp::ObjRecv<Type>& self);

    int NumOut(const gocpp::PtrRecv<Type, false>& self);
    int NumOut(const gocpp::ObjRecv<Type>& self);

    Type Out(const gocpp::PtrRecv<Type, false>& self, int i);
    Type Out(const gocpp::ObjRecv<Type>& self, int i);

    abi::Type* common(const gocpp::PtrRecv<Type, false>& self);
    abi::Type* common(const gocpp::ObjRecv<Type>& self);

    uncommonType* uncommon(const gocpp::PtrRecv<Type, false>& self);
    uncommonType* uncommon(const gocpp::ObjRecv<Type>& self);

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    struct common
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct common& value);
    struct rtype
    {
        abi::Type t;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct rtype& value);
    abi::Type* common(struct rtype* t);
    abi::UncommonType* uncommon(struct rtype* t);
    struct interfaceType
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct interfaceType& value);
    abi::Name nameOff(struct interfaceType* t, aNameOff off);
    abi::Name nameOffFor(abi::Type* t, aNameOff off);
    abi::Type* typeOffFor(abi::Type* t, aTypeOff off);
    abi::Type* typeOff(struct interfaceType* t, aTypeOff off);
    abi::Type* common(struct interfaceType* t);
    abi::UncommonType* uncommon(struct interfaceType* t);
    struct mapType
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapType& value);
    struct ptrType
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ptrType& value);
    struct sliceType
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sliceType& value);
    struct structType
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structType& value);
    std::string pkgPath(abi::Name n);
    abi::Name newName(std::string n, std::string tag, bool exported, bool embedded);
    struct Method
    {
        std::string Name;
        std::string PkgPath;
        Type Type;
        Value Func;
        int Index;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Method& value);
    bool IsExported(struct Method m);
    std::string String(Kind k);
    extern gocpp::slice<std::string> kindNames;
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off);
    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off);
    unsafe::Pointer resolveTextOff(unsafe::Pointer rtype, int32_t off);
    int32_t addReflectOff(unsafe::Pointer ptr);
    aNameOff resolveReflectName(abi::Name n);
    aTypeOff resolveReflectType(abi::Type* t);
    aTextOff resolveReflectText(unsafe::Pointer ptr);
    abi::Name nameOff(struct rtype* t, aNameOff off);
    abi::Type* typeOff(struct rtype* t, aTypeOff off);
    unsafe::Pointer textOff(struct rtype* t, aTextOff off);
    unsafe::Pointer textOffFor(abi::Type* t, aTextOff off);
    std::string String(struct rtype* t);
    uintptr_t Size(struct rtype* t);
    int Bits(struct rtype* t);
    int Align(struct rtype* t);
    int FieldAlign(struct rtype* t);
    Kind Kind(struct rtype* t);
    gocpp::slice<abi::Method> exportedMethods(struct rtype* t);
    int NumMethod(struct rtype* t);
    Method Method(struct rtype* t, int i);
    std::tuple<Method, bool> MethodByName(struct rtype* t, std::string name);
    std::string PkgPath(struct rtype* t);
    std::string pkgPathFor(abi::Type* t);
    std::string Name(struct rtype* t);
    std::string nameFor(abi::Type* t);
    ChanDir ChanDir(struct rtype* t);
    rtype* toRType(abi::Type* t);
    abi::Type* elem(abi::Type* t);
    Type Elem(struct rtype* t);
    StructField Field(struct rtype* t, int i);
    StructField FieldByIndex(struct rtype* t, gocpp::slice<int> index);
    std::tuple<StructField, bool> FieldByName(struct rtype* t, std::string name);
    std::tuple<StructField, bool> FieldByNameFunc(struct rtype* t, std::function<bool (std::string)> match);
    Type Key(struct rtype* t);
    int Len(struct rtype* t);
    int NumField(struct rtype* t);
    Type In(struct rtype* t, int i);
    int NumIn(struct rtype* t);
    int NumOut(struct rtype* t);
    Type Out(struct rtype* t, int i);
    bool IsVariadic(struct rtype* t);
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    std::string String(ChanDir d);
    Method Method(struct interfaceType* t, int i);
    int NumMethod(struct interfaceType* t);
    std::tuple<Method, bool> MethodByName(struct interfaceType* t, std::string name);
    struct StructField
    {
        std::string Name;
        std::string PkgPath;
        Type Type;
        StructTag Tag;
        uintptr_t Offset;
        gocpp::slice<int> Index;
        bool Anonymous;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructField& value);
    bool IsExported(struct StructField f);
    std::string Get(StructTag tag, std::string key);
    std::tuple<std::string, bool> Lookup(StructTag tag, std::string key);
    StructField Field(struct structType* t, int i);
    StructField FieldByIndex(struct structType* t, gocpp::slice<int> index);
    struct fieldScan
    {
        structType* typ;
        gocpp::slice<int> index;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct fieldScan& value);
    std::tuple<StructField, bool> FieldByNameFunc(struct structType* t, std::function<bool (std::string)> match);
    std::tuple<StructField, bool> FieldByName(struct structType* t, std::string name);
    Type TypeOf(go_any i);
    abi::Type* rtypeOf(go_any i);
    Type PtrTo(Type t);
    Type PointerTo(Type t);
    abi::Type* ptrTo(struct rtype* t);
    abi::Type* ptrTo(abi::Type* t);
    uint32_t fnv1(uint32_t x, gocpp::slice<unsigned char> list);
    template<typename... Args>
    uint32_t fnv1(uint32_t x, Args... list)
    {
        return fnv1(x, gocpp::ToSlice<unsigned char>(list...));
    }

    bool Implements(struct rtype* t, Type u);
    bool AssignableTo(struct rtype* t, Type u);
    bool ConvertibleTo(struct rtype* t, Type u);
    bool Comparable(struct rtype* t);
    bool implements(abi::Type* T, abi::Type* V);
    bool specialChannelAssignability(abi::Type* T, abi::Type* V);
    bool directlyAssignable(abi::Type* T, abi::Type* V);
    bool haveIdenticalType(abi::Type* T, abi::Type* V, bool cmpTags);
    bool haveIdenticalUnderlyingType(abi::Type* T, abi::Type* V, bool cmpTags);
    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> typelinks();
    abi::Type* rtypeOff(unsafe::Pointer section, int32_t off);
    gocpp::slice<abi::Type*> typesByString(std::string s);
    struct cacheKey
    {
        Kind kind;
        abi::Type* t1;
        abi::Type* t2;
        uintptr_t extra;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cacheKey& value);
    Type ChanOf(ChanDir dir, Type t);
    Type MapOf(Type key, Type elem);
    Type initFuncTypes(int n);
    Type FuncOf(gocpp::slice<Type> in, gocpp::slice<Type> out, bool variadic);
    std::string stringFor(abi::Type* t);
    std::string funcStr(funcType* ft);
    bool isReflexive(abi::Type* t);
    bool needKeyUpdate(abi::Type* t);
    bool hashMightPanic(abi::Type* t);
    abi::Type* bucketOf(abi::Type* ktyp, abi::Type* etyp);
    gocpp::slice<unsigned char> gcSlice(struct rtype* t, uintptr_t begin, uintptr_t end);
    void emitGCMask(gocpp::slice<unsigned char> out, uintptr_t base, abi::Type* typ, uintptr_t n);
    gocpp::slice<unsigned char> appendGCProg(gocpp::slice<unsigned char> dst, abi::Type* typ);
    Type SliceOf(Type t);
    struct structTypeUncommon
    {
        uncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value);
    bool isLetter(gocpp::rune ch);
    bool isValidFieldName(std::string fieldName);
    Type StructOf(gocpp::slice<StructField> fields);
    void embeddedIfaceMethStub();
    std::tuple<structField, std::string> runtimeStructField(StructField field);
    uintptr_t typeptrdata(abi::Type* t);
    Type ArrayOf(int length, Type elem);
    gocpp::slice<unsigned char> appendVarint(gocpp::slice<unsigned char> x, uintptr_t v);
    Type toType(abi::Type* t);
    struct layoutKey
    {
        funcType* ftyp;
        abi::Type* rcvr;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct layoutKey& value);
    struct layoutType
    {
        abi::Type* t;
        sync::Pool* framePool;
        abiDesc abid;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct layoutType& value);
    std::tuple<abi::Type*, sync::Pool*, abiDesc> funcLayout(funcType* t, abi::Type* rcvr);
    bool ifaceIndir(abi::Type* t);
    struct bitVector
    {
        uint32_t n;
        gocpp::slice<unsigned char> data;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bitVector& value);
    void append(struct bitVector* bv, uint8_t bit);
    void addTypeBits(bitVector* bv, uintptr_t offset, abi::Type* t);
    Type TypeFor();
}

