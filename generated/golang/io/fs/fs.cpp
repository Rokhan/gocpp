// generated by GoCpp from file '$(ImportDir)/io/fs/fs.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/io/fs/fs.h"
#include "gocpp/support.h"

#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::fs
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    
    template<typename T>
    FS::FS(T& ref)
    {
        value.reset(new FSImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FS::FS(const T& ref)
    {
        value.reset(new FSImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FS::FS(T* ptr)
    {
        value.reset(new FSImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& FS::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<struct File, struct gocpp::error> FS::FSImpl<T, StoreT>::vOpen(std::string name)
    {
        return rec::Open(gocpp::PtrRecv<T, false>(value.get()), name);
    }

    namespace rec
    {
        std::tuple<struct File, struct gocpp::error> Open(const gocpp::PtrRecv<struct FS, false>& self, std::string name)
        {
            return self.ptr->value->vOpen(name);
        }

        std::tuple<struct File, struct gocpp::error> Open(const gocpp::ObjRecv<struct FS>& self, std::string name)
        {
            return self.obj.value->vOpen(name);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct FS& value)
    {
        return value.PrintTo(os);
    }

    bool ValidPath(std::string name)
    {
        if(! utf8::ValidString(name))
        {
            return false;
        }
        if(name == ".")
        {
            return true;
        }
        for(; ; )
        {
            auto i = 0;
            for(; i < len(name) && name[i] != '/'; )
            {
                i++;
            }
            auto elem = name.make_slice(0, i);
            if(elem == "" || elem == "." || elem == "..")
            {
                return false;
            }
            if(i == len(name))
            {
                return true;
            }
            name = name.make_slice(i + 1);
        }
    }

    
    template<typename T>
    File::File(T& ref)
    {
        value.reset(new FileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    File::File(const T& ref)
    {
        value.reset(new FileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    File::File(T* ptr)
    {
        value.reset(new FileImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& File::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<struct FileInfo, struct gocpp::error> File::FileImpl<T, StoreT>::vStat()
    {
        return rec::Stat(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> File::FileImpl<T, StoreT>::vRead(gocpp::slice<unsigned char>)
    {
        return rec::Read(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct gocpp::error File::FileImpl<T, StoreT>::vClose()
    {
        return rec::Close(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<struct FileInfo, struct gocpp::error> Stat(const gocpp::PtrRecv<struct File, false>& self)
        {
            return self.ptr->value->vStat();
        }

        std::tuple<struct FileInfo, struct gocpp::error> Stat(const gocpp::ObjRecv<struct File>& self)
        {
            return self.obj.value->vStat();
        }

        std::tuple<int, struct gocpp::error> Read(const gocpp::PtrRecv<struct File, false>& self, gocpp::slice<unsigned char>)
        {
            return self.ptr->value->vRead();
        }

        std::tuple<int, struct gocpp::error> Read(const gocpp::ObjRecv<struct File>& self, gocpp::slice<unsigned char>)
        {
            return self.obj.value->vRead();
        }

        struct gocpp::error Close(const gocpp::PtrRecv<struct File, false>& self)
        {
            return self.ptr->value->vClose();
        }

        struct gocpp::error Close(const gocpp::ObjRecv<struct File>& self)
        {
            return self.obj.value->vClose();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct File& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    DirEntry::DirEntry(T& ref)
    {
        value.reset(new DirEntryImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    DirEntry::DirEntry(const T& ref)
    {
        value.reset(new DirEntryImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    DirEntry::DirEntry(T* ptr)
    {
        value.reset(new DirEntryImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& DirEntry::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string DirEntry::DirEntryImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool DirEntry::DirEntryImpl<T, StoreT>::vIsDir()
    {
        return rec::IsDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    fs::FileMode DirEntry::DirEntryImpl<T, StoreT>::vType()
    {
        return rec::Type(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<struct FileInfo, struct gocpp::error> DirEntry::DirEntryImpl<T, StoreT>::vInfo()
    {
        return rec::Info(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::string Name(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vName();
        }

        std::string Name(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vName();
        }

        bool IsDir(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vIsDir();
        }

        bool IsDir(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vIsDir();
        }

        fs::FileMode Type(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vType();
        }

        fs::FileMode Type(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vType();
        }

        std::tuple<struct FileInfo, struct gocpp::error> Info(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vInfo();
        }

        std::tuple<struct FileInfo, struct gocpp::error> Info(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vInfo();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct DirEntry& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadDirFile::ReadDirFile(T& ref)
    {
        value.reset(new ReadDirFileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadDirFile::ReadDirFile(const T& ref)
    {
        value.reset(new ReadDirFileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadDirFile::ReadDirFile(T* ptr)
    {
        value.reset(new ReadDirFileImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadDirFile::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDirFile::ReadDirFileImpl<T, StoreT>::vReadDir(int n)
    {
        return rec::ReadDir(gocpp::PtrRecv<T, false>(value.get()), n);
    }

    namespace rec
    {
        std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDir(const gocpp::PtrRecv<struct ReadDirFile, false>& self, int n)
        {
            return self.ptr->value->vReadDir(n);
        }

        std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDir(const gocpp::ObjRecv<struct ReadDirFile>& self, int n)
        {
            return self.obj.value->vReadDir(n);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ReadDirFile& value)
    {
        return value.PrintTo(os);
    }

    gocpp::error ErrInvalid = errInvalid();
    gocpp::error ErrPermission = errPermission();
    gocpp::error ErrExist = errExist();
    gocpp::error ErrNotExist = errNotExist();
    gocpp::error ErrClosed = errClosed();
    struct gocpp::error errInvalid()
    {
        return oserror::ErrInvalid;
    }

    struct gocpp::error errPermission()
    {
        return oserror::ErrPermission;
    }

    struct gocpp::error errExist()
    {
        return oserror::ErrExist;
    }

    struct gocpp::error errNotExist()
    {
        return oserror::ErrNotExist;
    }

    struct gocpp::error errClosed()
    {
        return oserror::ErrClosed;
    }

    
    template<typename T>
    FileInfo::FileInfo(T& ref)
    {
        value.reset(new FileInfoImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FileInfo::FileInfo(const T& ref)
    {
        value.reset(new FileInfoImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FileInfo::FileInfo(T* ptr)
    {
        value.reset(new FileInfoImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& FileInfo::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string FileInfo::FileInfoImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int64_t FileInfo::FileInfoImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    fs::FileMode FileInfo::FileInfoImpl<T, StoreT>::vMode()
    {
        return rec::Mode(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    mocklib::Date FileInfo::FileInfoImpl<T, StoreT>::vModTime()
    {
        return rec::ModTime(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool FileInfo::FileInfoImpl<T, StoreT>::vIsDir()
    {
        return rec::IsDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    go_any FileInfo::FileInfoImpl<T, StoreT>::vSys()
    {
        return rec::Sys(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::string Name(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vName();
        }

        std::string Name(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vName();
        }

        int64_t Size(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vSize();
        }

        int64_t Size(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vSize();
        }

        fs::FileMode Mode(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vMode();
        }

        fs::FileMode Mode(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vMode();
        }

        mocklib::Date ModTime(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vModTime();
        }

        mocklib::Date ModTime(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vModTime();
        }

        bool IsDir(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vIsDir();
        }

        bool IsDir(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vIsDir();
        }

        go_any Sys(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vSys();
        }

        go_any Sys(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vSys();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct FileInfo& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::String(golang::fs::FileMode m)
    {
        auto str = "dalTLDpSugct?";
        gocpp::array<unsigned char, 32> buf = {};
        auto w = 0;
        for(auto [i, c] : str)
        {
            if(m & (1 << (unsigned int)(32 - 1 - i)) != 0)
            {
                buf[w] = unsigned char(c);
                w++;
            }
        }
        if(w == 0)
        {
            buf[w] = '-';
            w++;
        }
        auto rwx = "rwxrwxrwx";
        for(auto [i, c] : rwx)
        {
            if(m & (1 << (unsigned int)(9 - 1 - i)) != 0)
            {
                buf[w] = unsigned char(c);
            }
            else
            {
                buf[w] = '-';
            }
            w++;
        }
        return std::string(buf.make_slice(0, w));
    }

    bool rec::IsDir(golang::fs::FileMode m)
    {
        return m & ModeDir != 0;
    }

    bool rec::IsRegular(golang::fs::FileMode m)
    {
        return m & ModeType == 0;
    }

    fs::FileMode rec::Perm(golang::fs::FileMode m)
    {
        return m & ModePerm;
    }

    fs::FileMode rec::Type(golang::fs::FileMode m)
    {
        return m & ModeType;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    PathError::operator T()
    {
        T result;
        result.Op = this->Op;
        result.Path = this->Path;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool PathError::operator==(const T& ref) const
    {
        if (Op != ref.Op) return false;
        if (Path != ref.Path) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& PathError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Op;
        os << " " << Path;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct PathError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct PathError* e)
    {
        return e->Op + " " + e->Path + ": " + rec::Error(gocpp::recv(e->Err));
    }

    struct gocpp::error rec::Unwrap(struct PathError* e)
    {
        return e->Err;
    }

    
        template<typename T>
        gocpp_id_0::gocpp_id_0(T& ref)
        {
            value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
        }

        template<typename T>
        gocpp_id_0::gocpp_id_0(const T& ref)
        {
            value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
        }

        template<typename T>
        gocpp_id_0::gocpp_id_0(T* ptr)
        {
            value.reset(new gocpp_id_0Impl<T, gocpp::ptr<T>>(ptr));
        }

        std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
        {
            return os;
        }

        template<typename T, typename StoreT>
        bool gocpp_id_0::gocpp_id_0Impl<T, StoreT>::vTimeout()
        {
            return rec::Timeout(gocpp::PtrRecv<T, false>(value.get()));
        }

        namespace rec
        {
            bool Timeout(const gocpp::PtrRecv<struct gocpp_id_0, false>& self)
            {
                return self.ptr->value->vTimeout();
            }

            bool Timeout(const gocpp::ObjRecv<struct gocpp_id_0>& self)
            {
                return self.obj.value->vTimeout();
            }
        }

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
        {
            return value.PrintTo(os);
        }


    bool rec::Timeout(struct PathError* e)
    {
        auto [t, ok] = gocpp::getValue<gocpp_id_0>(e->Err);
        return ok && rec::Timeout(gocpp::recv(t));
    }

}

