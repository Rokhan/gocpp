// generated by GoCpp from file '$(ImportDir)/runtime/mgcpacer.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcpacer.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct gcControllerState
    {
        atomic::Int32 gcPercent;
        atomic::Int64 memoryLimit;
        uint64_t heapMinimum;
        atomic::Uint64 runway;
        double consMark;
        gocpp::array<double, 4> lastConsMark;
        atomic::Uint64 gcPercentHeapGoal;
        atomic::Uint64 sweepDistMinTrigger;
        uint64_t triggered;
        uint64_t lastHeapGoal;
        atomic::Uint64 heapLive;
        atomic::Uint64 heapScan;
        uint64_t lastHeapScan;
        atomic::Uint64 lastStackScan;
        atomic::Uint64 maxStackScan;
        atomic::Uint64 globalsScan;
        uint64_t heapMarked;
        atomic::Int64 heapScanWork;
        atomic::Int64 stackScanWork;
        atomic::Int64 globalsScanWork;
        atomic::Int64 bgScanCredit;
        atomic::Int64 assistTime;
        atomic::Int64 dedicatedMarkTime;
        atomic::Int64 fractionalMarkTime;
        atomic::Int64 idleMarkTime;
        int64_t markStartTime;
        atomic::Int64 dedicatedMarkWorkersNeeded;
        atomic::Uint64 idleMarkWorkers;
        atomic::Float64 assistWorkPerByte;
        atomic::Float64 assistBytesPerWork;
        double fractionalUtilizationGoal;
        golang::runtime::sysMemStat heapInUse;
        golang::runtime::sysMemStat heapReleased;
        golang::runtime::sysMemStat heapFree;
        atomic::Uint64 totalAlloc;
        atomic::Uint64 totalFree;
        atomic::Uint64 mappedReady;
        bool test;
        cpu::CacheLinePad _1;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcControllerState& value);
    int32_t setGCPercent(int32_t in);
    int32_t readGOGC();
    int64_t setMemoryLimit(int64_t in);
    int64_t readGOMEMLIMIT();
    void gcControllerCommit();
    extern gcControllerState gcController;

    namespace rec
    {
        void init(struct gcControllerState* c, int32_t gcPercent, int64_t memoryLimit);
        void startCycle(struct gcControllerState* c, int64_t markStartTime, int procs, struct gcTrigger trigger);
        void revise(struct gcControllerState* c);
        void endCycle(struct gcControllerState* c, int64_t now, int procs, bool userForced);
        void enlistWorker(struct gcControllerState* c);
        std::tuple<struct g*, int64_t> findRunnableGCWorker(struct gcControllerState* c, struct p* pp, int64_t now);
        void resetLive(struct gcControllerState* c, uint64_t bytesMarked);
        void markWorkerStop(struct gcControllerState* c, golang::runtime::gcMarkWorkerMode mode, int64_t duration);
        void update(struct gcControllerState* c, int64_t dHeapLive, int64_t dHeapScan);
        void addScannableStack(struct gcControllerState* c, struct p* pp, int64_t amount);
        void addGlobals(struct gcControllerState* c, int64_t amount);
        uint64_t heapGoal(struct gcControllerState* c);
        std::tuple<uint64_t, uint64_t> heapGoalInternal(struct gcControllerState* c);
        uint64_t memoryLimitHeapGoal(struct gcControllerState* c);
        std::tuple<uint64_t, uint64_t> trigger(struct gcControllerState* c);
        void commit(struct gcControllerState* c, bool isSweepDone);
        int32_t setGCPercent(struct gcControllerState* c, int32_t in);
        int64_t setMemoryLimit(struct gcControllerState* c, int64_t in);
        bool addIdleMarkWorker(struct gcControllerState* c);
        bool needIdleMarkWorker(struct gcControllerState* c);
        void removeIdleMarkWorker(struct gcControllerState* c);
        void setMaxIdleMarkWorkers(struct gcControllerState* c, int32_t max);
    }
}

