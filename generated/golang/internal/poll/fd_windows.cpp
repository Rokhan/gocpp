// generated by GoCpp from file '$(ImportDir)/internal/poll/fd_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/poll/fd_windows.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/poll/fd.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_posix.h"
// #include "golang/internal/race/norace.h"  [Ignored, known errors]
#include "golang/internal/syscall/windows/net_windows.h"
#include "golang/internal/syscall/windows/symlink_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/internal/syscall/windows/zsyscall_windows.h"
#include "golang/io/io.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unicode/utf16/utf16.h"
#include "golang/unicode/utf8/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::poll
{
    gocpp::error initErr;
    uint64_t ioSync;
    bool useSetFileCompletionNotificationModes;
    void checkSetFileCompletionNotificationModes()
    {
        auto err = syscall::LoadSetFileCompletionNotificationModes();
        if(err != nullptr)
        {
            return;
        }
        auto protos = gocpp::array<int32_t, 2> {syscall::IPPROTO_TCP, 0};
        gocpp::array<syscall::WSAProtocolInfo, 32> buf = {};
        auto len = uint32_t(gocpp::Sizeof<gocpp::array<syscall::WSAProtocolInfo, 32>>());
        int32_t n;
        std::tie(n, err) = syscall::WSAEnumProtocols(& protos[0], & buf[0], & len);
        if(err != nullptr)
        {
            return;
        }
        for(auto i = int32_t(0); i < n; i++)
        {
            if(buf[i].ServiceFlags1 & syscall::XP1_IFS_HANDLES == 0)
            {
                return;
            }
        }
        useSetFileCompletionNotificationModes = true;
    }

    void init()
    {
        syscall::WSAData d = {};
        auto e = syscall::WSAStartup(uint32_t(0x202), & d);
        if(e != nullptr)
        {
            initErr = e;
        }
        checkSetFileCompletionNotificationModes();
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    operation::operator T()
    {
        T result;
        result.o = this->o;
        result.runtimeCtx = this->runtimeCtx;
        result.mode = this->mode;
        result.errno = this->errno;
        result.qty = this->qty;
        result.fd = this->fd;
        result.buf = this->buf;
        result.msg = this->msg;
        result.sa = this->sa;
        result.rsa = this->rsa;
        result.rsan = this->rsan;
        result.handle = this->handle;
        result.flags = this->flags;
        result.bufs = this->bufs;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool operation::operator==(const T& ref) const
    {
        if (o != ref.o) return false;
        if (runtimeCtx != ref.runtimeCtx) return false;
        if (mode != ref.mode) return false;
        if (errno != ref.errno) return false;
        if (qty != ref.qty) return false;
        if (fd != ref.fd) return false;
        if (buf != ref.buf) return false;
        if (msg != ref.msg) return false;
        if (sa != ref.sa) return false;
        if (rsa != ref.rsa) return false;
        if (rsan != ref.rsan) return false;
        if (handle != ref.handle) return false;
        if (flags != ref.flags) return false;
        if (bufs != ref.bufs) return false;
        return true;
    }

    std::ostream& operation::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << o;
        os << " " << runtimeCtx;
        os << " " << mode;
        os << " " << errno;
        os << " " << qty;
        os << " " << fd;
        os << " " << buf;
        os << " " << msg;
        os << " " << sa;
        os << " " << rsa;
        os << " " << rsan;
        os << " " << handle;
        os << " " << flags;
        os << " " << bufs;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct operation& value)
    {
        return value.PrintTo(os);
    }

    void InitBuf(struct operation* o, gocpp::slice<unsigned char> buf)
    {
        o->buf.Len = uint32_t(len(buf));
        o->buf.Buf = nullptr;
        if(len(buf) != 0)
        {
            o->buf.Buf = & buf[0];
        }
    }

    void InitBufs(struct operation* o, gocpp::slice<gocpp::slice<unsigned char>>* buf)
    {
        if(o->bufs == nullptr)
        {
            o->bufs = gocpp::make(gocpp::Tag<gocpp::slice<syscall::WSABuf>>(), 0, len(*buf));
        }
        else
        {
            o->bufs = o->bufs.make_slice(0, 0);
        }
        for(auto [gocpp_ignored, b] : *buf)
        {
            if(len(b) == 0)
            {
                o->bufs = append(o->bufs, syscall::WSABuf {});
                continue;
            }
            for(; len(b) > maxRW; )
            {
                o->bufs = append(o->bufs, gocpp::Init<syscall::WSABuf>([](syscall::WSABuf& x) { x.Len = maxRW; x.Buf = & b[0]; }));
                b = b.make_slice(maxRW);
            }
            if(len(b) > 0)
            {
                o->bufs = append(o->bufs, gocpp::Init<syscall::WSABuf>([](syscall::WSABuf& x) { x.Len = uint32_t(len(b)); x.Buf = & b[0]; }));
            }
        }
    }

    void ClearBufs(struct operation* o)
    {
        for(auto [i, gocpp_ignored] : o->bufs)
        {
            o->bufs[i].Buf = nullptr;
        }
        o->bufs = o->bufs.make_slice(0, 0);
    }

    void InitMsg(struct operation* o, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob)
    {
        InitBuf(gocpp::recv(o), p);
        o->msg.Buffers = & o->buf;
        o->msg.BufferCount = 1;
        o->msg.Name = nullptr;
        o->msg.Namelen = 0;
        o->msg.Flags = 0;
        o->msg.Control.Len = uint32_t(len(oob));
        o->msg.Control.Buf = nullptr;
        if(len(oob) != 0)
        {
            o->msg.Control.Buf = & oob[0];
        }
    }

    std::tuple<int, struct gocpp::error> execIO(struct operation* o, std::function<struct gocpp::error (struct operation* o)> submit)
    {
        if(o->fd->pd.runtimeCtx == 0)
        {
            return {0, errors::New("internal error: polling on unsupported descriptor type")};
        }
        auto fd = o->fd;
        auto err = prepare(gocpp::recv(fd->pd), int(o->mode), fd->isFile);
        if(err != nullptr)
        {
            return {0, err};
        }
        err = submit(o);
        //Go switch emulation
        {
            auto condition = err;
            int conditionId = -1;
            if(condition == nullptr) { conditionId = 0; }
            else if(condition == syscall::ERROR_IO_PENDING) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(o->fd->skipSyncNotif)
                    {
                        return {int(o->qty), nullptr};
                    }
                    break;
                case 1:
                    err = nullptr;
                    break;
                default:
                    return {0, err};
                    break;
            }
        }
        err = wait(gocpp::recv(fd->pd), int(o->mode), fd->isFile);
        if(err == nullptr)
        {
            if(o->errno != 0)
            {
                err = syscall::Errno(o->errno);
                if(err == syscall::ERROR_MORE_DATA || err == windows::WSAEMSGSIZE)
                {
                    return {int(o->qty), err};
                }
                return {0, err};
            }
            return {int(o->qty), nullptr};
        }
        auto netpollErr = err;
        //Go switch emulation
        {
            auto condition = netpollErr;
            int conditionId = -1;
            if(condition == ErrNetClosing) { conditionId = 0; }
            if(condition == ErrFileClosing) { conditionId = 1; }
            if(condition == ErrDeadlineExceeded) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                    break;
                default:
                    gocpp::panic("unexpected runtime.netpoll error: " + Error(gocpp::recv(netpollErr)));
                    break;
            }
        }
        err = syscall::CancelIoEx(fd->Sysfd, & o->o);
        if(err != nullptr && err != syscall::ERROR_NOT_FOUND)
        {
            gocpp::panic(err);
        }
        waitCanceled(gocpp::recv(fd->pd), int(o->mode));
        if(o->errno != 0)
        {
            err = syscall::Errno(o->errno);
            if(err == syscall::ERROR_OPERATION_ABORTED)
            {
                err = netpollErr;
            }
            return {0, err};
        }
        return {int(o->qty), nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    FD::operator T()
    {
        T result;
        result.fdmu = this->fdmu;
        result.Sysfd = this->Sysfd;
        result.rop = this->rop;
        result.wop = this->wop;
        result.pd = this->pd;
        result.l = this->l;
        result.lastbits = this->lastbits;
        result.readuint16 = this->readuint16;
        result.readbyte = this->readbyte;
        result.readbyteOffset = this->readbyteOffset;
        result.csema = this->csema;
        result.skipSyncNotif = this->skipSyncNotif;
        result.IsStream = this->IsStream;
        result.ZeroReadIsEOF = this->ZeroReadIsEOF;
        result.isFile = this->isFile;
        result.kind = this->kind;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool FD::operator==(const T& ref) const
    {
        if (fdmu != ref.fdmu) return false;
        if (Sysfd != ref.Sysfd) return false;
        if (rop != ref.rop) return false;
        if (wop != ref.wop) return false;
        if (pd != ref.pd) return false;
        if (l != ref.l) return false;
        if (lastbits != ref.lastbits) return false;
        if (readuint16 != ref.readuint16) return false;
        if (readbyte != ref.readbyte) return false;
        if (readbyteOffset != ref.readbyteOffset) return false;
        if (csema != ref.csema) return false;
        if (skipSyncNotif != ref.skipSyncNotif) return false;
        if (IsStream != ref.IsStream) return false;
        if (ZeroReadIsEOF != ref.ZeroReadIsEOF) return false;
        if (isFile != ref.isFile) return false;
        if (kind != ref.kind) return false;
        return true;
    }

    std::ostream& FD::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fdmu;
        os << " " << Sysfd;
        os << " " << rop;
        os << " " << wop;
        os << " " << pd;
        os << " " << l;
        os << " " << lastbits;
        os << " " << readuint16;
        os << " " << readbyte;
        os << " " << readbyteOffset;
        os << " " << csema;
        os << " " << skipSyncNotif;
        os << " " << IsStream;
        os << " " << ZeroReadIsEOF;
        os << " " << isFile;
        os << " " << kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FD& value)
    {
        return value.PrintTo(os);
    }

    std::function<void (std::string net, struct FD* fd, struct gocpp::error err)> logInitFD;
    std::tuple<std::string, struct gocpp::error> Init(struct FD* fd, std::string net, bool pollable)
    {
        if(initErr != nullptr)
        {
            return {"", initErr};
        }
        //Go switch emulation
        {
            auto condition = net;
            int conditionId = -1;
            if(condition == "file") { conditionId = 0; }
            if(condition == "dir") { conditionId = 1; }
            else if(condition == "console") { conditionId = 2; }
            else if(condition == "pipe") { conditionId = 3; }
            else if(condition == "tcp") { conditionId = 4; }
            else if(condition == "tcp4") { conditionId = 5; }
            else if(condition == "tcp6") { conditionId = 6; }
            else if(condition == "udp") { conditionId = 7; }
            else if(condition == "udp4") { conditionId = 8; }
            else if(condition == "udp6") { conditionId = 9; }
            else if(condition == "ip") { conditionId = 10; }
            else if(condition == "ip4") { conditionId = 11; }
            else if(condition == "ip6") { conditionId = 12; }
            else if(condition == "unix") { conditionId = 13; }
            else if(condition == "unixgram") { conditionId = 14; }
            else if(condition == "unixpacket") { conditionId = 15; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    fd->kind = kindFile;
                    break;
                case 2:
                    fd->kind = kindConsole;
                    break;
                case 3:
                    fd->kind = kindPipe;
                    break;
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    fd->kind = kindNet;
                    break;
                default:
                    return {"", errors::New("internal error: unknown network type " + net)};
                    break;
            }
        }
        fd->isFile = fd->kind != kindNet;
        gocpp::error err = {};
        if(pollable)
        {
            err = init(gocpp::recv(fd->pd), fd);
        }
        if(logInitFD != nullptr)
        {
            logInitFD(net, fd, err);
        }
        if(err != nullptr)
        {
            return {"", err};
        }
        if(pollable && useSetFileCompletionNotificationModes)
        {
            auto flags = uint8_t(syscall::FILE_SKIP_SET_EVENT_ON_HANDLE);
            //Go switch emulation
            {
                auto condition = net;
                int conditionId = -1;
                if(condition == "tcp") { conditionId = 0; }
                if(condition == "tcp4") { conditionId = 1; }
                if(condition == "tcp6") { conditionId = 2; }
                if(condition == "udp") { conditionId = 3; }
                if(condition == "udp4") { conditionId = 4; }
                if(condition == "udp6") { conditionId = 5; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        flags |= syscall::FILE_SKIP_COMPLETION_PORT_ON_SUCCESS;
                        break;
                }
            }
            auto err = syscall::SetFileCompletionNotificationModes(fd->Sysfd, flags);
            if(err == nullptr && flags & syscall::FILE_SKIP_COMPLETION_PORT_ON_SUCCESS != 0)
            {
                fd->skipSyncNotif = true;
            }
        }
        //Go switch emulation
        {
            auto condition = net;
            int conditionId = -1;
            if(condition == "udp") { conditionId = 0; }
            if(condition == "udp4") { conditionId = 1; }
            if(condition == "udp6") { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                    auto ret = uint32_t(0);
                    auto flag = uint32_t(0);
                    auto size = uint32_t(gocpp::Sizeof<uint32_t>());
                    auto err = syscall::WSAIoctl(fd->Sysfd, syscall::SIO_UDP_CONNRESET, (unsigned char*)(unsafe::Pointer(& flag)), size, nullptr, 0, & ret, nullptr, 0);
                    if(err != nullptr)
                    {
                        return {"wsaioctl", err};
                    }
                    break;
            }
        }
        fd->rop.mode = 'r';
        fd->wop.mode = 'w';
        fd->rop.fd = fd;
        fd->wop.fd = fd;
        fd->rop.runtimeCtx = fd->pd.runtimeCtx;
        fd->wop.runtimeCtx = fd->pd.runtimeCtx;
        return {"", nullptr};
    }

    struct gocpp::error destroy(struct FD* fd)
    {
        if(fd->Sysfd == syscall::InvalidHandle)
        {
            return syscall::EINVAL;
        }
        close(gocpp::recv(fd->pd));
        gocpp::error err = {};
        //Go switch emulation
        {
            auto condition = fd->kind;
            int conditionId = -1;
            if(condition == kindNet) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    err = CloseFunc(fd->Sysfd);
                    break;
                default:
                    err = syscall::CloseHandle(fd->Sysfd);
                    break;
            }
        }
        fd->Sysfd = syscall::InvalidHandle;
        runtime_Semrelease(& fd->csema);
        return err;
    }

    struct gocpp::error Close(struct FD* fd)
    {
        if(! increfAndClose(gocpp::recv(fd->fdmu)))
        {
            return errClosing(fd->isFile);
        }
        if(fd->kind == kindPipe)
        {
            syscall::CancelIoEx(fd->Sysfd, nullptr);
        }
        evict(gocpp::recv(fd->pd));
        auto err = decref(gocpp::recv(fd));
        runtime_Semacquire(& fd->csema);
        return err;
    }

    std::tuple<int, struct gocpp::error> Read(struct FD* fd, gocpp::slice<unsigned char> buf)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            if(len(buf) > maxRW)
            {
                buf = buf.make_slice(0, maxRW);
            }
            int n = {};
            gocpp::error err = {};
            if(fd->isFile)
            {
                Lock(gocpp::recv(fd->l));
                defer.push_back([=]{ Unlock(gocpp::recv(fd->l)); });
                //Go switch emulation
                {
                    auto condition = fd->kind;
                    int conditionId = -1;
                    if(condition == kindConsole) { conditionId = 0; }
                    switch(conditionId)
                    {
                        case 0:
                            std::tie(n, err) = readConsole(gocpp::recv(fd), buf);
                            break;
                        default:
                            std::tie(n, err) = syscall::Read(fd->Sysfd, buf);
                            if(fd->kind == kindPipe && err == syscall::ERROR_OPERATION_ABORTED)
                            {
                                err = ErrFileClosing;
                            }
                            break;
                    }
                }
                if(err != nullptr)
                {
                    n = 0;
                }
            }
            else
            {
                auto o = & fd->rop;
                InitBuf(gocpp::recv(o), buf);
                std::tie(n, err) = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return syscall::WSARecv(o->fd->Sysfd, & o->buf, 1, & o->qty, & o->flags, & o->o, nullptr);
                });
                if(race::Enabled)
                {
                    race::Acquire(unsafe::Pointer(& ioSync));
                }
            }
            if(len(buf) != 0)
            {
                err = eofError(gocpp::recv(fd), n, err);
            }
            return {n, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::function<gocpp::error (syscall::Handle, *uint16, uint32_t, *uint32, *byte)> ReadConsole = syscall::ReadConsole;
    std::tuple<int, struct gocpp::error> readConsole(struct FD* fd, gocpp::slice<unsigned char> b)
    {
        if(len(b) == 0)
        {
            return {0, nullptr};
        }
        if(fd->readuint16 == nullptr)
        {
            fd->readuint16 = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 0, 10000);
            fd->readbyte = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 4 * cap(fd->readuint16));
        }
        for(; fd->readbyteOffset >= len(fd->readbyte); )
        {
            auto n = cap(fd->readuint16) - len(fd->readuint16);
            if(n > len(b))
            {
                n = len(b);
            }
            uint32_t nw = {};
            auto err = ReadConsole(fd->Sysfd, & fd->readuint16.make_slice(0, len(fd->readuint16) + 1)[len(fd->readuint16)], uint32_t(n), & nw, nullptr);
            if(err != nullptr)
            {
                return {0, err};
            }
            auto uint16s = fd->readuint16.make_slice(0, len(fd->readuint16) + int(nw));
            fd->readuint16 = fd->readuint16.make_slice(0, 0);
            auto buf = fd->readbyte.make_slice(0, 0);
            for(auto i = 0; i < len(uint16s); i++)
            {
                auto r = rune(uint16s[i]);
                if(utf16::IsSurrogate(r))
                {
                    if(i + 1 == len(uint16s))
                    {
                        if(nw > 0)
                        {
                            fd->readuint16 = fd->readuint16.make_slice(0, 1);
                            fd->readuint16[0] = uint16_t(r);
                            break;
                        }
                        r = utf8::RuneError;
                    }
                    else
                    {
                        r = utf16::DecodeRune(r, rune(uint16s[i + 1]));
                        if(r != utf8::RuneError)
                        {
                            i++;
                        }
                    }
                }
                buf = utf8::AppendRune(buf, r);
            }
            fd->readbyte = buf;
            fd->readbyteOffset = 0;
            if(nw == 0)
            {
                break;
            }
        }
        auto src = fd->readbyte.make_slice(fd->readbyteOffset);
        int i = {};
        for(i = 0; i < len(src) && i < len(b); i++)
        {
            auto x = src[i];
            if(x == 0x1A)
            {
                if(i == 0)
                {
                    fd->readbyteOffset++;
                }
                break;
            }
            b[i] = x;
        }
        fd->readbyteOffset += i;
        return {i, nullptr};
    }

    std::tuple<int, struct gocpp::error> Pread(struct FD* fd, gocpp::slice<unsigned char> b, int64_t off)
    {
        gocpp::Defer defer;
        try
        {
            if(fd->kind == kindPipe)
            {
                return {0, syscall::ESPIPE};
            }
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            if(len(b) > maxRW)
            {
                b = b.make_slice(0, maxRW);
            }
            Lock(gocpp::recv(fd->l));
            defer.push_back([=]{ Unlock(gocpp::recv(fd->l)); });
            auto [curoffset, e] = syscall::Seek(fd->Sysfd, 0, io::SeekCurrent);
            if(e != nullptr)
            {
                return {0, e};
            }
            defer.push_back([=]{ syscall::Seek(fd->Sysfd, curoffset, io::SeekStart); });
            auto o = gocpp::Init<syscall::Overlapped>([](syscall::Overlapped& x) { x.OffsetHigh = uint32_t(off >> 32); x.Offset = uint32_t(off); });
            uint32_t done = {};
            e = syscall::ReadFile(fd->Sysfd, b, & done, & o);
            if(e != nullptr)
            {
                done = 0;
                if(e == syscall::ERROR_HANDLE_EOF)
                {
                    e = io::go_EOF;
                }
            }
            if(len(b) != 0)
            {
                e = eofError(gocpp::recv(fd), int(done), e);
            }
            return {int(done), e};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct syscall::Sockaddr, struct gocpp::error> ReadFrom(struct FD* fd, gocpp::slice<unsigned char> buf)
    {
        gocpp::Defer defer;
        try
        {
            if(len(buf) == 0)
            {
                return {0, nullptr, nullptr};
            }
            if(len(buf) > maxRW)
            {
                buf = buf.make_slice(0, maxRW);
            }
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, nullptr, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            auto o = & fd->rop;
            InitBuf(gocpp::recv(o), buf);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                if(o->rsa == nullptr)
                {
                    o->rsa = go_new(syscall::RawSockaddrAny);
                }
                o->rsan = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
                return syscall::WSARecvFrom(o->fd->Sysfd, & o->buf, 1, & o->qty, & o->flags, o->rsa, & o->rsan, & o->o, nullptr);
            });
            err = eofError(gocpp::recv(fd), n, err);
            if(err != nullptr)
            {
                return {n, nullptr, err};
            }
            auto [sa, gocpp_id_1] = Sockaddr(gocpp::recv(o->rsa));
            return {n, sa, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> ReadFromInet4(struct FD* fd, gocpp::slice<unsigned char> buf, struct syscall::SockaddrInet4* sa4)
    {
        gocpp::Defer defer;
        try
        {
            if(len(buf) == 0)
            {
                return {0, nullptr};
            }
            if(len(buf) > maxRW)
            {
                buf = buf.make_slice(0, maxRW);
            }
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            auto o = & fd->rop;
            InitBuf(gocpp::recv(o), buf);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                if(o->rsa == nullptr)
                {
                    o->rsa = go_new(syscall::RawSockaddrAny);
                }
                o->rsan = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
                return syscall::WSARecvFrom(o->fd->Sysfd, & o->buf, 1, & o->qty, & o->flags, o->rsa, & o->rsan, & o->o, nullptr);
            });
            err = eofError(gocpp::recv(fd), n, err);
            if(err != nullptr)
            {
                return {n, err};
            }
            rawToSockaddrInet4(o->rsa, sa4);
            return {n, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> ReadFromInet6(struct FD* fd, gocpp::slice<unsigned char> buf, struct syscall::SockaddrInet6* sa6)
    {
        gocpp::Defer defer;
        try
        {
            if(len(buf) == 0)
            {
                return {0, nullptr};
            }
            if(len(buf) > maxRW)
            {
                buf = buf.make_slice(0, maxRW);
            }
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            auto o = & fd->rop;
            InitBuf(gocpp::recv(o), buf);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                if(o->rsa == nullptr)
                {
                    o->rsa = go_new(syscall::RawSockaddrAny);
                }
                o->rsan = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
                return syscall::WSARecvFrom(o->fd->Sysfd, & o->buf, 1, & o->qty, & o->flags, o->rsa, & o->rsan, & o->o, nullptr);
            });
            err = eofError(gocpp::recv(fd), n, err);
            if(err != nullptr)
            {
                return {n, err};
            }
            rawToSockaddrInet6(o->rsa, sa6);
            return {n, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> Write(struct FD* fd, gocpp::slice<unsigned char> buf)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            if(fd->isFile)
            {
                Lock(gocpp::recv(fd->l));
                defer.push_back([=]{ Unlock(gocpp::recv(fd->l)); });
            }
            auto ntotal = 0;
            for(; len(buf) > 0; )
            {
                auto b = buf;
                if(len(b) > maxRW)
                {
                    b = b.make_slice(0, maxRW);
                }
                int n = {};
                gocpp::error err = {};
                if(fd->isFile)
                {
                    //Go switch emulation
                    {
                        auto condition = fd->kind;
                        int conditionId = -1;
                        if(condition == kindConsole) { conditionId = 0; }
                        switch(conditionId)
                        {
                            case 0:
                                std::tie(n, err) = writeConsole(gocpp::recv(fd), b);
                                break;
                            default:
                                std::tie(n, err) = syscall::Write(fd->Sysfd, b);
                                if(fd->kind == kindPipe && err == syscall::ERROR_OPERATION_ABORTED)
                                {
                                    err = ErrFileClosing;
                                }
                                break;
                        }
                    }
                    if(err != nullptr)
                    {
                        n = 0;
                    }
                }
                else
                {
                    if(race::Enabled)
                    {
                        race::ReleaseMerge(unsafe::Pointer(& ioSync));
                    }
                    auto o = & fd->wop;
                    InitBuf(gocpp::recv(o), b);
                    std::tie(n, err) = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                    {
                        return syscall::WSASend(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, & o->o, nullptr);
                    });
                }
                ntotal += n;
                if(err != nullptr)
                {
                    return {ntotal, err};
                }
                buf = buf.make_slice(n);
            }
            return {ntotal, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> writeConsole(struct FD* fd, gocpp::slice<unsigned char> b)
    {
        auto n = len(b);
        auto runes = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::rune>>(), 0, 256);
        if(len(fd->lastbits) > 0)
        {
            b = append(fd->lastbits, b);
            fd->lastbits = nullptr;
        }
        for(; len(b) >= utf8::UTFMax || utf8::FullRune(b); )
        {
            auto [r, l] = utf8::DecodeRune(b);
            runes = append(runes, r);
            b = b.make_slice(l);
        }
        if(len(b) > 0)
        {
            fd->lastbits = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(b));
            copy(fd->lastbits, b);
        }
        auto maxWrite = 16000;
        for(; len(runes) > 0; )
        {
            auto m = len(runes);
            if(m > maxWrite)
            {
                m = maxWrite;
            }
            auto chunk = runes.make_slice(0, m);
            runes = runes.make_slice(m);
            auto uint16s = utf16::Encode(chunk);
            for(; len(uint16s) > 0; )
            {
                uint32_t written = {};
                auto err = syscall::WriteConsole(fd->Sysfd, & uint16s[0], uint32_t(len(uint16s)), & written, nullptr);
                if(err != nullptr)
                {
                    return {0, err};
                }
                uint16s = uint16s.make_slice(written);
            }
        }
        return {n, nullptr};
    }

    std::tuple<int, struct gocpp::error> Pwrite(struct FD* fd, gocpp::slice<unsigned char> buf, int64_t off)
    {
        gocpp::Defer defer;
        try
        {
            if(fd->kind == kindPipe)
            {
                return {0, syscall::ESPIPE};
            }
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            Lock(gocpp::recv(fd->l));
            defer.push_back([=]{ Unlock(gocpp::recv(fd->l)); });
            auto [curoffset, e] = syscall::Seek(fd->Sysfd, 0, io::SeekCurrent);
            if(e != nullptr)
            {
                return {0, e};
            }
            defer.push_back([=]{ syscall::Seek(fd->Sysfd, curoffset, io::SeekStart); });
            auto ntotal = 0;
            for(; len(buf) > 0; )
            {
                auto b = buf;
                if(len(b) > maxRW)
                {
                    b = b.make_slice(0, maxRW);
                }
                uint32_t n = {};
                auto o = gocpp::Init<syscall::Overlapped>([](syscall::Overlapped& x) { x.OffsetHigh = uint32_t(off >> 32); x.Offset = uint32_t(off); });
                e = syscall::WriteFile(fd->Sysfd, b, & n, & o);
                ntotal += int(n);
                if(e != nullptr)
                {
                    return {ntotal, e};
                }
                buf = buf.make_slice(n);
                off += int64_t(n);
            }
            return {ntotal, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int64_t, struct gocpp::error> Writev(struct FD* fd, gocpp::slice<gocpp::slice<unsigned char>>* buf)
    {
        gocpp::Defer defer;
        try
        {
            if(len(*buf) == 0)
            {
                return {0, nullptr};
            }
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            if(race::Enabled)
            {
                race::ReleaseMerge(unsafe::Pointer(& ioSync));
            }
            auto o = & fd->wop;
            InitBufs(gocpp::recv(o), buf);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return syscall::WSASend(o->fd->Sysfd, & o->bufs[0], uint32_t(len(o->bufs)), & o->qty, 0, & o->o, nullptr);
            });
            ClearBufs(gocpp::recv(o));
            TestHookDidWritev(n);
            consume(buf, int64_t(n));
            return {int64_t(n), err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> WriteTo(struct FD* fd, gocpp::slice<unsigned char> buf, struct syscall::Sockaddr sa)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            if(len(buf) == 0)
            {
                auto o = & fd->wop;
                InitBuf(gocpp::recv(o), buf);
                o->sa = sa;
                auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return syscall::WSASendto(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, o->sa, & o->o, nullptr);
                });
                return {n, err};
            }
            auto ntotal = 0;
            for(; len(buf) > 0; )
            {
                auto b = buf;
                if(len(b) > maxRW)
                {
                    b = b.make_slice(0, maxRW);
                }
                auto o = & fd->wop;
                InitBuf(gocpp::recv(o), b);
                o->sa = sa;
                auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return syscall::WSASendto(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, o->sa, & o->o, nullptr);
                });
                ntotal += int(n);
                if(err != nullptr)
                {
                    return {ntotal, err};
                }
                buf = buf.make_slice(n);
            }
            return {ntotal, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> WriteToInet4(struct FD* fd, gocpp::slice<unsigned char> buf, struct syscall::SockaddrInet4* sa4)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            if(len(buf) == 0)
            {
                auto o = & fd->wop;
                InitBuf(gocpp::recv(o), buf);
                auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return windows::WSASendtoInet4(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, sa4, & o->o, nullptr);
                });
                return {n, err};
            }
            auto ntotal = 0;
            for(; len(buf) > 0; )
            {
                auto b = buf;
                if(len(b) > maxRW)
                {
                    b = b.make_slice(0, maxRW);
                }
                auto o = & fd->wop;
                InitBuf(gocpp::recv(o), b);
                auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return windows::WSASendtoInet4(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, sa4, & o->o, nullptr);
                });
                ntotal += int(n);
                if(err != nullptr)
                {
                    return {ntotal, err};
                }
                buf = buf.make_slice(n);
            }
            return {ntotal, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, struct gocpp::error> WriteToInet6(struct FD* fd, gocpp::slice<unsigned char> buf, struct syscall::SockaddrInet6* sa6)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            if(len(buf) == 0)
            {
                auto o = & fd->wop;
                InitBuf(gocpp::recv(o), buf);
                auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return windows::WSASendtoInet6(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, sa6, & o->o, nullptr);
                });
                return {n, err};
            }
            auto ntotal = 0;
            for(; len(buf) > 0; )
            {
                auto b = buf;
                if(len(b) > maxRW)
                {
                    b = b.make_slice(0, maxRW);
                }
                auto o = & fd->wop;
                InitBuf(gocpp::recv(o), b);
                auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return windows::WSASendtoInet6(o->fd->Sysfd, & o->buf, 1, & o->qty, 0, sa6, & o->o, nullptr);
                });
                ntotal += int(n);
                if(err != nullptr)
                {
                    return {ntotal, err};
                }
                buf = buf.make_slice(n);
            }
            return {ntotal, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error ConnectEx(struct FD* fd, struct syscall::Sockaddr ra)
    {
        auto o = & fd->wop;
        o->sa = ra;
        auto [gocpp_id_3, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
        {
            return ConnectExFunc(o->fd->Sysfd, o->sa, nullptr, 0, nullptr, & o->o);
        });
        return err;
    }

    std::tuple<std::string, struct gocpp::error> acceptOne(struct FD* fd, syscall::Handle s, gocpp::slice<syscall::RawSockaddrAny> rawsa, struct operation* o)
    {
        o->handle = s;
        o->rsan = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
        auto [gocpp_id_5, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
        {
            return AcceptFunc(o->fd->Sysfd, o->handle, (unsigned char*)(unsafe::Pointer(& rawsa[0])), 0, uint32_t(o->rsan), uint32_t(o->rsan), & o->qty, & o->o);
        });
        if(err != nullptr)
        {
            CloseFunc(s);
            return {"acceptex", err};
        }
        err = syscall::Setsockopt(s, syscall::SOL_SOCKET, syscall::SO_UPDATE_ACCEPT_CONTEXT, (unsigned char*)(unsafe::Pointer(& fd->Sysfd)), int32_t(gocpp::Sizeof<syscall::Handle>()));
        if(err != nullptr)
        {
            CloseFunc(s);
            return {"setsockopt", err};
        }
        return {"", nullptr};
    }

    std::tuple<syscall::Handle, gocpp::slice<syscall::RawSockaddrAny>, uint32_t, std::string, struct gocpp::error> Accept(struct FD* fd, std::function<std::tuple<syscall::Handle, struct gocpp::error> ()> sysSocket)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {syscall::InvalidHandle, nullptr, 0, "", err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            auto o = & fd->rop;
            gocpp::array<syscall::RawSockaddrAny, 2> rawsa = {};
            for(; ; )
            {
                auto [s, err] = sysSocket();
                if(err != nullptr)
                {
                    return {syscall::InvalidHandle, nullptr, 0, "", err};
                }
                std::string errcall;
                std::tie(errcall, err) = acceptOne(gocpp::recv(fd), s, rawsa.make_slice(0, ), o);
                if(err == nullptr)
                {
                    return {s, rawsa.make_slice(0, ), uint32_t(o->rsan), "", nullptr};
                }
                auto [errno, ok] = gocpp::getValue<syscall::Errno>(err);
                if(! ok)
                {
                    return {syscall::InvalidHandle, nullptr, 0, errcall, err};
                }
                //Go switch emulation
                {
                    auto condition = errno;
                    int conditionId = -1;
                    if(condition == syscall::ERROR_NETNAME_DELETED) { conditionId = 0; }
                    if(condition == syscall::WSAECONNRESET) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                            break;
                        default:
                            return {syscall::InvalidHandle, nullptr, 0, errcall, err};
                            break;
                    }
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int64_t, struct gocpp::error> Seek(struct FD* fd, int64_t offset, int whence)
    {
        gocpp::Defer defer;
        try
        {
            if(fd->kind == kindPipe)
            {
                return {0, syscall::ESPIPE};
            }
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            Lock(gocpp::recv(fd->l));
            defer.push_back([=]{ Unlock(gocpp::recv(fd->l)); });
            return syscall::Seek(fd->Sysfd, offset, whence);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error Fchmod(struct FD* fd, uint32_t mode)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return err;
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            syscall::ByHandleFileInformation d = {};
            if(auto err = syscall::GetFileInformationByHandle(fd->Sysfd, & d); err != nullptr)
            {
                return err;
            }
            auto attrs = d.FileAttributes;
            if(mode & syscall::S_IWRITE != 0)
            {
                attrs &^= syscall::FILE_ATTRIBUTE_READONLY;
            }
            else
            {
                attrs |= syscall::FILE_ATTRIBUTE_READONLY;
            }
            if(attrs == d.FileAttributes)
            {
                return nullptr;
            }
            windows::FILE_BASIC_INFO du = {};
            du.FileAttributes = attrs;
            return windows::SetFileInformationByHandle(fd->Sysfd, windows::FileBasicInfo, unsafe::Pointer(& du), uint32_t(gocpp::Sizeof<windows::FILE_BASIC_INFO>()));
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error Fchdir(struct FD* fd)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return err;
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            return syscall::Fchdir(fd->Sysfd);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileType(struct FD* fd)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return {0, err};
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            return syscall::GetFileType(fd->Sysfd);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error GetFileInformationByHandle(struct FD* fd, struct syscall::ByHandleFileInformation* data)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = incref(gocpp::recv(fd)); err != nullptr)
            {
                return err;
            }
            defer.push_back([=]{ decref(gocpp::recv(fd)); });
            return syscall::GetFileInformationByHandle(fd->Sysfd, data);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error RawRead(struct FD* fd, std::function<bool (uintptr_t)> f)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return err;
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            for(; ; )
            {
                if(f(uintptr_t(fd->Sysfd)))
                {
                    return nullptr;
                }
                auto o = & fd->rop;
                InitBuf(gocpp::recv(o), nullptr);
                if(! fd->IsStream)
                {
                    o->flags |= windows::MSG_PEEK;
                }
                auto [gocpp_id_7, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
                {
                    return syscall::WSARecv(o->fd->Sysfd, & o->buf, 1, & o->qty, & o->flags, & o->o, nullptr);
                });
                if(err == windows::WSAEMSGSIZE)
                {
                }
                else
                if(err != nullptr)
                {
                    return err;
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error RawWrite(struct FD* fd, std::function<bool (uintptr_t)> f)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return err;
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            if(f(uintptr_t(fd->Sysfd)))
            {
                return nullptr;
            }
            return syscall::EWINDOWS;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    int32_t sockaddrInet4ToRaw(struct syscall::RawSockaddrAny* rsa, struct syscall::SockaddrInet4* sa)
    {
        *rsa = syscall::RawSockaddrAny {};
        auto raw = (syscall::RawSockaddrInet4*)(unsafe::Pointer(rsa));
        raw->Family = syscall::AF_INET;
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& raw->Port));
        p[0] = unsigned char(sa->Port >> 8);
        p[1] = unsigned char(sa->Port);
        raw->Addr = sa->Addr;
        return int32_t(gocpp::Sizeof<syscall::RawSockaddrInet4>());
    }

    int32_t sockaddrInet6ToRaw(struct syscall::RawSockaddrAny* rsa, struct syscall::SockaddrInet6* sa)
    {
        *rsa = syscall::RawSockaddrAny {};
        auto raw = (syscall::RawSockaddrInet6*)(unsafe::Pointer(rsa));
        raw->Family = syscall::AF_INET6;
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& raw->Port));
        p[0] = unsigned char(sa->Port >> 8);
        p[1] = unsigned char(sa->Port);
        raw->Scope_id = sa->ZoneId;
        raw->Addr = sa->Addr;
        return int32_t(gocpp::Sizeof<syscall::RawSockaddrInet6>());
    }

    void rawToSockaddrInet4(struct syscall::RawSockaddrAny* rsa, struct syscall::SockaddrInet4* sa)
    {
        auto pp = (syscall::RawSockaddrInet4*)(unsafe::Pointer(rsa));
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& pp->Port));
        sa->Port = (int(p[0]) << 8) + int(p[1]);
        sa->Addr = pp->Addr;
    }

    void rawToSockaddrInet6(struct syscall::RawSockaddrAny* rsa, struct syscall::SockaddrInet6* sa)
    {
        auto pp = (syscall::RawSockaddrInet6*)(unsafe::Pointer(rsa));
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& pp->Port));
        sa->Port = (int(p[0]) << 8) + int(p[1]);
        sa->ZoneId = pp->Scope_id;
        sa->Addr = pp->Addr;
    }

    std::tuple<int32_t, struct gocpp::error> sockaddrToRaw(struct syscall::RawSockaddrAny* rsa, struct syscall::Sockaddr sa)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_8 = gocpp::type_info(sa);
            int conditionId = -1;
            if(gocpp_id_8 == typeid(syscall::SockaddrInet4*)) { conditionId = 0; }
            else if(gocpp_id_8 == typeid(syscall::SockaddrInet6*)) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                {
                    syscall::SockaddrInet4* sa = gocpp::any_cast<syscall::SockaddrInet4*>(sa);
                    auto sz = sockaddrInet4ToRaw(rsa, sa);
                    return {sz, nullptr};
                    break;
                }
                case 1:
                {
                    syscall::SockaddrInet6* sa = gocpp::any_cast<syscall::SockaddrInet6*>(sa);
                    auto sz = sockaddrInet6ToRaw(rsa, sa);
                    return {sz, nullptr};
                    break;
                }
                default:
                {
                    auto sa = sa;
                    return {0, syscall::EWINDOWS};
                    break;
                }
            }
        }
    }

    std::tuple<int, int, int, struct syscall::Sockaddr, struct gocpp::error> ReadMsg(struct FD* fd, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob, int flags)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, 0, 0, nullptr, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            if(len(p) > maxRW)
            {
                p = p.make_slice(0, maxRW);
            }
            auto o = & fd->rop;
            InitMsg(gocpp::recv(o), p, oob);
            if(o->rsa == nullptr)
            {
                o->rsa = go_new(syscall::RawSockaddrAny);
            }
            o->msg.Name = (syscall::Pointer)(unsafe::Pointer(o->rsa));
            o->msg.Namelen = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
            o->msg.Flags = uint32_t(flags);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return windows::WSARecvMsg(o->fd->Sysfd, & o->msg, & o->qty, & o->o, nullptr);
            });
            err = eofError(gocpp::recv(fd), n, err);
            syscall::Sockaddr sa = {};
            if(err == nullptr)
            {
                std::tie(sa, err) = Sockaddr(gocpp::recv(o->rsa));
            }
            return {n, int(o->msg.Control.Len), int(o->msg.Flags), sa, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, int, int, struct gocpp::error> ReadMsgInet4(struct FD* fd, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob, int flags, struct syscall::SockaddrInet4* sa4)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, 0, 0, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            if(len(p) > maxRW)
            {
                p = p.make_slice(0, maxRW);
            }
            auto o = & fd->rop;
            InitMsg(gocpp::recv(o), p, oob);
            if(o->rsa == nullptr)
            {
                o->rsa = go_new(syscall::RawSockaddrAny);
            }
            o->msg.Name = (syscall::Pointer)(unsafe::Pointer(o->rsa));
            o->msg.Namelen = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
            o->msg.Flags = uint32_t(flags);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return windows::WSARecvMsg(o->fd->Sysfd, & o->msg, & o->qty, & o->o, nullptr);
            });
            err = eofError(gocpp::recv(fd), n, err);
            if(err == nullptr)
            {
                rawToSockaddrInet4(o->rsa, sa4);
            }
            return {n, int(o->msg.Control.Len), int(o->msg.Flags), err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, int, int, struct gocpp::error> ReadMsgInet6(struct FD* fd, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob, int flags, struct syscall::SockaddrInet6* sa6)
    {
        gocpp::Defer defer;
        try
        {
            if(auto err = readLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, 0, 0, err};
            }
            defer.push_back([=]{ readUnlock(gocpp::recv(fd)); });
            if(len(p) > maxRW)
            {
                p = p.make_slice(0, maxRW);
            }
            auto o = & fd->rop;
            InitMsg(gocpp::recv(o), p, oob);
            if(o->rsa == nullptr)
            {
                o->rsa = go_new(syscall::RawSockaddrAny);
            }
            o->msg.Name = (syscall::Pointer)(unsafe::Pointer(o->rsa));
            o->msg.Namelen = int32_t(gocpp::Sizeof<syscall::RawSockaddrAny>());
            o->msg.Flags = uint32_t(flags);
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return windows::WSARecvMsg(o->fd->Sysfd, & o->msg, & o->qty, & o->o, nullptr);
            });
            err = eofError(gocpp::recv(fd), n, err);
            if(err == nullptr)
            {
                rawToSockaddrInet6(o->rsa, sa6);
            }
            return {n, int(o->msg.Control.Len), int(o->msg.Flags), err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, int, struct gocpp::error> WriteMsg(struct FD* fd, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob, struct syscall::Sockaddr sa)
    {
        gocpp::Defer defer;
        try
        {
            if(len(p) > maxRW)
            {
                return {0, 0, errors::New("packet is too large (only 1GB is allowed)")};
            }
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, 0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            auto o = & fd->wop;
            InitMsg(gocpp::recv(o), p, oob);
            if(sa != nullptr)
            {
                if(o->rsa == nullptr)
                {
                    o->rsa = go_new(syscall::RawSockaddrAny);
                }
                auto [len, err] = sockaddrToRaw(o->rsa, sa);
                if(err != nullptr)
                {
                    return {0, 0, err};
                }
                o->msg.Name = (syscall::Pointer)(unsafe::Pointer(o->rsa));
                o->msg.Namelen = len;
            }
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return windows::WSASendMsg(o->fd->Sysfd, & o->msg, 0, & o->qty, & o->o, nullptr);
            });
            return {n, int(o->msg.Control.Len), err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, int, struct gocpp::error> WriteMsgInet4(struct FD* fd, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob, struct syscall::SockaddrInet4* sa)
    {
        gocpp::Defer defer;
        try
        {
            if(len(p) > maxRW)
            {
                return {0, 0, errors::New("packet is too large (only 1GB is allowed)")};
            }
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, 0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            auto o = & fd->wop;
            InitMsg(gocpp::recv(o), p, oob);
            if(o->rsa == nullptr)
            {
                o->rsa = go_new(syscall::RawSockaddrAny);
            }
            auto len = sockaddrInet4ToRaw(o->rsa, sa);
            o->msg.Name = (syscall::Pointer)(unsafe::Pointer(o->rsa));
            o->msg.Namelen = len;
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return windows::WSASendMsg(o->fd->Sysfd, & o->msg, 0, & o->qty, & o->o, nullptr);
            });
            return {n, int(o->msg.Control.Len), err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int, int, struct gocpp::error> WriteMsgInet6(struct FD* fd, gocpp::slice<unsigned char> p, gocpp::slice<unsigned char> oob, struct syscall::SockaddrInet6* sa)
    {
        gocpp::Defer defer;
        try
        {
            if(len(p) > maxRW)
            {
                return {0, 0, errors::New("packet is too large (only 1GB is allowed)")};
            }
            if(auto err = writeLock(gocpp::recv(fd)); err != nullptr)
            {
                return {0, 0, err};
            }
            defer.push_back([=]{ writeUnlock(gocpp::recv(fd)); });
            auto o = & fd->wop;
            InitMsg(gocpp::recv(o), p, oob);
            if(o->rsa == nullptr)
            {
                o->rsa = go_new(syscall::RawSockaddrAny);
            }
            auto len = sockaddrInet6ToRaw(o->rsa, sa);
            o->msg.Name = (syscall::Pointer)(unsafe::Pointer(o->rsa));
            o->msg.Namelen = len;
            auto [n, err] = execIO(o, [=](struct operation* o) mutable -> struct gocpp::error
            {
                return windows::WSASendMsg(o->fd->Sysfd, & o->msg, 0, & o->qty, & o->o, nullptr);
            });
            return {n, int(o->msg.Control.Len), err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

