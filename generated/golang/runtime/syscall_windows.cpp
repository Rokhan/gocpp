// generated by GoCpp from file '$(ImportDir)/runtime/syscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/syscall_windows.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mprof.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/runtime/zcallback_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    struct gocpp_id_0
    {
        mutex lock;
        gocpp::array<winCallback, cb_max> ctxt;
        gocpp::map<winCallbackKey, int> index;
        int n;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.lock = this->lock;
            result.ctxt = this->ctxt;
            result.index = this->index;
            result.n = this->n;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (lock != ref.lock) return false;
            if (ctxt != ref.ctxt) return false;
            if (index != ref.index) return false;
            if (n != ref.n) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << ctxt;
            os << " " << index;
            os << " " << n;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 cbs;
    void cbsLock()
    {
        lock(& cbs.lock);
        if(raceenabled && mainStarted)
        {
            raceacquire(unsafe::Pointer(& cbs.lock));
        }
    }

    void cbsUnlock()
    {
        if(raceenabled && mainStarted)
        {
            racerelease(unsafe::Pointer(& cbs.lock));
        }
        unlock(& cbs.lock);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    winCallback::operator T()
    {
        T result;
        result.fn = this->fn;
        result.retPop = this->retPop;
        result.abiMap = this->abiMap;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool winCallback::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (retPop != ref.retPop) return false;
        if (abiMap != ref.abiMap) return false;
        return true;
    }

    std::ostream& winCallback::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << retPop;
        os << " " << abiMap;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct winCallback& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    abiPart::operator T()
    {
        T result;
        result.kind = this->kind;
        result.srcStackOffset = this->srcStackOffset;
        result.dstStackOffset = this->dstStackOffset;
        result.dstRegister = this->dstRegister;
        result.len = this->len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool abiPart::operator==(const T& ref) const
    {
        if (kind != ref.kind) return false;
        if (srcStackOffset != ref.srcStackOffset) return false;
        if (dstStackOffset != ref.dstStackOffset) return false;
        if (dstRegister != ref.dstRegister) return false;
        if (len != ref.len) return false;
        return true;
    }

    std::ostream& abiPart::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << srcStackOffset;
        os << " " << dstStackOffset;
        os << " " << dstRegister;
        os << " " << len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct abiPart& value)
    {
        return value.PrintTo(os);
    }

    bool rec::tryMerge(struct abiPart* a, struct abiPart b)
    {
        if(a->kind != abiPartStack || b.kind != abiPartStack)
        {
            return false;
        }
        if(a->srcStackOffset + a->len == b.srcStackOffset && a->dstStackOffset + a->len == b.dstStackOffset)
        {
            a->len += b.len;
            return true;
        }
        return false;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    abiDesc::operator T()
    {
        T result;
        result.parts = this->parts;
        result.srcStackSize = this->srcStackSize;
        result.dstStackSize = this->dstStackSize;
        result.dstSpill = this->dstSpill;
        result.dstRegisters = this->dstRegisters;
        result.retOffset = this->retOffset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool abiDesc::operator==(const T& ref) const
    {
        if (parts != ref.parts) return false;
        if (srcStackSize != ref.srcStackSize) return false;
        if (dstStackSize != ref.dstStackSize) return false;
        if (dstSpill != ref.dstSpill) return false;
        if (dstRegisters != ref.dstRegisters) return false;
        if (retOffset != ref.retOffset) return false;
        return true;
    }

    std::ostream& abiDesc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << parts;
        os << " " << srcStackSize;
        os << " " << dstStackSize;
        os << " " << dstSpill;
        os << " " << dstRegisters;
        os << " " << retOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct abiDesc& value)
    {
        return value.PrintTo(os);
    }

    void rec::assignArg(struct abiDesc* p, struct _type* t)
    {
        if(t->Size_ > goarch::PtrSize)
        {
            gocpp::panic("compileCallback: argument size is larger than uintptr");
        }
        if(auto k = t->Kind_ & kindMask; GOARCH != "386" && (k == kindFloat32 || k == kindFloat64))
        {
            gocpp::panic("compileCallback: float arguments not supported");
        }
        if(t->Size_ == 0)
        {
            p->dstStackSize = alignUp(p->dstStackSize, uintptr_t(t->Align_));
            return;
        }
        auto oldParts = p->parts;
        if(rec::tryRegAssignArg(gocpp::recv(p), t, 0))
        {
            p->dstSpill = alignUp(p->dstSpill, uintptr_t(t->Align_));
            p->dstSpill += t->Size_;
        }
        else
        {
            p->parts = oldParts;
            p->dstStackSize = alignUp(p->dstStackSize, uintptr_t(t->Align_));
            auto part = gocpp::Init<abiPart>([](abiPart& x) { x.kind = abiPartStack; x.srcStackOffset = p->srcStackSize; x.dstStackOffset = p->dstStackSize; x.len = t->Size_; });
            if(len(p->parts) == 0 || ! rec::tryMerge(gocpp::recv(p->parts[len(p->parts) - 1]), part))
            {
                p->parts = append(p->parts, part);
            }
            p->dstStackSize += t->Size_;
        }
        p->srcStackSize += goarch::PtrSize;
    }

    bool rec::tryRegAssignArg(struct abiDesc* p, struct _type* t, uintptr_t offset)
    {
        //Go switch emulation
        {
            auto k = t->Kind_ & kindMask;
            auto condition = k;
            int conditionId = -1;
            if(condition == kindBool) { conditionId = 0; }
            if(condition == kindInt) { conditionId = 1; }
            if(condition == kindInt8) { conditionId = 2; }
            if(condition == kindInt16) { conditionId = 3; }
            if(condition == kindInt32) { conditionId = 4; }
            if(condition == kindUint) { conditionId = 5; }
            if(condition == kindUint8) { conditionId = 6; }
            if(condition == kindUint16) { conditionId = 7; }
            if(condition == kindUint32) { conditionId = 8; }
            if(condition == kindUintptr) { conditionId = 9; }
            if(condition == kindPtr) { conditionId = 10; }
            if(condition == kindUnsafePointer) { conditionId = 11; }
            else if(condition == kindInt64) { conditionId = 12; }
            else if(condition == kindUint64) { conditionId = 13; }
            else if(condition == kindArray) { conditionId = 14; }
            else if(condition == kindStruct) { conditionId = 15; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    return rec::assignReg(gocpp::recv(p), t->Size_, offset);
                    break;
                case 12:
                case 13:
                    if(goarch::PtrSize == 8)
                    {
                        return rec::assignReg(gocpp::recv(p), t->Size_, offset);
                    }
                    break;
                case 14:
                    auto at = (arraytype*)(unsafe::Pointer(t));
                    if(at->Len == 1)
                    {
                        return rec::tryRegAssignArg(gocpp::recv(p), at->Elem, offset);
                    }
                    break;
                case 15:
                    auto st = (structtype*)(unsafe::Pointer(t));
                    for(auto [i, gocpp_ignored] : st->Fields)
                    {
                        auto f = & st->Fields[i];
                        if(! rec::tryRegAssignArg(gocpp::recv(p), f->Typ, offset + f->Offset))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
            }
        }
        gocpp::panic("compileCallback: type " + rec::string(gocpp::recv(toRType(t))) + " is currently not supported for use in system callbacks");
    }

    bool rec::assignReg(struct abiDesc* p, uintptr_t size, uintptr_t offset)
    {
        if(p->dstRegisters >= intArgRegs)
        {
            return false;
        }
        p->parts = append(p->parts, gocpp::Init<abiPart>([](abiPart& x) { x.kind = abiPartReg; x.srcStackOffset = p->srcStackSize + offset; x.dstRegister = p->dstRegisters; x.len = size; }));
        p->dstRegisters++;
        return true;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    winCallbackKey::operator T()
    {
        T result;
        result.fn = this->fn;
        result.cdecl = this->cdecl;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool winCallbackKey::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (cdecl != ref.cdecl) return false;
        return true;
    }

    std::ostream& winCallbackKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << cdecl;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct winCallbackKey& value)
    {
        return value.PrintTo(os);
    }

    void callbackasm()
    /* convertBlockStmt, nil block */;

    uintptr_t callbackasmAddr(int i)
    {
        int entrySize = {};
        //Go switch emulation
        {
            auto condition = GOARCH;
            int conditionId = -1;
            else if(condition == "386") { conditionId = 0; }
            else if(condition == "amd64") { conditionId = 1; }
            else if(condition == "arm") { conditionId = 2; }
            else if(condition == "arm64") { conditionId = 3; }
            switch(conditionId)
            {
                default:
                    gocpp::panic("unsupported architecture");
                    break;
                case 0:
                case 1:
                    entrySize = 5;
                    break;
                case 2:
                case 3:
                    entrySize = 8;
                    break;
            }
        }
        return abi::FuncPCABI0(callbackasm) + uintptr_t(i * entrySize);
    }

    uintptr_t compileCallback(struct eface fn, bool cdecl)
    {
        uintptr_t code;
        if(GOARCH != "386")
        {
            uintptr_t code;
            cdecl = false;
        }
        if(fn._type == nullptr || (fn._type->Kind_ & kindMask) != kindFunc)
        {
            uintptr_t code;
            gocpp::panic("compileCallback: expected function with one uintptr-sized result");
        }
        auto ft = (functype*)(unsafe::Pointer(fn._type));
        abiDesc abiMap = {};
        for(auto [gocpp_ignored, t] : rec::InSlice(gocpp::recv(ft)))
        {
            uintptr_t code;
            rec::assignArg(gocpp::recv(abiMap), t);
        }
        abiMap.dstStackSize = alignUp(abiMap.dstStackSize, goarch::PtrSize);
        abiMap.retOffset = abiMap.dstStackSize;
        if(len(rec::OutSlice(gocpp::recv(ft))) != 1)
        {
            uintptr_t code;
            gocpp::panic("compileCallback: expected function with one uintptr-sized result");
        }
        if(rec::OutSlice(gocpp::recv(ft))[0]->Size_ != goarch::PtrSize)
        {
            uintptr_t code;
            gocpp::panic("compileCallback: expected function with one uintptr-sized result");
        }
        if(auto k = rec::OutSlice(gocpp::recv(ft))[0]->Kind_ & kindMask; k == kindFloat32 || k == kindFloat64)
        {
            uintptr_t code;
            gocpp::panic("compileCallback: float results not supported");
        }
        if(intArgRegs == 0)
        {
            uintptr_t code;
            abiMap.dstStackSize += goarch::PtrSize;
        }
        auto frameSize = alignUp(abiMap.dstStackSize, goarch::PtrSize);
        frameSize += abiMap.dstSpill;
        if(frameSize > callbackMaxFrame)
        {
            uintptr_t code;
            gocpp::panic("compileCallback: function argument frame too large");
        }
        uintptr_t retPop = {};
        if(cdecl)
        {
            uintptr_t code;
            retPop = abiMap.srcStackSize;
        }
        auto key = winCallbackKey {(funcval*)(fn.data), cdecl};
        cbsLock();
        if(auto [n, ok] = cbs.index[key]; ok)
        {
            uintptr_t code;
            cbsUnlock();
            return callbackasmAddr(n);
        }
        if(cbs.index == nullptr)
        {
            uintptr_t code;
            cbs.index = gocpp::make(gocpp::Tag<gocpp::map<winCallbackKey, int>>());
        }
        auto n = cbs.n;
        if(n >= len(cbs.ctxt))
        {
            uintptr_t code;
            cbsUnlock();
            go_throw("too many callback functions");
        }
        auto c = winCallback {key.fn, retPop, abiMap};
        cbs.ctxt[n] = c;
        cbs.index[key] = n;
        cbs.n++;
        cbsUnlock();
        return callbackasmAddr(n);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    callbackArgs::operator T()
    {
        T result;
        result.index = this->index;
        result.args = this->args;
        result.result = this->result;
        result.retPop = this->retPop;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool callbackArgs::operator==(const T& ref) const
    {
        if (index != ref.index) return false;
        if (args != ref.args) return false;
        if (result != ref.result) return false;
        if (retPop != ref.retPop) return false;
        return true;
    }

    std::ostream& callbackArgs::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << index;
        os << " " << args;
        os << " " << result;
        os << " " << retPop;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct callbackArgs& value)
    {
        return value.PrintTo(os);
    }

    void callbackWrap(struct callbackArgs* a)
    {
        auto c = cbs.ctxt[a->index];
        a->retPop = c.retPop;
        abi::RegArgs regs = {};
        gocpp::array<unsigned char, callbackMaxFrame> frame = {};
        auto goArgs = unsafe::Pointer(& frame);
        for(auto [gocpp_ignored, part] : c.abiMap.parts)
        {
            //Go switch emulation
            {
                auto condition = part.kind;
                int conditionId = -1;
                if(condition == abiPartStack) { conditionId = 0; }
                else if(condition == abiPartReg) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        memmove(add(goArgs, part.dstStackOffset), add(a->args, part.srcStackOffset), part.len);
                        break;
                    case 1:
                        auto goReg = unsafe::Pointer(& regs.Ints[part.dstRegister]);
                        memmove(goReg, add(a->args, part.srcStackOffset), part.len);
                        break;
                    default:
                        gocpp::panic("bad ABI description");
                        break;
                }
            }
        }
        auto frameSize = alignUp(c.abiMap.dstStackSize, goarch::PtrSize);
        frameSize += c.abiMap.dstSpill;
        reflectcall(nullptr, unsafe::Pointer(c.fn), noescape(goArgs), uint32_t(c.abiMap.dstStackSize), uint32_t(c.abiMap.retOffset), uint32_t(frameSize), & regs);
        if(c.abiMap.dstStackSize != c.abiMap.retOffset)
        {
            a->result = *(uintptr_t*)(unsafe::Pointer(& frame[c.abiMap.retOffset]));
        }
        else
        {
            int zero = {};
            a->result = regs.Ints[zero];
        }
    }

    struct gocpp_id_1
        {
            uint16_t* lpFileName;
            uintptr_t hFile;
            uint32_t flags;

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                result.lpFileName = this->lpFileName;
                result.hFile = this->hFile;
                result.flags = this->flags;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                if (lpFileName != ref.lpFileName) return false;
                if (hFile != ref.hFile) return false;
                if (flags != ref.flags) return false;
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << lpFileName;
                os << " " << hFile;
                os << " " << flags;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    std::tuple<uintptr_t, uintptr_t> syscall_loadsystemlibrary(uint16_t* filename)
    {
        uintptr_t handle;
        uintptr_t err;
        lockOSThread();
        auto c = & getg()->m->syscall;
        c->fn = getLoadLibraryEx();
        c->n = 3;
        auto args = gocpp_id_1 {filename, 0, _LOAD_LIBRARY_SEARCH_SYSTEM32};
        c->args = uintptr_t(noescape(unsafe::Pointer(& args)));
        cgocall(asmstdcallAddr, unsafe::Pointer(c));
        KeepAlive(filename);
        handle = c->r1;
        if(handle == 0)
        {
            uintptr_t handle;
            uintptr_t err;
            err = c->err;
        }
        unlockOSThread();
        return {handle, err};
    }

    std::tuple<uintptr_t, uintptr_t> syscall_loadlibrary(uint16_t* filename)
    {
        gocpp::Defer defer;
        try
        {
            uintptr_t handle;
            uintptr_t err;
            lockOSThread();
            defer.push_back([=]{ unlockOSThread(); });
            auto c = & getg()->m->syscall;
            c->fn = getLoadLibrary();
            c->n = 1;
            c->args = uintptr_t(noescape(unsafe::Pointer(& filename)));
            cgocall(asmstdcallAddr, unsafe::Pointer(c));
            KeepAlive(filename);
            handle = c->r1;
            if(handle == 0)
            {
                uintptr_t handle;
                uintptr_t err;
                err = c->err;
            }
            return {handle, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<uintptr_t, uintptr_t> syscall_getprocaddress(uintptr_t handle, unsigned char* procname)
    {
        gocpp::Defer defer;
        try
        {
            uintptr_t outhandle;
            uintptr_t err;
            lockOSThread();
            defer.push_back([=]{ unlockOSThread(); });
            auto c = & getg()->m->syscall;
            c->fn = getGetProcAddress();
            c->n = 2;
            c->args = uintptr_t(noescape(unsafe::Pointer(& handle)));
            cgocall(asmstdcallAddr, unsafe::Pointer(c));
            KeepAlive(procname);
            outhandle = c->r1;
            if(outhandle == 0)
            {
                uintptr_t outhandle;
                uintptr_t err;
                err = c->err;
            }
            return {outhandle, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3)
    {
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;
        return syscall_SyscallN(fn, a1, a2, a3);
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall6(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
    {
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;
        return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6);
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall9(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9)
    {
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;
        return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall12(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12)
    {
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;
        return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall15(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15)
    {
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;
        return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall18(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15, uintptr_t a16, uintptr_t a17, uintptr_t a18)
    {
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;
        return syscall_SyscallN(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_SyscallN(uintptr_t trap, gocpp::slice<uintptr_t> args)
    {
        gocpp::Defer defer;
        try
        {
            uintptr_t r1;
            uintptr_t r2;
            uintptr_t err;
            auto nargs = len(args);
            gocpp::array<uintptr_t, 4> tmp = {};
            //Go switch emulation
            {
                int conditionId = -1;
                if(nargs < 4) { conditionId = 0; }
                else if(nargs > maxArgs) { conditionId = 1; }
                switch(conditionId)
                {
                    uintptr_t r1;
                    uintptr_t r2;
                    uintptr_t err;
                    case 0:
                        copy(tmp.make_slice(0, ), args);
                        args = tmp.make_slice(0, );
                        break;
                    case 1:
                        gocpp::panic("runtime: SyscallN has too many arguments");
                        break;
                }
            }
            lockOSThread();
            defer.push_back([=]{ unlockOSThread(); });
            auto c = & getg()->m->syscall;
            c->fn = trap;
            c->n = uintptr_t(nargs);
            c->args = uintptr_t(noescape(unsafe::Pointer(& args[0])));
            cgocall(asmstdcallAddr, unsafe::Pointer(c));
            return {c->r1, c->r2, c->err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

