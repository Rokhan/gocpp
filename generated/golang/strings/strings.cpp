// generated by GoCpp from file '$(ImportDir)/strings/strings.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strings/strings.h"
#include "gocpp/support.h"

#include "golang/internal/bytealg/bytealg.h"
#include "golang/internal/bytealg/count_native.h"
#include "golang/internal/bytealg/index_amd64.h"
#include "golang/internal/bytealg/index_native.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/bytealg/lastindexbyte_generic.h"
#include "golang/strings/builder.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/letter.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::strings
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace bytealg::rec;
        using namespace strings::rec;
        using namespace unicode::rec;
        using namespace utf8::rec;
    }

    gocpp::slice<std::string> explode(std::string s, int n)
    {
        auto l = utf8::RuneCountInString(s);
        if(n < 0 || n > l)
        {
            n = l;
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        for(auto i = 0; i < n - 1; i++)
        {
            auto [gocpp_id_1, size] = utf8::DecodeRuneInString(s);
            a[i] = s.make_slice(0, size);
            s = s.make_slice(size);
        }
        if(n > 0)
        {
            a[n - 1] = s;
        }
        return a;
    }

    int Count(std::string s, std::string substr)
    {
        if(len(substr) == 0)
        {
            return utf8::RuneCountInString(s) + 1;
        }
        if(len(substr) == 1)
        {
            return bytealg::CountString(s, substr[0]);
        }
        auto n = 0;
        for(; ; )
        {
            auto i = Index(s, substr);
            if(i == - 1)
            {
                return n;
            }
            n++;
            s = s.make_slice(i + len(substr));
        }
    }

    bool Contains(std::string s, std::string substr)
    {
        return Index(s, substr) >= 0;
    }

    bool ContainsAny(std::string s, std::string chars)
    {
        return IndexAny(s, chars) >= 0;
    }

    bool ContainsRune(std::string s, gocpp::rune r)
    {
        return IndexRune(s, r) >= 0;
    }

    bool ContainsFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        return IndexFunc(s, f) >= 0;
    }

    int LastIndex(std::string s, std::string substr)
    {
        auto n = len(substr);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return len(s);
                    break;
                case 1:
                    return bytealg::LastIndexByteString(s, substr[0]);
                    break;
                case 2:
                    if(substr == s)
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
            }
        }
        auto [hashss, pow] = bytealg::HashStrRev(substr);
        auto last = len(s) - n;
        uint32_t h = {};
        for(auto i = len(s) - 1; i >= last; i--)
        {
            h = h * bytealg::PrimeRK + uint32_t(s[i]);
        }
        if(h == hashss && s.make_slice(last) == substr)
        {
            return last;
        }
        for(auto i = last - 1; i >= 0; i--)
        {
            h *= bytealg::PrimeRK;
            h += uint32_t(s[i]);
            h -= pow * uint32_t(s[i + n]);
            if(h == hashss && s.make_slice(i, i + n) == substr)
            {
                return i;
            }
        }
        return - 1;
    }

    int IndexByte(std::string s, unsigned char c)
    {
        return bytealg::IndexByteString(s, c);
    }

    int IndexRune(std::string s, gocpp::rune r)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(0 <= r && r < utf8::RuneSelf) { conditionId = 0; }
            else if(r == utf8::RuneError) { conditionId = 1; }
            else if(! utf8::ValidRune(r)) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return IndexByte(s, unsigned char(r));
                    break;
                case 1:
                    for(auto [i, r] : s)
                    {
                        if(r == utf8::RuneError)
                        {
                            return i;
                        }
                    }
                    return - 1;
                    break;
                case 2:
                    return - 1;
                    break;
                default:
                    return Index(s, string(r));
                    break;
            }
        }
    }

    int IndexAny(std::string s, std::string chars)
    {
        if(chars == "")
        {
            return - 1;
        }
        if(len(chars) == 1)
        {
            auto r = rune(chars[0]);
            if(r >= utf8::RuneSelf)
            {
                r = utf8::RuneError;
            }
            return IndexRune(s, r);
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto i = 0; i < len(s); i++)
                {
                    if(rec::contains(gocpp::recv(as), s[i]))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        for(auto [i, c] : s)
        {
            if(IndexRune(chars, c) >= 0)
            {
                return i;
            }
        }
        return - 1;
    }

    int LastIndexAny(std::string s, std::string chars)
    {
        if(chars == "")
        {
            return - 1;
        }
        if(len(s) == 1)
        {
            auto rc = rune(s[0]);
            if(rc >= utf8::RuneSelf)
            {
                rc = utf8::RuneError;
            }
            if(IndexRune(chars, rc) >= 0)
            {
                return 0;
            }
            return - 1;
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto i = len(s) - 1; i >= 0; i--)
                {
                    if(rec::contains(gocpp::recv(as), s[i]))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        if(len(chars) == 1)
        {
            auto rc = rune(chars[0]);
            if(rc >= utf8::RuneSelf)
            {
                rc = utf8::RuneError;
            }
            for(auto i = len(s); i > 0; )
            {
                auto [r, size] = utf8::DecodeLastRuneInString(s.make_slice(0, i));
                i -= size;
                if(rc == r)
                {
                    return i;
                }
            }
            return - 1;
        }
        for(auto i = len(s); i > 0; )
        {
            auto [r, size] = utf8::DecodeLastRuneInString(s.make_slice(0, i));
            i -= size;
            if(IndexRune(chars, r) >= 0)
            {
                return i;
            }
        }
        return - 1;
    }

    int LastIndexByte(std::string s, unsigned char c)
    {
        return bytealg::LastIndexByteString(s, c);
    }

    gocpp::slice<std::string> genSplit(std::string s, std::string sep, int sepSave, int n)
    {
        if(n == 0)
        {
            return nullptr;
        }
        if(sep == "")
        {
            return explode(s, n);
        }
        if(n < 0)
        {
            n = Count(s, sep) + 1;
        }
        if(n > len(s) + 1)
        {
            n = len(s) + 1;
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        n--;
        auto i = 0;
        for(; i < n; )
        {
            auto m = Index(s, sep);
            if(m < 0)
            {
                break;
            }
            a[i] = s.make_slice(0, m + sepSave);
            s = s.make_slice(m + len(sep));
            i++;
        }
        a[i] = s;
        return a.make_slice(0, i + 1);
    }

    gocpp::slice<std::string> SplitN(std::string s, std::string sep, int n)
    {
        return genSplit(s, sep, 0, n);
    }

    gocpp::slice<std::string> SplitAfterN(std::string s, std::string sep, int n)
    {
        return genSplit(s, sep, len(sep), n);
    }

    gocpp::slice<std::string> Split(std::string s, std::string sep)
    {
        return genSplit(s, sep, 0, - 1);
    }

    gocpp::slice<std::string> SplitAfter(std::string s, std::string sep)
    {
        return genSplit(s, sep, len(sep), - 1);
    }

    gocpp::array<uint8_t, 256> asciiSpace = gocpp::Init<gocpp::array<uint8_t, 256>>([](auto& x) {
        x['\t'] = 1;
        x['\n'] = 1;
        x['\v'] = 1;
        x['\f'] = 1;
        x['\r'] = 1;
        x[' '] = 1;
    });
    gocpp::slice<std::string> Fields(std::string s)
    {
        auto n = 0;
        auto wasSpace = 1;
        auto setBits = uint8_t(0);
        for(auto i = 0; i < len(s); i++)
        {
            auto r = s[i];
            setBits |= r;
            auto isSpace = int(asciiSpace[r]);
            n += wasSpace & ~ isSpace;
            wasSpace = isSpace;
        }
        if(setBits >= utf8::RuneSelf)
        {
            return FieldsFunc(s, unicode::IsSpace);
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        auto na = 0;
        auto fieldStart = 0;
        auto i = 0;
        for(; i < len(s) && asciiSpace[s[i]] != 0; )
        {
            i++;
        }
        fieldStart = i;
        for(; i < len(s); )
        {
            if(asciiSpace[s[i]] == 0)
            {
                i++;
                continue;
            }
            a[na] = s.make_slice(fieldStart, i);
            na++;
            i++;
            for(; i < len(s) && asciiSpace[s[i]] != 0; )
            {
                i++;
            }
            fieldStart = i;
        }
        if(fieldStart < len(s))
        {
            a[na] = s.make_slice(fieldStart);
        }
        return a;
    }

    gocpp::slice<std::string> FieldsFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        
        template<typename T> requires gocpp::GoStruct<T>
        span::operator T()
        {
            T result;
            result.start = this->start;
            result.end = this->end;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool span::operator==(const T& ref) const
        {
            if (start != ref.start) return false;
            if (end != ref.end) return false;
            return true;
        }

        std::ostream& span::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << start;
            os << " " << end;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct span& value)
        {
            return value.PrintTo(os);
        }

        auto spans = gocpp::make(gocpp::Tag<gocpp::slice<span>>(), 0, 32);
        auto start = - 1;
        for(auto [end, rune] : s)
        {
            if(f(rune))
            {
                if(start >= 0)
                {
                    spans = append(spans, span {start, end});
                    start = ~ start;
                }
            }
            else
            {
                if(start < 0)
                {
                    start = end;
                }
            }
        }
        if(start >= 0)
        {
            spans = append(spans, span {start, len(s)});
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), len(spans));
        for(auto [i, span] : spans)
        {
            a[i] = s.make_slice(span.start, span.end);
        }
        return a;
    }

    std::string Join(gocpp::slice<std::string> elems, std::string sep)
    {
        //Go switch emulation
        {
            auto condition = len(elems);
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return "";
                    break;
                case 1:
                    return elems[0];
                    break;
            }
        }
        int n = {};
        if(len(sep) > 0)
        {
            if(len(sep) >= maxInt / (len(elems) - 1))
            {
                gocpp::panic("strings: Join output length overflow");
            }
            n += len(sep) * (len(elems) - 1);
        }
        for(auto [gocpp_ignored, elem] : elems)
        {
            if(len(elem) > maxInt - n)
            {
                gocpp::panic("strings: Join output length overflow");
            }
            n += len(elem);
        }
        Builder b = {};
        rec::Grow(gocpp::recv(b), n);
        rec::WriteString(gocpp::recv(b), elems[0]);
        for(auto [gocpp_ignored, s] : elems.make_slice(1))
        {
            rec::WriteString(gocpp::recv(b), sep);
            rec::WriteString(gocpp::recv(b), s);
        }
        return rec::String(gocpp::recv(b));
    }

    bool HasPrefix(std::string s, std::string prefix)
    {
        return len(s) >= len(prefix) && s.make_slice(0, len(prefix)) == prefix;
    }

    bool HasSuffix(std::string s, std::string suffix)
    {
        return len(s) >= len(suffix) && s.make_slice(len(s) - len(suffix)) == suffix;
    }

    std::string Map(std::function<gocpp::rune (gocpp::rune)> mapping, std::string s)
    {
        Builder b = {};
        for(auto [i, c] : s)
        {
            auto r = mapping(c);
            if(r == c && c != utf8::RuneError)
            {
                continue;
            }
            int width = {};
            if(c == utf8::RuneError)
            {
                std::tie(c, width) = utf8::DecodeRuneInString(s.make_slice(i));
                if(width != 1 && r == c)
                {
                    continue;
                }
            }
            else
            {
                width = utf8::RuneLen(c);
            }
            rec::Grow(gocpp::recv(b), len(s) + utf8::UTFMax);
            rec::WriteString(gocpp::recv(b), s.make_slice(0, i));
            if(r >= 0)
            {
                rec::WriteRune(gocpp::recv(b), r);
            }
            s = s.make_slice(i + width);
            break;
        }
        if(rec::Cap(gocpp::recv(b)) == 0)
        {
            return s;
        }
        for(auto [gocpp_ignored, c] : s)
        {
            auto r = mapping(c);
            if(r >= 0)
            {
                if(r < utf8::RuneSelf)
                {
                    rec::WriteByte(gocpp::recv(b), unsigned char(r));
                }
                else
                {
                    rec::WriteRune(gocpp::recv(b), r);
                }
            }
        }
        return rec::String(gocpp::recv(b));
    }

    std::string Repeat(std::string s, int count)
    {
        //Go switch emulation
        {
            auto condition = count;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return "";
                    break;
                case 1:
                    return s;
                    break;
            }
        }
        if(count < 0)
        {
            gocpp::panic("strings: negative Repeat count");
        }
        if(len(s) >= maxInt / count)
        {
            gocpp::panic("strings: Repeat output length overflow");
        }
        auto n = len(s) * count;
        if(len(s) == 0)
        {
            return "";
        }
        auto chunkLimit = 8 * 1024;
        auto chunkMax = n;
        if(n > chunkLimit)
        {
            chunkMax = chunkLimit / len(s) * len(s);
            if(chunkMax == 0)
            {
                chunkMax = len(s);
            }
        }
        Builder b = {};
        rec::Grow(gocpp::recv(b), n);
        rec::WriteString(gocpp::recv(b), s);
        for(; rec::Len(gocpp::recv(b)) < n; )
        {
            auto chunk = n - rec::Len(gocpp::recv(b));
            if(chunk > rec::Len(gocpp::recv(b)))
            {
                chunk = rec::Len(gocpp::recv(b));
            }
            if(chunk > chunkMax)
            {
                chunk = chunkMax;
            }
            rec::WriteString(gocpp::recv(b), rec::String(gocpp::recv(b)).make_slice(0, chunk));
        }
        return rec::String(gocpp::recv(b));
    }

    std::string ToUpper(std::string s)
    {
        auto [isASCII, hasLower] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasLower = hasLower || ('a' <= c && c <= 'z');
        }
        if(isASCII)
        {
            if(! hasLower)
            {
                return s;
            }
            Builder b = {};
            int pos = {};
            rec::Grow(gocpp::recv(b), len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('a' <= c && c <= 'z')
                {
                    c -= 'a' - 'A';
                    if(pos < i)
                    {
                        rec::WriteString(gocpp::recv(b), s.make_slice(pos, i));
                    }
                    rec::WriteByte(gocpp::recv(b), c);
                    pos = i + 1;
                }
            }
            if(pos < len(s))
            {
                rec::WriteString(gocpp::recv(b), s.make_slice(pos));
            }
            return rec::String(gocpp::recv(b));
        }
        return Map(unicode::ToUpper, s);
    }

    std::string ToLower(std::string s)
    {
        auto [isASCII, hasUpper] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasUpper = hasUpper || ('A' <= c && c <= 'Z');
        }
        if(isASCII)
        {
            if(! hasUpper)
            {
                return s;
            }
            Builder b = {};
            int pos = {};
            rec::Grow(gocpp::recv(b), len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('A' <= c && c <= 'Z')
                {
                    c += 'a' - 'A';
                    if(pos < i)
                    {
                        rec::WriteString(gocpp::recv(b), s.make_slice(pos, i));
                    }
                    rec::WriteByte(gocpp::recv(b), c);
                    pos = i + 1;
                }
            }
            if(pos < len(s))
            {
                rec::WriteString(gocpp::recv(b), s.make_slice(pos));
            }
            return rec::String(gocpp::recv(b));
        }
        return Map(unicode::ToLower, s);
    }

    std::string ToTitle(std::string s)
    {
        return Map(unicode::ToTitle, s);
    }

    std::string ToUpperSpecial(unicode::SpecialCase c, std::string s)
    {
        return Map(c->ToUpper, s);
    }

    std::string ToLowerSpecial(unicode::SpecialCase c, std::string s)
    {
        return Map(c->ToLower, s);
    }

    std::string ToTitleSpecial(unicode::SpecialCase c, std::string s)
    {
        return Map(c->ToTitle, s);
    }

    std::string ToValidUTF8(std::string s, std::string replacement)
    {
        Builder b = {};
        for(auto [i, c] : s)
        {
            if(c != utf8::RuneError)
            {
                continue;
            }
            auto [gocpp_id_3, wid] = utf8::DecodeRuneInString(s.make_slice(i));
            if(wid == 1)
            {
                rec::Grow(gocpp::recv(b), len(s) + len(replacement));
                rec::WriteString(gocpp::recv(b), s.make_slice(0, i));
                s = s.make_slice(i);
                break;
            }
        }
        if(rec::Cap(gocpp::recv(b)) == 0)
        {
            return s;
        }
        auto invalid = false;
        for(auto i = 0; i < len(s); )
        {
            auto c = s[i];
            if(c < utf8::RuneSelf)
            {
                i++;
                invalid = false;
                rec::WriteByte(gocpp::recv(b), c);
                continue;
            }
            auto [gocpp_id_5, wid] = utf8::DecodeRuneInString(s.make_slice(i));
            if(wid == 1)
            {
                i++;
                if(! invalid)
                {
                    invalid = true;
                    rec::WriteString(gocpp::recv(b), replacement);
                }
                continue;
            }
            invalid = false;
            rec::WriteString(gocpp::recv(b), s.make_slice(i, i + wid));
            i += wid;
        }
        return rec::String(gocpp::recv(b));
    }

    bool isSeparator(gocpp::rune r)
    {
        if(r <= 0x7F)
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if('0' <= r && r <= '9') { conditionId = 0; }
                else if('a' <= r && r <= 'z') { conditionId = 1; }
                else if('A' <= r && r <= 'Z') { conditionId = 2; }
                else if(r == '_') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        return false;
                        break;
                    case 1:
                        return false;
                        break;
                    case 2:
                        return false;
                        break;
                    case 3:
                        return false;
                        break;
                }
            }
            return true;
        }
        if(unicode::IsLetter(r) || unicode::IsDigit(r))
        {
            return false;
        }
        return unicode::IsSpace(r);
    }

    std::string Title(std::string s)
    {
        auto prev = ' ';
        return Map([=](gocpp::rune r) mutable -> gocpp::rune
        {
            if(isSeparator(prev))
            {
                prev = r;
                return unicode::ToTitle(r);
            }
            prev = r;
            return r;
        }, s);
    }

    std::string TrimLeftFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        auto i = indexFunc(s, f, false);
        if(i == - 1)
        {
            return "";
        }
        return s.make_slice(i);
    }

    std::string TrimRightFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        auto i = lastIndexFunc(s, f, false);
        if(i >= 0 && s[i] >= utf8::RuneSelf)
        {
            auto [gocpp_id_7, wid] = utf8::DecodeRuneInString(s.make_slice(i));
            i += wid;
        }
        else
        {
            i++;
        }
        return s.make_slice(0, i);
    }

    std::string TrimFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        return TrimRightFunc(TrimLeftFunc(s, f), f);
    }

    int IndexFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        return indexFunc(s, f, true);
    }

    int LastIndexFunc(std::string s, std::function<bool (gocpp::rune)> f)
    {
        return lastIndexFunc(s, f, true);
    }

    int indexFunc(std::string s, std::function<bool (gocpp::rune)> f, bool truth)
    {
        for(auto [i, r] : s)
        {
            if(f(r) == truth)
            {
                return i;
            }
        }
        return - 1;
    }

    int lastIndexFunc(std::string s, std::function<bool (gocpp::rune)> f, bool truth)
    {
        for(auto i = len(s); i > 0; )
        {
            auto [r, size] = utf8::DecodeLastRuneInString(s.make_slice(0, i));
            i -= size;
            if(f(r) == truth)
            {
                return i;
            }
        }
        return - 1;
    }

    std::tuple<strings::asciiSet, bool> makeASCIISet(std::string chars)
    {
        strings::asciiSet as;
        bool ok;
        for(auto i = 0; i < len(chars); i++)
        {
            strings::asciiSet as;
            bool ok;
            auto c = chars[i];
            if(c >= utf8::RuneSelf)
            {
                strings::asciiSet as;
                bool ok;
                return {as, false};
            }
            as[c / 32] |= 1 << (c % 32);
        }
        return {as, true};
    }

    bool rec::contains(golang::strings::asciiSet* as, unsigned char c)
    {
        return (as[c / 32] & (1 << (c % 32))) != 0;
    }

    std::string Trim(std::string s, std::string cutset)
    {
        if(s == "" || cutset == "")
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(trimRightByte(s, cutset[0]), cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(trimRightASCII(s, & as), & as);
        }
        return trimLeftUnicode(trimRightUnicode(s, cutset), cutset);
    }

    std::string TrimLeft(std::string s, std::string cutset)
    {
        if(s == "" || cutset == "")
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(s, & as);
        }
        return trimLeftUnicode(s, cutset);
    }

    std::string trimLeftByte(std::string s, unsigned char c)
    {
        for(; len(s) > 0 && s[0] == c; )
        {
            s = s.make_slice(1);
        }
        return s;
    }

    std::string trimLeftASCII(std::string s, golang::strings::asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[0]))
            {
                break;
            }
            s = s.make_slice(1);
        }
        return s;
    }

    std::string trimLeftUnicode(std::string s, std::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{rune(s[0]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeRuneInString(s);
            }
            if(! ContainsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(n);
        }
        return s;
    }

    std::string TrimRight(std::string s, std::string cutset)
    {
        if(s == "" || cutset == "")
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimRightByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimRightASCII(s, & as);
        }
        return trimRightUnicode(s, cutset);
    }

    std::string trimRightByte(std::string s, unsigned char c)
    {
        for(; len(s) > 0 && s[len(s) - 1] == c; )
        {
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    std::string trimRightASCII(std::string s, golang::strings::asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[len(s) - 1]))
            {
                break;
            }
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    std::string trimRightUnicode(std::string s, std::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{rune(s[len(s) - 1]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeLastRuneInString(s);
            }
            if(! ContainsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(0, len(s) - n);
        }
        return s;
    }

    std::string TrimSpace(std::string s)
    {
        auto start = 0;
        for(; start < len(s); start++)
        {
            auto c = s[start];
            if(c >= utf8::RuneSelf)
            {
                return TrimFunc(s.make_slice(start), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        auto stop = len(s);
        for(; stop > start; stop--)
        {
            auto c = s[stop - 1];
            if(c >= utf8::RuneSelf)
            {
                return TrimRightFunc(s.make_slice(start, stop), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        return s.make_slice(start, stop);
    }

    std::string TrimPrefix(std::string s, std::string prefix)
    {
        if(HasPrefix(s, prefix))
        {
            return s.make_slice(len(prefix));
        }
        return s;
    }

    std::string TrimSuffix(std::string s, std::string suffix)
    {
        if(HasSuffix(s, suffix))
        {
            return s.make_slice(0, len(s) - len(suffix));
        }
        return s;
    }

    std::string Replace(std::string s, std::string old, std::string go_new, int n)
    {
        if(old == go_new || n == 0)
        {
            return s;
        }
        if(auto m = Count(s, old); m == 0)
        {
            return s;
        }
        else
        if(n < 0 || m < n)
        {
            n = m;
        }
        Builder b = {};
        rec::Grow(gocpp::recv(b), len(s) + n * (len(go_new) - len(old)));
        auto start = 0;
        for(auto i = 0; i < n; i++)
        {
            auto j = start;
            if(len(old) == 0)
            {
                if(i > 0)
                {
                    auto [gocpp_id_9, wid] = utf8::DecodeRuneInString(s.make_slice(start));
                    j += wid;
                }
            }
            else
            {
                j += Index(s.make_slice(start), old);
            }
            rec::WriteString(gocpp::recv(b), s.make_slice(start, j));
            rec::WriteString(gocpp::recv(b), go_new);
            start = j + len(old);
        }
        rec::WriteString(gocpp::recv(b), s.make_slice(start));
        return rec::String(gocpp::recv(b));
    }

    std::string ReplaceAll(std::string s, std::string old, std::string go_new)
    {
        return Replace(s, old, go_new, - 1);
    }

    bool EqualFold(std::string s, std::string t)
    {
        auto i = 0;
        for(; i < len(s) && i < len(t); i++)
        {
            auto sr = s[i];
            auto tr = t[i];
            if(sr | tr >= utf8::RuneSelf)
            {
                goto hasUnicode;
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
            {
                continue;
            }
            return false;
        }
        return len(s) == len(t);
        hasUnicode:
        s = s.make_slice(i);
        t = t.make_slice(i);
        for(auto [gocpp_ignored, sr] : s)
        {
            if(len(t) == 0)
            {
                return false;
            }
            gocpp::rune tr = {};
            if(t[0] < utf8::RuneSelf)
            {
                std::tie(tr, t) = std::tuple{rune(t[0]), t.make_slice(1)};
            }
            else
            {
                auto [r, size] = utf8::DecodeRuneInString(t);
                std::tie(tr, t) = std::tuple{r, t.make_slice(size)};
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if(tr < utf8::RuneSelf)
            {
                if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
                {
                    continue;
                }
                return false;
            }
            auto r = unicode::SimpleFold(sr);
            for(; r != sr && r < tr; )
            {
                r = unicode::SimpleFold(r);
            }
            if(r == tr)
            {
                continue;
            }
            return false;
        }
        return len(t) == 0;
    }

    int Index(std::string s, std::string substr)
    {
        auto n = len(substr);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            else if(n <= bytealg::MaxLen) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    return 0;
                    break;
                case 1:
                    return IndexByte(s, substr[0]);
                    break;
                case 2:
                    if(substr == s)
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
                case 4:
                    if(len(s) <= bytealg::MaxBruteForce)
                    {
                        return bytealg::IndexString(s, substr);
                    }
                    auto c0 = substr[0];
                    auto c1 = substr[1];
                    auto i = 0;
                    auto t = len(s) - n + 1;
                    auto fails = 0;
                    for(; i < t; )
                    {
                        if(s[i] != c0)
                        {
                            auto o = IndexByte(s.make_slice(i + 1, t), c0);
                            if(o < 0)
                            {
                                return - 1;
                            }
                            i += o + 1;
                        }
                        if(s[i + 1] == c1 && s.make_slice(i, i + n) == substr)
                        {
                            return i;
                        }
                        fails++;
                        i++;
                        if(fails > bytealg::Cutover(i))
                        {
                            auto r = bytealg::IndexString(s.make_slice(i), substr);
                            if(r >= 0)
                            {
                                return r + i;
                            }
                            return - 1;
                        }
                    }
                    return - 1;
                    break;
            }
        }
        auto c0 = substr[0];
        auto c1 = substr[1];
        auto i = 0;
        auto t = len(s) - n + 1;
        auto fails = 0;
        for(; i < t; )
        {
            if(s[i] != c0)
            {
                auto o = IndexByte(s.make_slice(i + 1, t), c0);
                if(o < 0)
                {
                    return - 1;
                }
                i += o + 1;
            }
            if(s[i + 1] == c1 && s.make_slice(i, i + n) == substr)
            {
                return i;
            }
            i++;
            fails++;
            if(fails >= 4 + (i >> 4) && i < t)
            {
                auto j = bytealg::IndexRabinKarp(s.make_slice(i), substr);
                if(j < 0)
                {
                    return - 1;
                }
                return i + j;
            }
        }
        return - 1;
    }

    std::tuple<std::string, std::string, bool> Cut(std::string s, std::string sep)
    {
        std::string before;
        std::string after;
        bool found;
        if(auto i = Index(s, sep); i >= 0)
        {
            std::string before;
            std::string after;
            bool found;
            return {s.make_slice(0, i), s.make_slice(i + len(sep)), true};
        }
        return {s, "", false};
    }

    std::tuple<std::string, bool> CutPrefix(std::string s, std::string prefix)
    {
        std::string after;
        bool found;
        if(! HasPrefix(s, prefix))
        {
            std::string after;
            bool found;
            return {s, false};
        }
        return {s.make_slice(len(prefix)), true};
    }

    std::tuple<std::string, bool> CutSuffix(std::string s, std::string suffix)
    {
        std::string before;
        bool found;
        if(! HasSuffix(s, suffix))
        {
            std::string before;
            bool found;
            return {s, false};
        }
        return {s.make_slice(0, len(s) - len(suffix)), true};
    }

}

