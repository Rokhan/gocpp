// generated by GoCpp from file '$(ImportDir)/runtime/lfstack.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/lfstack.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/print.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/tagptr.h"
#include "golang/runtime/tagptr_64bit.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // lfstack is the head of a lock-free stack.
    //
    // The zero value of lfstack is an empty list.
    //
    // This stack is intrusive. Nodes must embed lfnode as the first field.
    //
    // The stack does not keep GC-visible pointers to nodes, so the caller
    // must ensure the nodes are allocated outside the Go heap.
    void rec::push(golang::runtime::lfstack* head, struct lfnode* node)
    {
        node->pushcnt++;
        auto go_new = lfstackPack(node, node->pushcnt);
        if(auto node1 = lfstackUnpack(go_new); node1 != node)
        {
            print("runtime: lfstack.push invalid packing: node="_s, node, " cnt="_s, hex(node->pushcnt), " packed="_s, hex(go_new), " -> node="_s, node1, "\n"_s);
            go_throw("lfstack.push"_s);
        }
        for(; ; )
        {
            auto old = atomic::Load64((uint64_t*)(head));
            node->next = old;
            if(atomic::Cas64((uint64_t*)(head), old, go_new))
            {
                break;
            }
        }
    }

    gocpp::unsafe_pointer rec::pop(golang::runtime::lfstack* head)
    {
        for(; ; )
        {
            auto old = atomic::Load64((uint64_t*)(head));
            if(old == 0)
            {
                return nullptr;
            }
            auto node = lfstackUnpack(old);
            auto next = atomic::Load64(& node->next);
            if(atomic::Cas64((uint64_t*)(head), old, next))
            {
                return gocpp::unsafe_pointer(node);
            }
        }
    }

    bool rec::empty(golang::runtime::lfstack* head)
    {
        return atomic::Load64((uint64_t*)(head)) == 0;
    }

    // lfnodeValidate panics if node is not a valid address for use with
    // lfstack.push. This only needs to be called when node is allocated.
    void lfnodeValidate(struct lfnode* node)
    {
        if(auto [base, gocpp_id_0, gocpp_id_1] = findObject(uintptr_t(gocpp::unsafe_pointer(node)), 0, 0); base != 0)
        {
            go_throw("lfstack node allocated from the heap"_s);
        }
        if(lfstackUnpack(lfstackPack(node, ~ uintptr_t(0))) != node)
        {
            printlock();
            println("runtime: bad lfnode address"_s, hex(uintptr_t(gocpp::unsafe_pointer(node))));
            go_throw("bad lfnode address"_s);
        }
    }

    uint64_t lfstackPack(struct lfnode* node, uintptr_t cnt)
    {
        return uint64_t(taggedPointerPack(gocpp::unsafe_pointer(node), cnt));
    }

    struct lfnode* lfstackUnpack(uint64_t val)
    {
        return (lfnode*)(rec::pointer(gocpp::recv(taggedPointer(val))));
    }

}

