// generated by GoCpp from file '$(ImportDir)/io/io.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/io/io.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/pool.h"

namespace golang::io
{
    std::string ErrShortWrite = errors::New("short write");
    std::string errInvalidWrite = errors::New("invalid write result");
    std::string ErrShortBuffer = errors::New("short buffer");
    std::string go_EOF = errors::New("EOF");
    std::string ErrUnexpectedEOF = errors::New("unexpected EOF");
    std::string ErrNoProgress = errors::New("multiple Read calls return no data or error");
    
    template<typename T>
    Reader::Reader(T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(const T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(T* ptr)
    {
        value.reset(new ReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, std::string> Reader::ReaderImpl<T, StoreT>::vRead(gocpp::slice<unsigned char> p)
    {
        return Read(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int, std::string> Read(const gocpp::PtrRecv<Reader, false>& self, gocpp::slice<unsigned char> p)
    {
        return self.ptr->value->vRead(gocpp::slice<unsigned char> p);
    }

    std::tuple<int, std::string> Read(const gocpp::ObjRecv<Reader>& self, gocpp::slice<unsigned char> p)
    {
        return self.obj.value->vRead(gocpp::slice<unsigned char> p);
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Writer::Writer(T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(const T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(T* ptr)
    {
        value.reset(new WriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, std::string> Writer::WriterImpl<T, StoreT>::vWrite(gocpp::slice<unsigned char> p)
    {
        return Write(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int, std::string> Write(const gocpp::PtrRecv<Writer, false>& self, gocpp::slice<unsigned char> p)
    {
        return self.ptr->value->vWrite(gocpp::slice<unsigned char> p);
    }

    std::tuple<int, std::string> Write(const gocpp::ObjRecv<Writer>& self, gocpp::slice<unsigned char> p)
    {
        return self.obj.value->vWrite(gocpp::slice<unsigned char> p);
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Closer::Closer(T& ref)
    {
        value.reset(new CloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Closer::Closer(const T& ref)
    {
        value.reset(new CloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Closer::Closer(T* ptr)
    {
        value.reset(new CloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Closer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string Closer::CloserImpl<T, StoreT>::vClose()
    {
        return Close(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::string Close(const gocpp::PtrRecv<Closer, false>& self)
    {
        return self.ptr->value->vClose();
    }

    std::string Close(const gocpp::ObjRecv<Closer>& self)
    {
        return self.obj.value->vClose();
    }

    std::ostream& operator<<(std::ostream& os, const struct Closer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Seeker::Seeker(T& ref)
    {
        value.reset(new SeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Seeker::Seeker(const T& ref)
    {
        value.reset(new SeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Seeker::Seeker(T* ptr)
    {
        value.reset(new SeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Seeker::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, std::string> Seeker::SeekerImpl<T, StoreT>::vSeek(int64_t offset, int whence)
    {
        return Seek(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int64_t, std::string> Seek(const gocpp::PtrRecv<Seeker, false>& self, int64_t offset, int whence)
    {
        return self.ptr->value->vSeek(int64_t offset, int whence);
    }

    std::tuple<int64_t, std::string> Seek(const gocpp::ObjRecv<Seeker>& self, int64_t offset, int whence)
    {
        return self.obj.value->vSeek(int64_t offset, int whence);
    }

    std::ostream& operator<<(std::ostream& os, const struct Seeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadWriter::ReadWriter(T& ref)
    {
        value.reset(new ReadWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriter::ReadWriter(const T& ref)
    {
        value.reset(new ReadWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriter::ReadWriter(T* ptr)
    {
        value.reset(new ReadWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct ReadWriter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadCloser::ReadCloser(T& ref)
    {
        value.reset(new ReadCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadCloser::ReadCloser(const T& ref)
    {
        value.reset(new ReadCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadCloser::ReadCloser(T* ptr)
    {
        value.reset(new ReadCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct ReadCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriteCloser::WriteCloser(T& ref)
    {
        value.reset(new WriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteCloser::WriteCloser(const T& ref)
    {
        value.reset(new WriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteCloser::WriteCloser(T* ptr)
    {
        value.reset(new WriteCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriteCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct WriteCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadWriteCloser::ReadWriteCloser(T& ref)
    {
        value.reset(new ReadWriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteCloser::ReadWriteCloser(const T& ref)
    {
        value.reset(new ReadWriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteCloser::ReadWriteCloser(T* ptr)
    {
        value.reset(new ReadWriteCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriteCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct ReadWriteCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadSeeker::ReadSeeker(T& ref)
    {
        value.reset(new ReadSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeeker::ReadSeeker(const T& ref)
    {
        value.reset(new ReadSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeeker::ReadSeeker(T* ptr)
    {
        value.reset(new ReadSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct ReadSeeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadSeekCloser::ReadSeekCloser(T& ref)
    {
        value.reset(new ReadSeekCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeekCloser::ReadSeekCloser(const T& ref)
    {
        value.reset(new ReadSeekCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeekCloser::ReadSeekCloser(T* ptr)
    {
        value.reset(new ReadSeekCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadSeekCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct ReadSeekCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriteSeeker::WriteSeeker(T& ref)
    {
        value.reset(new WriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteSeeker::WriteSeeker(const T& ref)
    {
        value.reset(new WriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteSeeker::WriteSeeker(T* ptr)
    {
        value.reset(new WriteSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriteSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct WriteSeeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(T& ref)
    {
        value.reset(new ReadWriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(const T& ref)
    {
        value.reset(new ReadWriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(T* ptr)
    {
        value.reset(new ReadWriteSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriteSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct ReadWriteSeeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReaderFrom::ReaderFrom(T& ref)
    {
        value.reset(new ReaderFromImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderFrom::ReaderFrom(const T& ref)
    {
        value.reset(new ReaderFromImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderFrom::ReaderFrom(T* ptr)
    {
        value.reset(new ReaderFromImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReaderFrom::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, std::string> ReaderFrom::ReaderFromImpl<T, StoreT>::vReadFrom(Reader r)
    {
        return ReadFrom(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int64_t, std::string> ReadFrom(const gocpp::PtrRecv<ReaderFrom, false>& self, Reader r)
    {
        return self.ptr->value->vReadFrom(Reader r);
    }

    std::tuple<int64_t, std::string> ReadFrom(const gocpp::ObjRecv<ReaderFrom>& self, Reader r)
    {
        return self.obj.value->vReadFrom(Reader r);
    }

    std::ostream& operator<<(std::ostream& os, const struct ReaderFrom& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriterTo::WriterTo(T& ref)
    {
        value.reset(new WriterToImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterTo::WriterTo(const T& ref)
    {
        value.reset(new WriterToImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterTo::WriterTo(T* ptr)
    {
        value.reset(new WriterToImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriterTo::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, std::string> WriterTo::WriterToImpl<T, StoreT>::vWriteTo(Writer w)
    {
        return WriteTo(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int64_t, std::string> WriteTo(const gocpp::PtrRecv<WriterTo, false>& self, Writer w)
    {
        return self.ptr->value->vWriteTo(Writer w);
    }

    std::tuple<int64_t, std::string> WriteTo(const gocpp::ObjRecv<WriterTo>& self, Writer w)
    {
        return self.obj.value->vWriteTo(Writer w);
    }

    std::ostream& operator<<(std::ostream& os, const struct WriterTo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReaderAt::ReaderAt(T& ref)
    {
        value.reset(new ReaderAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderAt::ReaderAt(const T& ref)
    {
        value.reset(new ReaderAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderAt::ReaderAt(T* ptr)
    {
        value.reset(new ReaderAtImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReaderAt::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, std::string> ReaderAt::ReaderAtImpl<T, StoreT>::vReadAt(gocpp::slice<unsigned char> p, int64_t off)
    {
        return ReadAt(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int, std::string> ReadAt(const gocpp::PtrRecv<ReaderAt, false>& self, gocpp::slice<unsigned char> p, int64_t off)
    {
        return self.ptr->value->vReadAt(gocpp::slice<unsigned char> p, int64_t off);
    }

    std::tuple<int, std::string> ReadAt(const gocpp::ObjRecv<ReaderAt>& self, gocpp::slice<unsigned char> p, int64_t off)
    {
        return self.obj.value->vReadAt(gocpp::slice<unsigned char> p, int64_t off);
    }

    std::ostream& operator<<(std::ostream& os, const struct ReaderAt& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriterAt::WriterAt(T& ref)
    {
        value.reset(new WriterAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterAt::WriterAt(const T& ref)
    {
        value.reset(new WriterAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterAt::WriterAt(T* ptr)
    {
        value.reset(new WriterAtImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriterAt::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, std::string> WriterAt::WriterAtImpl<T, StoreT>::vWriteAt(gocpp::slice<unsigned char> p, int64_t off)
    {
        return WriteAt(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int, std::string> WriteAt(const gocpp::PtrRecv<WriterAt, false>& self, gocpp::slice<unsigned char> p, int64_t off)
    {
        return self.ptr->value->vWriteAt(gocpp::slice<unsigned char> p, int64_t off);
    }

    std::tuple<int, std::string> WriteAt(const gocpp::ObjRecv<WriterAt>& self, gocpp::slice<unsigned char> p, int64_t off)
    {
        return self.obj.value->vWriteAt(gocpp::slice<unsigned char> p, int64_t off);
    }

    std::ostream& operator<<(std::ostream& os, const struct WriterAt& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ByteReader::ByteReader(T& ref)
    {
        value.reset(new ByteReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteReader::ByteReader(const T& ref)
    {
        value.reset(new ByteReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteReader::ByteReader(T* ptr)
    {
        value.reset(new ByteReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteReader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<unsigned char, std::string> ByteReader::ByteReaderImpl<T, StoreT>::vReadByte()
    {
        return ReadByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<unsigned char, std::string> ReadByte(const gocpp::PtrRecv<ByteReader, false>& self)
    {
        return self.ptr->value->vReadByte();
    }

    std::tuple<unsigned char, std::string> ReadByte(const gocpp::ObjRecv<ByteReader>& self)
    {
        return self.obj.value->vReadByte();
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteReader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ByteScanner::ByteScanner(T& ref)
    {
        value.reset(new ByteScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteScanner::ByteScanner(const T& ref)
    {
        value.reset(new ByteScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteScanner::ByteScanner(T* ptr)
    {
        value.reset(new ByteScannerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteScanner::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string ByteScanner::ByteScannerImpl<T, StoreT>::vUnreadByte()
    {
        return UnreadByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::string UnreadByte(const gocpp::PtrRecv<ByteScanner, false>& self)
    {
        return self.ptr->value->vUnreadByte();
    }

    std::string UnreadByte(const gocpp::ObjRecv<ByteScanner>& self)
    {
        return self.obj.value->vUnreadByte();
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteScanner& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ByteWriter::ByteWriter(T& ref)
    {
        value.reset(new ByteWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteWriter::ByteWriter(const T& ref)
    {
        value.reset(new ByteWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteWriter::ByteWriter(T* ptr)
    {
        value.reset(new ByteWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string ByteWriter::ByteWriterImpl<T, StoreT>::vWriteByte(unsigned char c)
    {
        return WriteByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::string WriteByte(const gocpp::PtrRecv<ByteWriter, false>& self, unsigned char c)
    {
        return self.ptr->value->vWriteByte(unsigned char c);
    }

    std::string WriteByte(const gocpp::ObjRecv<ByteWriter>& self, unsigned char c)
    {
        return self.obj.value->vWriteByte(unsigned char c);
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteWriter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    RuneReader::RuneReader(T& ref)
    {
        value.reset(new RuneReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneReader::RuneReader(const T& ref)
    {
        value.reset(new RuneReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneReader::RuneReader(T* ptr)
    {
        value.reset(new RuneReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RuneReader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<gocpp::rune, int, std::string> RuneReader::RuneReaderImpl<T, StoreT>::vReadRune()
    {
        return ReadRune(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<gocpp::rune, int, std::string> ReadRune(const gocpp::PtrRecv<RuneReader, false>& self)
    {
        return self.ptr->value->vReadRune();
    }

    std::tuple<gocpp::rune, int, std::string> ReadRune(const gocpp::ObjRecv<RuneReader>& self)
    {
        return self.obj.value->vReadRune();
    }

    std::ostream& operator<<(std::ostream& os, const struct RuneReader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    RuneScanner::RuneScanner(T& ref)
    {
        value.reset(new RuneScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneScanner::RuneScanner(const T& ref)
    {
        value.reset(new RuneScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneScanner::RuneScanner(T* ptr)
    {
        value.reset(new RuneScannerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RuneScanner::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string RuneScanner::RuneScannerImpl<T, StoreT>::vUnreadRune()
    {
        return UnreadRune(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::string UnreadRune(const gocpp::PtrRecv<RuneScanner, false>& self)
    {
        return self.ptr->value->vUnreadRune();
    }

    std::string UnreadRune(const gocpp::ObjRecv<RuneScanner>& self)
    {
        return self.obj.value->vUnreadRune();
    }

    std::ostream& operator<<(std::ostream& os, const struct RuneScanner& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    StringWriter::StringWriter(T& ref)
    {
        value.reset(new StringWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    StringWriter::StringWriter(const T& ref)
    {
        value.reset(new StringWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    StringWriter::StringWriter(T* ptr)
    {
        value.reset(new StringWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& StringWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, std::string> StringWriter::StringWriterImpl<T, StoreT>::vWriteString(std::string s)
    {
        return WriteString(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int, std::string> WriteString(const gocpp::PtrRecv<StringWriter, false>& self, std::string s)
    {
        return self.ptr->value->vWriteString(std::string s);
    }

    std::tuple<int, std::string> WriteString(const gocpp::ObjRecv<StringWriter>& self, std::string s)
    {
        return self.obj.value->vWriteString(std::string s);
    }

    std::ostream& operator<<(std::ostream& os, const struct StringWriter& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> WriteString(Writer w, std::string s)
    {
        int n;
        std::string err;
        if(auto [sw, ok] = gocpp::getValue<StringWriter>(w); ok)
        {
            int n;
            std::string err;
            return WriteString(gocpp::recv(sw), s);
        }
        return Write(gocpp::recv(w), gocpp::Tag<gocpp::slice<unsigned char>>()(s));
    }

    std::tuple<int, std::string> ReadAtLeast(Reader r, gocpp::slice<unsigned char> buf, int min)
    {
        int n;
        std::string err;
        if(len(buf) < min)
        {
            int n;
            std::string err;
            return {0, ErrShortBuffer};
        }
        for(; n < min && err == nullptr; )
        {
            int n;
            std::string err;
            int nn = {};
            std::tie(nn, err) = Read(gocpp::recv(r), buf.make_slice(n));
            n += nn;
        }
        if(n >= min)
        {
            int n;
            std::string err;
            err = nullptr;
        }
        else
        if(n > 0 && err == go_EOF)
        {
            int n;
            std::string err;
            err = ErrUnexpectedEOF;
        }
        return {n, err};
    }

    std::tuple<int, std::string> ReadFull(Reader r, gocpp::slice<unsigned char> buf)
    {
        int n;
        std::string err;
        return ReadAtLeast(r, buf, len(buf));
    }

    std::tuple<int64_t, std::string> CopyN(Writer dst, Reader src, int64_t n)
    {
        int64_t written;
        std::string err;
        std::tie(written, err) = Copy(dst, LimitReader(src, n));
        if(written == n)
        {
            int64_t written;
            std::string err;
            return {n, nullptr};
        }
        if(written < n && err == nullptr)
        {
            int64_t written;
            std::string err;
            err = go_EOF;
        }
        return {written, err};
    }

    std::tuple<int64_t, std::string> Copy(Writer dst, Reader src)
    {
        int64_t written;
        std::string err;
        return copyBuffer(dst, src, nullptr);
    }

    std::tuple<int64_t, std::string> CopyBuffer(Writer dst, Reader src, gocpp::slice<unsigned char> buf)
    {
        int64_t written;
        std::string err;
        if(buf != nullptr && len(buf) == 0)
        {
            int64_t written;
            std::string err;
            gocpp::panic("empty buffer in CopyBuffer");
        }
        return copyBuffer(dst, src, buf);
    }

    std::tuple<int64_t, std::string> copyBuffer(Writer dst, Reader src, gocpp::slice<unsigned char> buf)
    {
        int64_t written;
        std::string err;
        if(auto [wt, ok] = gocpp::getValue<WriterTo>(src); ok)
        {
            int64_t written;
            std::string err;
            return WriteTo(gocpp::recv(wt), dst);
        }
        if(auto [rt, ok] = gocpp::getValue<ReaderFrom>(dst); ok)
        {
            int64_t written;
            std::string err;
            return ReadFrom(gocpp::recv(rt), src);
        }
        if(buf == nullptr)
        {
            int64_t written;
            std::string err;
            auto size = 32 * 1024;
            if(auto [l, ok] = gocpp::getValue<LimitedReader*>(src); ok && int64_t(size) > l->N)
            {
                int64_t written;
                std::string err;
                if(l->N < 1)
                {
                    int64_t written;
                    std::string err;
                    size = 1;
                }
                else
                {
                    int64_t written;
                    std::string err;
                    size = int(l->N);
                }
            }
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        }
        for(; ; )
        {
            int64_t written;
            std::string err;
            auto [nr, er] = Read(gocpp::recv(src), buf);
            if(nr > 0)
            {
                int64_t written;
                std::string err;
                auto [nw, ew] = Write(gocpp::recv(dst), buf.make_slice(0, nr));
                if(nw < 0 || nr < nw)
                {
                    int64_t written;
                    std::string err;
                    nw = 0;
                    if(ew == nullptr)
                    {
                        int64_t written;
                        std::string err;
                        ew = errInvalidWrite;
                    }
                }
                written += int64_t(nw);
                if(ew != nullptr)
                {
                    int64_t written;
                    std::string err;
                    err = ew;
                    break;
                }
                if(nr != nw)
                {
                    int64_t written;
                    std::string err;
                    err = ErrShortWrite;
                    break;
                }
            }
            if(er != nullptr)
            {
                int64_t written;
                std::string err;
                if(er != go_EOF)
                {
                    int64_t written;
                    std::string err;
                    err = er;
                }
                break;
            }
        }
        return {written, err};
    }

    Reader LimitReader(Reader r, int64_t n)
    {
        return new LimitedReader {r, n};
    }

    
    std::ostream& LimitedReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << N;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LimitedReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> Read(struct LimitedReader* l, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        if(l->N <= 0)
        {
            int n;
            std::string err;
            return {0, go_EOF};
        }
        if(int64_t(len(p)) > l->N)
        {
            int n;
            std::string err;
            p = p.make_slice(0, l->N);
        }
        std::tie(n, err) = Read(gocpp::recv(l->R), p);
        l->N -= int64_t(n);
        return {n, err};
    }

    SectionReader* NewSectionReader(ReaderAt r, int64_t off, int64_t n)
    {
        int64_t remaining = {};
        auto maxint64 = (1 << 63) - 1;
        if(off <= maxint64 - n)
        {
            remaining = n + off;
        }
        else
        {
            remaining = maxint64;
        }
        return new SectionReader {r, off, off, remaining, n};
    }

    
    std::ostream& SectionReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << base;
        os << " " << off;
        os << " " << limit;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SectionReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> Read(struct SectionReader* s, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        if(s->off >= s->limit)
        {
            int n;
            std::string err;
            return {0, go_EOF};
        }
        if(auto max = s->limit - s->off; int64_t(len(p)) > max)
        {
            int n;
            std::string err;
            p = p.make_slice(0, max);
        }
        std::tie(n, err) = ReadAt(gocpp::recv(s->r), p, s->off);
        s->off += int64_t(n);
        return {n, err};
    }

    std::string errWhence = errors::New("Seek: invalid whence");
    std::string errOffset = errors::New("Seek: invalid offset");
    std::tuple<int64_t, std::string> Seek(struct SectionReader* s, int64_t offset, int whence)
    {
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            else if(condition == SeekStart) { conditionId = 0; }
            else if(condition == SeekCurrent) { conditionId = 1; }
            else if(condition == SeekEnd) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    return {0, errWhence};
                    break;
                case 0:
                    offset += s->base;
                    break;
                case 1:
                    offset += s->off;
                    break;
                case 2:
                    offset += s->limit;
                    break;
            }
        }
        if(offset < s->base)
        {
            return {0, errOffset};
        }
        s->off = offset;
        return {offset - s->base, nullptr};
    }

    std::tuple<int, std::string> ReadAt(struct SectionReader* s, gocpp::slice<unsigned char> p, int64_t off)
    {
        int n;
        std::string err;
        if(off < 0 || off >= Size(gocpp::recv(s)))
        {
            int n;
            std::string err;
            return {0, go_EOF};
        }
        off += s->base;
        if(auto max = s->limit - off; int64_t(len(p)) > max)
        {
            int n;
            std::string err;
            p = p.make_slice(0, max);
            std::tie(n, err) = ReadAt(gocpp::recv(s->r), p, off);
            if(err == nullptr)
            {
                int n;
                std::string err;
                err = go_EOF;
            }
            return {n, err};
        }
        return ReadAt(gocpp::recv(s->r), p, off);
    }

    int64_t Size(struct SectionReader* s)
    {
        return s->limit - s->base;
    }

    std::tuple<ReaderAt, int64_t, int64_t> Outer(struct SectionReader* s)
    {
        ReaderAt r;
        int64_t off;
        int64_t n;
        return {s->r, s->base, s->n};
    }

    
    std::ostream& OffsetWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << base;
        os << " " << off;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct OffsetWriter& value)
    {
        return value.PrintTo(os);
    }

    OffsetWriter* NewOffsetWriter(WriterAt w, int64_t off)
    {
        return new OffsetWriter {w, off, off};
    }

    std::tuple<int, std::string> Write(struct OffsetWriter* o, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        std::tie(n, err) = WriteAt(gocpp::recv(o->w), p, o->off);
        o->off += int64_t(n);
        return {n, err};
    }

    std::tuple<int, std::string> WriteAt(struct OffsetWriter* o, gocpp::slice<unsigned char> p, int64_t off)
    {
        int n;
        std::string err;
        if(off < 0)
        {
            int n;
            std::string err;
            return {0, errOffset};
        }
        off += o->base;
        return WriteAt(gocpp::recv(o->w), p, off);
    }

    std::tuple<int64_t, std::string> Seek(struct OffsetWriter* o, int64_t offset, int whence)
    {
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            else if(condition == SeekStart) { conditionId = 0; }
            else if(condition == SeekCurrent) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    return {0, errWhence};
                    break;
                case 0:
                    offset += o->base;
                    break;
                case 1:
                    offset += o->off;
                    break;
            }
        }
        if(offset < o->base)
        {
            return {0, errOffset};
        }
        o->off = offset;
        return {offset - o->base, nullptr};
    }

    Reader TeeReader(Reader r, Writer w)
    {
        return new teeReader {r, w};
    }

    
    std::ostream& teeReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << w;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct teeReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> Read(struct teeReader* t, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        std::tie(n, err) = Read(gocpp::recv(t->r), p);
        if(n > 0)
        {
            int n;
            std::string err;
            if(auto [n, err] = Write(gocpp::recv(t->w), p.make_slice(0, n)); err != nullptr)
            {
                int n;
                std::string err;
                return {n, err};
            }
        }
        return {n, err};
    }

    Writer Discard = discard {};
    
    std::ostream& discard::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct discard& value)
    {
        return value.PrintTo(os);
    }

    ReaderFrom _ = discard {};
    std::tuple<int, std::string> Write(discard, gocpp::slice<unsigned char> p)
    {
        return {len(p), nullptr};
    }

    std::tuple<int, std::string> WriteString(discard, std::string s)
    {
        return {len(s), nullptr};
    }

    sync::Pool blackHolePool = gocpp::Init<sync::Pool>([](sync::Pool& x) { x.New = [=]() mutable -> go_any
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 8192);
        return & b;
    }
; });
    std::tuple<int64_t, std::string> ReadFrom(discard, Reader r)
    {
        int64_t n;
        std::string err;
        auto bufp = gocpp::getValue<[]byte*>(Get(gocpp::recv(blackHolePool)));
        auto readSize = 0;
        for(; ; )
        {
            int64_t n;
            std::string err;
            std::tie(readSize, err) = Read(gocpp::recv(r), *bufp);
            n += int64_t(readSize);
            if(err != nullptr)
            {
                int64_t n;
                std::string err;
                Put(gocpp::recv(blackHolePool), bufp);
                if(err == go_EOF)
                {
                    int64_t n;
                    std::string err;
                    return {n, nullptr};
                }
                return {n, err};
            }
        }
    }

    ReadCloser NopCloser(Reader r)
    {
        if(auto [gocpp_id_1, ok] = gocpp::getValue<WriterTo>(r); ok)
        {
            return nopCloserWriterTo {r};
        }
        return nopCloser {r};
    }

    
    std::ostream& nopCloser::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nopCloser& value)
    {
        return value.PrintTo(os);
    }

    std::string Close(nopCloser)
    {
        return nullptr;
    }

    
    std::ostream& nopCloserWriterTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nopCloserWriterTo& value)
    {
        return value.PrintTo(os);
    }

    std::string Close(nopCloserWriterTo)
    {
        return nullptr;
    }

    std::tuple<int64_t, std::string> WriteTo(struct nopCloserWriterTo c, Writer w)
    {
        int64_t n;
        std::string err;
        return WriteTo(gocpp::recv(gocpp::getValue<WriterTo>(c.Reader)), w);
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> ReadAll(Reader r)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 512);
        for(; ; )
        {
            auto [n, err] = Read(gocpp::recv(r), b.make_slice(len(b), cap(b)));
            b = b.make_slice(0, len(b) + n);
            if(err != nullptr)
            {
                if(err == go_EOF)
                {
                    err = nullptr;
                }
                return {b, err};
            }
            if(len(b) == cap(b))
            {
                b = append(b, 0).make_slice(0, len(b));
            }
        }
    }

}

