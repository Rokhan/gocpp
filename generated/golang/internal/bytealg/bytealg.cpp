// generated by GoCpp from file '$(ImportDir)/internal/bytealg/bytealg.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/bytealg/bytealg.h"
#include "gocpp/support.h"

namespace golang::bytealg
{
    uintptr_t offsetX86HasSSE42 = Offsetof(gocpp::recv(unsafe), cpu.X86.HasSSE42);
    uintptr_t offsetX86HasAVX2 = Offsetof(gocpp::recv(unsafe), cpu.X86.HasAVX2);
    uintptr_t offsetX86HasPOPCNT = Offsetof(gocpp::recv(unsafe), cpu.X86.HasPOPCNT);
    uintptr_t offsetS390xHasVX = Offsetof(gocpp::recv(unsafe), cpu.S390X.HasVX);
    uintptr_t offsetPPC64HasPOWER9 = Offsetof(gocpp::recv(unsafe), cpu.PPC64.IsPOWER9);
    int MaxLen;
    int PrimeRK = 16777619;
    std::tuple<uint32_t, uint32_t> HashStr(T sep)
    {
        auto hash = uint32_t(0);
        for(auto i = 0; i < len(sep); i++)
        {
            hash = hash * PrimeRK + uint32_t(sep[i]);
        }
        uint32_t pow = 1;
        uint32_t sq = PrimeRK;
        for(auto i = len(sep); i > 0; i >>= 1)
        {
            if(i & 1 != 0)
            {
                pow *= sq;
            }
            sq *= sq;
        }
        return {hash, pow};
    }

    std::tuple<uint32_t, uint32_t> HashStrRev(T sep)
    {
        auto hash = uint32_t(0);
        for(auto i = len(sep) - 1; i >= 0; i--)
        {
            hash = hash * PrimeRK + uint32_t(sep[i]);
        }
        uint32_t pow = 1;
        uint32_t sq = PrimeRK;
        for(auto i = len(sep); i > 0; i >>= 1)
        {
            if(i & 1 != 0)
            {
                pow *= sq;
            }
            sq *= sq;
        }
        return {hash, pow};
    }

    int IndexRabinKarp(T s, T sep)
    {
        auto [hashss, pow] = HashStr(sep);
        auto n = len(sep);
        uint32_t h = {};
        for(auto i = 0; i < n; i++)
        {
            h = h * PrimeRK + uint32_t(s[i]);
        }
        if(h == hashss && string(s.make_slice(0, n)) == string(sep))
        {
            return 0;
        }
        for(auto i = n; i < len(s); )
        {
            h *= PrimeRK;
            h += uint32_t(s[i]);
            h -= pow * uint32_t(s[i - n]);
            i++;
            if(h == hashss && string(s.make_slice(i - n, i)) == string(sep))
            {
                return i - n;
            }
        }
        return - 1;
    }

    int LastIndexRabinKarp(T s, T sep)
    {
        auto [hashss, pow] = HashStrRev(sep);
        auto n = len(sep);
        auto last = len(s) - n;
        uint32_t h = {};
        for(auto i = len(s) - 1; i >= last; i--)
        {
            h = h * PrimeRK + uint32_t(s[i]);
        }
        if(h == hashss && string(s.make_slice(last)) == string(sep))
        {
            return last;
        }
        for(auto i = last - 1; i >= 0; i--)
        {
            h *= PrimeRK;
            h += uint32_t(s[i]);
            h -= pow * uint32_t(s[i + n]);
            if(h == hashss && string(s.make_slice(i, i + n)) == string(sep))
            {
                return i;
            }
        }
        return - 1;
    }

    gocpp::slice<unsigned char> MakeNoZero(int n)
    /* convertBlockStmt, nil block */;

}

