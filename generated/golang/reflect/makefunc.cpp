// generated by GoCpp from file '$(ImportDir)/reflect/makefunc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/makefunc.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/abi.h"  [Ignored, known errors]
#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/reflect/type.h"
#include "golang/reflect/value.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    
    std::ostream& makeFuncImpl::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ftyp;
        os << " " << fn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct makeFuncImpl& value)
    {
        return value.PrintTo(os);
    }

    Value MakeFunc(Type typ, std::function<gocpp::slice<Value> (gocpp::slice<Value> args)> fn)
    {
        if(Kind(gocpp::recv(typ)) != Func)
        {
            gocpp::panic("reflect: call of MakeFunc with non-Func type");
        }
        auto t = common(gocpp::recv(typ));
        auto ftyp = (funcType*)(Pointer(gocpp::recv(unsafe), t));
        auto code = FuncPCABI0(gocpp::recv(abi), makeFuncStub);
        internal/abi.Type* _;
        sync.Pool* _;
        reflect.abiDesc abid;
        std::tie(_, _, abid) = funcLayout(ftyp, nullptr);
        auto impl = gocpp::InitPtr<makeFuncImpl>([](makeFuncImpl& x) { x.makeFuncCtxt = gocpp::Init<makeFuncCtxt>([](makeFuncCtxt& x) { x.fn = code; x.stack = abid.stackPtrs; x.argLen = abid.stackCallArgsSize; x.regPtrs = abid.inRegPtrs; }); x.ftyp = ftyp; x.fn = fn; });
        return Value {t, Pointer(gocpp::recv(unsafe), impl), flag(Func)};
    }

    void makeFuncStub()
    /* convertBlockStmt, nil block */;

    
    std::ostream& methodValue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << method;
        os << " " << rcvr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct methodValue& value)
    {
        return value.PrintTo(os);
    }

    Value makeMethodValue(std::string op, Value v)
    {
        if(v.flag & flagMethod == 0)
        {
            gocpp::panic("reflect: internal error: invalid use of makeMethodValue");
        }
        auto fl = v.flag & (flagRO | flagAddr | flagIndir);
        fl |= flag(Kind(gocpp::recv(typ(gocpp::recv(v)))));
        auto rcvr = Value {typ(gocpp::recv(v)), v.ptr, fl};
        auto ftyp = (funcType*)(Pointer(gocpp::recv(unsafe), gocpp::getValue<reflect.rtype*>(Type(gocpp::recv(v)))));
        auto code = methodValueCallCodePtr();
        internal/abi.Type* _;
        sync.Pool* _;
        reflect.abiDesc abid;
        std::tie(_, _, abid) = funcLayout(ftyp, nullptr);
        auto fv = gocpp::InitPtr<methodValue>([](methodValue& x) { x.makeFuncCtxt = gocpp::Init<makeFuncCtxt>([](makeFuncCtxt& x) { x.fn = code; x.stack = abid.stackPtrs; x.argLen = abid.stackCallArgsSize; x.regPtrs = abid.inRegPtrs; }); x.method = int(v.flag) >> flagMethodShift; x.rcvr = rcvr; });
        methodReceiver(op, fv->rcvr, fv->method);
        return Value {Common(gocpp::recv(ftyp)), Pointer(gocpp::recv(unsafe), fv), v.flag & flagRO | flag(Func)};
    }

    uintptr_t methodValueCallCodePtr()
    {
        return FuncPCABI0(gocpp::recv(abi), methodValueCall);
    }

    void methodValueCall()
    /* convertBlockStmt, nil block */;

    
    std::ostream& makeFuncCtxt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << stack;
        os << " " << argLen;
        os << " " << regPtrs;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct makeFuncCtxt& value)
    {
        return value.PrintTo(os);
    }

    void moveMakeFuncArgPtrs(makeFuncCtxt* ctxt, abi::RegArgs* args)
    {
        for(auto [i, arg] : args->Ints)
        {
            if(Get(gocpp::recv(ctxt->regPtrs), i))
            {
                *(uintptr_t*)(Pointer(gocpp::recv(unsafe), & args->Ptrs[i])) = arg;
            }
            else
            {
                *(uintptr_t*)(Pointer(gocpp::recv(unsafe), & args->Ptrs[i])) = 0;
            }
        }
    }

}

