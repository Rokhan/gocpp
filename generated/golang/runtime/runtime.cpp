// generated by GoCpp from file '$(ImportDir)/runtime/runtime.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime.h"
#include "gocpp/support.h"

#include "golang/runtime/cputicks.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    ticksType ticks;
    
    template<typename T> requires gocpp::GoStruct<T>
    ticksType::operator T()
    {
        T result;
        result.lock = this->lock;
        result.startTicks = this->startTicks;
        result.startTime = this->startTime;
        result.val = this->val;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ticksType::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (startTicks != ref.startTicks) return false;
        if (startTime != ref.startTime) return false;
        if (val != ref.val) return false;
        return true;
    }

    std::ostream& ticksType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << startTicks;
        os << " " << startTime;
        os << " " << val;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ticksType& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct ticksType* t)
    {
        lock(& ticks.lock);
        t->startTime = nanotime();
        t->startTicks = cputicks();
        unlock(& ticks.lock);
    }

    int64_t ticksPerSecond()
    {
        auto r = rec::Load(gocpp::recv(ticks.val));
        if(r != 0)
        {
            return r;
        }
        for(; ; )
        {
            lock(& ticks.lock);
            r = rec::Load(gocpp::recv(ticks.val));
            if(r != 0)
            {
                unlock(& ticks.lock);
                return r;
            }
            auto nowTime = nanotime();
            auto nowTicks = cputicks();
            if(nowTicks > ticks.startTicks && nowTime - ticks.startTime > minTimeForTicksPerSecond)
            {
                r = int64_t(double(nowTicks - ticks.startTicks) * 1e9 / double(nowTime - ticks.startTime));
                if(r == 0)
                {
                    r++;
                }
                rec::Store(gocpp::recv(ticks.val), r);
                unlock(& ticks.lock);
                break;
            }
            unlock(& ticks.lock);
            timeSleep(1000000);
        }
        return r;
    }

    gocpp::slice<std::string> envs;
    gocpp::slice<std::string> argslice;
    gocpp::slice<std::string> syscall_runtime_envs()
    {
        return append(gocpp::slice<std::string> {}, envs);
    }

    int syscall_Getpagesize()
    {
        return int(physPageSize);
    }

    gocpp::slice<std::string> os_runtime_args()
    {
        return append(gocpp::slice<std::string> {}, argslice);
    }

    void syscall_Exit(int code)
    {
        exit(int32_t(code));
    }

    std::string godebugDefault;
    atomic::Pointer<std::function<void (std::string, std::string)>> godebugUpdate;
    atomic::Pointer<std::string> godebugEnv;
    atomic::Pointer<std::function<std::function<void ()> (std::string)>> godebugNewIncNonDefault;
    void godebug_setUpdate(std::function<void (std::string, std::string)> update)
    {
        auto p = new(gocpp::Tag<std::function<void (std::string, std::string)>>());
        *p = update;
        rec::Store(gocpp::recv(godebugUpdate), p);
        godebugNotify(false);
    }

    void godebug_setNewIncNonDefault(std::function<std::function<void ()> (std::string)> newIncNonDefault)
    {
        auto p = new(gocpp::Tag<std::function<std::function<void ()> (std::string)>>());
        *p = newIncNonDefault;
        rec::Store(gocpp::recv(godebugNewIncNonDefault), p);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    godebugInc::operator T()
    {
        T result;
        result.name = this->name;
        result.inc = this->inc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool godebugInc::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (inc != ref.inc) return false;
        return true;
    }

    std::ostream& godebugInc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << inc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct godebugInc& value)
    {
        return value.PrintTo(os);
    }

    void rec::IncNonDefault(struct godebugInc* g)
    {
        auto inc = rec::Load(gocpp::recv(g->inc));
        if(inc == nullptr)
        {
            auto newInc = rec::Load(gocpp::recv(godebugNewIncNonDefault));
            if(newInc == nullptr)
            {
                return;
            }
            inc = new(gocpp::Tag<std::function<void ()>>());
            *inc = (runtime::newInc*)(g->name);
            if(raceenabled)
            {
                racereleasemerge(unsafe::Pointer(& g->inc));
            }
            if(! rec::CompareAndSwap(gocpp::recv(g->inc), nullptr, inc))
            {
                inc = rec::Load(gocpp::recv(g->inc));
            }
        }
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& g->inc));
        }
        (runtime::inc*)();
    }

    void godebugNotify(bool envChanged)
    {
        auto update = rec::Load(gocpp::recv(godebugUpdate));
        std::string env = {};
        if(auto p = rec::Load(gocpp::recv(godebugEnv)); p != nullptr)
        {
            env = *p;
        }
        if(envChanged)
        {
            reparsedebugvars(env);
        }
        if(update != nullptr)
        {
            (runtime::update*)(godebugDefault, env);
        }
    }

    void syscall_runtimeSetenv(std::string key, std::string value)
    {
        setenv_c(key, value);
        if(key == "GODEBUG")
        {
            auto p = new(string);
            *p = value;
            rec::Store(gocpp::recv(godebugEnv), p);
            godebugNotify(true);
        }
    }

    void syscall_runtimeUnsetenv(std::string key)
    {
        unsetenv_c(key);
        if(key == "GODEBUG")
        {
            rec::Store(gocpp::recv(godebugEnv), nullptr);
            godebugNotify(true);
        }
    }

    void writeErrStr(std::string s)
    {
        write(2, unsafe::Pointer(unsafe::StringData(s)), int32_t(len(s)));
    }

    gocpp::slice<uintptr_t> auxv;
    gocpp::slice<uintptr_t> getAuxv()
    {
        return auxv;
    }

}

