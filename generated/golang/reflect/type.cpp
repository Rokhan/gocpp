// generated by GoCpp from file '$(ImportDir)/reflect/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/type.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/map.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/value.h"
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/cond.h"
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/utf8/utf8.h"
#include "golang/unsafe/unsafe.h"

// Package reflect implements run-time reflection, allowing a program to
// manipulate objects with arbitrary types. The typical use is to take a value
// with static type interface{} and extract its dynamic type information by
// calling TypeOf, which returns a Type.
//
// A call to ValueOf returns a Value representing the run-time data.
// Zero takes a Type and returns a Value representing a zero value
// for that type.
//
// See "The Laws of Reflection" for an introduction to reflection in Go:
// https://golang.org/doc/articles/laws_of_reflection.html
namespace golang::reflect
{
    namespace rec
    {
        using namespace mocklib::rec;
        using abi::rec::Align;
        using abi::rec::ChanDir;
        using abi::rec::DataChecked;
        using abi::rec::Elem;
        using abi::rec::Embedded;
        using abi::rec::Equal;
        using abi::rec::ExportedMethods;
        using abi::rec::FieldAlign;
        using abi::rec::GcSlice;
        using abi::rec::HasName;
        using abi::rec::HasTag;
        using abi::rec::In;
        using abi::rec::InSlice;
        using abi::rec::IsExported;
        using abi::rec::IsVariadic;
        using abi::rec::Key;
        using abi::rec::Kind;
        using abi::rec::Len;
        using abi::rec::Methods;
        using abi::rec::Name;
        using abi::rec::NumIn;
        using abi::rec::NumOut;
        using abi::rec::Out;
        using abi::rec::OutSlice;
        using abi::rec::Pointers;
        using abi::rec::ReadVarint;
        using abi::rec::Size;
        using abi::rec::Tag;
        using abi::rec::Uncommon;
        using mocklib::rec::Lock;
        using mocklib::rec::Unlock;
        using sync::rec::Load;
        using sync::rec::LoadOrStore;
        using sync::rec::Store;
    }

    // Type is the representation of a Go type.
    //
    // Not all methods apply to all kinds of types. Restrictions,
    // if any, are noted in the documentation for each method.
    // Use the Kind method to find out the kind of type before
    // calling kind-specific methods. Calling a method
    // inappropriate to the kind of type causes a run-time panic.
    //
    // Type values are comparable, such as with the == operator,
    // so they can be used as map keys.
    // Two Type values are equal if they represent identical types.
    
    template<typename T>
    Type::Type(T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(const T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(T* ptr)
    {
        value.reset(new TypeImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Type::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vAlign()
    {
        return rec::Align(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vFieldAlign()
    {
        return rec::FieldAlign(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Method Type::TypeImpl<T, StoreT>::vMethod(int _1)
    {
        return rec::Method(gocpp::PtrRecv<T, false>(value.get()), _1);
    }
    template<typename T, typename StoreT>
    std::tuple<struct Method, bool> Type::TypeImpl<T, StoreT>::vMethodByName(std::string _1)
    {
        return rec::MethodByName(gocpp::PtrRecv<T, false>(value.get()), _1);
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumMethod()
    {
        return rec::NumMethod(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vPkgPath()
    {
        return rec::PkgPath(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uintptr_t Type::TypeImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    reflect::Kind Type::TypeImpl<T, StoreT>::vKind()
    {
        return rec::Kind(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vImplements(struct Type u)
    {
        return rec::Implements(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vAssignableTo(struct Type u)
    {
        return rec::AssignableTo(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vConvertibleTo(struct Type u)
    {
        return rec::ConvertibleTo(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vComparable()
    {
        return rec::Comparable(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vBits()
    {
        return rec::Bits(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    reflect::ChanDir Type::TypeImpl<T, StoreT>::vChanDir()
    {
        return rec::ChanDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vIsVariadic()
    {
        return rec::IsVariadic(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vElem()
    {
        return rec::Elem(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct StructField Type::TypeImpl<T, StoreT>::vField(int i)
    {
        return rec::Field(gocpp::PtrRecv<T, false>(value.get()), i);
    }
    template<typename T, typename StoreT>
    struct StructField Type::TypeImpl<T, StoreT>::vFieldByIndex(gocpp::slice<int> index)
    {
        return rec::FieldByIndex(gocpp::PtrRecv<T, false>(value.get()), index);
    }
    template<typename T, typename StoreT>
    std::tuple<struct StructField, bool> Type::TypeImpl<T, StoreT>::vFieldByName(std::string name)
    {
        return rec::FieldByName(gocpp::PtrRecv<T, false>(value.get()), name);
    }
    template<typename T, typename StoreT>
    std::tuple<struct StructField, bool> Type::TypeImpl<T, StoreT>::vFieldByNameFunc(std::function<bool (std::string _1)> match)
    {
        return rec::FieldByNameFunc(gocpp::PtrRecv<T, false>(value.get()), match);
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vIn(int i)
    {
        return rec::In(gocpp::PtrRecv<T, false>(value.get()), i);
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vKey()
    {
        return rec::Key(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vLen()
    {
        return rec::Len(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumField()
    {
        return rec::NumField(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumIn()
    {
        return rec::NumIn(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumOut()
    {
        return rec::NumOut(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vOut(int i)
    {
        return rec::Out(gocpp::PtrRecv<T, false>(value.get()), i);
    }
    template<typename T, typename StoreT>
    abi::Type* Type::TypeImpl<T, StoreT>::vcommon()
    {
        return rec::common(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    reflect::uncommonType* Type::TypeImpl<T, StoreT>::vuncommon()
    {
        return rec::uncommon(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        int Align(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vAlign();
        }

        int Align(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vAlign();
        }

        int FieldAlign(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vFieldAlign();
        }

        int FieldAlign(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vFieldAlign();
        }

        struct Method Method(const gocpp::PtrRecv<struct Type, false>& self, int _1)
        {
            return self.ptr->value->vMethod(_1);
        }

        struct Method Method(const gocpp::ObjRecv<struct Type>& self, int _1)
        {
            return self.obj.value->vMethod(_1);
        }

        std::tuple<struct Method, bool> MethodByName(const gocpp::PtrRecv<struct Type, false>& self, std::string _1)
        {
            return self.ptr->value->vMethodByName(_1);
        }

        std::tuple<struct Method, bool> MethodByName(const gocpp::ObjRecv<struct Type>& self, std::string _1)
        {
            return self.obj.value->vMethodByName(_1);
        }

        int NumMethod(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vNumMethod();
        }

        int NumMethod(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vNumMethod();
        }

        std::string Name(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vName();
        }

        std::string Name(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vName();
        }

        std::string PkgPath(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vPkgPath();
        }

        std::string PkgPath(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vPkgPath();
        }

        uintptr_t Size(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vSize();
        }

        uintptr_t Size(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vSize();
        }

        std::string String(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vString();
        }

        reflect::Kind Kind(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vKind();
        }

        reflect::Kind Kind(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vKind();
        }

        bool Implements(const gocpp::PtrRecv<struct Type, false>& self, struct Type u)
        {
            return self.ptr->value->vImplements(u);
        }

        bool Implements(const gocpp::ObjRecv<struct Type>& self, struct Type u)
        {
            return self.obj.value->vImplements(u);
        }

        bool AssignableTo(const gocpp::PtrRecv<struct Type, false>& self, struct Type u)
        {
            return self.ptr->value->vAssignableTo(u);
        }

        bool AssignableTo(const gocpp::ObjRecv<struct Type>& self, struct Type u)
        {
            return self.obj.value->vAssignableTo(u);
        }

        bool ConvertibleTo(const gocpp::PtrRecv<struct Type, false>& self, struct Type u)
        {
            return self.ptr->value->vConvertibleTo(u);
        }

        bool ConvertibleTo(const gocpp::ObjRecv<struct Type>& self, struct Type u)
        {
            return self.obj.value->vConvertibleTo(u);
        }

        bool Comparable(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vComparable();
        }

        bool Comparable(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vComparable();
        }

        int Bits(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vBits();
        }

        int Bits(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vBits();
        }

        reflect::ChanDir ChanDir(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vChanDir();
        }

        reflect::ChanDir ChanDir(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vChanDir();
        }

        bool IsVariadic(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vIsVariadic();
        }

        bool IsVariadic(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vIsVariadic();
        }

        struct Type Elem(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vElem();
        }

        struct Type Elem(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vElem();
        }

        struct StructField Field(const gocpp::PtrRecv<struct Type, false>& self, int i)
        {
            return self.ptr->value->vField(i);
        }

        struct StructField Field(const gocpp::ObjRecv<struct Type>& self, int i)
        {
            return self.obj.value->vField(i);
        }

        struct StructField FieldByIndex(const gocpp::PtrRecv<struct Type, false>& self, gocpp::slice<int> index)
        {
            return self.ptr->value->vFieldByIndex(index);
        }

        struct StructField FieldByIndex(const gocpp::ObjRecv<struct Type>& self, gocpp::slice<int> index)
        {
            return self.obj.value->vFieldByIndex(index);
        }

        std::tuple<struct StructField, bool> FieldByName(const gocpp::PtrRecv<struct Type, false>& self, std::string name)
        {
            return self.ptr->value->vFieldByName(name);
        }

        std::tuple<struct StructField, bool> FieldByName(const gocpp::ObjRecv<struct Type>& self, std::string name)
        {
            return self.obj.value->vFieldByName(name);
        }

        std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::PtrRecv<struct Type, false>& self, std::function<bool (std::string _1)> match)
        {
            return self.ptr->value->vFieldByNameFunc(match);
        }

        std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::ObjRecv<struct Type>& self, std::function<bool (std::string _1)> match)
        {
            return self.obj.value->vFieldByNameFunc(match);
        }

        struct Type In(const gocpp::PtrRecv<struct Type, false>& self, int i)
        {
            return self.ptr->value->vIn(i);
        }

        struct Type In(const gocpp::ObjRecv<struct Type>& self, int i)
        {
            return self.obj.value->vIn(i);
        }

        struct Type Key(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vKey();
        }

        struct Type Key(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vKey();
        }

        int Len(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vLen();
        }

        int Len(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vLen();
        }

        int NumField(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vNumField();
        }

        int NumField(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vNumField();
        }

        int NumIn(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vNumIn();
        }

        int NumIn(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vNumIn();
        }

        int NumOut(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vNumOut();
        }

        int NumOut(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vNumOut();
        }

        struct Type Out(const gocpp::PtrRecv<struct Type, false>& self, int i)
        {
            return self.ptr->value->vOut(i);
        }

        struct Type Out(const gocpp::ObjRecv<struct Type>& self, int i)
        {
            return self.obj.value->vOut(i);
        }

        abi::Type* common(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vcommon();
        }

        abi::Type* common(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vcommon();
        }

        reflect::uncommonType* uncommon(const gocpp::PtrRecv<struct Type, false>& self)
        {
            return self.ptr->value->vuncommon();
        }

        reflect::uncommonType* uncommon(const gocpp::ObjRecv<struct Type>& self)
        {
            return self.obj.value->vuncommon();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value)
    {
        return value.PrintTo(os);
    }

    // A Kind represents the specific kind of type that a [Type] represents.
    // The zero Kind is not a valid kind.
    // Ptr is the old name for the [Pointer] kind.
    // uncommonType is present only for defined types or types with methods
    // (if T is a defined type, the uncommonTypes for T and *T have methods).
    // Using a pointer to this struct reduces the overall size required
    // to describe a non-defined type with no methods.
    // Embed this type to get common/uncommon
    
    template<typename T> requires gocpp::GoStruct<T>
    common::operator T()
    {
        T result;
        result.Type = this->Type;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool common::operator==(const T& ref) const
    {
        if (Type != ref.Type) return false;
        return true;
    }

    std::ostream& common::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Type;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct common& value)
    {
        return value.PrintTo(os);
    }

    // rtype is the common implementation of most values.
    // It is embedded in other struct types.
    
    template<typename T> requires gocpp::GoStruct<T>
    rtype::operator T()
    {
        T result;
        result.t = this->t;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool rtype::operator==(const T& ref) const
    {
        if (t != ref.t) return false;
        return true;
    }

    std::ostream& rtype::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << t;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rtype& value)
    {
        return value.PrintTo(os);
    }

    abi::Type* rec::common(struct rtype* t)
    {
        return & t->t;
    }

    abi::UncommonType* rec::uncommon(struct rtype* t)
    {
        return rec::Uncommon(gocpp::recv(t->t));
    }

    // ChanDir represents a channel type's direction.
    // arrayType represents a fixed array type.
    // chanType represents a channel type.
    // funcType represents a function type.
    //
    // A *rtype for each in and out parameter is stored in an array that
    // directly follows the funcType (and possibly its uncommonType). So
    // a function type with one method, one input, and one output is:
    //
    //	struct {
    //		funcType
    //		uncommonType
    //		[2]*rtype    // [0] is in, [1] is out
    //	}
    // interfaceType represents an interface type.
    
    template<typename T> requires gocpp::GoStruct<T>
    interfaceType::operator T()
    {
        T result;
        result.InterfaceType = this->InterfaceType;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool interfaceType::operator==(const T& ref) const
    {
        if (InterfaceType != ref.InterfaceType) return false;
        return true;
    }

    std::ostream& interfaceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << InterfaceType;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct interfaceType& value)
    {
        return value.PrintTo(os);
    }

    abi::Name rec::nameOff(struct interfaceType* t, golang::reflect::aNameOff off)
    {
        return rec::nameOff(gocpp::recv(toRType(& t->Type)), off);
    }

    abi::Name nameOffFor(abi::Type* t, golang::reflect::aNameOff off)
    {
        return rec::nameOff(gocpp::recv(toRType(t)), off);
    }

    abi::Type* typeOffFor(abi::Type* t, golang::reflect::aTypeOff off)
    {
        return rec::typeOff(gocpp::recv(toRType(t)), off);
    }

    abi::Type* rec::typeOff(struct interfaceType* t, golang::reflect::aTypeOff off)
    {
        return rec::typeOff(gocpp::recv(toRType(& t->Type)), off);
    }

    abi::Type* rec::common(struct interfaceType* t)
    {
        return & t->Type;
    }

    abi::UncommonType* rec::uncommon(struct interfaceType* t)
    {
        return rec::Uncommon(gocpp::recv(t));
    }

    // mapType represents a map type.
    
    template<typename T> requires gocpp::GoStruct<T>
    mapType::operator T()
    {
        T result;
        result.MapType = this->MapType;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mapType::operator==(const T& ref) const
    {
        if (MapType != ref.MapType) return false;
        return true;
    }

    std::ostream& mapType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << MapType;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mapType& value)
    {
        return value.PrintTo(os);
    }

    // ptrType represents a pointer type.
    
    template<typename T> requires gocpp::GoStruct<T>
    ptrType::operator T()
    {
        T result;
        result.PtrType = this->PtrType;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ptrType::operator==(const T& ref) const
    {
        if (PtrType != ref.PtrType) return false;
        return true;
    }

    std::ostream& ptrType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PtrType;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ptrType& value)
    {
        return value.PrintTo(os);
    }

    // sliceType represents a slice type.
    
    template<typename T> requires gocpp::GoStruct<T>
    sliceType::operator T()
    {
        T result;
        result.SliceType = this->SliceType;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sliceType::operator==(const T& ref) const
    {
        if (SliceType != ref.SliceType) return false;
        return true;
    }

    std::ostream& sliceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << SliceType;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sliceType& value)
    {
        return value.PrintTo(os);
    }

    // Struct field
    // structType represents a struct type.
    
    template<typename T> requires gocpp::GoStruct<T>
    structType::operator T()
    {
        T result;
        result.StructType = this->StructType;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool structType::operator==(const T& ref) const
    {
        if (StructType != ref.StructType) return false;
        return true;
    }

    std::ostream& structType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << StructType;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structType& value)
    {
        return value.PrintTo(os);
    }

    std::string pkgPath(abi::Name n)
    {
        if(n.Bytes == nullptr || *rec::DataChecked(gocpp::recv(n), 0, "name flag field"s) & (1 << 2) == 0)
        {
            return ""s;
        }
        auto [i, l] = rec::ReadVarint(gocpp::recv(n), 1);
        auto off = 1 + i + l;
        if(rec::HasTag(gocpp::recv(n)))
        {
            auto [i2, l2] = rec::ReadVarint(gocpp::recv(n), off);
            off += i2 + l2;
        }
        int32_t nameOff = {};
        copy((gocpp::array<unsigned char, 4>*)(unsafe::Pointer(& nameOff)).make_slice(0), (gocpp::array<unsigned char, 4>*)(unsafe::Pointer(rec::DataChecked(gocpp::recv(n), off, "name offset field"s))).make_slice(0));
        auto pkgPathName = gocpp::Init<abi::Name>([=](auto& x) {
            x.Bytes = (unsigned char*)(resolveTypeOff(unsafe::Pointer(n.Bytes), nameOff));
        });
        return rec::Name(gocpp::recv(pkgPathName));
    }

    abi::Name newName(std::string n, std::string tag, bool exported, bool embedded)
    {
        return abi::NewName(n, tag, exported, embedded);
    }

    // Method represents a single method.
    
    template<typename T> requires gocpp::GoStruct<T>
    Method::operator T()
    {
        T result;
        result.Name = this->Name;
        result.PkgPath = this->PkgPath;
        result.Type = this->Type;
        result.Func = this->Func;
        result.Index = this->Index;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Method::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (PkgPath != ref.PkgPath) return false;
        if (Type != ref.Type) return false;
        if (Func != ref.Func) return false;
        if (Index != ref.Index) return false;
        return true;
    }

    std::ostream& Method::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << PkgPath;
        os << " " << Type;
        os << " " << Func;
        os << " " << Index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Method& value)
    {
        return value.PrintTo(os);
    }

    // IsExported reports whether the method is exported.
    bool rec::IsExported(struct Method m)
    {
        return m.PkgPath == ""s;
    }

    // String returns the name of k.
    std::string rec::String(golang::reflect::Kind k)
    {
        if((unsigned int)(k) < (unsigned int)(len(kindNames)))
        {
            return kindNames[(unsigned int)(k)];
        }
        return "kind"s + strconv::Itoa(int(k));
    }

    gocpp::slice<std::string> kindNames = gocpp::Init<gocpp::slice<std::string>>([](auto& x) {
        x[Invalid] = "invalid"s;
        x[Bool] = "bool"s;
        x[Int] = "int"s;
        x[Int8] = "int8"s;
        x[Int16] = "int16"s;
        x[Int32] = "int32"s;
        x[Int64] = "int64"s;
        x[Uint] = "uint"s;
        x[Uint8] = "uint8"s;
        x[Uint16] = "uint16"s;
        x[Uint32] = "uint32"s;
        x[Uint64] = "uint64"s;
        x[Uintptr] = "uintptr"s;
        x[Float32] = "float32"s;
        x[Float64] = "float64"s;
        x[Complex64] = "complex64"s;
        x[Complex128] = "complex128"s;
        x[Array] = "array"s;
        x[Chan] = "chan"s;
        x[Func] = "func"s;
        x[Interface] = "interface"s;
        x[Map] = "map"s;
        x[Pointer] = "ptr"s;
        x[Slice] = "slice"s;
        x[String] = "string"s;
        x[Struct] = "struct"s;
        x[UnsafePointer] = "unsafe.Pointer"s;
    });
    // resolveNameOff resolves a name offset from a base pointer.
    // The (*rtype).nameOff method is a convenience wrapper for this function.
    // Implemented in the runtime package.
    //
    //go:noescape
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    /* convertBlockStmt, nil block */;

    // resolveTypeOff resolves an *rtype offset from a base type.
    // The (*rtype).typeOff method is a convenience wrapper for this function.
    // Implemented in the runtime package.
    //
    //go:noescape
    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    // resolveTextOff resolves a function pointer offset from a base type.
    // The (*rtype).textOff method is a convenience wrapper for this function.
    // Implemented in the runtime package.
    //
    //go:noescape
    unsafe::Pointer resolveTextOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    // addReflectOff adds a pointer to the reflection lookup map in the runtime.
    // It returns a new ID that can be used as a typeOff or textOff, and will
    // be resolved correctly. Implemented in the runtime package.
    //
    //go:noescape
    int32_t addReflectOff(unsafe::Pointer ptr)
    /* convertBlockStmt, nil block */;

    // resolveReflectName adds a name to the reflection lookup map in the runtime.
    // It returns a new nameOff that can be used to refer to the pointer.
    reflect::aNameOff resolveReflectName(abi::Name n)
    {
        return aNameOff(addReflectOff(unsafe::Pointer(n.Bytes)));
    }

    // resolveReflectType adds a *rtype to the reflection lookup map in the runtime.
    // It returns a new typeOff that can be used to refer to the pointer.
    reflect::aTypeOff resolveReflectType(abi::Type* t)
    {
        return aTypeOff(addReflectOff(unsafe::Pointer(t)));
    }

    // resolveReflectText adds a function pointer to the reflection lookup map in
    // the runtime. It returns a new textOff that can be used to refer to the
    // pointer.
    reflect::aTextOff resolveReflectText(unsafe::Pointer ptr)
    {
        return aTextOff(addReflectOff(ptr));
    }

    abi::Name rec::nameOff(reflect::rtype* t, golang::reflect::aNameOff off)
    {
        return gocpp::Init<abi::Name>([=](auto& x) {
            x.Bytes = (unsigned char*)(resolveNameOff(unsafe::Pointer(t), int32_t(off)));
        });
    }

    abi::Type* rec::typeOff(reflect::rtype* t, golang::reflect::aTypeOff off)
    {
        return (abi::Type*)(resolveTypeOff(unsafe::Pointer(t), int32_t(off)));
    }

    unsafe::Pointer rec::textOff(reflect::rtype* t, golang::reflect::aTextOff off)
    {
        return resolveTextOff(unsafe::Pointer(t), int32_t(off));
    }

    unsafe::Pointer textOffFor(abi::Type* t, golang::reflect::aTextOff off)
    {
        return rec::textOff(gocpp::recv(toRType(t)), off);
    }

    std::string rec::String(reflect::rtype* t)
    {
        auto s = rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), t->t.Str)));
        if(t->t.TFlag & abi::TFlagExtraStar != 0)
        {
            return s.make_slice(1);
        }
        return s;
    }

    uintptr_t rec::Size(reflect::rtype* t)
    {
        return rec::Size(gocpp::recv(t->t));
    }

    int rec::Bits(reflect::rtype* t)
    {
        if(t == nullptr)
        {
            gocpp::panic("reflect: Bits of nil Type"s);
        }
        auto k = rec::Kind(gocpp::recv(t));
        if(k < Int || k > Complex128)
        {
            gocpp::panic("reflect: Bits of non-arithmetic Type "s + rec::String(gocpp::recv(t)));
        }
        return int(t->t.Size_) * 8;
    }

    int rec::Align(reflect::rtype* t)
    {
        return rec::Align(gocpp::recv(t->t));
    }

    int rec::FieldAlign(reflect::rtype* t)
    {
        return rec::FieldAlign(gocpp::recv(t->t));
    }

    reflect::Kind rec::Kind(reflect::rtype* t)
    {
        return Kind(rec::Kind(gocpp::recv(t->t)));
    }

    gocpp::slice<abi::Method> rec::exportedMethods(reflect::rtype* t)
    {
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return nullptr;
        }
        return rec::ExportedMethods(gocpp::recv(ut));
    }

    int rec::NumMethod(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return rec::NumMethod(gocpp::recv(tt));
        }
        return len(rec::exportedMethods(gocpp::recv(t)));
    }

    struct Method rec::Method(reflect::rtype* t, int i)
    {
        struct Method m;
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return rec::Method(gocpp::recv(tt), i);
        }
        auto methods = rec::exportedMethods(gocpp::recv(t));
        if(i < 0 || i >= len(methods))
        {
            gocpp::panic("reflect: Method index out of range"s);
        }
        auto p = methods[i];
        auto pname = rec::nameOff(gocpp::recv(t), p.Name);
        m.Name = rec::Name(gocpp::recv(pname));
        auto fl = flag(Func);
        auto mtyp = rec::typeOff(gocpp::recv(t), p.Mtyp);
        auto ft = (reflect::funcType*)(unsafe::Pointer(mtyp));
        auto in = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), 0, 1 + rec::NumIn(gocpp::recv(ft)));
        in = append(in, t);
        for(auto [gocpp_ignored, arg] : rec::InSlice(gocpp::recv(ft)))
        {
            in = append(in, toRType(arg));
        }
        auto out = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), 0, rec::NumOut(gocpp::recv(ft)));
        for(auto [gocpp_ignored, ret] : rec::OutSlice(gocpp::recv(ft)))
        {
            out = append(out, toRType(ret));
        }
        auto mt = FuncOf(in, out, rec::IsVariadic(gocpp::recv(ft)));
        m.Type = mt;
        auto tfn = rec::textOff(gocpp::recv(t), p.Tfn);
        auto fn = unsafe::Pointer(& tfn);
        m.Func = Value {& gocpp::getValue<reflect::rtype*>(mt)->t, fn, fl};
        m.Index = i;
        return m;
    }

    std::tuple<struct Method, bool> rec::MethodByName(reflect::rtype* t, std::string name)
    {
        struct Method m;
        bool ok;
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return rec::MethodByName(gocpp::recv(tt), name);
        }
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return {Method {}, false};
        }
        auto methods = rec::ExportedMethods(gocpp::recv(ut));
        auto [i, j] = std::tuple{0, len(methods)};
        for(; i < j; )
        {
            auto h = int((unsigned int)(i + j) >> 1);
            if(! (rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), methods[h].Name))) >= name))
            {
                i = h + 1;
            }
            else
            {
                j = h;
            }
        }
        if(i < len(methods) && name == rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), methods[i].Name))))
        {
            return {rec::Method(gocpp::recv(t), i), true};
        }
        return {Method {}, false};
    }

    std::string rec::PkgPath(reflect::rtype* t)
    {
        if(t->t.TFlag & abi::TFlagNamed == 0)
        {
            return ""s;
        }
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return ""s;
        }
        return rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), ut->PkgPath)));
    }

    std::string pkgPathFor(abi::Type* t)
    {
        return rec::PkgPath(gocpp::recv(toRType(t)));
    }

    std::string rec::Name(reflect::rtype* t)
    {
        if(! rec::HasName(gocpp::recv(t->t)))
        {
            return ""s;
        }
        auto s = rec::String(gocpp::recv(t));
        auto i = len(s) - 1;
        auto sqBrackets = 0;
        for(; i >= 0 && (s[i] != '.' || sqBrackets != 0); )
        {
            //Go switch emulation
            {
                auto condition = s[i];
                int conditionId = -1;
                if(condition == ']') { conditionId = 0; }
                else if(condition == '[') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        sqBrackets++;
                        break;
                    case 1:
                        sqBrackets--;
                        break;
                }
            }
            i--;
        }
        return s.make_slice(i + 1);
    }

    std::string nameFor(abi::Type* t)
    {
        return rec::Name(gocpp::recv(toRType(t)));
    }

    reflect::ChanDir rec::ChanDir(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Chan)
        {
            gocpp::panic("reflect: ChanDir of non-chan type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::ChanType*)(unsafe::Pointer(t));
        return ChanDir(tt->Dir);
    }

    reflect::rtype* toRType(abi::Type* t)
    {
        return (reflect::rtype*)(unsafe::Pointer(t));
    }

    abi::Type* elem(abi::Type* t)
    {
        auto et = rec::Elem(gocpp::recv(t));
        if(et != nullptr)
        {
            return et;
        }
        gocpp::panic("reflect: Elem of invalid type "s + stringFor(t));
    }

    struct Type rec::Elem(reflect::rtype* t)
    {
        return toType(elem(rec::common(gocpp::recv(t))));
    }

    struct StructField rec::Field(reflect::rtype* t, int i)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: Field of non-struct type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::Field(gocpp::recv(tt), i);
    }

    struct StructField rec::FieldByIndex(reflect::rtype* t, gocpp::slice<int> index)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByIndex of non-struct type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::FieldByIndex(gocpp::recv(tt), index);
    }

    std::tuple<struct StructField, bool> rec::FieldByName(reflect::rtype* t, std::string name)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByName of non-struct type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::FieldByName(gocpp::recv(tt), name);
    }

    std::tuple<struct StructField, bool> rec::FieldByNameFunc(reflect::rtype* t, std::function<bool (std::string _1)> match)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByNameFunc of non-struct type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::FieldByNameFunc(gocpp::recv(tt), match);
    }

    struct Type rec::Key(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Map)
        {
            gocpp::panic("reflect: Key of non-map type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (mapType*)(unsafe::Pointer(t));
        return toType(tt->Key);
    }

    int rec::Len(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Array)
        {
            gocpp::panic("reflect: Len of non-array type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (reflect::arrayType*)(unsafe::Pointer(t));
        return int(tt->Len);
    }

    int rec::NumField(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: NumField of non-struct type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return len(tt->Fields);
    }

    struct Type rec::In(reflect::rtype* t, int i)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: In of non-func type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return toType(rec::InSlice(gocpp::recv(tt))[i]);
    }

    int rec::NumIn(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: NumIn of non-func type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return rec::NumIn(gocpp::recv(tt));
    }

    int rec::NumOut(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: NumOut of non-func type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return rec::NumOut(gocpp::recv(tt));
    }

    struct Type rec::Out(reflect::rtype* t, int i)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: Out of non-func type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return toType(rec::OutSlice(gocpp::recv(tt))[i]);
    }

    bool rec::IsVariadic(reflect::rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: IsVariadic of non-func type "s + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return rec::IsVariadic(gocpp::recv(tt));
    }

    // add returns p+x.
    //
    // The whySafe string is ignored, so that the function still inlines
    // as efficiently as p+x, but all call sites should use the string to
    // record why the addition is safe, which is to say why the addition
    // does not cause x to advance to the very end of p's allocation
    // and therefore point incorrectly at the next block in memory.
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    std::string rec::String(golang::reflect::ChanDir d)
    {
        //Go switch emulation
        {
            auto condition = d;
            int conditionId = -1;
            if(condition == SendDir) { conditionId = 0; }
            else if(condition == RecvDir) { conditionId = 1; }
            else if(condition == BothDir) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return "chan<-"s;
                    break;
                case 1:
                    return "<-chan"s;
                    break;
                case 2:
                    return "chan"s;
                    break;
            }
        }
        return "ChanDir"s + strconv::Itoa(int(d));
    }

    // Method returns the i'th method in the type's method set.
    struct Method rec::Method(struct interfaceType* t, int i)
    {
        struct Method m;
        if(i < 0 || i >= len(t->Methods))
        {
            return m;
        }
        auto p = & t->Methods[i];
        auto pname = rec::nameOff(gocpp::recv(t), p->Name);
        m.Name = rec::Name(gocpp::recv(pname));
        if(! rec::IsExported(gocpp::recv(pname)))
        {
            m.PkgPath = pkgPath(pname);
            if(m.PkgPath == ""s)
            {
                m.PkgPath = rec::Name(gocpp::recv(t->PkgPath));
            }
        }
        m.Type = toType(rec::typeOff(gocpp::recv(t), p->Typ));
        m.Index = i;
        return m;
    }

    // NumMethod returns the number of interface methods in the type's method set.
    int rec::NumMethod(struct interfaceType* t)
    {
        return len(t->Methods);
    }

    // MethodByName method with the given name in the type's method set.
    std::tuple<struct Method, bool> rec::MethodByName(struct interfaceType* t, std::string name)
    {
        struct Method m;
        bool ok;
        if(t == nullptr)
        {
            return {m, ok};
        }
        abi::Imethod* p = {};
        for(auto [i, gocpp_ignored] : t->Methods)
        {
            p = & t->Methods[i];
            if(rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), p->Name))) == name)
            {
                return {rec::Method(gocpp::recv(t), i), true};
            }
        }
        return {m, ok};
    }

    // A StructField describes a single field in a struct.
    
    template<typename T> requires gocpp::GoStruct<T>
    StructField::operator T()
    {
        T result;
        result.Name = this->Name;
        result.PkgPath = this->PkgPath;
        result.Type = this->Type;
        result.Tag = this->Tag;
        result.Offset = this->Offset;
        result.Index = this->Index;
        result.Anonymous = this->Anonymous;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StructField::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (PkgPath != ref.PkgPath) return false;
        if (Type != ref.Type) return false;
        if (Tag != ref.Tag) return false;
        if (Offset != ref.Offset) return false;
        if (Index != ref.Index) return false;
        if (Anonymous != ref.Anonymous) return false;
        return true;
    }

    std::ostream& StructField::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << PkgPath;
        os << " " << Type;
        os << " " << Tag;
        os << " " << Offset;
        os << " " << Index;
        os << " " << Anonymous;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructField& value)
    {
        return value.PrintTo(os);
    }

    // IsExported reports whether the field is exported.
    bool rec::IsExported(struct StructField f)
    {
        return f.PkgPath == ""s;
    }

    // A StructTag is the tag string in a struct field.
    //
    // By convention, tag strings are a concatenation of
    // optionally space-separated key:"value" pairs.
    // Each key is a non-empty string consisting of non-control
    // characters other than space (U+0020 ' '), quote (U+0022 '"'),
    // and colon (U+003A ':').  Each value is quoted using U+0022 '"'
    // characters and Go string literal syntax.
    // Get returns the value associated with key in the tag string.
    // If there is no such key in the tag, Get returns the empty string.
    // If the tag does not have the conventional format, the value
    // returned by Get is unspecified. To determine whether a tag is
    // explicitly set to the empty string, use Lookup.
    std::string rec::Get(golang::reflect::StructTag tag, std::string key)
    {
        auto [v, gocpp_id_0] = rec::Lookup(gocpp::recv(tag), key);
        return v;
    }

    // Lookup returns the value associated with key in the tag string.
    // If the key is present in the tag the value (which may be empty)
    // is returned. Otherwise the returned value will be the empty string.
    // The ok return value reports whether the value was explicitly set in
    // the tag string. If the tag does not have the conventional format,
    // the value returned by Lookup is unspecified.
    std::tuple<std::string, bool> rec::Lookup(golang::reflect::StructTag tag, std::string key)
    {
        std::string value;
        bool ok;
        for(; tag != ""s; )
        {
            auto i = 0;
            for(; i < len(tag) && tag[i] == ' '; )
            {
                i++;
            }
            tag = tag.make_slice(i);
            if(tag == ""s)
            {
                break;
            }
            i = 0;
            for(; i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '"' && tag[i] != 0x7f; )
            {
                i++;
            }
            if(i == 0 || i + 1 >= len(tag) || tag[i] != ':' || tag[i + 1] != '"')
            {
                break;
            }
            auto name = std::string(tag.make_slice(0, i));
            tag = tag.make_slice(i + 1);
            i = 1;
            for(; i < len(tag) && tag[i] != '"'; )
            {
                if(tag[i] == '\\')
                {
                    i++;
                }
                i++;
            }
            if(i >= len(tag))
            {
                break;
            }
            auto qvalue = std::string(tag.make_slice(0, i + 1));
            tag = tag.make_slice(i + 1);
            if(key == name)
            {
                auto [value, err] = strconv::Unquote(qvalue);
                if(err != nullptr)
                {
                    break;
                }
                return {value, true};
            }
        }
        return {""s, false};
    }

    // Field returns the i'th struct field.
    struct StructField rec::Field(struct structType* t, int i)
    {
        struct StructField f;
        if(i < 0 || i >= len(t->Fields))
        {
            gocpp::panic("reflect: Field index out of bounds"s);
        }
        auto p = & t->Fields[i];
        f.Type = toType(p->Typ);
        f.Name = rec::Name(gocpp::recv(p->Name));
        f.Anonymous = rec::Embedded(gocpp::recv(p));
        if(! rec::IsExported(gocpp::recv(p->Name)))
        {
            f.PkgPath = rec::Name(gocpp::recv(t->PkgPath));
        }
        if(auto tag = rec::Tag(gocpp::recv(p->Name)); tag != ""s)
        {
            f.Tag = StructTag(tag);
        }
        f.Offset = p->Offset;
        f.Index = gocpp::slice<int> {i};
        return f;
    }

    // FieldByIndex returns the nested field corresponding to index.
    struct StructField rec::FieldByIndex(struct structType* t, gocpp::slice<int> index)
    {
        struct StructField f;
        f.Type = toType(& t->Type);
        for(auto [i, x] : index)
        {
            if(i > 0)
            {
                auto ft = f.Type;
                if(rec::Kind(gocpp::recv(ft)) == Pointer && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(ft)))) == Struct)
                {
                    ft = rec::Elem(gocpp::recv(ft));
                }
                f.Type = ft;
            }
            f = rec::Field(gocpp::recv(f.Type), x);
        }
        return f;
    }

    // A fieldScan represents an item on the fieldByNameFunc scan work list.
    
    template<typename T> requires gocpp::GoStruct<T>
    fieldScan::operator T()
    {
        T result;
        result.typ = this->typ;
        result.index = this->index;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fieldScan::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (index != ref.index) return false;
        return true;
    }

    std::ostream& fieldScan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fieldScan& value)
    {
        return value.PrintTo(os);
    }

    // FieldByNameFunc returns the struct field with a name that satisfies the
    // match function and a boolean to indicate if the field was found.
    std::tuple<struct StructField, bool> rec::FieldByNameFunc(struct structType* t, std::function<bool (std::string _1)> match)
    {
        struct StructField result;
        bool ok;
        auto current = gocpp::slice<fieldScan> {};
        auto next = gocpp::slice<fieldScan> {gocpp::Init<>([=](auto& x) {
            x.typ = t;
        })};
        // nextCount records the number of times an embedded type has been
        // encountered and considered for queueing in the 'next' slice.
        // We only queue the first one, but we increment the count on each.
        // If a struct type T can be reached more than once at a given depth level,
        // then it annihilates itself and need not be considered at all when we
        // process that next depth level.
        gocpp::map<structType*, int> nextCount = {};
        auto visited = gocpp::map<structType*, bool> {};
        for(; len(next) > 0; )
        {
            std::tie(current, next) = std::tuple{next, current.make_slice(0, 0)};
            auto count = nextCount;
            nextCount = nullptr;
            for(auto [gocpp_ignored, scan] : current)
            {
                auto t = scan.typ;
                if(visited[t])
                {
                    continue;
                }
                visited[t] = true;
                for(auto [i, gocpp_ignored] : t->Fields)
                {
                    auto f = & t->Fields[i];
                    auto fname = rec::Name(gocpp::recv(f->Name));
                    abi::Type* ntyp = {};
                    if(rec::Embedded(gocpp::recv(f)))
                    {
                        ntyp = f->Typ;
                        if(rec::Kind(gocpp::recv(ntyp)) == abi::Pointer)
                        {
                            ntyp = rec::Elem(gocpp::recv(ntyp));
                        }
                    }
                    if(match(fname))
                    {
                        if(count[t] > 1 || ok)
                        {
                            return {StructField {}, false};
                        }
                        result = rec::Field(gocpp::recv(t), i);
                        result.Index = nullptr;
                        result.Index = append(result.Index, scan.index);
                        result.Index = append(result.Index, i);
                        ok = true;
                        continue;
                    }
                    if(ok || ntyp == nullptr || rec::Kind(gocpp::recv(ntyp)) != abi::Struct)
                    {
                        continue;
                    }
                    auto styp = (structType*)(unsafe::Pointer(ntyp));
                    if(nextCount[styp] > 0)
                    {
                        nextCount[styp] = 2;
                        continue;
                    }
                    if(nextCount == nullptr)
                    {
                        nextCount = gocpp::map<structType*, int> {};
                    }
                    nextCount[styp] = 1;
                    if(count[t] > 1)
                    {
                        nextCount[styp] = 2;
                    }
                    gocpp::slice<int> index = {};
                    index = append(index, scan.index);
                    index = append(index, i);
                    next = append(next, fieldScan {styp, index});
                }
            }
            if(ok)
            {
                break;
            }
        }
        return {result, ok};
    }

    // FieldByName returns the struct field with the given name
    // and a boolean to indicate if the field was found.
    std::tuple<struct StructField, bool> rec::FieldByName(struct structType* t, std::string name)
    {
        struct StructField f;
        bool present;
        auto hasEmbeds = false;
        if(name != ""s)
        {
            for(auto [i, gocpp_ignored] : t->Fields)
            {
                auto tf = & t->Fields[i];
                if(rec::Name(gocpp::recv(tf->Name)) == name)
                {
                    return {rec::Field(gocpp::recv(t), i), true};
                }
                if(rec::Embedded(gocpp::recv(tf)))
                {
                    hasEmbeds = true;
                }
            }
        }
        if(! hasEmbeds)
        {
            return {f, present};
        }
        return rec::FieldByNameFunc(gocpp::recv(t), [=](std::string s) mutable -> bool
        {
            return s == name;
        });
    }

    // TypeOf returns the reflection [Type] that represents the dynamic type of i.
    // If i is a nil interface value, TypeOf returns nil.
    struct Type TypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return toType((abi::Type*)(noescape(unsafe::Pointer(eface.typ))));
    }

    // rtypeOf directly extracts the *rtype of the provided value.
    abi::Type* rtypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return eface.typ;
    }

    // ptrMap is the cache for PointerTo.
    sync::Map ptrMap;
    // PtrTo returns the pointer type with element t.
    // For example, if t represents type Foo, PtrTo(t) represents *Foo.
    //
    // PtrTo is the old spelling of [PointerTo].
    // The two functions behave identically.
    //
    // Deprecated: Superseded by [PointerTo].
    struct Type PtrTo(struct Type t)
    {
        return PointerTo(t);
    }

    // PointerTo returns the pointer type with element t.
    // For example, if t represents type Foo, PointerTo(t) represents *Foo.
    struct Type PointerTo(struct Type t)
    {
        return toRType(rec::ptrTo(gocpp::recv(gocpp::getValue<reflect::rtype*>(t))));
    }

    abi::Type* rec::ptrTo(reflect::rtype* t)
    {
        auto at = & t->t;
        if(at->PtrToThis != 0)
        {
            return rec::typeOff(gocpp::recv(t), at->PtrToThis);
        }
        if(auto [pi, ok] = rec::Load(gocpp::recv(ptrMap), t); ok)
        {
            return & gocpp::getValue<ptrType*>(pi)->Type;
        }
        auto s = "*"s + rec::String(gocpp::recv(t));
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto p = (ptrType*)(unsafe::Pointer(tt));
            if(p->Elem != & t->t)
            {
                continue;
            }
            auto [pi, gocpp_id_1] = rec::LoadOrStore(gocpp::recv(ptrMap), t, p);
            return & gocpp::getValue<ptrType*>(pi)->Type;
        }
        // Create a new ptrType starting with the description
        // of an *unsafe.Pointer.
        go_any iptr = (unsafe::Pointer*)(nullptr);
        auto prototype = *(ptrType**)(unsafe::Pointer(& iptr));
        auto pp = *prototype;
        pp.Str = resolveReflectName(newName(s, ""s, false, false));
        pp.PtrToThis = 0;
        pp.Hash = fnv1(t->t.Hash, '*');
        pp.Elem = at;
        auto [pi, gocpp_id_2] = rec::LoadOrStore(gocpp::recv(ptrMap), t, & pp);
        return & gocpp::getValue<ptrType*>(pi)->Type;
    }

    abi::Type* ptrTo(abi::Type* t)
    {
        return rec::ptrTo(gocpp::recv(toRType(t)));
    }

    // fnv1 incorporates the list of bytes into the hash x using the FNV-1 hash function.
    uint32_t fnv1(uint32_t x, gocpp::slice<unsigned char> list)
    {
        for(auto [gocpp_ignored, b] : list)
        {
            x = x * 16777619 ^ uint32_t(b);
        }
        return x;
    }

    bool rec::Implements(reflect::rtype* t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.Implements"s);
        }
        if(rec::Kind(gocpp::recv(u)) != Interface)
        {
            gocpp::panic("reflect: non-interface type passed to Type.Implements"s);
        }
        return implements(rec::common(gocpp::recv(u)), rec::common(gocpp::recv(t)));
    }

    bool rec::AssignableTo(reflect::rtype* t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.AssignableTo"s);
        }
        auto uu = rec::common(gocpp::recv(u));
        return directlyAssignable(uu, rec::common(gocpp::recv(t))) || implements(uu, rec::common(gocpp::recv(t)));
    }

    bool rec::ConvertibleTo(reflect::rtype* t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.ConvertibleTo"s);
        }
        return convertOp(rec::common(gocpp::recv(u)), rec::common(gocpp::recv(t))) != nullptr;
    }

    bool rec::Comparable(reflect::rtype* t)
    {
        return t->t.Equal != nullptr;
    }

    // implements reports whether the type V implements the interface type T.
    bool implements(abi::Type* T, abi::Type* V)
    {
        if(rec::Kind(gocpp::recv(T)) != abi::Interface)
        {
            return false;
        }
        auto t = (interfaceType*)(unsafe::Pointer(T));
        if(len(t->Methods) == 0)
        {
            return true;
        }
        if(rec::Kind(gocpp::recv(V)) == abi::Interface)
        {
            auto v = (interfaceType*)(unsafe::Pointer(V));
            auto i = 0;
            for(auto j = 0; j < len(v->Methods); j++)
            {
                auto tm = & t->Methods[i];
                auto tmName = rec::nameOff(gocpp::recv(t), tm->Name);
                auto vm = & v->Methods[j];
                auto vmName = nameOffFor(V, vm->Name);
                if(rec::Name(gocpp::recv(vmName)) == rec::Name(gocpp::recv(tmName)) && typeOffFor(V, vm->Typ) == rec::typeOff(gocpp::recv(t), tm->Typ))
                {
                    if(! rec::IsExported(gocpp::recv(tmName)))
                    {
                        auto tmPkgPath = pkgPath(tmName);
                        if(tmPkgPath == ""s)
                        {
                            tmPkgPath = rec::Name(gocpp::recv(t->PkgPath));
                        }
                        auto vmPkgPath = pkgPath(vmName);
                        if(vmPkgPath == ""s)
                        {
                            vmPkgPath = rec::Name(gocpp::recv(v->PkgPath));
                        }
                        if(tmPkgPath != vmPkgPath)
                        {
                            continue;
                        }
                    }
                    if(i++; i >= len(t->Methods))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        auto v = rec::Uncommon(gocpp::recv(V));
        if(v == nullptr)
        {
            return false;
        }
        auto i = 0;
        auto vmethods = rec::Methods(gocpp::recv(v));
        for(auto j = 0; j < int(v->Mcount); j++)
        {
            auto tm = & t->Methods[i];
            auto tmName = rec::nameOff(gocpp::recv(t), tm->Name);
            auto vm = vmethods[j];
            auto vmName = nameOffFor(V, vm.Name);
            if(rec::Name(gocpp::recv(vmName)) == rec::Name(gocpp::recv(tmName)) && typeOffFor(V, vm.Mtyp) == rec::typeOff(gocpp::recv(t), tm->Typ))
            {
                if(! rec::IsExported(gocpp::recv(tmName)))
                {
                    auto tmPkgPath = pkgPath(tmName);
                    if(tmPkgPath == ""s)
                    {
                        tmPkgPath = rec::Name(gocpp::recv(t->PkgPath));
                    }
                    auto vmPkgPath = pkgPath(vmName);
                    if(vmPkgPath == ""s)
                    {
                        vmPkgPath = rec::Name(gocpp::recv(nameOffFor(V, v->PkgPath)));
                    }
                    if(tmPkgPath != vmPkgPath)
                    {
                        continue;
                    }
                }
                if(i++; i >= len(t->Methods))
                {
                    return true;
                }
            }
        }
        return false;
    }

    // specialChannelAssignability reports whether a value x of channel type V
    // can be directly assigned (using memmove) to another channel type T.
    // https://golang.org/doc/go_spec.html#Assignability
    // T and V must be both of Chan kind.
    bool specialChannelAssignability(abi::Type* T, abi::Type* V)
    {
        return rec::ChanDir(gocpp::recv(V)) == abi::BothDir && (nameFor(T) == ""s || nameFor(V) == ""s) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), true);
    }

    // directlyAssignable reports whether a value x of type V can be directly
    // assigned (using memmove) to a value of type T.
    // https://golang.org/doc/go_spec.html#Assignability
    // Ignoring the interface rules (implemented elsewhere)
    // and the ideal constant rules (no ideal constants at run time).
    bool directlyAssignable(abi::Type* T, abi::Type* V)
    {
        if(T == V)
        {
            return true;
        }
        if(rec::HasName(gocpp::recv(T)) && rec::HasName(gocpp::recv(V)) || rec::Kind(gocpp::recv(T)) != rec::Kind(gocpp::recv(V)))
        {
            return false;
        }
        if(rec::Kind(gocpp::recv(T)) == abi::Chan && specialChannelAssignability(T, V))
        {
            return true;
        }
        return haveIdenticalUnderlyingType(T, V, true);
    }

    bool haveIdenticalType(abi::Type* T, abi::Type* V, bool cmpTags)
    {
        if(cmpTags)
        {
            return T == V;
        }
        if(nameFor(T) != nameFor(V) || rec::Kind(gocpp::recv(T)) != rec::Kind(gocpp::recv(V)) || pkgPathFor(T) != pkgPathFor(V))
        {
            return false;
        }
        return haveIdenticalUnderlyingType(T, V, false);
    }

    bool haveIdenticalUnderlyingType(abi::Type* T, abi::Type* V, bool cmpTags)
    {
        if(T == V)
        {
            return true;
        }
        auto kind = Kind(rec::Kind(gocpp::recv(T)));
        if(kind != Kind(rec::Kind(gocpp::recv(V))))
        {
            return false;
        }
        if(Bool <= kind && kind <= Complex128 || kind == String || kind == UnsafePointer)
        {
            return true;
        }
        //Go switch emulation
        {
            auto condition = kind;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Func) { conditionId = 2; }
            else if(condition == Interface) { conditionId = 3; }
            else if(condition == Map) { conditionId = 4; }
            else if(condition == Pointer) { conditionId = 5; }
            else if(condition == Slice) { conditionId = 6; }
            else if(condition == Struct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return rec::Len(gocpp::recv(T)) == rec::Len(gocpp::recv(V)) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 1:
                    return rec::ChanDir(gocpp::recv(V)) == rec::ChanDir(gocpp::recv(T)) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 2:
                    auto t = (reflect::funcType*)(unsafe::Pointer(T));
                    auto v = (reflect::funcType*)(unsafe::Pointer(V));
                    if(t->OutCount != v->OutCount || t->InCount != v->InCount)
                    {
                        return false;
                    }
                    for(auto i = 0; i < rec::NumIn(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(rec::In(gocpp::recv(t), i), rec::In(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    for(auto i = 0; i < rec::NumOut(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(rec::Out(gocpp::recv(t), i), rec::Out(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 3:
                    auto t = (interfaceType*)(unsafe::Pointer(T));
                    auto v = (interfaceType*)(unsafe::Pointer(V));
                    if(len(t->Methods) == 0 && len(v->Methods) == 0)
                    {
                        return true;
                    }
                    return false;
                    break;
                case 4:
                    return haveIdenticalType(rec::Key(gocpp::recv(T)), rec::Key(gocpp::recv(V)), cmpTags) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 5:
                case 6:
                    return haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 7:
                    auto t = (structType*)(unsafe::Pointer(T));
                    auto v = (structType*)(unsafe::Pointer(V));
                    if(len(t->Fields) != len(v->Fields))
                    {
                        return false;
                    }
                    if(rec::Name(gocpp::recv(t->PkgPath)) != rec::Name(gocpp::recv(v->PkgPath)))
                    {
                        return false;
                    }
                    for(auto [i, gocpp_ignored] : t->Fields)
                    {
                        auto tf = & t->Fields[i];
                        auto vf = & v->Fields[i];
                        if(rec::Name(gocpp::recv(tf->Name)) != rec::Name(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(! haveIdenticalType(tf->Typ, vf->Typ, cmpTags))
                        {
                            return false;
                        }
                        if(cmpTags && rec::Tag(gocpp::recv(tf->Name)) != rec::Tag(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(tf->Offset != vf->Offset)
                        {
                            return false;
                        }
                        if(rec::Embedded(gocpp::recv(tf)) != rec::Embedded(gocpp::recv(vf)))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
            }
        }
        return false;
    }

    // typelinks is implemented in package runtime.
    // It returns a slice of the sections in each module,
    // and a slice of *rtype offsets in each module.
    //
    // The types in each module are sorted by string. That is, the first
    // two linked types of the first module are:
    //
    //	d0 := sections[0]
    //	t1 := (*rtype)(add(d0, offset[0][0]))
    //	t2 := (*rtype)(add(d0, offset[0][1]))
    //
    // and
    //
    //	t1.String() < t2.String()
    //
    // Note that strings are not unique identifiers for types:
    // there can be more than one with a given string.
    // Only types we might want to look up are included:
    // pointers, channels, maps, slices, and arrays.
    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> typelinks()
    /* convertBlockStmt, nil block */;

    abi::Type* rtypeOff(unsafe::Pointer section, int32_t off)
    {
        return (abi::Type*)(add(section, uintptr_t(off), "sizeof(rtype) > 0"s));
    }

    // typesByString returns the subslice of typelinks() whose elements have
    // the given string representation.
    // It may be empty (no known types with that string) or may have
    // multiple elements (multiple types with that string).
    gocpp::slice<abi::Type*> typesByString(std::string s)
    {
        auto [sections, offset] = typelinks();
        gocpp::slice<abi::Type*> ret = {};
        for(auto [offsI, offs] : offset)
        {
            auto section = sections[offsI];
            auto [i, j] = std::tuple{0, len(offs)};
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(! (stringFor(rtypeOff(section, offs[h])) >= s))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto j = i; j < len(offs); j++)
            {
                auto typ = rtypeOff(section, offs[j]);
                if(stringFor(typ) != s)
                {
                    break;
                }
                ret = append(ret, typ);
            }
        }
        return ret;
    }

    // The lookupCache caches ArrayOf, ChanOf, MapOf and SliceOf lookups.
    sync::Map lookupCache;
    // A cacheKey is the key for use in the lookupCache.
    // Four values describe any of the types we are looking for:
    // type kind, one or two subtypes, and an extra integer.
    
    template<typename T> requires gocpp::GoStruct<T>
    cacheKey::operator T()
    {
        T result;
        result.kind = this->kind;
        result.t1 = this->t1;
        result.t2 = this->t2;
        result.extra = this->extra;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cacheKey::operator==(const T& ref) const
    {
        if (kind != ref.kind) return false;
        if (t1 != ref.t1) return false;
        if (t2 != ref.t2) return false;
        if (extra != ref.extra) return false;
        return true;
    }

    std::ostream& cacheKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << t1;
        os << " " << t2;
        os << " " << extra;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cacheKey& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_3
    {
        mocklib::Mutex Mutex;
        sync::Map m;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.Mutex = this->Mutex;
            result.m = this->m;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (Mutex != ref.Mutex) return false;
            if (m != ref.m) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << Mutex;
            os << " " << m;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value)
    {
        return value.PrintTo(os);
    }


    // The funcLookupCache caches FuncOf lookups.
    // FuncOf does not share the common lookupCache since cacheKey is not
    // sufficient to represent functions unambiguously.
    gocpp_id_3 funcLookupCache;
    // ChanOf returns the channel type with the given direction and element type.
    // For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.
    //
    // The gc runtime imposes a limit of 64 kB on channel element types.
    // If t's size is equal to or exceeds this limit, ChanOf panics.
    struct Type ChanOf(golang::reflect::ChanDir dir, struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ckey = cacheKey {Chan, typ, nullptr, uintptr_t(dir)};
        if(auto [ch, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<reflect::rtype*>(ch);
        }
        if(typ->Size_ >= (1 << 16))
        {
            gocpp::panic("reflect.ChanOf: element size too large"s);
        }
        // Look in known types.
        std::string s = {};
        //Go switch emulation
        {
            auto condition = dir;
            int conditionId = -1;
            if(condition == SendDir) { conditionId = 0; }
            else if(condition == RecvDir) { conditionId = 1; }
            else if(condition == BothDir) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    gocpp::panic("reflect.ChanOf: invalid dir"s);
                    break;
                case 0:
                    s = "chan<- "s + stringFor(typ);
                    break;
                case 1:
                    s = "<-chan "s + stringFor(typ);
                    break;
                case 2:
                    auto typeStr = stringFor(typ);
                    if(typeStr[0] == '<')
                    {
                        s = "chan ("s + typeStr + ")"s;
                    }
                    else
                    {
                        s = "chan "s + typeStr;
                    }
                    break;
            }
        }
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto ch = (reflect::chanType*)(unsafe::Pointer(tt));
            if(ch->Elem == typ && ch->Dir == abi::ChanDir(dir))
            {
                auto [ti, gocpp_id_4] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        // Make a channel type.
        go_any ichan = (gocpp::channel<unsafe::Pointer>)(nullptr);
        auto prototype = *(reflect::chanType**)(unsafe::Pointer(& ichan));
        auto ch = *prototype;
        ch.TFlag = abi::TFlagRegularMemory;
        ch.Dir = abi::ChanDir(dir);
        ch.Str = resolveReflectName(newName(s, ""s, false, false));
        ch.Hash = fnv1(typ->Hash, 'c', (unsigned char)(dir));
        ch.Elem = typ;
        auto [ti, gocpp_id_5] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& ch.Type));
        return gocpp::getValue<Type>(ti);
    }

    // MapOf returns the map type with the given key and element types.
    // For example, if k represents int and e represents string,
    // MapOf(k, e) represents map[int]string.
    //
    // If the key type is not a valid map key type (that is, if it does
    // not implement Go's == operator), MapOf panics.
    struct Type MapOf(struct Type key, struct Type elem)
    {
        auto ktyp = rec::common(gocpp::recv(key));
        auto etyp = rec::common(gocpp::recv(elem));
        if(ktyp->Equal == nullptr)
        {
            gocpp::panic("reflect.MapOf: invalid key type "s + stringFor(ktyp));
        }
        auto ckey = cacheKey {Map, ktyp, etyp, 0};
        if(auto [mt, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(mt);
        }
        auto s = "map["s + stringFor(ktyp) + "]"s + stringFor(etyp);
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto mt = (mapType*)(unsafe::Pointer(tt));
            if(mt->Key == ktyp && mt->Elem == etyp)
            {
                auto [ti, gocpp_id_6] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        // Make a map type.
        // Note: flag values must match those used in the TMAP case
        // in ../cmd/compile/internal/reflectdata/reflect.go:writeType.
        go_any imap = (gocpp::map<unsafe::Pointer, unsafe::Pointer>)(nullptr);
        auto mt = **(mapType**)(unsafe::Pointer(& imap));
        mt.Str = resolveReflectName(newName(s, ""s, false, false));
        mt.TFlag = 0;
        mt.Hash = fnv1(etyp->Hash, 'm', (unsigned char)(ktyp->Hash >> 24), (unsigned char)(ktyp->Hash >> 16), (unsigned char)(ktyp->Hash >> 8), (unsigned char)(ktyp->Hash));
        mt.Key = ktyp;
        mt.Elem = etyp;
        mt.Bucket = bucketOf(ktyp, etyp);
        mt.Hasher = [=](unsafe::Pointer p, uintptr_t seed) mutable -> uintptr_t
        {
            return typehash(ktyp, p, seed);
        };
        mt.Flags = 0;
        if(ktyp->Size_ > maxKeySize)
        {
            mt.KeySize = uint8_t(goarch::PtrSize);
            mt.Flags |= 1;
        }
        else
        {
            mt.KeySize = uint8_t(ktyp->Size_);
        }
        if(etyp->Size_ > maxValSize)
        {
            mt.ValueSize = uint8_t(goarch::PtrSize);
            mt.Flags |= 2;
        }
        else
        {
            mt.MapType.ValueSize = uint8_t(etyp->Size_);
        }
        mt.MapType.BucketSize = uint16_t(mt.Bucket->Size_);
        if(isReflexive(ktyp))
        {
            mt.Flags |= 4;
        }
        if(needKeyUpdate(ktyp))
        {
            mt.Flags |= 8;
        }
        if(hashMightPanic(ktyp))
        {
            mt.Flags |= 16;
        }
        mt.PtrToThis = 0;
        auto [ti, gocpp_id_7] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& mt.Type));
        return gocpp::getValue<Type>(ti);
    }

    gocpp::slice<Type> funcTypes;
    mocklib::Mutex funcTypesMutex;
    struct Type initFuncTypes(int n)
    {
        gocpp::Defer defer;
        try
        {
            rec::Lock(gocpp::recv(funcTypesMutex));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(funcTypesMutex)); });
            if(n >= len(funcTypes))
            {
                auto newFuncTypes = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), n + 1);
                copy(newFuncTypes, funcTypes);
                funcTypes = newFuncTypes;
            }
            if(funcTypes[n] != nullptr)
            {
                return funcTypes[n];
            }
            funcTypes[n] = StructOf(gocpp::slice<StructField> {gocpp::Init<>([=](auto& x) {
                x.Name = "FuncType"s;
                x.Type = TypeOf(reflect::funcType {});
            }), gocpp::Init<>([=](auto& x) {
                x.Name = "Args"s;
                x.Type = ArrayOf(n, TypeOf(new reflect::rtype {}));
            })});
            return funcTypes[n];
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // FuncOf returns the function type with the given argument and result types.
    // For example if k represents int and e represents string,
    // FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.
    //
    // The variadic argument controls whether the function is variadic. FuncOf
    // panics if the in[len(in)-1] does not represent a slice and variadic is
    // true.
    struct Type FuncOf(gocpp::slice<Type> in, gocpp::slice<Type> out, bool variadic)
    {
        gocpp::Defer defer;
        try
        {
            if(variadic && (len(in) == 0 || rec::Kind(gocpp::recv(in[len(in) - 1])) != Slice))
            {
                gocpp::panic("reflect.FuncOf: last arg of variadic func must be slice"s);
            }
            // Make a func type.
            go_any ifunc = (std::function<void ()>)(nullptr);
            auto prototype = *(reflect::funcType**)(unsafe::Pointer(& ifunc));
            auto n = len(in) + len(out);
            if(n > 128)
            {
                gocpp::panic("reflect.FuncOf: too many arguments"s);
            }
            auto o = rec::Elem(gocpp::recv(New(initFuncTypes(n))));
            auto ft = (reflect::funcType*)(unsafe::Pointer(rec::Pointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(o), 0)))))));
            auto args = unsafe::Slice((reflect::rtype**)(unsafe::Pointer(rec::Pointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(o), 1))))))), n).make_slice(0, 0, n);
            *ft = *prototype;
            // Build a hash and minimally populate ft.
            uint32_t hash = {};
            for(auto [gocpp_ignored, in] : in)
            {
                auto t = gocpp::getValue<reflect::rtype*>(in);
                args = append(args, t);
                hash = fnv1(hash, (unsigned char)(t->t.Hash >> 24), (unsigned char)(t->t.Hash >> 16), (unsigned char)(t->t.Hash >> 8), (unsigned char)(t->t.Hash));
            }
            if(variadic)
            {
                hash = fnv1(hash, 'v');
            }
            hash = fnv1(hash, '.');
            for(auto [gocpp_ignored, out] : out)
            {
                auto t = gocpp::getValue<reflect::rtype*>(out);
                args = append(args, t);
                hash = fnv1(hash, (unsigned char)(t->t.Hash >> 24), (unsigned char)(t->t.Hash >> 16), (unsigned char)(t->t.Hash >> 8), (unsigned char)(t->t.Hash));
            }
            ft->TFlag = 0;
            ft->Hash = hash;
            ft->InCount = uint16_t(len(in));
            ft->OutCount = uint16_t(len(out));
            if(variadic)
            {
                ft->OutCount |= 1 << 15;
            }
            if(auto [ts, ok] = rec::Load(gocpp::recv(funcLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, t] : gocpp::getValue<gocpp::slice<abi::Type*>>(ts))
                {
                    if(haveIdenticalUnderlyingType(& ft->Type, t, true))
                    {
                        return toRType(t);
                    }
                }
            }
            rec::Lock(gocpp::recv(funcLookupCache));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(funcLookupCache)); });
            if(auto [ts, ok] = rec::Load(gocpp::recv(funcLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, t] : gocpp::getValue<gocpp::slice<abi::Type*>>(ts))
                {
                    if(haveIdenticalUnderlyingType(& ft->Type, t, true))
                    {
                        return toRType(t);
                    }
                }
            }
            auto addToCache = [=](abi::Type* tt) mutable -> struct Type
            {
                gocpp::slice<abi::Type*> rts = {};
                if(auto [rti, ok] = rec::Load(gocpp::recv(funcLookupCache.m), hash); ok)
                {
                    rts = gocpp::getValue<gocpp::slice<abi::Type*>>(rti);
                }
                rec::Store(gocpp::recv(funcLookupCache.m), hash, append(rts, tt));
                return toType(tt);
            };
            auto str = funcStr(ft);
            for(auto [gocpp_ignored, tt] : typesByString(str))
            {
                if(haveIdenticalUnderlyingType(& ft->Type, tt, true))
                {
                    return addToCache(tt);
                }
            }
            ft->Str = resolveReflectName(newName(str, ""s, false, false));
            ft->PtrToThis = 0;
            return addToCache(& ft->Type);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::string stringFor(abi::Type* t)
    {
        return rec::String(gocpp::recv(toRType(t)));
    }

    // funcStr builds a string representation of a funcType.
    std::string funcStr(golang::reflect::funcType* ft)
    {
        auto repr = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 64);
        repr = append(repr, "func("s);
        for(auto [i, t] : rec::InSlice(gocpp::recv(ft)))
        {
            if(i > 0)
            {
                repr = append(repr, ", "s);
            }
            if(rec::IsVariadic(gocpp::recv(ft)) && i == int(ft->InCount) - 1)
            {
                repr = append(repr, "..."s);
                repr = append(repr, stringFor((sliceType*)(unsafe::Pointer(t))->Elem));
            }
            else
            {
                repr = append(repr, stringFor(t));
            }
        }
        repr = append(repr, ')');
        auto out = rec::OutSlice(gocpp::recv(ft));
        if(len(out) == 1)
        {
            repr = append(repr, ' ');
        }
        else
        if(len(out) > 1)
        {
            repr = append(repr, " ("s);
        }
        for(auto [i, t] : out)
        {
            if(i > 0)
            {
                repr = append(repr, ", "s);
            }
            repr = append(repr, stringFor(t));
        }
        if(len(out) > 1)
        {
            repr = append(repr, ')');
        }
        return std::string(repr);
    }

    // isReflexive reports whether the == operation on the type is reflexive.
    // That is, x == x for all values x of type t.
    bool isReflexive(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            else if(condition == Int) { conditionId = 1; }
            else if(condition == Int8) { conditionId = 2; }
            else if(condition == Int16) { conditionId = 3; }
            else if(condition == Int32) { conditionId = 4; }
            else if(condition == Int64) { conditionId = 5; }
            else if(condition == Uint) { conditionId = 6; }
            else if(condition == Uint8) { conditionId = 7; }
            else if(condition == Uint16) { conditionId = 8; }
            else if(condition == Uint32) { conditionId = 9; }
            else if(condition == Uint64) { conditionId = 10; }
            else if(condition == Uintptr) { conditionId = 11; }
            else if(condition == Chan) { conditionId = 12; }
            else if(condition == Pointer) { conditionId = 13; }
            else if(condition == String) { conditionId = 14; }
            else if(condition == UnsafePointer) { conditionId = 15; }
            else if(condition == Float32) { conditionId = 16; }
            else if(condition == Float64) { conditionId = 17; }
            else if(condition == Complex64) { conditionId = 18; }
            else if(condition == Complex128) { conditionId = 19; }
            else if(condition == Interface) { conditionId = 20; }
            else if(condition == Array) { conditionId = 21; }
            else if(condition == Struct) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    return true;
                    break;
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    return false;
                    break;
                case 21:
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(t));
                    return isReflexive(tt->Elem);
                    break;
                case 22:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : tt->Fields)
                    {
                        if(! isReflexive(f.Typ))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                default:
                    gocpp::panic("isReflexive called on non-key type "s + stringFor(t));
                    break;
            }
        }
    }

    // needKeyUpdate reports whether map overwrites require the key to be copied.
    bool needKeyUpdate(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            else if(condition == Int) { conditionId = 1; }
            else if(condition == Int8) { conditionId = 2; }
            else if(condition == Int16) { conditionId = 3; }
            else if(condition == Int32) { conditionId = 4; }
            else if(condition == Int64) { conditionId = 5; }
            else if(condition == Uint) { conditionId = 6; }
            else if(condition == Uint8) { conditionId = 7; }
            else if(condition == Uint16) { conditionId = 8; }
            else if(condition == Uint32) { conditionId = 9; }
            else if(condition == Uint64) { conditionId = 10; }
            else if(condition == Uintptr) { conditionId = 11; }
            else if(condition == Chan) { conditionId = 12; }
            else if(condition == Pointer) { conditionId = 13; }
            else if(condition == UnsafePointer) { conditionId = 14; }
            else if(condition == Float32) { conditionId = 15; }
            else if(condition == Float64) { conditionId = 16; }
            else if(condition == Complex64) { conditionId = 17; }
            else if(condition == Complex128) { conditionId = 18; }
            else if(condition == Interface) { conditionId = 19; }
            else if(condition == String) { conditionId = 20; }
            else if(condition == Array) { conditionId = 21; }
            else if(condition == Struct) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    return false;
                    break;
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    return true;
                    break;
                case 21:
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(t));
                    return needKeyUpdate(tt->Elem);
                    break;
                case 22:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : tt->Fields)
                    {
                        if(needKeyUpdate(f.Typ))
                        {
                            return true;
                        }
                    }
                    return false;
                    break;
                default:
                    gocpp::panic("needKeyUpdate called on non-key type "s + stringFor(t));
                    break;
            }
        }
    }

    // hashMightPanic reports whether the hash of a map key of type t might panic.
    bool hashMightPanic(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Interface) { conditionId = 0; }
            else if(condition == Array) { conditionId = 1; }
            else if(condition == Struct) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return true;
                    break;
                case 1:
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(t));
                    return hashMightPanic(tt->Elem);
                    break;
                case 2:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : tt->Fields)
                    {
                        if(hashMightPanic(f.Typ))
                        {
                            return true;
                        }
                    }
                    return false;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    // Make sure these routines stay in sync with ../runtime/map.go!
    // These types exist only for GC, so we only fill out GC relevant info.
    // Currently, that's just size and the GC program. We also fill in string
    // for possible debugging use.
    abi::Type* bucketOf(abi::Type* ktyp, abi::Type* etyp)
    {
        if(ktyp->Size_ > maxKeySize)
        {
            ktyp = ptrTo(ktyp);
        }
        if(etyp->Size_ > maxValSize)
        {
            etyp = ptrTo(etyp);
        }
        // Prepare GC data if any.
        // A bucket is at most bucketSize*(1+maxKeySize+maxValSize)+ptrSize bytes,
        // or 2064 bytes, or 258 pointer-size words, or 33 bytes of pointer bitmap.
        // Note that since the key and value are known to be <= 128 bytes,
        // they're guaranteed to have bitmaps instead of GC programs.
        unsigned char* gcdata = {};
        uintptr_t ptrdata = {};
        auto size = bucketSize * (1 + ktyp->Size_ + etyp->Size_) + goarch::PtrSize;
        if(size & uintptr_t(ktyp->Align_ - 1) != 0 || size & uintptr_t(etyp->Align_ - 1) != 0)
        {
            gocpp::panic("reflect: bad size computation in MapOf"s);
        }
        if(ktyp->PtrBytes != 0 || etyp->PtrBytes != 0)
        {
            auto nptr = (bucketSize * (1 + ktyp->Size_ + etyp->Size_) + goarch::PtrSize) / goarch::PtrSize;
            auto n = (nptr + 7) / 8;
            n = (n + goarch::PtrSize - 1) &^ (goarch::PtrSize - 1);
            auto mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            auto base = bucketSize / goarch::PtrSize;
            if(ktyp->PtrBytes != 0)
            {
                emitGCMask(mask, base, ktyp, bucketSize);
            }
            base += bucketSize * ktyp->Size_ / goarch::PtrSize;
            if(etyp->PtrBytes != 0)
            {
                emitGCMask(mask, base, etyp, bucketSize);
            }
            base += bucketSize * etyp->Size_ / goarch::PtrSize;
            auto word = base;
            mask[word / 8] |= 1 << (word % 8);
            gcdata = & mask[0];
            ptrdata = (word + 1) * goarch::PtrSize;
            if(ptrdata != size)
            {
                gocpp::panic("reflect: bad layout computation in MapOf"s);
            }
        }
        auto b = gocpp::InitPtr<abi::Type>([=](auto& x) {
            x.Align_ = goarch::PtrSize;
            x.Size_ = size;
            x.Kind_ = uint8_t(Struct);
            x.PtrBytes = ptrdata;
            x.GCData = gcdata;
        });
        auto s = "bucket("s + stringFor(ktyp) + ","s + stringFor(etyp) + ")"s;
        b->Str = resolveReflectName(newName(s, ""s, false, false));
        return b;
    }

    gocpp::slice<unsigned char> rec::gcSlice(reflect::rtype* t, uintptr_t begin, uintptr_t end)
    {
        return (gocpp::array<unsigned char, 1 << 30>*)(unsafe::Pointer(t->t.GCData)).make_slice(begin, end, end);
    }

    // emitGCMask writes the GC mask for [n]typ into out, starting at bit
    // offset base.
    void emitGCMask(gocpp::slice<unsigned char> out, uintptr_t base, abi::Type* typ, uintptr_t n)
    {
        if(typ->Kind_ & kindGCProg != 0)
        {
            gocpp::panic("reflect: unexpected GC program"s);
        }
        auto ptrs = typ->PtrBytes / goarch::PtrSize;
        auto words = typ->Size_ / goarch::PtrSize;
        auto mask = rec::GcSlice(gocpp::recv(typ), 0, (ptrs + 7) / 8);
        for(auto j = uintptr_t(0); j < ptrs; j++)
        {
            if((mask[j / 8] >> (j % 8)) & 1 != 0)
            {
                for(auto i = uintptr_t(0); i < n; i++)
                {
                    auto k = base + i * words + j;
                    out[k / 8] |= 1 << (k % 8);
                }
            }
        }
    }

    // appendGCProg appends the GC program for the first ptrdata bytes of
    // typ to dst and returns the extended slice.
    gocpp::slice<unsigned char> appendGCProg(gocpp::slice<unsigned char> dst, abi::Type* typ)
    {
        if(typ->Kind_ & kindGCProg != 0)
        {
            auto n = uintptr_t(*(uint32_t*)(unsafe::Pointer(typ->GCData)));
            auto prog = rec::GcSlice(gocpp::recv(typ), 4, 4 + n - 1);
            return append(dst, prog);
        }
        auto ptrs = typ->PtrBytes / goarch::PtrSize;
        auto mask = rec::GcSlice(gocpp::recv(typ), 0, (ptrs + 7) / 8);
        for(; ptrs > 120; ptrs -= 120)
        {
            dst = append(dst, 120);
            dst = append(dst, mask.make_slice(0, 15));
            mask = mask.make_slice(15);
        }
        dst = append(dst, (unsigned char)(ptrs));
        dst = append(dst, mask);
        return dst;
    }

    // SliceOf returns the slice type with element type t.
    // For example, if t represents int, SliceOf(t) represents []int.
    struct Type SliceOf(struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ckey = cacheKey {Slice, typ, nullptr, 0};
        if(auto [slice, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(slice);
        }
        auto s = "[]"s + stringFor(typ);
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto slice = (sliceType*)(unsafe::Pointer(tt));
            if(slice->Elem == typ)
            {
                auto [ti, gocpp_id_8] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        // Make a slice type.
        go_any islice = (gocpp::slice<unsafe::Pointer>)(nullptr);
        auto prototype = *(sliceType**)(unsafe::Pointer(& islice));
        auto slice = *prototype;
        slice.TFlag = 0;
        slice.Str = resolveReflectName(newName(s, ""s, false, false));
        slice.Hash = fnv1(typ->Hash, '[');
        slice.Elem = typ;
        slice.PtrToThis = 0;
        auto [ti, gocpp_id_9] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& slice.Type));
        return gocpp::getValue<Type>(ti);
    }

    struct gocpp_id_10
    {
        mocklib::Mutex Mutex;
        sync::Map m;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.Mutex = this->Mutex;
            result.m = this->m;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (Mutex != ref.Mutex) return false;
            if (m != ref.m) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << Mutex;
            os << " " << m;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_10& value)
    {
        return value.PrintTo(os);
    }


    // The structLookupCache caches StructOf lookups.
    // StructOf does not share the common lookupCache since we need to pin
    // the memory associated with *structTypeFixedN.
    gocpp_id_10 structLookupCache;
    
    template<typename T> requires gocpp::GoStruct<T>
    structTypeUncommon::operator T()
    {
        T result;
        result.structType = this->structType;
        result.u = this->u;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool structTypeUncommon::operator==(const T& ref) const
    {
        if (structType != ref.structType) return false;
        if (u != ref.u) return false;
        return true;
    }

    std::ostream& structTypeUncommon::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << structType;
        os << " " << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value)
    {
        return value.PrintTo(os);
    }

    // isLetter reports whether a given 'rune' is classified as a Letter.
    bool isLetter(gocpp::rune ch)
    {
        return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= utf8::RuneSelf && unicode::IsLetter(ch);
    }

    // isValidFieldName checks if a string is a valid (struct) field name or not.
    //
    // According to the language spec, a field name should be an identifier.
    //
    // identifier = letter { letter | unicode_digit } .
    // letter = unicode_letter | "_" .
    bool isValidFieldName(std::string fieldName)
    {
        for(auto [i, c] : fieldName)
        {
            if(i == 0 && ! isLetter(c))
            {
                return false;
            }
            if(! (isLetter(c) || unicode::IsDigit(c)))
            {
                return false;
            }
        }
        return len(fieldName) > 0;
    }

    struct gocpp_id_11
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_11& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_13
            {

                using isGoStruct = void;

                template<typename T> requires gocpp::GoStruct<T>
                operator T()
                {
                    T result;
                    return result;
                }

                template<typename T> requires gocpp::GoStruct<T>
                bool operator==(const T& ref) const
                {
                    return true;
                }

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_13& value)
            {
                return value.PrintTo(os);
            }


    struct gocpp_id_14
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_14& value)
        {
            return value.PrintTo(os);
        }


    // StructOf returns the struct type containing fields.
    // The Offset and Index fields are ignored and computed as they would be
    // by the compiler.
    //
    // StructOf currently does not support promoted methods of embedded fields
    // and panics if passed unexported StructFields.
    struct Type StructOf(gocpp::slice<StructField> fields)
    {
        gocpp::Defer defer;
        try
        {
            auto hash = fnv1(0, gocpp::slice<unsigned char>("struct {"s));
            uintptr_t size = fnv1(0, gocpp::slice<unsigned char>("struct {"s));
            uint8_t typalign = fnv1(0, gocpp::slice<unsigned char>("struct {"s));
            auto comparable = true;
            gocpp::slice<abi::Method> methods = true;
            auto fs = gocpp::make(gocpp::Tag<gocpp::slice<reflect::structField>>(), len(fields));
            auto repr = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 64);
            auto fset = gocpp::map<std::string, gocpp_id_11> {};
            auto hasGCProg = false;
            auto lastzero = uintptr_t(0);
            repr = append(repr, "struct {"s);
            auto pkgpath = ""s;
            for(auto [i, field] : fields)
            {
                if(field.Name == ""s)
                {
                    gocpp::panic("reflect.StructOf: field "s + strconv::Itoa(i) + " has no name"s);
                }
                if(! isValidFieldName(field.Name))
                {
                    gocpp::panic("reflect.StructOf: field "s + strconv::Itoa(i) + " has invalid name"s);
                }
                if(field.Type == nullptr)
                {
                    gocpp::panic("reflect.StructOf: field "s + strconv::Itoa(i) + " has no type"s);
                }
                auto [f, fpkgpath] = runtimeStructField(field);
                auto ft = f.Typ;
                if(ft->Kind_ & kindGCProg != 0)
                {
                    hasGCProg = true;
                }
                if(fpkgpath != ""s)
                {
                    if(pkgpath == ""s)
                    {
                        pkgpath = fpkgpath;
                    }
                    else
                    if(pkgpath != fpkgpath)
                    {
                        gocpp::panic("reflect.Struct: fields with different PkgPath "s + pkgpath + " and "s + fpkgpath);
                    }
                }
                auto name = rec::Name(gocpp::recv(f.Name));
                hash = fnv1(hash, gocpp::slice<unsigned char>(name));
                repr = append(repr, (" "s + name));
                if(rec::Embedded(gocpp::recv(f)))
                {
                    if(rec::Kind(gocpp::recv(f.Typ)) == abi::Pointer)
                    {
                        auto elem = rec::Elem(gocpp::recv(ft));
                        if(auto k = rec::Kind(gocpp::recv(elem)); k == abi::Pointer || k == abi::Interface)
                        {
                            gocpp::panic("reflect.StructOf: illegal embedded field type "s + stringFor(ft));
                        }
                    }
                    //Go switch emulation
                    {
                        auto condition = Kind(rec::Kind(gocpp::recv(f.Typ)));
                        int conditionId = -1;
                        if(condition == Interface) { conditionId = 0; }
                        else if(condition == Pointer) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                auto ift = (interfaceType*)(unsafe::Pointer(ft));
                                for(auto [gocpp_ignored, m] : ift->Methods)
                                {
                                    if(pkgPath(rec::nameOff(gocpp::recv(ift), m.Name)) != ""s)
                                    {
                                        gocpp::panic("reflect: embedded interface with unexported method(s) not implemented"s);
                                    }
                                    auto fnStub = resolveReflectText(unsafe::Pointer(abi::FuncPCABIInternal(embeddedIfaceMethStub)));
                                    methods = append(methods, gocpp::Init<abi::Method>([=](auto& x) {
                                        x.Name = resolveReflectName(rec::nameOff(gocpp::recv(ift), m.Name));
                                        x.Mtyp = resolveReflectType(rec::typeOff(gocpp::recv(ift), m.Typ));
                                        x.Ifn = fnStub;
                                        x.Tfn = fnStub;
                                    }));
                                }
                                break;
                            case 1:
                                auto ptr = (ptrType*)(unsafe::Pointer(ft));
                                if(auto unt = rec::Uncommon(gocpp::recv(ptr)); unt != nullptr)
                                {
                                    if(i > 0 && unt->Mcount > 0)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented if type is not first field"s);
                                    }
                                    if(len(fields) > 1)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented if there is more than one field"s);
                                    }
                                    for(auto [gocpp_ignored, m] : rec::Methods(gocpp::recv(unt)))
                                    {
                                        auto mname = nameOffFor(ft, m.Name);
                                        if(pkgPath(mname) != ""s)
                                        {
                                            gocpp::panic("reflect: embedded interface with unexported method(s) not implemented"s);
                                        }
                                        methods = append(methods, gocpp::Init<abi::Method>([=](auto& x) {
                                            x.Name = resolveReflectName(mname);
                                            x.Mtyp = resolveReflectType(typeOffFor(ft, m.Mtyp));
                                            x.Ifn = resolveReflectText(textOffFor(ft, m.Ifn));
                                            x.Tfn = resolveReflectText(textOffFor(ft, m.Tfn));
                                        }));
                                    }
                                }
                                if(auto unt = rec::Uncommon(gocpp::recv(ptr->Elem)); unt != nullptr)
                                {
                                    for(auto [gocpp_ignored, m] : rec::Methods(gocpp::recv(unt)))
                                    {
                                        auto mname = nameOffFor(ft, m.Name);
                                        if(pkgPath(mname) != ""s)
                                        {
                                            gocpp::panic("reflect: embedded interface with unexported method(s) not implemented"s);
                                        }
                                        methods = append(methods, gocpp::Init<abi::Method>([=](auto& x) {
                                            x.Name = resolveReflectName(mname);
                                            x.Mtyp = resolveReflectType(typeOffFor(ptr->Elem, m.Mtyp));
                                            x.Ifn = resolveReflectText(textOffFor(ptr->Elem, m.Ifn));
                                            x.Tfn = resolveReflectText(textOffFor(ptr->Elem, m.Tfn));
                                        }));
                                    }
                                }
                                break;
                            default:
                                if(auto unt = rec::Uncommon(gocpp::recv(ft)); unt != nullptr)
                                {
                                    if(i > 0 && unt->Mcount > 0)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented if type is not first field"s);
                                    }
                                    if(len(fields) > 1 && ft->Kind_ & kindDirectIface != 0)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented for non-pointer type"s);
                                    }
                                    for(auto [gocpp_ignored, m] : rec::Methods(gocpp::recv(unt)))
                                    {
                                        auto mname = nameOffFor(ft, m.Name);
                                        if(pkgPath(mname) != ""s)
                                        {
                                            gocpp::panic("reflect: embedded interface with unexported method(s) not implemented"s);
                                        }
                                        methods = append(methods, gocpp::Init<abi::Method>([=](auto& x) {
                                            x.Name = resolveReflectName(mname);
                                            x.Mtyp = resolveReflectType(typeOffFor(ft, m.Mtyp));
                                            x.Ifn = resolveReflectText(textOffFor(ft, m.Ifn));
                                            x.Tfn = resolveReflectText(textOffFor(ft, m.Tfn));
                                        }));
                                    }
                                }
                                break;
                        }
                    }
                }
                if(auto [gocpp_id_12, dup] = fset[name]; dup && name != "_"s)
                {
                    gocpp::panic("reflect.StructOf: duplicate field "s + name);
                }
                fset[name] = gocpp_id_13 {};
                hash = fnv1(hash, (unsigned char)(ft->Hash >> 24), (unsigned char)(ft->Hash >> 16), (unsigned char)(ft->Hash >> 8), (unsigned char)(ft->Hash));
                repr = append(repr, (" "s + stringFor(ft)));
                if(rec::HasTag(gocpp::recv(f.Name)))
                {
                    hash = fnv1(hash, gocpp::slice<unsigned char>(rec::Tag(gocpp::recv(f.Name))));
                    repr = append(repr, (" "s + strconv::Quote(rec::Tag(gocpp::recv(f.Name)))));
                }
                if(i < len(fields) - 1)
                {
                    repr = append(repr, ';');
                }
                comparable = comparable && (ft->Equal != nullptr);
                auto offset = align(size, uintptr_t(ft->Align_));
                if(offset < size)
                {
                    gocpp::panic("reflect.StructOf: struct size would exceed virtual address space"s);
                }
                if(ft->Align_ > typalign)
                {
                    typalign = ft->Align_;
                }
                size = offset + ft->Size_;
                if(size < offset)
                {
                    gocpp::panic("reflect.StructOf: struct size would exceed virtual address space"s);
                }
                f.Offset = offset;
                if(ft->Size_ == 0)
                {
                    lastzero = size;
                }
                fs[i] = f;
            }
            if(size > 0 && lastzero == size)
            {
                size++;
                if(size == 0)
                {
                    gocpp::panic("reflect.StructOf: struct size would exceed virtual address space"s);
                }
            }
            structType* typ = {};
            reflect::uncommonType* ut = {};
            if(len(methods) == 0)
            {
                auto t = new(structTypeUncommon);
                typ = & t->structType;
                ut = & t->u;
            }
            else
            {
                auto tt = New(StructOf(gocpp::slice<StructField> {gocpp::Init<>([=](auto& x) {
                    x.Name = "S"s;
                    x.Type = TypeOf(structType {});
                }), gocpp::Init<>([=](auto& x) {
                    x.Name = "U"s;
                    x.Type = TypeOf(reflect::uncommonType {});
                }), gocpp::Init<>([=](auto& x) {
                    x.Name = "M"s;
                    x.Type = ArrayOf(len(methods), TypeOf(methods[0]));
                })}));
                typ = (structType*)(rec::UnsafePointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(rec::Elem(gocpp::recv(tt))), 0))))));
                ut = (reflect::uncommonType*)(rec::UnsafePointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(rec::Elem(gocpp::recv(tt))), 1))))));
                copy(gocpp::getValue<gocpp::slice<abi::Method>>(rec::Interface(gocpp::recv(rec::Slice(gocpp::recv(rec::Field(gocpp::recv(rec::Elem(gocpp::recv(tt))), 2)), 0, len(methods))))), methods);
            }
            ut->Mcount = uint16_t(len(methods));
            ut->Xcount = ut->Mcount;
            ut->Moff = uint32_t(gocpp::Sizeof<reflect::uncommonType>());
            if(len(fs) > 0)
            {
                repr = append(repr, ' ');
            }
            repr = append(repr, '}');
            hash = fnv1(hash, '}');
            auto str = std::string(repr);
            auto s = align(size, uintptr_t(typalign));
            if(s < size)
            {
                gocpp::panic("reflect.StructOf: struct size would exceed virtual address space"s);
            }
            size = s;
            // Make the struct type.
            go_any istruct = gocpp_id_14 {};
            auto prototype = *(structType**)(unsafe::Pointer(& istruct));
            *typ = *prototype;
            typ->Fields = fs;
            if(pkgpath != ""s)
            {
                typ->PkgPath = newName(pkgpath, ""s, false, false);
            }
            if(auto [ts, ok] = rec::Load(gocpp::recv(structLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, st] : gocpp::getValue<gocpp::slice<Type>>(ts))
                {
                    auto t = rec::common(gocpp::recv(st));
                    if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                    {
                        return toType(t);
                    }
                }
            }
            rec::Lock(gocpp::recv(structLookupCache));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(structLookupCache)); });
            if(auto [ts, ok] = rec::Load(gocpp::recv(structLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, st] : gocpp::getValue<gocpp::slice<Type>>(ts))
                {
                    auto t = rec::common(gocpp::recv(st));
                    if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                    {
                        return toType(t);
                    }
                }
            }
            auto addToCache = [=](struct Type t) mutable -> struct Type
            {
                gocpp::slice<Type> ts = {};
                if(auto [ti, ok] = rec::Load(gocpp::recv(structLookupCache.m), hash); ok)
                {
                    ts = gocpp::getValue<gocpp::slice<Type>>(ti);
                }
                rec::Store(gocpp::recv(structLookupCache.m), hash, append(ts, t));
                return t;
            };
            for(auto [gocpp_ignored, t] : typesByString(str))
            {
                if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                {
                    return addToCache(toType(t));
                }
            }
            typ->Str = resolveReflectName(newName(str, ""s, false, false));
            typ->TFlag = 0;
            typ->Hash = hash;
            typ->Size_ = size;
            typ->PtrBytes = typeptrdata(& typ->Type);
            typ->Align_ = typalign;
            typ->FieldAlign_ = typalign;
            typ->PtrToThis = 0;
            if(len(methods) > 0)
            {
                typ->TFlag |= abi::TFlagUncommon;
            }
            if(hasGCProg)
            {
                auto lastPtrField = 0;
                for(auto [i, ft] : fs)
                {
                    if(rec::Pointers(gocpp::recv(ft->Typ)))
                    {
                        lastPtrField = i;
                    }
                }
                auto prog = gocpp::slice<unsigned char> {0, 0, 0, 0};
                uintptr_t off = {};
                for(auto [i, ft] : fs)
                {
                    if(i > lastPtrField)
                    {
                        break;
                    }
                    if(! rec::Pointers(gocpp::recv(ft->Typ)))
                    {
                        continue;
                    }
                    if(ft->Offset > off)
                    {
                        auto n = (ft->Offset - off) / goarch::PtrSize;
                        prog = append(prog, 0x01, 0x00);
                        if(n > 1)
                        {
                            prog = append(prog, 0x81);
                            prog = appendVarint(prog, n - 1);
                        }
                        off = ft->Offset;
                    }
                    prog = appendGCProg(prog, ft->Typ);
                    off += ft->Typ->PtrBytes;
                }
                prog = append(prog, 0);
                *(uint32_t*)(unsafe::Pointer(& prog[0])) = uint32_t(len(prog) - 4);
                typ->Kind_ |= kindGCProg;
                typ->GCData = & prog[0];
            }
            else
            {
                typ->Kind_ &^= kindGCProg;
                auto bv = new(bitVector);
                addTypeBits(bv, 0, & typ->Type);
                if(len(bv->data) > 0)
                {
                    typ->GCData = & bv->data[0];
                }
            }
            typ->Equal = nullptr;
            if(comparable)
            {
                typ->Equal = [=](unsafe::Pointer p, unsafe::Pointer q) mutable -> bool
                {
                    for(auto [gocpp_ignored, ft] : typ->Fields)
                    {
                        auto pi = add(p, ft->Offset, "&x.field safe"s);
                        auto qi = add(q, ft->Offset, "&x.field safe"s);
                        if(! rec::Equal(gocpp::recv(ft->Typ), pi, qi))
                        {
                            return false;
                        }
                    }
                    return true;
                };
            }
            //Go switch emulation
            {
                int conditionId = -1;
                if(len(fs) == 1 && ! ifaceIndir(fs[0].Typ)) { conditionId = 0; }
                switch(conditionId)
                {
                    case 0:
                        typ->Kind_ |= kindDirectIface;
                        break;
                    default:
                        typ->Kind_ &^= kindDirectIface;
                        break;
                }
            }
            return addToCache(toType(& typ->Type));
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void embeddedIfaceMethStub()
    {
        gocpp::panic("reflect: StructOf does not support methods of embedded interfaces"s);
    }

    // runtimeStructField takes a StructField value passed to StructOf and
    // returns both the corresponding internal representation, of type
    // structField, and the pkgpath value to use for this field.
    std::tuple<reflect::structField, std::string> runtimeStructField(struct StructField field)
    {
        if(field.Anonymous && field.PkgPath != ""s)
        {
            gocpp::panic("reflect.StructOf: field \""s + field.Name + "\" is anonymous but has PkgPath set"s);
        }
        if(rec::IsExported(gocpp::recv(field)))
        {
            auto c = field.Name[0];
            if('a' <= c && c <= 'z' || c == '_')
            {
                gocpp::panic("reflect.StructOf: field \""s + field.Name + "\" is unexported but missing PkgPath"s);
            }
        }
        resolveReflectType(rec::common(gocpp::recv(field.Type)));
        auto f = gocpp::Init<reflect::structField>([=](auto& x) {
            x.Name = newName(field.Name, std::string(field.Tag), rec::IsExported(gocpp::recv(field)), field.Anonymous);
            x.Typ = rec::common(gocpp::recv(field.Type));
            x.Offset = 0;
        });
        return {f, field.PkgPath};
    }

    // typeptrdata returns the length in bytes of the prefix of t
    // containing pointer data. Anything after this offset is scalar data.
    // keep in sync with ../cmd/compile/internal/reflectdata/reflect.go
    uintptr_t typeptrdata(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == abi::Struct) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    auto st = (structType*)(unsafe::Pointer(t));
                    auto field = - 1;
                    for(auto [i, gocpp_ignored] : st->Fields)
                    {
                        auto ft = st->Fields[i].Typ;
                        if(rec::Pointers(gocpp::recv(ft)))
                        {
                            field = i;
                        }
                    }
                    if(field == - 1)
                    {
                        return 0;
                    }
                    auto f = st->Fields[field];
                    return f.Offset + f.Typ->PtrBytes;
                    break;
                default:
                    gocpp::panic("reflect.typeptrdata: unexpected type, "s + stringFor(t));
                    break;
            }
        }
    }

    // See cmd/compile/internal/reflectdata/reflect.go for derivation of constant.
    // ArrayOf returns the array type with the given length and element type.
    // For example, if t represents int, ArrayOf(5, t) represents [5]int.
    //
    // If the resulting type would be larger than the available address space,
    // ArrayOf panics.
    struct Type ArrayOf(int length, struct Type elem)
    {
        if(length < 0)
        {
            gocpp::panic("reflect: negative length passed to ArrayOf"s);
        }
        auto typ = rec::common(gocpp::recv(elem));
        auto ckey = cacheKey {Array, typ, nullptr, uintptr_t(length)};
        if(auto [array, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(array);
        }
        auto s = "["s + strconv::Itoa(length) + "]"s + stringFor(typ);
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto array = (reflect::arrayType*)(unsafe::Pointer(tt));
            if(array->Elem == typ)
            {
                auto [ti, gocpp_id_15] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        // Make an array type.
        go_any iarray = gocpp::array<unsafe::Pointer, 1> {};
        auto prototype = *(reflect::arrayType**)(unsafe::Pointer(& iarray));
        auto array = *prototype;
        array.TFlag = typ->TFlag & abi::TFlagRegularMemory;
        array.Str = resolveReflectName(newName(s, ""s, false, false));
        array.Hash = fnv1(typ->Hash, '[');
        for(auto n = uint32_t(length); n > 0; n >>= 8)
        {
            array.Hash = fnv1(array.Hash, (unsigned char)(n));
        }
        array.Hash = fnv1(array.Hash, ']');
        array.Elem = typ;
        array.PtrToThis = 0;
        if(typ->Size_ > 0)
        {
            auto max = ~ uintptr_t(0) / typ->Size_;
            if(uintptr_t(length) > max)
            {
                gocpp::panic("reflect.ArrayOf: array size would exceed virtual address space"s);
            }
        }
        array.Size_ = typ->Size_ * uintptr_t(length);
        if(length > 0 && typ->PtrBytes != 0)
        {
            array.PtrBytes = typ->Size_ * uintptr_t(length - 1) + typ->PtrBytes;
        }
        array.Align_ = typ->Align_;
        array.FieldAlign_ = typ->FieldAlign_;
        array.Len = uintptr_t(length);
        array.Slice = & (gocpp::getValue<reflect::rtype*>(SliceOf(elem))->t);
        //Go switch emulation
        {
            int conditionId = -1;
            if(typ->PtrBytes == 0 || array.Size_ == 0) { conditionId = 0; }
            else if(length == 1) { conditionId = 1; }
            else if(typ->Kind_ & kindGCProg == 0 && array.Size_ <= maxPtrmaskBytes * 8 * goarch::PtrSize) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    array.GCData = nullptr;
                    array.PtrBytes = 0;
                    break;
                case 1:
                    array.Kind_ |= typ->Kind_ & kindGCProg;
                    array.GCData = typ->GCData;
                    array.PtrBytes = typ->PtrBytes;
                    break;
                case 2:
                    auto n = (array.PtrBytes / goarch::PtrSize + 7) / 8;
                    n = (n + goarch::PtrSize - 1) &^ (goarch::PtrSize - 1);
                    auto mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
                    emitGCMask(mask, 0, typ, array.Len);
                    array.GCData = & mask[0];
                    break;
                default:
                    auto prog = gocpp::slice<unsigned char> {0, 0, 0, 0};
                    prog = appendGCProg(prog, typ);
                    auto elemPtrs = typ->PtrBytes / goarch::PtrSize;
                    auto elemWords = typ->Size_ / goarch::PtrSize;
                    if(elemPtrs < elemWords)
                    {
                        prog = append(prog, 0x01, 0x00);
                        if(elemPtrs + 1 < elemWords)
                        {
                            prog = append(prog, 0x81);
                            prog = appendVarint(prog, elemWords - elemPtrs - 1);
                        }
                    }
                    if(elemWords < 0x80)
                    {
                        prog = append(prog, (unsigned char)(elemWords | 0x80));
                    }
                    else
                    {
                        prog = append(prog, 0x80);
                        prog = appendVarint(prog, elemWords);
                    }
                    prog = appendVarint(prog, uintptr_t(length) - 1);
                    prog = append(prog, 0);
                    *(uint32_t*)(unsafe::Pointer(& prog[0])) = uint32_t(len(prog) - 4);
                    array.Kind_ |= kindGCProg;
                    array.GCData = & prog[0];
                    array.PtrBytes = array.Size_;
                    break;
            }
        }
        auto etyp = typ;
        auto esize = rec::Size(gocpp::recv(etyp));
        array.Equal = nullptr;
        if(auto eequal = etyp->Equal; eequal != nullptr)
        {
            array.Equal = [=](unsafe::Pointer p, unsafe::Pointer q) mutable -> bool
            {
                for(auto i = 0; i < length; i++)
                {
                    auto pi = arrayAt(p, i, esize, "i < length"s);
                    auto qi = arrayAt(q, i, esize, "i < length"s);
                    if(! eequal(pi, qi))
                    {
                        return false;
                    }
                }
                return true;
            };
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(length == 1 && ! ifaceIndir(typ)) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    array.Kind_ |= kindDirectIface;
                    break;
                default:
                    array.Kind_ &^= kindDirectIface;
                    break;
            }
        }
        auto [ti, gocpp_id_16] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& array.Type));
        return gocpp::getValue<Type>(ti);
    }

    gocpp::slice<unsigned char> appendVarint(gocpp::slice<unsigned char> x, uintptr_t v)
    {
        for(; v >= 0x80; v >>= 7)
        {
            x = append(x, (unsigned char)(v | 0x80));
        }
        x = append(x, (unsigned char)(v));
        return x;
    }

    // toType converts from a *rtype to a Type that can be returned
    // to the client of package reflect. In gc, the only concern is that
    // a nil *rtype must be replaced by a nil Type, but in gccgo this
    // function takes care of ensuring that multiple *rtype for the same
    // type are coalesced into a single Type.
    struct Type toType(abi::Type* t)
    {
        if(t == nullptr)
        {
            return nullptr;
        }
        return toRType(t);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    layoutKey::operator T()
    {
        T result;
        result.ftyp = this->ftyp;
        result.rcvr = this->rcvr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool layoutKey::operator==(const T& ref) const
    {
        if (ftyp != ref.ftyp) return false;
        if (rcvr != ref.rcvr) return false;
        return true;
    }

    std::ostream& layoutKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ftyp;
        os << " " << rcvr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct layoutKey& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    layoutType::operator T()
    {
        T result;
        result.t = this->t;
        result.framePool = this->framePool;
        result.abid = this->abid;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool layoutType::operator==(const T& ref) const
    {
        if (t != ref.t) return false;
        if (framePool != ref.framePool) return false;
        if (abid != ref.abid) return false;
        return true;
    }

    std::ostream& layoutType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << t;
        os << " " << framePool;
        os << " " << abid;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct layoutType& value)
    {
        return value.PrintTo(os);
    }

    sync::Map layoutCache;
    // funcLayout computes a struct type representing the layout of the
    // stack-assigned function arguments and return values for the function
    // type t.
    // If rcvr != nil, rcvr specifies the type of the receiver.
    // The returned type exists only for GC, so we only fill out GC relevant info.
    // Currently, that's just size and the GC program. We also fill in
    // the name for possible debugging use.
    std::tuple<abi::Type*, sync::Pool*, struct abiDesc> funcLayout(golang::reflect::funcType* t, abi::Type* rcvr)
    {
        abi::Type* frametype;
        sync::Pool* framePool;
        struct abiDesc abid;
        if(rec::Kind(gocpp::recv(t)) != abi::Func)
        {
            gocpp::panic("reflect: funcLayout of non-func type "s + stringFor(& t->Type));
        }
        if(rcvr != nullptr && rec::Kind(gocpp::recv(rcvr)) == abi::Interface)
        {
            gocpp::panic("reflect: funcLayout with interface receiver "s + stringFor(rcvr));
        }
        auto k = layoutKey {t, rcvr};
        if(auto [lti, ok] = rec::Load(gocpp::recv(layoutCache), k); ok)
        {
            auto lt = gocpp::getValue<layoutType>(lti);
            return {lt.t, lt.framePool, lt.abid};
        }
        abid = newAbiDesc(t, rcvr);
        auto x = gocpp::InitPtr<abi::Type>([=](auto& x) {
            x.Align_ = goarch::PtrSize;
            x.Size_ = align(abid.retOffset + abid.ret.stackBytes, goarch::PtrSize);
            x.PtrBytes = uintptr_t(abid.stackPtrs->n) * goarch::PtrSize;
        });
        if(abid.stackPtrs->n > 0)
        {
            x->GCData = & abid.stackPtrs->data[0];
        }
        std::string s = {};
        if(rcvr != nullptr)
        {
            s = "methodargs("s + stringFor(rcvr) + ")("s + stringFor(& t->Type) + ")"s;
        }
        else
        {
            s = "funcargs("s + stringFor(& t->Type) + ")"s;
        }
        x->Str = resolveReflectName(newName(s, ""s, false, false));
        framePool = gocpp::InitPtr<sync::Pool>([=](auto& x) {
            x.New = [=]() mutable -> go_any
            {
                return unsafe_New(x);
            };
        });
        auto [lti, gocpp_id_17] = rec::LoadOrStore(gocpp::recv(layoutCache), k, gocpp::Init<layoutType>([=](auto& x) {
            x.t = x;
            x.framePool = framePool;
            x.abid = abid;
        }));
        auto lt = gocpp::getValue<layoutType>(lti);
        return {lt.t, lt.framePool, lt.abid};
    }

    // ifaceIndir reports whether t is stored indirectly in an interface value.
    bool ifaceIndir(abi::Type* t)
    {
        return t->Kind_ & kindDirectIface == 0;
    }

    // Note: this type must agree with runtime.bitvector.
    
    template<typename T> requires gocpp::GoStruct<T>
    bitVector::operator T()
    {
        T result;
        result.n = this->n;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool bitVector::operator==(const T& ref) const
    {
        if (n != ref.n) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& bitVector::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << n;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct bitVector& value)
    {
        return value.PrintTo(os);
    }

    // append a bit to the bitmap.
    void rec::append(struct bitVector* bv, uint8_t bit)
    {
        if(bv->n % (8 * goarch::PtrSize) == 0)
        {
            for(auto i = 0; i < goarch::PtrSize; i++)
            {
                bv->data = append(bv->data, 0);
            }
        }
        bv->data[bv->n / 8] |= bit << (bv->n % 8);
        bv->n++;
    }

    void addTypeBits(struct bitVector* bv, uintptr_t offset, abi::Type* t)
    {
        if(t->PtrBytes == 0)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = Kind(t->Kind_ & kindMask);
            int conditionId = -1;
            if(condition == Chan) { conditionId = 0; }
            else if(condition == Func) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == Pointer) { conditionId = 3; }
            else if(condition == Slice) { conditionId = 4; }
            else if(condition == String) { conditionId = 5; }
            else if(condition == UnsafePointer) { conditionId = 6; }
            else if(condition == Interface) { conditionId = 7; }
            else if(condition == Array) { conditionId = 8; }
            else if(condition == Struct) { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    for(; bv->n < uint32_t(offset / uintptr_t(goarch::PtrSize)); )
                    {
                        rec::append(gocpp::recv(bv), 0);
                    }
                    rec::append(gocpp::recv(bv), 1);
                    break;
                case 7:
                    for(; bv->n < uint32_t(offset / uintptr_t(goarch::PtrSize)); )
                    {
                        rec::append(gocpp::recv(bv), 0);
                    }
                    rec::append(gocpp::recv(bv), 1);
                    rec::append(gocpp::recv(bv), 1);
                    break;
                case 8:
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(t));
                    for(auto i = 0; i < int(tt->Len); i++)
                    {
                        addTypeBits(bv, offset + uintptr_t(i) * tt->Elem->Size_, tt->Elem);
                    }
                    break;
                case 9:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [i, gocpp_ignored] : tt->Fields)
                    {
                        auto f = & tt->Fields[i];
                        addTypeBits(bv, offset + f->Offset, f->Typ);
                    }
                    break;
            }
        }
    }

    // TypeFor returns the [Type] that represents the type argument T.

    template<typename T>
    struct Type TypeFor()
    {
        return rec::Elem(gocpp::recv(TypeOf((reflect::T*)(nullptr))));
    }

}

