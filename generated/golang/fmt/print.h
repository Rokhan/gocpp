// generated by GoCpp from file '$(ImportDir)/fmt/print.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/fmt/print.fwd.h"
#include "gocpp/support.h"

#include "golang/fmt/format.h"
#include "golang/internal/abi/type.h"
#include "golang/io/io.h"
#include "golang/reflect/value.h"
#include "golang/sync/cond.h"
#include "golang/sync/pool.h"

namespace golang::fmt
{
    extern std::string commaSpaceString;
    extern std::string nilAngleString;
    extern std::string nilParenString;
    extern std::string nilString;
    extern std::string mapString;
    extern std::string percentBangString;
    extern std::string missingString;
    extern std::string badIndexString;
    extern std::string panicString;
    extern std::string extraString;
    extern std::string badWidthString;
    extern std::string badPrecString;
    extern std::string noVerbString;
    extern std::string invReflectString;
    struct State : gocpp::Interface
    {
        State(){}
        State(State& i) = default;
        State(const State& i) = default;
        State& operator=(State& i) = default;
        State& operator=(const State& i) = default;

        template<typename T>
        State(T& ref);

        template<typename T>
        State(const T& ref);

        template<typename T>
        State(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IState
        {
            virtual std::tuple<int, struct gocpp::error> vWrite(gocpp::slice<unsigned char> b) = 0;
            virtual std::tuple<int, bool> vWidth() = 0;
            virtual std::tuple<int, bool> vPrecision() = 0;
            virtual bool vFlag(int c) = 0;
        };

        template<typename T, typename StoreT>
        struct StateImpl : IState
        {
            explicit StateImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<int, struct gocpp::error> vWrite(gocpp::slice<unsigned char> b) override;

            std::tuple<int, bool> vWidth() override;

            std::tuple<int, bool> vPrecision() override;

            bool vFlag(int c) override;

            StoreT value;
        };

        std::shared_ptr<IState> value;
    };

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Write(const gocpp::PtrRecv<struct State, false>& self, gocpp::slice<unsigned char> b);
        std::tuple<int, struct gocpp::error> Write(const gocpp::ObjRecv<struct State>& self, gocpp::slice<unsigned char> b);

        std::tuple<int, bool> Width(const gocpp::PtrRecv<struct State, false>& self);
        std::tuple<int, bool> Width(const gocpp::ObjRecv<struct State>& self);

        std::tuple<int, bool> Precision(const gocpp::PtrRecv<struct State, false>& self);
        std::tuple<int, bool> Precision(const gocpp::ObjRecv<struct State>& self);

        bool Flag(const gocpp::PtrRecv<struct State, false>& self, int c);
        bool Flag(const gocpp::ObjRecv<struct State>& self, int c);
    }

    std::ostream& operator<<(std::ostream& os, const struct State& value);
    struct Formatter : gocpp::Interface
    {
        Formatter(){}
        Formatter(Formatter& i) = default;
        Formatter(const Formatter& i) = default;
        Formatter& operator=(Formatter& i) = default;
        Formatter& operator=(const Formatter& i) = default;

        template<typename T>
        Formatter(T& ref);

        template<typename T>
        Formatter(const T& ref);

        template<typename T>
        Formatter(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IFormatter
        {
            virtual void vFormat(struct State f, gocpp::rune verb) = 0;
        };

        template<typename T, typename StoreT>
        struct FormatterImpl : IFormatter
        {
            explicit FormatterImpl(T* ptr)
            {
                value.reset(ptr);
            }

            void vFormat(struct State f, gocpp::rune verb) override;

            StoreT value;
        };

        std::shared_ptr<IFormatter> value;
    };

    namespace rec
    {
        void Format(const gocpp::PtrRecv<struct Formatter, false>& self, struct State f, gocpp::rune verb);
        void Format(const gocpp::ObjRecv<struct Formatter>& self, struct State f, gocpp::rune verb);
    }

    std::ostream& operator<<(std::ostream& os, const struct Formatter& value);
    struct Stringer : gocpp::Interface
    {
        Stringer(){}
        Stringer(Stringer& i) = default;
        Stringer(const Stringer& i) = default;
        Stringer& operator=(Stringer& i) = default;
        Stringer& operator=(const Stringer& i) = default;

        template<typename T>
        Stringer(T& ref);

        template<typename T>
        Stringer(const T& ref);

        template<typename T>
        Stringer(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IStringer
        {
            virtual std::string vString() = 0;
        };

        template<typename T, typename StoreT>
        struct StringerImpl : IStringer
        {
            explicit StringerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vString() override;

            StoreT value;
        };

        std::shared_ptr<IStringer> value;
    };

    namespace rec
    {
        std::string String(const gocpp::PtrRecv<struct Stringer, false>& self);
        std::string String(const gocpp::ObjRecv<struct Stringer>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct Stringer& value);
    struct GoStringer : gocpp::Interface
    {
        GoStringer(){}
        GoStringer(GoStringer& i) = default;
        GoStringer(const GoStringer& i) = default;
        GoStringer& operator=(GoStringer& i) = default;
        GoStringer& operator=(const GoStringer& i) = default;

        template<typename T>
        GoStringer(T& ref);

        template<typename T>
        GoStringer(const T& ref);

        template<typename T>
        GoStringer(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IGoStringer
        {
            virtual std::string vGoString() = 0;
        };

        template<typename T, typename StoreT>
        struct GoStringerImpl : IGoStringer
        {
            explicit GoStringerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vGoString() override;

            StoreT value;
        };

        std::shared_ptr<IGoStringer> value;
    };

    namespace rec
    {
        std::string GoString(const gocpp::PtrRecv<struct GoStringer, false>& self);
        std::string GoString(const gocpp::ObjRecv<struct GoStringer>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct GoStringer& value);
    struct pp
    {
        golang::fmt::buffer buf;
        go_any arg;
        reflect::Value value;
        fmt fmt;
        bool reordered;
        bool goodArgNum;
        bool panicking;
        bool erroring;
        bool wrapErrs;
        gocpp::slice<int> wrappedErrs;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pp& value);
    std::string FormatString(struct State state, gocpp::rune verb);
    struct pp* newPrinter();
    std::tuple<int, struct gocpp::error> Fprintf(io::Writer w, std::string format, gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Fprintf(io::Writer w, std::string format, Args... a)
    {
        return Fprintf(w, format, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Fprintf(io::Writer w, std::string format, go_any value, Args... a)
    {
        return Fprintf(w, format, gocpp::ToSlice<go_any>(value, a...));
    }
    std::tuple<int, struct gocpp::error> Printf(std::string format, gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Printf(std::string format, Args... a)
    {
        return Printf(format, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Printf(std::string format, go_any value, Args... a)
    {
        return Printf(format, gocpp::ToSlice<go_any>(value, a...));
    }
    std::string Sprintf(std::string format, gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::string Sprintf(std::string format, Args... a)
    {
        return Sprintf(format, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::string Sprintf(std::string format, go_any value, Args... a)
    {
        return Sprintf(format, gocpp::ToSlice<go_any>(value, a...));
    }
    gocpp::slice<unsigned char> Appendf(gocpp::slice<unsigned char> b, std::string format, gocpp::slice<go_any> a);
    
    template<typename... Args>
    gocpp::slice<unsigned char> Appendf(gocpp::slice<unsigned char> b, std::string format, Args... a)
    {
        return Appendf(b, format, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    gocpp::slice<unsigned char> Appendf(gocpp::slice<unsigned char> b, std::string format, go_any value, Args... a)
    {
        return Appendf(b, format, gocpp::ToSlice<go_any>(value, a...));
    }
    std::tuple<int, struct gocpp::error> Fprint(io::Writer w, gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Fprint(io::Writer w, Args... a)
    {
        return Fprint(w, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Fprint(io::Writer w, go_any value, Args... a)
    {
        return Fprint(w, gocpp::ToSlice<go_any>(value, a...));
    }
    std::tuple<int, struct gocpp::error> Print(gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Print(Args... a)
    {
        return Print(gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Print(go_any value, Args... a)
    {
        return Print(gocpp::ToSlice<go_any>(value, a...));
    }
    std::string Sprint(gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::string Sprint(Args... a)
    {
        return Sprint(gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::string Sprint(go_any value, Args... a)
    {
        return Sprint(gocpp::ToSlice<go_any>(value, a...));
    }
    gocpp::slice<unsigned char> Append(gocpp::slice<unsigned char> b, gocpp::slice<go_any> a);
    
    template<typename... Args>
    gocpp::slice<unsigned char> Append(gocpp::slice<unsigned char> b, Args... a)
    {
        return Append(b, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    gocpp::slice<unsigned char> Append(gocpp::slice<unsigned char> b, go_any value, Args... a)
    {
        return Append(b, gocpp::ToSlice<go_any>(value, a...));
    }
    std::tuple<int, struct gocpp::error> Fprintln(io::Writer w, gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Fprintln(io::Writer w, Args... a)
    {
        return Fprintln(w, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Fprintln(io::Writer w, go_any value, Args... a)
    {
        return Fprintln(w, gocpp::ToSlice<go_any>(value, a...));
    }
    std::tuple<int, struct gocpp::error> Println(gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Println(Args... a)
    {
        return Println(gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::tuple<int, struct gocpp::error> Println(go_any value, Args... a)
    {
        return Println(gocpp::ToSlice<go_any>(value, a...));
    }
    std::string Sprintln(gocpp::slice<go_any> a);
    
    template<typename... Args>
    std::string Sprintln(Args... a)
    {
        return Sprintln(gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    std::string Sprintln(go_any value, Args... a)
    {
        return Sprintln(gocpp::ToSlice<go_any>(value, a...));
    }
    gocpp::slice<unsigned char> Appendln(gocpp::slice<unsigned char> b, gocpp::slice<go_any> a);
    
    template<typename... Args>
    gocpp::slice<unsigned char> Appendln(gocpp::slice<unsigned char> b, Args... a)
    {
        return Appendln(b, gocpp::ToSlice<go_any>(a...));
    }
    
    template<typename... Args>
    gocpp::slice<unsigned char> Appendln(gocpp::slice<unsigned char> b, go_any value, Args... a)
    {
        return Appendln(b, gocpp::ToSlice<go_any>(value, a...));
    }
    reflect::Value getField(reflect::Value v, int i);
    bool tooLarge(int x);
    std::tuple<int, bool, int> parsenum(std::string s, int start, int end);
    std::tuple<int, bool, int> intFromArg(gocpp::slice<go_any> a, int argNum);
    std::tuple<int, int, bool> parseArgNumber(std::string format);
    extern sync::Pool ppFree;

    namespace rec
    {
        void write(golang::fmt::buffer* b, gocpp::slice<unsigned char> p);
        void writeString(golang::fmt::buffer* b, std::string s);
        void writeByte(golang::fmt::buffer* b, unsigned char c);
        void writeRune(golang::fmt::buffer* b, gocpp::rune r);
        void free(struct pp* p);
        std::tuple<int, bool> Width(struct pp* p);
        std::tuple<int, bool> Precision(struct pp* p);
        bool Flag(struct pp* p, int b);
        std::tuple<int, struct gocpp::error> Write(struct pp* p, gocpp::slice<unsigned char> b);
        std::tuple<int, struct gocpp::error> WriteString(struct pp* p, std::string s);
        void unknownType(struct pp* p, reflect::Value v);
        void badVerb(struct pp* p, gocpp::rune verb);
        void fmtBool(struct pp* p, bool v, gocpp::rune verb);
        void fmt0x64(struct pp* p, uint64_t v, bool leading0x);
        void fmtInteger(struct pp* p, uint64_t v, bool isSigned, gocpp::rune verb);
        void fmtFloat(struct pp* p, double v, int size, gocpp::rune verb);
        void fmtComplex(struct pp* p, struct gocpp::complex128 v, int size, gocpp::rune verb);
        void fmtString(struct pp* p, std::string v, gocpp::rune verb);
        void fmtBytes(struct pp* p, gocpp::slice<unsigned char> v, gocpp::rune verb, std::string typeString);
        void fmtPointer(struct pp* p, reflect::Value value, gocpp::rune verb);
        void catchPanic(struct pp* p, go_any arg, gocpp::rune verb, std::string method);
        bool handleMethods(struct pp* p, gocpp::rune verb);
        void printArg(struct pp* p, go_any arg, gocpp::rune verb);
        void printValue(struct pp* p, reflect::Value value, gocpp::rune verb, int depth);
        std::tuple<int, int, bool> argNumber(struct pp* p, int argNum, std::string format, int i, int numArgs);
        void badArgNum(struct pp* p, gocpp::rune verb);
        void missingArg(struct pp* p, gocpp::rune verb);
        void doPrintf(struct pp* p, std::string format, gocpp::slice<go_any> a);
        void doPrint(struct pp* p, gocpp::slice<go_any> a);
        void doPrintln(struct pp* p, gocpp::slice<go_any> a);
    }
}

