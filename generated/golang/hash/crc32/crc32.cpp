// generated by GoCpp from file '$(ImportDir)/hash/crc32/crc32.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/hash/crc32/crc32.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/hash/crc32/crc32_amd64.h"
#include "golang/hash/crc32/crc32_generic.h"
#include "golang/hash/hash.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/once.h"

namespace golang::crc32
{
    int Size = 4;
    int IEEE = 0xedb88320;
    int Castagnoli = 0x82f63b78;
    int Koopman = 0xeb31d82e;
    Table* castagnoliTable;
    slicing8Table* castagnoliTable8;
    std::function<uint32_t (uint32_t crc, gocpp::slice<unsigned char> p)> updateCastagnoli;
    sync::Once castagnoliOnce;
    atomic::Bool haveCastagnoli;
    void castagnoliInit()
    {
        castagnoliTable = simpleMakeTable(Castagnoli);
        if(archAvailableCastagnoli())
        {
            archInitCastagnoli();
            updateCastagnoli = archUpdateCastagnoli;
        }
        else
        {
            castagnoliTable8 = slicingMakeTable(Castagnoli);
            updateCastagnoli = [=](uint32_t crc, gocpp::slice<unsigned char> p) mutable -> uint32_t
            {
                return slicingUpdate(crc, castagnoliTable8, p);
            }
;
        }
        Store(gocpp::recv(haveCastagnoli), true);
    }

    Table* IEEETable = simpleMakeTable(IEEE);
    slicing8Table* ieeeTable8;
    std::function<uint32_t (uint32_t crc, gocpp::slice<unsigned char> p)> updateIEEE;
    sync::Once ieeeOnce;
    void ieeeInit()
    {
        if(archAvailableIEEE())
        {
            archInitIEEE();
            updateIEEE = archUpdateIEEE;
        }
        else
        {
            ieeeTable8 = slicingMakeTable(IEEE);
            updateIEEE = [=](uint32_t crc, gocpp::slice<unsigned char> p) mutable -> uint32_t
            {
                return slicingUpdate(crc, ieeeTable8, p);
            }
;
        }
    }

    Table* MakeTable(uint32_t poly)
    {
        //Go switch emulation
        {
            auto condition = poly;
            int conditionId = -1;
            if(condition == IEEE) { conditionId = 0; }
            else if(condition == Castagnoli) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    Do(gocpp::recv(ieeeOnce), ieeeInit);
                    return IEEETable;
                    break;
                case 1:
                    Do(gocpp::recv(castagnoliOnce), castagnoliInit);
                    return castagnoliTable;
                    break;
                default:
                    return simpleMakeTable(poly);
                    break;
            }
        }
    }

    
    std::ostream& digest::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << crc;
        os << " " << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct digest& value)
    {
        return value.PrintTo(os);
    }

    hash::Hash32 New(Table* tab)
    {
        if(tab == IEEETable)
        {
            Do(gocpp::recv(ieeeOnce), ieeeInit);
        }
        return new digest {0, tab};
    }

    hash::Hash32 NewIEEE()
    {
        return New(IEEETable);
    }

    int Size(struct digest* d)
    {
        return Size;
    }

    int BlockSize(struct digest* d)
    {
        return 1;
    }

    void Reset(struct digest* d)
    {
        d->crc = 0;
    }

    std::string magic = "crc\x01";
    int marshaledSize = len(magic) + 4 + 4;
    std::tuple<gocpp::slice<unsigned char>, std::string> MarshalBinary(struct digest* d)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, marshaledSize);
        b = append(b, magic);
        b = appendUint32(b, tableSum(d->tab));
        b = appendUint32(b, d->crc);
        return {b, nullptr};
    }

    std::string UnmarshalBinary(struct digest* d, gocpp::slice<unsigned char> b)
    {
        if(len(b) < len(magic) || string(b.make_slice(0, len(magic))) != magic)
        {
            return New(gocpp::recv(errors), "hash/crc32: invalid hash state identifier");
        }
        if(len(b) != marshaledSize)
        {
            return New(gocpp::recv(errors), "hash/crc32: invalid hash state size");
        }
        if(tableSum(d->tab) != readUint32(b.make_slice(4)))
        {
            return New(gocpp::recv(errors), "hash/crc32: tables do not match");
        }
        d->crc = readUint32(b.make_slice(8));
        return nullptr;
    }

    gocpp::slice<unsigned char> appendUint32(gocpp::slice<unsigned char> b, uint32_t x)
    {
        return append(b, byte(x >> 24), byte(x >> 16), byte(x >> 8), byte(x));
    }

    uint32_t readUint32(gocpp::slice<unsigned char> b)
    {
        _ = b[3];
        return uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
    }

    uint32_t update(uint32_t crc, Table* tab, gocpp::slice<unsigned char> p, bool checkInitIEEE)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(Load(gocpp::recv(haveCastagnoli)) && tab == castagnoliTable) { conditionId = 0; }
            else if(tab == IEEETable) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return updateCastagnoli(crc, p);
                    break;
                case 1:
                    if(checkInitIEEE)
                    {
                        Do(gocpp::recv(ieeeOnce), ieeeInit);
                    }
                    return updateIEEE(crc, p);
                    break;
                default:
                    return simpleUpdate(crc, tab, p);
                    break;
            }
        }
    }

    uint32_t Update(uint32_t crc, Table* tab, gocpp::slice<unsigned char> p)
    {
        return update(crc, tab, p, true);
    }

    std::tuple<int, std::string> Write(struct digest* d, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        d->crc = update(d->crc, d->tab, p, false);
        return {len(p), nullptr};
    }

    uint32_t Sum32(struct digest* d)
    {
        return d->crc;
    }

    gocpp::slice<unsigned char> Sum(struct digest* d, gocpp::slice<unsigned char> in)
    {
        auto s = Sum32(gocpp::recv(d));
        return append(in, byte(s >> 24), byte(s >> 16), byte(s >> 8), byte(s));
    }

    uint32_t Checksum(gocpp::slice<unsigned char> data, Table* tab)
    {
        return Update(0, tab, data);
    }

    uint32_t ChecksumIEEE(gocpp::slice<unsigned char> data)
    {
        Do(gocpp::recv(ieeeOnce), ieeeInit);
        return updateIEEE(0, data);
    }

    uint32_t tableSum(Table* t)
    {
        gocpp::array<unsigned char, 1024> a = {};
        auto b = a.make_slice(0, 0);
        if(t != nullptr)
        {
            for(auto [_, x] : t)
            {
                b = appendUint32(b, x);
            }
        }
        return ChecksumIEEE(b);
    }

}

