// generated by GoCpp from file '$(ImportDir)/runtime/netpoll_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/netpoll_windows.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/defs_windows.h"  [Ignored, known errors]
#include "golang/runtime/netpoll.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    int _DWORD_MAX = 0xffffffff;
    uintptr_t _INVALID_HANDLE_VALUE = ^ uintptr(0);
    
    std::ostream& net_op::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << o;
        os << " " << pd;
        os << " " << mode;
        os << " " << errno;
        os << " " << qty;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const net_op& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& overlappedEntry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << key;
        os << " " << op;
        os << " " << internal;
        os << " " << qty;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const overlappedEntry& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t iocphandle = _INVALID_HANDLE_VALUE;
    atomic::Uint32 netpollWakeSig = _INVALID_HANDLE_VALUE;
    void netpollinit()
    {
        iocphandle = stdcall4(_CreateIoCompletionPort, _INVALID_HANDLE_VALUE, 0, 0, _DWORD_MAX);
        if(iocphandle == 0)
        {
            println("runtime: CreateIoCompletionPort failed (errno=", getlasterror(), ")");
            go_throw("runtime: netpollinit failed");
        }
    }

    bool netpollIsPollDescriptor(uintptr_t fd)
    {
        return fd == iocphandle;
    }

    int32_t netpollopen(uintptr_t fd, pollDesc* pd)
    {
        if(stdcall4(_CreateIoCompletionPort, fd, iocphandle, uintptr(Pointer(gocpp::recv(unsafe), pd)), 0) == 0)
        {
            return int32(getlasterror());
        }
        return 0;
    }

    int32_t netpollclose(uintptr_t fd)
    {
        return 0;
    }

    void netpollarm(pollDesc* pd, int mode)
    {
        go_throw("runtime: unused");
    }

    void netpollBreak()
    {
        if(! CompareAndSwap(gocpp::recv(netpollWakeSig), 0, 1))
        {
            return;
        }
        if(stdcall4(_PostQueuedCompletionStatus, iocphandle, 0, 0, 0) == 0)
        {
            println("runtime: netpoll: PostQueuedCompletionStatus failed (errno=", getlasterror(), ")");
            go_throw("runtime: netpoll: PostQueuedCompletionStatus failed");
        }
    }

    std::tuple<gList, int32_t> netpoll(int64_t delay)
    {
        gocpp::array<overlappedEntry, 64> entries = {};
        uint32_t wait = {};
        uint32_t qty = {};
        uint32_t flags = {};
        uint32_t n = {};
        uint32_t i = {};
        int32_t errno = {};
        net_op* op = {};
        gList toRun = {};
        auto mp = getg()->m;
        if(iocphandle == _INVALID_HANDLE_VALUE)
        {
            return {gList {}, 0};
        }
        if(delay < 0)
        {
            wait = _INFINITE;
        }
        else
        if(delay == 0)
        {
            wait = 0;
        }
        else
        if(delay < 1e6)
        {
            wait = 1;
        }
        else
        if(delay < 1e15)
        {
            wait = uint32_t(delay / 1e6);
        }
        else
        {
            wait = 1e9;
        }
        n = uint32_t(len(entries) / int(gomaxprocs));
        if(n < 8)
        {
            n = 8;
        }
        if(delay != 0)
        {
            mp->blocked = true;
        }
        if(stdcall6(_GetQueuedCompletionStatusEx, iocphandle, uintptr(Pointer(gocpp::recv(unsafe), & entries[0])), uintptr(n), uintptr(Pointer(gocpp::recv(unsafe), & n)), uintptr(wait), 0) == 0)
        {
            mp->blocked = false;
            errno = int32(getlasterror());
            if(errno == _WAIT_TIMEOUT)
            {
                return {gList {}, 0};
            }
            println("runtime: GetQueuedCompletionStatusEx failed (errno=", errno, ")");
            go_throw("runtime: netpoll failed");
        }
        mp->blocked = false;
        auto delta = int32(0);
        for(i = 0; i < n; i++)
        {
            op = entries[i].op;
            if(op != nullptr && op->pd == entries[i].key)
            {
                errno = 0;
                qty = 0;
                if(stdcall5(_WSAGetOverlappedResult, op->pd->fd, uintptr(Pointer(gocpp::recv(unsafe), op)), uintptr(Pointer(gocpp::recv(unsafe), & qty)), 0, uintptr(Pointer(gocpp::recv(unsafe), & flags))) == 0)
                {
                    errno = int32(getlasterror());
                }
                delta += handlecompletion(& toRun, op, errno, qty);
            }
            else
            {
                Store(gocpp::recv(netpollWakeSig), 0);
                if(delay == 0)
                {
                    netpollBreak();
                }
            }
        }
        return {toRun, delta};
    }

    int32_t handlecompletion(gList* toRun, net_op* op, int32_t errno, uint32_t qty)
    {
        auto mode = op->mode;
        if(mode != 'r' && mode != 'w')
        {
            println("runtime: GetQueuedCompletionStatusEx returned invalid mode=", mode);
            go_throw("runtime: netpoll failed");
        }
        op->errno = errno;
        op->qty = qty;
        return netpollready(toRun, op->pd, mode);
    }

}

