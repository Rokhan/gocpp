// generated by GoCpp from file '$(ImportDir)/runtime/mbitmap.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mbitmap.fwd.h"
#include "gocpp/support.h"

// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
#include "golang/runtime/mgcmark.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    unsigned char* addb(unsigned char* p, uintptr_t n);
    unsigned char* subtractb(unsigned char* p, uintptr_t n);
    unsigned char* add1(unsigned char* p);
    unsigned char* subtract1(unsigned char* p);
    struct markBits
    {
        uint8_t* bytep;
        uint8_t mask;
        uintptr_t index;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const markBits& value);
    markBits allocBitsForIndex(mspan* s, uintptr_t allocBitIndex);
    void refillAllocCache(mspan* s, uint16_t whichByte);
    uint16_t nextFreeIndex(mspan* s);
    bool isFree(mspan* s, uintptr_t index);
    uintptr_t divideByElemSize(mspan* s, uintptr_t n);
    uintptr_t objIndex(mspan* s, uintptr_t p);
    markBits markBitsForAddr(uintptr_t p);
    markBits markBitsForIndex(mspan* s, uintptr_t objIndex);
    markBits markBitsForBase(mspan* s);
    bool isMarked(markBits m);
    void setMarked(markBits m);
    void setMarkedNonAtomic(markBits m);
    void clearMarked(markBits m);
    markBits markBitsForSpan(uintptr_t base);
    void advance(markBits* m);
    extern uintptr_t clobberdeadPtr;
    void badPointer(mspan* s, uintptr_t p, uintptr_t refBase, uintptr_t refOff);
    std::tuple<uintptr_t, mspan*, uintptr_t> findObject(uintptr_t p, uintptr_t refBase, uintptr_t refOff);
    bool reflect_verifyNotInHeapPtr(uintptr_t p);
    extern int ptrBits;
    void bulkBarrierBitmap(uintptr_t dst, uintptr_t src, uintptr_t size, uintptr_t maskOffset, uint8_t* bits);
    void typeBitsBulkBarrier(_type* typ, uintptr_t dst, uintptr_t src, uintptr_t size);
    int countAlloc(mspan* s);
    uintptr_t readUintptr(unsigned char* p);
    bitvector progToPointerMask(unsigned char* prog, uintptr_t size);
    uintptr_t runGCProg(unsigned char* prog, unsigned char* dst);
    mspan* materializeGCProg(uintptr_t ptrdata, unsigned char* prog);
    void dematerializeGCProg(mspan* s);
    void dumpGCProg(unsigned char* p);
    gocpp::slice<unsigned char> reflect_gcbits(go_any x);
}

