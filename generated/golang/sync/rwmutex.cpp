// generated by GoCpp from file '$(ImportDir)/sync/rwmutex.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/rwmutex.h"
#include "gocpp/support.h"

// #include "golang/internal/race/norace.h"  [Ignored, known errors]
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
// #include "golang/sync/runtime.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    template<typename T> requires gocpp::GoStruct<T>
    RWMutex::operator T()
    {
        T result;
        result.w = this->w;
        result.writerSem = this->writerSem;
        result.readerSem = this->readerSem;
        result.readerCount = this->readerCount;
        result.readerWait = this->readerWait;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RWMutex::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (writerSem != ref.writerSem) return false;
        if (readerSem != ref.readerSem) return false;
        if (readerCount != ref.readerCount) return false;
        if (readerWait != ref.readerWait) return false;
        return true;
    }

    std::ostream& RWMutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << writerSem;
        os << " " << readerSem;
        os << " " << readerCount;
        os << " " << readerWait;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RWMutex& value)
    {
        return value.PrintTo(os);
    }

    void RLock(struct RWMutex* rw)
    {
        if(race::Enabled)
        {
            _ = rw->w.state;
            race::Disable();
        }
        if(Add(gocpp::recv(rw->readerCount), 1) < 0)
        {
            runtime_SemacquireRWMutexR(& rw->readerSem, false, 0);
        }
        if(race::Enabled)
        {
            race::Enable();
            race::Acquire(unsafe::Pointer(& rw->readerSem));
        }
    }

    bool TryRLock(struct RWMutex* rw)
    {
        if(race::Enabled)
        {
            _ = rw->w.state;
            race::Disable();
        }
        for(; ; )
        {
            auto c = Load(gocpp::recv(rw->readerCount));
            if(c < 0)
            {
                if(race::Enabled)
                {
                    race::Enable();
                }
                return false;
            }
            if(CompareAndSwap(gocpp::recv(rw->readerCount), c, c + 1))
            {
                if(race::Enabled)
                {
                    race::Enable();
                    race::Acquire(unsafe::Pointer(& rw->readerSem));
                }
                return true;
            }
        }
    }

    void RUnlock(struct RWMutex* rw)
    {
        if(race::Enabled)
        {
            _ = rw->w.state;
            race::ReleaseMerge(unsafe::Pointer(& rw->writerSem));
            race::Disable();
        }
        if(auto r = Add(gocpp::recv(rw->readerCount), - 1); r < 0)
        {
            rUnlockSlow(gocpp::recv(rw), r);
        }
        if(race::Enabled)
        {
            race::Enable();
        }
    }

    void rUnlockSlow(struct RWMutex* rw, int32_t r)
    {
        if(r + 1 == 0 || r + 1 == - rwmutexMaxReaders)
        {
            race::Enable();
            fatal("sync: RUnlock of unlocked RWMutex");
        }
        if(Add(gocpp::recv(rw->readerWait), - 1) == 0)
        {
            runtime_Semrelease(& rw->writerSem, false, 1);
        }
    }

    void Lock(struct RWMutex* rw)
    {
        if(race::Enabled)
        {
            _ = rw->w.state;
            race::Disable();
        }
        Lock(gocpp::recv(rw->w));
        auto r = Add(gocpp::recv(rw->readerCount), - rwmutexMaxReaders) + rwmutexMaxReaders;
        if(r != 0 && Add(gocpp::recv(rw->readerWait), r) != 0)
        {
            runtime_SemacquireRWMutex(& rw->writerSem, false, 0);
        }
        if(race::Enabled)
        {
            race::Enable();
            race::Acquire(unsafe::Pointer(& rw->readerSem));
            race::Acquire(unsafe::Pointer(& rw->writerSem));
        }
    }

    bool TryLock(struct RWMutex* rw)
    {
        if(race::Enabled)
        {
            _ = rw->w.state;
            race::Disable();
        }
        if(! TryLock(gocpp::recv(rw->w)))
        {
            if(race::Enabled)
            {
                race::Enable();
            }
            return false;
        }
        if(! CompareAndSwap(gocpp::recv(rw->readerCount), 0, - rwmutexMaxReaders))
        {
            Unlock(gocpp::recv(rw->w));
            if(race::Enabled)
            {
                race::Enable();
            }
            return false;
        }
        if(race::Enabled)
        {
            race::Enable();
            race::Acquire(unsafe::Pointer(& rw->readerSem));
            race::Acquire(unsafe::Pointer(& rw->writerSem));
        }
        return true;
    }

    void Unlock(struct RWMutex* rw)
    {
        if(race::Enabled)
        {
            _ = rw->w.state;
            race::Release(unsafe::Pointer(& rw->readerSem));
            race::Disable();
        }
        auto r = Add(gocpp::recv(rw->readerCount), rwmutexMaxReaders);
        if(r >= rwmutexMaxReaders)
        {
            race::Enable();
            fatal("sync: Unlock of unlocked RWMutex");
        }
        for(auto i = 0; i < int(r); i++)
        {
            runtime_Semrelease(& rw->readerSem, false, 0);
        }
        Unlock(gocpp::recv(rw->w));
        if(race::Enabled)
        {
            race::Enable();
        }
    }

    bool syscall_hasWaitingReaders(struct RWMutex* rw)
    {
        auto r = Load(gocpp::recv(rw->readerCount));
        return r < 0 && r + rwmutexMaxReaders > 0;
    }

    struct Locker RLocker(struct RWMutex* rw)
    {
        return (rlocker*)(rw);
    }

    void Lock(struct rlocker* r)
    {
        RLock(gocpp::recv((RWMutex*)(r)));
    }

    void Unlock(struct rlocker* r)
    {
        RUnlock(gocpp::recv((RWMutex*)(r)));
    }

}

