// generated by GoCpp from file '$(ImportDir)/internal/abi/abi.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/abi.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi_amd64.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/unsafe/unsafe.h"

namespace golang::abi
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // RegArgs is a struct that has space for each argument
    // and return value register on the current architecture.
    //
    // Assembly code knows the layout of the first two fields
    // of RegArgs.
    //
    // RegArgs also contains additional space to hold pointers
    // when it may not be safe to keep them only in the integer
    // register space otherwise.
    
    template<typename T> requires gocpp::GoStruct<T>
    RegArgs::operator T()
    {
        T result;
        result.Ints = this->Ints;
        result.Floats = this->Floats;
        result.Ptrs = this->Ptrs;
        result.ReturnIsPtr = this->ReturnIsPtr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RegArgs::operator==(const T& ref) const
    {
        if (Ints != ref.Ints) return false;
        if (Floats != ref.Floats) return false;
        if (Ptrs != ref.Ptrs) return false;
        if (ReturnIsPtr != ref.ReturnIsPtr) return false;
        return true;
    }

    std::ostream& RegArgs::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Ints;
        os << " " << Floats;
        os << " " << Ptrs;
        os << " " << ReturnIsPtr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RegArgs& value)
    {
        return value.PrintTo(os);
    }

    void rec::Dump(struct RegArgs* r)
    {
        print("Ints:"s);
        for(auto [gocpp_ignored, x] : r->Ints)
        {
            print(" "s, x);
        }
        println();
        print("Floats:"s);
        for(auto [gocpp_ignored, x] : r->Floats)
        {
            print(" "s, x);
        }
        println();
        print("Ptrs:"s);
        for(auto [gocpp_ignored, x] : r->Ptrs)
        {
            print(" "s, x);
        }
        println();
    }

    // IntRegArgAddr returns a pointer inside of r.Ints[reg] that is appropriately
    // offset for an argument of size argSize.
    //
    // argSize must be non-zero, fit in a register, and a power-of-two.
    //
    // This method is a helper for dealing with the endianness of different CPU
    // architectures, since sub-word-sized arguments in big endian architectures
    // need to be "aligned" to the upper edge of the register to be interpreted
    // by the CPU correctly.
    unsafe::Pointer rec::IntRegArgAddr(struct RegArgs* r, int reg, uintptr_t argSize)
    {
        if(argSize > goarch::PtrSize || argSize == 0 || argSize & (argSize - 1) != 0)
        {
            gocpp::panic("invalid argSize"s);
        }
        auto offset = uintptr_t(0);
        if(goarch::BigEndian)
        {
            offset = goarch::PtrSize - argSize;
        }
        return unsafe::Pointer(uintptr_t(unsafe::Pointer(& r->Ints[reg])) + offset);
    }

    // IntArgRegBitmap is a bitmap large enough to hold one bit per
    // integer argument/return register.
    // Set sets the i'th bit of the bitmap to 1.
    void rec::Set(golang::abi::IntArgRegBitmap* b, int i)
    {
        b[i / 8] |= uint8_t(1) << (i % 8);
    }

    // Get returns whether the i'th bit of the bitmap is set.
    //
    // nosplit because it's called in extremely sensitive contexts, like
    // on the reflectcall return path.
    //
    //go:nosplit
    bool rec::Get(golang::abi::IntArgRegBitmap* b, int i)
    {
        return b[i / 8] & (uint8_t(1) << (i % 8)) != 0;
    }

}

