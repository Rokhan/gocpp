// generated by GoCpp from file '$(ImportDir)/internal/syscall/windows/registry/key.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/syscall/windows/registry/key.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/registry/syscall.h"
#include "golang/internal/syscall/windows/registry/zsyscall_windows.h"
#include "golang/runtime/proc.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"

namespace golang::registry
{
    std::string Close(Key k)
    {
        return syscall::RegCloseKey(syscall::Handle(k));
    }

    std::tuple<Key, std::string> OpenKey(Key k, std::string path, uint32_t access)
    {
        auto [p, err] = syscall::UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return {0, err};
        }
        syscall::Handle subkey = {};
        err = syscall::RegOpenKeyEx(syscall::Handle(k), p, 0, access, & subkey);
        if(err != nullptr)
        {
            return {0, err};
        }
        return {Key(subkey), nullptr};
    }

    std::tuple<gocpp::slice<std::string>, std::string> ReadSubKeyNames(Key k)
    {
        gocpp::Defer defer;
        runtime::LockOSThread();
        defer.push_back([=]{ runtime::UnlockOSThread(); });
        auto names = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 256);
        loopItems:
        for(auto i = uint32_t(0); ; i++)
        {
            auto l = uint32_t(len(buf));
            for(; ; )
            {
                auto err = syscall::RegEnumKeyEx(syscall::Handle(k), i, & buf[0], & l, nullptr, nullptr, nullptr, nullptr);
                if(err == nullptr)
                {
                    break;
                }
                if(err == syscall::ERROR_MORE_DATA)
                {
                    l = uint32_t(2 * len(buf));
                    buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), l);
                    continue;
                }
                if(err == _ERROR_NO_MORE_ITEMS)
                {
                    goto loopItems_break;
                }
                return {names, err};
            }
            names = append(names, syscall::UTF16ToString(buf.make_slice(0, l)));
            if(false) {
            loopItems_continue:
                continue;
            loopItems_break:
                break;
            }
        }
        return {names, nullptr};
    }

    std::tuple<Key, bool, std::string> CreateKey(Key k, std::string path, uint32_t access)
    {
        Key newk;
        bool openedExisting;
        std::string err;
        syscall::Handle h = {};
        uint32_t d = {};
        err = regCreateKeyEx(syscall::Handle(k), syscall::StringToUTF16Ptr(path), 0, nullptr, _REG_OPTION_NON_VOLATILE, access, nullptr, & h, & d);
        if(err != nullptr)
        {
            Key newk;
            bool openedExisting;
            std::string err;
            return {0, false, err};
        }
        return {Key(h), d == _REG_OPENED_EXISTING_KEY, nullptr};
    }

    std::string DeleteKey(Key k, std::string path)
    {
        return regDeleteKey(syscall::Handle(k), syscall::StringToUTF16Ptr(path));
    }

    
    std::ostream& KeyInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << SubKeyCount;
        os << " " << MaxSubKeyLen;
        os << " " << ValueCount;
        os << " " << MaxValueNameLen;
        os << " " << MaxValueLen;
        os << " " << lastWriteTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct KeyInfo& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<KeyInfo*, std::string> Stat(Key k)
    {
        KeyInfo ki = {};
        auto err = syscall::RegQueryInfoKey(syscall::Handle(k), nullptr, nullptr, nullptr, & ki.SubKeyCount, & ki.MaxSubKeyLen, nullptr, & ki.ValueCount, & ki.MaxValueNameLen, & ki.MaxValueLen, nullptr, & ki.lastWriteTime);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {& ki, nullptr};
    }

}

