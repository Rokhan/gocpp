// generated by GoCpp from file '$(ImportDir)/runtime/mgc.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgc.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct gcTrigger
    {
        golang::runtime::gcTriggerKind kind;
        int64_t now;
        uint32_t n;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcTrigger& value);
    extern gocpp::array_base<std::string> gcMarkWorkerModeStrings;
    struct gocpp_id_1
    {
        mutex lock;
        mSpanList free;
        mSpanList busy;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value);
    struct gocpp_id_2
    {
        mutex lock;
        gQueue q;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value);
    struct gocpp_id_3
    {
        mutex lock;
        gList list;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value);
    struct gcBgMarkWorkerNode
    {
        lfnode node;
        golang::runtime::guintptr gp;
        golang::runtime::muintptr m;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcBgMarkWorkerNode& value);
    bool heapObjectsCanMove();
    void gcinit();
    void gcenable();
    void setGCPhase(uint32_t x);
    bool pollFractionalWorkerExit();
    void GC();
    void gcWaitOnMark(uint32_t n);
    void gcStart(struct gcTrigger trigger);
    void gcMarkDone();
    void gcMarkTermination(struct worldStop stw);
    void gcBgMarkStartWorkers();
    void gcBgMarkPrepare();
    void gcBgMarkWorker();
    bool gcMarkWorkAvailable(struct p* p);
    void gcMark(int64_t startTime);
    bool gcSweep(golang::runtime::gcMode mode);
    void gcResetMarkState();
    void sync_runtime_registerPoolCleanup(std::function<void ()> f);
    void boring_registerCache(unsafe::Pointer p);
    void clearpools();
    gocpp::slice<unsigned char> itoaDiv(gocpp::slice<unsigned char> buf, uint64_t val, int dec);
    gocpp::slice<unsigned char> fmtNSAsMS(gocpp::slice<unsigned char> buf, uint64_t ns);
    void gcTestMoveStackOnNextCall();
    uint64_t gcTestIsReachable(gocpp::slice<unsafe::Pointer> ptrs);
    
    template<typename... Args>
    uint64_t gcTestIsReachable(Args... ptrs)
    {
        return gcTestIsReachable(gocpp::ToSlice<unsafe::Pointer>(ptrs...));
    }
    
    template<typename... Args>
    uint64_t gcTestIsReachable(unsafe::Pointer value, Args... ptrs)
    {
        return gcTestIsReachable(gocpp::ToSlice<unsafe::Pointer>(value, ptrs...));
    }
    std::string gcTestPointerClass(unsafe::Pointer p);
    struct workType
    {
        golang::runtime::lfstack full;
        cpu::CacheLinePad _1;
        golang::runtime::lfstack empty;
        cpu::CacheLinePad _2;
        gocpp_id_1 wbufSpans;
        uint32_t _3;
        uint64_t bytesMarked;
        uint32_t markrootNext;
        uint32_t markrootJobs;
        uint32_t nproc;
        int64_t tstart;
        uint32_t nwait;
        int nDataRoots;
        int nBSSRoots;
        int nSpanRoots;
        int nStackRoots;
        uint32_t baseData;
        uint32_t baseBSS;
        uint32_t baseSpans;
        uint32_t baseStacks;
        uint32_t baseEnd;
        gocpp::slice<g*> stackRoots;
        uint32_t startSema;
        uint32_t markDoneSema;
        note bgMarkReady;
        uint32_t bgMarkDone;
        golang::runtime::gcMode mode;
        bool userForced;
        uint64_t initialHeapLive;
        gocpp_id_2 assistQueue;
        gocpp_id_3 sweepWaiters;
        atomic::Uint32 cycles;
        int32_t stwprocs;
        int32_t maxprocs;
        int64_t tSweepTerm;
        int64_t tMark;
        int64_t tMarkTerm;
        int64_t tEnd;
        int64_t pauseNS;
        uint64_t heap0;
        uint64_t heap1;
        uint64_t heap2;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct workType& value);

    namespace rec
    {
        bool test(struct gcTrigger t);
    }
}

