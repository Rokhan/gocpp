// generated by GoCpp from file '$(ImportDir)/sync/pool.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/pool.h"
#include "gocpp/support.h"

#include "golang/internal/race/norace.h"
#include "golang/runtime/debug.h"
#include "golang/sync/atomic/doc.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/cond.h"
#include "golang/sync/mutex.h"
#include "golang/sync/poolqueue.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Pool is a set of temporary objects that may be individually saved and
    // retrieved.
    //
    // Any item stored in the Pool may be removed automatically at any time without
    // notification. If the Pool holds the only reference when this happens, the
    // item might be deallocated.
    //
    // A Pool is safe for use by multiple goroutines simultaneously.
    //
    // Pool's purpose is to cache allocated but unused items for later reuse,
    // relieving pressure on the garbage collector. That is, it makes it easy to
    // build efficient, thread-safe free lists. However, it is not suitable for all
    // free lists.
    //
    // An appropriate use of a Pool is to manage a group of temporary items
    // silently shared among and potentially reused by concurrent independent
    // clients of a package. Pool provides a way to amortize allocation overhead
    // across many clients.
    //
    // An example of good use of a Pool is in the fmt package, which maintains a
    // dynamically-sized store of temporary output buffers. The store scales under
    // load (when many goroutines are actively printing) and shrinks when
    // quiescent.
    //
    // On the other hand, a free list maintained as part of a short-lived object is
    // not a suitable use for a Pool, since the overhead does not amortize well in
    // that scenario. It is more efficient to have such objects implement their own
    // free list.
    //
    // A Pool must not be copied after first use.
    //
    // In the terminology of the Go memory model, a call to Put(x) “synchronizes before”
    // a call to Get returning that same value x.
    // Similarly, a call to New returning x “synchronizes before”
    // a call to Get returning that same value x.
    
    template<typename T> requires gocpp::GoStruct<T>
    Pool::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.local = this->local;
        result.localSize = this->localSize;
        result.victim = this->victim;
        result.victimSize = this->victimSize;
        result.New = this->New;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Pool::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (local != ref.local) return false;
        if (localSize != ref.localSize) return false;
        if (victim != ref.victim) return false;
        if (victimSize != ref.victimSize) return false;
        if (New != ref.New) return false;
        return true;
    }

    std::ostream& Pool::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << local;
        os << " " << localSize;
        os << " " << victim;
        os << " " << victimSize;
        os << " " << New;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Pool& value)
    {
        return value.PrintTo(os);
    }

    // Local per-P Pool appendix.
    
    template<typename T> requires gocpp::GoStruct<T>
    poolLocalInternal::operator T()
    {
        T result;
        result.go_private = this->go_private;
        result.shared = this->shared;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolLocalInternal::operator==(const T& ref) const
    {
        if (go_private != ref.go_private) return false;
        if (shared != ref.shared) return false;
        return true;
    }

    std::ostream& poolLocalInternal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << go_private;
        os << " " << shared;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolLocalInternal& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    poolLocal::operator T()
    {
        T result;
        result.poolLocalInternal = this->poolLocalInternal;
        result.pad = this->pad;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolLocal::operator==(const T& ref) const
    {
        if (poolLocalInternal != ref.poolLocalInternal) return false;
        if (pad != ref.pad) return false;
        return true;
    }

    std::ostream& poolLocal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << poolLocalInternal;
        os << " " << pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolLocal& value)
    {
        return value.PrintTo(os);
    }

    // from runtime
    //go:linkname runtime_randn runtime.randn
    uint32_t runtime_randn(uint32_t n)
    /* convertBlockStmt, nil block */;

    gocpp::array<uint64_t, 128> poolRaceHash;
    // poolRaceAddr returns an address to use as the synchronization point
    // for race detector logic. We don't use the actual pointer stored in x
    // directly, for fear of conflicting with other synchronization on that address.
    // Instead, we hash the pointer to get an index into poolRaceHash.
    // See discussion on golang.org/cl/31589.
    unsafe::Pointer poolRaceAddr(go_any x)
    {
        auto ptr = uintptr_t((gocpp::array<unsafe::Pointer, 2>*)(unsafe::Pointer(& x))[1]);
        auto h = uint32_t((uint64_t(uint32_t(ptr)) * 0x85ebca6b) >> 16);
        return unsafe::Pointer(& poolRaceHash[h % uint32_t(len(poolRaceHash))]);
    }

    // Put adds x to the pool.
    void rec::Put(struct Pool* p, go_any x)
    {
        if(x == nullptr)
        {
            return;
        }
        if(race::Enabled)
        {
            if(runtime_randn(4) == 0)
            {
                return;
            }
            race::ReleaseMerge(poolRaceAddr(x));
            race::Disable();
        }
        auto [l, gocpp_id_0] = rec::pin(gocpp::recv(p));
        if(l->go_private == nullptr)
        {
            l->go_private = x;
        }
        else
        {
            rec::pushHead(gocpp::recv(l->shared), x);
        }
        runtime_procUnpin();
        if(race::Enabled)
        {
            race::Enable();
        }
    }

    // Get selects an arbitrary item from the Pool, removes it from the
    // Pool, and returns it to the caller.
    // Get may choose to ignore the pool and treat it as empty.
    // Callers should not assume any relation between values passed to Put and
    // the values returned by Get.
    //
    // If Get would otherwise return nil and p.New is non-nil, Get returns
    // the result of calling p.New.
    go_any rec::Get(struct Pool* p)
    {
        if(race::Enabled)
        {
            race::Disable();
        }
        auto [l, pid] = rec::pin(gocpp::recv(p));
        auto x = l->go_private;
        l->go_private = nullptr;
        if(x == nullptr)
        {
            std::tie(x, gocpp_id_1) = rec::popHead(gocpp::recv(l->shared));
            if(x == nullptr)
            {
                x = rec::getSlow(gocpp::recv(p), pid);
            }
        }
        runtime_procUnpin();
        if(race::Enabled)
        {
            race::Enable();
            if(x != nullptr)
            {
                race::Acquire(poolRaceAddr(x));
            }
        }
        if(x == nullptr && p->New != nullptr)
        {
            x = rec::New(gocpp::recv(p));
        }
        return x;
    }

    go_any rec::getSlow(struct Pool* p, int pid)
    {
        auto size = runtime_LoadAcquintptr(& p->localSize);
        auto locals = p->local;
        for(auto i = 0; i < int(size); i++)
        {
            auto l = indexLocal(locals, (pid + i + 1) % int(size));
            if(auto [x, gocpp_id_2] = rec::popTail(gocpp::recv(l->shared)); x != nullptr)
            {
                return x;
            }
        }
        size = atomic::LoadUintptr(& p->victimSize);
        if(uintptr_t(pid) >= size)
        {
            return nullptr;
        }
        locals = p->victim;
        auto l = indexLocal(locals, pid);
        if(auto x = l->go_private; x != nullptr)
        {
            l->go_private = nullptr;
            return x;
        }
        for(auto i = 0; i < int(size); i++)
        {
            auto l = indexLocal(locals, (pid + i) % int(size));
            if(auto [x, gocpp_id_3] = rec::popTail(gocpp::recv(l->shared)); x != nullptr)
            {
                return x;
            }
        }
        atomic::StoreUintptr(& p->victimSize, 0);
        return nullptr;
    }

    // pin pins the current goroutine to P, disables preemption and
    // returns poolLocal pool for the P and the P's id.
    // Caller must call runtime_procUnpin() when done with the pool.
    std::tuple<struct poolLocal*, int> rec::pin(struct Pool* p)
    {
        if(p == nullptr)
        {
            gocpp::panic("nil Pool"s);
        }
        auto pid = runtime_procPin();
        auto s = runtime_LoadAcquintptr(& p->localSize);
        auto l = p->local;
        if(uintptr_t(pid) < s)
        {
            return {indexLocal(l, pid), pid};
        }
        return rec::pinSlow(gocpp::recv(p));
    }

    std::tuple<struct poolLocal*, int> rec::pinSlow(struct Pool* p)
    {
        gocpp::Defer defer;
        try
        {
            runtime_procUnpin();
            rec::Lock(gocpp::recv(allPoolsMu));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(allPoolsMu)); });
            auto pid = runtime_procPin();
            auto s = p->localSize;
            auto l = p->local;
            if(uintptr_t(pid) < s)
            {
                return {indexLocal(l, pid), pid};
            }
            if(p->local == nullptr)
            {
                allPools = append(allPools, p);
            }
            auto size = runtime::GOMAXPROCS(0);
            auto local = gocpp::make(gocpp::Tag<gocpp::slice<poolLocal>>(), size);
            atomic::StorePointer(& p->local, unsafe::Pointer(& local[0]));
            runtime_StoreReluintptr(& p->localSize, uintptr_t(size));
            return {& local[pid], pid};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void poolCleanup()
    {
        for(auto [gocpp_ignored, p] : oldPools)
        {
            p->victim = nullptr;
            p->victimSize = 0;
        }
        for(auto [gocpp_ignored, p] : allPools)
        {
            p->victim = p->local;
            p->victimSize = p->localSize;
            p->local = nullptr;
            p->localSize = 0;
        }
        std::tie(oldPools, allPools) = std::tuple{allPools, nullptr};
    }

    // allPools is the set of pools that have non-empty primary
    // caches. Protected by either 1) allPoolsMu and pinning or 2)
    // STW.
    // oldPools is the set of pools that may have non-empty victim
    // caches. Protected by STW.
    Mutex allPoolsMu;
    gocpp::slice<Pool*> allPools;
    gocpp::slice<Pool*> oldPools;
    void init()
    {
        runtime_registerPoolCleanup(poolCleanup);
    }

    struct poolLocal* indexLocal(unsafe::Pointer l, int i)
    {
        auto lp = unsafe::Pointer(uintptr_t(l) + uintptr_t(i) * gocpp::Sizeof<poolLocal>());
        return (poolLocal*)(lp);
    }

    // Implemented in runtime.
    void runtime_registerPoolCleanup(std::function<void ()> cleanup)
    /* convertBlockStmt, nil block */;

    int runtime_procPin()
    /* convertBlockStmt, nil block */;

    void runtime_procUnpin()
    /* convertBlockStmt, nil block */;

    //go:linkname runtime_LoadAcquintptr runtime/internal/atomic.LoadAcquintptr
    uintptr_t runtime_LoadAcquintptr(uintptr_t* ptr)
    /* convertBlockStmt, nil block */;

    //go:linkname runtime_StoreReluintptr runtime/internal/atomic.StoreReluintptr
    uintptr_t runtime_StoreReluintptr(uintptr_t* ptr, uintptr_t val)
    /* convertBlockStmt, nil block */;

}

