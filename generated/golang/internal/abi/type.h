// generated by GoCpp from file '$(ImportDir)/internal/abi/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/type.fwd.h"
#include "gocpp/support.h"

#include "golang/unsafe/unsafe.h"

namespace golang::abi
{
    struct Type
    {
        uintptr_t Size_;
        uintptr_t PtrBytes;
        uint32_t Hash;
        TFlag TFlag;
        uint8_t Align_;
        uint8_t FieldAlign_;
        uint8_t Kind_;
        std::function<bool (unsafe::Pointer, unsafe::Pointer)> Equal;
        unsigned char* GCData;
        NameOff Str;
        TypeOff PtrToThis;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    extern abi.Kind Bool;
    extern abi.Kind Int;
    extern abi.Kind Int8;
    extern abi.Kind Int16;
    extern abi.Kind Int32;
    extern abi.Kind Int64;
    extern abi.Kind Uint;
    extern abi.Kind Uint8;
    extern abi.Kind Uint16;
    extern abi.Kind Uint32;
    extern abi.Kind Uint64;
    extern abi.Kind Uintptr;
    extern abi.Kind Float32;
    extern abi.Kind Float64;
    extern abi.Kind Complex64;
    extern abi.Kind Complex128;
    extern abi.Kind Array;
    extern abi.Kind Chan;
    extern abi.Kind Func;
    extern abi.Kind Interface;
    extern abi.Kind Map;
    extern abi.Kind Pointer;
    extern abi.Kind Slice;
    extern abi.Kind String;
    extern abi.Kind Struct;
    extern abi.Kind UnsafePointer;
    extern int KindDirectIface;
    extern int KindGCProg;
    extern int KindMask;
    std::string String(Kind k);
    extern gocpp::slice<std::string> kindNames;
    Kind Kind(struct Type* t);
    bool HasName(struct Type* t);
    bool Pointers(struct Type* t);
    bool IfaceIndir(struct Type* t);
    bool IsDirectIface(struct Type* t);
    gocpp::slice<unsigned char> GcSlice(struct Type* t, uintptr_t begin, uintptr_t end);
    struct Method
    {
        NameOff Name;
        TypeOff Mtyp;
        TextOff Ifn;
        TextOff Tfn;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Method& value);
    struct UncommonType
    {
        NameOff PkgPath;
        uint16_t Mcount;
        uint16_t Xcount;
        uint32_t Moff;
        uint32_t _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct UncommonType& value);
    gocpp::slice<Method> Methods(struct UncommonType* t);
    gocpp::slice<Method> ExportedMethods(struct UncommonType* t);
    unsafe::Pointer addChecked(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    struct Imethod
    {
        NameOff Name;
        TypeOff Typ;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Imethod& value);
    struct ArrayType
    {
        Type* Elem;
        Type* Slice;
        uintptr_t Len;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ArrayType& value);
    int Len(struct Type* t);
    Type* Common(struct Type* t);
    extern abi.ChanDir SendDir;
    extern abi.ChanDir BothDir;
    struct ChanType
    {
        Type* Elem;
        ChanDir Dir;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ChanType& value);
    struct structTypeUncommon
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value);
    ChanDir ChanDir(struct Type* t);
    UncommonType* Uncommon(struct Type* t);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    struct u
    {
        UncommonType u;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct u& value);
    Type* Elem(struct Type* t);
    StructType* StructType(struct Type* t);
    MapType* MapType(struct Type* t);
    ArrayType* ArrayType(struct Type* t);
    FuncType* FuncType(struct Type* t);
    InterfaceType* InterfaceType(struct Type* t);
    uintptr_t Size(struct Type* t);
    int Align(struct Type* t);
    int FieldAlign(struct Type* t);
    struct InterfaceType
    {
        Name PkgPath;
        gocpp::slice<Imethod> Methods;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct InterfaceType& value);
    gocpp::slice<Method> ExportedMethods(struct Type* t);
    int NumMethod(struct Type* t);
    int NumMethod(struct InterfaceType* t);
    struct MapType
    {
        Type* Key;
        Type* Elem;
        Type* Bucket;
        std::function<uintptr_t (unsafe::Pointer, uintptr_t)> Hasher;
        uint8_t KeySize;
        uint8_t ValueSize;
        uint16_t BucketSize;
        uint32_t Flags;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MapType& value);
    bool IndirectKey(struct MapType* mt);
    bool IndirectElem(struct MapType* mt);
    bool ReflexiveKey(struct MapType* mt);
    bool NeedKeyUpdate(struct MapType* mt);
    bool HashMightPanic(struct MapType* mt);
    Type* Key(struct Type* t);
    struct SliceType
    {
        Type* Elem;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SliceType& value);
    struct FuncType
    {
        uint16_t InCount;
        uint16_t OutCount;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct FuncType& value);
    Type* In(struct FuncType* t, int i);
    int NumIn(struct FuncType* t);
    int NumOut(struct FuncType* t);
    Type* Out(struct FuncType* t, int i);
    gocpp::slice<Type*> InSlice(struct FuncType* t);
    gocpp::slice<Type*> OutSlice(struct FuncType* t);
    bool IsVariadic(struct FuncType* t);
    struct PtrType
    {
        Type* Elem;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct PtrType& value);
    struct StructField
    {
        Name Name;
        Type* Typ;
        uintptr_t Offset;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructField& value);
    bool Embedded(struct StructField* f);
    struct StructType
    {
        Name PkgPath;
        gocpp::slice<StructField> Fields;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructType& value);
    struct Name
    {
        unsigned char* Bytes;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Name& value);
    unsigned char* DataChecked(struct Name n, int off, std::string whySafe);
    unsigned char* Data(struct Name n, int off);
    bool IsExported(struct Name n);
    bool HasTag(struct Name n);
    bool IsEmbedded(struct Name n);
    std::tuple<int, int> ReadVarint(struct Name n, int off);
    bool IsBlank(struct Name n);
    int writeVarint(gocpp::slice<unsigned char> buf, int n);
    std::string Name(struct Name n);
    std::string Tag(struct Name n);
    Name NewName(std::string n, std::string tag, bool exported, bool embedded);
}

