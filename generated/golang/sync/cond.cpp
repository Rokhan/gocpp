// generated by GoCpp from file '$(ImportDir)/sync/cond.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/cond.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/mutex.h"
// #include "golang/sync/runtime.h"  [Ignored, known errors]
// #include "golang/sync/runtime2.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    std::ostream& Cond::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << L;
        os << " " << notify;
        os << " " << checker;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Cond& value)
    {
        return value.PrintTo(os);
    }

    Cond* NewCond(Locker l)
    {
        return gocpp::InitPtr<Cond>([](Cond& x) { x.L = l; });
    }

    void Wait(struct Cond* c)
    {
        check(gocpp::recv(c->checker));
        auto t = runtime_notifyListAdd(& c->notify);
        Unlock(gocpp::recv(c->L));
        runtime_notifyListWait(& c->notify, t);
        Lock(gocpp::recv(c->L));
    }

    void Signal(struct Cond* c)
    {
        check(gocpp::recv(c->checker));
        runtime_notifyListNotifyOne(& c->notify);
    }

    void Broadcast(struct Cond* c)
    {
        check(gocpp::recv(c->checker));
        runtime_notifyListNotifyAll(& c->notify);
    }

    void check(copyChecker* c)
    {
        if(uintptr(*c) != uintptr(Pointer(gocpp::recv(unsafe), c)) && ! CompareAndSwapUintptr(gocpp::recv(atomic), (uintptr_t*)(c), 0, uintptr(Pointer(gocpp::recv(unsafe), c))) && uintptr(*c) != uintptr(Pointer(gocpp::recv(unsafe), c)))
        {
            gocpp::panic("sync.Cond is copied");
        }
    }

    
    std::ostream& noCopy::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value)
    {
        return value.PrintTo(os);
    }

    void Lock(noCopy*)
    {
    }

    void Unlock(noCopy*)
    {
    }

}

