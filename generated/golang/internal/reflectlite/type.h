// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/type.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"

namespace golang::reflectlite
{
    struct Type : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        Type(){}
        Type(Type& i) = default;
        Type(const Type& i) = default;
        Type& operator=(Type& i) = default;
        Type& operator=(const Type& i) = default;

        template<typename T>
        Type(T& ref);

        template<typename T>
        Type(const T& ref);

        template<typename T>
        Type(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IType
        {
            virtual std::string vName() = 0;
            virtual std::string vPkgPath() = 0;
            virtual uintptr_t vSize() = 0;
            virtual reflectlite::Kind vKind() = 0;
            virtual bool vImplements(struct Type u) = 0;
            virtual bool vAssignableTo(struct Type u) = 0;
            virtual bool vComparable() = 0;
            virtual std::string vString() = 0;
            virtual struct Type vElem() = 0;
            virtual abi::Type* vcommon() = 0;
            virtual reflectlite::uncommonType* vuncommon() = 0;
        };

        template<typename T, typename StoreT>
        struct TypeImpl : IType
        {
            explicit TypeImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vName() override;

            std::string vPkgPath() override;

            uintptr_t vSize() override;

            reflectlite::Kind vKind() override;

            bool vImplements(struct Type u) override;

            bool vAssignableTo(struct Type u) override;

            bool vComparable() override;

            std::string vString() override;

            struct Type vElem() override;

            abi::Type* vcommon() override;

            reflectlite::uncommonType* vuncommon() override;

            StoreT value;
        };

        std::shared_ptr<IType> value;
    };

    namespace rec
    {
        std::string Name(const gocpp::PtrRecv<struct Type, false>& self);
        std::string Name(const gocpp::ObjRecv<struct Type>& self);

        std::string PkgPath(const gocpp::PtrRecv<struct Type, false>& self);
        std::string PkgPath(const gocpp::ObjRecv<struct Type>& self);

        uintptr_t Size(const gocpp::PtrRecv<struct Type, false>& self);
        uintptr_t Size(const gocpp::ObjRecv<struct Type>& self);

        reflectlite::Kind Kind(const gocpp::PtrRecv<struct Type, false>& self);
        reflectlite::Kind Kind(const gocpp::ObjRecv<struct Type>& self);

        bool Implements(const gocpp::PtrRecv<struct Type, false>& self, struct Type u);
        bool Implements(const gocpp::ObjRecv<struct Type>& self, struct Type u);

        bool AssignableTo(const gocpp::PtrRecv<struct Type, false>& self, struct Type u);
        bool AssignableTo(const gocpp::ObjRecv<struct Type>& self, struct Type u);

        bool Comparable(const gocpp::PtrRecv<struct Type, false>& self);
        bool Comparable(const gocpp::ObjRecv<struct Type>& self);

        std::string String(const gocpp::PtrRecv<struct Type, false>& self);
        std::string String(const gocpp::ObjRecv<struct Type>& self);

        struct Type Elem(const gocpp::PtrRecv<struct Type, false>& self);
        struct Type Elem(const gocpp::ObjRecv<struct Type>& self);

        abi::Type* common(const gocpp::PtrRecv<struct Type, false>& self);
        abi::Type* common(const gocpp::ObjRecv<struct Type>& self);

        reflectlite::uncommonType* uncommon(const gocpp::PtrRecv<struct Type, false>& self);
        reflectlite::uncommonType* uncommon(const gocpp::ObjRecv<struct Type>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    struct rtype
    {
        abi::Type* Type;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct rtype& value);
    struct name
    {
        unsigned char* bytes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct name& value);
    std::string pkgPath(abi::Name n);
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off);
    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off);
    reflectlite::rtype toRType(abi::Type* t);
    abi::Type* elem(abi::Type* t);
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    struct Type TypeOf(go_any i);
    bool implements(abi::Type* T, abi::Type* V);
    bool directlyAssignable(abi::Type* T, abi::Type* V);
    bool haveIdenticalType(abi::Type* T, abi::Type* V, bool cmpTags);
    bool haveIdenticalUnderlyingType(abi::Type* T, abi::Type* V, bool cmpTags);
    struct Type toType(abi::Type* t);
    bool ifaceIndir(abi::Type* t);
    struct mapType
    {
        rtype rtype;
        abi::Type* Key;
        abi::Type* Elem;
        abi::Type* Bucket;
        std::function<uintptr_t (unsafe::Pointer _1, uintptr_t _2)> Hasher;
        uint8_t KeySize;
        uint8_t ValueSize;
        uint16_t BucketSize;
        uint32_t Flags;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapType& value);

    namespace rec
    {
        unsigned char* data(struct name n, int off, std::string whySafe);
        bool isExported(struct name n);
        bool hasTag(struct name n);
        bool embedded(struct name n);
        std::tuple<int, int> readVarint(struct name n, int off);
        std::string name(struct name n);
        std::string tag(struct name n);
        abi::Name nameOff(reflectlite::rtype t, golang::reflectlite::nameOff off);
        abi::Type* typeOff(reflectlite::rtype t, golang::reflectlite::typeOff off);
        reflectlite::uncommonType* uncommon(reflectlite::rtype t);
        std::string String(reflectlite::rtype t);
        abi::Type* common(reflectlite::rtype t);
        gocpp::slice<abi::Method> exportedMethods(reflectlite::rtype t);
        int NumMethod(reflectlite::rtype t);
        std::string PkgPath(reflectlite::rtype t);
        std::string Name(reflectlite::rtype t);
        struct Type Elem(reflectlite::rtype t);
        struct Type In(reflectlite::rtype t, int i);
        struct Type Key(reflectlite::rtype t);
        int Len(reflectlite::rtype t);
        int NumField(reflectlite::rtype t);
        int NumIn(reflectlite::rtype t);
        int NumOut(reflectlite::rtype t);
        struct Type Out(reflectlite::rtype t, int i);
        bool Implements(reflectlite::rtype t, struct Type u);
        bool AssignableTo(reflectlite::rtype t, struct Type u);
        bool Comparable(reflectlite::rtype t);
    }
}

