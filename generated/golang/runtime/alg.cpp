// generated by GoCpp from file '$(ImportDir)/runtime/alg.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/alg.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/hash64.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using abi::rec::HashMightPanic;
        using abi::rec::IsBlank;
    }

    uintptr_t memhash0(gocpp::unsafe_pointer p, uintptr_t h)
    {
        return h;
    }

    uintptr_t memhash8(gocpp::unsafe_pointer p, uintptr_t h)
    {
        return memhash(p, h, 1);
    }

    uintptr_t memhash16(gocpp::unsafe_pointer p, uintptr_t h)
    {
        return memhash(p, h, 2);
    }

    uintptr_t memhash128(gocpp::unsafe_pointer p, uintptr_t h)
    {
        return memhash(p, h, 16);
    }

    //go:nosplit
    uintptr_t memhash_varlen(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto ptr = getclosureptr();
        auto size = *(uintptr_t*)(gocpp::unsafe_pointer(ptr + gocpp::Sizeof<uintptr_t>()));
        return memhash(p, h, size);
    }

    // runtime variable to check if the processor we're running on
    // actually supports the instructions used by the AES-based
    // hash implementation.
    bool useAeshash;
    // in asm_*.s
    uintptr_t memhash(gocpp::unsafe_pointer p, uintptr_t h, uintptr_t s)
    /* convertBlockStmt, nil block */;

    uintptr_t memhash32(gocpp::unsafe_pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    uintptr_t memhash64(gocpp::unsafe_pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    uintptr_t strhash(gocpp::unsafe_pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    uintptr_t strhashFallback(gocpp::unsafe_pointer a, uintptr_t h)
    {
        auto x = (stringStruct*)(a);
        return memhashFallback(x->str, h, uintptr_t(x->len));
    }

    uintptr_t f32hash(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto f = *(float*)(p);
        //Go switch emulation
        {
            int conditionId = -1;
            if(f == 0) { conditionId = 0; }
            else if(f != f) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return c1 * (c0 ^ h);
                    break;
                case 1:
                    return c1 * (c0 ^ h ^ uintptr_t(rand()));
                    break;
                default:
                    return memhash(p, h, 4);
                    break;
            }
        }
    }

    uintptr_t f64hash(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto f = *(double*)(p);
        //Go switch emulation
        {
            int conditionId = -1;
            if(f == 0) { conditionId = 0; }
            else if(f != f) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return c1 * (c0 ^ h);
                    break;
                case 1:
                    return c1 * (c0 ^ h ^ uintptr_t(rand()));
                    break;
                default:
                    return memhash(p, h, 8);
                    break;
            }
        }
    }

    uintptr_t c64hash(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto x = (gocpp::array_ptr<gocpp::array<float, 2>>)(p);
        return f32hash(gocpp::unsafe_pointer(& x[1]), f32hash(gocpp::unsafe_pointer(& x[0]), h));
    }

    uintptr_t c128hash(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto x = (gocpp::array_ptr<gocpp::array<double, 2>>)(p);
        return f64hash(gocpp::unsafe_pointer(& x[1]), f64hash(gocpp::unsafe_pointer(& x[0]), h));
    }

    uintptr_t interhash(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto a = (iface*)(p);
        auto tab = a->tab;
        if(tab == nullptr)
        {
            return h;
        }
        auto t = tab->_type;
        if(t->Equal == nullptr)
        {
            gocpp::panic(errorString("hash of unhashable type "_s + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return c1 * typehash(t, gocpp::unsafe_pointer(& a->data), h ^ c0);
        }
        else
        {
            return c1 * typehash(t, a->data, h ^ c0);
        }
    }

    uintptr_t nilinterhash(gocpp::unsafe_pointer p, uintptr_t h)
    {
        auto a = (eface*)(p);
        auto t = a->_type;
        if(t == nullptr)
        {
            return h;
        }
        if(t->Equal == nullptr)
        {
            gocpp::panic(errorString("hash of unhashable type "_s + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return c1 * typehash(t, gocpp::unsafe_pointer(& a->data), h ^ c0);
        }
        else
        {
            return c1 * typehash(t, a->data, h ^ c0);
        }
    }

    // typehash computes the hash of the object of type t at address p.
    // h is the seed.
    // This function is seldom used. Most maps use for hashing either
    // fixed functions (e.g. f32hash) or compiler-generated functions
    // (e.g. for a type like struct { x, y string }). This implementation
    // is slower but more general and is used for hashing interface types
    // (called from interhash or nilinterhash, above) or for hashing in
    // maps generated by reflect.MapOf (reflect_typehash, below).
    // Note: this function must match the compiler generated
    // functions exactly. See issue 37716.
    uintptr_t typehash(golang::runtime::_type* t, gocpp::unsafe_pointer p, uintptr_t h)
    {
        if(t->TFlag & abi::TFlagRegularMemory != 0)
        {
            //Go switch emulation
            {
                auto condition = t->Size_;
                int conditionId = -1;
                if(condition == 4) { conditionId = 0; }
                else if(condition == 8) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        return memhash32(p, h);
                        break;
                    case 1:
                        return memhash64(p, h);
                        break;
                    default:
                        return memhash(p, h, t->Size_);
                        break;
                }
            }
        }
        //Go switch emulation
        {
            auto condition = t->Kind_ & kindMask;
            int conditionId = -1;
            if(condition == kindFloat32) { conditionId = 0; }
            else if(condition == kindFloat64) { conditionId = 1; }
            else if(condition == kindComplex64) { conditionId = 2; }
            else if(condition == kindComplex128) { conditionId = 3; }
            else if(condition == kindString) { conditionId = 4; }
            else if(condition == kindInterface) { conditionId = 5; }
            else if(condition == kindArray) { conditionId = 6; }
            else if(condition == kindStruct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return f32hash(p, h);
                    break;
                case 1:
                    return f64hash(p, h);
                    break;
                case 2:
                    return c64hash(p, h);
                    break;
                case 3:
                    return c128hash(p, h);
                    break;
                case 4:
                    return strhash(p, h);
                    break;
                case 5:
                    auto i = (runtime::interfacetype*)(gocpp::unsafe_pointer(t));
                    if(len(i->Methods) == 0)
                    {
                        return nilinterhash(p, h);
                    }
                    return interhash(p, h);
                    break;
                case 6:
                    auto a = (runtime::arraytype*)(gocpp::unsafe_pointer(t));
                    for(auto i = uintptr_t(0); i < a->Len; i++)
                    {
                        h = typehash(a->Elem, add(p, i * a->Elem->Size_), h);
                    }
                    return h;
                    break;
                case 7:
                    auto s = (runtime::structtype*)(gocpp::unsafe_pointer(t));
                    for(auto [gocpp_ignored, f] : s->Fields)
                    {
                        if(rec::IsBlank(gocpp::recv(f.Name)))
                        {
                            continue;
                        }
                        h = typehash(f.Typ, add(p, f.Offset), h);
                    }
                    return h;
                    break;
                default:
                    gocpp::panic(errorString("hash of unhashable type "_s + rec::string(gocpp::recv(toRType(t)))));
                    break;
            }
        }
    }

    struct gocpp::error mapKeyError(golang::runtime::maptype* t, gocpp::unsafe_pointer p)
    {
        if(! rec::HashMightPanic(gocpp::recv(t)))
        {
            return nullptr;
        }
        return mapKeyError2(t->Key, p);
    }

    struct gocpp::error mapKeyError2(golang::runtime::_type* t, gocpp::unsafe_pointer p)
    {
        if(t->TFlag & abi::TFlagRegularMemory != 0)
        {
            return nullptr;
        }
        //Go switch emulation
        {
            auto condition = t->Kind_ & kindMask;
            int conditionId = -1;
            if(condition == kindFloat32) { conditionId = 0; }
            else if(condition == kindFloat64) { conditionId = 1; }
            else if(condition == kindComplex64) { conditionId = 2; }
            else if(condition == kindComplex128) { conditionId = 3; }
            else if(condition == kindString) { conditionId = 4; }
            else if(condition == kindInterface) { conditionId = 5; }
            else if(condition == kindArray) { conditionId = 6; }
            else if(condition == kindStruct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    return nullptr;
                    break;
                case 5:
                    auto i = (runtime::interfacetype*)(gocpp::unsafe_pointer(t));
                    runtime::_type* t = {};
                    gocpp::unsafe_pointer* pdata = {};
                    if(len(i->Methods) == 0)
                    {
                        auto a = (eface*)(p);
                        t = a->_type;
                        if(t == nullptr)
                        {
                            return nullptr;
                        }
                        pdata = & a->data;
                    }
                    else
                    {
                        auto a = (iface*)(p);
                        if(a->tab == nullptr)
                        {
                            return nullptr;
                        }
                        t = a->tab->_type;
                        pdata = & a->data;
                    }
                    if(t->Equal == nullptr)
                    {
                        return gocpp::error(errorString("hash of unhashable type "_s + rec::string(gocpp::recv(toRType(t)))));
                    }
                    if(isDirectIface(t))
                    {
                        return mapKeyError2(t, gocpp::unsafe_pointer(pdata));
                    }
                    else
                    {
                        return mapKeyError2(t, *pdata);
                    }
                    break;
                case 6:
                    auto a = (runtime::arraytype*)(gocpp::unsafe_pointer(t));
                    for(auto i = uintptr_t(0); i < a->Len; i++)
                    {
                        if(auto err = mapKeyError2(a->Elem, add(p, i * a->Elem->Size_)); err != nullptr)
                        {
                            return err;
                        }
                    }
                    return nullptr;
                    break;
                case 7:
                    auto s = (runtime::structtype*)(gocpp::unsafe_pointer(t));
                    for(auto [gocpp_ignored, f] : s->Fields)
                    {
                        if(rec::IsBlank(gocpp::recv(f.Name)))
                        {
                            continue;
                        }
                        if(auto err = mapKeyError2(f.Typ, add(p, f.Offset)); err != nullptr)
                        {
                            return err;
                        }
                    }
                    return nullptr;
                    break;
                default:
                    return gocpp::error(errorString("hash of unhashable type "_s + rec::string(gocpp::recv(toRType(t)))));
                    break;
            }
        }
    }

    //go:linkname reflect_typehash reflect.typehash
    uintptr_t reflect_typehash(golang::runtime::_type* t, gocpp::unsafe_pointer p, uintptr_t h)
    {
        return typehash(t, p, h);
    }

    bool memequal0(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return true;
    }

    bool memequal8(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(int8_t*)(p) == *(int8_t*)(q);
    }

    bool memequal16(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(int16_t*)(p) == *(int16_t*)(q);
    }

    bool memequal32(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(int32_t*)(p) == *(int32_t*)(q);
    }

    bool memequal64(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(int64_t*)(p) == *(int64_t*)(q);
    }

    bool memequal128(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(gocpp::array_ptr<gocpp::array<int64_t, 2>>)(p) == *(gocpp::array_ptr<gocpp::array<int64_t, 2>>)(q);
    }

    bool f32equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(float*)(p) == *(float*)(q);
    }

    bool f64equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(double*)(p) == *(double*)(q);
    }

    bool c64equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(gocpp::complex64*)(p) == *(gocpp::complex64*)(q);
    }

    bool c128equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(gocpp::complex128*)(p) == *(gocpp::complex128*)(q);
    }

    bool strequal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        return *(gocpp::string*)(p) == *(gocpp::string*)(q);
    }

    bool interequal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        auto x = *(iface*)(p);
        auto y = *(iface*)(q);
        return x.tab == y.tab && ifaceeq(x.tab, x.data, y.data);
    }

    bool nilinterequal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q)
    {
        auto x = *(eface*)(p);
        auto y = *(eface*)(q);
        return x._type == y._type && efaceeq(x._type, x.data, y.data);
    }

    bool efaceeq(golang::runtime::_type* t, gocpp::unsafe_pointer x, gocpp::unsafe_pointer y)
    {
        if(t == nullptr)
        {
            return true;
        }
        auto eq = [&](auto z, auto u){ return abi::rec::Equal(t, z, u); };
        if(eq == nullptr)
        {
            gocpp::panic(errorString("comparing uncomparable type "_s + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return x == y;
        }
        return eq(x, y);
    }

    bool ifaceeq(struct itab* tab, gocpp::unsafe_pointer x, gocpp::unsafe_pointer y)
    {
        if(tab == nullptr)
        {
            return true;
        }
        auto t = tab->_type;
        auto eq = [&](auto z, auto t){ return abi::rec::Equal(t, z, t); };
        if(eq == nullptr)
        {
            gocpp::panic(errorString("comparing uncomparable type "_s + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return x == y;
        }
        return eq(x, y);
    }

    // Testing adapters for hash quality tests (see hash_test.go)
    uintptr_t stringHash(gocpp::string s, uintptr_t seed)
    {
        return strhash(noescape(gocpp::unsafe_pointer(& s)), seed);
    }

    uintptr_t bytesHash(gocpp::slice<unsigned char> b, uintptr_t seed)
    {
        auto s = (slice*)(gocpp::unsafe_pointer(& b));
        return memhash(s->array, seed, uintptr_t(s->len));
    }

    uintptr_t int32Hash(uint32_t i, uintptr_t seed)
    {
        return memhash32(noescape(gocpp::unsafe_pointer(& i)), seed);
    }

    uintptr_t int64Hash(uint64_t i, uintptr_t seed)
    {
        return memhash64(noescape(gocpp::unsafe_pointer(& i)), seed);
    }

    uintptr_t efaceHash(go_any i, uintptr_t seed)
    {
        return nilinterhash(noescape(gocpp::unsafe_pointer(& i)), seed);
    }

    
    template<typename T>
    gocpp_id_0::gocpp_id_0(T& ref)
    {
        value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    gocpp_id_0::gocpp_id_0(const T& ref)
    {
        value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    gocpp_id_0::gocpp_id_0(T* ptr)
    {
        value.reset(new gocpp_id_0Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void gocpp_id_0::gocpp_id_0Impl<T, StoreT>::vF()
    {
        return rec::F(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        void F(const gocpp::PtrRecv<struct gocpp_id_0, false>& self)
        {
            return self.ptr->value->vF();
        }

        void F(const gocpp::ObjRecv<struct gocpp_id_0>& self)
        {
            return self.obj.value->vF();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    uintptr_t ifaceHash(gocpp_id_0 i, uintptr_t seed)
    {
        return interhash(noescape(gocpp::unsafe_pointer(& i)), seed);
    }

    // used in asm_{386,amd64,arm64}.s to seed the hash function
    gocpp::array<unsigned char, hashRandomBytes> aeskeysched;
    // used in hash{32,64}.go to seed the hash function
    gocpp::array<uintptr_t, 4> hashkey;
    void alginit()
    {
        if((GOARCH == "386"_s || GOARCH == "amd64"_s) && cpu::X86.HasAES && cpu::X86.HasSSSE3 && cpu::X86.HasSSE41)
        {
            initAlgAES();
            return;
        }
        if(GOARCH == "arm64"_s && cpu::ARM64.HasAES)
        {
            initAlgAES();
            return;
        }
        for(auto [i, gocpp_ignored] : hashkey)
        {
            hashkey[i] = uintptr_t(rand()) | 1;
        }
    }

    void initAlgAES()
    {
        useAeshash = true;
        auto key = (gocpp::array_ptr<gocpp::array<uint64_t, hashRandomBytes / 8>>)(gocpp::unsafe_pointer(& aeskeysched));
        for(auto [i, gocpp_ignored] : key)
        {
            key[i] = bootstrapRand();
        }
    }

    // Note: These routines perform the read with a native endianness.
    uint32_t readUnaligned32(gocpp::unsafe_pointer p)
    {
        auto q = (gocpp::array_ptr<gocpp::array<unsigned char, 4>>)(p);
        if(goarch::BigEndian)
        {
            return uint32_t(q[3]) | (uint32_t(q[2]) << 8) | (uint32_t(q[1]) << 16) | (uint32_t(q[0]) << 24);
        }
        return uint32_t(q[0]) | (uint32_t(q[1]) << 8) | (uint32_t(q[2]) << 16) | (uint32_t(q[3]) << 24);
    }

    uint64_t readUnaligned64(gocpp::unsafe_pointer p)
    {
        auto q = (gocpp::array_ptr<gocpp::array<unsigned char, 8>>)(p);
        if(goarch::BigEndian)
        {
            return uint64_t(q[7]) | (uint64_t(q[6]) << 8) | (uint64_t(q[5]) << 16) | (uint64_t(q[4]) << 24) | (uint64_t(q[3]) << 32) | (uint64_t(q[2]) << 40) | (uint64_t(q[1]) << 48) | (uint64_t(q[0]) << 56);
        }
        return uint64_t(q[0]) | (uint64_t(q[1]) << 8) | (uint64_t(q[2]) << 16) | (uint64_t(q[3]) << 24) | (uint64_t(q[4]) << 32) | (uint64_t(q[5]) << 40) | (uint64_t(q[6]) << 48) | (uint64_t(q[7]) << 56);
    }

}

