// generated by GoCpp from file '$(ImportDir)/hash/adler32/adler32.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/hash/adler32/adler32.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"

namespace golang::adler32
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    void rec::Reset(golang::adler32::digest* d)
    {
        *d = 1;
    }

    hash::Hash32 New()
    {
        auto d = new(digest);
        rec::Reset(gocpp::recv(d));
        return d;
    }

    int rec::Size(golang::adler32::digest* d)
    {
        return Size;
    }

    int rec::BlockSize(golang::adler32::digest* d)
    {
        return 4;
    }

    std::string magic = "adl\x01";
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalBinary(golang::adler32::digest* d)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, marshaledSize);
        b = append(b, magic);
        b = appendUint32(b, uint32_t(*d));
        return {b, nullptr};
    }

    struct gocpp::error rec::UnmarshalBinary(golang::adler32::digest* d, gocpp::slice<unsigned char> b)
    {
        if(len(b) < len(magic) || std::string(b.make_slice(0, len(magic))) != magic)
        {
            return errors::New("hash/adler32: invalid hash state identifier");
        }
        if(len(b) != marshaledSize)
        {
            return errors::New("hash/adler32: invalid hash state size");
        }
        *d = digest(readUint32(b.make_slice(len(magic))));
        return nullptr;
    }

    gocpp::slice<unsigned char> appendUint32(gocpp::slice<unsigned char> b, uint32_t x)
    {
        return append(b, unsigned char(x >> 24), unsigned char(x >> 16), unsigned char(x >> 8), unsigned char(x));
    }

    uint32_t readUint32(gocpp::slice<unsigned char> b)
    {
        _ = b[3];
        return uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
    }

    adler32::digest update(golang::adler32::digest d, gocpp::slice<unsigned char> p)
    {
        auto [s1, s2] = std::tuple{uint32_t(d & 0xffff), uint32_t(d >> 16)};
        for(; len(p) > 0; )
        {
            gocpp::slice<unsigned char> q = {};
            if(len(p) > nmax)
            {
                std::tie(p, q) = std::tuple{p.make_slice(0, nmax), p.make_slice(nmax)};
            }
            for(; len(p) >= 4; )
            {
                s1 += uint32_t(p[0]);
                s2 += s1;
                s1 += uint32_t(p[1]);
                s2 += s1;
                s1 += uint32_t(p[2]);
                s2 += s1;
                s1 += uint32_t(p[3]);
                s2 += s1;
                p = p.make_slice(4);
            }
            for(auto [gocpp_ignored, x] : p)
            {
                s1 += uint32_t(x);
                s2 += s1;
            }
            s1 %= mod;
            s2 %= mod;
            p = q;
        }
        return digest((s2 << 16) | s1);
    }

    std::tuple<int, struct gocpp::error> rec::Write(golang::adler32::digest* d, gocpp::slice<unsigned char> p)
    {
        int nn;
        struct gocpp::error err;
        *d = update(*d, p);
        return {len(p), nullptr};
    }

    uint32_t rec::Sum32(golang::adler32::digest* d)
    {
        return uint32_t(*d);
    }

    gocpp::slice<unsigned char> rec::Sum(golang::adler32::digest* d, gocpp::slice<unsigned char> in)
    {
        auto s = uint32_t(*d);
        return append(in, unsigned char(s >> 24), unsigned char(s >> 16), unsigned char(s >> 8), unsigned char(s));
    }

    uint32_t Checksum(gocpp::slice<unsigned char> data)
    {
        return uint32_t(update(1, data));
    }

}

