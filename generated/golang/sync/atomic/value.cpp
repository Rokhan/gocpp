// generated by GoCpp from file '$(ImportDir)/sync/atomic/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/atomic/value.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/doc.h"
#include "golang/unsafe/unsafe.h"

namespace golang::atomic
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Value::operator T()
    {
        T result;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Value::operator==(const T& ref) const
    {
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Value& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    efaceWords::operator T()
    {
        T result;
        result.typ = this->typ;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool efaceWords::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& efaceWords::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct efaceWords& value)
    {
        return value.PrintTo(os);
    }

    go_any rec::Load(struct Value* v)
    {
        go_any val;
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto typ = LoadPointer(& vp->typ);
        if(typ == nullptr || typ == unsafe::Pointer(& firstStoreInProgress))
        {
            return nullptr;
        }
        auto data = LoadPointer(& vp->data);
        auto vlp = (efaceWords*)(unsafe::Pointer(& val));
        vlp->typ = typ;
        vlp->data = data;
        return val;
    }

    unsigned char firstStoreInProgress;
    void rec::Store(struct Value* v, go_any val)
    {
        if(val == nullptr)
        {
            gocpp::panic("sync/atomic: store of nil value into Value"s);
        }
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto vlp = (efaceWords*)(unsafe::Pointer(& val));
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, unsafe::Pointer(& firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, vlp->data);
                StorePointer(& vp->typ, vlp->typ);
                runtime_procUnpin();
                return;
            }
            if(typ == unsafe::Pointer(& firstStoreInProgress))
            {
                continue;
            }
            if(typ != vlp->typ)
            {
                gocpp::panic("sync/atomic: store of inconsistently typed value into Value"s);
            }
            StorePointer(& vp->data, vlp->data);
            return;
        }
    }

    go_any rec::Swap(struct Value* v, go_any go_new)
    {
        go_any old;
        if(go_new == nullptr)
        {
            gocpp::panic("sync/atomic: swap of nil value into Value"s);
        }
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto np = (efaceWords*)(unsafe::Pointer(& go_new));
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, unsafe::Pointer(& firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, np->data);
                StorePointer(& vp->typ, np->typ);
                runtime_procUnpin();
                return nullptr;
            }
            if(typ == unsafe::Pointer(& firstStoreInProgress))
            {
                continue;
            }
            if(typ != np->typ)
            {
                gocpp::panic("sync/atomic: swap of inconsistently typed value into Value"s);
            }
            auto op = (efaceWords*)(unsafe::Pointer(& old));
            std::tie(op->typ, op->data) = std::tuple{np->typ, SwapPointer(& vp->data, np->data)};
            return old;
        }
    }

    bool rec::CompareAndSwap(struct Value* v, go_any old, go_any go_new)
    {
        bool swapped;
        if(go_new == nullptr)
        {
            gocpp::panic("sync/atomic: compare and swap of nil value into Value"s);
        }
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto np = (efaceWords*)(unsafe::Pointer(& go_new));
        auto op = (efaceWords*)(unsafe::Pointer(& old));
        if(op->typ != nullptr && np->typ != op->typ)
        {
            gocpp::panic("sync/atomic: compare and swap of inconsistently typed values"s);
        }
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                if(old != nullptr)
                {
                    return false;
                }
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, unsafe::Pointer(& firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, np->data);
                StorePointer(& vp->typ, np->typ);
                runtime_procUnpin();
                return true;
            }
            if(typ == unsafe::Pointer(& firstStoreInProgress))
            {
                continue;
            }
            if(typ != np->typ)
            {
                gocpp::panic("sync/atomic: compare and swap of inconsistently typed value into Value"s);
            }
            auto data = LoadPointer(& vp->data);
            go_any i = {};
            (efaceWords*)(unsafe::Pointer(& i))->typ = typ;
            (efaceWords*)(unsafe::Pointer(& i))->data = data;
            if(i != old)
            {
                return false;
            }
            return CompareAndSwapPointer(& vp->data, data, np->data);
        }
    }

    int runtime_procPin()
    /* convertBlockStmt, nil block */;

    void runtime_procUnpin()
    /* convertBlockStmt, nil block */;

}

