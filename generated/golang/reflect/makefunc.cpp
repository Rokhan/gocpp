// generated by GoCpp from file '$(ImportDir)/reflect/makefunc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/makefunc.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/type.h"
#include "golang/reflect/value.h"
#include "golang/sync/cond.h"
#include "golang/sync/pool.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace reflect::rec;
        using namespace sync::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    makeFuncImpl::operator T()
    {
        T result;
        result.ftyp = this->ftyp;
        result.fn = this->fn;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool makeFuncImpl::operator==(const T& ref) const
    {
        if (ftyp != ref.ftyp) return false;
        if (fn != ref.fn) return false;
        return true;
    }

    std::ostream& makeFuncImpl::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ftyp;
        os << " " << fn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct makeFuncImpl& value)
    {
        return value.PrintTo(os);
    }

    struct Value MakeFunc(struct Type typ, std::function<gocpp::slice<Value> (gocpp::slice<Value> args)> fn)
    {
        if(rec::Kind(gocpp::recv(typ)) != Func)
        {
            gocpp::panic("reflect: call of MakeFunc with non-Func type");
        }
        auto t = rec::common(gocpp::recv(typ));
        auto ftyp = (reflect::funcType*)(unsafe::Pointer(t));
        auto code = abi::FuncPCABI0(makeFuncStub);
        auto [gocpp_id_2, gocpp_id_3, abid] = funcLayout(ftyp, nullptr);
        auto impl = gocpp::InitPtr<makeFuncImpl>([](auto& x) {
            x.makeFuncCtxt = gocpp::Init<makeFuncCtxt>([](auto& x) {
            x.fn = code;
            x.stack = abid.stackPtrs;
            x.argLen = abid.stackCallArgsSize;
            x.regPtrs = abid.inRegPtrs;
        });
            x.ftyp = ftyp;
            x.fn = fn;
        });
        return Value {t, unsafe::Pointer(impl), flag(Func)};
    }

    void makeFuncStub()
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    methodValue::operator T()
    {
        T result;
        result.method = this->method;
        result.rcvr = this->rcvr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool methodValue::operator==(const T& ref) const
    {
        if (method != ref.method) return false;
        if (rcvr != ref.rcvr) return false;
        return true;
    }

    std::ostream& methodValue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << method;
        os << " " << rcvr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct methodValue& value)
    {
        return value.PrintTo(os);
    }

    struct Value makeMethodValue(std::string op, struct Value v)
    {
        if(v.flag & flagMethod == 0)
        {
            gocpp::panic("reflect: internal error: invalid use of makeMethodValue");
        }
        auto fl = v.flag & (flagRO | flagAddr | flagIndir);
        fl |= flag(rec::Kind(gocpp::recv(rec::typ(gocpp::recv(v)))));
        auto rcvr = Value {rec::typ(gocpp::recv(v)), v.ptr, fl};
        auto ftyp = (reflect::funcType*)(unsafe::Pointer(gocpp::getValue<rtype*>(rec::Type(gocpp::recv(v)))));
        auto code = methodValueCallCodePtr();
        auto [gocpp_id_6, gocpp_id_7, abid] = funcLayout(ftyp, nullptr);
        auto fv = gocpp::InitPtr<methodValue>([](auto& x) {
            x.makeFuncCtxt = gocpp::Init<makeFuncCtxt>([](auto& x) {
            x.fn = code;
            x.stack = abid.stackPtrs;
            x.argLen = abid.stackCallArgsSize;
            x.regPtrs = abid.inRegPtrs;
        });
            x.method = int(v.flag) >> flagMethodShift;
            x.rcvr = rcvr;
        });
        methodReceiver(op, fv->rcvr, fv->method);
        return Value {rec::Common(gocpp::recv(ftyp)), unsafe::Pointer(fv), v.flag & flagRO | flag(Func)};
    }

    uintptr_t methodValueCallCodePtr()
    {
        return abi::FuncPCABI0(methodValueCall);
    }

    void methodValueCall()
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    makeFuncCtxt::operator T()
    {
        T result;
        result.fn = this->fn;
        result.stack = this->stack;
        result.argLen = this->argLen;
        result.regPtrs = this->regPtrs;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool makeFuncCtxt::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (stack != ref.stack) return false;
        if (argLen != ref.argLen) return false;
        if (regPtrs != ref.regPtrs) return false;
        return true;
    }

    std::ostream& makeFuncCtxt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << stack;
        os << " " << argLen;
        os << " " << regPtrs;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct makeFuncCtxt& value)
    {
        return value.PrintTo(os);
    }

    void moveMakeFuncArgPtrs(struct makeFuncCtxt* ctxt, abi::RegArgs* args)
    {
        for(auto [i, arg] : args->Ints)
        {
            if(rec::Get(gocpp::recv(ctxt->regPtrs), i))
            {
                *(uintptr_t*)(unsafe::Pointer(& args->Ptrs[i])) = arg;
            }
            else
            {
                *(uintptr_t*)(unsafe::Pointer(& args->Ptrs[i])) = 0;
            }
        }
    }

}

