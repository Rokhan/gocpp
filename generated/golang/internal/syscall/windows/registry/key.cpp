// generated by GoCpp from file '$(ImportDir)/internal/syscall/windows/registry/key.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/syscall/windows/registry/key.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/registry/syscall.h"
#include "golang/internal/syscall/windows/registry/zsyscall_windows.h"
#include "golang/runtime/proc.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"

// Package registry provides access to the Windows registry.
//
// Here is a simple example, opening a registry key and reading a string value from it.
//
//	k, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Windows NT\CurrentVersion`, registry.QUERY_VALUE)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer k.Close()
//
//	s, _, err := k.GetStringValue("SystemRoot")
//	if err != nil {
//		log.Fatal(err)
//	}
//	fmt.Printf("Windows system root is %q\n", s)
//
// NOTE: This package is a copy of golang.org/x/sys/windows/registry
// with KeyInfo.ModTime removed to prevent dependency cycles.
namespace golang::registry
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Registry key security and access rights.
    // See https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights
    // for details.
    // Key is a handle to an open Windows registry key.
    // Keys can be obtained by calling OpenKey; there are
    // also some predefined root keys such as CURRENT_USER.
    // Keys can be used directly in the Windows API.
    // Windows defines some predefined root keys that are always open.
    // An application can use these keys as entry points to the registry.
    // Normally these keys are used in OpenKey to open new keys,
    // but they can also be used anywhere a Key is required.
    // Close closes open key k.
    struct gocpp::error rec::Close(golang::registry::Key k)
    {
        return syscall::RegCloseKey(syscall::Handle(k));
    }

    // OpenKey opens a new key with path name relative to key k.
    // It accepts any open key, including CURRENT_USER and others,
    // and returns the new key and an error.
    // The access parameter specifies desired access rights to the
    // key to be opened.
    std::tuple<registry::Key, struct gocpp::error> OpenKey(golang::registry::Key k, std::string path, uint32_t access)
    {
        auto [p, err] = syscall::UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return {0, err};
        }
        syscall::Handle subkey = {};
        err = syscall::RegOpenKeyEx(syscall::Handle(k), p, 0, access, & subkey);
        if(err != nullptr)
        {
            return {0, err};
        }
        return {Key(subkey), nullptr};
    }

    // ReadSubKeyNames returns the names of subkeys of key k.
    std::tuple<gocpp::slice<std::string>, struct gocpp::error> rec::ReadSubKeyNames(golang::registry::Key k)
    {
        gocpp::Defer defer;
        try
        {
            runtime::LockOSThread();
            defer.push_back([=]{ runtime::UnlockOSThread(); });
            auto names = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0);
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 256);
            loopItems:
            for(auto i = uint32_t(0); ; i++)
            {
                auto l = uint32_t(len(buf));
                for(; ; )
                {
                    auto err = syscall::RegEnumKeyEx(syscall::Handle(k), i, & buf[0], & l, nullptr, nullptr, nullptr, nullptr);
                    if(err == nullptr)
                    {
                        break;
                    }
                    if(err == syscall::ERROR_MORE_DATA)
                    {
                        l = uint32_t(2 * len(buf));
                        buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), l);
                        continue;
                    }
                    if(err == _ERROR_NO_MORE_ITEMS)
                    {
                        goto loopItems_break;
                    }
                    return {names, err};
                }
                names = append(names, syscall::UTF16ToString(buf.make_slice(0, l)));
                if(false) {
                loopItems_continue:
                    continue;
                loopItems_break:
                    break;
                }
            }
            return {names, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // CreateKey creates a key named path under open key k.
    // CreateKey returns the new key and a boolean flag that reports
    // whether the key already existed.
    // The access parameter specifies the access rights for the key
    // to be created.
    std::tuple<registry::Key, bool, struct gocpp::error> CreateKey(golang::registry::Key k, std::string path, uint32_t access)
    {
        registry::Key newk;
        bool openedExisting;
        struct gocpp::error err;
        syscall::Handle h = {};
        uint32_t d = {};
        err = regCreateKeyEx(syscall::Handle(k), syscall::StringToUTF16Ptr(path), 0, nullptr, _REG_OPTION_NON_VOLATILE, access, nullptr, & h, & d);
        if(err != nullptr)
        {
            return {0, false, err};
        }
        return {Key(h), d == _REG_OPENED_EXISTING_KEY, nullptr};
    }

    // DeleteKey deletes the subkey path of key k and its values.
    struct gocpp::error DeleteKey(golang::registry::Key k, std::string path)
    {
        return regDeleteKey(syscall::Handle(k), syscall::StringToUTF16Ptr(path));
    }

    // A KeyInfo describes the statistics of a key. It is returned by Stat.
    
    template<typename T> requires gocpp::GoStruct<T>
    KeyInfo::operator T()
    {
        T result;
        result.SubKeyCount = this->SubKeyCount;
        result.MaxSubKeyLen = this->MaxSubKeyLen;
        result.ValueCount = this->ValueCount;
        result.MaxValueNameLen = this->MaxValueNameLen;
        result.MaxValueLen = this->MaxValueLen;
        result.lastWriteTime = this->lastWriteTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool KeyInfo::operator==(const T& ref) const
    {
        if (SubKeyCount != ref.SubKeyCount) return false;
        if (MaxSubKeyLen != ref.MaxSubKeyLen) return false;
        if (ValueCount != ref.ValueCount) return false;
        if (MaxValueNameLen != ref.MaxValueNameLen) return false;
        if (MaxValueLen != ref.MaxValueLen) return false;
        if (lastWriteTime != ref.lastWriteTime) return false;
        return true;
    }

    std::ostream& KeyInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << SubKeyCount;
        os << " " << MaxSubKeyLen;
        os << " " << ValueCount;
        os << " " << MaxValueNameLen;
        os << " " << MaxValueLen;
        os << " " << lastWriteTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct KeyInfo& value)
    {
        return value.PrintTo(os);
    }

    // Stat retrieves information about the open key k.
    std::tuple<struct KeyInfo*, struct gocpp::error> rec::Stat(golang::registry::Key k)
    {
        KeyInfo ki = {};
        auto err = syscall::RegQueryInfoKey(syscall::Handle(k), nullptr, nullptr, nullptr, & ki.SubKeyCount, & ki.MaxSubKeyLen, nullptr, & ki.ValueCount, & ki.MaxValueNameLen, & ki.MaxValueLen, nullptr, & ki.lastWriteTime);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {& ki, nullptr};
    }

}

