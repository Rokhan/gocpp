// generated by GoCpp from file '$(ImportDir)/image/geom.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/geom.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/math/bits/bits.h"
#include "golang/strconv/itoa.h"

namespace golang::image
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Point::operator T()
    {
        T result;
        result.X = this->X;
        result.Y = this->Y;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Point::operator==(const T& ref) const
    {
        if (X != ref.X) return false;
        if (Y != ref.Y) return false;
        return true;
    }

    std::ostream& Point::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << X;
        os << " " << Y;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Point& value)
    {
        return value.PrintTo(os);
    }

    std::string String(struct Point p)
    {
        return "(" + strconv::Itoa(p.X) + "," + strconv::Itoa(p.Y) + ")";
    }

    Point Add(struct Point p, Point q)
    {
        return Point {p.X + q.X, p.Y + q.Y};
    }

    Point Sub(struct Point p, Point q)
    {
        return Point {p.X - q.X, p.Y - q.Y};
    }

    Point Mul(struct Point p, int k)
    {
        return Point {p.X * k, p.Y * k};
    }

    Point Div(struct Point p, int k)
    {
        return Point {p.X / k, p.Y / k};
    }

    bool In(struct Point p, Rectangle r)
    {
        return r.Min.X <= p.X && p.X < r.Max.X && r.Min.Y <= p.Y && p.Y < r.Max.Y;
    }

    Point Mod(struct Point p, Rectangle r)
    {
        auto [w, h] = std::tuple{Dx(gocpp::recv(r)), Dy(gocpp::recv(r))};
        p = Sub(gocpp::recv(p), r.Min);
        p.X = p.X % w;
        if(p.X < 0)
        {
            p.X += w;
        }
        p.Y = p.Y % h;
        if(p.Y < 0)
        {
            p.Y += h;
        }
        return Add(gocpp::recv(p), r.Min);
    }

    bool Eq(struct Point p, Point q)
    {
        return p == q;
    }

    Point ZP;
    Point Pt(int X, int Y)
    {
        return Point {X, Y};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Rectangle::operator T()
    {
        T result;
        result.Min = this->Min;
        result.Max = this->Max;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rectangle::operator==(const T& ref) const
    {
        if (Min != ref.Min) return false;
        if (Max != ref.Max) return false;
        return true;
    }

    std::ostream& Rectangle::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Min;
        os << " " << Max;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rectangle& value)
    {
        return value.PrintTo(os);
    }

    std::string String(struct Rectangle r)
    {
        return String(gocpp::recv(r.Min)) + "-" + String(gocpp::recv(r.Max));
    }

    int Dx(struct Rectangle r)
    {
        return r.Max.X - r.Min.X;
    }

    int Dy(struct Rectangle r)
    {
        return r.Max.Y - r.Min.Y;
    }

    Point Size(struct Rectangle r)
    {
        return Point {r.Max.X - r.Min.X, r.Max.Y - r.Min.Y};
    }

    Rectangle Add(struct Rectangle r, Point p)
    {
        return Rectangle {Point {r.Min.X + p.X, r.Min.Y + p.Y}, Point {r.Max.X + p.X, r.Max.Y + p.Y}};
    }

    Rectangle Sub(struct Rectangle r, Point p)
    {
        return Rectangle {Point {r.Min.X - p.X, r.Min.Y - p.Y}, Point {r.Max.X - p.X, r.Max.Y - p.Y}};
    }

    Rectangle Inset(struct Rectangle r, int n)
    {
        if(Dx(gocpp::recv(r)) < 2 * n)
        {
            r.Min.X = (r.Min.X + r.Max.X) / 2;
            r.Max.X = r.Min.X;
        }
        else
        {
            r.Min.X += n;
            r.Max.X -= n;
        }
        if(Dy(gocpp::recv(r)) < 2 * n)
        {
            r.Min.Y = (r.Min.Y + r.Max.Y) / 2;
            r.Max.Y = r.Min.Y;
        }
        else
        {
            r.Min.Y += n;
            r.Max.Y -= n;
        }
        return r;
    }

    Rectangle Intersect(struct Rectangle r, Rectangle s)
    {
        if(r.Min.X < s.Min.X)
        {
            r.Min.X = s.Min.X;
        }
        if(r.Min.Y < s.Min.Y)
        {
            r.Min.Y = s.Min.Y;
        }
        if(r.Max.X > s.Max.X)
        {
            r.Max.X = s.Max.X;
        }
        if(r.Max.Y > s.Max.Y)
        {
            r.Max.Y = s.Max.Y;
        }
        if(Empty(gocpp::recv(r)))
        {
            return ZR;
        }
        return r;
    }

    Rectangle Union(struct Rectangle r, Rectangle s)
    {
        if(Empty(gocpp::recv(r)))
        {
            return s;
        }
        if(Empty(gocpp::recv(s)))
        {
            return r;
        }
        if(r.Min.X > s.Min.X)
        {
            r.Min.X = s.Min.X;
        }
        if(r.Min.Y > s.Min.Y)
        {
            r.Min.Y = s.Min.Y;
        }
        if(r.Max.X < s.Max.X)
        {
            r.Max.X = s.Max.X;
        }
        if(r.Max.Y < s.Max.Y)
        {
            r.Max.Y = s.Max.Y;
        }
        return r;
    }

    bool Empty(struct Rectangle r)
    {
        return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y;
    }

    bool Eq(struct Rectangle r, Rectangle s)
    {
        return r == s || Empty(gocpp::recv(r)) && Empty(gocpp::recv(s));
    }

    bool Overlaps(struct Rectangle r, Rectangle s)
    {
        return ! Empty(gocpp::recv(r)) && ! Empty(gocpp::recv(s)) && r.Min.X < s.Max.X && s.Min.X < r.Max.X && r.Min.Y < s.Max.Y && s.Min.Y < r.Max.Y;
    }

    bool In(struct Rectangle r, Rectangle s)
    {
        if(Empty(gocpp::recv(r)))
        {
            return true;
        }
        return s.Min.X <= r.Min.X && r.Max.X <= s.Max.X && s.Min.Y <= r.Min.Y && r.Max.Y <= s.Max.Y;
    }

    Rectangle Canon(struct Rectangle r)
    {
        if(r.Max.X < r.Min.X)
        {
            std::tie(r.Min.X, r.Max.X) = std::tuple{r.Max.X, r.Min.X};
        }
        if(r.Max.Y < r.Min.Y)
        {
            std::tie(r.Min.Y, r.Max.Y) = std::tuple{r.Max.Y, r.Min.Y};
        }
        return r;
    }

    color::Color At(struct Rectangle r, int x, int y)
    {
        if(In(gocpp::recv((Point {x, y})), r))
        {
            return color::Opaque;
        }
        return color::Transparent;
    }

    color::RGBA64 RGBA64At(struct Rectangle r, int x, int y)
    {
        if(In(gocpp::recv((Point {x, y})), r))
        {
            return color::RGBA64 {0xffff, 0xffff, 0xffff, 0xffff};
        }
        return color::RGBA64 {};
    }

    Rectangle Bounds(struct Rectangle r)
    {
        return r;
    }

    color::Model ColorModel(struct Rectangle r)
    {
        return color::Alpha16Model;
    }

    Rectangle ZR;
    Rectangle Rect(int x0, int y0, int x1, int y1)
    {
        if(x0 > x1)
        {
            std::tie(x0, x1) = std::tuple{x1, x0};
        }
        if(y0 > y1)
        {
            std::tie(y0, y1) = std::tuple{y1, y0};
        }
        return Rectangle {Point {x0, y0}, Point {x1, y1}};
    }

    int mul3NonNeg(int x, int y, int z)
    {
        if((x < 0) || (y < 0) || (z < 0))
        {
            return - 1;
        }
        auto [hi, lo] = bits::Mul64(uint64_t(x), uint64_t(y));
        if(hi != 0)
        {
            return - 1;
        }
        std::tie(hi, lo) = bits::Mul64(lo, uint64_t(z));
        if(hi != 0)
        {
            return - 1;
        }
        auto a = int(lo);
        if((a < 0) || (uint64_t(a) != lo))
        {
            return - 1;
        }
        return a;
    }

    int add2NonNeg(int x, int y)
    {
        if((x < 0) || (y < 0))
        {
            return - 1;
        }
        auto a = x + y;
        if(a < 0)
        {
            return - 1;
        }
        return a;
    }

}

