// generated by GoCpp from file '$(ImportDir)/fmt/format.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/fmt/format.h"
#include "gocpp/support.h"

#include "golang/fmt/print.h"
#include "golang/strconv/ftoa.h"
#include "golang/strconv/quote.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::fmt
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    gocpp::string ldigits = "0123456789abcdefx"_s;
    gocpp::string udigits = "0123456789ABCDEFX"_s;
    // flags placed in a separate struct for easy clearing.
    
    template<typename T> requires gocpp::GoStruct<T>
    fmtFlags::operator T()
    {
        T result;
        result.widPresent = this->widPresent;
        result.precPresent = this->precPresent;
        result.minus = this->minus;
        result.plus = this->plus;
        result.sharp = this->sharp;
        result.space = this->space;
        result.zero = this->zero;
        result.plusV = this->plusV;
        result.sharpV = this->sharpV;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fmtFlags::operator==(const T& ref) const
    {
        if (widPresent != ref.widPresent) return false;
        if (precPresent != ref.precPresent) return false;
        if (minus != ref.minus) return false;
        if (plus != ref.plus) return false;
        if (sharp != ref.sharp) return false;
        if (space != ref.space) return false;
        if (zero != ref.zero) return false;
        if (plusV != ref.plusV) return false;
        if (sharpV != ref.sharpV) return false;
        return true;
    }

    std::ostream& fmtFlags::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << widPresent;
        os << " " << precPresent;
        os << " " << minus;
        os << " " << plus;
        os << " " << sharp;
        os << " " << space;
        os << " " << zero;
        os << " " << plusV;
        os << " " << sharpV;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fmtFlags& value)
    {
        return value.PrintTo(os);
    }

    // A fmt is the raw formatter used by Printf etc.
    // It prints into a buffer that must be set up separately.
    
    template<typename T> requires gocpp::GoStruct<T>
    fmt::operator T()
    {
        T result;
        result.buf = this->buf;
        result.fmtFlags = this->fmtFlags;
        result.wid = this->wid;
        result.prec = this->prec;
        result.intbuf = this->intbuf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fmt::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (fmtFlags != ref.fmtFlags) return false;
        if (wid != ref.wid) return false;
        if (prec != ref.prec) return false;
        if (intbuf != ref.intbuf) return false;
        return true;
    }

    std::ostream& fmt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << fmtFlags;
        os << " " << wid;
        os << " " << prec;
        os << " " << intbuf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fmt& value)
    {
        return value.PrintTo(os);
    }

    void rec::clearflags(golang::fmt::fmt* f)
    {
        f->fmtFlags = fmtFlags {};
    }

    void rec::init(golang::fmt::fmt* f, buffer* buf)
    {
        f->buf = buf;
        rec::clearflags(gocpp::recv(f));
    }

    // writePadding generates n bytes of padding.
    void rec::writePadding(golang::fmt::fmt* f, int n)
    {
        if(n <= 0)
        {
            return;
        }
        auto buf = *f->buf;
        auto oldLen = len(buf);
        auto newLen = oldLen + n;
        if(newLen > cap(buf))
        {
            buf = gocpp::make(buffer, cap(buf) * 2 + n);
            copy(buf, *f->buf);
        }
        auto padByte = (unsigned char)(' ');
        if(f->zero)
        {
            padByte = (unsigned char)('0');
        }
        auto padding = buf.make_slice(oldLen, newLen);
        for(auto [i, gocpp_ignored] : padding)
        {
            padding[i] = padByte;
        }
        *f->buf = buf.make_slice(0, newLen);
    }

    // pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).
    void rec::pad(golang::fmt::fmt* f, gocpp::slice<unsigned char> b)
    {
        if(! f->widPresent || f->wid == 0)
        {
            rec::write(gocpp::recv(f->buf), b);
            return;
        }
        auto width = f->wid - utf8::RuneCount(b);
        if(! f->minus)
        {
            rec::writePadding(gocpp::recv(f), width);
            rec::write(gocpp::recv(f->buf), b);
        }
        else
        {
            rec::write(gocpp::recv(f->buf), b);
            rec::writePadding(gocpp::recv(f), width);
        }
    }

    // padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).
    void rec::padString(golang::fmt::fmt* f, gocpp::string s)
    {
        if(! f->widPresent || f->wid == 0)
        {
            rec::writeString(gocpp::recv(f->buf), s);
            return;
        }
        auto width = f->wid - utf8::RuneCountInString(s);
        if(! f->minus)
        {
            rec::writePadding(gocpp::recv(f), width);
            rec::writeString(gocpp::recv(f->buf), s);
        }
        else
        {
            rec::writeString(gocpp::recv(f->buf), s);
            rec::writePadding(gocpp::recv(f), width);
        }
    }

    // fmtBoolean formats a boolean.
    void rec::fmtBoolean(golang::fmt::fmt* f, bool v)
    {
        if(v)
        {
            rec::padString(gocpp::recv(f), "true"_s);
        }
        else
        {
            rec::padString(gocpp::recv(f), "false"_s);
        }
    }

    // fmtUnicode formats a uint64 as "U+0078" or with f.sharp set as "U+0078 'x'".
    void rec::fmtUnicode(golang::fmt::fmt* f, uint64_t u)
    {
        auto buf = f->intbuf.make_slice(0);
        auto prec = 4;
        if(f->precPresent && f->prec > 4)
        {
            prec = f->prec;
            auto width = 2 + prec + 2 + utf8::UTFMax + 1;
            if(width > len(buf))
            {
                buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), width);
            }
        }
        auto i = len(buf);
        if(f->sharp && u <= utf8::MaxRune && strconv::IsPrint(gocpp::rune(u)))
        {
            i--;
            buf[i] = '\'';
            i -= utf8::RuneLen(gocpp::rune(u));
            utf8::EncodeRune(buf.make_slice(i), gocpp::rune(u));
            i--;
            buf[i] = '\'';
            i--;
            buf[i] = ' ';
        }
        for(; u >= 16; )
        {
            i--;
            buf[i] = udigits[u & 0xF];
            prec--;
            u >>= 4;
        }
        i--;
        buf[i] = udigits[u];
        prec--;
        for(; prec > 0; )
        {
            i--;
            buf[i] = '0';
            prec--;
        }
        i--;
        buf[i] = '+';
        i--;
        buf[i] = 'U';
        auto oldZero = f->zero;
        f->zero = false;
        rec::pad(gocpp::recv(f), buf.make_slice(i));
        f->zero = oldZero;
    }

    // fmtInteger formats signed and unsigned integers.
    void rec::fmtInteger(golang::fmt::fmt* f, uint64_t u, int base, bool isSigned, gocpp::rune verb, gocpp::string digits)
    {
        auto negative = isSigned && int64_t(u) < 0;
        if(negative)
        {
            u = - u;
        }
        auto buf = f->intbuf.make_slice(0);
        if(f->widPresent || f->precPresent)
        {
            auto width = 3 + f->wid + f->prec;
            if(width > len(buf))
            {
                buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), width);
            }
        }
        auto prec = 0;
        if(f->precPresent)
        {
            prec = f->prec;
            if(prec == 0 && u == 0)
            {
                auto oldZero = f->zero;
                f->zero = false;
                rec::writePadding(gocpp::recv(f), f->wid);
                f->zero = oldZero;
                return;
            }
        }
        else
        if(f->zero && f->widPresent)
        {
            prec = f->wid;
            if(negative || f->plus || f->space)
            {
                prec--;
            }
        }
        auto i = len(buf);
        //Go switch emulation
        {
            auto condition = base;
            int conditionId = -1;
            if(condition == 10) { conditionId = 0; }
            else if(condition == 16) { conditionId = 1; }
            else if(condition == 8) { conditionId = 2; }
            else if(condition == 2) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    for(; u >= 10; )
                    {
                        i--;
                        auto next = u / 10;
                        buf[i] = (unsigned char)('0' + u - next * 10);
                        u = next;
                    }
                    break;
                case 1:
                    for(; u >= 16; )
                    {
                        i--;
                        buf[i] = digits[u & 0xF];
                        u >>= 4;
                    }
                    break;
                case 2:
                    for(; u >= 8; )
                    {
                        i--;
                        buf[i] = (unsigned char)('0' + u & 7);
                        u >>= 3;
                    }
                    break;
                case 3:
                    for(; u >= 2; )
                    {
                        i--;
                        buf[i] = (unsigned char)('0' + u & 1);
                        u >>= 1;
                    }
                    break;
                default:
                    gocpp::panic("fmt: unknown base; can't happen"_s);
                    break;
            }
        }
        i--;
        buf[i] = digits[u];
        for(; i > 0 && prec > len(buf) - i; )
        {
            i--;
            buf[i] = '0';
        }
        if(f->sharp)
        {
            //Go switch emulation
            {
                auto condition = base;
                int conditionId = -1;
                if(condition == 2) { conditionId = 0; }
                else if(condition == 8) { conditionId = 1; }
                else if(condition == 16) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        i--;
                        buf[i] = 'b';
                        i--;
                        buf[i] = '0';
                        break;
                    case 1:
                        if(buf[i] != '0')
                        {
                            i--;
                            buf[i] = '0';
                        }
                        break;
                    case 2:
                        i--;
                        buf[i] = digits[16];
                        i--;
                        buf[i] = '0';
                        break;
                }
            }
        }
        if(verb == 'O')
        {
            i--;
            buf[i] = 'o';
            i--;
            buf[i] = '0';
        }
        if(negative)
        {
            i--;
            buf[i] = '-';
        }
        else
        if(f->plus)
        {
            i--;
            buf[i] = '+';
        }
        else
        if(f->space)
        {
            i--;
            buf[i] = ' ';
        }
        auto oldZero = f->zero;
        f->zero = false;
        rec::pad(gocpp::recv(f), buf.make_slice(i));
        f->zero = oldZero;
    }

    // truncateString truncates the string s to the specified precision, if present.
    gocpp::string rec::truncateString(golang::fmt::fmt* f, gocpp::string s)
    {
        if(f->precPresent)
        {
            auto n = f->prec;
            for(auto [i, gocpp_ignored] : s)
            {
                n--;
                if(n < 0)
                {
                    return s.make_slice(0, i);
                }
            }
        }
        return s;
    }

    // truncate truncates the byte slice b as a string of the specified precision, if present.
    gocpp::slice<unsigned char> rec::truncate(golang::fmt::fmt* f, gocpp::slice<unsigned char> b)
    {
        if(f->precPresent)
        {
            auto n = f->prec;
            for(auto i = 0; i < len(b); )
            {
                n--;
                if(n < 0)
                {
                    return b.make_slice(0, i);
                }
                auto wid = 1;
                if(b[i] >= utf8::RuneSelf)
                {
                    std::tie(std::ignore, wid) = utf8::DecodeRune(b.make_slice(i));
                }
                i += wid;
            }
        }
        return b;
    }

    // fmtS formats a string.
    void rec::fmtS(golang::fmt::fmt* f, gocpp::string s)
    {
        s = rec::truncateString(gocpp::recv(f), s);
        rec::padString(gocpp::recv(f), s);
    }

    // fmtBs formats the byte slice b as if it was formatted as string with fmtS.
    void rec::fmtBs(golang::fmt::fmt* f, gocpp::slice<unsigned char> b)
    {
        b = rec::truncate(gocpp::recv(f), b);
        rec::pad(gocpp::recv(f), b);
    }

    // fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.
    void rec::fmtSbx(golang::fmt::fmt* f, gocpp::string s, gocpp::slice<unsigned char> b, gocpp::string digits)
    {
        auto length = len(b);
        if(b == nullptr)
        {
            length = len(s);
        }
        if(f->precPresent && f->prec < length)
        {
            length = f->prec;
        }
        auto width = 2 * length;
        if(width > 0)
        {
            if(f->space)
            {
                if(f->sharp)
                {
                    width *= 2;
                }
                width += length - 1;
            }
            else
            if(f->sharp)
            {
                width += 2;
            }
        }
        else
        {
            if(f->widPresent)
            {
                rec::writePadding(gocpp::recv(f), f->wid);
            }
            return;
        }
        if(f->widPresent && f->wid > width && ! f->minus)
        {
            rec::writePadding(gocpp::recv(f), f->wid - width);
        }
        auto buf = *f->buf;
        if(f->sharp)
        {
            buf = append(buf, '0', digits[16]);
        }
        unsigned char c = {};
        for(auto i = 0; i < length; i++)
        {
            if(f->space && i > 0)
            {
                buf = append(buf, ' ');
                if(f->sharp)
                {
                    buf = append(buf, '0', digits[16]);
                }
            }
            if(b != nullptr)
            {
                c = b[i];
            }
            else
            {
                c = s[i];
            }
            buf = append(buf, digits[c >> 4], digits[c & 0xF]);
        }
        *f->buf = buf;
        if(f->widPresent && f->wid > width && f->minus)
        {
            rec::writePadding(gocpp::recv(f), f->wid - width);
        }
    }

    // fmtSx formats a string as a hexadecimal encoding of its bytes.
    void rec::fmtSx(golang::fmt::fmt* f, gocpp::string s, gocpp::string digits)
    {
        rec::fmtSbx(gocpp::recv(f), s, nullptr, digits);
    }

    // fmtBx formats a byte slice as a hexadecimal encoding of its bytes.
    void rec::fmtBx(golang::fmt::fmt* f, gocpp::slice<unsigned char> b, gocpp::string digits)
    {
        rec::fmtSbx(gocpp::recv(f), ""_s, b, digits);
    }

    // fmtQ formats a string as a double-quoted, escaped Go string constant.
    // If f.sharp is set a raw (backquoted) string may be returned instead
    // if the string does not contain any control characters other than tab.
    void rec::fmtQ(golang::fmt::fmt* f, gocpp::string s)
    {
        s = rec::truncateString(gocpp::recv(f), s);
        if(f->sharp && strconv::CanBackquote(s))
        {
            rec::padString(gocpp::recv(f), "`"_s + s + "`"_s);
            return;
        }
        auto buf = f->intbuf.make_slice(0, 0);
        if(f->plus)
        {
            rec::pad(gocpp::recv(f), strconv::AppendQuoteToASCII(buf, s));
        }
        else
        {
            rec::pad(gocpp::recv(f), strconv::AppendQuote(buf, s));
        }
    }

    // fmtC formats an integer as a Unicode character.
    // If the character is not valid Unicode, it will print '\ufffd'.
    void rec::fmtC(golang::fmt::fmt* f, uint64_t c)
    {
        auto r = gocpp::rune(c);
        if(c > utf8::MaxRune)
        {
            r = utf8::RuneError;
        }
        auto buf = f->intbuf.make_slice(0, 0);
        rec::pad(gocpp::recv(f), utf8::AppendRune(buf, r));
    }

    // fmtQc formats an integer as a single-quoted, escaped Go character constant.
    // If the character is not valid Unicode, it will print '\ufffd'.
    void rec::fmtQc(golang::fmt::fmt* f, uint64_t c)
    {
        auto r = gocpp::rune(c);
        if(c > utf8::MaxRune)
        {
            r = utf8::RuneError;
        }
        auto buf = f->intbuf.make_slice(0, 0);
        if(f->plus)
        {
            rec::pad(gocpp::recv(f), strconv::AppendQuoteRuneToASCII(buf, r));
        }
        else
        {
            rec::pad(gocpp::recv(f), strconv::AppendQuoteRune(buf, r));
        }
    }

    // fmtFloat formats a float64. It assumes that verb is a valid format specifier
    // for strconv.AppendFloat and therefore fits into a byte.
    void rec::fmtFloat(golang::fmt::fmt* f, double v, int size, gocpp::rune verb, int prec)
    {
        if(f->precPresent)
        {
            prec = f->prec;
        }
        auto num = strconv::AppendFloat(f->intbuf.make_slice(0, 1), v, (unsigned char)(verb), prec, size);
        if(num[1] == '-' || num[1] == '+')
        {
            num = num.make_slice(1);
        }
        else
        {
            num[0] = '+';
        }
        if(f->space && num[0] == '+' && ! f->plus)
        {
            num[0] = ' ';
        }
        if(num[1] == 'I' || num[1] == 'N')
        {
            auto oldZero = f->zero;
            f->zero = false;
            if(num[1] == 'N' && ! f->space && ! f->plus)
            {
                num = num.make_slice(1);
            }
            rec::pad(gocpp::recv(f), num);
            f->zero = oldZero;
            return;
        }
        if(f->sharp && verb != 'b')
        {
            auto digits = 0;
            //Go switch emulation
            {
                auto condition = verb;
                int conditionId = -1;
                if(condition == 'v') { conditionId = 0; }
                else if(condition == 'g') { conditionId = 1; }
                else if(condition == 'G') { conditionId = 2; }
                else if(condition == 'x') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        digits = prec;
                        if(digits == - 1)
                        {
                            digits = 6;
                        }
                        break;
                }
            }
            // Buffer pre-allocated with enough room for
            // exponent notations of the form "e+123" or "p-1023".
            gocpp::array<unsigned char, 6> tailBuf = {};
            auto tail = tailBuf.make_slice(0, 0);
            auto hasDecimalPoint = false;
            auto sawNonzeroDigit = false;
            for(auto i = 1; i < len(num); i++)
            {
                //Go switch emulation
                {
                    auto condition = num[i];
                    int conditionId = -1;
                    if(condition == '.') { conditionId = 0; }
                    else if(condition == 'p') { conditionId = 1; }
                    else if(condition == 'P') { conditionId = 2; }
                    else if(condition == 'e') { conditionId = 3; }
                    else if(condition == 'E') { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                            hasDecimalPoint = true;
                            break;
                        case 1:
                        case 2:
                            tail = append(tail, num.make_slice(i));
                            num = num.make_slice(0, i);
                            break;
                        case 3:
                        case 4:
                            if(verb != 'x' && verb != 'X')
                            {
                                tail = append(tail, num.make_slice(i));
                                num = num.make_slice(0, i);
                                break;
                            }
                        default:
                            if(num[i] != '0')
                            {
                                sawNonzeroDigit = true;
                            }
                            if(sawNonzeroDigit)
                            {
                                digits--;
                            }
                            break;
                    }
                }
            }
            if(! hasDecimalPoint)
            {
                if(len(num) == 2 && num[1] == '0')
                {
                    digits--;
                }
                num = append(num, '.');
            }
            for(; digits > 0; )
            {
                num = append(num, '0');
                digits--;
            }
            num = append(num, tail);
        }
        if(f->plus || num[0] != '+')
        {
            if(f->zero && f->widPresent && f->wid > len(num))
            {
                rec::writeByte(gocpp::recv(f->buf), num[0]);
                rec::writePadding(gocpp::recv(f), f->wid - len(num));
                rec::write(gocpp::recv(f->buf), num.make_slice(1));
                return;
            }
            rec::pad(gocpp::recv(f), num);
            return;
        }
        rec::pad(gocpp::recv(f), num.make_slice(1));
    }

}

