// generated by GoCpp from file '$(ImportDir)/runtime/error.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/error.h"
#include "gocpp/support.h"

#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]

namespace golang::runtime
{
    
    template<typename T>
    Error::Error(T& ref)
    {
        value.reset(new ErrorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Error::Error(const T& ref)
    {
        value.reset(new ErrorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Error::Error(T* ptr)
    {
        value.reset(new ErrorImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Error::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Error::ErrorImpl<T, StoreT>::vRuntimeError()
    {
        return RuntimeError(gocpp::PtrRecv<T, false>(value.get()));
    }

    void RuntimeError(const gocpp::PtrRecv<Error, false>& self)
    {
        return self.ptr->value->vRuntimeError();
    }

    void RuntimeError(const gocpp::ObjRecv<Error>& self)
    {
        return self.obj.value->vRuntimeError();
    }

    std::ostream& operator<<(std::ostream& os, const struct Error& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& TypeAssertionError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _interface;
        os << " " << concrete;
        os << " " << asserted;
        os << " " << missingMethod;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct TypeAssertionError& value)
    {
        return value.PrintTo(os);
    }

    void RuntimeError(TypeAssertionError*)
    {
    }

    std::string Error(struct TypeAssertionError* e)
    {
        auto inter = "interface";
        if(e->_interface != nullptr)
        {
            inter = string(gocpp::recv(toRType(e->_interface)));
        }
        auto as = string(gocpp::recv(toRType(e->asserted)));
        if(e->concrete == nullptr)
        {
            return "interface conversion: " + inter + " is nil, not " + as;
        }
        auto cs = string(gocpp::recv(toRType(e->concrete)));
        if(e->missingMethod == "")
        {
            auto msg = "interface conversion: " + inter + " is " + cs + ", not " + as;
            if(cs == as)
            {
                if(pkgpath(gocpp::recv(toRType(e->concrete))) != pkgpath(gocpp::recv(toRType(e->asserted))))
                {
                    msg += " (types from different packages)";
                }
                else
                {
                    msg += " (types from different scopes)";
                }
            }
            return msg;
        }
        return "interface conversion: " + cs + " is not " + as + ": missing method " + e->missingMethod;
    }

    gocpp::slice<unsigned char> itoa(gocpp::slice<unsigned char> buf, uint64_t val)
    {
        auto i = len(buf) - 1;
        for(; val >= 10; )
        {
            buf[i] = byte(val % 10 + '0');
            i--;
            val /= 10;
        }
        buf[i] = byte(val + '0');
        return buf.make_slice(i);
    }

    void RuntimeError(errorString e)
    {
    }

    std::string Error(errorString e)
    {
        return "runtime error: " + string(e);
    }

    
    std::ostream& errorAddressString::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << msg;
        os << " " << addr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct errorAddressString& value)
    {
        return value.PrintTo(os);
    }

    void RuntimeError(struct errorAddressString e)
    {
    }

    std::string Error(struct errorAddressString e)
    {
        return "runtime error: " + e.msg;
    }

    uintptr_t Addr(struct errorAddressString e)
    {
        return e.addr;
    }

    void RuntimeError(plainError e)
    {
    }

    std::string Error(plainError e)
    {
        return string(e);
    }

    
    std::ostream& boundsError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << x;
        os << " " << y;
        os << " " << go_signed;
        os << " " << code;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct boundsError& value)
    {
        return value.PrintTo(os);
    }

    boundsErrorCode boundsIndex = 0;
    boundsErrorCode boundsSliceAlen = 1;
    boundsErrorCode boundsSliceAcap = 2;
    boundsErrorCode boundsSliceB = 3;
    boundsErrorCode boundsSlice3Alen = 4;
    boundsErrorCode boundsSlice3Acap = 5;
    boundsErrorCode boundsSlice3B = 6;
    boundsErrorCode boundsSlice3C = 7;
    boundsErrorCode boundsConvert = 8;
    gocpp::array_base<std::string> boundsErrorFmts = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.boundsIndex = "index out of range [%x] with length %y"; x.boundsSliceAlen = "slice bounds out of range [:%x] with length %y"; x.boundsSliceAcap = "slice bounds out of range [:%x] with capacity %y"; x.boundsSliceB = "slice bounds out of range [%x:%y]"; x.boundsSlice3Alen = "slice bounds out of range [::%x] with length %y"; x.boundsSlice3Acap = "slice bounds out of range [::%x] with capacity %y"; x.boundsSlice3B = "slice bounds out of range [:%x:%y]"; x.boundsSlice3C = "slice bounds out of range [%x:%y:]"; x.boundsConvert = "cannot convert slice with length %y to array or pointer to array with length %x"; });
    gocpp::array_base<std::string> boundsNegErrorFmts = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.boundsIndex = "index out of range [%x]"; x.boundsSliceAlen = "slice bounds out of range [:%x]"; x.boundsSliceAcap = "slice bounds out of range [:%x]"; x.boundsSliceB = "slice bounds out of range [%x:]"; x.boundsSlice3Alen = "slice bounds out of range [::%x]"; x.boundsSlice3Acap = "slice bounds out of range [::%x]"; x.boundsSlice3B = "slice bounds out of range [:%x:]"; x.boundsSlice3C = "slice bounds out of range [%x::]"; });
    void RuntimeError(struct boundsError e)
    {
    }

    gocpp::slice<unsigned char> appendIntStr(gocpp::slice<unsigned char> b, int64_t v, bool go_signed)
    {
        if(go_signed && v < 0)
        {
            b = append(b, '-');
            v = - v;
        }
        gocpp::array<unsigned char, 20> buf = {};
        b = append(b, itoa(buf.make_slice(0, ), uint64_t(v)));
        return b;
    }

    std::string Error(struct boundsError e)
    {
        auto fmt = boundsErrorFmts[e.code];
        if(e.go_signed && e.x < 0)
        {
            fmt = boundsNegErrorFmts[e.code];
        }
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 100);
        b = append(b, "runtime error: ");
        for(auto i = 0; i < len(fmt); i++)
        {
            auto c = fmt[i];
            if(c != '%')
            {
                b = append(b, c);
                continue;
            }
            i++;
            //Go switch emulation
            {
                auto condition = fmt[i];
                int conditionId = -1;
                if(condition == 'x') { conditionId = 0; }
                else if(condition == 'y') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        b = appendIntStr(b, e.x, e.go_signed);
                        break;
                    case 1:
                        b = appendIntStr(b, int64(e.y), true);
                        break;
                }
            }
        }
        return string(b);
    }

    
    template<typename T>
    stringer::stringer(T& ref)
    {
        value.reset(new stringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    stringer::stringer(const T& ref)
    {
        value.reset(new stringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    stringer::stringer(T* ptr)
    {
        value.reset(new stringerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& stringer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string stringer::stringerImpl<T, StoreT>::vString()
    {
        return String(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::string String(const gocpp::PtrRecv<stringer, false>& self)
    {
        return self.ptr->value->vString();
    }

    std::string String(const gocpp::ObjRecv<stringer>& self)
    {
        return self.obj.value->vString();
    }

    std::ostream& operator<<(std::ostream& os, const struct stringer& value)
    {
        return value.PrintTo(os);
    }

    void printany(go_any i)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_0 = gocpp::type_info(i);
            int conditionId = -1;
            if(gocpp_id_0 == typeid(untyped nil)) { conditionId = 0; }
            else if(gocpp_id_0 == typeid(bool)) { conditionId = 1; }
            else if(gocpp_id_0 == typeid(int)) { conditionId = 2; }
            else if(gocpp_id_0 == typeid(int8_t)) { conditionId = 3; }
            else if(gocpp_id_0 == typeid(int16_t)) { conditionId = 4; }
            else if(gocpp_id_0 == typeid(int32_t)) { conditionId = 5; }
            else if(gocpp_id_0 == typeid(int64_t)) { conditionId = 6; }
            else if(gocpp_id_0 == typeid(unsigned int)) { conditionId = 7; }
            else if(gocpp_id_0 == typeid(uint8_t)) { conditionId = 8; }
            else if(gocpp_id_0 == typeid(uint16_t)) { conditionId = 9; }
            else if(gocpp_id_0 == typeid(uint32_t)) { conditionId = 10; }
            else if(gocpp_id_0 == typeid(uint64_t)) { conditionId = 11; }
            else if(gocpp_id_0 == typeid(uintptr_t)) { conditionId = 12; }
            else if(gocpp_id_0 == typeid(float)) { conditionId = 13; }
            else if(gocpp_id_0 == typeid(double)) { conditionId = 14; }
            else if(gocpp_id_0 == typeid(complex64)) { conditionId = 15; }
            else if(gocpp_id_0 == typeid(gocpp::complex128)) { conditionId = 16; }
            else if(gocpp_id_0 == typeid(std::string)) { conditionId = 17; }
            switch(conditionId)
            {
                case 0:
                {
                    untyped nil v = gocpp::any_cast<untyped nil>(i);
                    print("nil");
                    break;
                }
                case 1:
                {
                    bool v = gocpp::any_cast<bool>(i);
                    print(v);
                    break;
                }
                case 2:
                {
                    int v = gocpp::any_cast<int>(i);
                    print(v);
                    break;
                }
                case 3:
                {
                    int8_t v = gocpp::any_cast<int8_t>(i);
                    print(v);
                    break;
                }
                case 4:
                {
                    int16_t v = gocpp::any_cast<int16_t>(i);
                    print(v);
                    break;
                }
                case 5:
                {
                    int32_t v = gocpp::any_cast<int32_t>(i);
                    print(v);
                    break;
                }
                case 6:
                {
                    int64_t v = gocpp::any_cast<int64_t>(i);
                    print(v);
                    break;
                }
                case 7:
                {
                    unsigned int v = gocpp::any_cast<unsigned int>(i);
                    print(v);
                    break;
                }
                case 8:
                {
                    uint8_t v = gocpp::any_cast<uint8_t>(i);
                    print(v);
                    break;
                }
                case 9:
                {
                    uint16_t v = gocpp::any_cast<uint16_t>(i);
                    print(v);
                    break;
                }
                case 10:
                {
                    uint32_t v = gocpp::any_cast<uint32_t>(i);
                    print(v);
                    break;
                }
                case 11:
                {
                    uint64_t v = gocpp::any_cast<uint64_t>(i);
                    print(v);
                    break;
                }
                case 12:
                {
                    uintptr_t v = gocpp::any_cast<uintptr_t>(i);
                    print(v);
                    break;
                }
                case 13:
                {
                    float v = gocpp::any_cast<float>(i);
                    print(v);
                    break;
                }
                case 14:
                {
                    double v = gocpp::any_cast<double>(i);
                    print(v);
                    break;
                }
                case 15:
                {
                    complex64 v = gocpp::any_cast<complex64>(i);
                    print(v);
                    break;
                }
                case 16:
                {
                    gocpp::complex128 v = gocpp::any_cast<gocpp::complex128>(i);
                    print(v);
                    break;
                }
                case 17:
                {
                    std::string v = gocpp::any_cast<std::string>(i);
                    print(v);
                    break;
                }
                default:
                {
                    auto v = i;
                    printanycustomtype(i);
                    break;
                }
            }
        }
    }

    void printanycustomtype(go_any i)
    {
        auto eface = efaceOf(& i);
        auto typestring = string(gocpp::recv(toRType(eface->_type)));
        //Go switch emulation
        {
            auto condition = eface->_type->Kind_;
            int conditionId = -1;
            if(condition == kindString) { conditionId = 0; }
            else if(condition == kindBool) { conditionId = 1; }
            else if(condition == kindInt) { conditionId = 2; }
            else if(condition == kindInt8) { conditionId = 3; }
            else if(condition == kindInt16) { conditionId = 4; }
            else if(condition == kindInt32) { conditionId = 5; }
            else if(condition == kindInt64) { conditionId = 6; }
            else if(condition == kindUint) { conditionId = 7; }
            else if(condition == kindUint8) { conditionId = 8; }
            else if(condition == kindUint16) { conditionId = 9; }
            else if(condition == kindUint32) { conditionId = 10; }
            else if(condition == kindUint64) { conditionId = 11; }
            else if(condition == kindUintptr) { conditionId = 12; }
            else if(condition == kindFloat32) { conditionId = 13; }
            else if(condition == kindFloat64) { conditionId = 14; }
            else if(condition == kindComplex64) { conditionId = 15; }
            else if(condition == kindComplex128) { conditionId = 16; }
            switch(conditionId)
            {
                case 0:
                    print(typestring, `("`, *(std::string*)(eface->data), `")`);
                    break;
                case 1:
                    print(typestring, "(", *(bool*)(eface->data), ")");
                    break;
                case 2:
                    print(typestring, "(", *(int*)(eface->data), ")");
                    break;
                case 3:
                    print(typestring, "(", *(int8_t*)(eface->data), ")");
                    break;
                case 4:
                    print(typestring, "(", *(int16_t*)(eface->data), ")");
                    break;
                case 5:
                    print(typestring, "(", *(int32_t*)(eface->data), ")");
                    break;
                case 6:
                    print(typestring, "(", *(int64_t*)(eface->data), ")");
                    break;
                case 7:
                    print(typestring, "(", *(unsigned int*)(eface->data), ")");
                    break;
                case 8:
                    print(typestring, "(", *(uint8_t*)(eface->data), ")");
                    break;
                case 9:
                    print(typestring, "(", *(uint16_t*)(eface->data), ")");
                    break;
                case 10:
                    print(typestring, "(", *(uint32_t*)(eface->data), ")");
                    break;
                case 11:
                    print(typestring, "(", *(uint64_t*)(eface->data), ")");
                    break;
                case 12:
                    print(typestring, "(", *(uintptr_t*)(eface->data), ")");
                    break;
                case 13:
                    print(typestring, "(", *(float*)(eface->data), ")");
                    break;
                case 14:
                    print(typestring, "(", *(double*)(eface->data), ")");
                    break;
                case 15:
                    print(typestring, *(complex64*)(eface->data));
                    break;
                case 16:
                    print(typestring, *(gocpp::complex128*)(eface->data));
                    break;
                default:
                    print("(", typestring, ") ", eface->data);
                    break;
            }
        }
    }

    void panicwrap()
    {
        auto pc = getcallerpc();
        auto name = funcNameForPrint(funcname(findfunc(pc)));
        auto i = IndexByteString(gocpp::recv(bytealg), name, '(');
        if(i < 0)
        {
            go_throw("panicwrap: no ( in " + name);
        }
        auto pkg = name.make_slice(0, i - 1);
        if(i + 2 >= len(name) || name.make_slice(i - 1, i + 2) != ".(*")
        {
            go_throw("panicwrap: unexpected string after package name: " + name);
        }
        name = name.make_slice(i + 2);
        i = IndexByteString(gocpp::recv(bytealg), name, ')');
        if(i < 0)
        {
            go_throw("panicwrap: no ) in " + name);
        }
        if(i + 2 >= len(name) || name.make_slice(i, i + 2) != ").")
        {
            go_throw("panicwrap: unexpected string after type name: " + name);
        }
        auto typ = name.make_slice(0, i);
        auto meth = name.make_slice(i + 2);
        gocpp::panic(plainError("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"));
    }

}

