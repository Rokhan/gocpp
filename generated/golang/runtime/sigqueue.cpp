// generated by GoCpp from file '$(ImportDir)/runtime/sigqueue.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/sigqueue.h"
#include "gocpp/support.h"

#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sigqueue_note.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
    }

    struct gocpp_id_0
    {
        note note;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> mask;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> wanted;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> ignored;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> recv;
        atomic::Uint32 state;
        atomic::Uint32 delivering;
        bool inuse;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.note = this->note;
            result.mask = this->mask;
            result.wanted = this->wanted;
            result.ignored = this->ignored;
            result.recv = this->recv;
            result.state = this->state;
            result.delivering = this->delivering;
            result.inuse = this->inuse;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (note != ref.note) return false;
            if (mask != ref.mask) return false;
            if (wanted != ref.wanted) return false;
            if (ignored != ref.ignored) return false;
            if (recv != ref.recv) return false;
            if (state != ref.state) return false;
            if (delivering != ref.delivering) return false;
            if (inuse != ref.inuse) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << note;
            os << " " << mask;
            os << " " << wanted;
            os << " " << ignored;
            os << " " << recv;
            os << " " << state;
            os << " " << delivering;
            os << " " << inuse;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // sig handles communication between the signal handler and os/signal.
    // Other than the inuse and recv fields, the fields are accessed atomically.
    //
    // The wanted and ignored fields are only written by one goroutine at
    // a time; access is controlled by the handlers Mutex in os/signal.
    // The fields are only read by that one goroutine and by the signal handler.
    // We access them atomically to minimize the race between setting them
    // in the goroutine calling os/signal and the signal handler,
    // which may be running in a different thread. That race is unavoidable,
    // as there is no connection between handling a signal and receiving one,
    // but atomic instructions should minimize it.
    gocpp_id_0 sig;
    // sigsend delivers a signal from sighandler to the internal signal delivery queue.
    // It reports whether the signal was sent. If not, the caller typically crashes the program.
    // It runs from the signal handler, so it's limited in what it can do.
    bool sigsend(uint32_t s)
    {
        auto bit = uint32_t(1) << (unsigned int)(s & 31);
        if(s >= uint32_t(32 * len(sig.wanted)))
        {
            return false;
        }
        rec::Add(gocpp::recv(sig.delivering), 1);
        if(auto w = atomic::Load(& sig.wanted[s / 32]); w & bit == 0)
        {
            rec::Add(gocpp::recv(sig.delivering), - 1);
            return false;
        }
        for(; ; )
        {
            auto mask = sig.mask[s / 32];
            if(mask & bit != 0)
            {
                rec::Add(gocpp::recv(sig.delivering), - 1);
                return true;
            }
            if(atomic::Cas(& sig.mask[s / 32], mask, mask | bit))
            {
                break;
            }
        }
        Send:
        for(; ; )
        {
            //Go switch emulation
            {
                auto condition = rec::Load(gocpp::recv(sig.state));
                int conditionId = -1;
                if(condition == sigIdle) { conditionId = 0; }
                else if(condition == sigSending) { conditionId = 1; }
                else if(condition == sigReceiving) { conditionId = 2; }
                switch(conditionId)
                {
                    default:
                        go_throw("sigsend: inconsistent state"s);
                        break;
                    case 0:
                        if(rec::CompareAndSwap(gocpp::recv(sig.state), sigIdle, sigSending))
                        {
                            goto Send_break;
                        }
                        break;
                    case 1:
                        goto Send_break;
                        break;
                    case 2:
                        if(rec::CompareAndSwap(gocpp::recv(sig.state), sigReceiving, sigIdle))
                        {
                            if(GOOS == "darwin"s || GOOS == "ios"s)
                            {
                                sigNoteWakeup(& sig.note);
                                goto Send_break;
                            }
                            notewakeup(& sig.note);
                            goto Send_break;
                        }
                        break;
                }
            }
            if(false) {
            Send_continue:
                continue;
            Send_break:
                break;
            }
        }
        rec::Add(gocpp::recv(sig.delivering), - 1);
        return true;
    }

    // Called to receive the next queued signal.
    // Must only be called from a single goroutine at a time.
    //
    //go:linkname signal_recv os/signal.signal_recv
    uint32_t signal_recv()
    {
        for(; ; )
        {
            for(auto i = uint32_t(0); i < _NSIG; i++)
            {
                if(sig.recv[i / 32] & (1 << (i & 31)) != 0)
                {
                    sig.recv[i / 32] &^= 1 << (i & 31);
                    return i;
                }
            }
            Receive:
            for(; ; )
            {
                //Go switch emulation
                {
                    auto condition = rec::Load(gocpp::recv(sig.state));
                    int conditionId = -1;
                    if(condition == sigIdle) { conditionId = 0; }
                    else if(condition == sigSending) { conditionId = 1; }
                    switch(conditionId)
                    {
                        default:
                            go_throw("signal_recv: inconsistent state"s);
                            break;
                        case 0:
                            if(rec::CompareAndSwap(gocpp::recv(sig.state), sigIdle, sigReceiving))
                            {
                                if(GOOS == "darwin"s || GOOS == "ios"s)
                                {
                                    sigNoteSleep(& sig.note);
                                    goto Receive_break;
                                }
                                notetsleepg(& sig.note, - 1);
                                noteclear(& sig.note);
                                goto Receive_break;
                            }
                            break;
                        case 1:
                            if(rec::CompareAndSwap(gocpp::recv(sig.state), sigSending, sigIdle))
                            {
                                goto Receive_break;
                            }
                            break;
                    }
                }
                if(false) {
                Receive_continue:
                    continue;
                Receive_break:
                    break;
                }
            }
            for(auto [i, gocpp_ignored] : sig.mask)
            {
                sig.recv[i] = atomic::Xchg(& sig.mask[i], 0);
            }
        }
    }

    // signalWaitUntilIdle waits until the signal delivery mechanism is idle.
    // This is used to ensure that we do not drop a signal notification due
    // to a race between disabling a signal and receiving a signal.
    // This assumes that signal delivery has already been disabled for
    // the signal(s) in question, and here we are just waiting to make sure
    // that all the signals have been delivered to the user channels
    // by the os/signal package.
    //
    //go:linkname signalWaitUntilIdle os/signal.signalWaitUntilIdle
    void signalWaitUntilIdle()
    {
        for(; rec::Load(gocpp::recv(sig.delivering)) != 0; )
        {
            Gosched();
        }
        for(; rec::Load(gocpp::recv(sig.state)) != sigReceiving; )
        {
            Gosched();
        }
    }

    // Must only be called from a single goroutine at a time.
    //
    //go:linkname signal_enable os/signal.signal_enable
    void signal_enable(uint32_t s)
    {
        if(! sig.inuse)
        {
            sig.inuse = true;
            if(GOOS == "darwin"s || GOOS == "ios"s)
            {
                sigNoteSetup(& sig.note);
            }
            else
            {
                noteclear(& sig.note);
            }
        }
        if(s >= uint32_t(len(sig.wanted) * 32))
        {
            return;
        }
        auto w = sig.wanted[s / 32];
        w |= 1 << (s & 31);
        atomic::Store(& sig.wanted[s / 32], w);
        auto i = sig.ignored[s / 32];
        i &^= 1 << (s & 31);
        atomic::Store(& sig.ignored[s / 32], i);
        sigenable(s);
    }

    // Must only be called from a single goroutine at a time.
    //
    //go:linkname signal_disable os/signal.signal_disable
    void signal_disable(uint32_t s)
    {
        if(s >= uint32_t(len(sig.wanted) * 32))
        {
            return;
        }
        sigdisable(s);
        auto w = sig.wanted[s / 32];
        w &^= 1 << (s & 31);
        atomic::Store(& sig.wanted[s / 32], w);
    }

    // Must only be called from a single goroutine at a time.
    //
    //go:linkname signal_ignore os/signal.signal_ignore
    void signal_ignore(uint32_t s)
    {
        if(s >= uint32_t(len(sig.wanted) * 32))
        {
            return;
        }
        sigignore(s);
        auto w = sig.wanted[s / 32];
        w &^= 1 << (s & 31);
        atomic::Store(& sig.wanted[s / 32], w);
        auto i = sig.ignored[s / 32];
        i |= 1 << (s & 31);
        atomic::Store(& sig.ignored[s / 32], i);
    }

    // sigInitIgnored marks the signal as already ignored. This is called at
    // program start by initsig. In a shared library initsig is called by
    // libpreinit, so the runtime may not be initialized yet.
    //
    //go:nosplit
    void sigInitIgnored(uint32_t s)
    {
        auto i = sig.ignored[s / 32];
        i |= 1 << (s & 31);
        atomic::Store(& sig.ignored[s / 32], i);
    }

    // Checked by signal handlers.
    //
    //go:linkname signal_ignored os/signal.signal_ignored
    bool signal_ignored(uint32_t s)
    {
        auto i = atomic::Load(& sig.ignored[s / 32]);
        return i & (1 << (s & 31)) != 0;
    }

}

