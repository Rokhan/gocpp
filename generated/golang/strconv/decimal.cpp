// generated by GoCpp from file '$(ImportDir)/strconv/decimal.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/decimal.h"
#include "gocpp/support.h"

namespace golang::strconv
{
    
    template<typename T> requires gocpp::GoStruct<T>
    decimal::operator T()
    {
        T result;
        result.d = this->d;
        result.nd = this->nd;
        result.dp = this->dp;
        result.neg = this->neg;
        result.trunc = this->trunc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decimal::operator==(const T& ref) const
    {
        if (d != ref.d) return false;
        if (nd != ref.nd) return false;
        if (dp != ref.dp) return false;
        if (neg != ref.neg) return false;
        if (trunc != ref.trunc) return false;
        return true;
    }

    std::ostream& decimal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << d;
        os << " " << nd;
        os << " " << dp;
        os << " " << neg;
        os << " " << trunc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decimal& value)
    {
        return value.PrintTo(os);
    }

    std::string String(struct decimal* a)
    {
        auto n = 10 + a->nd;
        if(a->dp > 0)
        {
            n += a->dp;
        }
        if(a->dp < 0)
        {
            n += - a->dp;
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
        auto w = 0;
        //Go switch emulation
        {
            int conditionId = -1;
            if(a->nd == 0) { conditionId = 0; }
            else if(a->dp <= 0) { conditionId = 1; }
            else if(a->dp < a->nd) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return "0";
                    break;
                case 1:
                    buf[w] = '0';
                    w++;
                    buf[w] = '.';
                    w++;
                    w += digitZero(buf.make_slice(w, w + - a->dp));
                    w += copy(buf.make_slice(w), a->d.make_slice(0, a->nd));
                    break;
                case 2:
                    w += copy(buf.make_slice(w), a->d.make_slice(0, a->dp));
                    buf[w] = '.';
                    w++;
                    w += copy(buf.make_slice(w), a->d.make_slice(a->dp, a->nd));
                    break;
                default:
                    w += copy(buf.make_slice(w), a->d.make_slice(0, a->nd));
                    w += digitZero(buf.make_slice(w, w + a->dp - a->nd));
                    break;
            }
        }
        return string(buf.make_slice(0, w));
    }

    int digitZero(gocpp::slice<unsigned char> dst)
    {
        for(auto [i, gocpp_ignored] : dst)
        {
            dst[i] = '0';
        }
        return len(dst);
    }

    void trim(struct decimal* a)
    {
        for(; a->nd > 0 && a->d[a->nd - 1] == '0'; )
        {
            a->nd--;
        }
        if(a->nd == 0)
        {
            a->dp = 0;
        }
    }

    void Assign(struct decimal* a, uint64_t v)
    {
        gocpp::array<unsigned char, 24> buf = {};
        auto n = 0;
        for(; v > 0; )
        {
            auto v1 = v / 10;
            v -= 10 * v1;
            buf[n] = unsigned char(v + '0');
            n++;
            v = v1;
        }
        a->nd = 0;
        for(n--; n >= 0; n--)
        {
            a->d[a->nd] = buf[n];
            a->nd++;
        }
        a->dp = a->nd;
        trim(a);
    }

    void rightShift(struct decimal* a, unsigned int k)
    {
        auto r = 0;
        auto w = 0;
        unsigned int n = {};
        for(; (n >> k) == 0; r++)
        {
            if(r >= a->nd)
            {
                if(n == 0)
                {
                    a->nd = 0;
                    return;
                }
                for(; (n >> k) == 0; )
                {
                    n = n * 10;
                    r++;
                }
                break;
            }
            auto c = (unsigned int)(a->d[r]);
            n = n * 10 + c - '0';
        }
        a->dp -= r - 1;
        unsigned int mask = (1 << k) - 1;
        for(; r < a->nd; r++)
        {
            auto c = (unsigned int)(a->d[r]);
            auto dig = n >> k;
            n &= mask;
            a->d[w] = unsigned char(dig + '0');
            w++;
            n = n * 10 + c - '0';
        }
        for(; n > 0; )
        {
            auto dig = n >> k;
            n &= mask;
            if(w < len(a->d))
            {
                a->d[w] = unsigned char(dig + '0');
                w++;
            }
            else
            if(dig > 0)
            {
                a->trunc = true;
            }
            n = n * 10;
        }
        a->nd = w;
        trim(a);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    leftCheat::operator T()
    {
        T result;
        result.delta = this->delta;
        result.cutoff = this->cutoff;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool leftCheat::operator==(const T& ref) const
    {
        if (delta != ref.delta) return false;
        if (cutoff != ref.cutoff) return false;
        return true;
    }

    std::ostream& leftCheat::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << delta;
        os << " " << cutoff;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct leftCheat& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<leftCheat> leftcheats = gocpp::slice<leftCheat> { {0, ""},  {1, "5"},  {1, "25"},  {1, "125"},  {2, "625"},  {2, "3125"},  {2, "15625"},  {3, "78125"},  {3, "390625"},  {3, "1953125"},  {4, "9765625"},  {4, "48828125"},  {4, "244140625"},  {4, "1220703125"},  {5, "6103515625"},  {5, "30517578125"},  {5, "152587890625"},  {6, "762939453125"},  {6, "3814697265625"},  {6, "19073486328125"},  {7, "95367431640625"},  {7, "476837158203125"},  {7, "2384185791015625"},  {7, "11920928955078125"},  {8, "59604644775390625"},  {8, "298023223876953125"},  {8, "1490116119384765625"},  {9, "7450580596923828125"},  {9, "37252902984619140625"},  {9, "186264514923095703125"},  {10, "931322574615478515625"},  {10, "4656612873077392578125"},  {10, "23283064365386962890625"},  {10, "116415321826934814453125"},  {11, "582076609134674072265625"},  {11, "2910383045673370361328125"},  {11, "14551915228366851806640625"},  {12, "72759576141834259033203125"},  {12, "363797880709171295166015625"},  {12, "1818989403545856475830078125"},  {13, "9094947017729282379150390625"},  {13, "45474735088646411895751953125"},  {13, "227373675443232059478759765625"},  {13, "1136868377216160297393798828125"},  {14, "5684341886080801486968994140625"},  {14, "28421709430404007434844970703125"},  {14, "142108547152020037174224853515625"},  {15, "710542735760100185871124267578125"},  {15, "3552713678800500929355621337890625"},  {15, "17763568394002504646778106689453125"},  {16, "88817841970012523233890533447265625"},  {16, "444089209850062616169452667236328125"},  {16, "2220446049250313080847263336181640625"},  {16, "11102230246251565404236316680908203125"},  {17, "55511151231257827021181583404541015625"},  {17, "277555756156289135105907917022705078125"},  {17, "1387778780781445675529539585113525390625"},  {18, "6938893903907228377647697925567626953125"},  {18, "34694469519536141888238489627838134765625"},  {18, "173472347597680709441192448139190673828125"},  {19, "867361737988403547205962240695953369140625"}};
    bool prefixIsLessThan(gocpp::slice<unsigned char> b, std::string s)
    {
        for(auto i = 0; i < len(s); i++)
        {
            if(i >= len(b))
            {
                return true;
            }
            if(b[i] != s[i])
            {
                return b[i] < s[i];
            }
        }
        return false;
    }

    void leftShift(struct decimal* a, unsigned int k)
    {
        auto delta = leftcheats[k].delta;
        if(prefixIsLessThan(a->d.make_slice(0, a->nd), leftcheats[k].cutoff))
        {
            delta--;
        }
        auto r = a->nd;
        auto w = a->nd + delta;
        unsigned int n = {};
        for(r--; r >= 0; r--)
        {
            n += ((unsigned int)(a->d[r]) - '0') << k;
            auto quo = n / 10;
            auto rem = n - 10 * quo;
            w--;
            if(w < len(a->d))
            {
                a->d[w] = unsigned char(rem + '0');
            }
            else
            if(rem != 0)
            {
                a->trunc = true;
            }
            n = quo;
        }
        for(; n > 0; )
        {
            auto quo = n / 10;
            auto rem = n - 10 * quo;
            w--;
            if(w < len(a->d))
            {
                a->d[w] = unsigned char(rem + '0');
            }
            else
            if(rem != 0)
            {
                a->trunc = true;
            }
            n = quo;
        }
        a->nd += delta;
        if(a->nd >= len(a->d))
        {
            a->nd = len(a->d);
        }
        a->dp += delta;
        trim(a);
    }

    void Shift(struct decimal* a, int k)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(a->nd == 0) { conditionId = 0; }
            else if(k > 0) { conditionId = 1; }
            else if(k < 0) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    break;
                case 1:
                    for(; k > maxShift; )
                    {
                        leftShift(a, maxShift);
                        k -= maxShift;
                    }
                    leftShift(a, (unsigned int)(k));
                    break;
                case 2:
                    for(; k < - maxShift; )
                    {
                        rightShift(a, maxShift);
                        k += maxShift;
                    }
                    rightShift(a, (unsigned int)(- k));
                    break;
            }
        }
    }

    bool shouldRoundUp(struct decimal* a, int nd)
    {
        if(nd < 0 || nd >= a->nd)
        {
            return false;
        }
        if(a->d[nd] == '5' && nd + 1 == a->nd)
        {
            if(a->trunc)
            {
                return true;
            }
            return nd > 0 && (a->d[nd - 1] - '0') % 2 != 0;
        }
        return a->d[nd] >= '5';
    }

    void Round(struct decimal* a, int nd)
    {
        if(nd < 0 || nd >= a->nd)
        {
            return;
        }
        if(shouldRoundUp(a, nd))
        {
            RoundUp(gocpp::recv(a), nd);
        }
        else
        {
            RoundDown(gocpp::recv(a), nd);
        }
    }

    void RoundDown(struct decimal* a, int nd)
    {
        if(nd < 0 || nd >= a->nd)
        {
            return;
        }
        a->nd = nd;
        trim(a);
    }

    void RoundUp(struct decimal* a, int nd)
    {
        if(nd < 0 || nd >= a->nd)
        {
            return;
        }
        for(auto i = nd - 1; i >= 0; i--)
        {
            auto c = a->d[i];
            if(c < '9')
            {
                a->d[i]++;
                a->nd = i + 1;
                return;
            }
        }
        a->d[0] = '1';
        a->nd = 1;
        a->dp++;
    }

    uint64_t RoundedInteger(struct decimal* a)
    {
        if(a->dp > 20)
        {
            return 0xFFFFFFFFFFFFFFFF;
        }
        int i = {};
        auto n = uint64_t(0);
        for(i = 0; i < a->dp && i < a->nd; i++)
        {
            n = n * 10 + uint64_t(a->d[i] - '0');
        }
        for(; i < a->dp; i++)
        {
            n *= 10;
        }
        if(shouldRoundUp(a, a->dp))
        {
            n++;
        }
        return n;
    }

}

