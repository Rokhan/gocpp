// generated by GoCpp from file '$(ImportDir)/golang.org/x/tour/wc/wc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/golang.org/x/tour/wc/wc.h"
#include "gocpp/support.h"

#include "golang/fmt/print.h"

namespace golang::wc
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Test runs a test suite against f.
    void Test(std::function<gocpp::map<std::string, int> (std::string)> f)
    {
        auto ok = true;
        for(auto [gocpp_ignored, c] : testCases)
        {
            auto got = f(c.in);
            if(len(c.want) != len(got))
            {
                ok = false;
            }
            else
            {
                for(auto [k, gocpp_ignored] : c.want)
                {
                    if(c.want[k] != got[k])
                    {
                        ok = false;
                    }
                }
            }
            if(! ok)
            {
                mocklib::Printf("FAIL\n f(%q) =\n  %#v\n want:\n  %#v"s, c.in, got, c.want);
                break;
            }
            mocklib::Printf("PASS\n f(%q) = \n  %#v\n"s, c.in, got);
        }
    }

    struct gocpp_id_0
    {
        std::string in;
        gocpp::map<std::string, int> want;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.in = this->in;
            result.want = this->want;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (in != ref.in) return false;
            if (want != ref.want) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << in;
            os << " " << want;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp::slice<gocpp_id_0> testCases = gocpp::slice<gocpp_id_0> { {"I am learning Go!"s, gocpp::map<std::string, int> {{ "I"s, 1 }, { "am"s, 1 }, { "learning"s, 1 }, { "Go!"s, 1 }}},  {"The quick brown fox jumped over the lazy dog."s, gocpp::map<std::string, int> {{ "The"s, 1 }, { "quick"s, 1 }, { "brown"s, 1 }, { "fox"s, 1 }, { "jumped"s, 1 }, { "over"s, 1 }, { "the"s, 1 }, { "lazy"s, 1 }, { "dog."s, 1 }}},  {"I ate a donut. Then I ate another donut."s, gocpp::map<std::string, int> {{ "I"s, 2 }, { "ate"s, 2 }, { "a"s, 1 }, { "donut."s, 2 }, { "Then"s, 1 }, { "another"s, 1 }}},  {"A man a plan a canal panama."s, gocpp::map<std::string, int> {{ "A"s, 1 }, { "man"s, 1 }, { "a"s, 2 }, { "plan"s, 1 }, { "canal"s, 1 }, { "panama."s, 1 }}}};
}

