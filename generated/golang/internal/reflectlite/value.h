// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/value.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/value.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/reflectlite/type.h"

namespace golang::reflectlite
{
    struct Value
    {
        abi::Type* typ_;
        gocpp::unsafe_pointer ptr;
        golang::reflectlite::flag flag;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Value& value);
    go_any packEface(struct Value v);
    struct Value unpackEface(go_any i);
    struct ValueError
    {
        gocpp::string Method;
        golang::reflectlite::Kind Kind;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value);
    gocpp::string methodName();
    struct emptyInterface
    {
        abi::Type* typ;
        gocpp::unsafe_pointer word;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value);
    struct gocpp_id_3 : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        gocpp_id_3(){}
        gocpp_id_3(gocpp_id_3& i) = default;
        gocpp_id_3(const gocpp_id_3& i) = default;
        gocpp_id_3& operator=(gocpp_id_3& i) = default;
        gocpp_id_3& operator=(const gocpp_id_3& i) = default;

        template<typename T>
        gocpp_id_3(T& ref);

        template<typename T>
        gocpp_id_3(const T& ref);

        template<typename T>
        gocpp_id_3(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_3
        {
            virtual void vM() = 0;
            virtual void* getPtr() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_3Impl : Igocpp_id_3
        {
            explicit gocpp_id_3Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            void* getPtr() override
            {
                return value.get();
            }

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_3> value;
    };

    namespace rec
    {
        void M(const gocpp::PtrRecv<struct gocpp_id_3, false>& self);
        void M(const gocpp::ObjRecv<struct gocpp_id_3>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value);
    go_any valueInterface(struct Value v);
    struct gocpp_id_4 : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        gocpp_id_4(){}
        gocpp_id_4(gocpp_id_4& i) = default;
        gocpp_id_4(const gocpp_id_4& i) = default;
        gocpp_id_4& operator=(gocpp_id_4& i) = default;
        gocpp_id_4& operator=(const gocpp_id_4& i) = default;

        template<typename T>
        gocpp_id_4(T& ref);

        template<typename T>
        gocpp_id_4(const T& ref);

        template<typename T>
        gocpp_id_4(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_4
        {
            virtual void vM() = 0;
            virtual void* getPtr() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_4Impl : Igocpp_id_4
        {
            explicit gocpp_id_4Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            void* getPtr() override
            {
                return value.get();
            }

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_4> value;
    };

    namespace rec
    {
        void M(const gocpp::PtrRecv<struct gocpp_id_4, false>& self);
        void M(const gocpp::ObjRecv<struct gocpp_id_4>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_4& value);
    int chanlen(gocpp::unsafe_pointer);
    int maplen(gocpp::unsafe_pointer);
    gocpp::unsafe_pointer unsafe_New(abi::Type*);
    struct Value ValueOf(go_any i);
    gocpp::unsafe_pointer arrayAt(gocpp::unsafe_pointer p, int i, uintptr_t eltSize, gocpp::string whySafe);
    void ifaceE2I(abi::Type* t, go_any src, gocpp::unsafe_pointer dst);
    void typedmemmove(abi::Type* t, gocpp::unsafe_pointer dst, gocpp::unsafe_pointer src);
    void escapes(go_any x);
    extern gocpp_id_5 dummy;
    gocpp::unsafe_pointer noescape(gocpp::unsafe_pointer p);

    namespace rec
    {
        reflectlite::Kind kind(golang::reflectlite::flag f);
        reflectlite::flag ro(golang::reflectlite::flag f);
        abi::Type* typ(golang::reflectlite::Value v);
        gocpp::unsafe_pointer pointer(golang::reflectlite::Value v);
        gocpp::string Error(golang::reflectlite::ValueError* e);
        void mustBeExported(golang::reflectlite::flag f);
        void mustBeAssignable(golang::reflectlite::flag f);
        bool CanSet(golang::reflectlite::Value v);
        struct Value Elem(golang::reflectlite::Value v);
        bool IsNil(golang::reflectlite::Value v);
        bool IsValid(golang::reflectlite::Value v);
        reflectlite::Kind Kind(golang::reflectlite::Value v);
        int Len(golang::reflectlite::Value v);
        int numMethod(golang::reflectlite::Value v);
        void Set(golang::reflectlite::Value v, struct Value x);
        struct Type Type(golang::reflectlite::Value v);
        struct Value assignTo(golang::reflectlite::Value v, gocpp::string context, abi::Type* dst, gocpp::unsafe_pointer target);
    }
}

