// generated by GoCpp from file '$(ImportDir)/compress/flate/deflate.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/deflate.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/errors/errors.h"
#include "golang/fmt/errors.h"
#include "golang/io/io.h"
#include "golang/math/const.h"

namespace golang::flate
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Write;
    }

    // HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman
    // entropy encoding. This mode is useful in compressing data that has
    // already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)
    // that lacks an entropy encoder. Compression gains are achieved when
    // certain bytes in the input stream occur more frequently than others.
    //
    // Note that HuffmanOnly produces a compressed output that is
    // RFC 1951 compliant. That is, any valid DEFLATE decompressor will
    // continue to be able to decompress this output.
    // The LZ77 step produces a sequence of literal tokens and <length, offset>
    // pair tokens. The offset is also known as distance. The underlying wire
    // format limits the range of lengths and offsets. For example, there are
    // 256 legitimate lengths: those in the range [3, 258]. This package's
    // compressor uses a higher minimum match length, enabling optimizations
    // such as finding matches via 32-bit loads and compares.
    // The maximum number of tokens we put into a single flate block, just to
    // stop things from getting too large.
    
    template<typename T> requires gocpp::GoStruct<T>
    compressionLevel::operator T()
    {
        T result;
        result.level = this->level;
        result.good = this->good;
        result.lazy = this->lazy;
        result.nice = this->nice;
        result.chain = this->chain;
        result.fastSkipHashing = this->fastSkipHashing;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool compressionLevel::operator==(const T& ref) const
    {
        if (level != ref.level) return false;
        if (good != ref.good) return false;
        if (lazy != ref.lazy) return false;
        if (nice != ref.nice) return false;
        if (chain != ref.chain) return false;
        if (fastSkipHashing != ref.fastSkipHashing) return false;
        return true;
    }

    std::ostream& compressionLevel::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << level;
        os << " " << good;
        os << " " << lazy;
        os << " " << nice;
        os << " " << chain;
        os << " " << fastSkipHashing;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct compressionLevel& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<compressionLevel> levels = gocpp::slice<compressionLevel> { {0, 0, 0, 0, 0, 0},  {1, 0, 0, 0, 0, 0},  {2, 4, 0, 16, 8, 5},  {3, 4, 0, 32, 32, 6},  {4, 4, 4, 16, 16, skipNever},  {5, 8, 16, 32, 32, skipNever},  {6, 8, 16, 128, 128, skipNever},  {7, 8, 32, 128, 256, skipNever},  {8, 32, 128, 258, 1024, skipNever},  {9, 32, 258, 258, 4096, skipNever}};
    
    template<typename T> requires gocpp::GoStruct<T>
    compressor::operator T()
    {
        T result;
        result.compressionLevel = this->compressionLevel;
        result.w = this->w;
        result.bulkHasher = this->bulkHasher;
        result.fill = this->fill;
        result.step = this->step;
        result.sync = this->sync;
        result.bestSpeed = this->bestSpeed;
        result.chainHead = this->chainHead;
        result.hashHead = this->hashHead;
        result.hashPrev = this->hashPrev;
        result.hashOffset = this->hashOffset;
        result.index = this->index;
        result.window = this->window;
        result.windowEnd = this->windowEnd;
        result.blockStart = this->blockStart;
        result.byteAvailable = this->byteAvailable;
        result.tokens = this->tokens;
        result.length = this->length;
        result.offset = this->offset;
        result.maxInsertIndex = this->maxInsertIndex;
        result.err = this->err;
        result.hashMatch = this->hashMatch;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool compressor::operator==(const T& ref) const
    {
        if (compressionLevel != ref.compressionLevel) return false;
        if (w != ref.w) return false;
        if (bulkHasher != ref.bulkHasher) return false;
        if (fill != ref.fill) return false;
        if (step != ref.step) return false;
        if (sync != ref.sync) return false;
        if (bestSpeed != ref.bestSpeed) return false;
        if (chainHead != ref.chainHead) return false;
        if (hashHead != ref.hashHead) return false;
        if (hashPrev != ref.hashPrev) return false;
        if (hashOffset != ref.hashOffset) return false;
        if (index != ref.index) return false;
        if (window != ref.window) return false;
        if (windowEnd != ref.windowEnd) return false;
        if (blockStart != ref.blockStart) return false;
        if (byteAvailable != ref.byteAvailable) return false;
        if (tokens != ref.tokens) return false;
        if (length != ref.length) return false;
        if (offset != ref.offset) return false;
        if (maxInsertIndex != ref.maxInsertIndex) return false;
        if (err != ref.err) return false;
        if (hashMatch != ref.hashMatch) return false;
        return true;
    }

    std::ostream& compressor::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << compressionLevel;
        os << " " << w;
        os << " " << bulkHasher;
        os << " " << fill;
        os << " " << step;
        os << " " << sync;
        os << " " << bestSpeed;
        os << " " << chainHead;
        os << " " << hashHead;
        os << " " << hashPrev;
        os << " " << hashOffset;
        os << " " << index;
        os << " " << window;
        os << " " << windowEnd;
        os << " " << blockStart;
        os << " " << byteAvailable;
        os << " " << tokens;
        os << " " << length;
        os << " " << offset;
        os << " " << maxInsertIndex;
        os << " " << err;
        os << " " << hashMatch;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct compressor& value)
    {
        return value.PrintTo(os);
    }

    int rec::fillDeflate(golang::flate::compressor* d, gocpp::slice<unsigned char> b)
    {
        if(d->index >= 2 * windowSize - (minMatchLength + maxMatchLength))
        {
            copy(d->window, d->window.make_slice(windowSize, 2 * windowSize));
            d->index -= windowSize;
            d->windowEnd -= windowSize;
            if(d->blockStart >= windowSize)
            {
                d->blockStart -= windowSize;
            }
            else
            {
                d->blockStart = math::MaxInt32;
            }
            d->hashOffset += windowSize;
            if(d->hashOffset > maxHashOffset)
            {
                auto delta = d->hashOffset - 1;
                d->hashOffset -= delta;
                d->chainHead -= delta;
                for(auto [i, v] : d->hashPrev.make_slice(0))
                {
                    if(int(v) > delta)
                    {
                        d->hashPrev[i] = uint32_t(int(v) - delta);
                    }
                    else
                    {
                        d->hashPrev[i] = 0;
                    }
                }
                for(auto [i, v] : d->hashHead.make_slice(0))
                {
                    if(int(v) > delta)
                    {
                        d->hashHead[i] = uint32_t(int(v) - delta);
                    }
                    else
                    {
                        d->hashHead[i] = 0;
                    }
                }
            }
        }
        auto n = copy(d->window.make_slice(d->windowEnd), b);
        d->windowEnd += n;
        return n;
    }

    struct gocpp::error rec::writeBlock(golang::flate::compressor* d, gocpp::slice<golang::flate::token> tokens, int index)
    {
        if(index > 0)
        {
            gocpp::slice<unsigned char> window = {};
            if(d->blockStart <= index)
            {
                window = d->window.make_slice(d->blockStart, index);
            }
            d->blockStart = index;
            rec::writeBlock(gocpp::recv(d->w), tokens, false, window);
            return d->w->err;
        }
        return nullptr;
    }

    // fillWindow will fill the current window with the supplied
    // dictionary and calculate all hashes.
    // This is much faster than doing a full encode.
    // Should only be used after a reset.
    void rec::fillWindow(golang::flate::compressor* d, gocpp::slice<unsigned char> b)
    {
        if(d->compressionLevel.level < 2)
        {
            return;
        }
        if(d->index != 0 || d->windowEnd != 0)
        {
            gocpp::panic("internal error: fillWindow called with stale data"_s);
        }
        if(len(b) > windowSize)
        {
            b = b.make_slice(len(b) - windowSize);
        }
        auto n = copy(d->window, b);
        auto loops = (n + 256 - minMatchLength) / 256;
        for(auto j = 0; j < loops; j++)
        {
            auto index = j * 256;
            auto end = index + 256 + minMatchLength - 1;
            if(end > n)
            {
                end = n;
            }
            auto toCheck = d->window.make_slice(index, end);
            auto dstSize = len(toCheck) - minMatchLength + 1;
            if(dstSize <= 0)
            {
                continue;
            }
            auto dst = d->hashMatch.make_slice(0, dstSize);
            d->bulkHasher(toCheck, dst);
            for(auto [i, val] : dst)
            {
                auto di = i + index;
                auto hh = & d->hashHead[val & hashMask];
                d->hashPrev[di & windowMask] = *hh;
                *hh = uint32_t(di + d->hashOffset);
            }
        }
        d->windowEnd = n;
        d->index = n;
    }

    // Try to find a match starting at index whose length is greater than prevSize.
    // We only look at chainCount possibilities before giving up.
    std::tuple<int, int, bool> rec::findMatch(golang::flate::compressor* d, int pos, int prevHead, int prevLength, int lookahead)
    {
        int length;
        int offset;
        bool ok;
        auto minMatchLook = maxMatchLength;
        if(lookahead < minMatchLook)
        {
            minMatchLook = lookahead;
        }
        auto win = d->window.make_slice(0, pos + minMatchLook);
        auto nice = len(win) - pos;
        if(d->nice < nice)
        {
            nice = d->nice;
        }
        auto tries = d->chain;
        length = prevLength;
        if(length >= d->good)
        {
            tries >>= 2;
        }
        auto wEnd = win[pos + length];
        auto wPos = win.make_slice(pos);
        auto minIndex = pos - windowSize;
        for(auto i = prevHead; tries > 0; tries--)
        {
            if(wEnd == win[i + length])
            {
                auto n = matchLen(win.make_slice(i), wPos, minMatchLook);
                if(n > length && (n > minMatchLength || pos - i <= 4096))
                {
                    length = n;
                    offset = pos - i;
                    ok = true;
                    if(n >= nice)
                    {
                        break;
                    }
                    wEnd = win[pos + n];
                }
            }
            if(i == minIndex)
            {
                break;
            }
            i = int(d->hashPrev[i & windowMask]) - d->hashOffset;
            if(i < minIndex || i < 0)
            {
                break;
            }
        }
        return {length, offset, ok};
    }

    struct gocpp::error rec::writeStoredBlock(golang::flate::compressor* d, gocpp::slice<unsigned char> buf)
    {
        if(rec::writeStoredHeader(gocpp::recv(d->w), len(buf), false); d->w->err != nullptr)
        {
            return d->w->err;
        }
        rec::writeBytes(gocpp::recv(d->w), buf);
        return d->w->err;
    }

    // hash4 returns a hash representation of the first 4 bytes
    // of the supplied slice.
    // The caller must ensure that len(b) >= 4.
    uint32_t hash4(gocpp::slice<unsigned char> b)
    {
        return ((uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24)) * hashmul) >> (32 - hashBits);
    }

    // bulkHash4 will compute hashes using the same
    // algorithm as hash4.
    void bulkHash4(gocpp::slice<unsigned char> b, gocpp::slice<uint32_t> dst)
    {
        if(len(b) < minMatchLength)
        {
            return;
        }
        auto hb = uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
        dst[0] = (hb * hashmul) >> (32 - hashBits);
        auto end = len(b) - minMatchLength + 1;
        for(auto i = 1; i < end; i++)
        {
            hb = (hb << 8) | uint32_t(b[i + 3]);
            dst[i] = (hb * hashmul) >> (32 - hashBits);
        }
    }

    // matchLen returns the number of matching bytes in a and b
    // up to length 'max'. Both slices must be at least 'max'
    // bytes in size.
    int matchLen(gocpp::slice<unsigned char> a, gocpp::slice<unsigned char> b, int max)
    {
        a = a.make_slice(0, max);
        b = b.make_slice(0, len(a));
        for(auto [i, av] : a)
        {
            if(b[i] != av)
            {
                return i;
            }
        }
        return max;
    }

    // encSpeed will compress and store the currently added data,
    // if enough has been accumulated or we at the end of the stream.
    // Any error that occurred will be in d.err
    void rec::encSpeed(golang::flate::compressor* d)
    {
        if(d->windowEnd < maxStoreBlockSize)
        {
            if(! d->sync)
            {
                return;
            }
            if(d->windowEnd < 128)
            {
                //Go switch emulation
                {
                    int conditionId = -1;
                    if(d->windowEnd == 0) { conditionId = 0; }
                    else if(d->windowEnd <= 16) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                            return;
                            break;
                        case 1:
                            d->err = rec::writeStoredBlock(gocpp::recv(d), d->window.make_slice(0, d->windowEnd));
                            break;
                        default:
                            rec::writeBlockHuff(gocpp::recv(d->w), false, d->window.make_slice(0, d->windowEnd));
                            d->err = d->w->err;
                            break;
                    }
                }
                d->windowEnd = 0;
                rec::reset(gocpp::recv(d->bestSpeed));
                return;
            }
        }
        d->tokens = rec::encode(gocpp::recv(d->bestSpeed), d->tokens.make_slice(0, 0), d->window.make_slice(0, d->windowEnd));
        if(len(d->tokens) > d->windowEnd - (d->windowEnd >> 4))
        {
            rec::writeBlockHuff(gocpp::recv(d->w), false, d->window.make_slice(0, d->windowEnd));
        }
        else
        {
            rec::writeBlockDynamic(gocpp::recv(d->w), d->tokens, false, d->window.make_slice(0, d->windowEnd));
        }
        d->err = d->w->err;
        d->windowEnd = 0;
    }

    void rec::initDeflate(golang::flate::compressor* d)
    {
        d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 2 * windowSize);
        d->hashOffset = 1;
        d->tokens = gocpp::make(gocpp::Tag<gocpp::slice<flate::token>>(), 0, maxFlateBlockTokens + 1);
        d->length = minMatchLength - 1;
        d->offset = 0;
        d->byteAvailable = false;
        d->index = 0;
        d->chainHead = - 1;
        d->bulkHasher = bulkHash4;
    }

    void rec::deflate(golang::flate::compressor* d)
    {
        if(d->windowEnd - d->index < minMatchLength + maxMatchLength && ! d->sync)
        {
            return;
        }
        d->maxInsertIndex = d->windowEnd - (minMatchLength - 1);
        Loop:
        for(; ; )
        {
            if(d->index > d->windowEnd)
            {
                gocpp::panic("index > windowEnd"_s);
            }
            auto lookahead = d->windowEnd - d->index;
            if(lookahead < minMatchLength + maxMatchLength)
            {
                if(! d->sync)
                {
                    goto Loop_break;
                }
                if(d->index > d->windowEnd)
                {
                    gocpp::panic("index > windowEnd"_s);
                }
                if(lookahead == 0)
                {
                    if(d->byteAvailable)
                    {
                        d->tokens = append(d->tokens, literalToken(uint32_t(d->window[d->index - 1])));
                        d->byteAvailable = false;
                    }
                    if(len(d->tokens) > 0)
                    {
                        if(d->err = rec::writeBlock(gocpp::recv(d), d->tokens, d->index); d->err != nullptr)
                        {
                            return;
                        }
                        d->tokens = d->tokens.make_slice(0, 0);
                    }
                    goto Loop_break;
                }
            }
            if(d->index < d->maxInsertIndex)
            {
                auto hash = hash4(d->window.make_slice(d->index, d->index + minMatchLength));
                auto hh = & d->hashHead[hash & hashMask];
                d->chainHead = int(*hh);
                d->hashPrev[d->index & windowMask] = uint32_t(d->chainHead);
                *hh = uint32_t(d->index + d->hashOffset);
            }
            auto prevLength = d->length;
            auto prevOffset = d->offset;
            d->length = minMatchLength - 1;
            d->offset = 0;
            auto minIndex = d->index - windowSize;
            if(minIndex < 0)
            {
                minIndex = 0;
            }
            if(d->chainHead - d->hashOffset >= minIndex && (d->fastSkipHashing != skipNever && lookahead > minMatchLength - 1 || d->fastSkipHashing == skipNever && lookahead > prevLength && prevLength < d->lazy))
            {
                if(auto [newLength, newOffset, ok] = rec::findMatch(gocpp::recv(d), d->index, d->chainHead - d->hashOffset, minMatchLength - 1, lookahead); ok)
                {
                    d->length = newLength;
                    d->offset = newOffset;
                }
            }
            if(d->fastSkipHashing != skipNever && d->length >= minMatchLength || d->fastSkipHashing == skipNever && prevLength >= minMatchLength && d->length <= prevLength)
            {
                if(d->fastSkipHashing != skipNever)
                {
                    d->tokens = append(d->tokens, matchToken(uint32_t(d->length - baseMatchLength), uint32_t(d->offset - baseMatchOffset)));
                }
                else
                {
                    d->tokens = append(d->tokens, matchToken(uint32_t(prevLength - baseMatchLength), uint32_t(prevOffset - baseMatchOffset)));
                }
                if(d->length <= d->fastSkipHashing)
                {
                    int newIndex = {};
                    if(d->fastSkipHashing != skipNever)
                    {
                        newIndex = d->index + d->length;
                    }
                    else
                    {
                        newIndex = d->index + prevLength - 1;
                    }
                    auto index = d->index;
                    for(index++; index < newIndex; index++)
                    {
                        if(index < d->maxInsertIndex)
                        {
                            auto hash = hash4(d->window.make_slice(index, index + minMatchLength));
                            auto hh = & d->hashHead[hash & hashMask];
                            d->hashPrev[index & windowMask] = *hh;
                            *hh = uint32_t(index + d->hashOffset);
                        }
                    }
                    d->index = index;
                    if(d->fastSkipHashing == skipNever)
                    {
                        d->byteAvailable = false;
                        d->length = minMatchLength - 1;
                    }
                }
                else
                {
                    d->index += d->length;
                }
                if(len(d->tokens) == maxFlateBlockTokens)
                {
                    if(d->err = rec::writeBlock(gocpp::recv(d), d->tokens, d->index); d->err != nullptr)
                    {
                        return;
                    }
                    d->tokens = d->tokens.make_slice(0, 0);
                }
            }
            else
            {
                if(d->fastSkipHashing != skipNever || d->byteAvailable)
                {
                    auto i = d->index - 1;
                    if(d->fastSkipHashing != skipNever)
                    {
                        i = d->index;
                    }
                    d->tokens = append(d->tokens, literalToken(uint32_t(d->window[i])));
                    if(len(d->tokens) == maxFlateBlockTokens)
                    {
                        if(d->err = rec::writeBlock(gocpp::recv(d), d->tokens, i + 1); d->err != nullptr)
                        {
                            return;
                        }
                        d->tokens = d->tokens.make_slice(0, 0);
                    }
                }
                d->index++;
                if(d->fastSkipHashing == skipNever)
                {
                    d->byteAvailable = true;
                }
            }
            if(false) {
            Loop_continue:
                continue;
            Loop_break:
                break;
            }
        }
    }

    int rec::fillStore(golang::flate::compressor* d, gocpp::slice<unsigned char> b)
    {
        auto n = copy(d->window.make_slice(d->windowEnd), b);
        d->windowEnd += n;
        return n;
    }

    void rec::store(golang::flate::compressor* d)
    {
        if(d->windowEnd > 0 && (d->windowEnd == maxStoreBlockSize || d->sync))
        {
            d->err = rec::writeStoredBlock(gocpp::recv(d), d->window.make_slice(0, d->windowEnd));
            d->windowEnd = 0;
        }
    }

    // storeHuff compresses and stores the currently added data
    // when the d.window is full or we are at the end of the stream.
    // Any error that occurred will be in d.err
    void rec::storeHuff(golang::flate::compressor* d)
    {
        if(d->windowEnd < len(d->window) && ! d->sync || d->windowEnd == 0)
        {
            return;
        }
        rec::writeBlockHuff(gocpp::recv(d->w), false, d->window.make_slice(0, d->windowEnd));
        d->err = d->w->err;
        d->windowEnd = 0;
    }

    std::tuple<int, struct gocpp::error> rec::write(golang::flate::compressor* d, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        if(d->err != nullptr)
        {
            return {0, d->err};
        }
        n = len(b);
        for(; len(b) > 0; )
        {
            d->step(d);
            b = b.make_slice(d->fill(d, b));
            if(d->err != nullptr)
            {
                return {0, d->err};
            }
        }
        return {n, nullptr};
    }

    struct gocpp::error rec::syncFlush(golang::flate::compressor* d)
    {
        if(d->err != nullptr)
        {
            return d->err;
        }
        d->sync = true;
        d->step(d);
        if(d->err == nullptr)
        {
            rec::writeStoredHeader(gocpp::recv(d->w), 0, false);
            rec::flush(gocpp::recv(d->w));
            d->err = d->w->err;
        }
        d->sync = false;
        return d->err;
    }

    struct gocpp::error rec::init(golang::flate::compressor* d, io::Writer w, int level)
    {
        struct gocpp::error err;
        d->w = newHuffmanBitWriter(w);
        //Go switch emulation
        {
            int conditionId = -1;
            if(level == NoCompression) { conditionId = 0; }
            else if(level == HuffmanOnly) { conditionId = 1; }
            else if(level == BestSpeed) { conditionId = 2; }
            else if(level == DefaultCompression) { conditionId = 3; }
            else if(2 <= level && level <= 9) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), maxStoreBlockSize);
                    d->fill = [&](auto x, auto y){ return rec::fillStore(x, y); };
                    d->step = [&](auto x){ return rec::store(x); };
                    break;
                case 1:
                    d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), maxStoreBlockSize);
                    d->fill = [&](auto x, auto y){ return rec::fillStore(x, y); };
                    d->step = [&](auto x){ return rec::storeHuff(x); };
                    break;
                case 2:
                    d->compressionLevel = levels[level];
                    d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), maxStoreBlockSize);
                    d->fill = [&](auto x, auto y){ return rec::fillStore(x, y); };
                    d->step = [&](auto x){ return rec::encSpeed(x); };
                    d->bestSpeed = newDeflateFast();
                    d->tokens = gocpp::make(gocpp::Tag<gocpp::slice<flate::token>>(), maxStoreBlockSize);
                    break;
                case 3:
                    level = 6;
                case 4:
                    d->compressionLevel = levels[level];
                    rec::initDeflate(gocpp::recv(d));
                    d->fill = [&](auto x, auto y){ return rec::fillDeflate(x, y); };
                    d->step = [&](auto x){ return rec::deflate(x); };
                    break;
                default:
                    return mocklib::Errorf("flate: invalid compression level %d: want value in range [-2, 9]"_s, level);
                    break;
            }
        }
        return nullptr;
    }

    void rec::reset(golang::flate::compressor* d, io::Writer w)
    {
        rec::reset(gocpp::recv(d->w), w);
        d->sync = false;
        d->err = nullptr;
        //Go switch emulation
        {
            auto condition = d->compressionLevel.level;
            int conditionId = -1;
            if(condition == NoCompression) { conditionId = 0; }
            else if(condition == BestSpeed) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    d->windowEnd = 0;
                    break;
                case 1:
                    d->windowEnd = 0;
                    d->tokens = d->tokens.make_slice(0, 0);
                    rec::reset(gocpp::recv(d->bestSpeed));
                    break;
                default:
                    d->chainHead = - 1;
                    for(auto [i, gocpp_ignored] : d->hashHead)
                    {
                        d->hashHead[i] = 0;
                    }
                    for(auto [i, gocpp_ignored] : d->hashPrev)
                    {
                        d->hashPrev[i] = 0;
                    }
                    d->hashOffset = 1;
                    std::tie(d->index, d->windowEnd) = std::tuple{0, 0};
                    std::tie(d->blockStart, d->byteAvailable) = std::tuple{0, false};
                    d->tokens = d->tokens.make_slice(0, 0);
                    d->length = minMatchLength - 1;
                    d->offset = 0;
                    d->maxInsertIndex = 0;
                    break;
            }
        }
    }

    struct gocpp::error rec::close(golang::flate::compressor* d)
    {
        if(d->err == errWriterClosed)
        {
            return nullptr;
        }
        if(d->err != nullptr)
        {
            return d->err;
        }
        d->sync = true;
        d->step(d);
        if(d->err != nullptr)
        {
            return d->err;
        }
        if(rec::writeStoredHeader(gocpp::recv(d->w), 0, true); d->w->err != nullptr)
        {
            return d->w->err;
        }
        rec::flush(gocpp::recv(d->w));
        if(d->w->err != nullptr)
        {
            return d->w->err;
        }
        d->err = errWriterClosed;
        return nullptr;
    }

    // NewWriter returns a new [Writer] compressing data at the given level.
    // Following zlib, levels range from 1 ([BestSpeed]) to 9 ([BestCompression]);
    // higher levels typically run slower but compress more. Level 0
    // ([NoCompression]) does not attempt any compression; it only adds the
    // necessary DEFLATE framing.
    // Level -1 ([DefaultCompression]) uses the default compression level.
    // Level -2 ([HuffmanOnly]) will use Huffman compression only, giving
    // a very fast compression for all types of input, but sacrificing considerable
    // compression efficiency.
    //
    // If level is in the range [-2, 9] then the error returned will be nil.
    // Otherwise the error returned will be non-nil.
    std::tuple<struct Writer*, struct gocpp::error> NewWriter(io::Writer w, int level)
    {
        Writer dw = {};
        if(auto err = rec::init(gocpp::recv(dw.d), w, level); err != nullptr)
        {
            return {nullptr, err};
        }
        return {& dw, nullptr};
    }

    // NewWriterDict is like [NewWriter] but initializes the new
    // [Writer] with a preset dictionary. The returned [Writer] behaves
    // as if the dictionary had been written to it without producing
    // any compressed output. The compressed data written to w
    // can only be decompressed by a [Reader] initialized with the
    // same dictionary.
    std::tuple<struct Writer*, struct gocpp::error> NewWriterDict(io::Writer w, int level, gocpp::slice<unsigned char> dict)
    {
        auto dw = new dictWriter {w};
        auto [zw, err] = NewWriter(dw, level);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        rec::fillWindow(gocpp::recv(zw->d), dict);
        zw->dict = append(zw->dict, dict);
        return {zw, err};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dictWriter::operator T()
    {
        T result;
        result.w = this->w;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dictWriter::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        return true;
    }

    std::ostream& dictWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dictWriter& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Write(golang::flate::dictWriter* w, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        return rec::Write(gocpp::recv(w->w), b);
    }

    gocpp::error errWriterClosed = errors::New("flate: closed writer"_s);
    // A Writer takes data written to it and writes the compressed
    // form of that data to an underlying writer (see [NewWriter]).
    
    template<typename T> requires gocpp::GoStruct<T>
    Writer::operator T()
    {
        T result;
        result.d = this->d;
        result.dict = this->dict;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Writer::operator==(const T& ref) const
    {
        if (d != ref.d) return false;
        if (dict != ref.dict) return false;
        return true;
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << d;
        os << " " << dict;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    // Write writes data to w, which will eventually write the
    // compressed form of data to its underlying writer.
    std::tuple<int, struct gocpp::error> rec::Write(golang::flate::Writer* w, gocpp::slice<unsigned char> data)
    {
        int n;
        struct gocpp::error err;
        return rec::write(gocpp::recv(w->d), data);
    }

    // Flush flushes any pending data to the underlying writer.
    // It is useful mainly in compressed network protocols, to ensure that
    // a remote reader has enough data to reconstruct a packet.
    // Flush does not return until the data has been written.
    // Calling Flush when there is no pending data still causes the [Writer]
    // to emit a sync marker of at least 4 bytes.
    // If the underlying writer returns an error, Flush returns that error.
    //
    // In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.
    struct gocpp::error rec::Flush(golang::flate::Writer* w)
    {
        return rec::syncFlush(gocpp::recv(w->d));
    }

    // Close flushes and closes the writer.
    struct gocpp::error rec::Close(golang::flate::Writer* w)
    {
        return rec::close(gocpp::recv(w->d));
    }

    // Reset discards the writer's state and makes it equivalent to
    // the result of [NewWriter] or [NewWriterDict] called with dst
    // and w's level and dictionary.
    void rec::Reset(golang::flate::Writer* w, io::Writer dst)
    {
        if(auto [dw, ok] = gocpp::getValue<dictWriter*>(w->d.w->writer); ok)
        {
            dw->w = dst;
            rec::reset(gocpp::recv(w->d), dw);
            rec::fillWindow(gocpp::recv(w->d), w->dict);
        }
        else
        {
            rec::reset(gocpp::recv(w->d), dst);
        }
    }

}

