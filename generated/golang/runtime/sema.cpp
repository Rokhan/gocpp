// generated by GoCpp from file '$(ImportDir)/runtime/sema.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/sema.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu_x86.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/cputicks.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mprof.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace cpu::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    semaRoot::operator T()
    {
        T result;
        result.lock = this->lock;
        result.treap = this->treap;
        result.nwait = this->nwait;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool semaRoot::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (treap != ref.treap) return false;
        if (nwait != ref.nwait) return false;
        return true;
    }

    std::ostream& semaRoot::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << treap;
        os << " " << nwait;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct semaRoot& value)
    {
        return value.PrintTo(os);
    }

    semTable semtable;
    struct gocpp_id_0
    {
        semaRoot root;
        gocpp::array<unsigned char, cpu::CacheLinePadSize - gocpp::Sizeof<semaRoot>()> pad;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.root = this->root;
            result.pad = this->pad;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (root != ref.root) return false;
            if (pad != ref.pad) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << root;
            os << " " << pad;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    struct semaRoot* rec::rootFor(semTable* t, uint32_t* addr)
    {
        return & t[(uintptr_t(unsafe::Pointer(addr)) >> 3) % semTabSize].root;
    }

    void sync_runtime_Semacquire(uint32_t* addr)
    {
        semacquire1(addr, false, semaBlockProfile, 0, waitReasonSemacquire);
    }

    void poll_runtime_Semacquire(uint32_t* addr)
    {
        semacquire1(addr, false, semaBlockProfile, 0, waitReasonSemacquire);
    }

    void sync_runtime_Semrelease(uint32_t* addr, bool handoff, int skipframes)
    {
        semrelease1(addr, handoff, skipframes);
    }

    void sync_runtime_SemacquireMutex(uint32_t* addr, bool lifo, int skipframes)
    {
        semacquire1(addr, lifo, semaBlockProfile | semaMutexProfile, skipframes, waitReasonSyncMutexLock);
    }

    void sync_runtime_SemacquireRWMutexR(uint32_t* addr, bool lifo, int skipframes)
    {
        semacquire1(addr, lifo, semaBlockProfile | semaMutexProfile, skipframes, waitReasonSyncRWMutexRLock);
    }

    void sync_runtime_SemacquireRWMutex(uint32_t* addr, bool lifo, int skipframes)
    {
        semacquire1(addr, lifo, semaBlockProfile | semaMutexProfile, skipframes, waitReasonSyncRWMutexLock);
    }

    void poll_runtime_Semrelease(uint32_t* addr)
    {
        semrelease(addr);
    }

    void readyWithTime(struct sudog* s, int traceskip)
    {
        if(s->releasetime != 0)
        {
            s->releasetime = cputicks();
        }
        goready(s->g, traceskip);
    }

    void semacquire(uint32_t* addr)
    {
        semacquire1(addr, false, 0, 0, waitReasonSemacquire);
    }

    void semacquire1(uint32_t* addr, bool lifo, runtime::semaProfileFlags profile, int skipframes, runtime::waitReason reason)
    {
        auto gp = getg();
        if(gp != gp->m->curg)
        {
            go_throw("semacquire not on the G stack");
        }
        if(cansemacquire(addr))
        {
            return;
        }
        auto s = acquireSudog();
        auto root = rec::rootFor(gocpp::recv(semtable), addr);
        auto t0 = int64_t(0);
        s->releasetime = 0;
        s->acquiretime = 0;
        s->ticket = 0;
        if(profile & semaBlockProfile != 0 && blockprofilerate > 0)
        {
            t0 = cputicks();
            s->releasetime = - 1;
        }
        if(profile & semaMutexProfile != 0 && mutexprofilerate > 0)
        {
            if(t0 == 0)
            {
                t0 = cputicks();
            }
            s->acquiretime = t0;
        }
        for(; ; )
        {
            lockWithRank(& root->lock, lockRankRoot);
            rec::Add(gocpp::recv(root->nwait), 1);
            if(cansemacquire(addr))
            {
                rec::Add(gocpp::recv(root->nwait), - 1);
                unlock(& root->lock);
                break;
            }
            rec::queue(gocpp::recv(root), addr, s, lifo);
            goparkunlock(& root->lock, reason, traceBlockSync, 4 + skipframes);
            if(s->ticket != 0 || cansemacquire(addr))
            {
                break;
            }
        }
        if(s->releasetime > 0)
        {
            blockevent(s->releasetime - t0, 3 + skipframes);
        }
        releaseSudog(s);
    }

    void semrelease(uint32_t* addr)
    {
        semrelease1(addr, false, 0);
    }

    void semrelease1(uint32_t* addr, bool handoff, int skipframes)
    {
        auto root = rec::rootFor(gocpp::recv(semtable), addr);
        atomic::Xadd(addr, 1);
        if(rec::Load(gocpp::recv(root->nwait)) == 0)
        {
            return;
        }
        lockWithRank(& root->lock, lockRankRoot);
        if(rec::Load(gocpp::recv(root->nwait)) == 0)
        {
            unlock(& root->lock);
            return;
        }
        auto [s, t0, tailtime] = rec::dequeue(gocpp::recv(root), addr);
        if(s != nullptr)
        {
            rec::Add(gocpp::recv(root->nwait), - 1);
        }
        unlock(& root->lock);
        if(s != nullptr)
        {
            auto acquiretime = s->acquiretime;
            if(acquiretime != 0)
            {
                auto dt0 = t0 - acquiretime;
                auto dt = dt0;
                if(s->waiters != 0)
                {
                    auto dtail = t0 - tailtime;
                    dt += (dtail + dt0) / 2 * int64_t(s->waiters);
                }
                mutexevent(dt, 3 + skipframes);
            }
            if(s->ticket != 0)
            {
                go_throw("corrupted semaphore ticket");
            }
            if(handoff && cansemacquire(addr))
            {
                s->ticket = 1;
            }
            readyWithTime(s, 5 + skipframes);
            if(s->ticket == 1 && getg()->m->locks == 0)
            {
                goyield();
            }
        }
    }

    bool cansemacquire(uint32_t* addr)
    {
        for(; ; )
        {
            auto v = atomic::Load(addr);
            if(v == 0)
            {
                return false;
            }
            if(atomic::Cas(addr, v, v - 1))
            {
                return true;
            }
        }
    }

    void rec::queue(struct semaRoot* root, uint32_t* addr, struct sudog* s, bool lifo)
    {
        s->g = getg();
        s->elem = unsafe::Pointer(addr);
        s->next = nullptr;
        s->prev = nullptr;
        s->waiters = 0;
        sudog* last = {};
        auto pt = & root->treap;
        for(auto t = *pt; t != nullptr; t = *pt)
        {
            if(t->elem == unsafe::Pointer(addr))
            {
                if(lifo)
                {
                    *pt = s;
                    s->ticket = t->ticket;
                    s->acquiretime = t->acquiretime;
                    s->parent = t->parent;
                    s->prev = t->prev;
                    s->next = t->next;
                    if(s->prev != nullptr)
                    {
                        s->prev->parent = s;
                    }
                    if(s->next != nullptr)
                    {
                        s->next->parent = s;
                    }
                    s->waitlink = t;
                    s->waittail = t->waittail;
                    if(s->waittail == nullptr)
                    {
                        s->waittail = t;
                    }
                    s->waiters = t->waiters;
                    if(s->waiters + 1 != 0)
                    {
                        s->waiters++;
                    }
                    t->parent = nullptr;
                    t->prev = nullptr;
                    t->next = nullptr;
                    t->waittail = nullptr;
                }
                else
                {
                    if(t->waittail == nullptr)
                    {
                        t->waitlink = s;
                    }
                    else
                    {
                        t->waittail->waitlink = s;
                    }
                    t->waittail = s;
                    s->waitlink = nullptr;
                    if(t->waiters + 1 != 0)
                    {
                        t->waiters++;
                    }
                }
                return;
            }
            last = t;
            if(uintptr_t(unsafe::Pointer(addr)) < uintptr_t(t->elem))
            {
                pt = & t->prev;
            }
            else
            {
                pt = & t->next;
            }
        }
        s->ticket = cheaprand() | 1;
        s->parent = last;
        *pt = s;
        for(; s->parent != nullptr && s->parent->ticket > s->ticket; )
        {
            if(s->parent->prev == s)
            {
                rec::rotateRight(gocpp::recv(root), s->parent);
            }
            else
            {
                if(s->parent->next != s)
                {
                    gocpp::panic("semaRoot queue");
                }
                rec::rotateLeft(gocpp::recv(root), s->parent);
            }
        }
    }

    std::tuple<struct sudog*, int64_t, int64_t> rec::dequeue(struct semaRoot* root, uint32_t* addr)
    {
        struct sudog* found;
        int64_t now;
        int64_t tailtime;
        auto ps = & root->treap;
        auto s = *ps;
        for(; s != nullptr; s = *ps)
        {
            struct sudog* found;
            int64_t now;
            int64_t tailtime;
            if(s->elem == unsafe::Pointer(addr))
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                goto Found;
            }
            if(uintptr_t(unsafe::Pointer(addr)) < uintptr_t(s->elem))
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                ps = & s->prev;
            }
            else
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                ps = & s->next;
            }
        }
        return {nullptr, 0, 0};
        Found:
        now = int64_t(0);
        if(s->acquiretime != 0)
        {
            struct sudog* found;
            int64_t now;
            int64_t tailtime;
            now = cputicks();
        }
        if(auto t = s->waitlink; t != nullptr)
        {
            struct sudog* found;
            int64_t now;
            int64_t tailtime;
            *ps = t;
            t->ticket = s->ticket;
            t->parent = s->parent;
            t->prev = s->prev;
            if(t->prev != nullptr)
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                t->prev->parent = t;
            }
            t->next = s->next;
            if(t->next != nullptr)
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                t->next->parent = t;
            }
            if(t->waitlink != nullptr)
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                t->waittail = s->waittail;
            }
            else
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                t->waittail = nullptr;
            }
            t->waiters = s->waiters;
            if(t->waiters > 1)
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                t->waiters--;
            }
            t->acquiretime = now;
            tailtime = s->waittail->acquiretime;
            s->waittail->acquiretime = now;
            s->waitlink = nullptr;
            s->waittail = nullptr;
        }
        else
        {
            struct sudog* found;
            int64_t now;
            int64_t tailtime;
            for(; s->next != nullptr || s->prev != nullptr; )
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                if(s->next == nullptr || s->prev != nullptr && s->prev->ticket < s->next->ticket)
                {
                    struct sudog* found;
                    int64_t now;
                    int64_t tailtime;
                    rec::rotateRight(gocpp::recv(root), s);
                }
                else
                {
                    struct sudog* found;
                    int64_t now;
                    int64_t tailtime;
                    rec::rotateLeft(gocpp::recv(root), s);
                }
            }
            if(s->parent != nullptr)
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                if(s->parent->prev == s)
                {
                    struct sudog* found;
                    int64_t now;
                    int64_t tailtime;
                    s->parent->prev = nullptr;
                }
                else
                {
                    struct sudog* found;
                    int64_t now;
                    int64_t tailtime;
                    s->parent->next = nullptr;
                }
            }
            else
            {
                struct sudog* found;
                int64_t now;
                int64_t tailtime;
                root->treap = nullptr;
            }
            tailtime = s->acquiretime;
        }
        s->parent = nullptr;
        s->elem = nullptr;
        s->next = nullptr;
        s->prev = nullptr;
        s->ticket = 0;
        return {s, now, tailtime};
    }

    void rec::rotateLeft(struct semaRoot* root, struct sudog* x)
    {
        auto p = x->parent;
        auto y = x->next;
        auto b = y->prev;
        y->prev = x;
        x->parent = y;
        x->next = b;
        if(b != nullptr)
        {
            b->parent = x;
        }
        y->parent = p;
        if(p == nullptr)
        {
            root->treap = y;
        }
        else
        if(p->prev == x)
        {
            p->prev = y;
        }
        else
        {
            if(p->next != x)
            {
                go_throw("semaRoot rotateLeft");
            }
            p->next = y;
        }
    }

    void rec::rotateRight(struct semaRoot* root, struct sudog* y)
    {
        auto p = y->parent;
        auto x = y->prev;
        auto b = x->next;
        x->next = y;
        y->parent = x;
        y->prev = b;
        if(b != nullptr)
        {
            b->parent = y;
        }
        x->parent = p;
        if(p == nullptr)
        {
            root->treap = x;
        }
        else
        if(p->prev == y)
        {
            p->prev = x;
        }
        else
        {
            if(p->next != y)
            {
                go_throw("semaRoot rotateRight");
            }
            p->next = x;
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    notifyList::operator T()
    {
        T result;
        result.wait = this->wait;
        result.notify = this->notify;
        result.lock = this->lock;
        result.head = this->head;
        result.tail = this->tail;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool notifyList::operator==(const T& ref) const
    {
        if (wait != ref.wait) return false;
        if (notify != ref.notify) return false;
        if (lock != ref.lock) return false;
        if (head != ref.head) return false;
        if (tail != ref.tail) return false;
        return true;
    }

    std::ostream& notifyList::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wait;
        os << " " << notify;
        os << " " << lock;
        os << " " << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct notifyList& value)
    {
        return value.PrintTo(os);
    }

    bool less(uint32_t a, uint32_t b)
    {
        return int32_t(a - b) < 0;
    }

    uint32_t notifyListAdd(struct notifyList* l)
    {
        return rec::Add(gocpp::recv(l->wait), 1) - 1;
    }

    void notifyListWait(struct notifyList* l, uint32_t t)
    {
        lockWithRank(& l->lock, lockRankNotifyList);
        if(less(t, l->notify))
        {
            unlock(& l->lock);
            return;
        }
        auto s = acquireSudog();
        s->g = getg();
        s->ticket = t;
        s->releasetime = 0;
        auto t0 = int64_t(0);
        if(blockprofilerate > 0)
        {
            t0 = cputicks();
            s->releasetime = - 1;
        }
        if(l->tail == nullptr)
        {
            l->head = s;
        }
        else
        {
            l->tail->next = s;
        }
        l->tail = s;
        goparkunlock(& l->lock, waitReasonSyncCondWait, traceBlockCondWait, 3);
        if(t0 != 0)
        {
            blockevent(s->releasetime - t0, 2);
        }
        releaseSudog(s);
    }

    void notifyListNotifyAll(struct notifyList* l)
    {
        if(rec::Load(gocpp::recv(l->wait)) == atomic::Load(& l->notify))
        {
            return;
        }
        lockWithRank(& l->lock, lockRankNotifyList);
        auto s = l->head;
        l->head = nullptr;
        l->tail = nullptr;
        atomic::Store(& l->notify, rec::Load(gocpp::recv(l->wait)));
        unlock(& l->lock);
        for(; s != nullptr; )
        {
            auto next = s->next;
            s->next = nullptr;
            readyWithTime(s, 4);
            s = next;
        }
    }

    void notifyListNotifyOne(struct notifyList* l)
    {
        if(rec::Load(gocpp::recv(l->wait)) == atomic::Load(& l->notify))
        {
            return;
        }
        lockWithRank(& l->lock, lockRankNotifyList);
        auto t = l->notify;
        if(t == rec::Load(gocpp::recv(l->wait)))
        {
            unlock(& l->lock);
            return;
        }
        atomic::Store(& l->notify, t + 1);
        for(auto [p, s] = std::tuple{(sudog*)(nullptr), l->head}; s != nullptr; std::tie(p, s) = std::tuple{s, s->next})
        {
            if(s->ticket == t)
            {
                auto n = s->next;
                if(p != nullptr)
                {
                    p->next = n;
                }
                else
                {
                    l->head = n;
                }
                if(n == nullptr)
                {
                    l->tail = p;
                }
                unlock(& l->lock);
                s->next = nullptr;
                readyWithTime(s, 4);
                return;
            }
        }
        unlock(& l->lock);
    }

    void notifyListCheck(uintptr_t sz)
    {
        if(sz != gocpp::Sizeof<notifyList>())
        {
            print("runtime: bad notifyList size - sync=", sz, " runtime=", gocpp::Sizeof<notifyList>(), "\n");
            go_throw("bad notifyList size");
        }
    }

    int64_t sync_nanotime()
    {
        return nanotime();
    }

}

