// generated by GoCpp from file '$(ImportDir)/internal/bisect/bisect.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/bisect/bisect.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/symtab.h"
#include "golang/sync/atomic/doc.h"
#include "golang/sync/mutex.h"
#include "golang/unsafe/unsafe.h"

// Package bisect can be used by compilers and other programs
// to serve as a target for the bisect debugging tool.
// See [golang.org/x/tools/cmd/bisect] for details about using the tool.
//
// To be a bisect target, allowing bisect to help determine which of a set of independent
// changes provokes a failure, a program needs to:
//
//  1. Define a way to accept a change pattern on its command line or in its environment.
//     The most common mechanism is a command-line flag.
//     The pattern can be passed to [New] to create a [Matcher], the compiled form of a pattern.
//
//  2. Assign each change a unique ID. One possibility is to use a sequence number,
//     but the most common mechanism is to hash some kind of identifying information
//     like the file and line number where the change might be applied.
//     [Hash] hashes its arguments to compute an ID.
//
//  3. Enable each change that the pattern says should be enabled.
//     The [Matcher.ShouldEnable] method answers this question for a given change ID.
//
//  4. Print a report identifying each change that the pattern says should be printed.
//     The [Matcher.ShouldPrint] method answers this question for a given change ID.
//     The report consists of one more lines on standard error or standard output
//     that contain a “match marker”. [Marker] returns the match marker for a given ID.
//     When bisect reports a change as causing the failure, it identifies the change
//     by printing the report lines with the match marker removed.
//
// # Example Usage
//
// A program starts by defining how it receives the pattern. In this example, we will assume a flag.
// The next step is to compile the pattern:
//
//	m, err := bisect.New(patternFlag)
//	if err != nil {
//		log.Fatal(err)
//	}
//
// Then, each time a potential change is considered, the program computes
// a change ID by hashing identifying information (source file and line, in this case)
// and then calls m.ShouldPrint and m.ShouldEnable to decide whether to
// print and enable the change, respectively. The two can return different values
// depending on whether bisect is trying to find a minimal set of changes to
// disable or to enable to provoke the failure.
//
// It is usually helpful to write a helper function that accepts the identifying information
// and then takes care of hashing, printing, and reporting whether the identified change
// should be enabled. For example, a helper for changes identified by a file and line number
// would be:
//
//	func ShouldEnable(file string, line int) {
//		h := bisect.Hash(file, line)
//		if m.ShouldPrint(h) {
//			fmt.Fprintf(os.Stderr, "%v %s:%d\n", bisect.Marker(h), file, line)
//		}
//		return m.ShouldEnable(h)
//	}
//
// Finally, note that New returns a nil Matcher when there is no pattern,
// meaning that the target is not running under bisect at all,
// so all changes should be enabled and none should be printed.
// In that common case, the computation of the hash can be avoided entirely
// by checking for m == nil first:
//
//	func ShouldEnable(file string, line int) bool {
//		if m == nil {
//			return true
//		}
//		h := bisect.Hash(file, line)
//		if m.ShouldPrint(h) {
//			fmt.Fprintf(os.Stderr, "%v %s:%d\n", bisect.Marker(h), file, line)
//		}
//		return m.ShouldEnable(h)
//	}
//
// When the identifying information is expensive to format, this code can call
// [Matcher.MarkerOnly] to find out whether short report lines containing only the
// marker are permitted for a given run. (Bisect permits such lines when it is
// still exploring the space of possible changes and will not be showing the
// output to the user.) If so, the client can choose to print only the marker:
//
//	func ShouldEnable(file string, line int) bool {
//		if m == nil {
//			return true
//		}
//		h := bisect.Hash(file, line)
//		if m.ShouldPrint(h) {
//			if m.MarkerOnly() {
//				bisect.PrintMarker(os.Stderr, h)
//			} else {
//				fmt.Fprintf(os.Stderr, "%v %s:%d\n", bisect.Marker(h), file, line)
//			}
//		}
//		return m.ShouldEnable(h)
//	}
//
// This specific helper – deciding whether to enable a change identified by
// file and line number and printing about the change when necessary – is
// provided by the [Matcher.FileLine] method.
//
// Another common usage is deciding whether to make a change in a function
// based on the caller's stack, to identify the specific calling contexts that the
// change breaks. The [Matcher.Stack] method takes care of obtaining the stack,
// printing it when necessary, and reporting whether to enable the change
// based on that stack.
//
// # Pattern Syntax
//
// Patterns are generated by the bisect tool and interpreted by [New].
// Users should not have to understand the patterns except when
// debugging a target's bisect support or debugging the bisect tool itself.
//
// The pattern syntax selecting a change is a sequence of bit strings
// separated by + and - operators. Each bit string denotes the set of
// changes with IDs ending in those bits, + is set addition, - is set subtraction,
// and the expression is evaluated in the usual left-to-right order.
// The special binary number “y” denotes the set of all changes,
// standing in for the empty bit string.
// In the expression, all the + operators must appear before all the - operators.
// A leading + adds to an empty set. A leading - subtracts from the set of all
// possible suffixes.
//
// For example:
//
//   - “01+10” and “+01+10” both denote the set of changes
//     with IDs ending with the bits 01 or 10.
//
//   - “01+10-1001” denotes the set of changes with IDs
//     ending with the bits 01 or 10, but excluding those ending in 1001.
//
//   - “-01-1000” and “y-01-1000 both denote the set of all changes
//     with IDs not ending in 01 nor 1000.
//
//   - “0+1-01+001” is not a valid pattern, because all the + operators do not
//     appear before all the - operators.
//
// In the syntaxes described so far, the pattern specifies the changes to
// enable and report. If a pattern is prefixed by a “!”, the meaning
// changes: the pattern specifies the changes to DISABLE and report. This
// mode of operation is needed when a program passes with all changes
// enabled but fails with no changes enabled. In this case, bisect
// searches for minimal sets of changes to disable.
// Put another way, the leading “!” inverts the result from [Matcher.ShouldEnable]
// but does not invert the result from [Matcher.ShouldPrint].
//
// As a convenience for manual debugging, “n” is an alias for “!y”,
// meaning to disable and report all changes.
//
// Finally, a leading “v” in the pattern indicates that the reports will be shown
// to the user of bisect to describe the changes involved in a failure.
// At the API level, the leading “v” causes [Matcher.Visible] to return true.
// See the next section for details.
//
// # Match Reports
//
// The target program must enable only those changed matched
// by the pattern, and it must print a match report for each such change.
// A match report consists of one or more lines of text that will be
// printed by the bisect tool to describe a change implicated in causing
// a failure. Each line in the report for a given change must contain a
// match marker with that change ID, as returned by [Marker].
// The markers are elided when displaying the lines to the user.
//
// A match marker has the form “[bisect-match 0x1234]” where
// 0x1234 is the change ID in hexadecimal.
// An alternate form is “[bisect-match 010101]”, giving the change ID in binary.
//
// When [Matcher.Visible] returns false, the match reports are only
// being processed by bisect to learn the set of enabled changes,
// not shown to the user, meaning that each report can be a match
// marker on a line by itself, eliding the usual textual description.
// When the textual description is expensive to compute,
// checking [Matcher.Visible] can help the avoid that expense
// in most runs.
namespace golang::bisect
{
    namespace rec
    {
        using namespace mocklib::rec;
        using mocklib::rec::Lock;
        using mocklib::rec::Unlock;
        using runtime::rec::Name;
        using runtime::rec::Next;
    }

    // New creates and returns a new Matcher implementing the given pattern.
    // The pattern syntax is defined in the package doc comment.
    //
    // In addition to the pattern syntax syntax, New("") returns nil, nil.
    // The nil *Matcher is valid for use: it returns true from ShouldEnable
    // and false from ShouldPrint for all changes. Callers can avoid calling
    // [Hash], [Matcher.ShouldEnable], and [Matcher.ShouldPrint] entirely
    // when they recognize the nil Matcher.
    std::tuple<struct Matcher*, struct gocpp::error> New(std::string pattern)
    {
        if(pattern == ""s)
        {
            return {nullptr, nullptr};
        }
        auto m = new(Matcher);
        auto p = pattern;
        if(len(p) > 0 && p[0] == 'q')
        {
            m->quiet = true;
            p = p.make_slice(1);
            if(p == ""s)
            {
                return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
            }
        }
        for(; len(p) > 0 && p[0] == 'v'; )
        {
            m->verbose = true;
            m->quiet = false;
            p = p.make_slice(1);
            if(p == ""s)
            {
                return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
            }
        }
        m->enable = true;
        for(; len(p) > 0 && p[0] == '!'; )
        {
            m->enable = ! m->enable;
            p = p.make_slice(1);
            if(p == ""s)
            {
                return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
            }
        }
        if(p == "n"s)
        {
            m->enable = ! m->enable;
            p = "y"s;
        }
        auto result = true;
        auto bits = uint64_t(0);
        auto start = 0;
        auto wid = 1;
        for(auto i = 0; i <= len(p); i++)
        {
            auto c = (unsigned char)('-');
            if(i < len(p))
            {
                c = p[i];
            }
            if(i == start && wid == 1 && c == 'x')
            {
                start = i + 1;
                wid = 4;
                continue;
            }
            //Go switch emulation
            {
                auto condition = c;
                int conditionId = -1;
                if(condition == '2') { conditionId = 0; }
                else if(condition == '3') { conditionId = 1; }
                else if(condition == '4') { conditionId = 2; }
                else if(condition == '5') { conditionId = 3; }
                else if(condition == '6') { conditionId = 4; }
                else if(condition == '7') { conditionId = 5; }
                else if(condition == '8') { conditionId = 6; }
                else if(condition == '9') { conditionId = 7; }
                else if(condition == '0') { conditionId = 8; }
                else if(condition == '1') { conditionId = 9; }
                else if(condition == 'a') { conditionId = 10; }
                else if(condition == 'b') { conditionId = 11; }
                else if(condition == 'c') { conditionId = 12; }
                else if(condition == 'd') { conditionId = 13; }
                else if(condition == 'e') { conditionId = 14; }
                else if(condition == 'f') { conditionId = 15; }
                else if(condition == 'A') { conditionId = 16; }
                else if(condition == 'B') { conditionId = 17; }
                else if(condition == 'C') { conditionId = 18; }
                else if(condition == 'D') { conditionId = 19; }
                else if(condition == 'E') { conditionId = 20; }
                else if(condition == 'F') { conditionId = 21; }
                else if(condition == 'y') { conditionId = 22; }
                else if(condition == '+') { conditionId = 23; }
                else if(condition == '-') { conditionId = 24; }
                switch(conditionId)
                {
                    default:
                        return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
                        break;
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        if(wid != 4)
                        {
                            return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
                        }
                    case 8:
                    case 9:
                        bits <<= wid;
                        bits |= uint64_t(c - '0');
                        break;
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                        if(wid != 4)
                        {
                            return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
                        }
                        bits <<= 4;
                        bits |= uint64_t(c &^ 0x20 - 'A' + 10);
                        break;
                    case 22:
                        if(i + 1 < len(p) && (p[i + 1] == '0' || p[i + 1] == '1'))
                        {
                            return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
                        }
                        bits = 0;
                        break;
                    case 23:
                    case 24:
                        if(c == '+' && result == false)
                        {
                            return {nullptr, new parseError {"invalid pattern syntax (+ after -): "s + pattern}};
                        }
                        if(i > 0)
                        {
                            auto n = (i - start) * wid;
                            if(n > 64)
                            {
                                return {nullptr, new parseError {"pattern bits too long: "s + pattern}};
                            }
                            if(n <= 0)
                            {
                                return {nullptr, new parseError {"invalid pattern syntax: "s + pattern}};
                            }
                            if(p[start] == 'y')
                            {
                                n = 0;
                            }
                            auto mask = (uint64_t(1) << n) - 1;
                            m->list = append(m->list, cond {mask, bits, result});
                        }
                        else
                        if(c == '-')
                        {
                            m->list = append(m->list, cond {0, 0, true});
                        }
                        bits = 0;
                        result = c == '+';
                        start = i + 1;
                        wid = 1;
                        break;
                }
            }
        }
        return {m, nullptr};
    }

    // A Matcher is the parsed, compiled form of a PATTERN string.
    // The nil *Matcher is valid: it has all changes enabled but none reported.
    
    template<typename T> requires gocpp::GoStruct<T>
    Matcher::operator T()
    {
        T result;
        result.verbose = this->verbose;
        result.quiet = this->quiet;
        result.enable = this->enable;
        result.list = this->list;
        result.dedup = this->dedup;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Matcher::operator==(const T& ref) const
    {
        if (verbose != ref.verbose) return false;
        if (quiet != ref.quiet) return false;
        if (enable != ref.enable) return false;
        if (list != ref.list) return false;
        if (dedup != ref.dedup) return false;
        return true;
    }

    std::ostream& Matcher::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << verbose;
        os << " " << quiet;
        os << " " << enable;
        os << " " << list;
        os << " " << dedup;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Matcher& value)
    {
        return value.PrintTo(os);
    }

    // atomicPointerDedup is an atomic.Pointer[dedup],
    // but we are avoiding using Go 1.19's atomic.Pointer
    // until the bootstrap toolchain can be relied upon to have it.
    
    template<typename T> requires gocpp::GoStruct<T>
    atomicPointerDedup::operator T()
    {
        T result;
        result.p = this->p;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicPointerDedup::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        return true;
    }

    std::ostream& atomicPointerDedup::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicPointerDedup& value)
    {
        return value.PrintTo(os);
    }

    struct dedup* rec::Load(struct atomicPointerDedup* p)
    {
        return (dedup*)(atomic::LoadPointer(& p->p));
    }

    bool rec::CompareAndSwap(struct atomicPointerDedup* p, struct dedup* old, struct dedup* go_new)
    {
        return atomic::CompareAndSwapPointer(& p->p, unsafe::Pointer(old), unsafe::Pointer(go_new));
    }

    // A cond is a single condition in the matcher.
    // Given an input id, if id&mask == bits, return the result.
    
    template<typename T> requires gocpp::GoStruct<T>
    cond::operator T()
    {
        T result;
        result.mask = this->mask;
        result.bits = this->bits;
        result.result = this->result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cond::operator==(const T& ref) const
    {
        if (mask != ref.mask) return false;
        if (bits != ref.bits) return false;
        if (result != ref.result) return false;
        return true;
    }

    std::ostream& cond::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mask;
        os << " " << bits;
        os << " " << result;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cond& value)
    {
        return value.PrintTo(os);
    }

    // MarkerOnly reports whether it is okay to print only the marker for
    // a given change, omitting the identifying information.
    // MarkerOnly returns true when bisect is using the printed reports
    // only for an intermediate search step, not for showing to users.
    bool rec::MarkerOnly(struct Matcher* m)
    {
        return ! m->verbose;
    }

    // ShouldEnable reports whether the change with the given id should be enabled.
    bool rec::ShouldEnable(struct Matcher* m, uint64_t id)
    {
        if(m == nullptr)
        {
            return true;
        }
        return rec::matchResult(gocpp::recv(m), id) == m->enable;
    }

    // ShouldPrint reports whether to print identifying information about the change with the given id.
    bool rec::ShouldPrint(struct Matcher* m, uint64_t id)
    {
        if(m == nullptr || m->quiet)
        {
            return false;
        }
        return rec::matchResult(gocpp::recv(m), id);
    }

    // matchResult returns the result from the first condition that matches id.
    bool rec::matchResult(struct Matcher* m, uint64_t id)
    {
        for(auto i = len(m->list) - 1; i >= 0; i--)
        {
            auto c = & m->list[i];
            if(id & c->mask == c->bits)
            {
                return c->result;
            }
        }
        return false;
    }

    // FileLine reports whether the change identified by file and line should be enabled.
    // If the change should be printed, FileLine prints a one-line report to w.
    bool rec::FileLine(struct Matcher* m, struct Writer w, std::string file, int line)
    {
        if(m == nullptr)
        {
            return true;
        }
        return rec::fileLine(gocpp::recv(m), w, file, line);
    }

    // fileLine does the real work for FileLine.
    // This lets FileLine's body handle m == nil and potentially be inlined.
    bool rec::fileLine(struct Matcher* m, struct Writer w, std::string file, int line)
    {
        auto h = Hash(file, line);
        if(rec::ShouldPrint(gocpp::recv(m), h))
        {
            if(rec::MarkerOnly(gocpp::recv(m)))
            {
                PrintMarker(w, h);
            }
            else
            {
                printFileLine(w, h, file, line);
            }
        }
        return rec::ShouldEnable(gocpp::recv(m), h);
    }

    // printFileLine prints a non-marker-only report for file:line to w.
    struct gocpp::error printFileLine(struct Writer w, uint64_t h, std::string file, int line)
    {
        auto markerLen = 40;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, markerLen + len(file) + 24);
        b = AppendMarker(b, h);
        b = appendFileLine(b, file, line);
        b = append(b, '\n');
        auto [gocpp_id_1, err] = rec::Write(gocpp::recv(w), b);
        return err;
    }

    // appendFileLine appends file:line to dst, returning the extended slice.
    gocpp::slice<unsigned char> appendFileLine(gocpp::slice<unsigned char> dst, std::string file, int line)
    {
        dst = append(dst, file);
        dst = append(dst, ':');
        auto u = (unsigned int)(line);
        if(line < 0)
        {
            dst = append(dst, '-');
            u = - u;
        }
        gocpp::array<unsigned char, 24> buf = {};
        auto i = len(buf);
        for(; i == len(buf) || u > 0; )
        {
            i--;
            buf[i] = '0' + (unsigned char)(u % 10);
            u /= 10;
        }
        dst = append(dst, buf.make_slice(i));
        return dst;
    }

    // MatchStack assigns the current call stack a change ID.
    // If the stack should be printed, MatchStack prints it.
    // Then MatchStack reports whether a change at the current call stack should be enabled.
    bool rec::Stack(struct Matcher* m, struct Writer w)
    {
        if(m == nullptr)
        {
            return true;
        }
        return rec::stack(gocpp::recv(m), w);
    }

    // stack does the real work for Stack.
    // This lets stack's body handle m == nil and potentially be inlined.
    bool rec::stack(struct Matcher* m, struct Writer w)
    {
        auto maxStack = 16;
        gocpp::array<uintptr_t, maxStack> stk = {};
        auto n = runtime::Callers(2, stk.make_slice(0));
        if(n <= 1)
        {
            return false;
        }
        auto base = stk[0];
        for(auto [i, gocpp_ignored] : stk.make_slice(0, n))
        {
            stk[i] -= base;
        }
        auto h = Hash(stk.make_slice(0, n));
        if(rec::ShouldPrint(gocpp::recv(m), h))
        {
            dedup* d = {};
            for(; ; )
            {
                d = rec::Load(gocpp::recv(m->dedup));
                if(d != nullptr)
                {
                    break;
                }
                d = new(dedup);
                if(rec::CompareAndSwap(gocpp::recv(m->dedup), nullptr, d))
                {
                    break;
                }
            }
            if(rec::MarkerOnly(gocpp::recv(m)))
            {
                if(! rec::seenLossy(gocpp::recv(d), h))
                {
                    PrintMarker(w, h);
                }
            }
            else
            {
                if(! rec::seen(gocpp::recv(d), h))
                {
                    for(auto [i, gocpp_ignored] : stk.make_slice(0, n))
                    {
                        stk[i] += base;
                    }
                    printStack(w, h, stk.make_slice(1, n));
                }
            }
        }
        return rec::ShouldEnable(gocpp::recv(m), h);
    }

    // Writer is the same interface as io.Writer.
    // It is duplicated here to avoid importing io.
    
    template<typename T>
    Writer::Writer(T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(const T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(T* ptr)
    {
        value.reset(new WriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> Writer::WriterImpl<T, StoreT>::vWrite(gocpp::slice<unsigned char>)
    {
        return rec::Write(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Write(const gocpp::PtrRecv<struct Writer, false>& self, gocpp::slice<unsigned char>)
        {
            return self.ptr->value->vWrite();
        }

        std::tuple<int, struct gocpp::error> Write(const gocpp::ObjRecv<struct Writer>& self, gocpp::slice<unsigned char>)
        {
            return self.obj.value->vWrite();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    // PrintMarker prints to w a one-line report containing only the marker for h.
    // It is appropriate to use when [Matcher.ShouldPrint] and [Matcher.MarkerOnly] both return true.
    struct gocpp::error PrintMarker(struct Writer w, uint64_t h)
    {
        gocpp::array<unsigned char, 50> buf = {};
        auto b = AppendMarker(buf.make_slice(0, 0), h);
        b = append(b, '\n');
        auto [gocpp_id_3, err] = rec::Write(gocpp::recv(w), b);
        return err;
    }

    // printStack prints to w a multi-line report containing a formatting of the call stack stk,
    // with each line preceded by the marker for h.
    struct gocpp::error printStack(struct Writer w, uint64_t h, gocpp::slice<uintptr_t> stk)
    {
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 2048);
        gocpp::array<unsigned char, 100> prefixBuf = {};
        auto prefix = AppendMarker(prefixBuf.make_slice(0, 0), h);
        auto frames = runtime::CallersFrames(stk);
        for(; ; )
        {
            auto [f, more] = rec::Next(gocpp::recv(frames));
            buf = append(buf, prefix);
            buf = append(buf, rec::Name(gocpp::recv(f.Func)));
            buf = append(buf, "()\n"s);
            buf = append(buf, prefix);
            buf = append(buf, '\t');
            buf = appendFileLine(buf, f.File, f.Line);
            buf = append(buf, '\n');
            if(! more)
            {
                break;
            }
        }
        buf = append(buf, prefix);
        buf = append(buf, '\n');
        auto [gocpp_id_5, err] = rec::Write(gocpp::recv(w), buf);
        return err;
    }

    // Marker returns the match marker text to use on any line reporting details
    // about a match of the given ID.
    // It always returns the hexadecimal format.
    std::string Marker(uint64_t id)
    {
        return std::string(AppendMarker(nullptr, id));
    }

    // AppendMarker is like [Marker] but appends the marker to dst.
    gocpp::slice<unsigned char> AppendMarker(gocpp::slice<unsigned char> dst, uint64_t id)
    {
        auto prefix = "[bisect-match 0x"s;
        gocpp::array<unsigned char, len(prefix) + 16 + 1> buf = {};
        copy(buf.make_slice(0), prefix);
        for(auto i = 0; i < 16; i++)
        {
            buf[len(prefix) + i] = "0123456789abcdef"s[id >> 60];
            id <<= 4;
        }
        buf[len(prefix) + 16] = ']';
        return append(dst, buf.make_slice(0));
    }

    // CutMarker finds the first match marker in line and removes it,
    // returning the shortened line (with the marker removed),
    // the ID from the match marker,
    // and whether a marker was found at all.
    // If there is no marker, CutMarker returns line, 0, false.
    std::tuple<std::string, uint64_t, bool> CutMarker(std::string line)
    {
        std::string short;
        uint64_t id;
        bool ok;
        auto prefix = "[bisect-match "s;
        auto i = 0;
        for(; ; i++)
        {
            if(i >= len(line) - len(prefix))
            {
                return {line, 0, false};
            }
            if(line[i] == '[' && line.make_slice(i, i + len(prefix)) == prefix)
            {
                break;
            }
        }
        auto j = i + len(prefix);
        for(; j < len(line) && line[j] != ']'; )
        {
            j++;
        }
        if(j >= len(line))
        {
            return {line, 0, false};
        }
        auto idstr = line.make_slice(i + len(prefix), j);
        if(len(idstr) >= 3 && idstr.make_slice(0, 2) == "0x"s)
        {
            if(len(idstr) > 2 + 16)
            {
                return {line, 0, false};
            }
            for(auto i = 2; i < len(idstr); i++)
            {
                id <<= 4;
                //Go switch emulation
                {
                    auto c = idstr[i];
                    int conditionId = -1;
                    if('0' <= c && c <= '9') { conditionId = 0; }
                    else if('a' <= c && c <= 'f') { conditionId = 1; }
                    else if('A' <= c && c <= 'F') { conditionId = 2; }
                    switch(conditionId)
                    {
                        case 0:
                            id |= uint64_t(c - '0');
                            break;
                        case 1:
                            id |= uint64_t(c - 'a' + 10);
                            break;
                        case 2:
                            id |= uint64_t(c - 'A' + 10);
                            break;
                    }
                }
            }
        }
        else
        {
            if(idstr == ""s || len(idstr) > 64)
            {
                return {line, 0, false};
            }
            for(auto i = 0; i < len(idstr); i++)
            {
                id <<= 1;
                //Go switch emulation
                {
                    auto c = idstr[i];
                    auto condition = c;
                    int conditionId = -1;
                    if(condition == '0') { conditionId = 0; }
                    else if(condition == '1') { conditionId = 1; }
                    switch(conditionId)
                    {
                        default:
                            return {line, 0, false};
                            break;
                        case 0:
                        case 1:
                            id |= uint64_t(c - '0');
                            break;
                    }
                }
            }
        }
        j++;
        if(i > 0 && line[i - 1] == ' ')
        {
            i--;
        }
        else
        if(j < len(line) && line[j] == ' ')
        {
            j++;
        }
        short = line.make_slice(0, i) + line.make_slice(j);
        return {short, id, true};
    }

    // Hash computes a hash of the data arguments,
    // each of which must be of type string, byte, int, uint, int32, uint32, int64, uint64, uintptr, or a slice of one of those types.
    uint64_t Hash(gocpp::slice<go_any> data)
    {
        auto h = offset64;
        for(auto [gocpp_ignored, v] : data)
        {
            //Go type switch emulation
            {
                const auto& gocpp_id_6 = gocpp::type_info(v);
                int conditionId = -1;
                if(gocpp_id_6 == typeid(std::string)) { conditionId = 0; }
                else if(gocpp_id_6 == typeid(unsigned char)) { conditionId = 1; }
                else if(gocpp_id_6 == typeid(int)) { conditionId = 2; }
                else if(gocpp_id_6 == typeid(unsigned int)) { conditionId = 3; }
                else if(gocpp_id_6 == typeid(int32_t)) { conditionId = 4; }
                else if(gocpp_id_6 == typeid(uint32_t)) { conditionId = 5; }
                else if(gocpp_id_6 == typeid(int64_t)) { conditionId = 6; }
                else if(gocpp_id_6 == typeid(uint64_t)) { conditionId = 7; }
                else if(gocpp_id_6 == typeid(uintptr_t)) { conditionId = 8; }
                else if(gocpp_id_6 == typeid(gocpp::slice<std::string>)) { conditionId = 9; }
                else if(gocpp_id_6 == typeid(gocpp::slice<unsigned char>)) { conditionId = 10; }
                else if(gocpp_id_6 == typeid(gocpp::slice<int>)) { conditionId = 11; }
                else if(gocpp_id_6 == typeid(gocpp::slice<unsigned int>)) { conditionId = 12; }
                else if(gocpp_id_6 == typeid(gocpp::slice<int32_t>)) { conditionId = 13; }
                else if(gocpp_id_6 == typeid(gocpp::slice<uint32_t>)) { conditionId = 14; }
                else if(gocpp_id_6 == typeid(gocpp::slice<int64_t>)) { conditionId = 15; }
                else if(gocpp_id_6 == typeid(gocpp::slice<uint64_t>)) { conditionId = 16; }
                else if(gocpp_id_6 == typeid(gocpp::slice<uintptr_t>)) { conditionId = 17; }
                switch(conditionId)
                {
                    default:
                    {
                        auto v = v;
                        gocpp::panic("bisect.Hash: unexpected argument type"s);
                        break;
                    }
                    case 0:
                    {
                        std::string v = gocpp::any_cast<std::string>(v);
                        h = fnvString(h, v);
                        break;
                    }
                    case 1:
                    {
                        unsigned char v = gocpp::any_cast<unsigned char>(v);
                        h = fnv(h, v);
                        break;
                    }
                    case 2:
                    {
                        int v = gocpp::any_cast<int>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 3:
                    {
                        unsigned int v = gocpp::any_cast<unsigned int>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 4:
                    {
                        int32_t v = gocpp::any_cast<int32_t>(v);
                        h = fnvUint32(h, uint32_t(v));
                        break;
                    }
                    case 5:
                    {
                        uint32_t v = gocpp::any_cast<uint32_t>(v);
                        h = fnvUint32(h, v);
                        break;
                    }
                    case 6:
                    {
                        int64_t v = gocpp::any_cast<int64_t>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 7:
                    {
                        uint64_t v = gocpp::any_cast<uint64_t>(v);
                        h = fnvUint64(h, v);
                        break;
                    }
                    case 8:
                    {
                        uintptr_t v = gocpp::any_cast<uintptr_t>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 9:
                    {
                        gocpp::slice<std::string> v = gocpp::any_cast<gocpp::slice<std::string>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvString(h, x);
                        }
                        break;
                    }
                    case 10:
                    {
                        gocpp::slice<unsigned char> v = gocpp::any_cast<gocpp::slice<unsigned char>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnv(h, x);
                        }
                        break;
                    }
                    case 11:
                    {
                        gocpp::slice<int> v = gocpp::any_cast<gocpp::slice<int>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                    case 12:
                    {
                        gocpp::slice<unsigned int> v = gocpp::any_cast<gocpp::slice<unsigned int>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                    case 13:
                    {
                        gocpp::slice<int32_t> v = gocpp::any_cast<gocpp::slice<int32_t>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint32(h, uint32_t(x));
                        }
                        break;
                    }
                    case 14:
                    {
                        gocpp::slice<uint32_t> v = gocpp::any_cast<gocpp::slice<uint32_t>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint32(h, x);
                        }
                        break;
                    }
                    case 15:
                    {
                        gocpp::slice<int64_t> v = gocpp::any_cast<gocpp::slice<int64_t>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                    case 16:
                    {
                        gocpp::slice<uint64_t> v = gocpp::any_cast<gocpp::slice<uint64_t>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint64(h, x);
                        }
                        break;
                    }
                    case 17:
                    {
                        gocpp::slice<uintptr_t> v = gocpp::any_cast<gocpp::slice<uintptr_t>>(v);
                        for(auto [gocpp_ignored, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                }
            }
        }
        return h;
    }

    // parseError is a trivial error implementation,
    // defined here to avoid importing errors.
    
    template<typename T> requires gocpp::GoStruct<T>
    parseError::operator T()
    {
        T result;
        result.text = this->text;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool parseError::operator==(const T& ref) const
    {
        if (text != ref.text) return false;
        return true;
    }

    std::ostream& parseError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << text;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct parseError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct parseError* e)
    {
        return e->text;
    }

    uint64_t fnv(uint64_t h, unsigned char x)
    {
        h ^= uint64_t(x);
        h *= prime64;
        return h;
    }

    uint64_t fnvString(uint64_t h, std::string x)
    {
        for(auto i = 0; i < len(x); i++)
        {
            h ^= uint64_t(x[i]);
            h *= prime64;
        }
        return h;
    }

    uint64_t fnvUint64(uint64_t h, uint64_t x)
    {
        for(auto i = 0; i < 8; i++)
        {
            h ^= x & 0xFF;
            x >>= 8;
            h *= prime64;
        }
        return h;
    }

    uint64_t fnvUint32(uint64_t h, uint32_t x)
    {
        for(auto i = 0; i < 4; i++)
        {
            h ^= uint64_t(x & 0xFF);
            x >>= 8;
            h *= prime64;
        }
        return h;
    }

    // A dedup is a deduplicator for call stacks, so that we only print
    // a report for new call stacks, not for call stacks we've already
    // reported.
    //
    // It has two modes: an approximate but lock-free mode that
    // may still emit some duplicates, and a precise mode that uses
    // a lock and never emits duplicates.
    
    template<typename T> requires gocpp::GoStruct<T>
    dedup::operator T()
    {
        T result;
        result.recent = this->recent;
        result.mu = this->mu;
        result.m = this->m;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dedup::operator==(const T& ref) const
    {
        if (recent != ref.recent) return false;
        if (mu != ref.mu) return false;
        if (m != ref.m) return false;
        return true;
    }

    std::ostream& dedup::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << recent;
        os << " " << mu;
        os << " " << m;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dedup& value)
    {
        return value.PrintTo(os);
    }

    // seen records that h has now been seen and reports whether it was seen before.
    // When seen returns false, the caller is expected to print a report for h.
    bool rec::seen(struct dedup* d, uint64_t h)
    {
        rec::Lock(gocpp::recv(d->mu));
        if(d->m == nullptr)
        {
            d->m = gocpp::make(gocpp::Tag<gocpp::map<uint64_t, bool>>());
        }
        auto seen = d->m[h];
        d->m[h] = true;
        rec::Unlock(gocpp::recv(d->mu));
        return seen;
    }

    // seenLossy is a variant of seen that avoids a lock by using a cache of recently seen hashes.
    // Each cache entry is N-way set-associative: h can appear in any of the slots.
    // If h does not appear in any of them, then it is inserted into a random slot,
    // overwriting whatever was there before.
    bool rec::seenLossy(struct dedup* d, uint64_t h)
    {
        auto cache = & d->recent[(unsigned int)(h) % (unsigned int)(len(d->recent))];
        for(auto i = 0; i < len(cache); i++)
        {
            if(atomic::LoadUint64(& cache[i]) == h)
            {
                return true;
            }
        }
        auto ch = offset64;
        for(auto [gocpp_ignored, x] : cache)
        {
            ch = fnvUint64(ch, x);
        }
        atomic::StoreUint64(& cache[(unsigned int)(ch) % (unsigned int)(len(cache))], h);
        return false;
    }

}

