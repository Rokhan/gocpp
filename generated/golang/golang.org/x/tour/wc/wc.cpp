// generated by GoCpp from file '$(ImportDir)/golang.org/x/tour/wc/wc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/golang.org/x/tour/wc/wc.h"
#include "gocpp/support.h"

#include "golang/fmt/print.h"

namespace golang::wc
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Test runs a test suite against f.
    void Test(std::function<gocpp::map<gocpp::string, int> (gocpp::string _1)> f)
    {
        auto ok = true;
        for(auto [gocpp_ignored, c] : testCases)
        {
            auto got = f(c.in);
            if(len(c.want) != len(got))
            {
                ok = false;
            }
            else
            {
                for(auto [k, gocpp_ignored] : c.want)
                {
                    if(c.want[k] != got[k])
                    {
                        ok = false;
                    }
                }
            }
            if(! ok)
            {
                mocklib::Printf("FAIL\n f(%q) =\n  %#v\n want:\n  %#v"_s, c.in, got, c.want);
                break;
            }
            mocklib::Printf("PASS\n f(%q) = \n  %#v\n"_s, c.in, got);
        }
    }

    struct gocpp_id_0
    {
        gocpp::string in;
        gocpp::map<gocpp::string, int> want;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.in = this->in;
            result.want = this->want;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (in != ref.in) return false;
            if (want != ref.want) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << in;
            os << " " << want;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp::slice<gocpp_id_0> testCases = gocpp::slice<gocpp_id_0> { {"I am learning Go!"_s, gocpp::map<gocpp::string, int> {{ "I"_s, 1 }, { "am"_s, 1 }, { "learning"_s, 1 }, { "Go!"_s, 1 }}},  {"The quick brown fox jumped over the lazy dog."_s, gocpp::map<gocpp::string, int> {{ "The"_s, 1 }, { "quick"_s, 1 }, { "brown"_s, 1 }, { "fox"_s, 1 }, { "jumped"_s, 1 }, { "over"_s, 1 }, { "the"_s, 1 }, { "lazy"_s, 1 }, { "dog."_s, 1 }}},  {"I ate a donut. Then I ate another donut."_s, gocpp::map<gocpp::string, int> {{ "I"_s, 2 }, { "ate"_s, 2 }, { "a"_s, 1 }, { "donut."_s, 2 }, { "Then"_s, 1 }, { "another"_s, 1 }}},  {"A man a plan a canal panama."_s, gocpp::map<gocpp::string, int> {{ "A"_s, 1 }, { "man"_s, 1 }, { "a"_s, 2 }, { "plan"_s, 1 }, { "canal"_s, 1 }, { "panama."_s, 1 }}}};
}

