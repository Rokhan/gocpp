// generated by GoCpp from file '$(ImportDir)/runtime/mstats.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mstats.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace cpu::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mstats::operator T()
    {
        T result;
        result.heapStats = this->heapStats;
        result.stacks_sys = this->stacks_sys;
        result.mspan_sys = this->mspan_sys;
        result.mcache_sys = this->mcache_sys;
        result.buckhash_sys = this->buckhash_sys;
        result.gcMiscSys = this->gcMiscSys;
        result.other_sys = this->other_sys;
        result.last_gc_unix = this->last_gc_unix;
        result.pause_total_ns = this->pause_total_ns;
        result.pause_ns = this->pause_ns;
        result.pause_end = this->pause_end;
        result.numgc = this->numgc;
        result.numforcedgc = this->numforcedgc;
        result.gc_cpu_fraction = this->gc_cpu_fraction;
        result.last_gc_nanotime = this->last_gc_nanotime;
        result.lastHeapInUse = this->lastHeapInUse;
        result.enablegc = this->enablegc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mstats::operator==(const T& ref) const
    {
        if (heapStats != ref.heapStats) return false;
        if (stacks_sys != ref.stacks_sys) return false;
        if (mspan_sys != ref.mspan_sys) return false;
        if (mcache_sys != ref.mcache_sys) return false;
        if (buckhash_sys != ref.buckhash_sys) return false;
        if (gcMiscSys != ref.gcMiscSys) return false;
        if (other_sys != ref.other_sys) return false;
        if (last_gc_unix != ref.last_gc_unix) return false;
        if (pause_total_ns != ref.pause_total_ns) return false;
        if (pause_ns != ref.pause_ns) return false;
        if (pause_end != ref.pause_end) return false;
        if (numgc != ref.numgc) return false;
        if (numforcedgc != ref.numforcedgc) return false;
        if (gc_cpu_fraction != ref.gc_cpu_fraction) return false;
        if (last_gc_nanotime != ref.last_gc_nanotime) return false;
        if (lastHeapInUse != ref.lastHeapInUse) return false;
        if (enablegc != ref.enablegc) return false;
        return true;
    }

    std::ostream& mstats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heapStats;
        os << " " << stacks_sys;
        os << " " << mspan_sys;
        os << " " << mcache_sys;
        os << " " << buckhash_sys;
        os << " " << gcMiscSys;
        os << " " << other_sys;
        os << " " << last_gc_unix;
        os << " " << pause_total_ns;
        os << " " << pause_ns;
        os << " " << pause_end;
        os << " " << numgc;
        os << " " << numforcedgc;
        os << " " << gc_cpu_fraction;
        os << " " << last_gc_nanotime;
        os << " " << lastHeapInUse;
        os << " " << enablegc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mstats& value)
    {
        return value.PrintTo(os);
    }

    mstats memstats;
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.Size = this->Size;
        result.Mallocs = this->Mallocs;
        result.Frees = this->Frees;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (Mallocs != ref.Mallocs) return false;
        if (Frees != ref.Frees) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << Mallocs;
        os << " " << Frees;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    MemStats::operator T()
    {
        T result;
        result.Alloc = this->Alloc;
        result.TotalAlloc = this->TotalAlloc;
        result.Sys = this->Sys;
        result.Lookups = this->Lookups;
        result.Mallocs = this->Mallocs;
        result.Frees = this->Frees;
        result.HeapAlloc = this->HeapAlloc;
        result.HeapSys = this->HeapSys;
        result.HeapIdle = this->HeapIdle;
        result.HeapInuse = this->HeapInuse;
        result.HeapReleased = this->HeapReleased;
        result.HeapObjects = this->HeapObjects;
        result.StackInuse = this->StackInuse;
        result.StackSys = this->StackSys;
        result.MSpanInuse = this->MSpanInuse;
        result.MSpanSys = this->MSpanSys;
        result.MCacheInuse = this->MCacheInuse;
        result.MCacheSys = this->MCacheSys;
        result.BuckHashSys = this->BuckHashSys;
        result.GCSys = this->GCSys;
        result.OtherSys = this->OtherSys;
        result.NextGC = this->NextGC;
        result.LastGC = this->LastGC;
        result.PauseTotalNs = this->PauseTotalNs;
        result.PauseNs = this->PauseNs;
        result.PauseEnd = this->PauseEnd;
        result.NumGC = this->NumGC;
        result.NumForcedGC = this->NumForcedGC;
        result.GCCPUFraction = this->GCCPUFraction;
        result.EnableGC = this->EnableGC;
        result.DebugGC = this->DebugGC;
        result.BySize = this->BySize;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool MemStats::operator==(const T& ref) const
    {
        if (Alloc != ref.Alloc) return false;
        if (TotalAlloc != ref.TotalAlloc) return false;
        if (Sys != ref.Sys) return false;
        if (Lookups != ref.Lookups) return false;
        if (Mallocs != ref.Mallocs) return false;
        if (Frees != ref.Frees) return false;
        if (HeapAlloc != ref.HeapAlloc) return false;
        if (HeapSys != ref.HeapSys) return false;
        if (HeapIdle != ref.HeapIdle) return false;
        if (HeapInuse != ref.HeapInuse) return false;
        if (HeapReleased != ref.HeapReleased) return false;
        if (HeapObjects != ref.HeapObjects) return false;
        if (StackInuse != ref.StackInuse) return false;
        if (StackSys != ref.StackSys) return false;
        if (MSpanInuse != ref.MSpanInuse) return false;
        if (MSpanSys != ref.MSpanSys) return false;
        if (MCacheInuse != ref.MCacheInuse) return false;
        if (MCacheSys != ref.MCacheSys) return false;
        if (BuckHashSys != ref.BuckHashSys) return false;
        if (GCSys != ref.GCSys) return false;
        if (OtherSys != ref.OtherSys) return false;
        if (NextGC != ref.NextGC) return false;
        if (LastGC != ref.LastGC) return false;
        if (PauseTotalNs != ref.PauseTotalNs) return false;
        if (PauseNs != ref.PauseNs) return false;
        if (PauseEnd != ref.PauseEnd) return false;
        if (NumGC != ref.NumGC) return false;
        if (NumForcedGC != ref.NumForcedGC) return false;
        if (GCCPUFraction != ref.GCCPUFraction) return false;
        if (EnableGC != ref.EnableGC) return false;
        if (DebugGC != ref.DebugGC) return false;
        if (BySize != ref.BySize) return false;
        return true;
    }

    std::ostream& MemStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Alloc;
        os << " " << TotalAlloc;
        os << " " << Sys;
        os << " " << Lookups;
        os << " " << Mallocs;
        os << " " << Frees;
        os << " " << HeapAlloc;
        os << " " << HeapSys;
        os << " " << HeapIdle;
        os << " " << HeapInuse;
        os << " " << HeapReleased;
        os << " " << HeapObjects;
        os << " " << StackInuse;
        os << " " << StackSys;
        os << " " << MSpanInuse;
        os << " " << MSpanSys;
        os << " " << MCacheInuse;
        os << " " << MCacheSys;
        os << " " << BuckHashSys;
        os << " " << GCSys;
        os << " " << OtherSys;
        os << " " << NextGC;
        os << " " << LastGC;
        os << " " << PauseTotalNs;
        os << " " << PauseNs;
        os << " " << PauseEnd;
        os << " " << NumGC;
        os << " " << NumForcedGC;
        os << " " << GCCPUFraction;
        os << " " << EnableGC;
        os << " " << DebugGC;
        os << " " << BySize;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MemStats& value)
    {
        return value.PrintTo(os);
    }

    void init()
    {
        if(auto offset = unsafe::Offsetof(memstats.heapStats); offset % 8 != 0)
        {
            println(offset);
            go_throw("memstats.heapStats not aligned to 8 bytes");
        }
        if(auto size = gocpp::Sizeof<heapStatsDelta>(); size % 8 != 0)
        {
            println(size);
            go_throw("heapStatsDelta not a multiple of 8 bytes in size");
        }
    }

    void ReadMemStats(struct MemStats* m)
    {
        _ = m->Alloc;
        auto stw = stopTheWorld(stwReadMemStats);
        systemstack([=]() mutable -> void
        {
            readmemstats_m(m);
        });
        startTheWorld(stw);
    }

    bool doubleCheckReadMemStats = false;
    struct gocpp_id_1
        {
            uint32_t Size;
            uint64_t Mallocs;
            uint64_t Frees;

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                result.Size = this->Size;
                result.Mallocs = this->Mallocs;
                result.Frees = this->Frees;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                if (Size != ref.Size) return false;
                if (Mallocs != ref.Mallocs) return false;
                if (Frees != ref.Frees) return false;
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << Size;
                os << " " << Mallocs;
                os << " " << Frees;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    void readmemstats_m(struct MemStats* stats)
    {
        assertWorldStopped();
        systemstack(flushallmcaches);
        heapStatsDelta consStats = {};
        rec::unsafeRead(gocpp::recv(memstats.heapStats), & consStats);
        auto totalAlloc = consStats.largeAlloc;
        auto nMalloc = consStats.largeAllocCount;
        auto totalFree = consStats.largeFree;
        auto nFree = consStats.largeFreeCount;
        gocpp::array<gocpp_id_1, _NumSizeClasses> bySize = {};
        for(auto [i, gocpp_ignored] : bySize)
        {
            bySize[i].Size = uint32_t(class_to_size[i]);
            auto a = consStats.smallAllocCount[i];
            totalAlloc += a * uint64_t(class_to_size[i]);
            nMalloc += a;
            bySize[i].Mallocs = a;
            auto f = consStats.smallFreeCount[i];
            totalFree += f * uint64_t(class_to_size[i]);
            nFree += f;
            bySize[i].Frees = f;
        }
        nFree += consStats.tinyAllocCount;
        nMalloc += consStats.tinyAllocCount;
        auto stackInUse = uint64_t(consStats.inStacks);
        auto gcWorkBufInUse = uint64_t(consStats.inWorkBufs);
        auto gcProgPtrScalarBitsInUse = uint64_t(consStats.inPtrScalarBits);
        auto totalMapped = rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree)) + rec::load(gocpp::recv(gcController.heapReleased)) + rec::load(gocpp::recv(memstats.stacks_sys)) + rec::load(gocpp::recv(memstats.mspan_sys)) + rec::load(gocpp::recv(memstats.mcache_sys)) + rec::load(gocpp::recv(memstats.buckhash_sys)) + rec::load(gocpp::recv(memstats.gcMiscSys)) + rec::load(gocpp::recv(memstats.other_sys)) + stackInUse + gcWorkBufInUse + gcProgPtrScalarBitsInUse;
        auto heapGoal = rec::heapGoal(gocpp::recv(gcController));
        if(doubleCheckReadMemStats)
        {
            lock(& sched.sysmonlock);
            lock(& trace.lock);
            if(rec::load(gocpp::recv(gcController.heapInUse)) != uint64_t(consStats.inHeap))
            {
                print("runtime: heapInUse=", rec::load(gocpp::recv(gcController.heapInUse)), "\n");
                print("runtime: consistent value=", consStats.inHeap, "\n");
                go_throw("heapInUse and consistent stats are not equal");
            }
            if(rec::load(gocpp::recv(gcController.heapReleased)) != uint64_t(consStats.released))
            {
                print("runtime: heapReleased=", rec::load(gocpp::recv(gcController.heapReleased)), "\n");
                print("runtime: consistent value=", consStats.released, "\n");
                go_throw("heapReleased and consistent stats are not equal");
            }
            auto heapRetained = rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree));
            auto consRetained = uint64_t(consStats.committed - consStats.inStacks - consStats.inWorkBufs - consStats.inPtrScalarBits);
            if(heapRetained != consRetained)
            {
                print("runtime: global value=", heapRetained, "\n");
                print("runtime: consistent value=", consRetained, "\n");
                go_throw("measures of the retained heap are not equal");
            }
            if(rec::Load(gocpp::recv(gcController.totalAlloc)) != totalAlloc)
            {
                print("runtime: totalAlloc=", rec::Load(gocpp::recv(gcController.totalAlloc)), "\n");
                print("runtime: consistent value=", totalAlloc, "\n");
                go_throw("totalAlloc and consistent stats are not equal");
            }
            if(rec::Load(gocpp::recv(gcController.totalFree)) != totalFree)
            {
                print("runtime: totalFree=", rec::Load(gocpp::recv(gcController.totalFree)), "\n");
                print("runtime: consistent value=", totalFree, "\n");
                go_throw("totalFree and consistent stats are not equal");
            }
            if(rec::Load(gocpp::recv(gcController.mappedReady)) != totalMapped - uint64_t(consStats.released))
            {
                print("runtime: mappedReady=", rec::Load(gocpp::recv(gcController.mappedReady)), "\n");
                print("runtime: totalMapped=", totalMapped, "\n");
                print("runtime: released=", uint64_t(consStats.released), "\n");
                print("runtime: totalMapped-released=", totalMapped - uint64_t(consStats.released), "\n");
                go_throw("mappedReady and other memstats are not equal");
            }
            unlock(& trace.lock);
            unlock(& sched.sysmonlock);
        }
        stats->Alloc = totalAlloc - totalFree;
        stats->TotalAlloc = totalAlloc;
        stats->Sys = totalMapped;
        stats->Mallocs = nMalloc;
        stats->Frees = nFree;
        stats->HeapAlloc = totalAlloc - totalFree;
        stats->HeapSys = rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree)) + rec::load(gocpp::recv(gcController.heapReleased));
        stats->HeapIdle = rec::load(gocpp::recv(gcController.heapFree)) + rec::load(gocpp::recv(gcController.heapReleased));
        stats->HeapInuse = rec::load(gocpp::recv(gcController.heapInUse));
        stats->HeapReleased = rec::load(gocpp::recv(gcController.heapReleased));
        stats->HeapObjects = nMalloc - nFree;
        stats->StackInuse = stackInUse;
        stats->StackSys = stackInUse + rec::load(gocpp::recv(memstats.stacks_sys));
        stats->MSpanInuse = uint64_t(mheap_.spanalloc.inuse);
        stats->MSpanSys = rec::load(gocpp::recv(memstats.mspan_sys));
        stats->MCacheInuse = uint64_t(mheap_.cachealloc.inuse);
        stats->MCacheSys = rec::load(gocpp::recv(memstats.mcache_sys));
        stats->BuckHashSys = rec::load(gocpp::recv(memstats.buckhash_sys));
        stats->GCSys = rec::load(gocpp::recv(memstats.gcMiscSys)) + gcWorkBufInUse + gcProgPtrScalarBitsInUse;
        stats->OtherSys = rec::load(gocpp::recv(memstats.other_sys));
        stats->NextGC = heapGoal;
        stats->LastGC = memstats.last_gc_unix;
        stats->PauseTotalNs = memstats.pause_total_ns;
        stats->PauseNs = memstats.pause_ns;
        stats->PauseEnd = memstats.pause_end;
        stats->NumGC = memstats.numgc;
        stats->NumForcedGC = memstats.numforcedgc;
        stats->GCCPUFraction = memstats.gc_cpu_fraction;
        stats->EnableGC = true;
        copy(stats->BySize.make_slice(0), bySize.make_slice(0));
    }

    void readGCStats(gocpp::slice<uint64_t>* pauses)
    {
        systemstack([=]() mutable -> void
        {
            readGCStats_m(pauses);
        });
    }

    void readGCStats_m(gocpp::slice<uint64_t>* pauses)
    {
        auto p = *pauses;
        if(cap(p) < len(memstats.pause_ns) + 3)
        {
            go_throw("short slice passed to readGCStats");
        }
        lock(& mheap_.lock);
        auto n = memstats.numgc;
        if(n > uint32_t(len(memstats.pause_ns)))
        {
            n = uint32_t(len(memstats.pause_ns));
        }
        p = p.make_slice(0, cap(p));
        for(auto i = uint32_t(0); i < n; i++)
        {
            auto j = (memstats.numgc - 1 - i) % uint32_t(len(memstats.pause_ns));
            p[i] = memstats.pause_ns[j];
            p[n + i] = memstats.pause_end[j];
        }
        p[n + n] = memstats.last_gc_unix;
        p[n + n + 1] = uint64_t(memstats.numgc);
        p[n + n + 2] = memstats.pause_total_ns;
        unlock(& mheap_.lock);
        *pauses = p.make_slice(0, n + n + 3);
    }

    void flushmcache(int i)
    {
        assertWorldStopped();
        auto p = allp[i];
        auto c = p->mcache;
        if(c == nullptr)
        {
            return;
        }
        rec::releaseAll(gocpp::recv(c));
        stackcache_clear(c);
    }

    void flushallmcaches()
    {
        assertWorldStopped();
        for(auto i = 0; i < int(gomaxprocs); i++)
        {
            flushmcache(i);
        }
    }

    uint64_t rec::load(golang::runtime::sysMemStat* s)
    {
        return atomic::Load64((uint64_t*)(s));
    }

    void rec::add(golang::runtime::sysMemStat* s, int64_t n)
    {
        auto val = atomic::Xadd64((uint64_t*)(s), n);
        if((n > 0 && int64_t(val) < n) || (n < 0 && int64_t(val) + n < n))
        {
            print("runtime: val=", val, " n=", n, "\n");
            go_throw("sysMemStat overflow");
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    heapStatsDelta::operator T()
    {
        T result;
        result.committed = this->committed;
        result.released = this->released;
        result.inHeap = this->inHeap;
        result.inStacks = this->inStacks;
        result.inWorkBufs = this->inWorkBufs;
        result.inPtrScalarBits = this->inPtrScalarBits;
        result.tinyAllocCount = this->tinyAllocCount;
        result.largeAlloc = this->largeAlloc;
        result.largeAllocCount = this->largeAllocCount;
        result.smallAllocCount = this->smallAllocCount;
        result.largeFree = this->largeFree;
        result.largeFreeCount = this->largeFreeCount;
        result.smallFreeCount = this->smallFreeCount;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heapStatsDelta::operator==(const T& ref) const
    {
        if (committed != ref.committed) return false;
        if (released != ref.released) return false;
        if (inHeap != ref.inHeap) return false;
        if (inStacks != ref.inStacks) return false;
        if (inWorkBufs != ref.inWorkBufs) return false;
        if (inPtrScalarBits != ref.inPtrScalarBits) return false;
        if (tinyAllocCount != ref.tinyAllocCount) return false;
        if (largeAlloc != ref.largeAlloc) return false;
        if (largeAllocCount != ref.largeAllocCount) return false;
        if (smallAllocCount != ref.smallAllocCount) return false;
        if (largeFree != ref.largeFree) return false;
        if (largeFreeCount != ref.largeFreeCount) return false;
        if (smallFreeCount != ref.smallFreeCount) return false;
        return true;
    }

    std::ostream& heapStatsDelta::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << committed;
        os << " " << released;
        os << " " << inHeap;
        os << " " << inStacks;
        os << " " << inWorkBufs;
        os << " " << inPtrScalarBits;
        os << " " << tinyAllocCount;
        os << " " << largeAlloc;
        os << " " << largeAllocCount;
        os << " " << smallAllocCount;
        os << " " << largeFree;
        os << " " << largeFreeCount;
        os << " " << smallFreeCount;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapStatsDelta& value)
    {
        return value.PrintTo(os);
    }

    void rec::merge(struct heapStatsDelta* a, struct heapStatsDelta* b)
    {
        a->committed += b->committed;
        a->released += b->released;
        a->inHeap += b->inHeap;
        a->inStacks += b->inStacks;
        a->inWorkBufs += b->inWorkBufs;
        a->inPtrScalarBits += b->inPtrScalarBits;
        a->tinyAllocCount += b->tinyAllocCount;
        a->largeAlloc += b->largeAlloc;
        a->largeAllocCount += b->largeAllocCount;
        for(auto [i, gocpp_ignored] : b->smallAllocCount)
        {
            a->smallAllocCount[i] += b->smallAllocCount[i];
        }
        a->largeFree += b->largeFree;
        a->largeFreeCount += b->largeFreeCount;
        for(auto [i, gocpp_ignored] : b->smallFreeCount)
        {
            a->smallFreeCount[i] += b->smallFreeCount[i];
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    consistentHeapStats::operator T()
    {
        T result;
        result.stats = this->stats;
        result.gen = this->gen;
        result.noPLock = this->noPLock;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool consistentHeapStats::operator==(const T& ref) const
    {
        if (stats != ref.stats) return false;
        if (gen != ref.gen) return false;
        if (noPLock != ref.noPLock) return false;
        return true;
    }

    std::ostream& consistentHeapStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stats;
        os << " " << gen;
        os << " " << noPLock;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct consistentHeapStats& value)
    {
        return value.PrintTo(os);
    }

    struct heapStatsDelta* rec::acquire(struct consistentHeapStats* m)
    {
        if(auto pp = rec::ptr(gocpp::recv(getg()->m->p)); pp != nullptr)
        {
            auto seq = rec::Add(gocpp::recv(pp->statsSeq), 1);
            if(seq % 2 == 0)
            {
                print("runtime: seq=", seq, "\n");
                go_throw("bad sequence number");
            }
        }
        else
        {
            lock(& m->noPLock);
        }
        auto gen = rec::Load(gocpp::recv(m->gen)) % 3;
        return & m->stats[gen];
    }

    void rec::release(struct consistentHeapStats* m)
    {
        if(auto pp = rec::ptr(gocpp::recv(getg()->m->p)); pp != nullptr)
        {
            auto seq = rec::Add(gocpp::recv(pp->statsSeq), 1);
            if(seq % 2 != 0)
            {
                print("runtime: seq=", seq, "\n");
                go_throw("bad sequence number");
            }
        }
        else
        {
            unlock(& m->noPLock);
        }
    }

    void rec::unsafeRead(struct consistentHeapStats* m, struct heapStatsDelta* out)
    {
        assertWorldStopped();
        for(auto [i, gocpp_ignored] : m->stats)
        {
            rec::merge(gocpp::recv(out), & m->stats[i]);
        }
    }

    void rec::unsafeClear(struct consistentHeapStats* m)
    {
        assertWorldStopped();
        for(auto [i, gocpp_ignored] : m->stats)
        {
            m->stats[i] = heapStatsDelta {};
        }
    }

    void rec::read(struct consistentHeapStats* m, struct heapStatsDelta* out)
    {
        auto mp = acquirem();
        auto currGen = rec::Load(gocpp::recv(m->gen));
        auto prevGen = currGen - 1;
        if(currGen == 0)
        {
            prevGen = 2;
        }
        lock(& m->noPLock);
        rec::Swap(gocpp::recv(m->gen), (currGen + 1) % 3);
        unlock(& m->noPLock);
        for(auto [gocpp_ignored, p] : allp)
        {
            for(; rec::Load(gocpp::recv(p->statsSeq)) % 2 != 0; )
            {
            }
        }
        rec::merge(gocpp::recv(m->stats[currGen]), & m->stats[prevGen]);
        m->stats[prevGen] = heapStatsDelta {};
        *out = m->stats[currGen];
        releasem(mp);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    cpuStats::operator T()
    {
        T result;
        result.gcAssistTime = this->gcAssistTime;
        result.gcDedicatedTime = this->gcDedicatedTime;
        result.gcIdleTime = this->gcIdleTime;
        result.gcPauseTime = this->gcPauseTime;
        result.gcTotalTime = this->gcTotalTime;
        result.scavengeAssistTime = this->scavengeAssistTime;
        result.scavengeBgTime = this->scavengeBgTime;
        result.scavengeTotalTime = this->scavengeTotalTime;
        result.idleTime = this->idleTime;
        result.userTime = this->userTime;
        result.totalTime = this->totalTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cpuStats::operator==(const T& ref) const
    {
        if (gcAssistTime != ref.gcAssistTime) return false;
        if (gcDedicatedTime != ref.gcDedicatedTime) return false;
        if (gcIdleTime != ref.gcIdleTime) return false;
        if (gcPauseTime != ref.gcPauseTime) return false;
        if (gcTotalTime != ref.gcTotalTime) return false;
        if (scavengeAssistTime != ref.scavengeAssistTime) return false;
        if (scavengeBgTime != ref.scavengeBgTime) return false;
        if (scavengeTotalTime != ref.scavengeTotalTime) return false;
        if (idleTime != ref.idleTime) return false;
        if (userTime != ref.userTime) return false;
        if (totalTime != ref.totalTime) return false;
        return true;
    }

    std::ostream& cpuStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << gcAssistTime;
        os << " " << gcDedicatedTime;
        os << " " << gcIdleTime;
        os << " " << gcPauseTime;
        os << " " << gcTotalTime;
        os << " " << scavengeAssistTime;
        os << " " << scavengeBgTime;
        os << " " << scavengeTotalTime;
        os << " " << idleTime;
        os << " " << userTime;
        os << " " << totalTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuStats& value)
    {
        return value.PrintTo(os);
    }

    void rec::accumulate(struct cpuStats* s, int64_t now, bool gcMarkPhase)
    {
        int64_t markAssistCpu = {};
        int64_t markDedicatedCpu = {};
        int64_t markFractionalCpu = {};
        int64_t markIdleCpu = {};
        if(gcMarkPhase)
        {
            markAssistCpu = rec::Load(gocpp::recv(gcController.assistTime));
            markDedicatedCpu = rec::Load(gocpp::recv(gcController.dedicatedMarkTime));
            markFractionalCpu = rec::Load(gocpp::recv(gcController.fractionalMarkTime));
            markIdleCpu = rec::Load(gocpp::recv(gcController.idleMarkTime));
        }
        auto scavAssistCpu = rec::Load(gocpp::recv(scavenge.assistTime));
        auto scavBgCpu = rec::Load(gocpp::recv(scavenge.backgroundTime));
        s->gcAssistTime += markAssistCpu;
        s->gcDedicatedTime += markDedicatedCpu + markFractionalCpu;
        s->gcIdleTime += markIdleCpu;
        s->gcTotalTime += markAssistCpu + markDedicatedCpu + markFractionalCpu + markIdleCpu;
        s->scavengeAssistTime += scavAssistCpu;
        s->scavengeBgTime += scavBgCpu;
        s->scavengeTotalTime += scavAssistCpu + scavBgCpu;
        s->totalTime = sched.totaltime + (now - sched.procresizetime) * int64_t(gomaxprocs);
        s->idleTime += rec::Load(gocpp::recv(sched.idleTime));
        s->userTime = s->totalTime - (s->gcTotalTime + s->scavengeTotalTime + s->idleTime);
    }

}

