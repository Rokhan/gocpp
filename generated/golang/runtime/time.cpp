// generated by GoCpp from file '$(ImportDir)/runtime/time.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/time.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
#include "golang/runtime/netpoll.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& timer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pp;
        os << " " << when;
        os << " " << period;
        os << " " << f;
        os << " " << arg;
        os << " " << seq;
        os << " " << nextwhen;
        os << " " << status;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct timer& value)
    {
        return value.PrintTo(os);
    }

    int timerNoStatus = 0;
    int timerWaiting = 1;
    int timerRunning = 2;
    int timerDeleted = 3;
    int timerRemoving = 4;
    int timerRemoved = 5;
    int timerModifying = 6;
    int timerModifiedEarlier = 7;
    int timerModifiedLater = 8;
    int timerMoving = 9;
    int maxWhen = (1 << 63) - 1;
    bool verifyTimers = false;
    void timeSleep(int64_t ns)
    {
        if(ns <= 0)
        {
            return;
        }
        auto gp = getg();
        auto t = gp->timer;
        if(t == nullptr)
        {
            t = go_new(timer);
            gp->timer = t;
        }
        t->f = goroutineReady;
        t->arg = gp;
        t->nextwhen = nanotime() + ns;
        if(t->nextwhen < 0)
        {
            t->nextwhen = maxWhen;
        }
        gopark(resetForSleep, Pointer(gocpp::recv(unsafe), t), waitReasonSleep, traceBlockSleep, 1);
    }

    bool resetForSleep(g* gp, unsafe::Pointer ut)
    {
        auto t = (timer*)(ut);
        resettimer(t, t->nextwhen);
        return true;
    }

    void startTimer(timer* t)
    {
        if(raceenabled)
        {
            racerelease(Pointer(gocpp::recv(unsafe), t));
        }
        addtimer(t);
    }

    bool stopTimer(timer* t)
    {
        return deltimer(t);
    }

    bool resetTimer(timer* t, int64_t when)
    {
        if(raceenabled)
        {
            racerelease(Pointer(gocpp::recv(unsafe), t));
        }
        return resettimer(t, when);
    }

    void modTimer(timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq)
    {
        modtimer(t, when, period, f, arg, seq);
    }

    void goroutineReady(go_any arg, uintptr_t seq)
    {
        goready(gocpp::getValue<runtime.g*>(arg), 0);
    }

    void addtimer(timer* t)
    {
        if(t->when <= 0)
        {
            go_throw("timer when must be positive");
        }
        if(t->period < 0)
        {
            go_throw("timer period must be non-negative");
        }
        if(Load(gocpp::recv(t->status)) != timerNoStatus)
        {
            go_throw("addtimer called with initialized timer");
        }
        Store(gocpp::recv(t->status), timerWaiting);
        auto when = t->when;
        auto mp = acquirem();
        auto pp = ptr(gocpp::recv(getg()->m->p));
        lock(& pp->timersLock);
        cleantimers(pp);
        doaddtimer(pp, t);
        unlock(& pp->timersLock);
        wakeNetPoller(when);
        releasem(mp);
    }

    void doaddtimer(p* pp, timer* t)
    {
        if(Load(gocpp::recv(netpollInited)) == 0)
        {
            netpollGenericInit();
        }
        if(t->pp != 0)
        {
            go_throw("doaddtimer: P already set in timer");
        }
        set(gocpp::recv(t->pp), pp);
        auto i = len(pp->timers);
        pp->timers = append(pp->timers, t);
        siftupTimer(pp->timers, i);
        if(t == pp->timers[0])
        {
            Store(gocpp::recv(pp->timer0When), t->when);
        }
        Add(gocpp::recv(pp->numTimers), 1);
    }

    bool deltimer(timer* t)
    {
        for(; ; )
        {
            //Go switch emulation
            {
                auto s = Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerWaiting) { conditionId = 0; }
                if(condition == timerModifiedLater) { conditionId = 1; }
                else if(condition == timerModifiedEarlier) { conditionId = 2; }
                else if(condition == timerDeleted) { conditionId = 3; }
                else if(condition == timerRemoving) { conditionId = 4; }
                else if(condition == timerRemoved) { conditionId = 5; }
                else if(condition == timerRunning) { conditionId = 6; }
                else if(condition == timerMoving) { conditionId = 7; }
                else if(condition == timerNoStatus) { conditionId = 8; }
                else if(condition == timerModifying) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        auto mp = acquirem();
                        if(CompareAndSwap(gocpp::recv(t->status), s, timerModifying))
                        {
                            auto tpp = ptr(gocpp::recv(t->pp));
                            if(! CompareAndSwap(gocpp::recv(t->status), timerModifying, timerDeleted))
                            {
                                badTimer();
                            }
                            releasem(mp);
                            Add(gocpp::recv(tpp->deletedTimers), 1);
                            return true;
                        }
                        else
                        {
                            releasem(mp);
                        }
                        break;
                    case 2:
                        auto mp = acquirem();
                        if(CompareAndSwap(gocpp::recv(t->status), s, timerModifying))
                        {
                            auto tpp = ptr(gocpp::recv(t->pp));
                            if(! CompareAndSwap(gocpp::recv(t->status), timerModifying, timerDeleted))
                            {
                                badTimer();
                            }
                            releasem(mp);
                            Add(gocpp::recv(tpp->deletedTimers), 1);
                            return true;
                        }
                        else
                        {
                            releasem(mp);
                        }
                        break;
                    case 3:
                    case 4:
                    case 5:
                        return false;
                        break;
                    case 6:
                    case 7:
                        osyield();
                        break;
                    case 8:
                        return false;
                        break;
                    case 9:
                        osyield();
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
        }
    }

    int dodeltimer(p* pp, int i)
    {
        if(auto t = pp->timers[i]; ptr(gocpp::recv(t->pp)) != pp)
        {
            go_throw("dodeltimer: wrong P");
        }
        else
        {
            t->pp = 0;
        }
        auto last = len(pp->timers) - 1;
        if(i != last)
        {
            pp->timers[i] = pp->timers[last];
        }
        pp->timers[last] = nullptr;
        pp->timers = pp->timers.make_slice(0, last);
        auto smallestChanged = i;
        if(i != last)
        {
            smallestChanged = siftupTimer(pp->timers, i);
            siftdownTimer(pp->timers, i);
        }
        if(i == 0)
        {
            updateTimer0When(pp);
        }
        auto n = Add(gocpp::recv(pp->numTimers), - 1);
        if(n == 0)
        {
            Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        }
        return smallestChanged;
    }

    void dodeltimer0(p* pp)
    {
        if(auto t = pp->timers[0]; ptr(gocpp::recv(t->pp)) != pp)
        {
            go_throw("dodeltimer0: wrong P");
        }
        else
        {
            t->pp = 0;
        }
        auto last = len(pp->timers) - 1;
        if(last > 0)
        {
            pp->timers[0] = pp->timers[last];
        }
        pp->timers[last] = nullptr;
        pp->timers = pp->timers.make_slice(0, last);
        if(last > 0)
        {
            siftdownTimer(pp->timers, 0);
        }
        updateTimer0When(pp);
        auto n = Add(gocpp::recv(pp->numTimers), - 1);
        if(n == 0)
        {
            Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        }
    }

    bool modtimer(timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq)
    {
        if(when <= 0)
        {
            go_throw("timer when must be positive");
        }
        if(period < 0)
        {
            go_throw("timer period must be non-negative");
        }
        auto status = uint32_t(timerNoStatus);
        auto wasRemoved = false;
        bool pending = {};
        m* mp = {};
        for(; ; )
        {
            //Go switch emulation
            {
                status = Load(gocpp::recv(t->status));
                auto condition = status;
                int conditionId = -1;
                if(condition == timerWaiting) { conditionId = 0; }
                if(condition == timerModifiedEarlier) { conditionId = 1; }
                if(condition == timerModifiedLater) { conditionId = 2; }
                else if(condition == timerNoStatus) { conditionId = 3; }
                else if(condition == timerRemoved) { conditionId = 4; }
                else if(condition == timerDeleted) { conditionId = 5; }
                else if(condition == timerRunning) { conditionId = 6; }
                else if(condition == timerRemoving) { conditionId = 7; }
                else if(condition == timerMoving) { conditionId = 8; }
                else if(condition == timerModifying) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                        mp = acquirem();
                        if(CompareAndSwap(gocpp::recv(t->status), status, timerModifying))
                        {
                            pending = true;
                            goto loop_break;
                        }
                        releasem(mp);
                        break;
                    case 3:
                    case 4:
                        mp = acquirem();
                        if(CompareAndSwap(gocpp::recv(t->status), status, timerModifying))
                        {
                            wasRemoved = true;
                            pending = false;
                            goto loop_break;
                        }
                        releasem(mp);
                        break;
                    case 5:
                        mp = acquirem();
                        if(CompareAndSwap(gocpp::recv(t->status), status, timerModifying))
                        {
                            Add(gocpp::recv(ptr(gocpp::recv(t->pp))->deletedTimers), - 1);
                            pending = false;
                            goto loop_break;
                        }
                        releasem(mp);
                        break;
                    case 6:
                    case 7:
                    case 8:
                        osyield();
                        break;
                    case 9:
                        osyield();
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
            if(false) {
            loop_continue:
                continue;
            loop_break:
                break;
            }
        }
        t->period = period;
        t->f = f;
        t->arg = arg;
        t->seq = seq;
        if(wasRemoved)
        {
            t->when = when;
            auto pp = ptr(gocpp::recv(getg()->m->p));
            lock(& pp->timersLock);
            doaddtimer(pp, t);
            unlock(& pp->timersLock);
            if(! CompareAndSwap(gocpp::recv(t->status), timerModifying, timerWaiting))
            {
                badTimer();
            }
            releasem(mp);
            wakeNetPoller(when);
        }
        else
        {
            t->nextwhen = when;
            auto newStatus = uint32_t(timerModifiedLater);
            if(when < t->when)
            {
                newStatus = timerModifiedEarlier;
            }
            auto tpp = ptr(gocpp::recv(t->pp));
            if(newStatus == timerModifiedEarlier)
            {
                updateTimerModifiedEarliest(tpp, when);
            }
            if(! CompareAndSwap(gocpp::recv(t->status), timerModifying, newStatus))
            {
                badTimer();
            }
            releasem(mp);
            if(newStatus == timerModifiedEarlier)
            {
                wakeNetPoller(when);
            }
        }
        return pending;
    }

    bool resettimer(timer* t, int64_t when)
    {
        return modtimer(t, when, t->period, t->f, t->arg, t->seq);
    }

    void cleantimers(p* pp)
    {
        auto gp = getg();
        for(; ; )
        {
            if(len(pp->timers) == 0)
            {
                return;
            }
            if(gp->preemptStop)
            {
                return;
            }
            auto t = pp->timers[0];
            if(ptr(gocpp::recv(t->pp)) != pp)
            {
                go_throw("cleantimers: bad p");
            }
            //Go switch emulation
            {
                auto s = Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerDeleted) { conditionId = 0; }
                else if(condition == timerModifiedEarlier) { conditionId = 1; }
                else if(condition == timerModifiedLater) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        if(! CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                        {
                            continue;
                        }
                        dodeltimer0(pp);
                        if(! CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                        {
                            badTimer();
                        }
                        Add(gocpp::recv(pp->deletedTimers), - 1);
                        break;
                    case 1:
                    case 2:
                        if(! CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                        {
                            continue;
                        }
                        t->when = t->nextwhen;
                        dodeltimer0(pp);
                        doaddtimer(pp, t);
                        if(! CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                        {
                            badTimer();
                        }
                        break;
                    default:
                        return;
                        break;
                }
            }
        }
    }

    void moveTimers(p* pp, gocpp::slice<timer*> timers)
    {
        for(auto [_, t] : timers)
        {
            for(; ; )
            {
                //Go switch emulation
                {
                    auto s = Load(gocpp::recv(t->status));
                    auto condition = s;
                    int conditionId = -1;
                    if(condition == timerWaiting) { conditionId = 0; }
                    else if(condition == timerModifiedEarlier) { conditionId = 1; }
                    else if(condition == timerModifiedLater) { conditionId = 2; }
                    else if(condition == timerDeleted) { conditionId = 3; }
                    else if(condition == timerModifying) { conditionId = 4; }
                    else if(condition == timerNoStatus) { conditionId = 5; }
                    else if(condition == timerRemoved) { conditionId = 6; }
                    else if(condition == timerRunning) { conditionId = 7; }
                    else if(condition == timerRemoving) { conditionId = 8; }
                    else if(condition == timerMoving) { conditionId = 9; }
                    switch(conditionId)
                    {
                        case 0:
                            if(! CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                            {
                                continue;
                            }
                            t->pp = 0;
                            doaddtimer(pp, t);
                            if(! CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                            {
                                badTimer();
                            }
                            goto loop_break;
                            break;
                        case 1:
                        case 2:
                            if(! CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                            {
                                continue;
                            }
                            t->when = t->nextwhen;
                            t->pp = 0;
                            doaddtimer(pp, t);
                            if(! CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                            {
                                badTimer();
                            }
                            goto loop_break;
                            break;
                        case 3:
                            if(! CompareAndSwap(gocpp::recv(t->status), s, timerRemoved))
                            {
                                continue;
                            }
                            t->pp = 0;
                            goto loop_break;
                            break;
                        case 4:
                            osyield();
                            break;
                        case 5:
                        case 6:
                            badTimer();
                            break;
                        case 7:
                        case 8:
                        case 9:
                            badTimer();
                            break;
                        default:
                            badTimer();
                            break;
                    }
                }
                if(false) {
                loop_continue:
                    continue;
                loop_break:
                    break;
                }
            }
        }
    }

    void adjusttimers(p* pp, int64_t now)
    {
        auto first = Load(gocpp::recv(pp->timerModifiedEarliest));
        if(first == 0 || first > now)
        {
            if(verifyTimers)
            {
                verifyTimerHeap(pp);
            }
            return;
        }
        Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        gocpp::slice<timer*> moved = {};
        for(auto i = 0; i < len(pp->timers); i++)
        {
            auto t = pp->timers[i];
            if(ptr(gocpp::recv(t->pp)) != pp)
            {
                go_throw("adjusttimers: bad p");
            }
            //Go switch emulation
            {
                auto s = Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerDeleted) { conditionId = 0; }
                else if(condition == timerModifiedEarlier) { conditionId = 1; }
                else if(condition == timerModifiedLater) { conditionId = 2; }
                else if(condition == timerNoStatus) { conditionId = 3; }
                else if(condition == timerRunning) { conditionId = 4; }
                else if(condition == timerRemoving) { conditionId = 5; }
                else if(condition == timerRemoved) { conditionId = 6; }
                else if(condition == timerMoving) { conditionId = 7; }
                else if(condition == timerWaiting) { conditionId = 8; }
                else if(condition == timerModifying) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                        if(CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                        {
                            auto changed = dodeltimer(pp, i);
                            if(! CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                            {
                                badTimer();
                            }
                            Add(gocpp::recv(pp->deletedTimers), - 1);
                            i = changed - 1;
                        }
                        break;
                    case 1:
                    case 2:
                        if(CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                        {
                            t->when = t->nextwhen;
                            auto changed = dodeltimer(pp, i);
                            moved = append(moved, t);
                            i = changed - 1;
                        }
                        break;
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        badTimer();
                        break;
                    case 8:
                        break;
                    case 9:
                        osyield();
                        i--;
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
        }
        if(len(moved) > 0)
        {
            addAdjustedTimers(pp, moved);
        }
        if(verifyTimers)
        {
            verifyTimerHeap(pp);
        }
    }

    void addAdjustedTimers(p* pp, gocpp::slice<timer*> moved)
    {
        for(auto [_, t] : moved)
        {
            doaddtimer(pp, t);
            if(! CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
            {
                badTimer();
            }
        }
    }

    int64_t nobarrierWakeTime(p* pp)
    {
        auto next = Load(gocpp::recv(pp->timer0When));
        auto nextAdj = Load(gocpp::recv(pp->timerModifiedEarliest));
        if(next == 0 || (nextAdj != 0 && nextAdj < next))
        {
            next = nextAdj;
        }
        return next;
    }

    int64_t runtimer(p* pp, int64_t now)
    {
        for(; ; )
        {
            auto t = pp->timers[0];
            if(ptr(gocpp::recv(t->pp)) != pp)
            {
                go_throw("runtimer: bad p");
            }
            //Go switch emulation
            {
                auto s = Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerWaiting) { conditionId = 0; }
                else if(condition == timerDeleted) { conditionId = 1; }
                else if(condition == timerModifiedEarlier) { conditionId = 2; }
                else if(condition == timerModifiedLater) { conditionId = 3; }
                else if(condition == timerModifying) { conditionId = 4; }
                else if(condition == timerNoStatus) { conditionId = 5; }
                else if(condition == timerRemoved) { conditionId = 6; }
                else if(condition == timerRunning) { conditionId = 7; }
                else if(condition == timerRemoving) { conditionId = 8; }
                else if(condition == timerMoving) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                        if(t->when > now)
                        {
                            return t->when;
                        }
                        if(! CompareAndSwap(gocpp::recv(t->status), s, timerRunning))
                        {
                            continue;
                        }
                        runOneTimer(pp, t, now);
                        return 0;
                        break;
                    case 1:
                        if(! CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                        {
                            continue;
                        }
                        dodeltimer0(pp);
                        if(! CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                        {
                            badTimer();
                        }
                        Add(gocpp::recv(pp->deletedTimers), - 1);
                        if(len(pp->timers) == 0)
                        {
                            return - 1;
                        }
                        break;
                    case 2:
                    case 3:
                        if(! CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                        {
                            continue;
                        }
                        t->when = t->nextwhen;
                        dodeltimer0(pp);
                        doaddtimer(pp, t);
                        if(! CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                        {
                            badTimer();
                        }
                        break;
                    case 4:
                        osyield();
                        break;
                    case 5:
                    case 6:
                        badTimer();
                        break;
                    case 7:
                    case 8:
                    case 9:
                        badTimer();
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
        }
    }

    void runOneTimer(p* pp, timer* t, int64_t now)
    {
        if(raceenabled)
        {
            auto ppcur = ptr(gocpp::recv(getg()->m->p));
            if(ppcur->timerRaceCtx == 0)
            {
                ppcur->timerRaceCtx = racegostart(FuncPCABIInternal(gocpp::recv(abi), runtimer) + sys.PCQuantum);
            }
            raceacquirectx(ppcur->timerRaceCtx, Pointer(gocpp::recv(unsafe), t));
        }
        auto f = t->f;
        auto arg = t->arg;
        auto seq = t->seq;
        if(t->period > 0)
        {
            auto delta = t->when - now;
            t->when += t->period * (1 + - delta / t->period);
            if(t->when < 0)
            {
                t->when = maxWhen;
            }
            siftdownTimer(pp->timers, 0);
            if(! CompareAndSwap(gocpp::recv(t->status), timerRunning, timerWaiting))
            {
                badTimer();
            }
            updateTimer0When(pp);
        }
        else
        {
            dodeltimer0(pp);
            if(! CompareAndSwap(gocpp::recv(t->status), timerRunning, timerNoStatus))
            {
                badTimer();
            }
        }
        if(raceenabled)
        {
            auto gp = getg();
            if(gp->racectx != 0)
            {
                go_throw("runOneTimer: unexpected racectx");
            }
            gp->racectx = ptr(gocpp::recv(gp->m->p))->timerRaceCtx;
        }
        unlock(& pp->timersLock);
        f(arg, seq);
        lock(& pp->timersLock);
        if(raceenabled)
        {
            auto gp = getg();
            gp->racectx = 0;
        }
    }

    void clearDeletedTimers(p* pp)
    {
        Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        auto cdel = int32(0);
        auto to = 0;
        auto changedHeap = false;
        auto timers = pp->timers;
        for(auto [_, t] : timers)
        {
            for(; ; )
            {
                //Go switch emulation
                {
                    auto s = Load(gocpp::recv(t->status));
                    auto condition = s;
                    int conditionId = -1;
                    if(condition == timerWaiting) { conditionId = 0; }
                    else if(condition == timerModifiedEarlier) { conditionId = 1; }
                    else if(condition == timerModifiedLater) { conditionId = 2; }
                    else if(condition == timerDeleted) { conditionId = 3; }
                    else if(condition == timerModifying) { conditionId = 4; }
                    else if(condition == timerNoStatus) { conditionId = 5; }
                    else if(condition == timerRemoved) { conditionId = 6; }
                    else if(condition == timerRunning) { conditionId = 7; }
                    else if(condition == timerRemoving) { conditionId = 8; }
                    else if(condition == timerMoving) { conditionId = 9; }
                    switch(conditionId)
                    {
                        case 0:
                            if(changedHeap)
                            {
                                timers[to] = t;
                                siftupTimer(timers, to);
                            }
                            to++;
                            goto nextTimer_continue;
                            break;
                        case 1:
                        case 2:
                            if(CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                            {
                                t->when = t->nextwhen;
                                timers[to] = t;
                                siftupTimer(timers, to);
                                to++;
                                changedHeap = true;
                                if(! CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                                {
                                    badTimer();
                                }
                                goto nextTimer_continue;
                            }
                            break;
                        case 3:
                            if(CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                            {
                                t->pp = 0;
                                cdel++;
                                if(! CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                                {
                                    badTimer();
                                }
                                changedHeap = true;
                                goto nextTimer_continue;
                            }
                            break;
                        case 4:
                            osyield();
                            break;
                        case 5:
                        case 6:
                            badTimer();
                            break;
                        case 7:
                        case 8:
                        case 9:
                            badTimer();
                            break;
                        default:
                            badTimer();
                            break;
                    }
                }
            }
            if(false) {
            nextTimer_continue:
                continue;
            nextTimer_break:
                break;
            }
        }
        for(auto i = to; i < len(timers); i++)
        {
            timers[i] = nullptr;
        }
        Add(gocpp::recv(pp->deletedTimers), - cdel);
        Add(gocpp::recv(pp->numTimers), - cdel);
        timers = timers.make_slice(0, to);
        pp->timers = timers;
        updateTimer0When(pp);
        if(verifyTimers)
        {
            verifyTimerHeap(pp);
        }
    }

    void verifyTimerHeap(p* pp)
    {
        for(auto [i, t] : pp->timers)
        {
            if(i == 0)
            {
                continue;
            }
            auto p = (i - 1) / 4;
            if(t->when < pp->timers[p]->when)
            {
                print("bad timer heap at ", i, ": ", p, ": ", pp->timers[p]->when, ", ", i, ": ", t->when, "\n");
                go_throw("bad timer heap");
            }
        }
        if(auto numTimers = int(Load(gocpp::recv(pp->numTimers))); len(pp->timers) != numTimers)
        {
            println("timer heap len", len(pp->timers), "!= numTimers", numTimers);
            go_throw("bad timer heap len");
        }
    }

    void updateTimer0When(p* pp)
    {
        if(len(pp->timers) == 0)
        {
            Store(gocpp::recv(pp->timer0When), 0);
        }
        else
        {
            Store(gocpp::recv(pp->timer0When), pp->timers[0]->when);
        }
    }

    void updateTimerModifiedEarliest(p* pp, int64_t nextwhen)
    {
        for(; ; )
        {
            auto old = Load(gocpp::recv(pp->timerModifiedEarliest));
            if(old != 0 && old < nextwhen)
            {
                return;
            }
            if(CompareAndSwap(gocpp::recv(pp->timerModifiedEarliest), old, nextwhen))
            {
                return;
            }
        }
    }

    int64_t timeSleepUntil()
    {
        auto next = int64(maxWhen);
        lock(& allpLock);
        for(auto [_, pp] : allp)
        {
            if(pp == nullptr)
            {
                continue;
            }
            auto w = Load(gocpp::recv(pp->timer0When));
            if(w != 0 && w < next)
            {
                next = w;
            }
            w = Load(gocpp::recv(pp->timerModifiedEarliest));
            if(w != 0 && w < next)
            {
                next = w;
            }
        }
        unlock(& allpLock);
        return next;
    }

    int siftupTimer(gocpp::slice<timer*> t, int i)
    {
        if(i >= len(t))
        {
            badTimer();
        }
        auto when = t[i]->when;
        if(when <= 0)
        {
            badTimer();
        }
        auto tmp = t[i];
        for(; i > 0; )
        {
            auto p = (i - 1) / 4;
            if(when >= t[p]->when)
            {
                break;
            }
            t[i] = t[p];
            i = p;
        }
        if(tmp != t[i])
        {
            t[i] = tmp;
        }
        return i;
    }

    void siftdownTimer(gocpp::slice<timer*> t, int i)
    {
        auto n = len(t);
        if(i >= n)
        {
            badTimer();
        }
        auto when = t[i]->when;
        if(when <= 0)
        {
            badTimer();
        }
        auto tmp = t[i];
        for(; ; )
        {
            auto c = i * 4 + 1;
            auto c3 = c + 2;
            if(c >= n)
            {
                break;
            }
            auto w = t[c]->when;
            if(c + 1 < n && t[c + 1]->when < w)
            {
                w = t[c + 1]->when;
                c++;
            }
            if(c3 < n)
            {
                auto w3 = t[c3]->when;
                if(c3 + 1 < n && t[c3 + 1]->when < w3)
                {
                    w3 = t[c3 + 1]->when;
                    c3++;
                }
                if(w3 < w)
                {
                    w = w3;
                    c = c3;
                }
            }
            if(w >= when)
            {
                break;
            }
            t[i] = t[c];
            i = c;
        }
        if(tmp != t[i])
        {
            t[i] = tmp;
        }
    }

    void badTimer()
    {
        go_throw("timer data corruption");
    }

}

