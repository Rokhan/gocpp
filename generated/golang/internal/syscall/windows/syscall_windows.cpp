// generated by GoCpp from file '$(ImportDir)/internal/syscall/windows/syscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/syscall/windows/syscall_windows.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/zsyscall_windows.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::windows
{
    namespace rec
    {
        using namespace mocklib::rec;
        using sync::rec::Do;
        using syscall::rec::Find;
    }

    std::string UTF16PtrToString(uint16_t* p)
    {
        if(p == nullptr)
        {
            return "";
        }
        auto end = unsafe::Pointer(p);
        auto n = 0;
        for(; *(uint16_t*)(end) != 0; )
        {
            end = unsafe::Pointer(uintptr_t(end) + gocpp::Sizeof<uint16_t>());
            n++;
        }
        return syscall::UTF16ToString(unsafe::Slice(p, n));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SocketAddress::operator T()
    {
        T result;
        result.Sockaddr = this->Sockaddr;
        result.SockaddrLength = this->SockaddrLength;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SocketAddress::operator==(const T& ref) const
    {
        if (Sockaddr != ref.Sockaddr) return false;
        if (SockaddrLength != ref.SockaddrLength) return false;
        return true;
    }

    std::ostream& SocketAddress::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Sockaddr;
        os << " " << SockaddrLength;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SocketAddress& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterUnicastAddress::operator T()
    {
        T result;
        result.Length = this->Length;
        result.Flags = this->Flags;
        result.Next = this->Next;
        result.Address = this->Address;
        result.PrefixOrigin = this->PrefixOrigin;
        result.SuffixOrigin = this->SuffixOrigin;
        result.DadState = this->DadState;
        result.ValidLifetime = this->ValidLifetime;
        result.PreferredLifetime = this->PreferredLifetime;
        result.LeaseLifetime = this->LeaseLifetime;
        result.OnLinkPrefixLength = this->OnLinkPrefixLength;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterUnicastAddress::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (Flags != ref.Flags) return false;
        if (Next != ref.Next) return false;
        if (Address != ref.Address) return false;
        if (PrefixOrigin != ref.PrefixOrigin) return false;
        if (SuffixOrigin != ref.SuffixOrigin) return false;
        if (DadState != ref.DadState) return false;
        if (ValidLifetime != ref.ValidLifetime) return false;
        if (PreferredLifetime != ref.PreferredLifetime) return false;
        if (LeaseLifetime != ref.LeaseLifetime) return false;
        if (OnLinkPrefixLength != ref.OnLinkPrefixLength) return false;
        return true;
    }

    std::ostream& IpAdapterUnicastAddress::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << Flags;
        os << " " << Next;
        os << " " << Address;
        os << " " << PrefixOrigin;
        os << " " << SuffixOrigin;
        os << " " << DadState;
        os << " " << ValidLifetime;
        os << " " << PreferredLifetime;
        os << " " << LeaseLifetime;
        os << " " << OnLinkPrefixLength;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterUnicastAddress& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterAnycastAddress::operator T()
    {
        T result;
        result.Length = this->Length;
        result.Flags = this->Flags;
        result.Next = this->Next;
        result.Address = this->Address;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterAnycastAddress::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (Flags != ref.Flags) return false;
        if (Next != ref.Next) return false;
        if (Address != ref.Address) return false;
        return true;
    }

    std::ostream& IpAdapterAnycastAddress::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << Flags;
        os << " " << Next;
        os << " " << Address;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterAnycastAddress& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterMulticastAddress::operator T()
    {
        T result;
        result.Length = this->Length;
        result.Flags = this->Flags;
        result.Next = this->Next;
        result.Address = this->Address;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterMulticastAddress::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (Flags != ref.Flags) return false;
        if (Next != ref.Next) return false;
        if (Address != ref.Address) return false;
        return true;
    }

    std::ostream& IpAdapterMulticastAddress::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << Flags;
        os << " " << Next;
        os << " " << Address;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterMulticastAddress& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterDnsServerAdapter::operator T()
    {
        T result;
        result.Length = this->Length;
        result.Reserved = this->Reserved;
        result.Next = this->Next;
        result.Address = this->Address;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterDnsServerAdapter::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (Reserved != ref.Reserved) return false;
        if (Next != ref.Next) return false;
        if (Address != ref.Address) return false;
        return true;
    }

    std::ostream& IpAdapterDnsServerAdapter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << Reserved;
        os << " " << Next;
        os << " " << Address;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterDnsServerAdapter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterPrefix::operator T()
    {
        T result;
        result.Length = this->Length;
        result.Flags = this->Flags;
        result.Next = this->Next;
        result.Address = this->Address;
        result.PrefixLength = this->PrefixLength;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterPrefix::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (Flags != ref.Flags) return false;
        if (Next != ref.Next) return false;
        if (Address != ref.Address) return false;
        if (PrefixLength != ref.PrefixLength) return false;
        return true;
    }

    std::ostream& IpAdapterPrefix::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << Flags;
        os << " " << Next;
        os << " " << Address;
        os << " " << PrefixLength;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterPrefix& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterAddresses::operator T()
    {
        T result;
        result.Length = this->Length;
        result.IfIndex = this->IfIndex;
        result.Next = this->Next;
        result.AdapterName = this->AdapterName;
        result.FirstUnicastAddress = this->FirstUnicastAddress;
        result.FirstAnycastAddress = this->FirstAnycastAddress;
        result.FirstMulticastAddress = this->FirstMulticastAddress;
        result.FirstDnsServerAddress = this->FirstDnsServerAddress;
        result.DnsSuffix = this->DnsSuffix;
        result.Description = this->Description;
        result.FriendlyName = this->FriendlyName;
        result.PhysicalAddress = this->PhysicalAddress;
        result.PhysicalAddressLength = this->PhysicalAddressLength;
        result.Flags = this->Flags;
        result.Mtu = this->Mtu;
        result.IfType = this->IfType;
        result.OperStatus = this->OperStatus;
        result.Ipv6IfIndex = this->Ipv6IfIndex;
        result.ZoneIndices = this->ZoneIndices;
        result.FirstPrefix = this->FirstPrefix;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterAddresses::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (IfIndex != ref.IfIndex) return false;
        if (Next != ref.Next) return false;
        if (AdapterName != ref.AdapterName) return false;
        if (FirstUnicastAddress != ref.FirstUnicastAddress) return false;
        if (FirstAnycastAddress != ref.FirstAnycastAddress) return false;
        if (FirstMulticastAddress != ref.FirstMulticastAddress) return false;
        if (FirstDnsServerAddress != ref.FirstDnsServerAddress) return false;
        if (DnsSuffix != ref.DnsSuffix) return false;
        if (Description != ref.Description) return false;
        if (FriendlyName != ref.FriendlyName) return false;
        if (PhysicalAddress != ref.PhysicalAddress) return false;
        if (PhysicalAddressLength != ref.PhysicalAddressLength) return false;
        if (Flags != ref.Flags) return false;
        if (Mtu != ref.Mtu) return false;
        if (IfType != ref.IfType) return false;
        if (OperStatus != ref.OperStatus) return false;
        if (Ipv6IfIndex != ref.Ipv6IfIndex) return false;
        if (ZoneIndices != ref.ZoneIndices) return false;
        if (FirstPrefix != ref.FirstPrefix) return false;
        return true;
    }

    std::ostream& IpAdapterAddresses::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << IfIndex;
        os << " " << Next;
        os << " " << AdapterName;
        os << " " << FirstUnicastAddress;
        os << " " << FirstAnycastAddress;
        os << " " << FirstMulticastAddress;
        os << " " << FirstDnsServerAddress;
        os << " " << DnsSuffix;
        os << " " << Description;
        os << " " << FriendlyName;
        os << " " << PhysicalAddress;
        os << " " << PhysicalAddressLength;
        os << " " << Flags;
        os << " " << Mtu;
        os << " " << IfType;
        os << " " << OperStatus;
        os << " " << Ipv6IfIndex;
        os << " " << ZoneIndices;
        os << " " << FirstPrefix;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterAddresses& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SecurityAttributes::operator T()
    {
        T result;
        result.Length = this->Length;
        result.SecurityDescriptor = this->SecurityDescriptor;
        result.InheritHandle = this->InheritHandle;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SecurityAttributes::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (SecurityDescriptor != ref.SecurityDescriptor) return false;
        if (InheritHandle != ref.InheritHandle) return false;
        return true;
    }

    std::ostream& SecurityAttributes::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << SecurityDescriptor;
        os << " " << InheritHandle;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SecurityAttributes& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    FILE_BASIC_INFO::operator T()
    {
        T result;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.ChangedTime = this->ChangedTime;
        result.FileAttributes = this->FileAttributes;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool FILE_BASIC_INFO::operator==(const T& ref) const
    {
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (ChangedTime != ref.ChangedTime) return false;
        if (FileAttributes != ref.FileAttributes) return false;
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& FILE_BASIC_INFO::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << ChangedTime;
        os << " " << FileAttributes;
        os << " " << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FILE_BASIC_INFO& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ModuleEntry32::operator T()
    {
        T result;
        result.Size = this->Size;
        result.ModuleID = this->ModuleID;
        result.ProcessID = this->ProcessID;
        result.GlblcntUsage = this->GlblcntUsage;
        result.ProccntUsage = this->ProccntUsage;
        result.ModBaseAddr = this->ModBaseAddr;
        result.ModBaseSize = this->ModBaseSize;
        result.ModuleHandle = this->ModuleHandle;
        result.Module = this->Module;
        result.ExePath = this->ExePath;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ModuleEntry32::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (ModuleID != ref.ModuleID) return false;
        if (ProcessID != ref.ProcessID) return false;
        if (GlblcntUsage != ref.GlblcntUsage) return false;
        if (ProccntUsage != ref.ProccntUsage) return false;
        if (ModBaseAddr != ref.ModBaseAddr) return false;
        if (ModBaseSize != ref.ModBaseSize) return false;
        if (ModuleHandle != ref.ModuleHandle) return false;
        if (Module != ref.Module) return false;
        if (ExePath != ref.ExePath) return false;
        return true;
    }

    std::ostream& ModuleEntry32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << ModuleID;
        os << " " << ProcessID;
        os << " " << GlblcntUsage;
        os << " " << ProccntUsage;
        os << " " << ModBaseAddr;
        os << " " << ModBaseSize;
        os << " " << ModuleHandle;
        os << " " << Module;
        os << " " << ExePath;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ModuleEntry32& value)
    {
        return value.PrintTo(os);
    }

    syscall::GUID WSAID_WSASENDMSG = gocpp::Init<syscall::GUID>([](auto& x) {
        x.Data1 = 0xa441e712;
        x.Data2 = 0x754f;
        x.Data3 = 0x43ca;
        x.Data4 = gocpp::array<unsigned char, 8> {0x84, 0xa7, 0x0d, 0xee, 0x44, 0xcf, 0x60, 0x6d};
    });
    syscall::GUID WSAID_WSARECVMSG = gocpp::Init<syscall::GUID>([](auto& x) {
        x.Data1 = 0xf689d7c8;
        x.Data2 = 0x6f1f;
        x.Data3 = 0x436b;
        x.Data4 = gocpp::array<unsigned char, 8> {0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22};
    });
    struct gocpp_id_0
    {
        sync::Once once;
        uintptr_t sendAddr;
        uintptr_t recvAddr;
        gocpp::error err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.once = this->once;
            result.sendAddr = this->sendAddr;
            result.recvAddr = this->recvAddr;
            result.err = this->err;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (once != ref.once) return false;
            if (sendAddr != ref.sendAddr) return false;
            if (recvAddr != ref.recvAddr) return false;
            if (err != ref.err) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << once;
            os << " " << sendAddr;
            os << " " << recvAddr;
            os << " " << err;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 sendRecvMsgFunc;
    
    template<typename T> requires gocpp::GoStruct<T>
    WSAMsg::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Namelen = this->Namelen;
        result.Buffers = this->Buffers;
        result.BufferCount = this->BufferCount;
        result.Control = this->Control;
        result.Flags = this->Flags;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WSAMsg::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Namelen != ref.Namelen) return false;
        if (Buffers != ref.Buffers) return false;
        if (BufferCount != ref.BufferCount) return false;
        if (Control != ref.Control) return false;
        if (Flags != ref.Flags) return false;
        return true;
    }

    std::ostream& WSAMsg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Namelen;
        os << " " << Buffers;
        os << " " << BufferCount;
        os << " " << Control;
        os << " " << Flags;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WSAMsg& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp::error loadWSASendRecvMsg()
    {
        rec::Do(gocpp::recv(sendRecvMsgFunc.once), [=]() mutable -> void
        {
            gocpp::Defer defer;
            try
            {
                syscall::Handle s = {};
                std::tie(s, sendRecvMsgFunc.err) = syscall::Socket(syscall::AF_INET, syscall::SOCK_DGRAM, syscall::IPPROTO_UDP);
                if(sendRecvMsgFunc.err != nullptr)
                {
                    return;
                }
                defer.push_back([=]{ syscall::CloseHandle(s); });
                uint32_t n = {};
                sendRecvMsgFunc.err = syscall::WSAIoctl(s, syscall::SIO_GET_EXTENSION_FUNCTION_POINTER, (unsigned char*)(unsafe::Pointer(& WSAID_WSARECVMSG)), uint32_t(gocpp::Sizeof<syscall::GUID>()), (unsigned char*)(unsafe::Pointer(& sendRecvMsgFunc.recvAddr)), uint32_t(gocpp::Sizeof<uintptr_t>()), & n, nullptr, 0);
                if(sendRecvMsgFunc.err != nullptr)
                {
                    return;
                }
                sendRecvMsgFunc.err = syscall::WSAIoctl(s, syscall::SIO_GET_EXTENSION_FUNCTION_POINTER, (unsigned char*)(unsafe::Pointer(& WSAID_WSASENDMSG)), uint32_t(gocpp::Sizeof<syscall::GUID>()), (unsigned char*)(unsafe::Pointer(& sendRecvMsgFunc.sendAddr)), uint32_t(gocpp::Sizeof<uintptr_t>()), & n, nullptr, 0);
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        });
        return sendRecvMsgFunc.err;
    }

    struct gocpp::error WSASendMsg(syscall::Handle fd, struct WSAMsg* msg, uint32_t flags, uint32_t* bytesSent, syscall::Overlapped* overlapped, unsigned char* croutine)
    {
        auto err = loadWSASendRecvMsg();
        if(err != nullptr)
        {
            return err;
        }
        auto [r1, gocpp_id_2, e1] = syscall::Syscall6(sendRecvMsgFunc.sendAddr, 6, uintptr_t(fd), uintptr_t(unsafe::Pointer(msg)), uintptr_t(flags), uintptr_t(unsafe::Pointer(bytesSent)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            if(e1 != 0)
            {
                err = errnoErr(e1);
            }
            else
            {
                err = syscall::go_EINVAL;
            }
        }
        return err;
    }

    struct gocpp::error WSARecvMsg(syscall::Handle fd, struct WSAMsg* msg, uint32_t* bytesReceived, syscall::Overlapped* overlapped, unsigned char* croutine)
    {
        auto err = loadWSASendRecvMsg();
        if(err != nullptr)
        {
            return err;
        }
        auto [r1, gocpp_id_4, e1] = syscall::Syscall6(sendRecvMsgFunc.recvAddr, 5, uintptr_t(fd), uintptr_t(unsafe::Pointer(msg)), uintptr_t(unsafe::Pointer(bytesReceived)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0);
        if(r1 == socket_error)
        {
            if(e1 != 0)
            {
                err = errnoErr(e1);
            }
            else
            {
                err = syscall::go_EINVAL;
            }
        }
        return err;
    }

    struct gocpp::error Rename(std::string oldpath, std::string newpath)
    {
        auto [from, err] = syscall::UTF16PtrFromString(oldpath);
        if(err != nullptr)
        {
            return err;
        }
        uint16_t* to;
        std::tie(to, err) = syscall::UTF16PtrFromString(newpath);
        if(err != nullptr)
        {
            return err;
        }
        return MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SHARE_INFO_2::operator T()
    {
        T result;
        result.Netname = this->Netname;
        result.Type = this->Type;
        result.Remark = this->Remark;
        result.Permissions = this->Permissions;
        result.MaxUses = this->MaxUses;
        result.CurrentUses = this->CurrentUses;
        result.Path = this->Path;
        result.Passwd = this->Passwd;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SHARE_INFO_2::operator==(const T& ref) const
    {
        if (Netname != ref.Netname) return false;
        if (Type != ref.Type) return false;
        if (Remark != ref.Remark) return false;
        if (Permissions != ref.Permissions) return false;
        if (MaxUses != ref.MaxUses) return false;
        if (CurrentUses != ref.CurrentUses) return false;
        if (Path != ref.Path) return false;
        if (Passwd != ref.Passwd) return false;
        return true;
    }

    std::ostream& SHARE_INFO_2::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Netname;
        os << " " << Type;
        os << " " << Remark;
        os << " " << Permissions;
        os << " " << MaxUses;
        os << " " << CurrentUses;
        os << " " << Path;
        os << " " << Passwd;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SHARE_INFO_2& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp::error ErrorLoadingGetTempPath2()
    {
        return rec::Find(gocpp::recv(procGetTempPath2W));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    FILE_ID_BOTH_DIR_INFO::operator T()
    {
        T result;
        result.NextEntryOffset = this->NextEntryOffset;
        result.FileIndex = this->FileIndex;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.ChangeTime = this->ChangeTime;
        result.EndOfFile = this->EndOfFile;
        result.AllocationSize = this->AllocationSize;
        result.FileAttributes = this->FileAttributes;
        result.FileNameLength = this->FileNameLength;
        result.EaSize = this->EaSize;
        result.ShortNameLength = this->ShortNameLength;
        result.ShortName = this->ShortName;
        result.FileID = this->FileID;
        result.FileName = this->FileName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool FILE_ID_BOTH_DIR_INFO::operator==(const T& ref) const
    {
        if (NextEntryOffset != ref.NextEntryOffset) return false;
        if (FileIndex != ref.FileIndex) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (ChangeTime != ref.ChangeTime) return false;
        if (EndOfFile != ref.EndOfFile) return false;
        if (AllocationSize != ref.AllocationSize) return false;
        if (FileAttributes != ref.FileAttributes) return false;
        if (FileNameLength != ref.FileNameLength) return false;
        if (EaSize != ref.EaSize) return false;
        if (ShortNameLength != ref.ShortNameLength) return false;
        if (ShortName != ref.ShortName) return false;
        if (FileID != ref.FileID) return false;
        if (FileName != ref.FileName) return false;
        return true;
    }

    std::ostream& FILE_ID_BOTH_DIR_INFO::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << NextEntryOffset;
        os << " " << FileIndex;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << ChangeTime;
        os << " " << EndOfFile;
        os << " " << AllocationSize;
        os << " " << FileAttributes;
        os << " " << FileNameLength;
        os << " " << EaSize;
        os << " " << ShortNameLength;
        os << " " << ShortName;
        os << " " << FileID;
        os << " " << FileName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FILE_ID_BOTH_DIR_INFO& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    FILE_FULL_DIR_INFO::operator T()
    {
        T result;
        result.NextEntryOffset = this->NextEntryOffset;
        result.FileIndex = this->FileIndex;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.ChangeTime = this->ChangeTime;
        result.EndOfFile = this->EndOfFile;
        result.AllocationSize = this->AllocationSize;
        result.FileAttributes = this->FileAttributes;
        result.FileNameLength = this->FileNameLength;
        result.EaSize = this->EaSize;
        result.FileName = this->FileName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool FILE_FULL_DIR_INFO::operator==(const T& ref) const
    {
        if (NextEntryOffset != ref.NextEntryOffset) return false;
        if (FileIndex != ref.FileIndex) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (ChangeTime != ref.ChangeTime) return false;
        if (EndOfFile != ref.EndOfFile) return false;
        if (AllocationSize != ref.AllocationSize) return false;
        if (FileAttributes != ref.FileAttributes) return false;
        if (FileNameLength != ref.FileNameLength) return false;
        if (EaSize != ref.EaSize) return false;
        if (FileName != ref.FileName) return false;
        return true;
    }

    std::ostream& FILE_FULL_DIR_INFO::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << NextEntryOffset;
        os << " " << FileIndex;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << ChangeTime;
        os << " " << EndOfFile;
        os << " " << AllocationSize;
        os << " " << FileAttributes;
        os << " " << FileNameLength;
        os << " " << EaSize;
        os << " " << FileName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FILE_FULL_DIR_INFO& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SERVICE_STATUS::operator T()
    {
        T result;
        result.ServiceType = this->ServiceType;
        result.CurrentState = this->CurrentState;
        result.ControlsAccepted = this->ControlsAccepted;
        result.Win32ExitCode = this->Win32ExitCode;
        result.ServiceSpecificExitCode = this->ServiceSpecificExitCode;
        result.CheckPoint = this->CheckPoint;
        result.WaitHint = this->WaitHint;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SERVICE_STATUS::operator==(const T& ref) const
    {
        if (ServiceType != ref.ServiceType) return false;
        if (CurrentState != ref.CurrentState) return false;
        if (ControlsAccepted != ref.ControlsAccepted) return false;
        if (Win32ExitCode != ref.Win32ExitCode) return false;
        if (ServiceSpecificExitCode != ref.ServiceSpecificExitCode) return false;
        if (CheckPoint != ref.CheckPoint) return false;
        if (WaitHint != ref.WaitHint) return false;
        return true;
    }

    std::ostream& SERVICE_STATUS::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ServiceType;
        os << " " << CurrentState;
        os << " " << ControlsAccepted;
        os << " " << Win32ExitCode;
        os << " " << ServiceSpecificExitCode;
        os << " " << CheckPoint;
        os << " " << WaitHint;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SERVICE_STATUS& value)
    {
        return value.PrintTo(os);
    }

}

