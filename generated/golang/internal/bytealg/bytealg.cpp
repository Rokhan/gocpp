// generated by GoCpp from file '$(ImportDir)/internal/bytealg/bytealg.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/bytealg/bytealg.h"
#include "gocpp/support.h"

#include "golang/internal/cpu/cpu.h"

namespace golang::bytealg
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Offsets into internal/cpu records for use in assembly.
    // MaxLen is the maximum length of the string to be searched for (argument b) in Index.
    // If MaxLen is not 0, make sure MaxLen >= 4.
    int MaxLen;
    // PrimeRK is the prime base used in Rabin-Karp algorithm.
    // HashStr returns the hash and the appropriate multiplicative
    // factor for use in Rabin-Karp algorithm.
    template<typename T>
    std::tuple<uint32_t, uint32_t> HashStr(T sep)
    {
        auto hash = uint32_t(0);
        for(auto i = 0; i < len(sep); i++)
        {
            hash = hash * PrimeRK + uint32_t(sep[i]);
        }
        uint32_t pow = 1;
        uint32_t sq = PrimeRK;
        for(auto i = len(sep); i > 0; i >>= 1)
        {
            if(i & 1 != 0)
            {
                pow *= sq;
            }
            sq *= sq;
        }
        return {hash, pow};
    }

    // HashStrRev returns the hash of the reverse of sep and the
    // appropriate multiplicative factor for use in Rabin-Karp algorithm.
    template<typename T>
    std::tuple<uint32_t, uint32_t> HashStrRev(T sep)
    {
        auto hash = uint32_t(0);
        for(auto i = len(sep) - 1; i >= 0; i--)
        {
            hash = hash * PrimeRK + uint32_t(sep[i]);
        }
        uint32_t pow = 1;
        uint32_t sq = PrimeRK;
        for(auto i = len(sep); i > 0; i >>= 1)
        {
            if(i & 1 != 0)
            {
                pow *= sq;
            }
            sq *= sq;
        }
        return {hash, pow};
    }

    // IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the
    // first occurrence of sep in s, or -1 if not present.
    template<typename T>
    int IndexRabinKarp(T s, T sep)
    {
        auto [hashss, pow] = HashStr(sep);
        auto n = len(sep);
        uint32_t h = {};
        for(auto i = 0; i < n; i++)
        {
            h = h * PrimeRK + uint32_t(s[i]);
        }
        if(h == hashss && std::string(s.make_slice(0, n)) == std::string(sep))
        {
            return 0;
        }
        for(auto i = n; i < len(s); )
        {
            h *= PrimeRK;
            h += uint32_t(s[i]);
            h -= pow * uint32_t(s[i - n]);
            i++;
            if(h == hashss && std::string(s.make_slice(i - n, i)) == std::string(sep))
            {
                return i - n;
            }
        }
        return - 1;
    }

    // LastIndexRabinKarp uses the Rabin-Karp search algorithm to return the last index of the
    // occurrence of sep in s, or -1 if not present.
    template<typename T>
    int LastIndexRabinKarp(T s, T sep)
    {
        auto [hashss, pow] = HashStrRev(sep);
        auto n = len(sep);
        auto last = len(s) - n;
        uint32_t h = {};
        for(auto i = len(s) - 1; i >= last; i--)
        {
            h = h * PrimeRK + uint32_t(s[i]);
        }
        if(h == hashss && std::string(s.make_slice(last)) == std::string(sep))
        {
            return last;
        }
        for(auto i = last - 1; i >= 0; i--)
        {
            h *= PrimeRK;
            h += uint32_t(s[i]);
            h -= pow * uint32_t(s[i + n]);
            if(h == hashss && std::string(s.make_slice(i, i + n)) == std::string(sep))
            {
                return i;
            }
        }
        return - 1;
    }

    // MakeNoZero makes a slice of length and capacity n without zeroing the bytes.
    // It is the caller's responsibility to ensure uninitialized bytes
    // do not leak to the end user.
    gocpp::slice<unsigned char> MakeNoZero(int n)
    /* convertBlockStmt, nil block */;

}

