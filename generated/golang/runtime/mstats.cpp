// generated by GoCpp from file '$(ImportDir)/runtime/mstats.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mstats.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::Load;
        using atomic::rec::Swap;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mstats::operator T()
    {
        T result;
        result.heapStats = this->heapStats;
        result.stacks_sys = this->stacks_sys;
        result.mspan_sys = this->mspan_sys;
        result.mcache_sys = this->mcache_sys;
        result.buckhash_sys = this->buckhash_sys;
        result.gcMiscSys = this->gcMiscSys;
        result.other_sys = this->other_sys;
        result.last_gc_unix = this->last_gc_unix;
        result.pause_total_ns = this->pause_total_ns;
        result.pause_ns = this->pause_ns;
        result.pause_end = this->pause_end;
        result.numgc = this->numgc;
        result.numforcedgc = this->numforcedgc;
        result.gc_cpu_fraction = this->gc_cpu_fraction;
        result.last_gc_nanotime = this->last_gc_nanotime;
        result.lastHeapInUse = this->lastHeapInUse;
        result.enablegc = this->enablegc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mstats::operator==(const T& ref) const
    {
        if (heapStats != ref.heapStats) return false;
        if (stacks_sys != ref.stacks_sys) return false;
        if (mspan_sys != ref.mspan_sys) return false;
        if (mcache_sys != ref.mcache_sys) return false;
        if (buckhash_sys != ref.buckhash_sys) return false;
        if (gcMiscSys != ref.gcMiscSys) return false;
        if (other_sys != ref.other_sys) return false;
        if (last_gc_unix != ref.last_gc_unix) return false;
        if (pause_total_ns != ref.pause_total_ns) return false;
        if (pause_ns != ref.pause_ns) return false;
        if (pause_end != ref.pause_end) return false;
        if (numgc != ref.numgc) return false;
        if (numforcedgc != ref.numforcedgc) return false;
        if (gc_cpu_fraction != ref.gc_cpu_fraction) return false;
        if (last_gc_nanotime != ref.last_gc_nanotime) return false;
        if (lastHeapInUse != ref.lastHeapInUse) return false;
        if (enablegc != ref.enablegc) return false;
        return true;
    }

    std::ostream& mstats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heapStats;
        os << " " << stacks_sys;
        os << " " << mspan_sys;
        os << " " << mcache_sys;
        os << " " << buckhash_sys;
        os << " " << gcMiscSys;
        os << " " << other_sys;
        os << " " << last_gc_unix;
        os << " " << pause_total_ns;
        os << " " << pause_ns;
        os << " " << pause_end;
        os << " " << numgc;
        os << " " << numforcedgc;
        os << " " << gc_cpu_fraction;
        os << " " << last_gc_nanotime;
        os << " " << lastHeapInUse;
        os << " " << enablegc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mstats& value)
    {
        return value.PrintTo(os);
    }

    mstats memstats;
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.Size = this->Size;
        result.Mallocs = this->Mallocs;
        result.Frees = this->Frees;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (Mallocs != ref.Mallocs) return false;
        if (Frees != ref.Frees) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << Mallocs;
        os << " " << Frees;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // A MemStats records statistics about the memory allocator.
    
    template<typename T> requires gocpp::GoStruct<T>
    MemStats::operator T()
    {
        T result;
        result.Alloc = this->Alloc;
        result.TotalAlloc = this->TotalAlloc;
        result.Sys = this->Sys;
        result.Lookups = this->Lookups;
        result.Mallocs = this->Mallocs;
        result.Frees = this->Frees;
        result.HeapAlloc = this->HeapAlloc;
        result.HeapSys = this->HeapSys;
        result.HeapIdle = this->HeapIdle;
        result.HeapInuse = this->HeapInuse;
        result.HeapReleased = this->HeapReleased;
        result.HeapObjects = this->HeapObjects;
        result.StackInuse = this->StackInuse;
        result.StackSys = this->StackSys;
        result.MSpanInuse = this->MSpanInuse;
        result.MSpanSys = this->MSpanSys;
        result.MCacheInuse = this->MCacheInuse;
        result.MCacheSys = this->MCacheSys;
        result.BuckHashSys = this->BuckHashSys;
        result.GCSys = this->GCSys;
        result.OtherSys = this->OtherSys;
        result.NextGC = this->NextGC;
        result.LastGC = this->LastGC;
        result.PauseTotalNs = this->PauseTotalNs;
        result.PauseNs = this->PauseNs;
        result.PauseEnd = this->PauseEnd;
        result.NumGC = this->NumGC;
        result.NumForcedGC = this->NumForcedGC;
        result.GCCPUFraction = this->GCCPUFraction;
        result.EnableGC = this->EnableGC;
        result.DebugGC = this->DebugGC;
        result.BySize = this->BySize;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool MemStats::operator==(const T& ref) const
    {
        if (Alloc != ref.Alloc) return false;
        if (TotalAlloc != ref.TotalAlloc) return false;
        if (Sys != ref.Sys) return false;
        if (Lookups != ref.Lookups) return false;
        if (Mallocs != ref.Mallocs) return false;
        if (Frees != ref.Frees) return false;
        if (HeapAlloc != ref.HeapAlloc) return false;
        if (HeapSys != ref.HeapSys) return false;
        if (HeapIdle != ref.HeapIdle) return false;
        if (HeapInuse != ref.HeapInuse) return false;
        if (HeapReleased != ref.HeapReleased) return false;
        if (HeapObjects != ref.HeapObjects) return false;
        if (StackInuse != ref.StackInuse) return false;
        if (StackSys != ref.StackSys) return false;
        if (MSpanInuse != ref.MSpanInuse) return false;
        if (MSpanSys != ref.MSpanSys) return false;
        if (MCacheInuse != ref.MCacheInuse) return false;
        if (MCacheSys != ref.MCacheSys) return false;
        if (BuckHashSys != ref.BuckHashSys) return false;
        if (GCSys != ref.GCSys) return false;
        if (OtherSys != ref.OtherSys) return false;
        if (NextGC != ref.NextGC) return false;
        if (LastGC != ref.LastGC) return false;
        if (PauseTotalNs != ref.PauseTotalNs) return false;
        if (PauseNs != ref.PauseNs) return false;
        if (PauseEnd != ref.PauseEnd) return false;
        if (NumGC != ref.NumGC) return false;
        if (NumForcedGC != ref.NumForcedGC) return false;
        if (GCCPUFraction != ref.GCCPUFraction) return false;
        if (EnableGC != ref.EnableGC) return false;
        if (DebugGC != ref.DebugGC) return false;
        if (BySize != ref.BySize) return false;
        return true;
    }

    std::ostream& MemStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Alloc;
        os << " " << TotalAlloc;
        os << " " << Sys;
        os << " " << Lookups;
        os << " " << Mallocs;
        os << " " << Frees;
        os << " " << HeapAlloc;
        os << " " << HeapSys;
        os << " " << HeapIdle;
        os << " " << HeapInuse;
        os << " " << HeapReleased;
        os << " " << HeapObjects;
        os << " " << StackInuse;
        os << " " << StackSys;
        os << " " << MSpanInuse;
        os << " " << MSpanSys;
        os << " " << MCacheInuse;
        os << " " << MCacheSys;
        os << " " << BuckHashSys;
        os << " " << GCSys;
        os << " " << OtherSys;
        os << " " << NextGC;
        os << " " << LastGC;
        os << " " << PauseTotalNs;
        os << " " << PauseNs;
        os << " " << PauseEnd;
        os << " " << NumGC;
        os << " " << NumForcedGC;
        os << " " << GCCPUFraction;
        os << " " << EnableGC;
        os << " " << DebugGC;
        os << " " << BySize;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MemStats& value)
    {
        return value.PrintTo(os);
    }

    void init()
    {
        if(auto offset = unsafe::Offsetof(memstats.heapStats); offset % 8 != 0)
        {
            println(offset);
            go_throw("memstats.heapStats not aligned to 8 bytes"s);
        }
        if(auto size = gocpp::Sizeof<heapStatsDelta>(); size % 8 != 0)
        {
            println(size);
            go_throw("heapStatsDelta not a multiple of 8 bytes in size"s);
        }
    }

    // ReadMemStats populates m with memory allocator statistics.
    //
    // The returned memory allocator statistics are up to date as of the
    // call to ReadMemStats. This is in contrast with a heap profile,
    // which is a snapshot as of the most recently completed garbage
    // collection cycle.
    void ReadMemStats(struct MemStats* m)
    {
        _ = m->Alloc;
        auto stw = stopTheWorld(stwReadMemStats);
        systemstack([=]() mutable -> void
        {
            readmemstats_m(m);
        });
        startTheWorld(stw);
    }

    // doubleCheckReadMemStats controls a double-check mode for ReadMemStats that
    // ensures consistency between the values that ReadMemStats is using and the
    // runtime-internal stats.
    bool doubleCheckReadMemStats = false;
    struct gocpp_id_1
        {
            uint32_t Size;
            uint64_t Mallocs;
            uint64_t Frees;

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                result.Size = this->Size;
                result.Mallocs = this->Mallocs;
                result.Frees = this->Frees;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                if (Size != ref.Size) return false;
                if (Mallocs != ref.Mallocs) return false;
                if (Frees != ref.Frees) return false;
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << Size;
                os << " " << Mallocs;
                os << " " << Frees;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    // readmemstats_m populates stats for internal runtime values.
    //
    // The world must be stopped.
    void readmemstats_m(struct MemStats* stats)
    {
        assertWorldStopped();
        systemstack(flushallmcaches);
        // Collect consistent stats, which are the source-of-truth in some cases.
        heapStatsDelta consStats = {};
        rec::unsafeRead(gocpp::recv(memstats.heapStats), & consStats);
        auto totalAlloc = consStats.largeAlloc;
        auto nMalloc = consStats.largeAllocCount;
        auto totalFree = consStats.largeFree;
        auto nFree = consStats.largeFreeCount;
        // Collect per-sizeclass stats.
        gocpp::array<gocpp_id_1, _NumSizeClasses> bySize = {};
        for(auto [i, gocpp_ignored] : bySize)
        {
            bySize[i].Size = uint32_t(class_to_size[i]);
            auto a = consStats.smallAllocCount[i];
            totalAlloc += a * uint64_t(class_to_size[i]);
            nMalloc += a;
            bySize[i].Mallocs = a;
            auto f = consStats.smallFreeCount[i];
            totalFree += f * uint64_t(class_to_size[i]);
            nFree += f;
            bySize[i].Frees = f;
        }
        nFree += consStats.tinyAllocCount;
        nMalloc += consStats.tinyAllocCount;
        auto stackInUse = uint64_t(consStats.inStacks);
        auto gcWorkBufInUse = uint64_t(consStats.inWorkBufs);
        auto gcProgPtrScalarBitsInUse = uint64_t(consStats.inPtrScalarBits);
        auto totalMapped = rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree)) + rec::load(gocpp::recv(gcController.heapReleased)) + rec::load(gocpp::recv(memstats.stacks_sys)) + rec::load(gocpp::recv(memstats.mspan_sys)) + rec::load(gocpp::recv(memstats.mcache_sys)) + rec::load(gocpp::recv(memstats.buckhash_sys)) + rec::load(gocpp::recv(memstats.gcMiscSys)) + rec::load(gocpp::recv(memstats.other_sys)) + stackInUse + gcWorkBufInUse + gcProgPtrScalarBitsInUse;
        auto heapGoal = rec::heapGoal(gocpp::recv(gcController));
        if(doubleCheckReadMemStats)
        {
            lock(& sched.sysmonlock);
            lock(& trace.lock);
            if(rec::load(gocpp::recv(gcController.heapInUse)) != uint64_t(consStats.inHeap))
            {
                print("runtime: heapInUse="s, rec::load(gocpp::recv(gcController.heapInUse)), "\n"s);
                print("runtime: consistent value="s, consStats.inHeap, "\n"s);
                go_throw("heapInUse and consistent stats are not equal"s);
            }
            if(rec::load(gocpp::recv(gcController.heapReleased)) != uint64_t(consStats.released))
            {
                print("runtime: heapReleased="s, rec::load(gocpp::recv(gcController.heapReleased)), "\n"s);
                print("runtime: consistent value="s, consStats.released, "\n"s);
                go_throw("heapReleased and consistent stats are not equal"s);
            }
            auto heapRetained = rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree));
            auto consRetained = uint64_t(consStats.committed - consStats.inStacks - consStats.inWorkBufs - consStats.inPtrScalarBits);
            if(heapRetained != consRetained)
            {
                print("runtime: global value="s, heapRetained, "\n"s);
                print("runtime: consistent value="s, consRetained, "\n"s);
                go_throw("measures of the retained heap are not equal"s);
            }
            if(rec::Load(gocpp::recv(gcController.totalAlloc)) != totalAlloc)
            {
                print("runtime: totalAlloc="s, rec::Load(gocpp::recv(gcController.totalAlloc)), "\n"s);
                print("runtime: consistent value="s, totalAlloc, "\n"s);
                go_throw("totalAlloc and consistent stats are not equal"s);
            }
            if(rec::Load(gocpp::recv(gcController.totalFree)) != totalFree)
            {
                print("runtime: totalFree="s, rec::Load(gocpp::recv(gcController.totalFree)), "\n"s);
                print("runtime: consistent value="s, totalFree, "\n"s);
                go_throw("totalFree and consistent stats are not equal"s);
            }
            if(rec::Load(gocpp::recv(gcController.mappedReady)) != totalMapped - uint64_t(consStats.released))
            {
                print("runtime: mappedReady="s, rec::Load(gocpp::recv(gcController.mappedReady)), "\n"s);
                print("runtime: totalMapped="s, totalMapped, "\n"s);
                print("runtime: released="s, uint64_t(consStats.released), "\n"s);
                print("runtime: totalMapped-released="s, totalMapped - uint64_t(consStats.released), "\n"s);
                go_throw("mappedReady and other memstats are not equal"s);
            }
            unlock(& trace.lock);
            unlock(& sched.sysmonlock);
        }
        stats->Alloc = totalAlloc - totalFree;
        stats->TotalAlloc = totalAlloc;
        stats->Sys = totalMapped;
        stats->Mallocs = nMalloc;
        stats->Frees = nFree;
        stats->HeapAlloc = totalAlloc - totalFree;
        stats->HeapSys = rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree)) + rec::load(gocpp::recv(gcController.heapReleased));
        stats->HeapIdle = rec::load(gocpp::recv(gcController.heapFree)) + rec::load(gocpp::recv(gcController.heapReleased));
        stats->HeapInuse = rec::load(gocpp::recv(gcController.heapInUse));
        stats->HeapReleased = rec::load(gocpp::recv(gcController.heapReleased));
        stats->HeapObjects = nMalloc - nFree;
        stats->StackInuse = stackInUse;
        stats->StackSys = stackInUse + rec::load(gocpp::recv(memstats.stacks_sys));
        stats->MSpanInuse = uint64_t(mheap_.spanalloc.inuse);
        stats->MSpanSys = rec::load(gocpp::recv(memstats.mspan_sys));
        stats->MCacheInuse = uint64_t(mheap_.cachealloc.inuse);
        stats->MCacheSys = rec::load(gocpp::recv(memstats.mcache_sys));
        stats->BuckHashSys = rec::load(gocpp::recv(memstats.buckhash_sys));
        stats->GCSys = rec::load(gocpp::recv(memstats.gcMiscSys)) + gcWorkBufInUse + gcProgPtrScalarBitsInUse;
        stats->OtherSys = rec::load(gocpp::recv(memstats.other_sys));
        stats->NextGC = heapGoal;
        stats->LastGC = memstats.last_gc_unix;
        stats->PauseTotalNs = memstats.pause_total_ns;
        stats->PauseNs = memstats.pause_ns;
        stats->PauseEnd = memstats.pause_end;
        stats->NumGC = memstats.numgc;
        stats->NumForcedGC = memstats.numforcedgc;
        stats->GCCPUFraction = memstats.gc_cpu_fraction;
        stats->EnableGC = true;
        copy(stats->BySize.make_slice(0), bySize.make_slice(0));
    }

    //go:linkname readGCStats runtime/debug.readGCStats
    void readGCStats(gocpp::slice<uint64_t>* pauses)
    {
        systemstack([=]() mutable -> void
        {
            readGCStats_m(pauses);
        });
    }

    // readGCStats_m must be called on the system stack because it acquires the heap
    // lock. See mheap for details.
    //
    //go:systemstack
    void readGCStats_m(gocpp::slice<uint64_t>* pauses)
    {
        auto p = *pauses;
        if(cap(p) < len(memstats.pause_ns) + 3)
        {
            go_throw("short slice passed to readGCStats"s);
        }
        lock(& mheap_.lock);
        auto n = memstats.numgc;
        if(n > uint32_t(len(memstats.pause_ns)))
        {
            n = uint32_t(len(memstats.pause_ns));
        }
        p = p.make_slice(0, cap(p));
        for(auto i = uint32_t(0); i < n; i++)
        {
            auto j = (memstats.numgc - 1 - i) % uint32_t(len(memstats.pause_ns));
            p[i] = memstats.pause_ns[j];
            p[n + i] = memstats.pause_end[j];
        }
        p[n + n] = memstats.last_gc_unix;
        p[n + n + 1] = uint64_t(memstats.numgc);
        p[n + n + 2] = memstats.pause_total_ns;
        unlock(& mheap_.lock);
        *pauses = p.make_slice(0, n + n + 3);
    }

    // flushmcache flushes the mcache of allp[i].
    //
    // The world must be stopped.
    //
    //go:nowritebarrier
    void flushmcache(int i)
    {
        assertWorldStopped();
        auto p = allp[i];
        auto c = p->mcache;
        if(c == nullptr)
        {
            return;
        }
        rec::releaseAll(gocpp::recv(c));
        stackcache_clear(c);
    }

    // flushallmcaches flushes the mcaches of all Ps.
    //
    // The world must be stopped.
    //
    //go:nowritebarrier
    void flushallmcaches()
    {
        assertWorldStopped();
        for(auto i = 0; i < int(gomaxprocs); i++)
        {
            flushmcache(i);
        }
    }

    // sysMemStat represents a global system statistic that is managed atomically.
    //
    // This type must structurally be a uint64 so that mstats aligns with MemStats.
    // load atomically reads the value of the stat.
    //
    // Must be nosplit as it is called in runtime initialization, e.g. newosproc0.
    //
    //go:nosplit
    uint64_t rec::load(golang::runtime::sysMemStat* s)
    {
        return atomic::Load64((uint64_t*)(s));
    }

    // add atomically adds the sysMemStat by n.
    //
    // Must be nosplit as it is called in runtime initialization, e.g. newosproc0.
    //
    //go:nosplit
    void rec::add(golang::runtime::sysMemStat* s, int64_t n)
    {
        auto val = atomic::Xadd64((uint64_t*)(s), n);
        if((n > 0 && int64_t(val) < n) || (n < 0 && int64_t(val) + n < n))
        {
            print("runtime: val="s, val, " n="s, n, "\n"s);
            go_throw("sysMemStat overflow"s);
        }
    }

    // heapStatsDelta contains deltas of various runtime memory statistics
    // that need to be updated together in order for them to be kept
    // consistent with one another.
    
    template<typename T> requires gocpp::GoStruct<T>
    heapStatsDelta::operator T()
    {
        T result;
        result.committed = this->committed;
        result.released = this->released;
        result.inHeap = this->inHeap;
        result.inStacks = this->inStacks;
        result.inWorkBufs = this->inWorkBufs;
        result.inPtrScalarBits = this->inPtrScalarBits;
        result.tinyAllocCount = this->tinyAllocCount;
        result.largeAlloc = this->largeAlloc;
        result.largeAllocCount = this->largeAllocCount;
        result.smallAllocCount = this->smallAllocCount;
        result.largeFree = this->largeFree;
        result.largeFreeCount = this->largeFreeCount;
        result.smallFreeCount = this->smallFreeCount;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heapStatsDelta::operator==(const T& ref) const
    {
        if (committed != ref.committed) return false;
        if (released != ref.released) return false;
        if (inHeap != ref.inHeap) return false;
        if (inStacks != ref.inStacks) return false;
        if (inWorkBufs != ref.inWorkBufs) return false;
        if (inPtrScalarBits != ref.inPtrScalarBits) return false;
        if (tinyAllocCount != ref.tinyAllocCount) return false;
        if (largeAlloc != ref.largeAlloc) return false;
        if (largeAllocCount != ref.largeAllocCount) return false;
        if (smallAllocCount != ref.smallAllocCount) return false;
        if (largeFree != ref.largeFree) return false;
        if (largeFreeCount != ref.largeFreeCount) return false;
        if (smallFreeCount != ref.smallFreeCount) return false;
        return true;
    }

    std::ostream& heapStatsDelta::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << committed;
        os << " " << released;
        os << " " << inHeap;
        os << " " << inStacks;
        os << " " << inWorkBufs;
        os << " " << inPtrScalarBits;
        os << " " << tinyAllocCount;
        os << " " << largeAlloc;
        os << " " << largeAllocCount;
        os << " " << smallAllocCount;
        os << " " << largeFree;
        os << " " << largeFreeCount;
        os << " " << smallFreeCount;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapStatsDelta& value)
    {
        return value.PrintTo(os);
    }

    // merge adds in the deltas from b into a.
    void rec::merge(struct heapStatsDelta* a, struct heapStatsDelta* b)
    {
        a->committed += b->committed;
        a->released += b->released;
        a->inHeap += b->inHeap;
        a->inStacks += b->inStacks;
        a->inWorkBufs += b->inWorkBufs;
        a->inPtrScalarBits += b->inPtrScalarBits;
        a->tinyAllocCount += b->tinyAllocCount;
        a->largeAlloc += b->largeAlloc;
        a->largeAllocCount += b->largeAllocCount;
        for(auto [i, gocpp_ignored] : b->smallAllocCount)
        {
            a->smallAllocCount[i] += b->smallAllocCount[i];
        }
        a->largeFree += b->largeFree;
        a->largeFreeCount += b->largeFreeCount;
        for(auto [i, gocpp_ignored] : b->smallFreeCount)
        {
            a->smallFreeCount[i] += b->smallFreeCount[i];
        }
    }

    // consistentHeapStats represents a set of various memory statistics
    // whose updates must be viewed completely to get a consistent
    // state of the world.
    //
    // To write updates to memory stats use the acquire and release
    // methods. To obtain a consistent global snapshot of these statistics,
    // use read.
    
    template<typename T> requires gocpp::GoStruct<T>
    consistentHeapStats::operator T()
    {
        T result;
        result.stats = this->stats;
        result.gen = this->gen;
        result.noPLock = this->noPLock;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool consistentHeapStats::operator==(const T& ref) const
    {
        if (stats != ref.stats) return false;
        if (gen != ref.gen) return false;
        if (noPLock != ref.noPLock) return false;
        return true;
    }

    std::ostream& consistentHeapStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stats;
        os << " " << gen;
        os << " " << noPLock;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct consistentHeapStats& value)
    {
        return value.PrintTo(os);
    }

    // acquire returns a heapStatsDelta to be updated. In effect,
    // it acquires the shard for writing. release must be called
    // as soon as the relevant deltas are updated.
    //
    // The returned heapStatsDelta must be updated atomically.
    //
    // The caller's P must not change between acquire and
    // release. This also means that the caller should not
    // acquire a P or release its P in between. A P also must
    // not acquire a given consistentHeapStats if it hasn't
    // yet released it.
    //
    // nosplit because a stack growth in this function could
    // lead to a stack allocation that could reenter the
    // function.
    //
    //go:nosplit
    struct heapStatsDelta* rec::acquire(struct consistentHeapStats* m)
    {
        if(auto pp = rec::ptr(gocpp::recv(getg()->m->p)); pp != nullptr)
        {
            auto seq = rec::Add(gocpp::recv(pp->statsSeq), 1);
            if(seq % 2 == 0)
            {
                print("runtime: seq="s, seq, "\n"s);
                go_throw("bad sequence number"s);
            }
        }
        else
        {
            lock(& m->noPLock);
        }
        auto gen = rec::Load(gocpp::recv(m->gen)) % 3;
        return & m->stats[gen];
    }

    // release indicates that the writer is done modifying
    // the delta. The value returned by the corresponding
    // acquire must no longer be accessed or modified after
    // release is called.
    //
    // The caller's P must not change between acquire and
    // release. This also means that the caller should not
    // acquire a P or release its P in between.
    //
    // nosplit because a stack growth in this function could
    // lead to a stack allocation that causes another acquire
    // before this operation has completed.
    //
    //go:nosplit
    void rec::release(struct consistentHeapStats* m)
    {
        if(auto pp = rec::ptr(gocpp::recv(getg()->m->p)); pp != nullptr)
        {
            auto seq = rec::Add(gocpp::recv(pp->statsSeq), 1);
            if(seq % 2 != 0)
            {
                print("runtime: seq="s, seq, "\n"s);
                go_throw("bad sequence number"s);
            }
        }
        else
        {
            unlock(& m->noPLock);
        }
    }

    // unsafeRead aggregates the delta for this shard into out.
    //
    // Unsafe because it does so without any synchronization. The
    // world must be stopped.
    void rec::unsafeRead(struct consistentHeapStats* m, struct heapStatsDelta* out)
    {
        assertWorldStopped();
        for(auto [i, gocpp_ignored] : m->stats)
        {
            rec::merge(gocpp::recv(out), & m->stats[i]);
        }
    }

    // unsafeClear clears the shard.
    //
    // Unsafe because the world must be stopped and values should
    // be donated elsewhere before clearing.
    void rec::unsafeClear(struct consistentHeapStats* m)
    {
        assertWorldStopped();
        for(auto [i, gocpp_ignored] : m->stats)
        {
            m->stats[i] = heapStatsDelta {};
        }
    }

    // read takes a globally consistent snapshot of m
    // and puts the aggregated value in out. Even though out is a
    // heapStatsDelta, the resulting values should be complete and
    // valid statistic values.
    //
    // Not safe to call concurrently. The world must be stopped
    // or metricsSema must be held.
    void rec::read(struct consistentHeapStats* m, struct heapStatsDelta* out)
    {
        auto mp = acquirem();
        auto currGen = rec::Load(gocpp::recv(m->gen));
        auto prevGen = currGen - 1;
        if(currGen == 0)
        {
            prevGen = 2;
        }
        lock(& m->noPLock);
        rec::Swap(gocpp::recv(m->gen), (currGen + 1) % 3);
        unlock(& m->noPLock);
        for(auto [gocpp_ignored, p] : allp)
        {
            for(; rec::Load(gocpp::recv(p->statsSeq)) % 2 != 0; )
            {
            }
        }
        rec::merge(gocpp::recv(m->stats[currGen]), & m->stats[prevGen]);
        m->stats[prevGen] = heapStatsDelta {};
        *out = m->stats[currGen];
        releasem(mp);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    cpuStats::operator T()
    {
        T result;
        result.gcAssistTime = this->gcAssistTime;
        result.gcDedicatedTime = this->gcDedicatedTime;
        result.gcIdleTime = this->gcIdleTime;
        result.gcPauseTime = this->gcPauseTime;
        result.gcTotalTime = this->gcTotalTime;
        result.scavengeAssistTime = this->scavengeAssistTime;
        result.scavengeBgTime = this->scavengeBgTime;
        result.scavengeTotalTime = this->scavengeTotalTime;
        result.idleTime = this->idleTime;
        result.userTime = this->userTime;
        result.totalTime = this->totalTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cpuStats::operator==(const T& ref) const
    {
        if (gcAssistTime != ref.gcAssistTime) return false;
        if (gcDedicatedTime != ref.gcDedicatedTime) return false;
        if (gcIdleTime != ref.gcIdleTime) return false;
        if (gcPauseTime != ref.gcPauseTime) return false;
        if (gcTotalTime != ref.gcTotalTime) return false;
        if (scavengeAssistTime != ref.scavengeAssistTime) return false;
        if (scavengeBgTime != ref.scavengeBgTime) return false;
        if (scavengeTotalTime != ref.scavengeTotalTime) return false;
        if (idleTime != ref.idleTime) return false;
        if (userTime != ref.userTime) return false;
        if (totalTime != ref.totalTime) return false;
        return true;
    }

    std::ostream& cpuStats::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << gcAssistTime;
        os << " " << gcDedicatedTime;
        os << " " << gcIdleTime;
        os << " " << gcPauseTime;
        os << " " << gcTotalTime;
        os << " " << scavengeAssistTime;
        os << " " << scavengeBgTime;
        os << " " << scavengeTotalTime;
        os << " " << idleTime;
        os << " " << userTime;
        os << " " << totalTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuStats& value)
    {
        return value.PrintTo(os);
    }

    // accumulate takes a cpuStats and adds in the current state of all GC CPU
    // counters.
    //
    // gcMarkPhase indicates that we're in the mark phase and that certain counter
    // values should be used.
    void rec::accumulate(struct cpuStats* s, int64_t now, bool gcMarkPhase)
    {
        // N.B. Mark termination and sweep termination pauses are
        // accumulated in work.cpuStats at the end of their respective pauses.
        int64_t markAssistCpu = {};
        int64_t markDedicatedCpu = {};
        int64_t markFractionalCpu = {};
        int64_t markIdleCpu = {};
        if(gcMarkPhase)
        {
            markAssistCpu = rec::Load(gocpp::recv(gcController.assistTime));
            markDedicatedCpu = rec::Load(gocpp::recv(gcController.dedicatedMarkTime));
            markFractionalCpu = rec::Load(gocpp::recv(gcController.fractionalMarkTime));
            markIdleCpu = rec::Load(gocpp::recv(gcController.idleMarkTime));
        }
        auto scavAssistCpu = rec::Load(gocpp::recv(scavenge.assistTime));
        auto scavBgCpu = rec::Load(gocpp::recv(scavenge.backgroundTime));
        s->gcAssistTime += markAssistCpu;
        s->gcDedicatedTime += markDedicatedCpu + markFractionalCpu;
        s->gcIdleTime += markIdleCpu;
        s->gcTotalTime += markAssistCpu + markDedicatedCpu + markFractionalCpu + markIdleCpu;
        s->scavengeAssistTime += scavAssistCpu;
        s->scavengeBgTime += scavBgCpu;
        s->scavengeTotalTime += scavAssistCpu + scavBgCpu;
        s->totalTime = sched.totaltime + (now - sched.procresizetime) * int64_t(gomaxprocs);
        s->idleTime += rec::Load(gocpp::recv(sched.idleTime));
        s->userTime = s->totalTime - (s->gcTotalTime + s->scavengeTotalTime + s->idleTime);
    }

}

