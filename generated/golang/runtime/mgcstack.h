// generated by GoCpp from file '$(ImportDir)/runtime/mgcstack.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcstack.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"

namespace golang::runtime
{
    struct stackWorkBuf
    {
        sys::NotInHeap _;
        /* gocpp::array<uintptr_t, (_WorkbufSize - gocpp::Sizeof<stackWorkBufHdr>()) / goarch::PtrSize> obj; [Known incomplete type] */

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackWorkBuf& value);
    struct stackWorkBufHdr
    {
        sys::NotInHeap _;
        stackWorkBuf* next;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackWorkBufHdr& value);
    struct stackObjectBuf
    {
        sys::NotInHeap _;
        /* gocpp::array<stackObject, (_WorkbufSize - gocpp::Sizeof<stackObjectBufHdr>()) / gocpp::Sizeof<stackObject>()> obj; [Known incomplete type] */

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackObjectBuf& value);
    struct stackObjectBufHdr
    {
        sys::NotInHeap _;
        stackObjectBuf* next;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackObjectBufHdr& value);
    void init();
    struct stackObject
    {
        sys::NotInHeap _;
        uint32_t off;
        uint32_t size;
        stackObjectRecord* r;
        stackObject* left;
        stackObject* right;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackObject& value);
    void setRecord(struct stackObject* obj, stackObjectRecord* r);
    struct stackScanState
    {
        stack stack;
        bool conservative;
        stackWorkBuf* buf;
        stackWorkBuf* freeBuf;
        stackWorkBuf* cbuf;
        stackObjectBuf* head;
        stackObjectBuf* tail;
        int nobjs;
        stackObject* root;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackScanState& value);
    void putPtr(struct stackScanState* s, uintptr_t p, bool conservative);
    std::tuple<uintptr_t, bool> getPtr(struct stackScanState* s);
    void addObject(struct stackScanState* s, uintptr_t addr, stackObjectRecord* r);
    void buildIndex(struct stackScanState* s);
    std::tuple<stackObject*, stackObjectBuf*, int> binarySearchTree(stackObjectBuf* x, int idx, int n);
    stackObject* findObject(struct stackScanState* s, uintptr_t a);
}

