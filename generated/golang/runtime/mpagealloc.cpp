// generated by GoCpp from file '$(ImportDir)/runtime/mpagealloc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mpagealloc.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mem.h"
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc_64bit.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    offAddr maxSearchAddr()
    {
        return maxOffAddr;
    }

    chunkIdx chunkIndex(uintptr_t p)
    {
        return chunkIdx((p - arenaBaseOffset) / pallocChunkBytes);
    }

    uintptr_t chunkBase(chunkIdx ci)
    {
        return uintptr_t(ci) * pallocChunkBytes + arenaBaseOffset;
    }

    unsigned int chunkPageIndex(uintptr_t p)
    {
        return (unsigned int)(p % pallocChunkBytes / pageSize);
    }

    unsigned int l1(chunkIdx i)
    {
        if(pallocChunksL1Bits == 0)
        {
            return 0;
        }
        else
        {
            return (unsigned int)(i) >> pallocChunksL1Shift;
        }
    }

    unsigned int l2(chunkIdx i)
    {
        if(pallocChunksL1Bits == 0)
        {
            return (unsigned int)(i);
        }
        else
        {
            return (unsigned int)(i) & ((1 << pallocChunksL2Bits) - 1);
        }
    }

    int offAddrToLevelIndex(int level, offAddr addr)
    {
        return int((addr.a - arenaBaseOffset) >> levelShift[level]);
    }

    offAddr levelIndexToOffAddr(int level, int idx)
    {
        return offAddr {(uintptr_t(idx) << levelShift[level]) + arenaBaseOffset};
    }

    std::tuple<int, int> addrsToSummaryRange(int level, uintptr_t base, uintptr_t limit)
    {
        int lo;
        int hi;
        lo = int((base - arenaBaseOffset) >> levelShift[level]);
        hi = int(((limit - 1) - arenaBaseOffset) >> levelShift[level]) + 1;
        return {lo, hi};
    }

    std::tuple<int, int> blockAlignSummaryRange(int level, int lo, int hi)
    {
        auto e = uintptr_t(1) << levelBits[level];
        return {int(alignDown(uintptr_t(lo), e)), int(alignUp(uintptr_t(hi), e))};
    }

    
    std::ostream& pageAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << summary;
        os << " " << chunks;
        os << " " << searchAddr;
        os << " " << start;
        os << " " << end;
        os << " " << inUse;
        os << " " << scav;
        os << " " << mheapLock;
        os << " " << sysStat;
        os << " " << summaryMappedReady;
        os << " " << chunkHugePages;
        os << " " << test;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pageAlloc& value)
    {
        return value.PrintTo(os);
    }

    void init(struct pageAlloc* p, mutex* mheapLock, sysMemStat* sysStat, bool test)
    {
        if(levelLogPages[0] > logMaxPackedValue)
        {
            print("runtime: root level max pages = ", 1 << levelLogPages[0], "\n");
            print("runtime: summary max pages = ", maxPackedValue, "\n");
            go_throw("root level max pages doesn't fit in summary");
        }
        p->sysStat = sysStat;
        init(gocpp::recv(p->inUse), sysStat);
        sysInit(gocpp::recv(p), test);
        p->searchAddr = maxSearchAddr();
        p->mheapLock = mheapLock;
        p->summaryMappedReady += init(gocpp::recv(p->scav.index), test, sysStat);
        p->test = test;
    }

    pallocData* tryChunkOf(struct pageAlloc* p, chunkIdx ci)
    {
        auto l2 = p->chunks[l1(gocpp::recv(ci))];
        if(l2 == nullptr)
        {
            return nullptr;
        }
        return & l2[l2(gocpp::recv(ci))];
    }

    pallocData* chunkOf(struct pageAlloc* p, chunkIdx ci)
    {
        return & p->chunks[l1(gocpp::recv(ci))][l2(gocpp::recv(ci))];
    }

    void grow(struct pageAlloc* p, uintptr_t base, uintptr_t size)
    {
        assertLockHeld(p->mheapLock);
        auto limit = alignUp(base + size, pallocChunkBytes);
        base = alignDown(base, pallocChunkBytes);
        sysGrow(gocpp::recv(p), base, limit);
        p->summaryMappedReady += grow(gocpp::recv(p->scav.index), base, limit, p->sysStat);
        auto firstGrowth = p->start == 0;
        auto [start, end] = std::tuple{chunkIndex(base), chunkIndex(limit)};
        if(firstGrowth || start < p->start)
        {
            p->start = start;
        }
        if(end > p->end)
        {
            p->end = end;
        }
        add(gocpp::recv(p->inUse), makeAddrRange(base, limit));
        if(auto b = (offAddr {base}); lessThan(gocpp::recv(b), p->searchAddr))
        {
            p->searchAddr = b;
        }
        for(auto c = chunkIndex(base); c < chunkIndex(limit); c++)
        {
            if(p->chunks[l1(gocpp::recv(c))] == nullptr)
            {
                auto l2Size = gocpp::Sizeof<gocpp::array<runtime::pallocData, 8192>>();
                auto r = sysAlloc(l2Size, p->sysStat);
                if(r == nullptr)
                {
                    go_throw("pageAlloc: out of memory");
                }
                if(! p->test)
                {
                    if(p->chunkHugePages)
                    {
                        sysHugePage(r, l2Size);
                    }
                    else
                    {
                        sysNoHugePage(r, l2Size);
                    }
                }
                *(uintptr_t*)(unsafe::Pointer(& p->chunks[l1(gocpp::recv(c))])) = uintptr_t(r);
            }
            setRange(gocpp::recv(chunkOf(gocpp::recv(p), c)->scavenged), 0, pallocChunkPages);
        }
        update(gocpp::recv(p), base, size / pageSize, true, false);
    }

    void enableChunkHugePages(struct pageAlloc* p)
    {
        lock(& mheap_.lock);
        if(p->chunkHugePages)
        {
            unlock(& mheap_.lock);
            return;
        }
        p->chunkHugePages = true;
        addrRanges inUse = {};
        inUse.sysStat = p->sysStat;
        cloneInto(gocpp::recv(p->inUse), & inUse);
        unlock(& mheap_.lock);
        for(auto [_, r] : p->inUse.ranges)
        {
            for(auto i = l1(gocpp::recv(chunkIndex(addr(gocpp::recv(r.base))))); i < l1(gocpp::recv(chunkIndex(addr(gocpp::recv(r.limit)) - 1))); i++)
            {
                sysHugePage(unsafe::Pointer(p->chunks[i]), gocpp::Sizeof<gocpp::array<runtime::pallocData, 8192>>());
            }
        }
    }

    void update(struct pageAlloc* p, uintptr_t base, uintptr_t npages, bool contig, bool alloc)
    {
        assertLockHeld(p->mheapLock);
        auto limit = base + npages * pageSize - 1;
        auto [sc, ec] = std::tuple{chunkIndex(base), chunkIndex(limit)};
        if(sc == ec)
        {
            auto x = p->summary[len(p->summary) - 1][sc];
            auto y = summarize(gocpp::recv(chunkOf(gocpp::recv(p), sc)));
            if(x == y)
            {
                return;
            }
            p->summary[len(p->summary) - 1][sc] = y;
        }
        else
        if(contig)
        {
            auto summary = p->summary[len(p->summary) - 1];
            summary[sc] = summarize(gocpp::recv(chunkOf(gocpp::recv(p), sc)));
            auto whole = p->summary[len(p->summary) - 1].make_slice(sc + 1, ec);
            if(alloc)
            {
                for(auto [i, gocpp_ignored] : whole)
                {
                    whole[i] = 0;
                }
            }
            else
            {
                for(auto [i, gocpp_ignored] : whole)
                {
                    whole[i] = freeChunkSum;
                }
            }
            summary[ec] = summarize(gocpp::recv(chunkOf(gocpp::recv(p), ec)));
        }
        else
        {
            auto summary = p->summary[len(p->summary) - 1];
            for(auto c = sc; c <= ec; c++)
            {
                summary[c] = summarize(gocpp::recv(chunkOf(gocpp::recv(p), c)));
            }
        }
        auto changed = true;
        for(auto l = len(p->summary) - 2; l >= 0 && changed; l--)
        {
            changed = false;
            auto logEntriesPerBlock = levelBits[l + 1];
            auto logMaxPages = levelLogPages[l + 1];
            auto [lo, hi] = addrsToSummaryRange(l, base, limit + 1);
            for(auto i = lo; i < hi; i++)
            {
                auto children = p->summary[l + 1].make_slice(i << logEntriesPerBlock, (i + 1) << logEntriesPerBlock);
                auto sum = mergeSummaries(children, logMaxPages);
                auto old = p->summary[l][i];
                if(old != sum)
                {
                    changed = true;
                    p->summary[l][i] = sum;
                }
            }
        }
    }

    uintptr_t allocRange(struct pageAlloc* p, uintptr_t base, uintptr_t npages)
    {
        assertLockHeld(p->mheapLock);
        auto limit = base + npages * pageSize - 1;
        auto [sc, ec] = std::tuple{chunkIndex(base), chunkIndex(limit)};
        auto [si, ei] = std::tuple{chunkPageIndex(base), chunkPageIndex(limit)};
        auto scav = (unsigned int)(0);
        if(sc == ec)
        {
            auto chunk = chunkOf(gocpp::recv(p), sc);
            scav += popcntRange(gocpp::recv(chunk->scavenged), si, ei + 1 - si);
            allocRange(gocpp::recv(chunk), si, ei + 1 - si);
            alloc(gocpp::recv(p->scav.index), sc, ei + 1 - si);
        }
        else
        {
            auto chunk = chunkOf(gocpp::recv(p), sc);
            scav += popcntRange(gocpp::recv(chunk->scavenged), si, pallocChunkPages - si);
            allocRange(gocpp::recv(chunk), si, pallocChunkPages - si);
            alloc(gocpp::recv(p->scav.index), sc, pallocChunkPages - si);
            for(auto c = sc + 1; c < ec; c++)
            {
                auto chunk = chunkOf(gocpp::recv(p), c);
                scav += popcntRange(gocpp::recv(chunk->scavenged), 0, pallocChunkPages);
                allocAll(gocpp::recv(chunk));
                alloc(gocpp::recv(p->scav.index), c, pallocChunkPages);
            }
            chunk = chunkOf(gocpp::recv(p), ec);
            scav += popcntRange(gocpp::recv(chunk->scavenged), 0, ei + 1);
            allocRange(gocpp::recv(chunk), 0, ei + 1);
            alloc(gocpp::recv(p->scav.index), ec, ei + 1);
        }
        update(gocpp::recv(p), base, npages, true, true);
        return uintptr_t(scav) * pageSize;
    }

    offAddr findMappedAddr(struct pageAlloc* p, offAddr addr)
    {
        assertLockHeld(p->mheapLock);
        auto ai = arenaIndex(addr(gocpp::recv(addr)));
        if(p->test || mheap_.arenas[l1(gocpp::recv(ai))] == nullptr || mheap_.arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))] == nullptr)
        {
            auto [vAddr, ok] = findAddrGreaterEqual(gocpp::recv(p->inUse), addr(gocpp::recv(addr)));
            if(ok)
            {
                return offAddr {vAddr};
            }
            else
            {
                return maxOffAddr;
            }
        }
        return addr;
    }

    struct gocpp_id_1
        {
            offAddr base;
            offAddr bound;

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << base;
                os << " " << bound;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_1
        {
            offAddr base;
            offAddr bound;

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << base;
                os << " " << bound;
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
        {
            return value.PrintTo(os);
        }


    std::tuple<uintptr_t, offAddr> find(struct pageAlloc* p, uintptr_t npages)
    {
        assertLockHeld(p->mheapLock);
        auto i = 0;
        auto firstFree = gocpp::Init<gocpp_id_1>([](gocpp_id_1& x) { x.base = minOffAddr; x.bound = maxOffAddr; });
        auto foundFree = [=](offAddr addr, uintptr_t size) mutable -> void
        {
            if(lessEqual(gocpp::recv(firstFree.base), addr) && lessEqual(gocpp::recv(add(gocpp::recv(addr), size - 1)), firstFree.bound))
            {
                firstFree.base = addr;
                firstFree.bound = add(gocpp::recv(addr), size - 1);
            }
            else
            if(! (lessThan(gocpp::recv(add(gocpp::recv(addr), size - 1)), firstFree.base) || lessThan(gocpp::recv(firstFree.bound), addr)))
            {
                print("runtime: addr = ", hex(addr(gocpp::recv(addr))), ", size = ", size, "\n");
                print("runtime: base = ", hex(addr(gocpp::recv(firstFree.base))), ", bound = ", hex(addr(gocpp::recv(firstFree.bound))), "\n");
                go_throw("range partially overlaps");
            }
        };
        auto lastSum = packPallocSum(0, 0, 0);
        auto lastSumIdx = - 1;
        nextLevel:
        for(auto l = 0; l < len(p->summary); l++)
        {
            auto entriesPerBlock = 1 << levelBits[l];
            auto logMaxPages = levelLogPages[l];
            i <<= levelBits[l];
            auto entries = p->summary[l].make_slice(i, i + entriesPerBlock);
            auto j0 = 0;
            if(auto searchIdx = offAddrToLevelIndex(l, p->searchAddr); searchIdx &^ (entriesPerBlock - 1) == i)
            {
                j0 = searchIdx & (entriesPerBlock - 1);
            }
            unsigned int base = {};
            unsigned int size = {};
            for(auto j = j0; j < len(entries); j++)
            {
                auto sum = entries[j];
                if(sum == 0)
                {
                    size = 0;
                    continue;
                }
                foundFree(levelIndexToOffAddr(l, i + j), (uintptr_t(1) << logMaxPages) * pageSize);
                auto s = start(gocpp::recv(sum));
                if(size + s >= (unsigned int)(npages))
                {
                    if(size == 0)
                    {
                        base = (unsigned int)(j) << logMaxPages;
                    }
                    size += s;
                    break;
                }
                if(max(gocpp::recv(sum)) >= (unsigned int)(npages))
                {
                    i += j;
                    lastSumIdx = i;
                    lastSum = sum;
                    goto nextLevel_continue;
                }
                if(size == 0 || s < (1 << logMaxPages))
                {
                    size = end(gocpp::recv(sum));
                    base = ((unsigned int)(j + 1) << logMaxPages) - size;
                    continue;
                }
                size += 1 << logMaxPages;
            }
            if(size >= (unsigned int)(npages))
            {
                auto addr = addr(gocpp::recv(add(gocpp::recv(levelIndexToOffAddr(l, i)), uintptr_t(base) * pageSize)));
                return {addr, findMappedAddr(gocpp::recv(p), firstFree.base)};
            }
            if(l == 0)
            {
                return {0, maxSearchAddr()};
            }
            print("runtime: summary[", l - 1, "][", lastSumIdx, "] = ", start(gocpp::recv(lastSum)), ", ", max(gocpp::recv(lastSum)), ", ", end(gocpp::recv(lastSum)), "\n");
            print("runtime: level = ", l, ", npages = ", npages, ", j0 = ", j0, "\n");
            print("runtime: p.searchAddr = ", hex(addr(gocpp::recv(p->searchAddr))), ", i = ", i, "\n");
            print("runtime: levelShift[level] = ", levelShift[l], ", levelBits[level] = ", levelBits[l], "\n");
            for(auto j = 0; j < len(entries); j++)
            {
                auto sum = entries[j];
                print("runtime: summary[", l, "][", i + j, "] = (", start(gocpp::recv(sum)), ", ", max(gocpp::recv(sum)), ", ", end(gocpp::recv(sum)), ")\n");
            }
            go_throw("bad summary data");
            if(false) {
            nextLevel_continue:
                continue;
            nextLevel_break:
                break;
            }
        }
        auto ci = chunkIdx(i);
        auto [j, searchIdx] = find(gocpp::recv(chunkOf(gocpp::recv(p), ci)), npages, 0);
        if(j == ~ (unsigned int)(0))
        {
            auto sum = p->summary[len(p->summary) - 1][i];
            print("runtime: summary[", len(p->summary) - 1, "][", i, "] = (", start(gocpp::recv(sum)), ", ", max(gocpp::recv(sum)), ", ", end(gocpp::recv(sum)), ")\n");
            print("runtime: npages = ", npages, "\n");
            go_throw("bad summary data");
        }
        auto addr = chunkBase(ci) + uintptr_t(j) * pageSize;
        auto searchAddr = chunkBase(ci) + uintptr_t(searchIdx) * pageSize;
        foundFree(offAddr {searchAddr}, chunkBase(ci + 1) - searchAddr);
        return {addr, findMappedAddr(gocpp::recv(p), firstFree.base)};
    }

    std::tuple<uintptr_t, uintptr_t> alloc(struct pageAlloc* p, uintptr_t npages)
    {
        uintptr_t addr;
        uintptr_t scav;
        assertLockHeld(p->mheapLock);
        if(chunkIndex(addr(gocpp::recv(p->searchAddr))) >= p->end)
        {
            uintptr_t addr;
            uintptr_t scav;
            return {0, 0};
        }
        auto searchAddr = minOffAddr;
        if(pallocChunkPages - chunkPageIndex(addr(gocpp::recv(p->searchAddr))) >= (unsigned int)(npages))
        {
            uintptr_t addr;
            uintptr_t scav;
            auto i = chunkIndex(addr(gocpp::recv(p->searchAddr)));
            if(auto max = max(gocpp::recv(p->summary[len(p->summary) - 1][i])); max >= (unsigned int)(npages))
            {
                uintptr_t addr;
                uintptr_t scav;
                auto [j, searchIdx] = find(gocpp::recv(chunkOf(gocpp::recv(p), i)), npages, chunkPageIndex(addr(gocpp::recv(p->searchAddr))));
                if(j == ~ (unsigned int)(0))
                {
                    uintptr_t addr;
                    uintptr_t scav;
                    print("runtime: max = ", max, ", npages = ", npages, "\n");
                    print("runtime: searchIdx = ", chunkPageIndex(addr(gocpp::recv(p->searchAddr))), ", p.searchAddr = ", hex(addr(gocpp::recv(p->searchAddr))), "\n");
                    go_throw("bad summary data");
                }
                addr = chunkBase(i) + uintptr_t(j) * pageSize;
                searchAddr = offAddr {chunkBase(i) + uintptr_t(searchIdx) * pageSize};
                goto Found;
            }
        }
        std::tie(addr, searchAddr) = find(gocpp::recv(p), npages);
        if(addr == 0)
        {
            uintptr_t addr;
            uintptr_t scav;
            if(npages == 1)
            {
                uintptr_t addr;
                uintptr_t scav;
                p->searchAddr = maxSearchAddr();
            }
            return {0, 0};
        }
        Found:
        scav = allocRange(gocpp::recv(p), addr, npages);
        if(lessThan(gocpp::recv(p->searchAddr), searchAddr))
        {
            uintptr_t addr;
            uintptr_t scav;
            p->searchAddr = searchAddr;
        }
        return {addr, scav};
    }

    void free(struct pageAlloc* p, uintptr_t base, uintptr_t npages)
    {
        assertLockHeld(p->mheapLock);
        if(auto b = (offAddr {base}); lessThan(gocpp::recv(b), p->searchAddr))
        {
            p->searchAddr = b;
        }
        auto limit = base + npages * pageSize - 1;
        if(npages == 1)
        {
            auto i = chunkIndex(base);
            auto pi = chunkPageIndex(base);
            free1(gocpp::recv(chunkOf(gocpp::recv(p), i)), pi);
            free(gocpp::recv(p->scav.index), i, pi, 1);
        }
        else
        {
            auto [sc, ec] = std::tuple{chunkIndex(base), chunkIndex(limit)};
            auto [si, ei] = std::tuple{chunkPageIndex(base), chunkPageIndex(limit)};
            if(sc == ec)
            {
                free(gocpp::recv(chunkOf(gocpp::recv(p), sc)), si, ei + 1 - si);
                free(gocpp::recv(p->scav.index), sc, si, ei + 1 - si);
            }
            else
            {
                free(gocpp::recv(chunkOf(gocpp::recv(p), sc)), si, pallocChunkPages - si);
                free(gocpp::recv(p->scav.index), sc, si, pallocChunkPages - si);
                for(auto c = sc + 1; c < ec; c++)
                {
                    freeAll(gocpp::recv(chunkOf(gocpp::recv(p), c)));
                    free(gocpp::recv(p->scav.index), c, 0, pallocChunkPages);
                }
                free(gocpp::recv(chunkOf(gocpp::recv(p), ec)), 0, ei + 1);
                free(gocpp::recv(p->scav.index), ec, 0, ei + 1);
            }
        }
        update(gocpp::recv(p), base, npages, true, false);
    }

    pallocSum packPallocSum(unsigned int start, unsigned int max, unsigned int end)
    {
        if(max == maxPackedValue)
        {
            return pallocSum(uint64_t(1 << 63));
        }
        return pallocSum((uint64_t(start) & (maxPackedValue - 1)) | ((uint64_t(max) & (maxPackedValue - 1)) << logMaxPackedValue) | ((uint64_t(end) & (maxPackedValue - 1)) << (2 * logMaxPackedValue)));
    }

    unsigned int start(pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return maxPackedValue;
        }
        return (unsigned int)(uint64_t(p) & (maxPackedValue - 1));
    }

    unsigned int max(pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return maxPackedValue;
        }
        return (unsigned int)((uint64_t(p) >> logMaxPackedValue) & (maxPackedValue - 1));
    }

    unsigned int end(pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return maxPackedValue;
        }
        return (unsigned int)((uint64_t(p) >> (2 * logMaxPackedValue)) & (maxPackedValue - 1));
    }

    std::tuple<unsigned int, unsigned int, unsigned int> unpack(pallocSum p)
    {
        if(uint64_t(p) & uint64_t(1 << 63) != 0)
        {
            return {maxPackedValue, maxPackedValue, maxPackedValue};
        }
        return {(unsigned int)(uint64_t(p) & (maxPackedValue - 1)), (unsigned int)((uint64_t(p) >> logMaxPackedValue) & (maxPackedValue - 1)), (unsigned int)((uint64_t(p) >> (2 * logMaxPackedValue)) & (maxPackedValue - 1))};
    }

    pallocSum mergeSummaries(gocpp::slice<pallocSum> sums, unsigned int logMaxPagesPerSum)
    {
        auto [start, most, end] = unpack(gocpp::recv(sums[0]));
        for(auto i = 1; i < len(sums); i++)
        {
            auto [si, mi, ei] = unpack(gocpp::recv(sums[i]));
            if(start == ((unsigned int)(i) << logMaxPagesPerSum))
            {
                start += si;
            }
            most = max(most, end + si, mi);
            if(ei == (1 << logMaxPagesPerSum))
            {
                end += 1 << logMaxPagesPerSum;
            }
            else
            {
                end = ei;
            }
        }
        return packPallocSum(start, most, end);
    }

}

