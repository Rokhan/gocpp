// generated by GoCpp from file '$(ImportDir)/runtime/proc.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/proc.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/rwmutex.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    void main_main();
    void main();
    void os_beforeExit(int exitCode);
    void init();
    void forcegchelper();
    void Gosched();
    void goschedguarded();
    void goschedIfBusy();
    void gopark(std::function<bool (g*, unsafe::Pointer)> unlockf, unsafe::Pointer lock, golang::runtime::waitReason reason, golang::runtime::traceBlockReason traceReason, int traceskip);
    void goparkunlock(struct mutex* lock, golang::runtime::waitReason reason, golang::runtime::traceBlockReason traceReason, int traceskip);
    void goready(struct g* gp, int traceskip);
    struct sudog* acquireSudog();
    void releaseSudog(struct sudog* s);
    void badmcall(std::function<void (g*)> fn);
    void badmcall2(std::function<void (g*)> fn);
    void badreflectcall();
    void badmorestackg0();
    void badmorestackgsignal();
    void badctxt();
    void switchToCrashStack(std::function<void ()> fn);
    extern bool crashStackImplemented;
    void switchToCrashStack0(std::function<void ()> fn);
    bool lockedOSThread();
    void allgadd(struct g* gp);
    gocpp::slice<g*> allGsSnapshot();
    std::tuple<struct g**, uintptr_t> atomicAllG();
    struct g* atomicAllGIndex(struct g** ptr, uintptr_t i);
    void forEachG(std::function<void (struct g* gp)> fn);
    void forEachGRace(std::function<void (struct g* gp)> fn);
    void cpuinit(std::string env);
    std::string getGodebugEarly();
    void schedinit();
    void dumpgstatus(struct g* gp);
    void checkmcount();
    int64_t mReserveID();
    void mcommoninit(struct m* mp, int64_t id);
    extern bool osHasLowResTimer;
    void ready(struct g* gp, int traceskip, bool next);
    void freezetheworld();
    uint32_t readgstatus(struct g* gp);
    void casfrom_Gscanstatus(struct g* gp, uint32_t oldval, uint32_t newval);
    bool castogscanstatus(struct g* gp, uint32_t oldval, uint32_t newval);
    extern bool casgstatusAlwaysTrack;
    void casgstatus(struct g* gp, uint32_t oldval, uint32_t newval);
    void casGToWaiting(struct g* gp, uint32_t old, golang::runtime::waitReason reason);
    uint32_t casgcopystack(struct g* gp);
    void casGToPreemptScan(struct g* gp, uint32_t old, uint32_t go_new);
    bool casGFromPreempted(struct g* gp, uint32_t old, uint32_t go_new);
    extern gocpp::array_base<std::string> stwReasonStrings;
    struct worldStop
    {
        golang::runtime::stwReason reason;
        int64_t start;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct worldStop& value);
    struct worldStop stopTheWorld(golang::runtime::stwReason reason);
    void startTheWorld(struct worldStop w);
    struct worldStop stopTheWorldGC(golang::runtime::stwReason reason);
    void startTheWorldGC(struct worldStop w);
    extern uint32_t worldsema;
    extern uint32_t gcsema;
    struct worldStop stopTheWorldWithSema(golang::runtime::stwReason reason);
    int64_t startTheWorldWithSema(int64_t now, struct worldStop w);
    bool usesLibcall();
    bool mStackIsSystemAllocated();
    void mstart();
    void mstart0();
    void mstart1();
    void mstartm0();
    void mPark();
    void mexit(bool osStack);
    void forEachP(golang::runtime::waitReason reason, std::function<void (p*)> fn);
    void forEachPInternal(std::function<void (p*)> fn);
    void runSafePointFn();
    struct cgothreadstart
    {
        golang::runtime::guintptr g;
        uint64_t* tls;
        unsafe::Pointer fn;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cgothreadstart& value);
    struct m* allocm(struct p* pp, std::function<void ()> fn, int64_t id);
    void needm(bool signal);
    void needAndBindM();
    void newextram();
    void oneNewExtraM();
    void dropm();
    void cgoBindM();
    uintptr_t getm();
    struct m* lockextra(bool nilokay);
    void unlockextra(struct m* mp, int32_t delta);
    std::tuple<struct m*, bool> getExtraM();
    void putExtraM(struct m* mp);
    void addExtraM(struct m* mp);
    extern std::string failthreadcreate;
    extern std::string failallocatestack;
    void newm(std::function<void ()> fn, struct p* pp, int64_t id);
    void newm1(struct m* mp);
    void startTemplateThread();
    void templateThread();
    void stopm();
    void mspinning();
    void startm(struct p* pp, bool spinning, bool lockheld);
    void handoffp(struct p* pp);
    void wakep();
    void stoplockedm();
    void startlockedm(struct g* gp);
    void gcstopm();
    void execute(struct g* gp, bool inheritTime);
    std::tuple<struct g*, bool, bool> findRunnable();
    bool pollWork();
    std::tuple<struct g*, bool, int64_t, int64_t, bool> stealWork(int64_t now);
    struct p* checkRunqsNoP(gocpp::slice<p*> allpSnapshot, pMask idlepMaskSnapshot);
    int64_t checkTimersNoP(gocpp::slice<p*> allpSnapshot, pMask timerpMaskSnapshot, int64_t pollUntil);
    std::tuple<struct p*, struct g*> checkIdleGCNoP();
    void wakeNetPoller(int64_t when);
    void resetspinning();
    void injectglist(struct gList* glist);
    void schedule();
    void dropg();
    std::tuple<int64_t, int64_t, bool> checkTimers(struct p* pp, int64_t now);
    bool parkunlock_c(struct g* gp, unsafe::Pointer lock);
    void park_m(struct g* gp);
    void goschedImpl(struct g* gp, bool preempted);
    void gosched_m(struct g* gp);
    void goschedguarded_m(struct g* gp);
    void gopreempt_m(struct g* gp);
    void preemptPark(struct g* gp);
    void goyield();
    void goyield_m(struct g* gp);
    void goexit1();
    void goexit0(struct g* gp);
    void gdestroy(struct g* gp);
    void save(uintptr_t pc, uintptr_t sp);
    void reentersyscall(uintptr_t pc, uintptr_t sp);
    void entersyscall();
    void entersyscall_sysmon();
    void entersyscall_gcwait();
    void entersyscallblock();
    void entersyscallblock_handoff();
    void exitsyscall();
    bool exitsyscallfast(struct p* oldp);
    void exitsyscallfast_reacquired(struct traceLocker trace);
    bool exitsyscallfast_pidle();
    void exitsyscall0(struct g* gp);
    void syscall_runtime_BeforeFork();
    void syscall_runtime_AfterFork();
    void syscall_runtime_AfterForkInChild();
    void syscall_runtime_BeforeExec();
    void syscall_runtime_AfterExec();
    struct g* malg(int32_t stacksize);
    void newproc(struct funcval* fn);
    struct g* newproc1(struct funcval* fn, struct g* callergp, uintptr_t callerpc);
    gocpp::slice<ancestorInfo>* saveAncestors(struct g* callergp);
    void gfput(struct p* pp, struct g* gp);
    struct g* gfget(struct p* pp);
    void gfpurge(struct p* pp);
    void Breakpoint();
    void dolockOSThread();
    void LockOSThread();
    void lockOSThread();
    void dounlockOSThread();
    void UnlockOSThread();
    void unlockOSThread();
    void badunlockosthread();
    int32_t gcount();
    int32_t mcount();
    void _System();
    void _ExternalCode();
    void _LostExternalCode();
    void _GC();
    void _LostSIGPROFDuringAtomic64();
    void _LostContendedRuntimeLock();
    void _VDSO();
    void sigprof(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp, struct m* mp);
    void setcpuprofilerate(int32_t hz);
    struct p* procresize(int32_t nprocs);
    void acquirep(struct p* pp);
    void wirep(struct p* pp);
    struct p* releasep();
    struct p* releasepNoTrace();
    void incidlelocked(int32_t v);
    void checkdead();
    extern int64_t forcegcperiod;
    extern bool needSysmonWorkaround;
    void sysmon();
    struct sysmontick
    {
        uint32_t schedtick;
        int64_t schedwhen;
        uint32_t syscalltick;
        int64_t syscallwhen;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sysmontick& value);
    uint32_t retake(int64_t now);
    bool preemptall();
    bool preemptone(struct p* pp);
    void schedtrace(bool detailed);
    void schedEnableUser(bool enable);
    bool schedEnabled(struct g* gp);
    void mput(struct m* mp);
    struct m* mget();
    void globrunqput(struct g* gp);
    void globrunqputhead(struct g* gp);
    void globrunqputbatch(struct gQueue* batch, int32_t n);
    struct g* globrunqget(struct p* pp, int32_t max);
    void updateTimerPMask(struct p* pp);
    int64_t pidleput(struct p* pp, int64_t now);
    std::tuple<struct p*, int64_t> pidleget(int64_t now);
    std::tuple<struct p*, int64_t> pidlegetSpinning(int64_t now);
    bool runqempty(struct p* pp);
    void runqput(struct p* pp, struct g* gp, bool next);
    bool runqputslow(struct p* pp, struct g* gp, uint32_t h, uint32_t t);
    void runqputbatch(struct p* pp, struct gQueue* q, int qsize);
    std::tuple<struct g*, bool> runqget(struct p* pp);
    std::tuple<struct gQueue, uint32_t> runqdrain(struct p* pp);
    uint32_t runqgrab(struct p* pp, gocpp::array<golang::runtime::guintptr, 256>* batch, uint32_t batchHead, bool stealRunNextG);
    struct g* runqsteal(struct p* pp, struct p* p2, bool stealRunNextG);
    struct gQueue
    {
        golang::runtime::guintptr head;
        golang::runtime::guintptr tail;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gQueue& value);
    struct gList
    {
        golang::runtime::guintptr head;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gList& value);
    int setMaxThreads(int in);
    int procPin();
    void procUnpin();
    int sync_runtime_procPin();
    void sync_runtime_procUnpin();
    int sync_atomic_runtime_procPin();
    void sync_atomic_runtime_procUnpin();
    bool sync_runtime_canSpin(int i);
    void sync_runtime_doSpin();
    struct randomOrder
    {
        uint32_t count;
        gocpp::slice<uint32_t> coprimes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct randomOrder& value);
    struct randomEnum
    {
        uint32_t i;
        uint32_t count;
        uint32_t pos;
        uint32_t inc;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct randomEnum& value);
    uint32_t gcd(uint32_t a, uint32_t b);
    struct initTask
    {
        uint32_t state;
        uint32_t nfns;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct initTask& value);
    struct tracestat
    {
        bool active;
        uint64_t id;
        uint64_t allocs;
        uint64_t bytes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct tracestat& value);
    void doInit(gocpp::slice<initTask*> ts);
    void doInit1(struct initTask* t);

    namespace rec
    {
        void becomeSpinning(struct m* mp);
        bool hasCgoOnStack(struct m* mp);
        std::string String(golang::runtime::stwReason r);
        bool isGC(golang::runtime::stwReason r);
        void init(struct p* pp, int32_t id);
        void destroy(struct p* pp);
        bool read(golang::runtime::pMask p, uint32_t id);
        void set(golang::runtime::pMask p, int32_t id);
        void clear(golang::runtime::pMask p, int32_t id);
        bool empty(struct gQueue* q);
        void push(struct gQueue* q, struct g* gp);
        void pushBack(struct gQueue* q, struct g* gp);
        void pushBackAll(struct gQueue* q, struct gQueue q2);
        struct g* pop(struct gQueue* q);
        struct gList popList(struct gQueue* q);
        bool empty(struct gList* l);
        void push(struct gList* l, struct g* gp);
        void pushAll(struct gList* l, struct gQueue q);
        struct g* pop(struct gList* l);
        void reset(struct randomOrder* ord, uint32_t count);
        struct randomEnum start(struct randomOrder* ord, uint32_t i);
        bool done(struct randomEnum* go_enum);
        void next(struct randomEnum* go_enum);
        uint32_t position(struct randomEnum* go_enum);
    }
}

