// generated by GoCpp from file '$(ImportDir)/runtime/mgclimit.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgclimit.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]

namespace golang::runtime
{
    struct gcCPULimiterState
    {
        atomic::Uint32 lock;
        atomic::Bool enabled;
        gocpp_id_0 bucket;
        uint64_t overflow;
        bool gcEnabled;
        bool transitioning;
        atomic::Int64 assistTimePool;
        atomic::Int64 idleMarkTimePool;
        atomic::Int64 idleTimePool;
        atomic::Int64 lastUpdate;
        atomic::Uint32 lastEnabledCycle;
        int32_t nprocs;
        bool test;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcCPULimiterState& value);
    bool limiting(struct gcCPULimiterState* l);
    void startGCTransition(struct gcCPULimiterState* l, bool enableGC, int64_t now);
    void finishGCTransition(struct gcCPULimiterState* l, int64_t now);
    bool needUpdate(struct gcCPULimiterState* l, int64_t now);
    void addAssistTime(struct gcCPULimiterState* l, int64_t t);
    void addIdleTime(struct gcCPULimiterState* l, int64_t t);
    void update(struct gcCPULimiterState* l, int64_t now);
    void updateLocked(struct gcCPULimiterState* l, int64_t now);
    void accumulate(struct gcCPULimiterState* l, int64_t mutatorTime, int64_t gcTime);
    bool tryLock(struct gcCPULimiterState* l);
    void unlock(struct gcCPULimiterState* l);
    void resetCapacity(struct gcCPULimiterState* l, int64_t now, int32_t nprocs);
    limiterEventStamp makeLimiterEventStamp(limiterEventType typ, int64_t now);
    int64_t duration(limiterEventStamp s, int64_t now);
    limiterEventType typ(limiterEventStamp s);
    struct limiterEvent
    {
        atomic::Uint64 stamp;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct limiterEvent& value);
    bool start(struct limiterEvent* e, limiterEventType typ, int64_t now);
    std::tuple<limiterEventType, int64_t> consume(struct limiterEvent* e, int64_t now);
    void stop(struct limiterEvent* e, limiterEventType typ, int64_t now);
}

