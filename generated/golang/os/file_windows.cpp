// generated by GoCpp from file '$(ImportDir)/os/file_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file_windows.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/reparse_windows.h"
#include "golang/internal/syscall/windows/symlink_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/internal/syscall/windows/zsyscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir_windows.h"
#include "golang/os/error.h"
#include "golang/os/file.h"
#include "golang/os/file_posix.h"
#include "golang/os/path_windows.h"
#include "golang/os/stat.h"
#include "golang/os/types.h"
#include "golang/runtime/mfinal.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/unsafe/unsafe.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace atomic::rec;
        using namespace errors::rec;
        using namespace fs::rec;
        using namespace os::rec;
        using namespace poll::rec;
        using namespace runtime::rec;
        using namespace sync::rec;
        using namespace syscall::rec;
        using namespace time::rec;
        using namespace unsafe::rec;
        using namespace windows::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    file::operator T()
    {
        T result;
        result.pfd = this->pfd;
        result.name = this->name;
        result.dirinfo = this->dirinfo;
        result.appendMode = this->appendMode;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool file::operator==(const T& ref) const
    {
        if (pfd != ref.pfd) return false;
        if (name != ref.name) return false;
        if (dirinfo != ref.dirinfo) return false;
        if (appendMode != ref.appendMode) return false;
        return true;
    }

    std::ostream& file::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pfd;
        os << " " << name;
        os << " " << dirinfo;
        os << " " << appendMode;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct file& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t rec::Fd(struct File* file)
    {
        if(file == nullptr)
        {
            return uintptr_t(syscall::InvalidHandle);
        }
        return uintptr_t(file->pfd.Sysfd);
    }

    struct File* newFile(syscall::Handle h, std::string name, std::string kind)
    {
        if(kind == "file")
        {
            uint32_t m = {};
            if(syscall::GetConsoleMode(h, & m) == nullptr)
            {
                kind = "console";
            }
            if(auto [t, err] = syscall::GetFileType(h); err == nullptr && t == syscall::FILE_TYPE_PIPE)
            {
                kind = "pipe";
            }
        }
        auto f = new File {gocpp::InitPtr<file>([=](auto& x) {
            x.pfd = gocpp::Init<poll::FD>([=](auto& x) {
                x.Sysfd = h;
                x.IsStream = true;
                x.ZeroReadIsEOF = true;
            });
            x.name = name;
        })};
        runtime::SetFinalizer(f->file, (*file)->close);
        rec::Init(gocpp::recv(f->pfd), kind, false);
        return f;
    }

    struct File* newConsoleFile(syscall::Handle h, std::string name)
    {
        return newFile(h, name, "console");
    }

    struct File* NewFile(uintptr_t fd, std::string name)
    {
        auto h = syscall::Handle(fd);
        if(h == syscall::InvalidHandle)
        {
            return nullptr;
        }
        return newFile(h, name, "file");
    }

    void epipecheck(struct File* file, struct gocpp::error e)
    {
    }

    std::string DevNull = "NUL";
    std::tuple<struct File*, struct gocpp::error> openFileNolog(std::string name, int flag, golang::os::FileMode perm)
    {
        if(name == "")
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "open";
                x.Path = name;
                x.Err = syscall::go_ENOENT;
            })};
        }
        auto path = fixLongPath(name);
        auto [r, e] = syscall::Open(path, flag | syscall::O_CLOEXEC, syscallMode(perm));
        if(e != nullptr)
        {
            if(e == syscall::ERROR_ACCESS_DENIED && (flag & O_WRONLY != 0 || flag & O_RDWR != 0))
            {
                auto [pathp, e1] = syscall::UTF16PtrFromString(path);
                if(e1 == nullptr)
                {
                    syscall::Win32FileAttributeData fa = {};
                    e1 = syscall::GetFileAttributesEx(pathp, syscall::GetFileExInfoStandard, (unsigned char*)(unsafe::Pointer(& fa)));
                    if(e1 == nullptr && fa.FileAttributes & syscall::FILE_ATTRIBUTE_DIRECTORY != 0)
                    {
                        e = syscall::go_EISDIR;
                    }
                }
            }
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "open";
                x.Path = name;
                x.Err = e;
            })};
        }
        File* f;
        std::tie(f, e) = std::tuple{newFile(r, name, "file"), nullptr};
        if(e != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "open";
                x.Path = name;
                x.Err = e;
            })};
        }
        return {f, nullptr};
    }

    struct gocpp::error rec::close(struct file* file)
    {
        if(file == nullptr)
        {
            return syscall::go_EINVAL;
        }
        if(file->dirinfo != nullptr)
        {
            rec::close(gocpp::recv(file->dirinfo));
            file->dirinfo = nullptr;
        }
        gocpp::error err = {};
        if(auto e = rec::Close(gocpp::recv(file->pfd)); e != nullptr)
        {
            if(e == poll::ErrFileClosing)
            {
                e = ErrClosed;
            }
            err = gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "close";
                x.Path = file->name;
                x.Err = e;
            });
        }
        runtime::SetFinalizer(file, nullptr);
        return err;
    }

    std::tuple<int64_t, struct gocpp::error> rec::seek(struct File* f, int64_t offset, int whence)
    {
        int64_t ret;
        struct gocpp::error err;
        if(f->dirinfo != nullptr)
        {
            int64_t ret;
            struct gocpp::error err;
            rec::close(gocpp::recv(f->dirinfo));
            f->dirinfo = nullptr;
        }
        std::tie(ret, err) = rec::Seek(gocpp::recv(f->pfd), offset, whence);
        runtime::KeepAlive(f);
        return {ret, err};
    }

    struct gocpp::error Truncate(std::string name, int64_t size)
    {
        gocpp::Defer defer;
        try
        {
            auto [f, e] = OpenFile(name, O_WRONLY, 0666);
            if(e != nullptr)
            {
                return e;
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(f)); });
            auto e1 = rec::Truncate(gocpp::recv(f), size);
            if(e1 != nullptr)
            {
                return e1;
            }
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error Remove(std::string name)
    {
        auto [p, e] = syscall::UTF16PtrFromString(fixLongPath(name));
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "remove";
                x.Path = name;
                x.Err = e;
            });
        }
        e = syscall::DeleteFile(p);
        if(e == nullptr)
        {
            return nullptr;
        }
        auto e1 = syscall::RemoveDirectory(p);
        if(e1 == nullptr)
        {
            return nullptr;
        }
        if(e1 != e)
        {
            auto [a, e2] = syscall::GetFileAttributes(p);
            if(e2 != nullptr)
            {
                e = e2;
            }
            else
            {
                if(a & syscall::FILE_ATTRIBUTE_DIRECTORY != 0)
                {
                    e = e1;
                }
                else
                if(a & syscall::FILE_ATTRIBUTE_READONLY != 0)
                {
                    if(e1 = syscall::SetFileAttributes(p, a &^ syscall::FILE_ATTRIBUTE_READONLY); e1 == nullptr)
                    {
                        if(e = syscall::DeleteFile(p); e == nullptr)
                        {
                            return nullptr;
                        }
                    }
                }
            }
        }
        return gocpp::InitPtr<os::PathError>([=](auto& x) {
            x.Op = "remove";
            x.Path = name;
            x.Err = e;
        });
    }

    struct gocpp::error rename(std::string oldname, std::string newname)
    {
        auto e = windows::Rename(fixLongPath(oldname), fixLongPath(newname));
        if(e != nullptr)
        {
            return new LinkError {"rename", oldname, newname, e};
        }
        return nullptr;
    }

    std::tuple<struct File*, struct File*, struct gocpp::error> Pipe()
    {
        struct File* r;
        struct File* w;
        struct gocpp::error err;
        gocpp::array<syscall::Handle, 2> p = {};
        auto e = syscall::Pipe(p.make_slice(0));
        if(e != nullptr)
        {
            struct File* r;
            struct File* w;
            struct gocpp::error err;
            return {nullptr, nullptr, NewSyscallError("pipe", e)};
        }
        return {newFile(p[0], "|0", "pipe"), newFile(p[1], "|1", "pipe"), nullptr};
    }

    sync::Once useGetTempPath2Once;
    bool useGetTempPath2;
    std::string tempDir()
    {
        rec::Do(gocpp::recv(useGetTempPath2Once), [=]() mutable -> void
        {
            useGetTempPath2 = (windows::ErrorLoadingGetTempPath2() == nullptr);
        });
        auto getTempPath = syscall::GetTempPath;
        if(useGetTempPath2)
        {
            getTempPath = windows::GetTempPath2;
        }
        auto n = uint32_t(syscall::MAX_PATH);
        for(; ; )
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            std::tie(n, gocpp_id_0) = getTempPath(uint32_t(len(b)), & b[0]);
            if(n > uint32_t(len(b)))
            {
                continue;
            }
            if(n == 3 && b[1] == ':' && b[2] == '\\')
            {
            }
            else
            if(n > 0 && b[n - 1] == '\\')
            {
                n--;
            }
            return syscall::UTF16ToString(b.make_slice(0, n));
        }
    }

    struct gocpp::error Link(std::string oldname, std::string newname)
    {
        auto [n, err] = syscall::UTF16PtrFromString(fixLongPath(newname));
        if(err != nullptr)
        {
            return new LinkError {"link", oldname, newname, err};
        }
        uint16_t* o;
        std::tie(o, err) = syscall::UTF16PtrFromString(fixLongPath(oldname));
        if(err != nullptr)
        {
            return new LinkError {"link", oldname, newname, err};
        }
        err = syscall::CreateHardLink(n, o, 0);
        if(err != nullptr)
        {
            return new LinkError {"link", oldname, newname, err};
        }
        return nullptr;
    }

    struct gocpp::error Symlink(std::string oldname, std::string newname)
    {
        oldname = fromSlash(oldname);
        auto destpath = oldname;
        if(auto v = volumeName(oldname); v == "")
        {
            if(len(oldname) > 0 && IsPathSeparator(oldname[0]))
            {
                if(v = volumeName(newname); v != "")
                {
                    destpath = v + oldname;
                }
            }
            else
            {
                destpath = dirname(newname) + "\\" + oldname;
            }
        }
        auto [fi, err] = Stat(destpath);
        auto isdir = err == nullptr && rec::IsDir(gocpp::recv(fi));
        uint16_t* n;
        std::tie(n, err) = syscall::UTF16PtrFromString(fixLongPath(newname));
        if(err != nullptr)
        {
            return new LinkError {"symlink", oldname, newname, err};
        }
        uint16_t* o;
        std::tie(o, err) = syscall::UTF16PtrFromString(fixLongPath(oldname));
        if(err != nullptr)
        {
            return new LinkError {"symlink", oldname, newname, err};
        }
        uint32_t flags = windows::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;
        if(isdir)
        {
            flags |= syscall::SYMBOLIC_LINK_FLAG_DIRECTORY;
        }
        err = syscall::CreateSymbolicLink(n, o, flags);
        if(err != nullptr)
        {
            flags &^= windows::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;
            err = syscall::CreateSymbolicLink(n, o, flags);
            if(err != nullptr)
            {
                return new LinkError {"symlink", oldname, newname, err};
            }
        }
        return nullptr;
    }

    std::tuple<syscall::Handle, struct gocpp::error> openSymlink(std::string path)
    {
        auto [p, err] = syscall::UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return {0, err};
        }
        auto attrs = uint32_t(syscall::FILE_FLAG_BACKUP_SEMANTICS);
        attrs |= syscall::FILE_FLAG_OPEN_REPARSE_POINT;
        syscall::Handle h;
        std::tie(h, err) = syscall::CreateFile(p, 0, 0, nullptr, syscall::OPEN_EXISTING, attrs, 0);
        if(err != nullptr)
        {
            return {0, err};
        }
        return {h, nullptr};
    }

    std::tuple<std::string, struct gocpp::error> normaliseLinkPath(std::string path)
    {
        gocpp::Defer defer;
        try
        {
            if(len(path) < 4 || path.make_slice(0, 4) != "\\??\\")
            {
                return {path, nullptr};
            }
            auto s = path.make_slice(4);
            //Go switch emulation
            {
                int conditionId = -1;
                if(len(s) >= 2 && s[1] == ':') { conditionId = 0; }
                else if(len(s) >= 4 && s.make_slice(0, 4) == "UNC\\") { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        return {s, nullptr};
                        break;
                    case 1:
                        return {"\\\\" + s.make_slice(4), nullptr};
                        break;
                }
            }
            auto [h, err] = openSymlink(path);
            if(err != nullptr)
            {
                return {"", err};
            }
            defer.push_back([=]{ syscall::CloseHandle(h); });
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 100);
            for(; ; )
            {
                auto [n, err] = windows::GetFinalPathNameByHandle(h, & buf[0], uint32_t(len(buf)), windows::VOLUME_NAME_DOS);
                if(err != nullptr)
                {
                    return {"", err};
                }
                if(n < uint32_t(len(buf)))
                {
                    break;
                }
                buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            }
            s = syscall::UTF16ToString(buf);
            if(len(s) > 4 && s.make_slice(0, 4) == "\\\\?\\")
            {
                s = s.make_slice(4);
                if(len(s) > 3 && s.make_slice(0, 3) == "UNC")
                {
                    return {"\\" + s.make_slice(3), nullptr};
                }
                return {s, nullptr};
            }
            return {"", errors::New("GetFinalPathNameByHandle returned unexpected path: " + s)};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<std::string, struct gocpp::error> readReparseLink(std::string path)
    {
        gocpp::Defer defer;
        try
        {
            auto [h, err] = openSymlink(path);
            if(err != nullptr)
            {
                return {"", err};
            }
            defer.push_back([=]{ syscall::CloseHandle(h); });
            auto rdbbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), syscall::MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
            uint32_t bytesReturned = {};
            err = syscall::DeviceIoControl(h, syscall::FSCTL_GET_REPARSE_POINT, nullptr, 0, & rdbbuf[0], uint32_t(len(rdbbuf)), & bytesReturned, nullptr);
            if(err != nullptr)
            {
                return {"", err};
            }
            auto rdb = (windows::REPARSE_DATA_BUFFER*)(unsafe::Pointer(& rdbbuf[0]));
            //Go switch emulation
            {
                auto condition = rdb->ReparseTag;
                int conditionId = -1;
                if(condition == syscall::IO_REPARSE_TAG_SYMLINK) { conditionId = 0; }
                else if(condition == windows::IO_REPARSE_TAG_MOUNT_POINT) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        auto rb = (windows::SymbolicLinkReparseBuffer*)(unsafe::Pointer(& rdb->DUMMYUNIONNAME));
                        auto s = rec::Path(gocpp::recv(rb));
                        if(rb->Flags & windows::SYMLINK_FLAG_RELATIVE != 0)
                        {
                            return {s, nullptr};
                        }
                        return normaliseLinkPath(s);
                        break;
                    case 1:
                        return normaliseLinkPath(rec::Path(gocpp::recv((windows::MountPointReparseBuffer*)(unsafe::Pointer(& rdb->DUMMYUNIONNAME)))));
                        break;
                    default:
                        return {"", syscall::go_ENOENT};
                        break;
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<std::string, struct gocpp::error> readlink(std::string name)
    {
        auto [s, err] = readReparseLink(fixLongPath(name));
        if(err != nullptr)
        {
            return {"", gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "readlink";
                x.Path = name;
                x.Err = err;
            })};
        }
        return {s, nullptr};
    }

}

