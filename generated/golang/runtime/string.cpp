// generated by GoCpp from file '$(ImportDir)/runtime/string.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/string.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/asan0.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/msize_allocheaders.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/slice.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace bytealg::rec;
        using namespace chacha8rand::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    std::string concatstrings(tmpBuf* buf, gocpp::slice<std::string> a)
    {
        auto idx = 0;
        auto l = 0;
        auto count = 0;
        for(auto [i, x] : a)
        {
            auto n = len(x);
            if(n == 0)
            {
                continue;
            }
            if(l + n < l)
            {
                go_throw("string concatenation too long");
            }
            l += n;
            count++;
            idx = i;
        }
        if(count == 0)
        {
            return "";
        }
        if(count == 1 && (buf != nullptr || ! stringDataOnStack(a[idx])))
        {
            return a[idx];
        }
        auto [s, b] = rawstringtmp(buf, l);
        for(auto [gocpp_ignored, x] : a)
        {
            copy(b, x);
            b = b.make_slice(len(x));
        }
        return s;
    }

    std::string concatstring2(tmpBuf* buf, std::string a0, std::string a1)
    {
        return concatstrings(buf, gocpp::slice<std::string> {a0, a1});
    }

    std::string concatstring3(tmpBuf* buf, std::string a0, std::string a1, std::string a2)
    {
        return concatstrings(buf, gocpp::slice<std::string> {a0, a1, a2});
    }

    std::string concatstring4(tmpBuf* buf, std::string a0, std::string a1, std::string a2, std::string a3)
    {
        return concatstrings(buf, gocpp::slice<std::string> {a0, a1, a2, a3});
    }

    std::string concatstring5(tmpBuf* buf, std::string a0, std::string a1, std::string a2, std::string a3, std::string a4)
    {
        return concatstrings(buf, gocpp::slice<std::string> {a0, a1, a2, a3, a4});
    }

    std::string slicebytetostring(tmpBuf* buf, unsigned char* ptr, int n)
    {
        if(n == 0)
        {
            return "";
        }
        if(raceenabled)
        {
            racereadrangepc(unsafe::Pointer(ptr), uintptr_t(n), getcallerpc(), abi::FuncPCABIInternal(slicebytetostring));
        }
        if(msanenabled)
        {
            msanread(unsafe::Pointer(ptr), uintptr_t(n));
        }
        if(asanenabled)
        {
            asanread(unsafe::Pointer(ptr), uintptr_t(n));
        }
        if(n == 1)
        {
            auto p = unsafe::Pointer(& staticuint64s[*ptr]);
            if(goarch::BigEndian)
            {
                p = add(p, 7);
            }
            return unsafe::String((unsigned char*)(p), 1);
        }
        unsafe::Pointer p = {};
        if(buf != nullptr && n <= len(buf))
        {
            p = unsafe::Pointer(buf);
        }
        else
        {
            p = mallocgc(uintptr_t(n), nullptr, false);
        }
        memmove(p, unsafe::Pointer(ptr), uintptr_t(n));
        return unsafe::String((unsigned char*)(p), n);
    }

    bool stringDataOnStack(std::string s)
    {
        auto ptr = uintptr_t(unsafe::Pointer(unsafe::StringData(s)));
        auto stk = getg()->stack;
        return stk.lo <= ptr && ptr < stk.hi;
    }

    std::tuple<std::string, gocpp::slice<unsigned char>> rawstringtmp(tmpBuf* buf, int l)
    {
        std::string s;
        gocpp::slice<unsigned char> b;
        if(buf != nullptr && l <= len(buf))
        {
            std::string s;
            gocpp::slice<unsigned char> b;
            b = buf.make_slice(0, l);
            s = slicebytetostringtmp(& b[0], len(b));
        }
        else
        {
            std::string s;
            gocpp::slice<unsigned char> b;
            std::tie(s, b) = rawstring(l);
        }
        return {s, b};
    }

    std::string slicebytetostringtmp(unsigned char* ptr, int n)
    {
        if(raceenabled && n > 0)
        {
            racereadrangepc(unsafe::Pointer(ptr), uintptr_t(n), getcallerpc(), abi::FuncPCABIInternal(slicebytetostringtmp));
        }
        if(msanenabled && n > 0)
        {
            msanread(unsafe::Pointer(ptr), uintptr_t(n));
        }
        if(asanenabled && n > 0)
        {
            asanread(unsafe::Pointer(ptr), uintptr_t(n));
        }
        return unsafe::String(ptr, n);
    }

    gocpp::slice<unsigned char> stringtoslicebyte(tmpBuf* buf, std::string s)
    {
        gocpp::slice<unsigned char> b = {};
        if(buf != nullptr && len(s) <= len(buf))
        {
            *buf = tmpBuf {};
            b = buf.make_slice(0, len(s));
        }
        else
        {
            b = rawbyteslice(len(s));
        }
        copy(b, s);
        return b;
    }

    gocpp::slice<gocpp::rune> stringtoslicerune(gocpp::array<gocpp::rune, tmpStringBufSize>* buf, std::string s)
    {
        auto n = 0;
        for(const auto& _ : s)
        {
            n++;
        }
        gocpp::slice<gocpp::rune> a = {};
        if(buf != nullptr && n <= len(buf))
        {
            *buf = gocpp::array<gocpp::rune, tmpStringBufSize> {};
            a = buf.make_slice(0, n);
        }
        else
        {
            a = rawruneslice(n);
        }
        n = 0;
        for(auto [gocpp_ignored, r] : s)
        {
            a[n] = r;
            n++;
        }
        return a;
    }

    std::string slicerunetostring(tmpBuf* buf, gocpp::slice<gocpp::rune> a)
    {
        if(raceenabled && len(a) > 0)
        {
            racereadrangepc(unsafe::Pointer(& a[0]), uintptr_t(len(a)) * gocpp::Sizeof<gocpp::rune>(), getcallerpc(), abi::FuncPCABIInternal(slicerunetostring));
        }
        if(msanenabled && len(a) > 0)
        {
            msanread(unsafe::Pointer(& a[0]), uintptr_t(len(a)) * gocpp::Sizeof<gocpp::rune>());
        }
        if(asanenabled && len(a) > 0)
        {
            asanread(unsafe::Pointer(& a[0]), uintptr_t(len(a)) * gocpp::Sizeof<gocpp::rune>());
        }
        gocpp::array<unsigned char, 4> dum = {};
        auto size1 = 0;
        for(auto [gocpp_ignored, r] : a)
        {
            size1 += encoderune(dum.make_slice(0, ), r);
        }
        auto [s, b] = rawstringtmp(buf, size1 + 3);
        auto size2 = 0;
        for(auto [gocpp_ignored, r] : a)
        {
            if(size2 >= size1)
            {
                break;
            }
            size2 += encoderune(b.make_slice(size2), r);
        }
        return s.make_slice(0, size2);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    stringStruct::operator T()
    {
        T result;
        result.str = this->str;
        result.len = this->len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stringStruct::operator==(const T& ref) const
    {
        if (str != ref.str) return false;
        if (len != ref.len) return false;
        return true;
    }

    std::ostream& stringStruct::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << str;
        os << " " << len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stringStruct& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    stringStructDWARF::operator T()
    {
        T result;
        result.str = this->str;
        result.len = this->len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stringStructDWARF::operator==(const T& ref) const
    {
        if (str != ref.str) return false;
        if (len != ref.len) return false;
        return true;
    }

    std::ostream& stringStructDWARF::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << str;
        os << " " << len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stringStructDWARF& value)
    {
        return value.PrintTo(os);
    }

    struct stringStruct* stringStructOf(std::string* sp)
    {
        return (stringStruct*)(unsafe::Pointer(sp));
    }

    std::string intstring(gocpp::array<unsigned char, 4>* buf, int64_t v)
    {
        std::string s;
        gocpp::slice<unsigned char> b = {};
        if(buf != nullptr)
        {
            std::string s;
            b = buf.make_slice(0, );
            s = slicebytetostringtmp(& b[0], len(b));
        }
        else
        {
            std::string s;
            std::tie(s, b) = rawstring(4);
        }
        if(int64_t(rune(v)) != v)
        {
            std::string s;
            v = runeError;
        }
        auto n = encoderune(b, rune(v));
        return s.make_slice(0, n);
    }

    std::tuple<std::string, gocpp::slice<unsigned char>> rawstring(int size)
    {
        std::string s;
        gocpp::slice<unsigned char> b;
        auto p = mallocgc(uintptr_t(size), nullptr, false);
        return {unsafe::String((unsigned char*)(p), size), unsafe::Slice((unsigned char*)(p), size)};
    }

    gocpp::slice<unsigned char> rawbyteslice(int size)
    {
        gocpp::slice<unsigned char> b;
        auto cap = roundupsize(uintptr_t(size), true);
        auto p = mallocgc(cap, nullptr, false);
        if(cap != uintptr_t(size))
        {
            gocpp::slice<unsigned char> b;
            memclrNoHeapPointers(add(p, uintptr_t(size)), cap - uintptr_t(size));
        }
        *(slice*)(unsafe::Pointer(& b)) = slice {p, size, int(cap)};
        return b;
    }

    gocpp::slice<gocpp::rune> rawruneslice(int size)
    {
        gocpp::slice<gocpp::rune> b;
        if(uintptr_t(size) > maxAlloc / 4)
        {
            gocpp::slice<gocpp::rune> b;
            go_throw("out of memory");
        }
        auto mem = roundupsize(uintptr_t(size) * 4, true);
        auto p = mallocgc(mem, nullptr, false);
        if(mem != uintptr_t(size) * 4)
        {
            gocpp::slice<gocpp::rune> b;
            memclrNoHeapPointers(add(p, uintptr_t(size) * 4), mem - uintptr_t(size) * 4);
        }
        *(slice*)(unsafe::Pointer(& b)) = slice {p, size, int(mem / 4)};
        return b;
    }

    gocpp::slice<unsigned char> gobytes(unsigned char* p, int n)
    {
        gocpp::slice<unsigned char> b;
        if(n == 0)
        {
            gocpp::slice<unsigned char> b;
            return gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0);
        }
        if(n < 0 || uintptr_t(n) > maxAlloc)
        {
            gocpp::slice<unsigned char> b;
            gocpp::panic(errorString("gobytes: length out of range"));
        }
        auto bp = mallocgc(uintptr_t(n), nullptr, false);
        memmove(bp, unsafe::Pointer(p), uintptr_t(n));
        *(slice*)(unsafe::Pointer(& b)) = slice {bp, n, n};
        return b;
    }

    std::string gostring(unsigned char* p)
    {
        auto l = findnull(p);
        if(l == 0)
        {
            return "";
        }
        auto [s, b] = rawstring(l);
        memmove(unsafe::Pointer(& b[0]), unsafe::Pointer(p), uintptr_t(l));
        return s;
    }

    std::string internal_syscall_gostring(unsigned char* p)
    {
        return gostring(p);
    }

    std::string gostringn(unsigned char* p, int l)
    {
        if(l == 0)
        {
            return "";
        }
        auto [s, b] = rawstring(l);
        memmove(unsafe::Pointer(& b[0]), unsafe::Pointer(p), uintptr_t(l));
        return s;
    }

    bool hasPrefix(std::string s, std::string prefix)
    {
        return len(s) >= len(prefix) && s.make_slice(0, len(prefix)) == prefix;
    }

    bool hasSuffix(std::string s, std::string suffix)
    {
        return len(s) >= len(suffix) && s.make_slice(len(s) - len(suffix)) == suffix;
    }

    std::tuple<int64_t, bool> atoi64(std::string s)
    {
        if(s == "")
        {
            return {0, false};
        }
        auto neg = false;
        if(s[0] == '-')
        {
            neg = true;
            s = s.make_slice(1);
        }
        auto un = uint64_t(0);
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c < '0' || c > '9')
            {
                return {0, false};
            }
            if(un > maxUint64 / 10)
            {
                return {0, false};
            }
            un *= 10;
            auto un1 = un + uint64_t(c) - '0';
            if(un1 < un)
            {
                return {0, false};
            }
            un = un1;
        }
        if(! neg && un > uint64_t(maxInt64))
        {
            return {0, false};
        }
        if(neg && un > uint64_t(maxInt64) + 1)
        {
            return {0, false};
        }
        auto n = int64_t(un);
        if(neg)
        {
            n = - n;
        }
        return {n, true};
    }

    std::tuple<int, bool> atoi(std::string s)
    {
        if(auto [n, ok] = atoi64(s); n == int64_t(int(n)))
        {
            return {int(n), ok};
        }
        return {0, false};
    }

    std::tuple<int32_t, bool> atoi32(std::string s)
    {
        if(auto [n, ok] = atoi64(s); n == int64_t(int32_t(n)))
        {
            return {int32_t(n), ok};
        }
        return {0, false};
    }

    std::tuple<int64_t, bool> parseByteCount(std::string s)
    {
        if(s == "")
        {
            return {0, false};
        }
        auto last = s[len(s) - 1];
        if(last >= '0' && last <= '9')
        {
            auto [n, ok] = atoi64(s);
            if(! ok || n < 0)
            {
                return {0, false};
            }
            return {n, ok};
        }
        if(last != 'B' || len(s) < 2)
        {
            return {0, false};
        }
        if(auto c = s[len(s) - 2]; c >= '0' && c <= '9')
        {
            auto [n, ok] = atoi64(s.make_slice(0, len(s) - 1));
            if(! ok || n < 0)
            {
                return {0, false};
            }
            return {n, ok};
        }
        else
        if(c != 'i')
        {
            return {0, false};
        }
        if(len(s) < 4)
        {
            return {0, false};
        }
        auto power = 0;
        //Go switch emulation
        {
            auto condition = s[len(s) - 3];
            int conditionId = -1;
            if(condition == 'K') { conditionId = 0; }
            else if(condition == 'M') { conditionId = 1; }
            else if(condition == 'G') { conditionId = 2; }
            else if(condition == 'T') { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    power = 1;
                    break;
                case 1:
                    power = 2;
                    break;
                case 2:
                    power = 3;
                    break;
                case 3:
                    power = 4;
                    break;
                default:
                    return {0, false};
                    break;
            }
        }
        auto m = uint64_t(1);
        for(auto i = 0; i < power; i++)
        {
            m *= 1024;
        }
        auto [n, ok] = atoi64(s.make_slice(0, len(s) - 3));
        if(! ok || n < 0)
        {
            return {0, false};
        }
        auto un = uint64_t(n);
        if(un > maxUint64 / m)
        {
            return {0, false};
        }
        un *= m;
        if(un > uint64_t(maxInt64))
        {
            return {0, false};
        }
        return {int64_t(un), true};
    }

    int findnull(unsigned char* s)
    {
        if(s == nullptr)
        {
            return 0;
        }
        if(GOOS == "plan9")
        {
            auto p = (gocpp::array<unsigned char, maxAlloc / 2 - 1>*)(unsafe::Pointer(s));
            auto l = 0;
            for(; p[l] != 0; )
            {
                l++;
            }
            return l;
        }
        auto pageSize = 4096;
        auto offset = 0;
        auto ptr = unsafe::Pointer(s);
        auto safeLen = int(pageSize - uintptr_t(ptr) % pageSize);
        for(; ; )
        {
            auto t = *(std::string*)(unsafe::Pointer(new stringStruct {ptr, safeLen}));
            if(auto i = bytealg::IndexByteString(t, 0); i != - 1)
            {
                return offset + i;
            }
            ptr = unsafe::Pointer(uintptr_t(ptr) + uintptr_t(safeLen));
            offset += safeLen;
            safeLen = pageSize;
        }
    }

    int findnullw(uint16_t* s)
    {
        if(s == nullptr)
        {
            return 0;
        }
        auto p = (gocpp::array<uint16_t, maxAlloc / 2 / 2 - 1>*)(unsafe::Pointer(s));
        auto l = 0;
        for(; p[l] != 0; )
        {
            l++;
        }
        return l;
    }

    std::string gostringnocopy(unsigned char* str)
    {
        auto ss = gocpp::Init<stringStruct>([](stringStruct& x) { x.str = unsafe::Pointer(str); x.len = findnull(str); });
        auto s = *(std::string*)(unsafe::Pointer(& ss));
        return s;
    }

    std::string gostringw(uint16_t* strw)
    {
        gocpp::array<unsigned char, 8> buf = {};
        auto str = (gocpp::array<uint16_t, maxAlloc / 2 / 2 - 1>*)(unsafe::Pointer(strw));
        auto n1 = 0;
        for(auto i = 0; str[i] != 0; i++)
        {
            n1 += encoderune(buf.make_slice(0, ), rune(str[i]));
        }
        auto [s, b] = rawstring(n1 + 4);
        auto n2 = 0;
        for(auto i = 0; str[i] != 0; i++)
        {
            if(n2 >= n1)
            {
                break;
            }
            n2 += encoderune(b.make_slice(n2), rune(str[i]));
        }
        b[n2] = 0;
        return s.make_slice(0, n2);
    }

}

