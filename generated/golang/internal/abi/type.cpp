// generated by GoCpp from file '$(ImportDir)/internal/abi/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/type.h"
#include "gocpp/support.h"

#include "golang/unsafe/unsafe.h"

namespace golang::abi
{
    
    std::ostream& Type::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size_;
        os << " " << PtrBytes;
        os << " " << Hash;
        os << " " << TFlag;
        os << " " << Align_;
        os << " " << FieldAlign_;
        os << " " << Kind_;
        os << " " << Equal;
        os << " " << GCData;
        os << " " << Str;
        os << " " << PtrToThis;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value)
    {
        return value.PrintTo(os);
    }

    std::string String(Kind k)
    {
        if(int(k) < len(kindNames))
        {
            return kindNames[k];
        }
        return kindNames[0];
    }

    gocpp::slice<std::string> kindNames = gocpp::Init<gocpp::slice<std::string>>([](gocpp::slice<std::string>& x) { x.Invalid = "invalid"; x.Bool = "bool"; x.Int = "int"; x.Int8 = "int8"; x.Int16 = "int16"; x.Int32 = "int32"; x.Int64 = "int64"; x.Uint = "uint"; x.Uint8 = "uint8"; x.Uint16 = "uint16"; x.Uint32 = "uint32"; x.Uint64 = "uint64"; x.Uintptr = "uintptr"; x.Float32 = "float32"; x.Float64 = "float64"; x.Complex64 = "complex64"; x.Complex128 = "complex128"; x.Array = "array"; x.Chan = "chan"; x.Func = "func"; x.Interface = "interface"; x.Map = "map"; x.Pointer = "ptr"; x.Slice = "slice"; x.String = "string"; x.Struct = "struct"; x.UnsafePointer = "unsafe.Pointer"; });
    Kind Kind(struct Type* t)
    {
        return Kind(t->Kind_ & KindMask);
    }

    bool HasName(struct Type* t)
    {
        return t->TFlag & TFlagNamed != 0;
    }

    bool Pointers(struct Type* t)
    {
        return t->PtrBytes != 0;
    }

    bool IfaceIndir(struct Type* t)
    {
        return t->Kind_ & KindDirectIface == 0;
    }

    bool IsDirectIface(struct Type* t)
    {
        return t->Kind_ & KindDirectIface != 0;
    }

    gocpp::slice<unsigned char> GcSlice(struct Type* t, uintptr_t begin, uintptr_t end)
    {
        return unsafe::Slice(t->GCData, int(end)).make_slice(begin);
    }

    
    std::ostream& Method::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Mtyp;
        os << " " << Ifn;
        os << " " << Tfn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Method& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& UncommonType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PkgPath;
        os << " " << Mcount;
        os << " " << Xcount;
        os << " " << Moff;
        os << " " << _;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct UncommonType& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<Method> Methods(struct UncommonType* t)
    {
        if(t->Mcount == 0)
        {
            return nullptr;
        }
        return (gocpp::array<Method, 1 << 16>*)(addChecked(unsafe::Pointer(t), uintptr_t(t->Moff), "t.mcount > 0")).make_slice(, t->Mcount, t->Mcount);
    }

    gocpp::slice<Method> ExportedMethods(struct UncommonType* t)
    {
        if(t->Xcount == 0)
        {
            return nullptr;
        }
        return (gocpp::array<Method, 1 << 16>*)(addChecked(unsafe::Pointer(t), uintptr_t(t->Moff), "t.xcount > 0")).make_slice(, t->Xcount, t->Xcount);
    }

    unsafe::Pointer addChecked(unsafe::Pointer p, uintptr_t x, std::string whySafe)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    
    std::ostream& Imethod::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Typ;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Imethod& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& ArrayType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << " " << Slice;
        os << " " << Len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ArrayType& value)
    {
        return value.PrintTo(os);
    }

    int Len(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) == Array)
        {
            return int((ArrayType*)(unsafe::Pointer(t))->Len);
        }
        return 0;
    }

    Type* Common(struct Type* t)
    {
        return t;
    }

    
    std::ostream& ChanType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << " " << Dir;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ChanType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& structTypeUncommon::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value)
    {
        return value.PrintTo(os);
    }

    ChanDir ChanDir(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) == Chan)
        {
            auto ch = (ChanType*)(unsafe::Pointer(t));
            return ch->Dir;
        }
        return InvalidDir;
    }

    UncommonType* Uncommon(struct Type* t)
    {
        if(t->TFlag & TFlagUncommon == 0)
        {
            return nullptr;
        }
        //Go switch emulation
        {
            auto condition = Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == Struct) { conditionId = 0; }
            else if(condition == Pointer) { conditionId = 1; }
            else if(condition == Func) { conditionId = 2; }
            else if(condition == Slice) { conditionId = 3; }
            else if(condition == Array) { conditionId = 4; }
            else if(condition == Chan) { conditionId = 5; }
            else if(condition == Map) { conditionId = 6; }
            else if(condition == Interface) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return & (structTypeUncommon*)(unsafe::Pointer(t))->u;
                    break;
                case 1:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 2:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 3:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 4:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 5:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 6:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                case 7:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
                default:
                    
                    std::ostream& u::PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << "" << u;
                        os << '}';
                        return os;
                    }

                    std::ostream& operator<<(std::ostream& os, const struct u& value)
                    {
                        return value.PrintTo(os);
                    }

                    return & (u*)(unsafe::Pointer(t))->u;
                    break;
            }
        }
    }

    Type* Elem(struct Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == Pointer) { conditionId = 3; }
            else if(condition == Slice) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    auto tt = (ArrayType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 1:
                    auto tt = (ChanType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 2:
                    auto tt = (MapType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 3:
                    auto tt = (PtrType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
                case 4:
                    auto tt = (SliceType*)(unsafe::Pointer(t));
                    return tt->Elem;
                    break;
            }
        }
        return nullptr;
    }

    StructType* StructType(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) != Struct)
        {
            return nullptr;
        }
        return (StructType*)(unsafe::Pointer(t));
    }

    MapType* MapType(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) != Map)
        {
            return nullptr;
        }
        return (MapType*)(unsafe::Pointer(t));
    }

    ArrayType* ArrayType(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) != Array)
        {
            return nullptr;
        }
        return (ArrayType*)(unsafe::Pointer(t));
    }

    FuncType* FuncType(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) != Func)
        {
            return nullptr;
        }
        return (FuncType*)(unsafe::Pointer(t));
    }

    InterfaceType* InterfaceType(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) != Interface)
        {
            return nullptr;
        }
        return (InterfaceType*)(unsafe::Pointer(t));
    }

    uintptr_t Size(struct Type* t)
    {
        return t->Size_;
    }

    int Align(struct Type* t)
    {
        return int(t->Align_);
    }

    int FieldAlign(struct Type* t)
    {
        return int(t->FieldAlign_);
    }

    
    std::ostream& InterfaceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PkgPath;
        os << " " << Methods;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct InterfaceType& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<Method> ExportedMethods(struct Type* t)
    {
        auto ut = Uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return nullptr;
        }
        return ExportedMethods(gocpp::recv(ut));
    }

    int NumMethod(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (InterfaceType*)(unsafe::Pointer(t));
            return NumMethod(gocpp::recv(tt));
        }
        return len(ExportedMethods(gocpp::recv(t)));
    }

    int NumMethod(struct InterfaceType* t)
    {
        return len(t->Methods);
    }

    
    std::ostream& MapType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Key;
        os << " " << Elem;
        os << " " << Bucket;
        os << " " << Hasher;
        os << " " << KeySize;
        os << " " << ValueSize;
        os << " " << BucketSize;
        os << " " << Flags;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MapType& value)
    {
        return value.PrintTo(os);
    }

    bool IndirectKey(struct MapType* mt)
    {
        return mt->Flags & 1 != 0;
    }

    bool IndirectElem(struct MapType* mt)
    {
        return mt->Flags & 2 != 0;
    }

    bool ReflexiveKey(struct MapType* mt)
    {
        return mt->Flags & 4 != 0;
    }

    bool NeedKeyUpdate(struct MapType* mt)
    {
        return mt->Flags & 8 != 0;
    }

    bool HashMightPanic(struct MapType* mt)
    {
        return mt->Flags & 16 != 0;
    }

    Type* Key(struct Type* t)
    {
        if(Kind(gocpp::recv(t)) == Map)
        {
            return (MapType*)(unsafe::Pointer(t))->Key;
        }
        return nullptr;
    }

    
    std::ostream& SliceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SliceType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& FuncType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << InCount;
        os << " " << OutCount;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FuncType& value)
    {
        return value.PrintTo(os);
    }

    Type* In(struct FuncType* t, int i)
    {
        return InSlice(gocpp::recv(t))[i];
    }

    int NumIn(struct FuncType* t)
    {
        return int(t->InCount);
    }

    int NumOut(struct FuncType* t)
    {
        return int(t->OutCount & ((1 << 15) - 1));
    }

    Type* Out(struct FuncType* t, int i)
    {
        return (OutSlice(gocpp::recv(t))[i]);
    }

    gocpp::slice<Type*> InSlice(struct FuncType* t)
    {
        auto uadd = gocpp::Sizeof<FuncType>();
        if(t->TFlag & TFlagUncommon != 0)
        {
            uadd += gocpp::Sizeof<UncommonType>();
        }
        if(t->InCount == 0)
        {
            return nullptr;
        }
        return (gocpp::array<Type*, 1 << 16>*)(addChecked(unsafe::Pointer(t), uadd, "t.inCount > 0")).make_slice(, t->InCount, t->InCount);
    }

    gocpp::slice<Type*> OutSlice(struct FuncType* t)
    {
        auto outCount = uint16_t(NumOut(gocpp::recv(t)));
        if(outCount == 0)
        {
            return nullptr;
        }
        auto uadd = gocpp::Sizeof<FuncType>();
        if(t->TFlag & TFlagUncommon != 0)
        {
            uadd += gocpp::Sizeof<UncommonType>();
        }
        return (gocpp::array<Type*, 1 << 17>*)(addChecked(unsafe::Pointer(t), uadd, "outCount > 0")).make_slice(t->InCount, t->InCount + outCount, t->InCount + outCount);
    }

    bool IsVariadic(struct FuncType* t)
    {
        return t->OutCount & (1 << 15) != 0;
    }

    
    std::ostream& PtrType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Elem;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct PtrType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& StructField::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Typ;
        os << " " << Offset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructField& value)
    {
        return value.PrintTo(os);
    }

    bool Embedded(struct StructField* f)
    {
        return IsEmbedded(gocpp::recv(f->Name));
    }

    
    std::ostream& StructType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PkgPath;
        os << " " << Fields;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& Name::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Bytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Name& value)
    {
        return value.PrintTo(os);
    }

    unsigned char* DataChecked(struct Name n, int off, std::string whySafe)
    {
        return (unsigned char*)(addChecked(unsafe::Pointer(n.Bytes), uintptr_t(off), whySafe));
    }

    unsigned char* Data(struct Name n, int off)
    {
        return (unsigned char*)(addChecked(unsafe::Pointer(n.Bytes), uintptr_t(off), "the runtime doesn't need to give you a reason"));
    }

    bool IsExported(struct Name n)
    {
        return (*n.Bytes) & (1 << 0) != 0;
    }

    bool HasTag(struct Name n)
    {
        return (*n.Bytes) & (1 << 1) != 0;
    }

    bool IsEmbedded(struct Name n)
    {
        return (*n.Bytes) & (1 << 3) != 0;
    }

    std::tuple<int, int> ReadVarint(struct Name n, int off)
    {
        auto v = 0;
        for(auto i = 0; ; i++)
        {
            auto x = *DataChecked(gocpp::recv(n), off + i, "read varint");
            v += int(x & 0x7f) << (7 * i);
            if(x & 0x80 == 0)
            {
                return {i + 1, v};
            }
        }
    }

    bool IsBlank(struct Name n)
    {
        if(n.Bytes == nullptr)
        {
            return false;
        }
        auto [gocpp_id_1, l] = ReadVarint(gocpp::recv(n), 1);
        return l == 1 && *Data(gocpp::recv(n), 2) == '_';
    }

    int writeVarint(gocpp::slice<unsigned char> buf, int n)
    {
        for(auto i = 0; ; i++)
        {
            auto b = unsigned char(n & 0x7f);
            n >>= 7;
            if(n == 0)
            {
                buf[i] = b;
                return i + 1;
            }
            buf[i] = b | 0x80;
        }
    }

    std::string Name(struct Name n)
    {
        if(n.Bytes == nullptr)
        {
            return "";
        }
        auto [i, l] = ReadVarint(gocpp::recv(n), 1);
        return unsafe::String(DataChecked(gocpp::recv(n), 1 + i, "non-empty string"), l);
    }

    std::string Tag(struct Name n)
    {
        if(! HasTag(gocpp::recv(n)))
        {
            return "";
        }
        auto [i, l] = ReadVarint(gocpp::recv(n), 1);
        auto [i2, l2] = ReadVarint(gocpp::recv(n), 1 + i + l);
        return unsafe::String(DataChecked(gocpp::recv(n), 1 + i + l + i2, "non-empty string"), l2);
    }

    Name NewName(std::string n, std::string tag, bool exported, bool embedded)
    {
        if(len(n) >= (1 << 29))
        {
            gocpp::panic("abi.NewName: name too long: " + n.make_slice(0, 1024) + "...");
        }
        if(len(tag) >= (1 << 29))
        {
            gocpp::panic("abi.NewName: tag too long: " + tag.make_slice(0, 1024) + "...");
        }
        gocpp::array<unsigned char, 10> nameLen = {};
        gocpp::array<unsigned char, 10> tagLen = {};
        auto nameLenLen = writeVarint(nameLen.make_slice(0, ), len(n));
        auto tagLenLen = writeVarint(tagLen.make_slice(0, ), len(tag));
        unsigned char bits = {};
        auto l = 1 + nameLenLen + len(n);
        if(exported)
        {
            bits |= 1 << 0;
        }
        if(len(tag) > 0)
        {
            l += tagLenLen + len(tag);
            bits |= 1 << 1;
        }
        if(embedded)
        {
            bits |= 1 << 3;
        }
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), l);
        b[0] = bits;
        copy(b.make_slice(1), nameLen.make_slice(0, nameLenLen));
        copy(b.make_slice(1 + nameLenLen), n);
        if(len(tag) > 0)
        {
            auto tb = b.make_slice(1 + nameLenLen + len(n));
            copy(tb, tagLen.make_slice(0, tagLenLen));
            copy(tb.make_slice(tagLenLen), tag);
        }
        return gocpp::Init<Name>([](Name& x) { x.Bytes = & b[0]; });
    }

}

