// generated by GoCpp from file '$(ImportDir)/errors/wrap.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/errors/wrap.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/reflectlite/type.h"
#include "golang/internal/reflectlite/value.h"

namespace golang::errors
{
    namespace rec
    {
        using namespace mocklib::rec;
        using reflectlite::rec::AssignableTo;
        using reflectlite::rec::Comparable;
        using reflectlite::rec::Elem;
        using reflectlite::rec::Implements;
        using reflectlite::rec::IsNil;
        using reflectlite::rec::Kind;
        using reflectlite::rec::Set;
        using reflectlite::rec::Type;
    }

    
        template<typename T>
        gocpp_id_0::gocpp_id_0(T& ref)
        {
            value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
        }

        template<typename T>
        gocpp_id_0::gocpp_id_0(const T& ref)
        {
            value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
        }

        template<typename T>
        gocpp_id_0::gocpp_id_0(T* ptr)
        {
            value.reset(new gocpp_id_0Impl<T, gocpp::ptr<T>>(ptr));
        }

        std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
        {
            return os;
        }

        template<typename T, typename StoreT>
        struct gocpp::error gocpp_id_0::gocpp_id_0Impl<T, StoreT>::vUnwrap()
        {
            return rec::Unwrap(gocpp::PtrRecv<T, false>(value.get()));
        }

        namespace rec
        {
            struct gocpp::error Unwrap(const gocpp::PtrRecv<struct gocpp_id_0, false>& self)
            {
                return self.ptr->value->vUnwrap();
            }

            struct gocpp::error Unwrap(const gocpp::ObjRecv<struct gocpp_id_0>& self)
            {
                return self.obj.value->vUnwrap();
            }
        }

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
        {
            return value.PrintTo(os);
        }


    // Unwrap returns the result of calling the Unwrap method on err, if err's
    // type contains an Unwrap method returning error.
    // Otherwise, Unwrap returns nil.
    //
    // Unwrap only calls a method of the form "Unwrap() error".
    // In particular Unwrap does not unwrap errors returned by [Join].
    struct gocpp::error Unwrap(struct gocpp::error err)
    {
        auto [u, ok] = gocpp::getValue<gocpp_id_0>(err);
        if(! ok)
        {
            return nullptr;
        }
        return rec::Unwrap(gocpp::recv(u));
    }

    // Is reports whether any error in err's tree matches target.
    //
    // The tree consists of err itself, followed by the errors obtained by repeatedly
    // calling its Unwrap() error or Unwrap() []error method. When err wraps multiple
    // errors, Is examines err followed by a depth-first traversal of its children.
    //
    // An error is considered to match a target if it is equal to that target or if
    // it implements a method Is(error) bool such that Is(target) returns true.
    //
    // An error type might provide an Is method so it can be treated as equivalent
    // to an existing error. For example, if MyError defines
    //
    //	func (m MyError) Is(target error) bool { return target == fs.ErrExist }
    //
    // then Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is] for
    // an example in the standard library. An Is method should only shallowly
    // compare err and the target and not call [Unwrap] on either.
    bool Is(struct gocpp::error err, struct gocpp::error target)
    {
        if(target == nullptr)
        {
            return err == target;
        }
        auto isComparable = rec::Comparable(gocpp::recv(reflectlite::TypeOf(target)));
        return is(err, target, isComparable);
    }

    
            template<typename T>
            gocpp_id_1::gocpp_id_1(T& ref)
            {
                value.reset(new gocpp_id_1Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_1::gocpp_id_1(const T& ref)
            {
                value.reset(new gocpp_id_1Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_1::gocpp_id_1(T* ptr)
            {
                value.reset(new gocpp_id_1Impl<T, gocpp::ptr<T>>(ptr));
            }

            std::ostream& gocpp_id_1::PrintTo(std::ostream& os) const
            {
                return os;
            }

            template<typename T, typename StoreT>
            bool gocpp_id_1::gocpp_id_1Impl<T, StoreT>::vIs(gocpp::error)
            {
                return rec::Is(gocpp::PtrRecv<T, false>(value.get()));
            }

            namespace rec
            {
                bool Is(const gocpp::PtrRecv<struct gocpp_id_1, false>& self, gocpp::error)
                {
                    return self.ptr->value->vIs();
                }

                bool Is(const gocpp::ObjRecv<struct gocpp_id_1>& self, gocpp::error)
                {
                    return self.obj.value->vIs();
                }
            }

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
            {
                return value.PrintTo(os);
            }


    
                template<typename T>
                gocpp_id_3::gocpp_id_3(T& ref)
                {
                    value.reset(new gocpp_id_3Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_3::gocpp_id_3(const T& ref)
                {
                    value.reset(new gocpp_id_3Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_3::gocpp_id_3(T* ptr)
                {
                    value.reset(new gocpp_id_3Impl<T, gocpp::ptr<T>>(ptr));
                }

                std::ostream& gocpp_id_3::PrintTo(std::ostream& os) const
                {
                    return os;
                }

                template<typename T, typename StoreT>
                struct gocpp::error gocpp_id_3::gocpp_id_3Impl<T, StoreT>::vUnwrap()
                {
                    return rec::Unwrap(gocpp::PtrRecv<T, false>(value.get()));
                }

                namespace rec
                {
                    struct gocpp::error Unwrap(const gocpp::PtrRecv<struct gocpp_id_3, false>& self)
                    {
                        return self.ptr->value->vUnwrap();
                    }

                    struct gocpp::error Unwrap(const gocpp::ObjRecv<struct gocpp_id_3>& self)
                    {
                        return self.obj.value->vUnwrap();
                    }
                }

                std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value)
                {
                    return value.PrintTo(os);
                }


    
                template<typename T>
                gocpp_id_4::gocpp_id_4(T& ref)
                {
                    value.reset(new gocpp_id_4Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_4::gocpp_id_4(const T& ref)
                {
                    value.reset(new gocpp_id_4Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_4::gocpp_id_4(T* ptr)
                {
                    value.reset(new gocpp_id_4Impl<T, gocpp::ptr<T>>(ptr));
                }

                std::ostream& gocpp_id_4::PrintTo(std::ostream& os) const
                {
                    return os;
                }

                template<typename T, typename StoreT>
                gocpp::slice<gocpp::error> gocpp_id_4::gocpp_id_4Impl<T, StoreT>::vUnwrap()
                {
                    return rec::Unwrap(gocpp::PtrRecv<T, false>(value.get()));
                }

                namespace rec
                {
                    gocpp::slice<gocpp::error> Unwrap(const gocpp::PtrRecv<struct gocpp_id_4, false>& self)
                    {
                        return self.ptr->value->vUnwrap();
                    }

                    gocpp::slice<gocpp::error> Unwrap(const gocpp::ObjRecv<struct gocpp_id_4>& self)
                    {
                        return self.obj.value->vUnwrap();
                    }
                }

                std::ostream& operator<<(std::ostream& os, const struct gocpp_id_4& value)
                {
                    return value.PrintTo(os);
                }


    bool is(struct gocpp::error err, struct gocpp::error target, bool targetComparable)
    {
        for(; ; )
        {
            if(targetComparable && err == target)
            {
                return true;
            }
            if(auto [x, ok] = gocpp::getValue<gocpp_id_1>(err); ok && rec::Is(gocpp::recv(x), target))
            {
                return true;
            }
            //Go type switch emulation
            {
                const auto& gocpp_id_2 = gocpp::type_info(err);
                int conditionId = -1;
                if(gocpp_id_2 == typeid(gocpp_id_3)) { conditionId = 0; }
                else if(gocpp_id_2 == typeid(gocpp_id_4)) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                    {
                        gocpp_id_3 x = gocpp::any_cast<gocpp_id_3>(err);
                        err = rec::Unwrap(gocpp::recv(x));
                        if(err == nullptr)
                        {
                            return false;
                        }
                        break;
                    }
                    case 1:
                    {
                        gocpp_id_4 x = gocpp::any_cast<gocpp_id_4>(err);
                        for(auto [gocpp_ignored, err] : rec::Unwrap(gocpp::recv(x)))
                        {
                            if(is(err, target, targetComparable))
                            {
                                return true;
                            }
                        }
                        return false;
                        break;
                    }
                    default:
                    {
                        auto x = err;
                        return false;
                        break;
                    }
                }
            }
        }
    }

    // As finds the first error in err's tree that matches target, and if one is found, sets
    // target to that error value and returns true. Otherwise, it returns false.
    //
    // The tree consists of err itself, followed by the errors obtained by repeatedly
    // calling its Unwrap() error or Unwrap() []error method. When err wraps multiple
    // errors, As examines err followed by a depth-first traversal of its children.
    //
    // An error matches target if the error's concrete value is assignable to the value
    // pointed to by target, or if the error has a method As(interface{}) bool such that
    // As(target) returns true. In the latter case, the As method is responsible for
    // setting target.
    //
    // An error type might provide an As method so it can be treated as if it were a
    // different error type.
    //
    // As panics if target is not a non-nil pointer to either a type that implements
    // error, or to any interface type.
    bool As(struct gocpp::error err, go_any target)
    {
        if(err == nullptr)
        {
            return false;
        }
        if(target == nullptr)
        {
            gocpp::panic("errors: target cannot be nil"s);
        }
        auto val = reflectlite::ValueOf(target);
        auto typ = rec::Type(gocpp::recv(val));
        if(rec::Kind(gocpp::recv(typ)) != reflectlite::Ptr || rec::IsNil(gocpp::recv(val)))
        {
            gocpp::panic("errors: target must be a non-nil pointer"s);
        }
        auto targetType = rec::Elem(gocpp::recv(typ));
        if(rec::Kind(gocpp::recv(targetType)) != reflectlite::Interface && ! rec::Implements(gocpp::recv(targetType), errorType))
        {
            gocpp::panic("errors: *target must be interface or implement error"s);
        }
        return as(err, target, val, targetType);
    }

    
            template<typename T>
            gocpp_id_5::gocpp_id_5(T& ref)
            {
                value.reset(new gocpp_id_5Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_5::gocpp_id_5(const T& ref)
            {
                value.reset(new gocpp_id_5Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_5::gocpp_id_5(T* ptr)
            {
                value.reset(new gocpp_id_5Impl<T, gocpp::ptr<T>>(ptr));
            }

            std::ostream& gocpp_id_5::PrintTo(std::ostream& os) const
            {
                return os;
            }

            template<typename T, typename StoreT>
            bool gocpp_id_5::gocpp_id_5Impl<T, StoreT>::vAs(go_any)
            {
                return rec::As(gocpp::PtrRecv<T, false>(value.get()));
            }

            namespace rec
            {
                bool As(const gocpp::PtrRecv<struct gocpp_id_5, false>& self, go_any)
                {
                    return self.ptr->value->vAs();
                }

                bool As(const gocpp::ObjRecv<struct gocpp_id_5>& self, go_any)
                {
                    return self.obj.value->vAs();
                }
            }

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_5& value)
            {
                return value.PrintTo(os);
            }


    
                template<typename T>
                gocpp_id_7::gocpp_id_7(T& ref)
                {
                    value.reset(new gocpp_id_7Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_7::gocpp_id_7(const T& ref)
                {
                    value.reset(new gocpp_id_7Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_7::gocpp_id_7(T* ptr)
                {
                    value.reset(new gocpp_id_7Impl<T, gocpp::ptr<T>>(ptr));
                }

                std::ostream& gocpp_id_7::PrintTo(std::ostream& os) const
                {
                    return os;
                }

                template<typename T, typename StoreT>
                struct gocpp::error gocpp_id_7::gocpp_id_7Impl<T, StoreT>::vUnwrap()
                {
                    return rec::Unwrap(gocpp::PtrRecv<T, false>(value.get()));
                }

                namespace rec
                {
                    struct gocpp::error Unwrap(const gocpp::PtrRecv<struct gocpp_id_7, false>& self)
                    {
                        return self.ptr->value->vUnwrap();
                    }

                    struct gocpp::error Unwrap(const gocpp::ObjRecv<struct gocpp_id_7>& self)
                    {
                        return self.obj.value->vUnwrap();
                    }
                }

                std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value)
                {
                    return value.PrintTo(os);
                }


    
                template<typename T>
                gocpp_id_8::gocpp_id_8(T& ref)
                {
                    value.reset(new gocpp_id_8Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_8::gocpp_id_8(const T& ref)
                {
                    value.reset(new gocpp_id_8Impl<T, std::unique_ptr<T>>(new T(ref)));
                }

                template<typename T>
                gocpp_id_8::gocpp_id_8(T* ptr)
                {
                    value.reset(new gocpp_id_8Impl<T, gocpp::ptr<T>>(ptr));
                }

                std::ostream& gocpp_id_8::PrintTo(std::ostream& os) const
                {
                    return os;
                }

                template<typename T, typename StoreT>
                gocpp::slice<gocpp::error> gocpp_id_8::gocpp_id_8Impl<T, StoreT>::vUnwrap()
                {
                    return rec::Unwrap(gocpp::PtrRecv<T, false>(value.get()));
                }

                namespace rec
                {
                    gocpp::slice<gocpp::error> Unwrap(const gocpp::PtrRecv<struct gocpp_id_8, false>& self)
                    {
                        return self.ptr->value->vUnwrap();
                    }

                    gocpp::slice<gocpp::error> Unwrap(const gocpp::ObjRecv<struct gocpp_id_8>& self)
                    {
                        return self.obj.value->vUnwrap();
                    }
                }

                std::ostream& operator<<(std::ostream& os, const struct gocpp_id_8& value)
                {
                    return value.PrintTo(os);
                }


    bool as(struct gocpp::error err, go_any target, reflectlite::Value targetVal, reflectlite::Type targetType)
    {
        for(; ; )
        {
            if(rec::AssignableTo(gocpp::recv(reflectlite::TypeOf(err)), targetType))
            {
                rec::Set(gocpp::recv(rec::Elem(gocpp::recv(targetVal))), reflectlite::ValueOf(err));
                return true;
            }
            if(auto [x, ok] = gocpp::getValue<gocpp_id_5>(err); ok && rec::As(gocpp::recv(x), target))
            {
                return true;
            }
            //Go type switch emulation
            {
                const auto& gocpp_id_6 = gocpp::type_info(err);
                int conditionId = -1;
                if(gocpp_id_6 == typeid(gocpp_id_7)) { conditionId = 0; }
                else if(gocpp_id_6 == typeid(gocpp_id_8)) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                    {
                        gocpp_id_7 x = gocpp::any_cast<gocpp_id_7>(err);
                        err = rec::Unwrap(gocpp::recv(x));
                        if(err == nullptr)
                        {
                            return false;
                        }
                        break;
                    }
                    case 1:
                    {
                        gocpp_id_8 x = gocpp::any_cast<gocpp_id_8>(err);
                        for(auto [gocpp_ignored, err] : rec::Unwrap(gocpp::recv(x)))
                        {
                            if(err == nullptr)
                            {
                                continue;
                            }
                            if(as(err, target, targetVal, targetType))
                            {
                                return true;
                            }
                        }
                        return false;
                        break;
                    }
                    default:
                    {
                        auto x = err;
                        return false;
                        break;
                    }
                }
            }
        }
    }

    reflectlite::Type errorType = rec::Elem(gocpp::recv(reflectlite::TypeOf((gocpp::error*)(nullptr))));
}

