// generated by GoCpp from file '$(ImportDir)/runtime/panic.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/panic.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goarch/zgoarch_amd64.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/security_nonunix.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
    }

    // throwType indicates the current type of ongoing throw, which affects the
    // amount of detail printed to stderr. Higher values include more detail.
    // throwTypeNone means that we are not throwing.
    // throwTypeUser is a throw due to a problem with the application.
    //
    // These throws do not include runtime frames, system goroutines, or
    // frame metadata.
    // throwTypeRuntime is a throw due to a problem with Go itself.
    //
    // These throws include as much information as possible to aid in
    // debugging the runtime, including runtime frames, system goroutines,
    // and frame metadata.
    // Check to make sure we can really generate a panic. If the panic
    // was generated from the runtime, or from inside malloc, then convert
    // to a throw of msg.
    // pc should be the program counter of the compiler-generated code that
    // triggered this panic.
    void panicCheck1(uintptr_t pc, std::string msg)
    {
        if(goarch::IsWasm == 0 && hasPrefix(funcname(findfunc(pc)), "runtime."s))
        {
            go_throw(msg);
        }
        auto gp = getg();
        if(gp != nullptr && gp->m != nullptr && gp->m->mallocing != 0)
        {
            go_throw(msg);
        }
    }

    // Same as above, but calling from the runtime is allowed.
    //
    // Using this function is necessary for any panic that may be
    // generated by runtime.sigpanic, since those are always called by the
    // runtime.
    void panicCheck2(std::string err)
    {
        auto gp = getg();
        if(gp != nullptr && gp->m != nullptr && gp->m->mallocing != 0)
        {
            go_throw(err);
        }
    }

    // failures in the comparisons for s[x], 0 <= x < y (y == len(s))
    //
    //go:yeswritebarrierrec
    void goPanicIndex(int x, int y)
    {
        panicCheck1(getcallerpc(), "index out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsIndex;
        }));
    }

    //go:yeswritebarrierrec
    void goPanicIndexU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "index out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsIndex;
        }));
    }

    // failures in the comparisons for s[:x], 0 <= x <= y (y == len(s) or cap(s))
    //
    //go:yeswritebarrierrec
    void goPanicSliceAlen(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSliceAlen;
        }));
    }

    //go:yeswritebarrierrec
    void goPanicSliceAlenU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSliceAlen;
        }));
    }

    //go:yeswritebarrierrec
    void goPanicSliceAcap(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSliceAcap;
        }));
    }

    //go:yeswritebarrierrec
    void goPanicSliceAcapU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSliceAcap;
        }));
    }

    // failures in the comparisons for s[x:y], 0 <= x <= y
    //
    //go:yeswritebarrierrec
    void goPanicSliceB(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSliceB;
        }));
    }

    //go:yeswritebarrierrec
    void goPanicSliceBU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSliceB;
        }));
    }

    // failures in the comparisons for s[::x], 0 <= x <= y (y == len(s) or cap(s))
    void goPanicSlice3Alen(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3Alen;
        }));
    }

    void goPanicSlice3AlenU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3Alen;
        }));
    }

    void goPanicSlice3Acap(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3Acap;
        }));
    }

    void goPanicSlice3AcapU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3Acap;
        }));
    }

    // failures in the comparisons for s[:x:y], 0 <= x <= y
    void goPanicSlice3B(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3B;
        }));
    }

    void goPanicSlice3BU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3B;
        }));
    }

    // failures in the comparisons for s[x:y:], 0 <= x <= y
    void goPanicSlice3C(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsSlice3C;
        }));
    }

    void goPanicSlice3CU(unsigned int x, int y)
    {
        panicCheck1(getcallerpc(), "slice bounds out of range"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = false;
            x.y = y;
            x.code = boundsSlice3C;
        }));
    }

    // failures in the conversion ([x]T)(s) or (*[x]T)(s), 0 <= x <= y, y == len(s)
    void goPanicSliceConvert(int x, int y)
    {
        panicCheck1(getcallerpc(), "slice length too short to convert to array or pointer to array"s);
        gocpp::panic(gocpp::Init<boundsError>([=](auto& x) {
            x.x = int64_t(x);
            x.go_signed = true;
            x.y = y;
            x.code = boundsConvert;
        }));
    }

    // Implemented in assembly, as they take arguments in registers.
    // Declared here to mark them as ABIInternal.
    void panicIndex(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicIndexU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAlen(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAlenU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAcap(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceAcapU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceB(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceBU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3Alen(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3AlenU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3Acap(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3AcapU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3B(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3BU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3C(int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSlice3CU(unsigned int x, int y)
    /* convertBlockStmt, nil block */;

    void panicSliceConvert(int x, int y)
    /* convertBlockStmt, nil block */;

    gocpp::error shiftError = error(errorString("negative shift amount"s));
    //go:yeswritebarrierrec
    void panicshift()
    {
        panicCheck1(getcallerpc(), "negative shift amount"s);
        gocpp::panic(shiftError);
    }

    gocpp::error divideError = error(errorString("integer divide by zero"s));
    //go:yeswritebarrierrec
    void panicdivide()
    {
        panicCheck2("integer divide by zero"s);
        gocpp::panic(divideError);
    }

    gocpp::error overflowError = error(errorString("integer overflow"s));
    void panicoverflow()
    {
        panicCheck2("integer overflow"s);
        gocpp::panic(overflowError);
    }

    gocpp::error floatError = error(errorString("floating point error"s));
    void panicfloat()
    {
        panicCheck2("floating point error"s);
        gocpp::panic(floatError);
    }

    gocpp::error memoryError = error(errorString("invalid memory address or nil pointer dereference"s));
    void panicmem()
    {
        panicCheck2("invalid memory address or nil pointer dereference"s);
        gocpp::panic(memoryError);
    }

    void panicmemAddr(uintptr_t addr)
    {
        panicCheck2("invalid memory address or nil pointer dereference"s);
        gocpp::panic(gocpp::Init<errorAddressString>([=](auto& x) {
            x.msg = "invalid memory address or nil pointer dereference"s;
            x.addr = addr;
        }));
    }

    // Create a new deferred function fn, which has no arguments and results.
    // The compiler turns a defer statement into a call to this.
    void deferproc(std::function<void ()> fn)
    {
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            go_throw("defer on system stack"s);
        }
        auto d = newdefer();
        d->link = gp->_defer;
        gp->_defer = d;
        d->fn = fn;
        d->pc = getcallerpc();
        d->sp = getcallersp();
        return0();
    }

    gocpp::error rangeExitError = error(errorString("range function continued iteration after exit"s));
    //go:noinline
    void panicrangeexit()
    {
        gocpp::panic(rangeExitError);
    }

    // deferrangefunc is called by functions that are about to
    // execute a range-over-function loop in which the loop body
    // may execute a defer statement. That defer needs to add to
    // the chain for the current function, not the func literal synthesized
    // to represent the loop body. To do that, the original function
    // calls deferrangefunc to obtain an opaque token representing
    // the current frame, and then the loop body uses deferprocat
    // instead of deferproc to add to that frame's defer lists.
    //
    // The token is an 'any' with underlying type *atomic.Pointer[_defer].
    // It is the atomically-updated head of a linked list of _defer structs
    // representing deferred calls. At the same time, we create a _defer
    // struct on the main g._defer list with d.head set to this head pointer.
    //
    // The g._defer list is now a linked list of deferred calls,
    // but an atomic list hanging off:
    //
    //		g._defer => d4 -> d3 -> drangefunc -> d2 -> d1 -> nil
    //	                             | .head
    //	                             |
    //	                             +--> dY -> dX -> nil
    //
    // with each -> indicating a d.link pointer, and where drangefunc
    // has the d.rangefunc = true bit set.
    // Note that the function being ranged over may have added
    // its own defers (d4 and d3), so drangefunc need not be at the
    // top of the list when deferprocat is used. This is why we pass
    // the atomic head explicitly.
    //
    // To keep misbehaving programs from crashing the runtime,
    // deferprocat pushes new defers onto the .head list atomically.
    // The fact that it is a separate list from the main goroutine
    // defer list means that the main goroutine's defers can still
    // be handled non-atomically.
    //
    // In the diagram, dY and dX are meant to be processed when
    // drangefunc would be processed, which is to say the defer order
    // should be d4, d3, dY, dX, d2, d1. To make that happen,
    // when defer processing reaches a d with rangefunc=true,
    // it calls deferconvert to atomically take the extras
    // away from d.head and then adds them to the main list.
    //
    // That is, deferconvert changes this list:
    //
    //		g._defer => drangefunc -> d2 -> d1 -> nil
    //	                 | .head
    //	                 |
    //	                 +--> dY -> dX -> nil
    //
    // into this list:
    //
    //	g._defer => dY -> dX -> d2 -> d1 -> nil
    //
    // It also poisons *drangefunc.head so that any future
    // deferprocat using that head will throw.
    // (The atomic head is ordinary garbage collected memory so that
    // it's not a problem if user code holds onto it beyond
    // the lifetime of drangefunc.)
    //
    // TODO: We could arrange for the compiler to call into the
    // runtime after the loop finishes normally, to do an eager
    // deferconvert, which would catch calling the loop body
    // and having it defer after the loop is done. If we have a
    // more general catch of loop body misuse, though, this
    // might not be worth worrying about in addition.
    //
    // See also ../cmd/compile/internal/rangefunc/rewrite.go.
    go_any deferrangefunc()
    {
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            go_throw("defer on system stack"s);
        }
        auto d = newdefer();
        d->link = gp->_defer;
        gp->_defer = d;
        d->pc = getcallerpc();
        d->sp = getcallersp();
        d->rangefunc = true;
        d->head = new(atomic::Pointer[_defer]);
        return d->head;
    }

    // badDefer returns a fixed bad defer pointer for poisoning an atomic defer list head.
    struct _defer* badDefer()
    {
        return (_defer*)(unsafe::Pointer(uintptr_t(1)));
    }

    // deferprocat is like deferproc but adds to the atomic list represented by frame.
    // See the doc comment for deferrangefunc for details.
    void deferprocat(std::function<void ()> fn, go_any frame)
    {
        auto head = gocpp::getValue<atomic::Pointer<_defer>*>(frame);
        if(raceenabled)
        {
            racewritepc(unsafe::Pointer(head), getcallerpc(), abi::FuncPCABIInternal(deferprocat));
        }
        auto d1 = newdefer();
        d1->fn = fn;
        for(; ; )
        {
            d1->link = rec::Load<_defer>(gocpp::recv(head));
            if(d1->link == badDefer())
            {
                go_throw("defer after range func returned"s);
            }
            if(rec::CompareAndSwap<_defer>(gocpp::recv(head), d1->link, d1))
            {
                break;
            }
        }
        return0();
    }

    // deferconvert converts a rangefunc defer list into an ordinary list.
    // See the doc comment for deferrangefunc for details.
    struct _defer* deferconvert(struct _defer* d)
    {
        auto head = d->head;
        if(raceenabled)
        {
            racereadpc(unsafe::Pointer(head), getcallerpc(), abi::FuncPCABIInternal(deferconvert));
        }
        auto tail = d->link;
        d->rangefunc = false;
        auto d0 = d;
        for(; ; )
        {
            d = rec::Load<_defer>(gocpp::recv(head));
            if(rec::CompareAndSwap<_defer>(gocpp::recv(head), d, badDefer()))
            {
                break;
            }
        }
        if(d == nullptr)
        {
            freedefer(d0);
            return tail;
        }
        for(auto d1 = d; ; d1 = d1->link)
        {
            d1->sp = d0->sp;
            d1->pc = d0->pc;
            if(d1->link == nullptr)
            {
                d1->link = tail;
                break;
            }
        }
        freedefer(d0);
        return d;
    }

    // deferprocStack queues a new deferred function with a defer record on the stack.
    // The defer record must have its fn field initialized.
    // All other fields can contain junk.
    // Nosplit because of the uninitialized pointer fields on the stack.
    //
    //go:nosplit
    void deferprocStack(struct _defer* d)
    {
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            go_throw("defer on system stack"s);
        }
        d->heap = false;
        d->rangefunc = false;
        d->sp = getcallersp();
        d->pc = getcallerpc();
        *(uintptr_t*)(unsafe::Pointer(& d->link)) = uintptr_t(unsafe::Pointer(gp->_defer));
        *(uintptr_t*)(unsafe::Pointer(& d->head)) = 0;
        *(uintptr_t*)(unsafe::Pointer(& gp->_defer)) = uintptr_t(unsafe::Pointer(d));
        return0();
    }

    // Allocate a Defer, usually using per-P pool.
    // Each defer must be released with freedefer.  The defer is not
    // added to any defer chain yet.
    struct _defer* newdefer()
    {
        _defer* d = {};
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(len(pp->deferpool) == 0 && sched.deferpool != nullptr)
        {
            lock(& sched.deferlock);
            for(; len(pp->deferpool) < cap(pp->deferpool) / 2 && sched.deferpool != nullptr; )
            {
                auto d = sched.deferpool;
                sched.deferpool = d->link;
                d->link = nullptr;
                pp->deferpool = append(pp->deferpool, d);
            }
            unlock(& sched.deferlock);
        }
        if(auto n = len(pp->deferpool); n > 0)
        {
            d = pp->deferpool[n - 1];
            pp->deferpool[n - 1] = nullptr;
            pp->deferpool = pp->deferpool.make_slice(0, n - 1);
        }
        releasem(mp);
        std::tie(mp, pp) = std::tuple{nullptr, nullptr};
        if(d == nullptr)
        {
            d = new(_defer);
        }
        d->heap = true;
        return d;
    }

    // Free the given defer.
    // The defer cannot be used after this call.
    //
    // This is nosplit because the incoming defer is in a perilous state.
    // It's not on any defer list, so stack copying won't adjust stack
    // pointers in it (namely, d.link). Hence, if we were to copy the
    // stack, d could then contain a stale pointer.
    //
    //go:nosplit
    void freedefer(struct _defer* d)
    {
        d->link = nullptr;
        if(d->fn != nullptr)
        {
            freedeferfn();
        }
        if(! d->heap)
        {
            return;
        }
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(len(pp->deferpool) == cap(pp->deferpool))
        {
            // Transfer half of local cache to the central cache.
            _defer* first = {};
            _defer* last = {};
            for(; len(pp->deferpool) > cap(pp->deferpool) / 2; )
            {
                auto n = len(pp->deferpool);
                auto d = pp->deferpool[n - 1];
                pp->deferpool[n - 1] = nullptr;
                pp->deferpool = pp->deferpool.make_slice(0, n - 1);
                if(first == nullptr)
                {
                    first = d;
                }
                else
                {
                    last->link = d;
                }
                last = d;
            }
            lock(& sched.deferlock);
            last->link = sched.deferpool;
            sched.deferpool = first;
            unlock(& sched.deferlock);
        }
        *d = _defer {};
        pp->deferpool = append(pp->deferpool, d);
        releasem(mp);
        std::tie(mp, pp) = std::tuple{nullptr, nullptr};
    }

    // Separate function so that it can split stack.
    // Windows otherwise runs out of stack space.
    void freedeferfn()
    {
        go_throw("freedefer with d.fn != nil"s);
    }

    // deferreturn runs deferred functions for the caller's frame.
    // The compiler inserts a call to this at the end of any
    // function which calls defer.
    void deferreturn()
    {
        _panic p = {};
        p.deferreturn = true;
        rec::start(gocpp::recv(p), getcallerpc(), unsafe::Pointer(getcallersp()));
        for(; ; )
        {
            auto [fn, ok] = rec::nextDefer(gocpp::recv(p));
            if(! ok)
            {
                break;
            }
            fn();
        }
    }

    // Goexit terminates the goroutine that calls it. No other goroutine is affected.
    // Goexit runs all deferred calls before terminating the goroutine. Because Goexit
    // is not a panic, any recover calls in those deferred functions will return nil.
    //
    // Calling Goexit from the main goroutine terminates that goroutine
    // without func main returning. Since func main has not returned,
    // the program continues execution of other goroutines.
    // If all other goroutines exit, the program crashes.
    void Goexit()
    {
        // Create a panic object for Goexit, so we can recognize when it might be
        // bypassed by a recover().
        _panic p = {};
        p.goexit = true;
        rec::start(gocpp::recv(p), getcallerpc(), unsafe::Pointer(getcallersp()));
        for(; ; )
        {
            auto [fn, ok] = rec::nextDefer(gocpp::recv(p));
            if(! ok)
            {
                break;
            }
            fn();
        }
        goexit1();
    }

    // Call all Error and String methods before freezing the world.
    // Used when crashing with panicking.
    void preprintpanics(struct _panic* p)
    {
        gocpp::Defer defer;
        try
        {
            defer.push_back([=]{ [=]() mutable -> void
            {
                auto text = "panic while printing panic value"s;
                //Go type switch emulation
                {
                    const auto& gocpp_id_0 = gocpp::type_info(gocpp::recover());
                    int conditionId = -1;
                    if(gocpp_id_0 == typeid(untyped nil)) { conditionId = 0; }
                    else if(gocpp_id_0 == typeid(std::string)) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                        {
                            untyped nil r = gocpp::any_cast<untyped nil>(gocpp::recover());
                            break;
                        }
                        case 1:
                        {
                            std::string r = gocpp::any_cast<std::string>(gocpp::recover());
                            go_throw(text + ": "s + r);
                            break;
                        }
                        default:
                        {
                            auto r = gocpp::recover();
                            go_throw(text + ": type "s + rec::string(gocpp::recv(toRType(efaceOf(& r)->_type))));
                            break;
                        }
                    }
                }
            }(); });
            for(; p != nullptr; )
            {
                //Go type switch emulation
                {
                    const auto& gocpp_id_1 = gocpp::type_info(p->arg);
                    int conditionId = -1;
                    if(gocpp_id_1 == typeid(gocpp::error)) { conditionId = 0; }
                    else if(gocpp_id_1 == typeid(stringer)) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                        {
                            gocpp::error v = gocpp::any_cast<gocpp::error>(p->arg);
                            p->arg = rec::Error(gocpp::recv(v));
                            break;
                        }
                        case 1:
                        {
                            stringer v = gocpp::any_cast<stringer>(p->arg);
                            p->arg = rec::String(gocpp::recv(v));
                            break;
                        }
                    }
                }
                p = p->link;
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // Print all currently active panics. Used when crashing.
    // Should only be called after preprintpanics.
    void printpanics(struct _panic* p)
    {
        if(p->link != nullptr)
        {
            printpanics(p->link);
            if(! p->link->goexit)
            {
                print("\t"s);
            }
        }
        if(p->goexit)
        {
            return;
        }
        print("panic: "s);
        printany(p->arg);
        if(p->recovered)
        {
            print(" [recovered]"s);
        }
        print("\n"s);
    }

    // readvarintUnsafe reads the uint32 in varint format starting at fd, and returns the
    // uint32 and a pointer to the byte following the varint.
    //
    // The implementation is the same with runtime.readvarint, except that this function
    // uses unsafe.Pointer for speed.
    std::tuple<uint32_t, unsafe::Pointer> readvarintUnsafe(unsafe::Pointer fd)
    {
        uint32_t r = {};
        int shift = {};
        for(; ; )
        {
            auto b = *(uint8_t*)(fd);
            fd = add(fd, gocpp::Sizeof<uint8_t>());
            if(b < 128)
            {
                return {r + (uint32_t(b) << shift), fd};
            }
            r += uint32_t(b & 0x7F) << (shift & 31);
            shift += 7;
            if(shift > 28)
            {
                gocpp::panic("Bad varint"s);
            }
        }
    }

    // A PanicNilError happens when code calls panic(nil).
    //
    // Before Go 1.21, programs that called panic(nil) observed recover returning nil.
    // Starting in Go 1.21, programs that call panic(nil) observe recover returning a *PanicNilError.
    // Programs can change back to the old behavior by setting GODEBUG=panicnil=1.
    
    template<typename T> requires gocpp::GoStruct<T>
    PanicNilError::operator T()
    {
        T result;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool PanicNilError::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& PanicNilError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct PanicNilError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(PanicNilError*)
    {
        return "panic called with nil argument"s;
    }

    void rec::RuntimeError(PanicNilError*)
    {
    }

    godebugInc* panicnil = gocpp::InitPtr<godebugInc>([](auto& x) {
        x.name = "panicnil"s;
    });
    // The implementation of the predeclared function panic.
    void gopanic(go_any e)
    {
        if(e == nullptr)
        {
            if(rec::Load(gocpp::recv(debug.panicnil)) != 1)
            {
                e = new(PanicNilError);
            }
            else
            {
                rec::IncNonDefault(gocpp::recv(panicnil));
            }
        }
        auto gp = getg();
        if(gp->m->curg != gp)
        {
            print("panic: "s);
            printany(e);
            print("\n"s);
            go_throw("panic on system stack"s);
        }
        if(gp->m->mallocing != 0)
        {
            print("panic: "s);
            printany(e);
            print("\n"s);
            go_throw("panic during malloc"s);
        }
        if(gp->m->preemptoff != ""s)
        {
            print("panic: "s);
            printany(e);
            print("\n"s);
            print("preempt off reason: "s);
            print(gp->m->preemptoff);
            print("\n"s);
            go_throw("panic during preemptoff"s);
        }
        if(gp->m->locks != 0)
        {
            print("panic: "s);
            printany(e);
            print("\n"s);
            go_throw("panic holding locks"s);
        }
        _panic p = {};
        p->arg = e;
        rec::Add(gocpp::recv(runningPanicDefers), 1);
        rec::start(gocpp::recv(p), getcallerpc(), unsafe::Pointer(getcallersp()));
        for(; ; )
        {
            auto [fn, ok] = rec::nextDefer(gocpp::recv(p));
            if(! ok)
            {
                break;
            }
            fn();
        }
        preprintpanics(& p);
        fatalpanic(& p);
        *(int*)(nullptr) = 0;
    }

    // start initializes a panic to start unwinding the stack.
    //
    // If p.goexit is true, then start may return multiple times.
    void rec::start(struct _panic* p, uintptr_t pc, unsafe::Pointer sp)
    {
        auto gp = getg();
        p->startPC = getcallerpc();
        p->startSP = unsafe::Pointer(getcallersp());
        if(p->deferreturn)
        {
            p->sp = sp;
            if(auto s = (savedOpenDeferState*)(gp->param); s != nullptr)
            {
                gp->param = nullptr;
                p->retpc = s->retpc;
                p->deferBitsPtr = (unsigned char*)(add(sp, s->deferBitsOffset));
                p->slotsPtr = add(sp, s->slotsOffset);
            }
            return;
        }
        p->link = gp->_panic;
        gp->_panic = (_panic*)(noescape(unsafe::Pointer(p)));
        std::tie(p->lr, p->fp) = std::tuple{pc, sp};
        rec::nextFrame(gocpp::recv(p));
    }

    // nextDefer returns the next deferred function to invoke, if any.
    //
    // Note: The "ok bool" result is necessary to correctly handle when
    // the deferred function itself was nil (e.g., "defer (func())(nil)").
    std::tuple<std::function<void ()>, bool> rec::nextDefer(struct _panic* p)
    {
        auto gp = getg();
        if(! p->deferreturn)
        {
            if(gp->_panic != p)
            {
                go_throw("bad panic stack"s);
            }
            if(p->recovered)
            {
                mcall(recovery);
                go_throw("recovery failed"s);
            }
        }
        p->argp = add(p->startSP, sys::MinFrameSize);
        for(; ; )
        {
            for(; p->deferBitsPtr != nullptr; )
            {
                auto bits = *p->deferBitsPtr;
                if(bits == 0)
                {
                    p->deferBitsPtr = nullptr;
                    break;
                }
                auto i = 7 - uintptr_t(sys::LeadingZeros8(bits));
                bits &^= 1 << i;
                *p->deferBitsPtr = bits;
                return {*(std::function<void ()>*)(add(p->slotsPtr, i * goarch::PtrSize)), true};
            }
            Recheck:
            if(auto d = gp->_defer; d != nullptr && d->sp == uintptr_t(p->sp))
            {
                if(d->rangefunc)
                {
                    gp->_defer = deferconvert(d);
                    goto Recheck;
                }
                auto fn = d->fn;
                d->fn = nullptr;
                p->retpc = d->pc;
                gp->_defer = d->link;
                freedefer(d);
                return {fn, true};
            }
            if(! rec::nextFrame(gocpp::recv(p)))
            {
                return {nullptr, false};
            }
        }
    }

    // nextFrame finds the next frame that contains deferred calls, if any.
    bool rec::nextFrame(struct _panic* p)
    {
        bool ok;
        if(p->lr == 0)
        {
            return false;
        }
        auto gp = getg();
        systemstack([=]() mutable -> void
        {
            uintptr_t limit = {};
            if(auto d = gp->_defer; d != nullptr)
            {
                limit = d->sp;
            }
            unwinder u = {};
            rec::initAt(gocpp::recv(u), p->lr, uintptr_t(p->fp), 0, gp, 0);
            for(; ; )
            {
                if(! rec::valid(gocpp::recv(u)))
                {
                    p->lr = 0;
                    return;
                }
                if(u.frame.sp == limit)
                {
                    break;
                }
                if(rec::initOpenCodedDefers(gocpp::recv(p), u.frame.fn, unsafe::Pointer(u.frame.varp)))
                {
                    break;
                }
                rec::next(gocpp::recv(u));
            }
            p->lr = u.frame.lr;
            p->sp = unsafe::Pointer(u.frame.sp);
            p->fp = unsafe::Pointer(u.frame.fp);
            ok = true;
        });
        return ok;
    }

    bool rec::initOpenCodedDefers(struct _panic* p, struct funcInfo fn, unsafe::Pointer varp)
    {
        auto fd = funcdata(fn, abi::FUNCDATA_OpenCodedDeferInfo);
        if(fd == nullptr)
        {
            return false;
        }
        if(fn.deferreturn == 0)
        {
            go_throw("missing deferreturn"s);
        }
        uint32_t deferBitsOffset;
        std::tie(deferBitsOffset, fd) = readvarintUnsafe(fd);
        auto deferBitsPtr = (uint8_t*)(add(varp, - uintptr_t(deferBitsOffset)));
        if(*deferBitsPtr == 0)
        {
            return false;
        }
        uint32_t slotsOffset;
        std::tie(slotsOffset, fd) = readvarintUnsafe(fd);
        p->retpc = rec::entry(gocpp::recv(fn)) + uintptr_t(fn.deferreturn);
        p->deferBitsPtr = deferBitsPtr;
        p->slotsPtr = add(varp, - uintptr_t(slotsOffset));
        return true;
    }

    // The implementation of the predeclared function recover.
    // Cannot split the stack because it needs to reliably
    // find the stack segment of its caller.
    //
    // TODO(rsc): Once we commit to CopyStackAlways,
    // this doesn't need to be nosplit.
    //
    //go:nosplit
    go_any gorecover(uintptr_t argp)
    {
        auto gp = getg();
        auto p = gp->_panic;
        if(p != nullptr && ! p->goexit && ! p->recovered && argp == uintptr_t(p->argp))
        {
            p->recovered = true;
            return p->arg;
        }
        return nullptr;
    }

    //go:linkname sync_throw sync.throw
    void sync_throw(std::string s)
    {
        go_throw(s);
    }

    //go:linkname sync_fatal sync.fatal
    void sync_fatal(std::string s)
    {
        fatal(s);
    }

    // throw triggers a fatal error that dumps a stack trace and exits.
    //
    // throw should be used for runtime-internal fatal errors where Go itself,
    // rather than user code, may be at fault for the failure.
    //
    //go:nosplit
    void go_throw(std::string s)
    {
        systemstack([=]() mutable -> void
        {
            print("fatal error: "s, s, "\n"s);
        });
        fatalthrow(throwTypeRuntime);
    }

    // fatal triggers a fatal error that dumps a stack trace and exits.
    //
    // fatal is equivalent to throw, but is used when user code is expected to be
    // at fault for the failure, such as racing map writes.
    //
    // fatal does not include runtime frames, system goroutines, or frame metadata
    // (fp, sp, pc) in the stack trace unless GOTRACEBACK=system or higher.
    //
    //go:nosplit
    void fatal(std::string s)
    {
        systemstack([=]() mutable -> void
        {
            print("fatal error: "s, s, "\n"s);
        });
        fatalthrow(throwTypeUser);
    }

    // runningPanicDefers is non-zero while running deferred functions for panic.
    // This is used to try hard to get a panic stack trace out when exiting.
    atomic::Uint32 runningPanicDefers;
    // panicking is non-zero when crashing the program for an unrecovered panic.
    atomic::Uint32 panicking;
    // paniclk is held while printing the panic information and stack trace,
    // so that two concurrent panics don't overlap their output.
    mutex paniclk;
    // Unwind the stack after a deferred function calls recover
    // after a panic. Then arrange to continue running as though
    // the caller of the deferred function returned normally.
    //
    // However, if unwinding the stack would skip over a Goexit call, we
    // return into the Goexit loop instead, so it can continue processing
    // defers instead.
    void recovery(struct g* gp)
    {
        auto p = gp->_panic;
        auto [pc, sp, fp] = std::tuple{p->retpc, uintptr_t(p->sp), uintptr_t(p->fp)};
        auto [p0, saveOpenDeferState] = std::tuple{p, p->deferBitsPtr != nullptr && *p->deferBitsPtr != 0};
        for(; p != nullptr && uintptr_t(p->startSP) < sp; p = p->link)
        {
            if(p->goexit)
            {
                std::tie(pc, sp) = std::tuple{p->startPC, uintptr_t(p->startSP)};
                saveOpenDeferState = false;
                break;
            }
            rec::Add(gocpp::recv(runningPanicDefers), - 1);
        }
        gp->_panic = p;
        if(p == nullptr)
        {
            gp->sig = 0;
        }
        if(gp->param != nullptr)
        {
            go_throw("unexpected gp.param"s);
        }
        if(saveOpenDeferState)
        {
            gp->param = unsafe::Pointer(gocpp::InitPtr<savedOpenDeferState>([=](auto& x) {
                x.retpc = p0->retpc;
                x.deferBitsOffset = uintptr_t(unsafe::Pointer(p0->deferBitsPtr)) - uintptr_t(p0->sp);
                x.slotsOffset = uintptr_t(p0->slotsPtr) - uintptr_t(p0->sp);
            }));
        }
        if(sp != 0 && (sp < gp->stack.lo || gp->stack.hi < sp))
        {
            print("recover: "s, hex(sp), " not in ["s, hex(gp->stack.lo), ", "s, hex(gp->stack.hi), "]\n"s);
            go_throw("bad recovery"s);
        }
        gp->sched.sp = sp;
        gp->sched.pc = pc;
        gp->sched.lr = 0;
        //Go switch emulation
        {
            int conditionId = -1;
            if(goarch::IsAmd64 != 0) { conditionId = 0; }
            else if(goarch::IsArm64 != 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    gp->sched.bp = fp - 2 * goarch::PtrSize;
                    break;
                case 1:
                    gp->sched.bp = sp - goarch::PtrSize;
                    break;
            }
        }
        gp->sched.ret = 1;
        gogo(& gp->sched);
    }

    // fatalthrow implements an unrecoverable runtime throw. It freezes the
    // system, prints stack traces starting from its caller, and terminates the
    // process.
    //
    //go:nosplit
    void fatalthrow(golang::runtime::throwType t)
    {
        auto pc = getcallerpc();
        auto sp = getcallersp();
        auto gp = getg();
        if(gp->m->throwing == throwTypeNone)
        {
            gp->m->throwing = t;
        }
        systemstack([=]() mutable -> void
        {
            if(isSecureMode())
            {
                exit(2);
            }
            startpanic_m();
            if(dopanic_m(gp, pc, sp))
            {
                crash();
            }
            exit(2);
        });
        *(int*)(nullptr) = 0;
    }

    // fatalpanic implements an unrecoverable panic. It is like fatalthrow, except
    // that if msgs != nil, fatalpanic also prints panic messages and decrements
    // runningPanicDefers once main is blocked from exiting.
    //
    //go:nosplit
    void fatalpanic(struct _panic* msgs)
    {
        auto pc = getcallerpc();
        auto sp = getcallersp();
        auto gp = getg();
        bool docrash = {};
        systemstack([=]() mutable -> void
        {
            if(startpanic_m() && msgs != nullptr)
            {
                rec::Add(gocpp::recv(runningPanicDefers), - 1);
                printpanics(msgs);
            }
            docrash = dopanic_m(gp, pc, sp);
        });
        if(docrash)
        {
            crash();
        }
        systemstack([=]() mutable -> void
        {
            exit(2);
        });
        *(int*)(nullptr) = 0;
    }

    // startpanic_m prepares for an unrecoverable panic.
    //
    // It returns true if panic messages should be printed, or false if
    // the runtime is in bad shape and should just print stacks.
    //
    // It must not have write barriers even though the write barrier
    // explicitly ignores writes once dying > 0. Write barriers still
    // assume that g.m.p != nil, and this function may not have P
    // in some contexts (e.g. a panic in a signal handler for a signal
    // sent to an M with no P).
    //
    //go:nowritebarrierrec
    bool startpanic_m()
    {
        auto gp = getg();
        if(mheap_.cachealloc.size == 0)
        {
            print("runtime: panic before malloc heap initialized\n"s);
        }
        gp->m->mallocing++;
        if(gp->m->locks < 0)
        {
            gp->m->locks = 1;
        }
        //Go switch emulation
        {
            auto condition = gp->m->dying;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    gp->m->dying = 1;
                    rec::Add(gocpp::recv(panicking), 1);
                    lock(& paniclk);
                    if(debug.schedtrace > 0 || debug.scheddetail > 0)
                    {
                        schedtrace(true);
                    }
                    freezetheworld();
                    return true;
                    break;
                case 1:
                    gp->m->dying = 2;
                    print("panic during panic\n"s);
                    return false;
                    break;
                case 2:
                    gp->m->dying = 3;
                    print("stack trace unavailable\n"s);
                    exit(4);
                default:
                    exit(5);
                    return false;
                    break;
            }
        }
    }

    bool didothers;
    mutex deadlock;
    // gp is the crashing g running on this M, but may be a user G, while getg() is
    // always g0.
    bool dopanic_m(struct g* gp, uintptr_t pc, uintptr_t sp)
    {
        if(gp->sig != 0)
        {
            auto signame_tmp = signame(gp->sig);
            auto& signame = signame_tmp;
            if(signame != ""s)
            {
                print("[signal "s, signame);
            }
            else
            {
                print("[signal "s, hex(gp->sig));
            }
            print(" code="s, hex(gp->sigcode0), " addr="s, hex(gp->sigcode1), " pc="s, hex(gp->sigpc), "]\n"s);
        }
        auto [level, all, docrash] = gotraceback();
        if(level > 0)
        {
            if(gp != gp->m->curg)
            {
                all = true;
            }
            if(gp != gp->m->g0)
            {
                print("\n"s);
                goroutineheader(gp);
                traceback(pc, sp, 0, gp);
            }
            else
            if(level >= 2 || gp->m->throwing >= throwTypeRuntime)
            {
                print("\nruntime stack:\n"s);
                traceback(pc, sp, 0, gp);
            }
            if(! didothers && all)
            {
                didothers = true;
                tracebackothers(gp);
            }
        }
        unlock(& paniclk);
        if(rec::Add(gocpp::recv(panicking), - 1) != 0)
        {
            lock(& deadlock);
            lock(& deadlock);
        }
        printDebugLog();
        return docrash;
    }

    // canpanic returns false if a signal should throw instead of
    // panicking.
    //
    //go:nosplit
    bool canpanic()
    {
        auto gp = getg();
        auto mp = acquirem();
        if(gp != mp->curg)
        {
            releasem(mp);
            return false;
        }
        if(mp->locks != 1 || mp->mallocing != 0 || mp->throwing != throwTypeNone || mp->preemptoff != ""s || mp->dying != 0)
        {
            releasem(mp);
            return false;
        }
        auto status = readgstatus(gp);
        if(status &^ _Gscan != _Grunning || gp->syscallsp != 0)
        {
            releasem(mp);
            return false;
        }
        if(GOOS == "windows"s && mp->libcallsp != 0)
        {
            releasem(mp);
            return false;
        }
        releasem(mp);
        return true;
    }

    // shouldPushSigpanic reports whether pc should be used as sigpanic's
    // return PC (pushing a frame for the call). Otherwise, it should be
    // left alone so that LR is used as sigpanic's return PC, effectively
    // replacing the top-most frame with sigpanic. This is used by
    // preparePanic.
    bool shouldPushSigpanic(struct g* gp, uintptr_t pc, uintptr_t lr)
    {
        if(pc == 0)
        {
            return false;
        }
        if(gp->m->incgo || rec::valid(gocpp::recv(findfunc(pc))))
        {
            return true;
        }
        if(rec::valid(gocpp::recv(findfunc(lr))))
        {
            return false;
        }
        return true;
    }

    // isAbortPC reports whether pc is the program counter at which
    // runtime.abort raises a signal.
    //
    // It is nosplit because it's part of the isgoexception
    // implementation.
    //
    //go:nosplit
    bool isAbortPC(uintptr_t pc)
    {
        auto f = findfunc(pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return false;
        }
        return f.funcID == abi::FuncID_abort;
    }

}

