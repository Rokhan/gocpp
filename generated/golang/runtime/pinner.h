// generated by GoCpp from file '$(ImportDir)/runtime/pinner.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/pinner.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    struct Pinner
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Pinner& value);
    struct pinner
    {
        gocpp::slice<unsafe::Pointer> refs;
        gocpp::array<unsafe::Pointer, pinnerRefStoreSize> refStore;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pinner& value);
    unsafe::Pointer pinnerGetPtr(go_any* i);
    bool isPinned(unsafe::Pointer ptr);
    bool setPinned(unsafe::Pointer ptr, bool pin);
    struct pinState
    {
        uint8_t* bytep;
        uint8_t byteVal;
        uint8_t mask;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pinState& value);
    uintptr_t* pinnerGetPinCounter(unsafe::Pointer addr);
    extern std::function<void (void)> pinnerLeakPanic;

    namespace rec
    {
        void Pin(struct Pinner* p, go_any pointer);
        void Unpin(struct Pinner* p);
        void unpin(struct pinner* p);
        bool isPinned(struct pinState* v);
        bool isMultiPinned(struct pinState* v);
        void setPinned(struct pinState* v, bool val);
        void setMultiPinned(struct pinState* v, bool val);
        void set(struct pinState* v, bool val, bool multipin);
        struct pinState ofObject(golang::runtime::pinnerBits* p, uintptr_t n);
        uintptr_t pinnerBitSize(struct mspan* s);
        runtime::pinnerBits* newPinnerBits(struct mspan* s);
        runtime::pinnerBits* getPinnerBits(struct mspan* s);
        void setPinnerBits(struct mspan* s, golang::runtime::pinnerBits* p);
        void refreshPinnerBits(struct mspan* s);
        void incPinCounter(struct mspan* span, uintptr_t offset);
        bool decPinCounter(struct mspan* span, uintptr_t offset);
    }
}

