// generated by GoCpp from file '$(ImportDir)/runtime/map_faststr.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/map_faststr.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/error.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/map.h"
#include "golang/runtime/mbarrier.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/race0.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace unsafe::rec;
    }

    unsafe::Pointer mapaccess1_faststr(golang::runtime::maptype* t, struct hmap* h, std::string ky)
    {
        if(raceenabled && h != nullptr)
        {
            auto callerpc = getcallerpc();
            racereadpc(unsafe::Pointer(h), callerpc, abi::FuncPCABIInternal(mapaccess1_faststr));
        }
        if(h == nullptr || h->count == 0)
        {
            return unsafe::Pointer(& zeroVal[0]);
        }
        if(h->flags & hashWriting != 0)
        {
            fatal("concurrent map read and map write");
        }
        auto key = stringStructOf(& ky);
        if(h->B == 0)
        {
            auto b = (bmap*)(h->buckets);
            if(key->len < 32)
            {
                for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
                {
                    auto k = (stringStruct*)(kptr);
                    if(k->len != key->len || isEmpty(b->tophash[i]))
                    {
                        if(b->tophash[i] == emptyRest)
                        {
                            break;
                        }
                        continue;
                    }
                    if(k->str == key->str || memequal(k->str, key->str, uintptr_t(key->len)))
                    {
                        return add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize));
                    }
                }
                return unsafe::Pointer(& zeroVal[0]);
            }
            auto keymaybe = uintptr_t(bucketCnt);
            for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
            {
                auto k = (stringStruct*)(kptr);
                if(k->len != key->len || isEmpty(b->tophash[i]))
                {
                    if(b->tophash[i] == emptyRest)
                    {
                        break;
                    }
                    continue;
                }
                if(k->str == key->str)
                {
                    return add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize));
                }
                if(*((gocpp::array<unsigned char, 4>*)(key->str)) != *((gocpp::array<unsigned char, 4>*)(k->str)))
                {
                    continue;
                }
                if(*((gocpp::array<unsigned char, 4>*)(add(key->str, uintptr_t(key->len) - 4))) != *((gocpp::array<unsigned char, 4>*)(add(k->str, uintptr_t(key->len) - 4))))
                {
                    continue;
                }
                if(keymaybe != bucketCnt)
                {
                    goto dohash;
                }
                keymaybe = i;
            }
            if(keymaybe != bucketCnt)
            {
                auto k = (stringStruct*)(add(unsafe::Pointer(b), dataOffset + keymaybe * 2 * goarch::PtrSize));
                if(memequal(k->str, key->str, uintptr_t(key->len)))
                {
                    return add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + keymaybe * uintptr_t(t->ValueSize));
                }
            }
            return unsafe::Pointer(& zeroVal[0]);
        }
        dohash:
        auto hash = rec::Hasher(gocpp::recv(t), noescape(unsafe::Pointer(& ky)), uintptr_t(h->hash0));
        auto m = bucketMask(h->B);
        auto b = (bmap*)(add(h->buckets, (hash & m) * uintptr_t(t->BucketSize)));
        if(auto c = h->oldbuckets; c != nullptr)
        {
            if(! rec::sameSizeGrow(gocpp::recv(h)))
            {
                m >>= 1;
            }
            auto oldb = (bmap*)(add(c, (hash & m) * uintptr_t(t->BucketSize)));
            if(! evacuated(oldb))
            {
                b = oldb;
            }
        }
        auto top = tophash(hash);
        for(; b != nullptr; b = rec::overflow(gocpp::recv(b), t))
        {
            for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
            {
                auto k = (stringStruct*)(kptr);
                if(k->len != key->len || b->tophash[i] != top)
                {
                    continue;
                }
                if(k->str == key->str || memequal(k->str, key->str, uintptr_t(key->len)))
                {
                    return add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize));
                }
            }
        }
        return unsafe::Pointer(& zeroVal[0]);
    }

    std::tuple<unsafe::Pointer, bool> mapaccess2_faststr(golang::runtime::maptype* t, struct hmap* h, std::string ky)
    {
        if(raceenabled && h != nullptr)
        {
            auto callerpc = getcallerpc();
            racereadpc(unsafe::Pointer(h), callerpc, abi::FuncPCABIInternal(mapaccess2_faststr));
        }
        if(h == nullptr || h->count == 0)
        {
            return {unsafe::Pointer(& zeroVal[0]), false};
        }
        if(h->flags & hashWriting != 0)
        {
            fatal("concurrent map read and map write");
        }
        auto key = stringStructOf(& ky);
        if(h->B == 0)
        {
            auto b = (bmap*)(h->buckets);
            if(key->len < 32)
            {
                for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
                {
                    auto k = (stringStruct*)(kptr);
                    if(k->len != key->len || isEmpty(b->tophash[i]))
                    {
                        if(b->tophash[i] == emptyRest)
                        {
                            break;
                        }
                        continue;
                    }
                    if(k->str == key->str || memequal(k->str, key->str, uintptr_t(key->len)))
                    {
                        return {add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize)), true};
                    }
                }
                return {unsafe::Pointer(& zeroVal[0]), false};
            }
            auto keymaybe = uintptr_t(bucketCnt);
            for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
            {
                auto k = (stringStruct*)(kptr);
                if(k->len != key->len || isEmpty(b->tophash[i]))
                {
                    if(b->tophash[i] == emptyRest)
                    {
                        break;
                    }
                    continue;
                }
                if(k->str == key->str)
                {
                    return {add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize)), true};
                }
                if(*((gocpp::array<unsigned char, 4>*)(key->str)) != *((gocpp::array<unsigned char, 4>*)(k->str)))
                {
                    continue;
                }
                if(*((gocpp::array<unsigned char, 4>*)(add(key->str, uintptr_t(key->len) - 4))) != *((gocpp::array<unsigned char, 4>*)(add(k->str, uintptr_t(key->len) - 4))))
                {
                    continue;
                }
                if(keymaybe != bucketCnt)
                {
                    goto dohash;
                }
                keymaybe = i;
            }
            if(keymaybe != bucketCnt)
            {
                auto k = (stringStruct*)(add(unsafe::Pointer(b), dataOffset + keymaybe * 2 * goarch::PtrSize));
                if(memequal(k->str, key->str, uintptr_t(key->len)))
                {
                    return {add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + keymaybe * uintptr_t(t->ValueSize)), true};
                }
            }
            return {unsafe::Pointer(& zeroVal[0]), false};
        }
        dohash:
        auto hash = rec::Hasher(gocpp::recv(t), noescape(unsafe::Pointer(& ky)), uintptr_t(h->hash0));
        auto m = bucketMask(h->B);
        auto b = (bmap*)(add(h->buckets, (hash & m) * uintptr_t(t->BucketSize)));
        if(auto c = h->oldbuckets; c != nullptr)
        {
            if(! rec::sameSizeGrow(gocpp::recv(h)))
            {
                m >>= 1;
            }
            auto oldb = (bmap*)(add(c, (hash & m) * uintptr_t(t->BucketSize)));
            if(! evacuated(oldb))
            {
                b = oldb;
            }
        }
        auto top = tophash(hash);
        for(; b != nullptr; b = rec::overflow(gocpp::recv(b), t))
        {
            for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
            {
                auto k = (stringStruct*)(kptr);
                if(k->len != key->len || b->tophash[i] != top)
                {
                    continue;
                }
                if(k->str == key->str || memequal(k->str, key->str, uintptr_t(key->len)))
                {
                    return {add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize)), true};
                }
            }
        }
        return {unsafe::Pointer(& zeroVal[0]), false};
    }

    unsafe::Pointer mapassign_faststr(golang::runtime::maptype* t, struct hmap* h, std::string s)
    {
        if(h == nullptr)
        {
            gocpp::panic(plainError("assignment to entry in nil map"));
        }
        if(raceenabled)
        {
            auto callerpc = getcallerpc();
            racewritepc(unsafe::Pointer(h), callerpc, abi::FuncPCABIInternal(mapassign_faststr));
        }
        if(h->flags & hashWriting != 0)
        {
            fatal("concurrent map writes");
        }
        auto key = stringStructOf(& s);
        auto hash = rec::Hasher(gocpp::recv(t), noescape(unsafe::Pointer(& s)), uintptr_t(h->hash0));
        h->flags ^= hashWriting;
        if(h->buckets == nullptr)
        {
            h->buckets = newobject(t->Bucket);
        }
        again:
        auto bucket = hash & bucketMask(h->B);
        if(rec::growing(gocpp::recv(h)))
        {
            growWork_faststr(t, h, bucket);
        }
        auto b = (bmap*)(add(h->buckets, bucket * uintptr_t(t->BucketSize)));
        auto top = tophash(hash);
        bmap* insertb = {};
        uintptr_t inserti = {};
        unsafe::Pointer insertk = {};
        bucketloop:
        for(; ; )
        {
            for(auto i = uintptr_t(0); i < bucketCnt; i++)
            {
                if(b->tophash[i] != top)
                {
                    if(isEmpty(b->tophash[i]) && insertb == nullptr)
                    {
                        insertb = b;
                        inserti = i;
                    }
                    if(b->tophash[i] == emptyRest)
                    {
                        goto bucketloop_break;
                    }
                    continue;
                }
                auto k = (stringStruct*)(add(unsafe::Pointer(b), dataOffset + i * 2 * goarch::PtrSize));
                if(k->len != key->len)
                {
                    continue;
                }
                if(k->str != key->str && ! memequal(k->str, key->str, uintptr_t(key->len)))
                {
                    continue;
                }
                inserti = i;
                insertb = b;
                k->str = key->str;
                goto done;
            }
            auto ovf = rec::overflow(gocpp::recv(b), t);
            if(ovf == nullptr)
            {
                break;
            }
            b = ovf;
            if(false) {
            bucketloop_continue:
                continue;
            bucketloop_break:
                break;
            }
        }
        if(! rec::growing(gocpp::recv(h)) && (overLoadFactor(h->count + 1, h->B) || tooManyOverflowBuckets(h->noverflow, h->B)))
        {
            hashGrow(t, h);
            goto again;
        }
        if(insertb == nullptr)
        {
            insertb = rec::newoverflow(gocpp::recv(h), t, b);
            inserti = 0;
        }
        insertb->tophash[inserti & (bucketCnt - 1)] = top;
        insertk = add(unsafe::Pointer(insertb), dataOffset + inserti * 2 * goarch::PtrSize);
        *((stringStruct*)(insertk)) = *key;
        h->count++;
        done:
        auto elem = add(unsafe::Pointer(insertb), dataOffset + bucketCnt * 2 * goarch::PtrSize + inserti * uintptr_t(t->ValueSize));
        if(h->flags & hashWriting == 0)
        {
            fatal("concurrent map writes");
        }
        h->flags &^= hashWriting;
        return elem;
    }

    void mapdelete_faststr(golang::runtime::maptype* t, struct hmap* h, std::string ky)
    {
        if(raceenabled && h != nullptr)
        {
            auto callerpc = getcallerpc();
            racewritepc(unsafe::Pointer(h), callerpc, abi::FuncPCABIInternal(mapdelete_faststr));
        }
        if(h == nullptr || h->count == 0)
        {
            return;
        }
        if(h->flags & hashWriting != 0)
        {
            fatal("concurrent map writes");
        }
        auto key = stringStructOf(& ky);
        auto hash = rec::Hasher(gocpp::recv(t), noescape(unsafe::Pointer(& ky)), uintptr_t(h->hash0));
        h->flags ^= hashWriting;
        auto bucket = hash & bucketMask(h->B);
        if(rec::growing(gocpp::recv(h)))
        {
            growWork_faststr(t, h, bucket);
        }
        auto b = (bmap*)(add(h->buckets, bucket * uintptr_t(t->BucketSize)));
        auto bOrig = b;
        auto top = tophash(hash);
        search:
        for(; b != nullptr; b = rec::overflow(gocpp::recv(b), t))
        {
            for(auto [i, kptr] = std::tuple{uintptr_t(0), rec::keys(gocpp::recv(b))}; i < bucketCnt; std::tie(i, kptr) = std::tuple{i + 1, add(kptr, 2 * goarch::PtrSize)})
            {
                auto k = (stringStruct*)(kptr);
                if(k->len != key->len || b->tophash[i] != top)
                {
                    continue;
                }
                if(k->str != key->str && ! memequal(k->str, key->str, uintptr_t(key->len)))
                {
                    continue;
                }
                k->str = nullptr;
                auto e = add(unsafe::Pointer(b), dataOffset + bucketCnt * 2 * goarch::PtrSize + i * uintptr_t(t->ValueSize));
                if(t->Elem->PtrBytes != 0)
                {
                    memclrHasPointers(e, t->Elem->Size_);
                }
                else
                {
                    memclrNoHeapPointers(e, t->Elem->Size_);
                }
                b->tophash[i] = emptyOne;
                if(i == bucketCnt - 1)
                {
                    if(rec::overflow(gocpp::recv(b), t) != nullptr && rec::overflow(gocpp::recv(b), t)->tophash[0] != emptyRest)
                    {
                        goto notLast;
                    }
                }
                else
                {
                    if(b->tophash[i + 1] != emptyRest)
                    {
                        goto notLast;
                    }
                }
                for(; ; )
                {
                    b->tophash[i] = emptyRest;
                    if(i == 0)
                    {
                        if(b == bOrig)
                        {
                            break;
                        }
                        auto c = b;
                        for(b = bOrig; rec::overflow(gocpp::recv(b), t) != c; b = rec::overflow(gocpp::recv(b), t))
                        {
                        }
                        i = bucketCnt - 1;
                    }
                    else
                    {
                        i--;
                    }
                    if(b->tophash[i] != emptyOne)
                    {
                        break;
                    }
                }
                notLast:
                h->count--;
                if(h->count == 0)
                {
                    h->hash0 = uint32_t(rand());
                }
                goto search_break;
            }
            if(false) {
            search_continue:
                continue;
            search_break:
                break;
            }
        }
        if(h->flags & hashWriting == 0)
        {
            fatal("concurrent map writes");
        }
        h->flags &^= hashWriting;
    }

    void growWork_faststr(golang::runtime::maptype* t, struct hmap* h, uintptr_t bucket)
    {
        evacuate_faststr(t, h, bucket & rec::oldbucketmask(gocpp::recv(h)));
        if(rec::growing(gocpp::recv(h)))
        {
            evacuate_faststr(t, h, h->nevacuate);
        }
    }

    void evacuate_faststr(golang::runtime::maptype* t, struct hmap* h, uintptr_t oldbucket)
    {
        auto b = (bmap*)(add(h->oldbuckets, oldbucket * uintptr_t(t->BucketSize)));
        auto newbit = rec::noldbuckets(gocpp::recv(h));
        if(! evacuated(b))
        {
            gocpp::array<evacDst, 2> xy = {};
            auto x = & xy[0];
            x->b = (bmap*)(add(h->buckets, oldbucket * uintptr_t(t->BucketSize)));
            x->k = add(unsafe::Pointer(x->b), dataOffset);
            x->e = add(x->k, bucketCnt * 2 * goarch::PtrSize);
            if(! rec::sameSizeGrow(gocpp::recv(h)))
            {
                auto y = & xy[1];
                y->b = (bmap*)(add(h->buckets, (oldbucket + newbit) * uintptr_t(t->BucketSize)));
                y->k = add(unsafe::Pointer(y->b), dataOffset);
                y->e = add(y->k, bucketCnt * 2 * goarch::PtrSize);
            }
            for(; b != nullptr; b = rec::overflow(gocpp::recv(b), t))
            {
                auto k = add(unsafe::Pointer(b), dataOffset);
                auto e = add(k, bucketCnt * 2 * goarch::PtrSize);
                for(auto i = 0; i < bucketCnt; std::tie(i, k, e) = std::tuple{i + 1, add(k, 2 * goarch::PtrSize), add(e, uintptr_t(t->ValueSize))})
                {
                    auto top = b->tophash[i];
                    if(isEmpty(top))
                    {
                        b->tophash[i] = evacuatedEmpty;
                        continue;
                    }
                    if(top < minTopHash)
                    {
                        go_throw("bad map state");
                    }
                    uint8_t useY = {};
                    if(! rec::sameSizeGrow(gocpp::recv(h)))
                    {
                        auto hash = rec::Hasher(gocpp::recv(t), k, uintptr_t(h->hash0));
                        if(hash & newbit != 0)
                        {
                            useY = 1;
                        }
                    }
                    b->tophash[i] = evacuatedX + useY;
                    auto dst = & xy[useY];
                    if(dst->i == bucketCnt)
                    {
                        dst->b = rec::newoverflow(gocpp::recv(h), t, dst->b);
                        dst->i = 0;
                        dst->k = add(unsafe::Pointer(dst->b), dataOffset);
                        dst->e = add(dst->k, bucketCnt * 2 * goarch::PtrSize);
                    }
                    dst->b->tophash[dst->i & (bucketCnt - 1)] = top;
                    *(std::string*)(dst->k) = *(std::string*)(k);
                    typedmemmove(t->Elem, dst->e, e);
                    dst->i++;
                    dst->k = add(dst->k, 2 * goarch::PtrSize);
                    dst->e = add(dst->e, uintptr_t(t->ValueSize));
                }
            }
            if(h->flags & oldIterator == 0 && t->Bucket->PtrBytes != 0)
            {
                auto b = add(h->oldbuckets, oldbucket * uintptr_t(t->BucketSize));
                auto ptr = add(b, dataOffset);
                auto n = uintptr_t(t->BucketSize) - dataOffset;
                memclrHasPointers(ptr, n);
            }
        }
        if(oldbucket == h->nevacuate)
        {
            advanceEvacuationMark(h, t, newbit);
        }
    }

}

