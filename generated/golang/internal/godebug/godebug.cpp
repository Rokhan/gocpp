// generated by GoCpp from file '$(ImportDir)/internal/godebug/godebug.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/godebug/godebug.h"
#include "gocpp/support.h"

#include "golang/internal/bisect/bisect.h"
#include "golang/internal/godebugs/table.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/unsafe/unsafe.h"

// Package godebug makes the settings in the $GODEBUG environment variable
// available to other packages. These settings are often used for compatibility
// tweaks, when we need to change a default behavior but want to let users
// opt back in to the original. For example GODEBUG=http2server=0 disables
// HTTP/2 support in the net/http server.
//
// In typical usage, code should declare a Setting as a global
// and then call Value each time the current setting value is needed:
//
//	var http2server = godebug.New("http2server")
//
//	func ServeConn(c net.Conn) {
//		if http2server.Value() == "0" {
//			disallow HTTP/2
//			...
//		}
//		...
//	}
//
// Each time a non-default setting causes a change in program behavior,
// code should call [Setting.IncNonDefault] to increment a counter that can
// be reported by [runtime/metrics.Read].
// Note that counters used with IncNonDefault must be added to
// various tables in other packages. See the [Setting.IncNonDefault]
// documentation for details.
namespace golang::godebug
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using bisect::rec::Stack;
        using mocklib::rec::Lock;
        using mocklib::rec::Unlock;
        using sync::rec::Do;
        using sync::rec::Load;
        using sync::rec::LoadOrStore;
        using sync::rec::Range;
    }

    // Note: Be careful about new imports here. Any package
    // that internal/godebug imports cannot itself import internal/godebug,
    // meaning it cannot introduce a GODEBUG setting of its own.
    // We keep imports to the absolute bare minimum.
    // A Setting is a single setting in the $GODEBUG environment variable.
    
    template<typename T> requires gocpp::GoStruct<T>
    Setting::operator T()
    {
        T result;
        result.name = this->name;
        result.once = this->once;
        result.setting = this->setting;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Setting::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (once != ref.once) return false;
        if (setting != ref.setting) return false;
        return true;
    }

    std::ostream& Setting::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << once;
        os << " " << setting;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Setting& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    setting::operator T()
    {
        T result;
        result.value = this->value;
        result.nonDefaultOnce = this->nonDefaultOnce;
        result.nonDefault = this->nonDefault;
        result.info = this->info;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool setting::operator==(const T& ref) const
    {
        if (value != ref.value) return false;
        if (nonDefaultOnce != ref.nonDefaultOnce) return false;
        if (nonDefault != ref.nonDefault) return false;
        if (info != ref.info) return false;
        return true;
    }

    std::ostream& setting::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << value;
        os << " " << nonDefaultOnce;
        os << " " << nonDefault;
        os << " " << info;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct setting& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    value::operator T()
    {
        T result;
        result.text = this->text;
        result.bisect = this->bisect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool value::operator==(const T& ref) const
    {
        if (text != ref.text) return false;
        if (bisect != ref.bisect) return false;
        return true;
    }

    std::ostream& value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << text;
        os << " " << bisect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct value& value)
    {
        return value.PrintTo(os);
    }

    // New returns a new Setting for the $GODEBUG setting with the given name.
    //
    // GODEBUGs meant for use by end users must be listed in ../godebugs/table.go,
    // which is used for generating and checking various documentation.
    // If the name is not listed in that table, New will succeed but calling Value
    // on the returned Setting will panic.
    // To disable that panic for access to an undocumented setting,
    // prefix the name with a #, as in godebug.New("#gofsystrace").
    // The # is a signal to New but not part of the key used in $GODEBUG.
    struct Setting* New(std::string name)
    {
        return gocpp::InitPtr<Setting>([=](auto& x) {
            x.name = name;
        });
    }

    // Name returns the name of the setting.
    std::string rec::Name(struct Setting* s)
    {
        if(s->name != ""s && s->name[0] == '#')
        {
            return s->name.make_slice(1);
        }
        return s->name;
    }

    // Undocumented reports whether this is an undocumented setting.
    bool rec::Undocumented(struct Setting* s)
    {
        return s->name != ""s && s->name[0] == '#';
    }

    // String returns a printable form for the setting: name=value.
    std::string rec::String(struct Setting* s)
    {
        return rec::Name(gocpp::recv(s)) + "="s + rec::Value(gocpp::recv(s));
    }

    // IncNonDefault increments the non-default behavior counter
    // associated with the given setting.
    // This counter is exposed in the runtime/metrics value
    // /godebug/non-default-behavior/<name>:events.
    //
    // Note that Value must be called at least once before IncNonDefault.
    void rec::IncNonDefault(struct Setting* s)
    {
        rec::Do(gocpp::recv(s->nonDefaultOnce), s->go_register);
        rec::Add(gocpp::recv(s->nonDefault), 1);
    }

    void rec::go_register(struct Setting* s)
    {
        if(s->info == nullptr || s->info->Opaque)
        {
            gocpp::panic("godebug: unexpected IncNonDefault of "s + s->name);
        }
        registerMetric("/godebug/non-default-behavior/"s + rec::Name(gocpp::recv(s)) + ":events"s, s->nonDefault.Load);
    }

    // cache is a cache of all the GODEBUG settings,
    // a locked map[string]*atomic.Pointer[string].
    //
    // All Settings with the same name share a single
    // *atomic.Pointer[string], so that when GODEBUG
    // changes only that single atomic string pointer
    // needs to be updated.
    //
    // A name appears in the values map either if it is the
    // name of a Setting for which Value has been called
    // at least once, or if the name has ever appeared in
    // a name=value pair in the $GODEBUG environment variable.
    // Once entered into the map, the name is never removed.
    sync::Map cache;
    value empty;
    // Value returns the current value for the GODEBUG setting s.
    //
    // Value maintains an internal cache that is synchronized
    // with changes to the $GODEBUG environment variable,
    // making Value efficient to call as frequently as needed.
    // Clients should therefore typically not attempt their own
    // caching of Value's result.
    std::string rec::Value(struct Setting* s)
    {
        rec::Do(gocpp::recv(s->once), [=]() mutable -> void
        {
            s->setting = lookup(rec::Name(gocpp::recv(s)));
            if(s->info == nullptr && ! rec::Undocumented(gocpp::recv(s)))
            {
                gocpp::panic("godebug: Value of name not listed in godebugs.All: "s + s->name);
            }
        });
        auto v = *rec::Load<value>(gocpp::recv(s->value));
        if(v.bisect != nullptr && ! rec::Stack(gocpp::recv(v.bisect), & go_stderr))
        {
            return ""s;
        }
        return v.text;
    }

    // lookup returns the unique *setting value for the given name.
    struct setting* lookup(std::string name)
    {
        if(auto [v, ok] = rec::Load(gocpp::recv(cache), name); ok)
        {
            return gocpp::getValue<setting*>(v);
        }
        auto s = new(setting);
        s->info = godebugs::Lookup(name);
        rec::Store<value>(gocpp::recv(s->value), & empty);
        if(auto [v, loaded] = rec::LoadOrStore(gocpp::recv(cache), name, s); loaded)
        {
            return gocpp::getValue<setting*>(v);
        }
        return s;
    }

    // setUpdate is provided by package runtime.
    // It calls update(def, env), where def is the default GODEBUG setting
    // and env is the current value of the $GODEBUG environment variable.
    // After that first call, the runtime calls update(def, env)
    // again each time the environment variable changes
    // (due to use of os.Setenv, for example).
    //
    //go:linkname setUpdate
    void setUpdate(std::function<void (std::string _1, std::string _2)> update)
    /* convertBlockStmt, nil block */;

    // registerMetric is provided by package runtime.
    // It forwards registrations to runtime/metrics.
    //
    //go:linkname registerMetric
    void registerMetric(std::string name, std::function<uint64_t ()> read)
    /* convertBlockStmt, nil block */;

    // setNewIncNonDefault is provided by package runtime.
    // The runtime can do
    //
    //	inc := newNonDefaultInc(name)
    //
    // instead of
    //
    //	inc := godebug.New(name).IncNonDefault
    //
    // since it cannot import godebug.
    //
    //go:linkname setNewIncNonDefault
    void setNewIncNonDefault(std::function<std::function<void ()> (std::string _1)> newIncNonDefault)
    /* convertBlockStmt, nil block */;

    void init()
    {
        setUpdate(update);
        setNewIncNonDefault(newIncNonDefault);
    }

    std::function<void ()> newIncNonDefault(std::string name)
    {
        auto s = New(name);
        rec::Value(gocpp::recv(s));
        return s->IncNonDefault;
    }

    mocklib::Mutex updateMu;
    // update records an updated GODEBUG setting.
    // def is the default GODEBUG setting for the running binary,
    // and env is the current value of the $GODEBUG environment variable.
    void update(std::string def, std::string env)
    {
        gocpp::Defer defer;
        try
        {
            rec::Lock(gocpp::recv(updateMu));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(updateMu)); });
            auto did = gocpp::make(gocpp::Tag<gocpp::map<std::string, bool>>());
            parse(did, env);
            parse(did, def);
            rec::Range(gocpp::recv(cache), [=](go_any name, go_any s) mutable -> bool
            {
                if(! did[gocpp::getValue<std::string>(name)])
                {
                    rec::Store<value>(gocpp::recv(gocpp::getValue<setting*>(s)->value), & empty);
                }
                return true;
            });
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // parse parses the GODEBUG setting string s,
    // which has the form k=v,k2=v2,k3=v3.
    // Later settings override earlier ones.
    // Parse only updates settings k=v for which did[k] = false.
    // It also sets did[k] = true for settings that it updates.
    // Each value v can also have the form v#pattern,
    // in which case the GODEBUG is only enabled for call stacks
    // matching pattern, for use with golang.org/x/tools/cmd/bisect.
    void parse(gocpp::map<std::string, bool> did, std::string s)
    {
        auto end = len(s);
        auto eq = - 1;
        for(auto i = end - 1; i >= - 1; i--)
        {
            if(i == - 1 || s[i] == ',')
            {
                if(eq >= 0)
                {
                    auto [name, arg] = std::tuple{s.make_slice(i + 1, eq), s.make_slice(eq + 1, end)};
                    if(! did[name])
                    {
                        did[name] = true;
                        auto v = gocpp::InitPtr<value>([=](auto& x) {
                            x.text = arg;
                        });
                        for(auto j = 0; j < len(arg); j++)
                        {
                            if(arg[j] == '#')
                            {
                                v->text = arg.make_slice(0, j);
                                std::tie(v->bisect, gocpp_id_0) = bisect::New(arg.make_slice(j + 1));
                                break;
                            }
                        }
                        rec::Store<value>(gocpp::recv(lookup(name)->value), v);
                    }
                }
                eq = - 1;
                end = i;
            }
            else
            if(s[i] == '=')
            {
                eq = i;
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeStderr::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeStderr::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& runtimeStderr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeStderr& value)
    {
        return value.PrintTo(os);
    }

    runtimeStderr go_stderr;
    std::tuple<int, struct gocpp::error> rec::Write(runtimeStderr*, gocpp::slice<unsigned char> b)
    {
        if(len(b) > 0)
        {
            write(2, unsafe::Pointer(& b[0]), int32_t(len(b)));
        }
        return {len(b), nullptr};
    }

    // Since we cannot import os or syscall, use the runtime's write function
    // to print to standard error.
    //
    //go:linkname write runtime.write
    int32_t write(uintptr_t fd, unsafe::Pointer p, int32_t n)
    /* convertBlockStmt, nil block */;

}

