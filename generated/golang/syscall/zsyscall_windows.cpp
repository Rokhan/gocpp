// generated by GoCpp from file '$(ImportDir)/syscall/zsyscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/zsyscall_windows.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/sysdll/sysdll.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    unsafe::Pointer _;
    // Do the interface allocations only once for common
    // Errno values.
    gocpp::error errERROR_IO_PENDING = Errno(errnoERROR_IO_PENDING);
    gocpp::error errERROR_EINVAL = go_EINVAL;
    // errnoErr returns common boxed Errno values, to prevent
    // allocations at runtime.
    struct gocpp::error errnoErr(golang::syscall::Errno e)
    {
        //Go switch emulation
        {
            auto condition = e;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == errnoERROR_IO_PENDING) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return errERROR_EINVAL;
                    break;
                case 1:
                    return errERROR_IO_PENDING;
                    break;
            }
        }
        return e;
    }

    LazyDLL* modadvapi32 = NewLazyDLL(sysdll::Add("advapi32.dll"s));
    LazyDLL* modcrypt32 = NewLazyDLL(sysdll::Add("crypt32.dll"s));
    LazyDLL* moddnsapi = NewLazyDLL(sysdll::Add("dnsapi.dll"s));
    LazyDLL* modiphlpapi = NewLazyDLL(sysdll::Add("iphlpapi.dll"s));
    LazyDLL* modkernel32 = NewLazyDLL(sysdll::Add("kernel32.dll"s));
    LazyDLL* modmswsock = NewLazyDLL(sysdll::Add("mswsock.dll"s));
    LazyDLL* modnetapi32 = NewLazyDLL(sysdll::Add("netapi32.dll"s));
    LazyDLL* modntdll = NewLazyDLL(sysdll::Add("ntdll.dll"s));
    LazyDLL* modsecur32 = NewLazyDLL(sysdll::Add("secur32.dll"s));
    LazyDLL* modshell32 = NewLazyDLL(sysdll::Add("shell32.dll"s));
    LazyDLL* moduserenv = NewLazyDLL(sysdll::Add("userenv.dll"s));
    LazyDLL* modws2_32 = NewLazyDLL(sysdll::Add("ws2_32.dll"s));
    LazyProc* procConvertSidToStringSidW = rec::NewProc(gocpp::recv(modadvapi32), "ConvertSidToStringSidW"s);
    LazyProc* procConvertStringSidToSidW = rec::NewProc(gocpp::recv(modadvapi32), "ConvertStringSidToSidW"s);
    LazyProc* procCopySid = rec::NewProc(gocpp::recv(modadvapi32), "CopySid"s);
    LazyProc* procCreateProcessAsUserW = rec::NewProc(gocpp::recv(modadvapi32), "CreateProcessAsUserW"s);
    LazyProc* procCryptAcquireContextW = rec::NewProc(gocpp::recv(modadvapi32), "CryptAcquireContextW"s);
    LazyProc* procCryptGenRandom = rec::NewProc(gocpp::recv(modadvapi32), "CryptGenRandom"s);
    LazyProc* procCryptReleaseContext = rec::NewProc(gocpp::recv(modadvapi32), "CryptReleaseContext"s);
    LazyProc* procGetLengthSid = rec::NewProc(gocpp::recv(modadvapi32), "GetLengthSid"s);
    LazyProc* procGetTokenInformation = rec::NewProc(gocpp::recv(modadvapi32), "GetTokenInformation"s);
    LazyProc* procLookupAccountNameW = rec::NewProc(gocpp::recv(modadvapi32), "LookupAccountNameW"s);
    LazyProc* procLookupAccountSidW = rec::NewProc(gocpp::recv(modadvapi32), "LookupAccountSidW"s);
    LazyProc* procOpenProcessToken = rec::NewProc(gocpp::recv(modadvapi32), "OpenProcessToken"s);
    LazyProc* procRegCloseKey = rec::NewProc(gocpp::recv(modadvapi32), "RegCloseKey"s);
    LazyProc* procRegEnumKeyExW = rec::NewProc(gocpp::recv(modadvapi32), "RegEnumKeyExW"s);
    LazyProc* procRegOpenKeyExW = rec::NewProc(gocpp::recv(modadvapi32), "RegOpenKeyExW"s);
    LazyProc* procRegQueryInfoKeyW = rec::NewProc(gocpp::recv(modadvapi32), "RegQueryInfoKeyW"s);
    LazyProc* procRegQueryValueExW = rec::NewProc(gocpp::recv(modadvapi32), "RegQueryValueExW"s);
    LazyProc* procCertAddCertificateContextToStore = rec::NewProc(gocpp::recv(modcrypt32), "CertAddCertificateContextToStore"s);
    LazyProc* procCertCloseStore = rec::NewProc(gocpp::recv(modcrypt32), "CertCloseStore"s);
    LazyProc* procCertCreateCertificateContext = rec::NewProc(gocpp::recv(modcrypt32), "CertCreateCertificateContext"s);
    LazyProc* procCertEnumCertificatesInStore = rec::NewProc(gocpp::recv(modcrypt32), "CertEnumCertificatesInStore"s);
    LazyProc* procCertFreeCertificateChain = rec::NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateChain"s);
    LazyProc* procCertFreeCertificateContext = rec::NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateContext"s);
    LazyProc* procCertGetCertificateChain = rec::NewProc(gocpp::recv(modcrypt32), "CertGetCertificateChain"s);
    LazyProc* procCertOpenStore = rec::NewProc(gocpp::recv(modcrypt32), "CertOpenStore"s);
    LazyProc* procCertOpenSystemStoreW = rec::NewProc(gocpp::recv(modcrypt32), "CertOpenSystemStoreW"s);
    LazyProc* procCertVerifyCertificateChainPolicy = rec::NewProc(gocpp::recv(modcrypt32), "CertVerifyCertificateChainPolicy"s);
    LazyProc* procDnsNameCompare_W = rec::NewProc(gocpp::recv(moddnsapi), "DnsNameCompare_W"s);
    LazyProc* procDnsQuery_W = rec::NewProc(gocpp::recv(moddnsapi), "DnsQuery_W"s);
    LazyProc* procDnsRecordListFree = rec::NewProc(gocpp::recv(moddnsapi), "DnsRecordListFree"s);
    LazyProc* procGetAdaptersInfo = rec::NewProc(gocpp::recv(modiphlpapi), "GetAdaptersInfo"s);
    LazyProc* procGetIfEntry = rec::NewProc(gocpp::recv(modiphlpapi), "GetIfEntry"s);
    LazyProc* procCancelIo = rec::NewProc(gocpp::recv(modkernel32), "CancelIo"s);
    LazyProc* procCancelIoEx = rec::NewProc(gocpp::recv(modkernel32), "CancelIoEx"s);
    LazyProc* procCloseHandle = rec::NewProc(gocpp::recv(modkernel32), "CloseHandle"s);
    LazyProc* procCreateDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "CreateDirectoryW"s);
    LazyProc* procCreateFileMappingW = rec::NewProc(gocpp::recv(modkernel32), "CreateFileMappingW"s);
    LazyProc* procCreateFileW = rec::NewProc(gocpp::recv(modkernel32), "CreateFileW"s);
    LazyProc* procCreateHardLinkW = rec::NewProc(gocpp::recv(modkernel32), "CreateHardLinkW"s);
    LazyProc* procCreateIoCompletionPort = rec::NewProc(gocpp::recv(modkernel32), "CreateIoCompletionPort"s);
    LazyProc* procCreatePipe = rec::NewProc(gocpp::recv(modkernel32), "CreatePipe"s);
    LazyProc* procCreateProcessW = rec::NewProc(gocpp::recv(modkernel32), "CreateProcessW"s);
    LazyProc* procCreateSymbolicLinkW = rec::NewProc(gocpp::recv(modkernel32), "CreateSymbolicLinkW"s);
    LazyProc* procCreateToolhelp32Snapshot = rec::NewProc(gocpp::recv(modkernel32), "CreateToolhelp32Snapshot"s);
    LazyProc* procDeleteFileW = rec::NewProc(gocpp::recv(modkernel32), "DeleteFileW"s);
    LazyProc* procDeleteProcThreadAttributeList = rec::NewProc(gocpp::recv(modkernel32), "DeleteProcThreadAttributeList"s);
    LazyProc* procDeviceIoControl = rec::NewProc(gocpp::recv(modkernel32), "DeviceIoControl"s);
    LazyProc* procDuplicateHandle = rec::NewProc(gocpp::recv(modkernel32), "DuplicateHandle"s);
    LazyProc* procExitProcess = rec::NewProc(gocpp::recv(modkernel32), "ExitProcess"s);
    LazyProc* procFindClose = rec::NewProc(gocpp::recv(modkernel32), "FindClose"s);
    LazyProc* procFindFirstFileW = rec::NewProc(gocpp::recv(modkernel32), "FindFirstFileW"s);
    LazyProc* procFindNextFileW = rec::NewProc(gocpp::recv(modkernel32), "FindNextFileW"s);
    LazyProc* procFlushFileBuffers = rec::NewProc(gocpp::recv(modkernel32), "FlushFileBuffers"s);
    LazyProc* procFlushViewOfFile = rec::NewProc(gocpp::recv(modkernel32), "FlushViewOfFile"s);
    LazyProc* procFormatMessageW = rec::NewProc(gocpp::recv(modkernel32), "FormatMessageW"s);
    LazyProc* procFreeEnvironmentStringsW = rec::NewProc(gocpp::recv(modkernel32), "FreeEnvironmentStringsW"s);
    LazyProc* procFreeLibrary = rec::NewProc(gocpp::recv(modkernel32), "FreeLibrary"s);
    LazyProc* procGetCommandLineW = rec::NewProc(gocpp::recv(modkernel32), "GetCommandLineW"s);
    LazyProc* procGetComputerNameW = rec::NewProc(gocpp::recv(modkernel32), "GetComputerNameW"s);
    LazyProc* procGetConsoleMode = rec::NewProc(gocpp::recv(modkernel32), "GetConsoleMode"s);
    LazyProc* procGetCurrentDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "GetCurrentDirectoryW"s);
    LazyProc* procGetCurrentProcess = rec::NewProc(gocpp::recv(modkernel32), "GetCurrentProcess"s);
    LazyProc* procGetCurrentProcessId = rec::NewProc(gocpp::recv(modkernel32), "GetCurrentProcessId"s);
    LazyProc* procGetEnvironmentStringsW = rec::NewProc(gocpp::recv(modkernel32), "GetEnvironmentStringsW"s);
    LazyProc* procGetEnvironmentVariableW = rec::NewProc(gocpp::recv(modkernel32), "GetEnvironmentVariableW"s);
    LazyProc* procGetExitCodeProcess = rec::NewProc(gocpp::recv(modkernel32), "GetExitCodeProcess"s);
    LazyProc* procGetFileAttributesExW = rec::NewProc(gocpp::recv(modkernel32), "GetFileAttributesExW"s);
    LazyProc* procGetFileAttributesW = rec::NewProc(gocpp::recv(modkernel32), "GetFileAttributesW"s);
    LazyProc* procGetFileInformationByHandle = rec::NewProc(gocpp::recv(modkernel32), "GetFileInformationByHandle"s);
    LazyProc* procGetFileType = rec::NewProc(gocpp::recv(modkernel32), "GetFileType"s);
    LazyProc* procGetFinalPathNameByHandleW = rec::NewProc(gocpp::recv(modkernel32), "GetFinalPathNameByHandleW"s);
    LazyProc* procGetFullPathNameW = rec::NewProc(gocpp::recv(modkernel32), "GetFullPathNameW"s);
    LazyProc* procGetLastError = rec::NewProc(gocpp::recv(modkernel32), "GetLastError"s);
    LazyProc* procGetLongPathNameW = rec::NewProc(gocpp::recv(modkernel32), "GetLongPathNameW"s);
    LazyProc* procGetProcAddress = rec::NewProc(gocpp::recv(modkernel32), "GetProcAddress"s);
    LazyProc* procGetProcessTimes = rec::NewProc(gocpp::recv(modkernel32), "GetProcessTimes"s);
    LazyProc* procGetQueuedCompletionStatus = rec::NewProc(gocpp::recv(modkernel32), "GetQueuedCompletionStatus"s);
    LazyProc* procGetShortPathNameW = rec::NewProc(gocpp::recv(modkernel32), "GetShortPathNameW"s);
    LazyProc* procGetStartupInfoW = rec::NewProc(gocpp::recv(modkernel32), "GetStartupInfoW"s);
    LazyProc* procGetStdHandle = rec::NewProc(gocpp::recv(modkernel32), "GetStdHandle"s);
    LazyProc* procGetSystemTimeAsFileTime = rec::NewProc(gocpp::recv(modkernel32), "GetSystemTimeAsFileTime"s);
    LazyProc* procGetTempPathW = rec::NewProc(gocpp::recv(modkernel32), "GetTempPathW"s);
    LazyProc* procGetTimeZoneInformation = rec::NewProc(gocpp::recv(modkernel32), "GetTimeZoneInformation"s);
    LazyProc* procGetVersion = rec::NewProc(gocpp::recv(modkernel32), "GetVersion"s);
    LazyProc* procInitializeProcThreadAttributeList = rec::NewProc(gocpp::recv(modkernel32), "InitializeProcThreadAttributeList"s);
    LazyProc* procLoadLibraryW = rec::NewProc(gocpp::recv(modkernel32), "LoadLibraryW"s);
    LazyProc* procLocalFree = rec::NewProc(gocpp::recv(modkernel32), "LocalFree"s);
    LazyProc* procMapViewOfFile = rec::NewProc(gocpp::recv(modkernel32), "MapViewOfFile"s);
    LazyProc* procMoveFileW = rec::NewProc(gocpp::recv(modkernel32), "MoveFileW"s);
    LazyProc* procOpenProcess = rec::NewProc(gocpp::recv(modkernel32), "OpenProcess"s);
    LazyProc* procPostQueuedCompletionStatus = rec::NewProc(gocpp::recv(modkernel32), "PostQueuedCompletionStatus"s);
    LazyProc* procProcess32FirstW = rec::NewProc(gocpp::recv(modkernel32), "Process32FirstW"s);
    LazyProc* procProcess32NextW = rec::NewProc(gocpp::recv(modkernel32), "Process32NextW"s);
    LazyProc* procReadConsoleW = rec::NewProc(gocpp::recv(modkernel32), "ReadConsoleW"s);
    LazyProc* procReadDirectoryChangesW = rec::NewProc(gocpp::recv(modkernel32), "ReadDirectoryChangesW"s);
    LazyProc* procReadFile = rec::NewProc(gocpp::recv(modkernel32), "ReadFile"s);
    LazyProc* procRemoveDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "RemoveDirectoryW"s);
    LazyProc* procSetCurrentDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "SetCurrentDirectoryW"s);
    LazyProc* procSetEndOfFile = rec::NewProc(gocpp::recv(modkernel32), "SetEndOfFile"s);
    LazyProc* procSetEnvironmentVariableW = rec::NewProc(gocpp::recv(modkernel32), "SetEnvironmentVariableW"s);
    LazyProc* procSetFileAttributesW = rec::NewProc(gocpp::recv(modkernel32), "SetFileAttributesW"s);
    LazyProc* procSetFileCompletionNotificationModes = rec::NewProc(gocpp::recv(modkernel32), "SetFileCompletionNotificationModes"s);
    LazyProc* procSetFilePointer = rec::NewProc(gocpp::recv(modkernel32), "SetFilePointer"s);
    LazyProc* procSetFileTime = rec::NewProc(gocpp::recv(modkernel32), "SetFileTime"s);
    LazyProc* procSetHandleInformation = rec::NewProc(gocpp::recv(modkernel32), "SetHandleInformation"s);
    LazyProc* procTerminateProcess = rec::NewProc(gocpp::recv(modkernel32), "TerminateProcess"s);
    LazyProc* procUnmapViewOfFile = rec::NewProc(gocpp::recv(modkernel32), "UnmapViewOfFile"s);
    LazyProc* procUpdateProcThreadAttribute = rec::NewProc(gocpp::recv(modkernel32), "UpdateProcThreadAttribute"s);
    LazyProc* procVirtualLock = rec::NewProc(gocpp::recv(modkernel32), "VirtualLock"s);
    LazyProc* procVirtualUnlock = rec::NewProc(gocpp::recv(modkernel32), "VirtualUnlock"s);
    LazyProc* procWaitForSingleObject = rec::NewProc(gocpp::recv(modkernel32), "WaitForSingleObject"s);
    LazyProc* procWriteConsoleW = rec::NewProc(gocpp::recv(modkernel32), "WriteConsoleW"s);
    LazyProc* procWriteFile = rec::NewProc(gocpp::recv(modkernel32), "WriteFile"s);
    LazyProc* procAcceptEx = rec::NewProc(gocpp::recv(modmswsock), "AcceptEx"s);
    LazyProc* procGetAcceptExSockaddrs = rec::NewProc(gocpp::recv(modmswsock), "GetAcceptExSockaddrs"s);
    LazyProc* procTransmitFile = rec::NewProc(gocpp::recv(modmswsock), "TransmitFile"s);
    LazyProc* procNetApiBufferFree = rec::NewProc(gocpp::recv(modnetapi32), "NetApiBufferFree"s);
    LazyProc* procNetGetJoinInformation = rec::NewProc(gocpp::recv(modnetapi32), "NetGetJoinInformation"s);
    LazyProc* procNetUserGetInfo = rec::NewProc(gocpp::recv(modnetapi32), "NetUserGetInfo"s);
    LazyProc* procRtlGetNtVersionNumbers = rec::NewProc(gocpp::recv(modntdll), "RtlGetNtVersionNumbers"s);
    LazyProc* procGetUserNameExW = rec::NewProc(gocpp::recv(modsecur32), "GetUserNameExW"s);
    LazyProc* procTranslateNameW = rec::NewProc(gocpp::recv(modsecur32), "TranslateNameW"s);
    LazyProc* procCommandLineToArgvW = rec::NewProc(gocpp::recv(modshell32), "CommandLineToArgvW"s);
    LazyProc* procGetUserProfileDirectoryW = rec::NewProc(gocpp::recv(moduserenv), "GetUserProfileDirectoryW"s);
    LazyProc* procFreeAddrInfoW = rec::NewProc(gocpp::recv(modws2_32), "FreeAddrInfoW"s);
    LazyProc* procGetAddrInfoW = rec::NewProc(gocpp::recv(modws2_32), "GetAddrInfoW"s);
    LazyProc* procWSACleanup = rec::NewProc(gocpp::recv(modws2_32), "WSACleanup"s);
    LazyProc* procWSAEnumProtocolsW = rec::NewProc(gocpp::recv(modws2_32), "WSAEnumProtocolsW"s);
    LazyProc* procWSAIoctl = rec::NewProc(gocpp::recv(modws2_32), "WSAIoctl"s);
    LazyProc* procWSARecv = rec::NewProc(gocpp::recv(modws2_32), "WSARecv"s);
    LazyProc* procWSARecvFrom = rec::NewProc(gocpp::recv(modws2_32), "WSARecvFrom"s);
    LazyProc* procWSASend = rec::NewProc(gocpp::recv(modws2_32), "WSASend"s);
    LazyProc* procWSASendTo = rec::NewProc(gocpp::recv(modws2_32), "WSASendTo"s);
    LazyProc* procWSAStartup = rec::NewProc(gocpp::recv(modws2_32), "WSAStartup"s);
    LazyProc* procbind = rec::NewProc(gocpp::recv(modws2_32), "bind"s);
    LazyProc* procclosesocket = rec::NewProc(gocpp::recv(modws2_32), "closesocket"s);
    LazyProc* procconnect = rec::NewProc(gocpp::recv(modws2_32), "connect"s);
    LazyProc* procgethostbyname = rec::NewProc(gocpp::recv(modws2_32), "gethostbyname"s);
    LazyProc* procgetpeername = rec::NewProc(gocpp::recv(modws2_32), "getpeername"s);
    LazyProc* procgetprotobyname = rec::NewProc(gocpp::recv(modws2_32), "getprotobyname"s);
    LazyProc* procgetservbyname = rec::NewProc(gocpp::recv(modws2_32), "getservbyname"s);
    LazyProc* procgetsockname = rec::NewProc(gocpp::recv(modws2_32), "getsockname"s);
    LazyProc* procgetsockopt = rec::NewProc(gocpp::recv(modws2_32), "getsockopt"s);
    LazyProc* proclisten = rec::NewProc(gocpp::recv(modws2_32), "listen"s);
    LazyProc* procntohs = rec::NewProc(gocpp::recv(modws2_32), "ntohs"s);
    LazyProc* procsetsockopt = rec::NewProc(gocpp::recv(modws2_32), "setsockopt"s);
    LazyProc* procshutdown = rec::NewProc(gocpp::recv(modws2_32), "shutdown"s);
    LazyProc* procsocket = rec::NewProc(gocpp::recv(modws2_32), "socket"s);
    struct gocpp::error ConvertSidToStringSid(struct SID* sid, uint16_t** stringSid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_1, e1] = Syscall(rec::Addr(gocpp::recv(procConvertSidToStringSidW)), 2, uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(stringSid)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ConvertStringSidToSid(uint16_t* stringSid, struct SID** sid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_3, e1] = Syscall(rec::Addr(gocpp::recv(procConvertStringSidToSidW)), 2, uintptr_t(unsafe::Pointer(stringSid)), uintptr_t(unsafe::Pointer(sid)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CopySid(uint32_t destSidLen, struct SID* destSid, struct SID* srcSid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_5, e1] = Syscall(rec::Addr(gocpp::recv(procCopySid)), 3, uintptr_t(destSidLen), uintptr_t(unsafe::Pointer(destSid)), uintptr_t(unsafe::Pointer(srcSid)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateProcessAsUser(golang::syscall::Token token, uint16_t* appName, uint16_t* commandLine, struct SecurityAttributes* procSecurity, struct SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, struct StartupInfo* startupInfo, struct ProcessInformation* outProcInfo)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_7, e1] = Syscall12(rec::Addr(gocpp::recv(procCreateProcessAsUserW)), 11, uintptr_t(token), uintptr_t(unsafe::Pointer(appName)), uintptr_t(unsafe::Pointer(commandLine)), uintptr_t(unsafe::Pointer(procSecurity)), uintptr_t(unsafe::Pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(unsafe::Pointer(env)), uintptr_t(unsafe::Pointer(currentDir)), uintptr_t(unsafe::Pointer(startupInfo)), uintptr_t(unsafe::Pointer(outProcInfo)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptAcquireContext(golang::syscall::Handle* provhandle, uint16_t* container, uint16_t* provider, uint32_t provtype, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_9, e1] = Syscall6(rec::Addr(gocpp::recv(procCryptAcquireContextW)), 5, uintptr_t(unsafe::Pointer(provhandle)), uintptr_t(unsafe::Pointer(container)), uintptr_t(unsafe::Pointer(provider)), uintptr_t(provtype), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptGenRandom(golang::syscall::Handle provhandle, uint32_t buflen, unsigned char* buf)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_11, e1] = Syscall(rec::Addr(gocpp::recv(procCryptGenRandom)), 3, uintptr_t(provhandle), uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptReleaseContext(golang::syscall::Handle provhandle, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_13, e1] = Syscall(rec::Addr(gocpp::recv(procCryptReleaseContext)), 2, uintptr_t(provhandle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    uint32_t GetLengthSid(struct SID* sid)
    {
        uint32_t len;
        auto [r0, gocpp_id_16, gocpp_id_17] = Syscall(rec::Addr(gocpp::recv(procGetLengthSid)), 1, uintptr_t(unsafe::Pointer(sid)), 0, 0);
        len = uint32_t(r0);
        return len;
    }

    struct gocpp::error GetTokenInformation(golang::syscall::Token t, uint32_t infoClass, unsigned char* info, uint32_t infoLen, uint32_t* returnedLen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_19, e1] = Syscall6(rec::Addr(gocpp::recv(procGetTokenInformation)), 5, uintptr_t(t), uintptr_t(infoClass), uintptr_t(unsafe::Pointer(info)), uintptr_t(infoLen), uintptr_t(unsafe::Pointer(returnedLen)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error LookupAccountName(uint16_t* systemName, uint16_t* accountName, struct SID* sid, uint32_t* sidLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_21, e1] = Syscall9(rec::Addr(gocpp::recv(procLookupAccountNameW)), 7, uintptr_t(unsafe::Pointer(systemName)), uintptr_t(unsafe::Pointer(accountName)), uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(sidLen)), uintptr_t(unsafe::Pointer(refdDomainName)), uintptr_t(unsafe::Pointer(refdDomainNameLen)), uintptr_t(unsafe::Pointer(use)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error LookupAccountSid(uint16_t* systemName, struct SID* sid, uint16_t* name, uint32_t* nameLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_23, e1] = Syscall9(rec::Addr(gocpp::recv(procLookupAccountSidW)), 7, uintptr_t(unsafe::Pointer(systemName)), uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(nameLen)), uintptr_t(unsafe::Pointer(refdDomainName)), uintptr_t(unsafe::Pointer(refdDomainNameLen)), uintptr_t(unsafe::Pointer(use)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error OpenProcessToken(golang::syscall::Handle h, uint32_t access, golang::syscall::Token* token)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_25, e1] = Syscall(rec::Addr(gocpp::recv(procOpenProcessToken)), 3, uintptr_t(h), uintptr_t(access), uintptr_t(unsafe::Pointer(token)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error RegCloseKey(golang::syscall::Handle key)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_28, gocpp_id_29] = Syscall(rec::Addr(gocpp::recv(procRegCloseKey)), 1, uintptr_t(key), 0, 0);
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error regEnumKeyEx(golang::syscall::Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_32, gocpp_id_33] = Syscall9(rec::Addr(gocpp::recv(procRegEnumKeyExW)), 8, uintptr_t(key), uintptr_t(index), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(nameLen)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(go_class)), uintptr_t(unsafe::Pointer(classLen)), uintptr_t(unsafe::Pointer(lastWriteTime)), 0);
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegOpenKeyEx(golang::syscall::Handle key, uint16_t* subkey, uint32_t options, uint32_t desiredAccess, golang::syscall::Handle* result)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_36, gocpp_id_37] = Syscall6(rec::Addr(gocpp::recv(procRegOpenKeyExW)), 5, uintptr_t(key), uintptr_t(unsafe::Pointer(subkey)), uintptr_t(options), uintptr_t(desiredAccess), uintptr_t(unsafe::Pointer(result)), 0);
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegQueryInfoKey(golang::syscall::Handle key, uint16_t* go_class, uint32_t* classLen, uint32_t* reserved, uint32_t* subkeysLen, uint32_t* maxSubkeyLen, uint32_t* maxClassLen, uint32_t* valuesLen, uint32_t* maxValueNameLen, uint32_t* maxValueLen, uint32_t* saLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_40, gocpp_id_41] = Syscall12(rec::Addr(gocpp::recv(procRegQueryInfoKeyW)), 12, uintptr_t(key), uintptr_t(unsafe::Pointer(go_class)), uintptr_t(unsafe::Pointer(classLen)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(subkeysLen)), uintptr_t(unsafe::Pointer(maxSubkeyLen)), uintptr_t(unsafe::Pointer(maxClassLen)), uintptr_t(unsafe::Pointer(valuesLen)), uintptr_t(unsafe::Pointer(maxValueNameLen)), uintptr_t(unsafe::Pointer(maxValueLen)), uintptr_t(unsafe::Pointer(saLen)), uintptr_t(unsafe::Pointer(lastWriteTime)));
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegQueryValueEx(golang::syscall::Handle key, uint16_t* name, uint32_t* reserved, uint32_t* valtype, unsigned char* buf, uint32_t* buflen)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_44, gocpp_id_45] = Syscall6(rec::Addr(gocpp::recv(procRegQueryValueExW)), 6, uintptr_t(key), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(valtype)), uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(buflen)));
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error CertAddCertificateContextToStore(golang::syscall::Handle store, struct CertContext* certContext, uint32_t addDisposition, struct CertContext** storeContext)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_47, e1] = Syscall6(rec::Addr(gocpp::recv(procCertAddCertificateContextToStore)), 4, uintptr_t(store), uintptr_t(unsafe::Pointer(certContext)), uintptr_t(addDisposition), uintptr_t(unsafe::Pointer(storeContext)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CertCloseStore(golang::syscall::Handle store, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_49, e1] = Syscall(rec::Addr(gocpp::recv(procCertCloseStore)), 2, uintptr_t(store), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct CertContext*, struct gocpp::error> CertCreateCertificateContext(uint32_t certEncodingType, unsigned char* certEncoded, uint32_t encodedLen)
    {
        struct CertContext* context;
        struct gocpp::error err;
        auto [r0, gocpp_id_51, e1] = Syscall(rec::Addr(gocpp::recv(procCertCreateCertificateContext)), 3, uintptr_t(certEncodingType), uintptr_t(unsafe::Pointer(certEncoded)), uintptr_t(encodedLen));
        context = (CertContext*)(unsafe::Pointer(r0));
        if(context == nullptr)
        {
            err = errnoErr(e1);
        }
        return {context, err};
    }

    std::tuple<struct CertContext*, struct gocpp::error> CertEnumCertificatesInStore(golang::syscall::Handle store, struct CertContext* prevContext)
    {
        struct CertContext* context;
        struct gocpp::error err;
        auto [r0, gocpp_id_53, e1] = Syscall(rec::Addr(gocpp::recv(procCertEnumCertificatesInStore)), 2, uintptr_t(store), uintptr_t(unsafe::Pointer(prevContext)), 0);
        context = (CertContext*)(unsafe::Pointer(r0));
        if(context == nullptr)
        {
            err = errnoErr(e1);
        }
        return {context, err};
    }

    void CertFreeCertificateChain(struct CertChainContext* ctx)
    {
        Syscall(rec::Addr(gocpp::recv(procCertFreeCertificateChain)), 1, uintptr_t(unsafe::Pointer(ctx)), 0, 0);
        return;
    }

    struct gocpp::error CertFreeCertificateContext(struct CertContext* ctx)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_55, e1] = Syscall(rec::Addr(gocpp::recv(procCertFreeCertificateContext)), 1, uintptr_t(unsafe::Pointer(ctx)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CertGetCertificateChain(golang::syscall::Handle engine, struct CertContext* leaf, struct Filetime* time, golang::syscall::Handle additionalStore, struct CertChainPara* para, uint32_t flags, uintptr_t reserved, struct CertChainContext** chainCtx)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_57, e1] = Syscall9(rec::Addr(gocpp::recv(procCertGetCertificateChain)), 8, uintptr_t(engine), uintptr_t(unsafe::Pointer(leaf)), uintptr_t(unsafe::Pointer(time)), uintptr_t(additionalStore), uintptr_t(unsafe::Pointer(para)), uintptr_t(flags), uintptr_t(reserved), uintptr_t(unsafe::Pointer(chainCtx)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> CertOpenStore(uintptr_t storeProvider, uint32_t msgAndCertEncodingType, uintptr_t cryptProv, uint32_t flags, uintptr_t para)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_59, e1] = Syscall6(rec::Addr(gocpp::recv(procCertOpenStore)), 5, uintptr_t(storeProvider), uintptr_t(msgAndCertEncodingType), uintptr_t(cryptProv), uintptr_t(flags), uintptr_t(para), 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> CertOpenSystemStore(golang::syscall::Handle hprov, uint16_t* name)
    {
        syscall::Handle store;
        struct gocpp::error err;
        auto [r0, gocpp_id_61, e1] = Syscall(rec::Addr(gocpp::recv(procCertOpenSystemStoreW)), 2, uintptr_t(hprov), uintptr_t(unsafe::Pointer(name)), 0);
        store = Handle(r0);
        if(store == 0)
        {
            err = errnoErr(e1);
        }
        return {store, err};
    }

    struct gocpp::error CertVerifyCertificateChainPolicy(uintptr_t policyOID, struct CertChainContext* chain, struct CertChainPolicyPara* para, struct CertChainPolicyStatus* status)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_63, e1] = Syscall6(rec::Addr(gocpp::recv(procCertVerifyCertificateChainPolicy)), 4, uintptr_t(policyOID), uintptr_t(unsafe::Pointer(chain)), uintptr_t(unsafe::Pointer(para)), uintptr_t(unsafe::Pointer(status)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    bool DnsNameCompare(uint16_t* name1, uint16_t* name2)
    {
        bool same;
        auto [r0, gocpp_id_66, gocpp_id_67] = Syscall(rec::Addr(gocpp::recv(procDnsNameCompare_W)), 2, uintptr_t(unsafe::Pointer(name1)), uintptr_t(unsafe::Pointer(name2)), 0);
        same = r0 != 0;
        return same;
    }

    struct gocpp::error DnsQuery(std::string name, uint16_t qtype, uint32_t options, unsigned char* extra, struct DNSRecord** qrs, unsigned char* pr)
    {
        struct gocpp::error status;
        uint16_t* _p0 = {};
        std::tie(_p0, status) = UTF16PtrFromString(name);
        if(status != nullptr)
        {
            return status;
        }
        return _DnsQuery(_p0, qtype, options, extra, qrs, pr);
    }

    struct gocpp::error _DnsQuery(uint16_t* name, uint16_t qtype, uint32_t options, unsigned char* extra, struct DNSRecord** qrs, unsigned char* pr)
    {
        struct gocpp::error status;
        auto [r0, gocpp_id_70, gocpp_id_71] = Syscall6(rec::Addr(gocpp::recv(procDnsQuery_W)), 6, uintptr_t(unsafe::Pointer(name)), uintptr_t(qtype), uintptr_t(options), uintptr_t(unsafe::Pointer(extra)), uintptr_t(unsafe::Pointer(qrs)), uintptr_t(unsafe::Pointer(pr)));
        if(r0 != 0)
        {
            status = Errno(r0);
        }
        return status;
    }

    void DnsRecordListFree(struct DNSRecord* rl, uint32_t freetype)
    {
        Syscall(rec::Addr(gocpp::recv(procDnsRecordListFree)), 2, uintptr_t(unsafe::Pointer(rl)), uintptr_t(freetype), 0);
        return;
    }

    struct gocpp::error GetAdaptersInfo(struct IpAdapterInfo* ai, uint32_t* ol)
    {
        struct gocpp::error errcode;
        auto [r0, gocpp_id_74, gocpp_id_75] = Syscall(rec::Addr(gocpp::recv(procGetAdaptersInfo)), 2, uintptr_t(unsafe::Pointer(ai)), uintptr_t(unsafe::Pointer(ol)), 0);
        if(r0 != 0)
        {
            errcode = Errno(r0);
        }
        return errcode;
    }

    struct gocpp::error GetIfEntry(struct MibIfRow* pIfRow)
    {
        struct gocpp::error errcode;
        auto [r0, gocpp_id_78, gocpp_id_79] = Syscall(rec::Addr(gocpp::recv(procGetIfEntry)), 1, uintptr_t(unsafe::Pointer(pIfRow)), 0, 0);
        if(r0 != 0)
        {
            errcode = Errno(r0);
        }
        return errcode;
    }

    struct gocpp::error CancelIo(golang::syscall::Handle s)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_81, e1] = Syscall(rec::Addr(gocpp::recv(procCancelIo)), 1, uintptr_t(s), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CancelIoEx(golang::syscall::Handle s, struct Overlapped* o)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_83, e1] = Syscall(rec::Addr(gocpp::recv(procCancelIoEx)), 2, uintptr_t(s), uintptr_t(unsafe::Pointer(o)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CloseHandle(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_85, e1] = Syscall(rec::Addr(gocpp::recv(procCloseHandle)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateDirectory(uint16_t* path, struct SecurityAttributes* sa)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_87, e1] = Syscall(rec::Addr(gocpp::recv(procCreateDirectoryW)), 2, uintptr_t(unsafe::Pointer(path)), uintptr_t(unsafe::Pointer(sa)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> CreateFileMapping(golang::syscall::Handle fhandle, struct SecurityAttributes* sa, uint32_t prot, uint32_t maxSizeHigh, uint32_t maxSizeLow, uint16_t* name)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_89, e1] = Syscall6(rec::Addr(gocpp::recv(procCreateFileMappingW)), 6, uintptr_t(fhandle), uintptr_t(unsafe::Pointer(sa)), uintptr_t(prot), uintptr_t(maxSizeHigh), uintptr_t(maxSizeLow), uintptr_t(unsafe::Pointer(name)));
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> CreateFile(uint16_t* name, uint32_t access, uint32_t mode, struct SecurityAttributes* sa, uint32_t createmode, uint32_t attrs, int32_t templatefile)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_91, e1] = Syscall9(rec::Addr(gocpp::recv(procCreateFileW)), 7, uintptr_t(unsafe::Pointer(name)), uintptr_t(access), uintptr_t(mode), uintptr_t(unsafe::Pointer(sa)), uintptr_t(createmode), uintptr_t(attrs), uintptr_t(templatefile), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error CreateHardLink(uint16_t* filename, uint16_t* existingfilename, uintptr_t reserved)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_93, e1] = Syscall(rec::Addr(gocpp::recv(procCreateHardLinkW)), 3, uintptr_t(unsafe::Pointer(filename)), uintptr_t(unsafe::Pointer(existingfilename)), uintptr_t(reserved));
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> createIoCompletionPort(golang::syscall::Handle filehandle, golang::syscall::Handle cphandle, uintptr_t key, uint32_t threadcnt)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_95, e1] = Syscall6(rec::Addr(gocpp::recv(procCreateIoCompletionPort)), 4, uintptr_t(filehandle), uintptr_t(cphandle), uintptr_t(key), uintptr_t(threadcnt), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error CreatePipe(golang::syscall::Handle* readhandle, golang::syscall::Handle* writehandle, struct SecurityAttributes* sa, uint32_t size)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_97, e1] = Syscall6(rec::Addr(gocpp::recv(procCreatePipe)), 4, uintptr_t(unsafe::Pointer(readhandle)), uintptr_t(unsafe::Pointer(writehandle)), uintptr_t(unsafe::Pointer(sa)), uintptr_t(size), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateProcess(uint16_t* appName, uint16_t* commandLine, struct SecurityAttributes* procSecurity, struct SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, struct StartupInfo* startupInfo, struct ProcessInformation* outProcInfo)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_99, e1] = Syscall12(rec::Addr(gocpp::recv(procCreateProcessW)), 10, uintptr_t(unsafe::Pointer(appName)), uintptr_t(unsafe::Pointer(commandLine)), uintptr_t(unsafe::Pointer(procSecurity)), uintptr_t(unsafe::Pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(unsafe::Pointer(env)), uintptr_t(unsafe::Pointer(currentDir)), uintptr_t(unsafe::Pointer(startupInfo)), uintptr_t(unsafe::Pointer(outProcInfo)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateSymbolicLink(uint16_t* symlinkfilename, uint16_t* targetfilename, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_101, e1] = Syscall(rec::Addr(gocpp::recv(procCreateSymbolicLinkW)), 3, uintptr_t(unsafe::Pointer(symlinkfilename)), uintptr_t(unsafe::Pointer(targetfilename)), uintptr_t(flags));
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> CreateToolhelp32Snapshot(uint32_t flags, uint32_t processId)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_103, e1] = Syscall(rec::Addr(gocpp::recv(procCreateToolhelp32Snapshot)), 2, uintptr_t(flags), uintptr_t(processId), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error DeleteFile(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_105, e1] = Syscall(rec::Addr(gocpp::recv(procDeleteFileW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void deleteProcThreadAttributeList(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist)
    {
        Syscall(rec::Addr(gocpp::recv(procDeleteProcThreadAttributeList)), 1, uintptr_t(unsafe::Pointer(attrlist)), 0, 0);
        return;
    }

    struct gocpp::error DeviceIoControl(golang::syscall::Handle handle, uint32_t ioControlCode, unsigned char* inBuffer, uint32_t inBufferSize, unsigned char* outBuffer, uint32_t outBufferSize, uint32_t* bytesReturned, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_107, e1] = Syscall9(rec::Addr(gocpp::recv(procDeviceIoControl)), 8, uintptr_t(handle), uintptr_t(ioControlCode), uintptr_t(unsafe::Pointer(inBuffer)), uintptr_t(inBufferSize), uintptr_t(unsafe::Pointer(outBuffer)), uintptr_t(outBufferSize), uintptr_t(unsafe::Pointer(bytesReturned)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error DuplicateHandle(golang::syscall::Handle hSourceProcessHandle, golang::syscall::Handle hSourceHandle, golang::syscall::Handle hTargetProcessHandle, golang::syscall::Handle* lpTargetHandle, uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwOptions)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(bInheritHandle)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_109, e1] = Syscall9(rec::Addr(gocpp::recv(procDuplicateHandle)), 7, uintptr_t(hSourceProcessHandle), uintptr_t(hSourceHandle), uintptr_t(hTargetProcessHandle), uintptr_t(unsafe::Pointer(lpTargetHandle)), uintptr_t(dwDesiredAccess), uintptr_t(_p0), uintptr_t(dwOptions), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void ExitProcess(uint32_t exitcode)
    {
        Syscall(rec::Addr(gocpp::recv(procExitProcess)), 1, uintptr_t(exitcode), 0, 0);
        return;
    }

    struct gocpp::error FindClose(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_111, e1] = Syscall(rec::Addr(gocpp::recv(procFindClose)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> findFirstFile1(uint16_t* name, struct win32finddata1* data)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_113, e1] = Syscall(rec::Addr(gocpp::recv(procFindFirstFileW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(data)), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error findNextFile1(golang::syscall::Handle handle, struct win32finddata1* data)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_115, e1] = Syscall(rec::Addr(gocpp::recv(procFindNextFileW)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(data)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FlushFileBuffers(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_117, e1] = Syscall(rec::Addr(gocpp::recv(procFlushFileBuffers)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FlushViewOfFile(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_119, e1] = Syscall(rec::Addr(gocpp::recv(procFlushViewOfFile)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> formatMessage(uint32_t flags, uintptr_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args)
    {
        uint32_t n;
        struct gocpp::error err;
        uint16_t* _p0 = {};
        if(len(buf) > 0)
        {
            _p0 = & buf[0];
        }
        auto [r0, gocpp_id_121, e1] = Syscall9(rec::Addr(gocpp::recv(procFormatMessageW)), 7, uintptr_t(flags), uintptr_t(msgsrc), uintptr_t(msgid), uintptr_t(langid), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(args)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error FreeEnvironmentStrings(uint16_t* envs)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_123, e1] = Syscall(rec::Addr(gocpp::recv(procFreeEnvironmentStringsW)), 1, uintptr_t(unsafe::Pointer(envs)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FreeLibrary(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_125, e1] = Syscall(rec::Addr(gocpp::recv(procFreeLibrary)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t* GetCommandLine()
    {
        uint16_t* cmd;
        auto [r0, gocpp_id_128, gocpp_id_129] = Syscall(rec::Addr(gocpp::recv(procGetCommandLineW)), 0, 0, 0, 0);
        cmd = (uint16_t*)(unsafe::Pointer(r0));
        return cmd;
    }

    struct gocpp::error GetComputerName(uint16_t* buf, uint32_t* n)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_131, e1] = Syscall(rec::Addr(gocpp::recv(procGetComputerNameW)), 2, uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(n)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error GetConsoleMode(golang::syscall::Handle console, uint32_t* mode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_133, e1] = Syscall(rec::Addr(gocpp::recv(procGetConsoleMode)), 2, uintptr_t(console), uintptr_t(unsafe::Pointer(mode)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetCurrentDirectory(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_135, e1] = Syscall(rec::Addr(gocpp::recv(procGetCurrentDirectoryW)), 2, uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> GetCurrentProcess()
    {
        syscall::Handle pseudoHandle;
        struct gocpp::error err;
        auto [r0, gocpp_id_137, e1] = Syscall(rec::Addr(gocpp::recv(procGetCurrentProcess)), 0, 0, 0, 0);
        pseudoHandle = Handle(r0);
        if(pseudoHandle == 0)
        {
            err = errnoErr(e1);
        }
        return {pseudoHandle, err};
    }

    uint32_t getCurrentProcessId()
    {
        uint32_t pid;
        auto [r0, gocpp_id_140, gocpp_id_141] = Syscall(rec::Addr(gocpp::recv(procGetCurrentProcessId)), 0, 0, 0, 0);
        pid = uint32_t(r0);
        return pid;
    }

    std::tuple<uint16_t*, struct gocpp::error> GetEnvironmentStrings()
    {
        uint16_t* envs;
        struct gocpp::error err;
        auto [r0, gocpp_id_143, e1] = Syscall(rec::Addr(gocpp::recv(procGetEnvironmentStringsW)), 0, 0, 0, 0);
        envs = (uint16_t*)(unsafe::Pointer(r0));
        if(envs == nullptr)
        {
            err = errnoErr(e1);
        }
        return {envs, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetEnvironmentVariable(uint16_t* name, uint16_t* buffer, uint32_t size)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_145, e1] = Syscall(rec::Addr(gocpp::recv(procGetEnvironmentVariableW)), 3, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(buffer)), uintptr_t(size));
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error GetExitCodeProcess(golang::syscall::Handle handle, uint32_t* exitcode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_147, e1] = Syscall(rec::Addr(gocpp::recv(procGetExitCodeProcess)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(exitcode)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error GetFileAttributesEx(uint16_t* name, uint32_t level, unsigned char* info)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_149, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileAttributesExW)), 3, uintptr_t(unsafe::Pointer(name)), uintptr_t(level), uintptr_t(unsafe::Pointer(info)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileAttributes(uint16_t* name)
    {
        uint32_t attrs;
        struct gocpp::error err;
        auto [r0, gocpp_id_151, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileAttributesW)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        attrs = uint32_t(r0);
        if(attrs == INVALID_FILE_ATTRIBUTES)
        {
            err = errnoErr(e1);
        }
        return {attrs, err};
    }

    struct gocpp::error GetFileInformationByHandle(golang::syscall::Handle handle, struct ByHandleFileInformation* data)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_153, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileInformationByHandle)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(data)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileType(golang::syscall::Handle filehandle)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_155, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileType)), 1, uintptr_t(filehandle), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> getFinalPathNameByHandle(golang::syscall::Handle file, uint16_t* filePath, uint32_t filePathSize, uint32_t flags)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_157, e1] = Syscall6(rec::Addr(gocpp::recv(procGetFinalPathNameByHandleW)), 4, uintptr_t(file), uintptr_t(unsafe::Pointer(filePath)), uintptr_t(filePathSize), uintptr_t(flags), 0, 0);
        n = uint32_t(r0);
        if(n == 0 || n >= filePathSize)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetFullPathName(uint16_t* path, uint32_t buflen, uint16_t* buf, uint16_t** fname)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_159, e1] = Syscall6(rec::Addr(gocpp::recv(procGetFullPathNameW)), 4, uintptr_t(unsafe::Pointer(path)), uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(fname)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error GetLastError()
    {
        struct gocpp::error lasterr;
        auto [r0, gocpp_id_162, gocpp_id_163] = Syscall(rec::Addr(gocpp::recv(procGetLastError)), 0, 0, 0, 0);
        if(r0 != 0)
        {
            lasterr = Errno(r0);
        }
        return lasterr;
    }

    std::tuple<uint32_t, struct gocpp::error> GetLongPathName(uint16_t* path, uint16_t* buf, uint32_t buflen)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_165, e1] = Syscall(rec::Addr(gocpp::recv(procGetLongPathNameW)), 3, uintptr_t(unsafe::Pointer(path)), uintptr_t(unsafe::Pointer(buf)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uintptr_t, struct gocpp::error> GetProcAddress(golang::syscall::Handle module, std::string procname)
    {
        uintptr_t proc;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(procname);
        if(err != nullptr)
        {
            return {proc, err};
        }
        return _GetProcAddress(module, _p0);
    }

    std::tuple<uintptr_t, struct gocpp::error> _GetProcAddress(golang::syscall::Handle module, unsigned char* procname)
    {
        uintptr_t proc;
        struct gocpp::error err;
        auto [r0, gocpp_id_167, e1] = Syscall(rec::Addr(gocpp::recv(procGetProcAddress)), 2, uintptr_t(module), uintptr_t(unsafe::Pointer(procname)), 0);
        proc = uintptr_t(r0);
        if(proc == 0)
        {
            err = errnoErr(e1);
        }
        return {proc, err};
    }

    struct gocpp::error GetProcessTimes(golang::syscall::Handle handle, struct Filetime* creationTime, struct Filetime* exitTime, struct Filetime* kernelTime, struct Filetime* userTime)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_169, e1] = Syscall6(rec::Addr(gocpp::recv(procGetProcessTimes)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(creationTime)), uintptr_t(unsafe::Pointer(exitTime)), uintptr_t(unsafe::Pointer(kernelTime)), uintptr_t(unsafe::Pointer(userTime)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error getQueuedCompletionStatus(golang::syscall::Handle cphandle, uint32_t* qty, uintptr_t* key, struct Overlapped** overlapped, uint32_t timeout)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_171, e1] = Syscall6(rec::Addr(gocpp::recv(procGetQueuedCompletionStatus)), 5, uintptr_t(cphandle), uintptr_t(unsafe::Pointer(qty)), uintptr_t(unsafe::Pointer(key)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(timeout), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetShortPathName(uint16_t* longpath, uint16_t* shortpath, uint32_t buflen)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_173, e1] = Syscall(rec::Addr(gocpp::recv(procGetShortPathNameW)), 3, uintptr_t(unsafe::Pointer(longpath)), uintptr_t(unsafe::Pointer(shortpath)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    void getStartupInfo(struct StartupInfo* startupInfo)
    {
        Syscall(rec::Addr(gocpp::recv(procGetStartupInfoW)), 1, uintptr_t(unsafe::Pointer(startupInfo)), 0, 0);
        return;
    }

    std::tuple<syscall::Handle, struct gocpp::error> GetStdHandle(int stdhandle)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_175, e1] = Syscall(rec::Addr(gocpp::recv(procGetStdHandle)), 1, uintptr_t(stdhandle), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    void GetSystemTimeAsFileTime(struct Filetime* time)
    {
        Syscall(rec::Addr(gocpp::recv(procGetSystemTimeAsFileTime)), 1, uintptr_t(unsafe::Pointer(time)), 0, 0);
        return;
    }

    std::tuple<uint32_t, struct gocpp::error> GetTempPath(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_177, e1] = Syscall(rec::Addr(gocpp::recv(procGetTempPathW)), 2, uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetTimeZoneInformation(struct Timezoneinformation* tzi)
    {
        uint32_t rc;
        struct gocpp::error err;
        auto [r0, gocpp_id_179, e1] = Syscall(rec::Addr(gocpp::recv(procGetTimeZoneInformation)), 1, uintptr_t(unsafe::Pointer(tzi)), 0, 0);
        rc = uint32_t(r0);
        if(rc == 0xffffffff)
        {
            err = errnoErr(e1);
        }
        return {rc, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetVersion()
    {
        uint32_t ver;
        struct gocpp::error err;
        auto [r0, gocpp_id_181, e1] = Syscall(rec::Addr(gocpp::recv(procGetVersion)), 0, 0, 0, 0);
        ver = uint32_t(r0);
        if(ver == 0)
        {
            err = errnoErr(e1);
        }
        return {ver, err};
    }

    struct gocpp::error initializeProcThreadAttributeList(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t attrcount, uint32_t flags, uintptr_t* size)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_183, e1] = Syscall6(rec::Addr(gocpp::recv(procInitializeProcThreadAttributeList)), 4, uintptr_t(unsafe::Pointer(attrlist)), uintptr_t(attrcount), uintptr_t(flags), uintptr_t(unsafe::Pointer(size)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> LoadLibrary(std::string libname)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        uint16_t* _p0 = {};
        std::tie(_p0, err) = UTF16PtrFromString(libname);
        if(err != nullptr)
        {
            return {handle, err};
        }
        return _LoadLibrary(_p0);
    }

    std::tuple<syscall::Handle, struct gocpp::error> _LoadLibrary(uint16_t* libname)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_185, e1] = Syscall(rec::Addr(gocpp::recv(procLoadLibraryW)), 1, uintptr_t(unsafe::Pointer(libname)), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> LocalFree(golang::syscall::Handle hmem)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_187, e1] = Syscall(rec::Addr(gocpp::recv(procLocalFree)), 1, uintptr_t(hmem), 0, 0);
        handle = Handle(r0);
        if(handle != 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<uintptr_t, struct gocpp::error> MapViewOfFile(golang::syscall::Handle handle, uint32_t access, uint32_t offsetHigh, uint32_t offsetLow, uintptr_t length)
    {
        uintptr_t addr;
        struct gocpp::error err;
        auto [r0, gocpp_id_189, e1] = Syscall6(rec::Addr(gocpp::recv(procMapViewOfFile)), 5, uintptr_t(handle), uintptr_t(access), uintptr_t(offsetHigh), uintptr_t(offsetLow), uintptr_t(length), 0);
        addr = uintptr_t(r0);
        if(addr == 0)
        {
            err = errnoErr(e1);
        }
        return {addr, err};
    }

    struct gocpp::error MoveFile(uint16_t* from, uint16_t* to)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_191, e1] = Syscall(rec::Addr(gocpp::recv(procMoveFileW)), 2, uintptr_t(unsafe::Pointer(from)), uintptr_t(unsafe::Pointer(to)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> OpenProcess(uint32_t da, bool inheritHandle, uint32_t pid)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandle)
        {
            _p0 = 1;
        }
        auto [r0, gocpp_id_193, e1] = Syscall(rec::Addr(gocpp::recv(procOpenProcess)), 3, uintptr_t(da), uintptr_t(_p0), uintptr_t(pid));
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error postQueuedCompletionStatus(golang::syscall::Handle cphandle, uint32_t qty, uintptr_t key, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_195, e1] = Syscall6(rec::Addr(gocpp::recv(procPostQueuedCompletionStatus)), 4, uintptr_t(cphandle), uintptr_t(qty), uintptr_t(key), uintptr_t(unsafe::Pointer(overlapped)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Process32First(golang::syscall::Handle snapshot, struct ProcessEntry32* procEntry)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_197, e1] = Syscall(rec::Addr(gocpp::recv(procProcess32FirstW)), 2, uintptr_t(snapshot), uintptr_t(unsafe::Pointer(procEntry)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Process32Next(golang::syscall::Handle snapshot, struct ProcessEntry32* procEntry)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_199, e1] = Syscall(rec::Addr(gocpp::recv(procProcess32NextW)), 2, uintptr_t(snapshot), uintptr_t(unsafe::Pointer(procEntry)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ReadConsole(golang::syscall::Handle console, uint16_t* buf, uint32_t toread, uint32_t* read, unsigned char* inputControl)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_201, e1] = Syscall6(rec::Addr(gocpp::recv(procReadConsoleW)), 5, uintptr_t(console), uintptr_t(unsafe::Pointer(buf)), uintptr_t(toread), uintptr_t(unsafe::Pointer(read)), uintptr_t(unsafe::Pointer(inputControl)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ReadDirectoryChanges(golang::syscall::Handle handle, unsigned char* buf, uint32_t buflen, bool watchSubTree, uint32_t mask, uint32_t* retlen, struct Overlapped* overlapped, uintptr_t completionRoutine)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(watchSubTree)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_203, e1] = Syscall9(rec::Addr(gocpp::recv(procReadDirectoryChangesW)), 8, uintptr_t(handle), uintptr_t(unsafe::Pointer(buf)), uintptr_t(buflen), uintptr_t(_p0), uintptr_t(mask), uintptr_t(unsafe::Pointer(retlen)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(completionRoutine), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error readFile(golang::syscall::Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            _p0 = & buf[0];
        }
        auto [r1, gocpp_id_205, e1] = Syscall6(rec::Addr(gocpp::recv(procReadFile)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(done)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error RemoveDirectory(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_207, e1] = Syscall(rec::Addr(gocpp::recv(procRemoveDirectoryW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetCurrentDirectory(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_209, e1] = Syscall(rec::Addr(gocpp::recv(procSetCurrentDirectoryW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetEndOfFile(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_211, e1] = Syscall(rec::Addr(gocpp::recv(procSetEndOfFile)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetEnvironmentVariable(uint16_t* name, uint16_t* value)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_213, e1] = Syscall(rec::Addr(gocpp::recv(procSetEnvironmentVariableW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(value)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetFileAttributes(uint16_t* name, uint32_t attrs)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_215, e1] = Syscall(rec::Addr(gocpp::recv(procSetFileAttributesW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(attrs), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetFileCompletionNotificationModes(golang::syscall::Handle handle, uint8_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_217, e1] = Syscall(rec::Addr(gocpp::recv(procSetFileCompletionNotificationModes)), 2, uintptr_t(handle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> SetFilePointer(golang::syscall::Handle handle, int32_t lowoffset, int32_t* highoffsetptr, uint32_t whence)
    {
        uint32_t newlowoffset;
        struct gocpp::error err;
        auto [r0, gocpp_id_219, e1] = Syscall6(rec::Addr(gocpp::recv(procSetFilePointer)), 4, uintptr_t(handle), uintptr_t(lowoffset), uintptr_t(unsafe::Pointer(highoffsetptr)), uintptr_t(whence), 0, 0);
        newlowoffset = uint32_t(r0);
        if(newlowoffset == 0xffffffff)
        {
            err = errnoErr(e1);
        }
        return {newlowoffset, err};
    }

    struct gocpp::error SetFileTime(golang::syscall::Handle handle, struct Filetime* ctime, struct Filetime* atime, struct Filetime* wtime)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_221, e1] = Syscall6(rec::Addr(gocpp::recv(procSetFileTime)), 4, uintptr_t(handle), uintptr_t(unsafe::Pointer(ctime)), uintptr_t(unsafe::Pointer(atime)), uintptr_t(unsafe::Pointer(wtime)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetHandleInformation(golang::syscall::Handle handle, uint32_t mask, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_223, e1] = Syscall(rec::Addr(gocpp::recv(procSetHandleInformation)), 3, uintptr_t(handle), uintptr_t(mask), uintptr_t(flags));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error TerminateProcess(golang::syscall::Handle handle, uint32_t exitcode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_225, e1] = Syscall(rec::Addr(gocpp::recv(procTerminateProcess)), 2, uintptr_t(handle), uintptr_t(exitcode), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error UnmapViewOfFile(uintptr_t addr)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_227, e1] = Syscall(rec::Addr(gocpp::recv(procUnmapViewOfFile)), 1, uintptr_t(addr), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error updateProcThreadAttribute(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t flags, uintptr_t attr, unsafe::Pointer value, uintptr_t size, unsafe::Pointer prevvalue, uintptr_t* returnedsize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_229, e1] = Syscall9(rec::Addr(gocpp::recv(procUpdateProcThreadAttribute)), 7, uintptr_t(unsafe::Pointer(attrlist)), uintptr_t(flags), uintptr_t(attr), uintptr_t(value), uintptr_t(size), uintptr_t(prevvalue), uintptr_t(unsafe::Pointer(returnedsize)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error VirtualLock(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_231, e1] = Syscall(rec::Addr(gocpp::recv(procVirtualLock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error VirtualUnlock(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_233, e1] = Syscall(rec::Addr(gocpp::recv(procVirtualUnlock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> WaitForSingleObject(golang::syscall::Handle handle, uint32_t waitMilliseconds)
    {
        uint32_t event;
        struct gocpp::error err;
        auto [r0, gocpp_id_235, e1] = Syscall(rec::Addr(gocpp::recv(procWaitForSingleObject)), 2, uintptr_t(handle), uintptr_t(waitMilliseconds), 0);
        event = uint32_t(r0);
        if(event == 0xffffffff)
        {
            err = errnoErr(e1);
        }
        return {event, err};
    }

    struct gocpp::error WriteConsole(golang::syscall::Handle console, uint16_t* buf, uint32_t towrite, uint32_t* written, unsigned char* reserved)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_237, e1] = Syscall6(rec::Addr(gocpp::recv(procWriteConsoleW)), 5, uintptr_t(console), uintptr_t(unsafe::Pointer(buf)), uintptr_t(towrite), uintptr_t(unsafe::Pointer(written)), uintptr_t(unsafe::Pointer(reserved)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error writeFile(golang::syscall::Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            _p0 = & buf[0];
        }
        auto [r1, gocpp_id_239, e1] = Syscall6(rec::Addr(gocpp::recv(procWriteFile)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(done)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error AcceptEx(golang::syscall::Handle ls, golang::syscall::Handle as, unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, uint32_t* recvd, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_241, e1] = Syscall9(rec::Addr(gocpp::recv(procAcceptEx)), 8, uintptr_t(ls), uintptr_t(as), uintptr_t(unsafe::Pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void GetAcceptExSockaddrs(unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, struct RawSockaddrAny** lrsa, int32_t* lrsalen, struct RawSockaddrAny** rrsa, int32_t* rrsalen)
    {
        Syscall9(rec::Addr(gocpp::recv(procGetAcceptExSockaddrs)), 8, uintptr_t(unsafe::Pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(unsafe::Pointer(lrsa)), uintptr_t(unsafe::Pointer(lrsalen)), uintptr_t(unsafe::Pointer(rrsa)), uintptr_t(unsafe::Pointer(rrsalen)), 0);
        return;
    }

    struct gocpp::error TransmitFile(golang::syscall::Handle s, golang::syscall::Handle handle, uint32_t bytesToWrite, uint32_t bytsPerSend, struct Overlapped* overlapped, struct TransmitFileBuffers* transmitFileBuf, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_243, e1] = Syscall9(rec::Addr(gocpp::recv(procTransmitFile)), 7, uintptr_t(s), uintptr_t(handle), uintptr_t(bytesToWrite), uintptr_t(bytsPerSend), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(transmitFileBuf)), uintptr_t(flags), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error NetApiBufferFree(unsigned char* buf)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_246, gocpp_id_247] = Syscall(rec::Addr(gocpp::recv(procNetApiBufferFree)), 1, uintptr_t(unsafe::Pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            neterr = Errno(r0);
        }
        return neterr;
    }

    struct gocpp::error NetGetJoinInformation(uint16_t* server, uint16_t** name, uint32_t* bufType)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_250, gocpp_id_251] = Syscall(rec::Addr(gocpp::recv(procNetGetJoinInformation)), 3, uintptr_t(unsafe::Pointer(server)), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(bufType)));
        if(r0 != 0)
        {
            neterr = Errno(r0);
        }
        return neterr;
    }

    struct gocpp::error NetUserGetInfo(uint16_t* serverName, uint16_t* userName, uint32_t level, unsigned char** buf)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_254, gocpp_id_255] = Syscall6(rec::Addr(gocpp::recv(procNetUserGetInfo)), 4, uintptr_t(unsafe::Pointer(serverName)), uintptr_t(unsafe::Pointer(userName)), uintptr_t(level), uintptr_t(unsafe::Pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            neterr = Errno(r0);
        }
        return neterr;
    }

    void rtlGetNtVersionNumbers(uint32_t* majorVersion, uint32_t* minorVersion, uint32_t* buildNumber)
    {
        Syscall(rec::Addr(gocpp::recv(procRtlGetNtVersionNumbers)), 3, uintptr_t(unsafe::Pointer(majorVersion)), uintptr_t(unsafe::Pointer(minorVersion)), uintptr_t(unsafe::Pointer(buildNumber)));
        return;
    }

    struct gocpp::error GetUserNameEx(uint32_t nameFormat, uint16_t* nameBuffre, uint32_t* nSize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_257, e1] = Syscall(rec::Addr(gocpp::recv(procGetUserNameExW)), 3, uintptr_t(nameFormat), uintptr_t(unsafe::Pointer(nameBuffre)), uintptr_t(unsafe::Pointer(nSize)));
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error TranslateName(uint16_t* accName, uint32_t accNameFormat, uint32_t desiredNameFormat, uint16_t* translatedName, uint32_t* nSize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_259, e1] = Syscall6(rec::Addr(gocpp::recv(procTranslateNameW)), 5, uintptr_t(unsafe::Pointer(accName)), uintptr_t(accNameFormat), uintptr_t(desiredNameFormat), uintptr_t(unsafe::Pointer(translatedName)), uintptr_t(unsafe::Pointer(nSize)), 0);
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*, struct gocpp::error> CommandLineToArgv(uint16_t* cmd, int32_t* argc)
    {
        gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>* argv;
        struct gocpp::error err;
        auto [r0, gocpp_id_261, e1] = Syscall(rec::Addr(gocpp::recv(procCommandLineToArgvW)), 2, uintptr_t(unsafe::Pointer(cmd)), uintptr_t(unsafe::Pointer(argc)), 0);
        argv = (gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*)(unsafe::Pointer(r0));
        if(argv == nullptr)
        {
            err = errnoErr(e1);
        }
        return {argv, err};
    }

    struct gocpp::error GetUserProfileDirectory(golang::syscall::Token t, uint16_t* dir, uint32_t* dirLen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_263, e1] = Syscall(rec::Addr(gocpp::recv(procGetUserProfileDirectoryW)), 3, uintptr_t(t), uintptr_t(unsafe::Pointer(dir)), uintptr_t(unsafe::Pointer(dirLen)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void FreeAddrInfoW(struct AddrinfoW* addrinfo)
    {
        Syscall(rec::Addr(gocpp::recv(procFreeAddrInfoW)), 1, uintptr_t(unsafe::Pointer(addrinfo)), 0, 0);
        return;
    }

    struct gocpp::error GetAddrInfoW(uint16_t* nodename, uint16_t* servicename, struct AddrinfoW* hints, struct AddrinfoW** result)
    {
        struct gocpp::error sockerr;
        auto [r0, gocpp_id_266, gocpp_id_267] = Syscall6(rec::Addr(gocpp::recv(procGetAddrInfoW)), 4, uintptr_t(unsafe::Pointer(nodename)), uintptr_t(unsafe::Pointer(servicename)), uintptr_t(unsafe::Pointer(hints)), uintptr_t(unsafe::Pointer(result)), 0, 0);
        if(r0 != 0)
        {
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    struct gocpp::error WSACleanup()
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_269, e1] = Syscall(rec::Addr(gocpp::recv(procWSACleanup)), 0, 0, 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<int32_t, struct gocpp::error> WSAEnumProtocols(int32_t* protocols, struct WSAProtocolInfo* protocolBuffer, uint32_t* bufferLength)
    {
        int32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_271, e1] = Syscall(rec::Addr(gocpp::recv(procWSAEnumProtocolsW)), 3, uintptr_t(unsafe::Pointer(protocols)), uintptr_t(unsafe::Pointer(protocolBuffer)), uintptr_t(unsafe::Pointer(bufferLength)));
        n = int32_t(r0);
        if(n == - 1)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error WSAIoctl(golang::syscall::Handle s, uint32_t iocc, unsigned char* inbuf, uint32_t cbif, unsigned char* outbuf, uint32_t cbob, uint32_t* cbbr, struct Overlapped* overlapped, uintptr_t completionRoutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_273, e1] = Syscall9(rec::Addr(gocpp::recv(procWSAIoctl)), 9, uintptr_t(s), uintptr_t(iocc), uintptr_t(unsafe::Pointer(inbuf)), uintptr_t(cbif), uintptr_t(unsafe::Pointer(outbuf)), uintptr_t(cbob), uintptr_t(unsafe::Pointer(cbbr)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(completionRoutine));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSARecv(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_275, e1] = Syscall9(rec::Addr(gocpp::recv(procWSARecv)), 7, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(flags)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSARecvFrom(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, struct RawSockaddrAny* from, int32_t* fromlen, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_277, e1] = Syscall9(rec::Addr(gocpp::recv(procWSARecvFrom)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(flags)), uintptr_t(unsafe::Pointer(from)), uintptr_t(unsafe::Pointer(fromlen)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSASend(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_279, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASend)), 7, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSASendTo(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct RawSockaddrAny* to, int32_t tolen, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_281, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(to)), uintptr_t(tolen), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSAStartup(uint32_t verreq, struct WSAData* data)
    {
        struct gocpp::error sockerr;
        auto [r0, gocpp_id_284, gocpp_id_285] = Syscall(rec::Addr(gocpp::recv(procWSAStartup)), 2, uintptr_t(verreq), uintptr_t(unsafe::Pointer(data)), 0);
        if(r0 != 0)
        {
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    struct gocpp::error bind(golang::syscall::Handle s, unsafe::Pointer name, int32_t namelen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_287, e1] = Syscall(rec::Addr(gocpp::recv(procbind)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Closesocket(golang::syscall::Handle s)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_289, e1] = Syscall(rec::Addr(gocpp::recv(procclosesocket)), 1, uintptr_t(s), 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error connect(golang::syscall::Handle s, unsafe::Pointer name, int32_t namelen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_291, e1] = Syscall(rec::Addr(gocpp::recv(procconnect)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct Hostent*, struct gocpp::error> GetHostByName(std::string name)
    {
        struct Hostent* h;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {h, err};
        }
        return _GetHostByName(_p0);
    }

    std::tuple<struct Hostent*, struct gocpp::error> _GetHostByName(unsigned char* name)
    {
        struct Hostent* h;
        struct gocpp::error err;
        auto [r0, gocpp_id_293, e1] = Syscall(rec::Addr(gocpp::recv(procgethostbyname)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        h = (Hostent*)(unsafe::Pointer(r0));
        if(h == nullptr)
        {
            err = errnoErr(e1);
        }
        return {h, err};
    }

    struct gocpp::error getpeername(golang::syscall::Handle s, struct RawSockaddrAny* rsa, int32_t* addrlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_295, e1] = Syscall(rec::Addr(gocpp::recv(procgetpeername)), 3, uintptr_t(s), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(unsafe::Pointer(addrlen)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct Protoent*, struct gocpp::error> GetProtoByName(std::string name)
    {
        struct Protoent* p;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {p, err};
        }
        return _GetProtoByName(_p0);
    }

    std::tuple<struct Protoent*, struct gocpp::error> _GetProtoByName(unsigned char* name)
    {
        struct Protoent* p;
        struct gocpp::error err;
        auto [r0, gocpp_id_297, e1] = Syscall(rec::Addr(gocpp::recv(procgetprotobyname)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        p = (Protoent*)(unsafe::Pointer(r0));
        if(p == nullptr)
        {
            err = errnoErr(e1);
        }
        return {p, err};
    }

    std::tuple<struct Servent*, struct gocpp::error> GetServByName(std::string name, std::string proto)
    {
        struct Servent* s;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {s, err};
        }
        unsigned char* _p1 = {};
        std::tie(_p1, err) = BytePtrFromString(proto);
        if(err != nullptr)
        {
            return {s, err};
        }
        return _GetServByName(_p0, _p1);
    }

    std::tuple<struct Servent*, struct gocpp::error> _GetServByName(unsigned char* name, unsigned char* proto)
    {
        struct Servent* s;
        struct gocpp::error err;
        auto [r0, gocpp_id_299, e1] = Syscall(rec::Addr(gocpp::recv(procgetservbyname)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(proto)), 0);
        s = (Servent*)(unsafe::Pointer(r0));
        if(s == nullptr)
        {
            err = errnoErr(e1);
        }
        return {s, err};
    }

    struct gocpp::error getsockname(golang::syscall::Handle s, struct RawSockaddrAny* rsa, int32_t* addrlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_301, e1] = Syscall(rec::Addr(gocpp::recv(procgetsockname)), 3, uintptr_t(s), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(unsafe::Pointer(addrlen)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Getsockopt(golang::syscall::Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t* optlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_303, e1] = Syscall6(rec::Addr(gocpp::recv(procgetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(unsafe::Pointer(optval)), uintptr_t(unsafe::Pointer(optlen)), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error listen(golang::syscall::Handle s, int32_t backlog)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_305, e1] = Syscall(rec::Addr(gocpp::recv(proclisten)), 2, uintptr_t(s), uintptr_t(backlog), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t Ntohs(uint16_t netshort)
    {
        uint16_t u;
        auto [r0, gocpp_id_308, gocpp_id_309] = Syscall(rec::Addr(gocpp::recv(procntohs)), 1, uintptr_t(netshort), 0, 0);
        u = uint16_t(r0);
        return u;
    }

    struct gocpp::error Setsockopt(golang::syscall::Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t optlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_311, e1] = Syscall6(rec::Addr(gocpp::recv(procsetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(unsafe::Pointer(optval)), uintptr_t(optlen), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error shutdown(golang::syscall::Handle s, int32_t how)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_313, e1] = Syscall(rec::Addr(gocpp::recv(procshutdown)), 2, uintptr_t(s), uintptr_t(how), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> socket(int32_t af, int32_t typ, int32_t protocol)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_315, e1] = Syscall(rec::Addr(gocpp::recv(procsocket)), 3, uintptr_t(af), uintptr_t(typ), uintptr_t(protocol));
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

}

