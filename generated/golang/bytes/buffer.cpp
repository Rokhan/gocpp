// generated by GoCpp from file '$(ImportDir)/bytes/buffer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bytes/buffer.h"
#include "gocpp/support.h"

#include "golang/bytes/bytes.h"
#include "golang/errors/errors.h"
#include "golang/io/io.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::bytes
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Buffer::operator T()
    {
        T result;
        result.buf = this->buf;
        result.off = this->off;
        result.lastRead = this->lastRead;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Buffer::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (off != ref.off) return false;
        if (lastRead != ref.lastRead) return false;
        return true;
    }

    std::ostream& Buffer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << off;
        os << " " << lastRead;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Buffer& value)
    {
        return value.PrintTo(os);
    }

    gocpp::error ErrTooLarge = errors::New("bytes.Buffer: too large");
    gocpp::error errNegativeRead = errors::New("bytes.Buffer: reader returned negative count from Read");
    gocpp::slice<unsigned char> Bytes(struct Buffer* b)
    {
        return b->buf.make_slice(b->off);
    }

    gocpp::slice<unsigned char> AvailableBuffer(struct Buffer* b)
    {
        return b->buf.make_slice(len(b->buf));
    }

    std::string String(struct Buffer* b)
    {
        if(b == nullptr)
        {
            return "<nil>";
        }
        return string(b->buf.make_slice(b->off));
    }

    bool empty(struct Buffer* b)
    {
        return len(b->buf) <= b->off;
    }

    int Len(struct Buffer* b)
    {
        return len(b->buf) - b->off;
    }

    int Cap(struct Buffer* b)
    {
        return cap(b->buf);
    }

    int Available(struct Buffer* b)
    {
        return cap(b->buf) - len(b->buf);
    }

    void Truncate(struct Buffer* b, int n)
    {
        if(n == 0)
        {
            Reset(gocpp::recv(b));
            return;
        }
        b->lastRead = opInvalid;
        if(n < 0 || n > Len(gocpp::recv(b)))
        {
            gocpp::panic("bytes.Buffer: truncation out of range");
        }
        b->buf = b->buf.make_slice(0, b->off + n);
    }

    void Reset(struct Buffer* b)
    {
        b->buf = b->buf.make_slice(0, 0);
        b->off = 0;
        b->lastRead = opInvalid;
    }

    std::tuple<int, bool> tryGrowByReslice(struct Buffer* b, int n)
    {
        if(auto l = len(b->buf); n <= cap(b->buf) - l)
        {
            b->buf = b->buf.make_slice(0, l + n);
            return {l, true};
        }
        return {0, false};
    }

    int grow(struct Buffer* b, int n)
    {
        auto m = Len(gocpp::recv(b));
        if(m == 0 && b->off != 0)
        {
            Reset(gocpp::recv(b));
        }
        if(auto [i, ok] = tryGrowByReslice(gocpp::recv(b), n); ok)
        {
            return i;
        }
        if(b->buf == nullptr && n <= smallBufferSize)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n, smallBufferSize);
            return 0;
        }
        auto c = cap(b->buf);
        if(n <= c / 2 - m)
        {
            copy(b->buf, b->buf.make_slice(b->off));
        }
        else
        if(c > maxInt - c - n)
        {
            gocpp::panic(ErrTooLarge);
        }
        else
        {
            b->buf = growSlice(b->buf.make_slice(b->off), b->off + n);
        }
        b->off = 0;
        b->buf = b->buf.make_slice(0, m + n);
        return m;
    }

    void Grow(struct Buffer* b, int n)
    {
        if(n < 0)
        {
            gocpp::panic("bytes.Buffer.Grow: negative count");
        }
        auto m = grow(gocpp::recv(b), n);
        b->buf = b->buf.make_slice(0, m);
    }

    std::tuple<int, struct gocpp::error> Write(struct Buffer* b, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        auto [m, ok] = tryGrowByReslice(gocpp::recv(b), len(p));
        if(! ok)
        {
            int n;
            struct gocpp::error err;
            m = grow(gocpp::recv(b), len(p));
        }
        return {copy(b->buf.make_slice(m), p), nullptr};
    }

    std::tuple<int, struct gocpp::error> WriteString(struct Buffer* b, std::string s)
    {
        int n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        auto [m, ok] = tryGrowByReslice(gocpp::recv(b), len(s));
        if(! ok)
        {
            int n;
            struct gocpp::error err;
            m = grow(gocpp::recv(b), len(s));
        }
        return {copy(b->buf.make_slice(m), s), nullptr};
    }

    std::tuple<int64_t, struct gocpp::error> ReadFrom(struct Buffer* b, struct io::Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        for(; ; )
        {
            int64_t n;
            struct gocpp::error err;
            auto i = grow(gocpp::recv(b), MinRead);
            b->buf = b->buf.make_slice(0, i);
            auto [m, e] = Read(gocpp::recv(r), b->buf.make_slice(i, cap(b->buf)));
            if(m < 0)
            {
                int64_t n;
                struct gocpp::error err;
                gocpp::panic(errNegativeRead);
            }
            b->buf = b->buf.make_slice(0, i + m);
            n += int64_t(m);
            if(e == io::go_EOF)
            {
                int64_t n;
                struct gocpp::error err;
                return {n, nullptr};
            }
            if(e != nullptr)
            {
                int64_t n;
                struct gocpp::error err;
                return {n, e};
            }
        }
    }

    gocpp::slice<unsigned char> growSlice(gocpp::slice<unsigned char> b, int n)
    {
        gocpp::Defer defer;
        try
        {
            defer.push_back([=]{ [=]() mutable -> void
            {
                if(gocpp::recover() != nullptr)
                {
                    gocpp::panic(ErrTooLarge);
                }
            }(); });
            auto c = len(b) + n;
            if(c < 2 * cap(b))
            {
                c = 2 * cap(b);
            }
            auto b2 = append(gocpp::Tag<gocpp::slice<unsigned char>>()(nullptr), gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), c));
            copy(b2, b);
            return b2.make_slice(0, len(b));
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<int64_t, struct gocpp::error> WriteTo(struct Buffer* b, struct io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        if(auto nBytes = Len(gocpp::recv(b)); nBytes > 0)
        {
            int64_t n;
            struct gocpp::error err;
            auto [m, e] = Write(gocpp::recv(w), b->buf.make_slice(b->off));
            if(m > nBytes)
            {
                int64_t n;
                struct gocpp::error err;
                gocpp::panic("bytes.Buffer.WriteTo: invalid Write count");
            }
            b->off += m;
            n = int64_t(m);
            if(e != nullptr)
            {
                int64_t n;
                struct gocpp::error err;
                return {n, e};
            }
            if(m != nBytes)
            {
                int64_t n;
                struct gocpp::error err;
                return {n, io::ErrShortWrite};
            }
        }
        Reset(gocpp::recv(b));
        return {n, nullptr};
    }

    struct gocpp::error WriteByte(struct Buffer* b, unsigned char c)
    {
        b->lastRead = opInvalid;
        auto [m, ok] = tryGrowByReslice(gocpp::recv(b), 1);
        if(! ok)
        {
            m = grow(gocpp::recv(b), 1);
        }
        b->buf[m] = c;
        return nullptr;
    }

    std::tuple<int, struct gocpp::error> WriteRune(struct Buffer* b, gocpp::rune r)
    {
        int n;
        struct gocpp::error err;
        if(uint32_t(r) < utf8::RuneSelf)
        {
            int n;
            struct gocpp::error err;
            WriteByte(gocpp::recv(b), unsigned char(r));
            return {1, nullptr};
        }
        b->lastRead = opInvalid;
        auto [m, ok] = tryGrowByReslice(gocpp::recv(b), utf8::UTFMax);
        if(! ok)
        {
            int n;
            struct gocpp::error err;
            m = grow(gocpp::recv(b), utf8::UTFMax);
        }
        b->buf = utf8::AppendRune(b->buf.make_slice(0, m), r);
        return {len(b->buf) - m, nullptr};
    }

    std::tuple<int, struct gocpp::error> Read(struct Buffer* b, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        if(empty(gocpp::recv(b)))
        {
            int n;
            struct gocpp::error err;
            Reset(gocpp::recv(b));
            if(len(p) == 0)
            {
                int n;
                struct gocpp::error err;
                return {0, nullptr};
            }
            return {0, io::go_EOF};
        }
        n = copy(p, b->buf.make_slice(b->off));
        b->off += n;
        if(n > 0)
        {
            int n;
            struct gocpp::error err;
            b->lastRead = opRead;
        }
        return {n, nullptr};
    }

    gocpp::slice<unsigned char> Next(struct Buffer* b, int n)
    {
        b->lastRead = opInvalid;
        auto m = Len(gocpp::recv(b));
        if(n > m)
        {
            n = m;
        }
        auto data = b->buf.make_slice(b->off, b->off + n);
        b->off += n;
        if(n > 0)
        {
            b->lastRead = opRead;
        }
        return data;
    }

    std::tuple<unsigned char, struct gocpp::error> ReadByte(struct Buffer* b)
    {
        if(empty(gocpp::recv(b)))
        {
            Reset(gocpp::recv(b));
            return {0, io::go_EOF};
        }
        auto c = b->buf[b->off];
        b->off++;
        b->lastRead = opRead;
        return {c, nullptr};
    }

    std::tuple<gocpp::rune, int, struct gocpp::error> ReadRune(struct Buffer* b)
    {
        gocpp::rune r;
        int size;
        struct gocpp::error err;
        if(empty(gocpp::recv(b)))
        {
            gocpp::rune r;
            int size;
            struct gocpp::error err;
            Reset(gocpp::recv(b));
            return {0, 0, io::go_EOF};
        }
        auto c = b->buf[b->off];
        if(c < utf8::RuneSelf)
        {
            gocpp::rune r;
            int size;
            struct gocpp::error err;
            b->off++;
            b->lastRead = opReadRune1;
            return {rune(c), 1, nullptr};
        }
        auto [r, n] = utf8::DecodeRune(b->buf.make_slice(b->off));
        b->off += n;
        b->lastRead = readOp(n);
        return {r, n, nullptr};
    }

    struct gocpp::error UnreadRune(struct Buffer* b)
    {
        if(b->lastRead <= opInvalid)
        {
            return errors::New("bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune");
        }
        if(b->off >= int(b->lastRead))
        {
            b->off -= int(b->lastRead);
        }
        b->lastRead = opInvalid;
        return nullptr;
    }

    gocpp::error errUnreadByte = errors::New("bytes.Buffer: UnreadByte: previous operation was not a successful read");
    struct gocpp::error UnreadByte(struct Buffer* b)
    {
        if(b->lastRead == opInvalid)
        {
            return errUnreadByte;
        }
        b->lastRead = opInvalid;
        if(b->off > 0)
        {
            b->off--;
        }
        return nullptr;
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadBytes(struct Buffer* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        struct gocpp::error err;
        auto [slice, err] = readSlice(gocpp::recv(b), delim);
        line = append(line, slice);
        return {line, err};
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> readSlice(struct Buffer* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        struct gocpp::error err;
        auto i = IndexByte(b->buf.make_slice(b->off), delim);
        auto end = b->off + i + 1;
        if(i < 0)
        {
            gocpp::slice<unsigned char> line;
            struct gocpp::error err;
            end = len(b->buf);
            err = io::go_EOF;
        }
        line = b->buf.make_slice(b->off, end);
        b->off = end;
        b->lastRead = opRead;
        return {line, err};
    }

    std::tuple<std::string, struct gocpp::error> ReadString(struct Buffer* b, unsigned char delim)
    {
        std::string line;
        struct gocpp::error err;
        auto [slice, err] = readSlice(gocpp::recv(b), delim);
        return {string(slice), err};
    }

    struct Buffer* NewBuffer(gocpp::slice<unsigned char> buf)
    {
        return gocpp::InitPtr<Buffer>([](Buffer& x) { x.buf = buf; });
    }

    struct Buffer* NewBufferString(std::string s)
    {
        return gocpp::InitPtr<Buffer>([](Buffer& x) { x.buf = gocpp::Tag<gocpp::slice<unsigned char>>()(s); });
    }

}

