// generated by GoCpp from file '$(ImportDir)/runtime/mgclimit.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgclimit.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"

namespace golang::runtime
{
    struct gocpp_id_0
    {
        uint64_t fill;
        uint64_t capacity;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    runtime::limiterEventStamp makeLimiterEventStamp(golang::runtime::limiterEventType typ, int64_t now);
    struct limiterEvent
    {
        atomic::Uint64 stamp;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct limiterEvent& value);
    struct gcCPULimiterState
    {
        atomic::Uint32 lock;
        atomic::Bool enabled;
        gocpp_id_0 bucket;
        uint64_t overflow;
        bool gcEnabled;
        bool transitioning;
        atomic::Int64 assistTimePool;
        atomic::Int64 idleMarkTimePool;
        atomic::Int64 idleTimePool;
        atomic::Int64 lastUpdate;
        atomic::Uint32 lastEnabledCycle;
        int32_t nprocs;
        bool test;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcCPULimiterState& value);
    extern gcCPULimiterState gcCPULimiter;

    namespace rec
    {
        bool limiting(golang::runtime::gcCPULimiterState* l);
        void startGCTransition(golang::runtime::gcCPULimiterState* l, bool enableGC, int64_t now);
        void finishGCTransition(golang::runtime::gcCPULimiterState* l, int64_t now);
        bool needUpdate(golang::runtime::gcCPULimiterState* l, int64_t now);
        void addAssistTime(golang::runtime::gcCPULimiterState* l, int64_t t);
        void addIdleTime(golang::runtime::gcCPULimiterState* l, int64_t t);
        void update(golang::runtime::gcCPULimiterState* l, int64_t now);
        void updateLocked(golang::runtime::gcCPULimiterState* l, int64_t now);
        void accumulate(golang::runtime::gcCPULimiterState* l, int64_t mutatorTime, int64_t gcTime);
        bool tryLock(golang::runtime::gcCPULimiterState* l);
        void unlock(golang::runtime::gcCPULimiterState* l);
        void resetCapacity(golang::runtime::gcCPULimiterState* l, int64_t now, int32_t nprocs);
        int64_t duration(golang::runtime::limiterEventStamp s, int64_t now);
        runtime::limiterEventType typ(golang::runtime::limiterEventStamp s);
        bool start(golang::runtime::limiterEvent* e, golang::runtime::limiterEventType typ, int64_t now);
        std::tuple<runtime::limiterEventType, int64_t> consume(golang::runtime::limiterEvent* e, int64_t now);
        void stop(golang::runtime::limiterEvent* e, golang::runtime::limiterEventType typ, int64_t now);
    }
}

