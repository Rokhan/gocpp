// generated by GoCpp from file '$(ImportDir)/runtime/runtime2.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime2.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // defined constants
    // _Gidle means this goroutine was just allocated and has not
    // yet been initialized.
    // _Grunnable means this goroutine is on a run queue. It is
    // not currently executing user code. The stack is not owned.
    // _Grunning means this goroutine may execute user code. The
    // stack is owned by this goroutine. It is not on a run queue.
    // It is assigned an M and a P (g.m and g.m.p are valid).
    // _Gsyscall means this goroutine is executing a system call.
    // It is not executing user code. The stack is owned by this
    // goroutine. It is not on a run queue. It is assigned an M.
    // _Gwaiting means this goroutine is blocked in the runtime.
    // It is not executing user code. It is not on a run queue,
    // but should be recorded somewhere (e.g., a channel wait
    // queue) so it can be ready()d when necessary. The stack is
    // not owned *except* that a channel operation may read or
    // write parts of the stack under the appropriate channel
    // lock. Otherwise, it is not safe to access the stack after a
    // goroutine enters _Gwaiting (e.g., it may get moved).
    // _Gmoribund_unused is currently unused, but hardcoded in gdb
    // scripts.
    // _Gdead means this goroutine is currently unused. It may be
    // just exited, on a free list, or just being initialized. It
    // is not executing user code. It may or may not have a stack
    // allocated. The G and its stack (if any) are owned by the M
    // that is exiting the G or that obtained the G from the free
    // list.
    // _Genqueue_unused is currently unused.
    // _Gcopystack means this goroutine's stack is being moved. It
    // is not executing user code and is not on a run queue. The
    // stack is owned by the goroutine that put it in _Gcopystack.
    // _Gpreempted means this goroutine stopped itself for a
    // suspendG preemption. It is like _Gwaiting, but nothing is
    // yet responsible for ready()ing it. Some suspendG must CAS
    // the status to _Gwaiting to take responsibility for
    // ready()ing this G.
    // _Gscan combined with one of the above states other than
    // _Grunning indicates that GC is scanning the stack. The
    // goroutine is not executing user code and the stack is owned
    // by the goroutine that set the _Gscan bit.
    //
    // _Gscanrunning is different: it is used to briefly block
    // state transitions while GC signals the G to scan its own
    // stack. This is otherwise like _Grunning.
    //
    // atomicstatus&~Gscan gives the state the goroutine will
    // return to when the scan completes.
    // _Pidle means a P is not being used to run user code or the
    // scheduler. Typically, it's on the idle P list and available
    // to the scheduler, but it may just be transitioning between
    // other states.
    //
    // The P is owned by the idle list or by whatever is
    // transitioning its state. Its run queue is empty.
    // _Prunning means a P is owned by an M and is being used to
    // run user code or the scheduler. Only the M that owns this P
    // is allowed to change the P's status from _Prunning. The M
    // may transition the P to _Pidle (if it has no more work to
    // do), _Psyscall (when entering a syscall), or _Pgcstop (to
    // halt for the GC). The M may also hand ownership of the P
    // off directly to another M (e.g., to schedule a locked G).
    // _Psyscall means a P is not running user code. It has
    // affinity to an M in a syscall but is not owned by it and
    // may be stolen by another M. This is similar to _Pidle but
    // uses lightweight transitions and maintains M affinity.
    //
    // Leaving _Psyscall must be done with a CAS, either to steal
    // or retake the P. Note that there's an ABA hazard: even if
    // an M successfully CASes its original P back to _Prunning
    // after a syscall, it must understand the P may have been
    // used by another M in the interim.
    // _Pgcstop means a P is halted for STW and owned by the M
    // that stopped the world. The M that stopped the world
    // continues to use its P, even in _Pgcstop. Transitioning
    // from _Prunning to _Pgcstop causes an M to release its P and
    // park.
    //
    // The P retains its run queue and startTheWorld will restart
    // the scheduler on Ps with non-empty run queues.
    // _Pdead means a P is no longer used (GOMAXPROCS shrank). We
    // reuse Ps if GOMAXPROCS increases. A dead P is mostly
    // stripped of its resources, though a few things remain
    // (e.g., trace buffers).
    // Mutual exclusion locks.  In the uncontended case,
    // as fast as spin locks (just a few user-level instructions),
    // but on the contention path they sleep in the kernel.
    // A zeroed Mutex is unlocked (no need to initialize each lock).
    // Initialization is helpful for static lock ranking, but not required.
    
    template<typename T> requires gocpp::GoStruct<T>
    mutex::operator T()
    {
        T result;
        result.lockRankStruct = this->lockRankStruct;
        result.key = this->key;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mutex::operator==(const T& ref) const
    {
        if (lockRankStruct != ref.lockRankStruct) return false;
        if (key != ref.key) return false;
        return true;
    }

    std::ostream& mutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lockRankStruct;
        os << " " << key;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mutex& value)
    {
        return value.PrintTo(os);
    }

    // sleep and wakeup on one-time events.
    // before any calls to notesleep or notewakeup,
    // must call noteclear to initialize the Note.
    // then, exactly one thread can call notesleep
    // and exactly one thread can call notewakeup (once).
    // once notewakeup has been called, the notesleep
    // will return.  future notesleep will return immediately.
    // subsequent noteclear must be called only after
    // previous notesleep has returned, e.g. it's disallowed
    // to call noteclear straight after notewakeup.
    //
    // notetsleep is like notesleep but wakes up after
    // a given number of nanoseconds even if the event
    // has not yet happened.  if a goroutine uses notetsleep to
    // wake up early, it must wait to call noteclear until it
    // can be sure that no other goroutine is calling
    // notewakeup.
    //
    // notesleep/notetsleep are generally called on g0,
    // notetsleepg is similar to notetsleep but is called on user g.
    
    template<typename T> requires gocpp::GoStruct<T>
    note::operator T()
    {
        T result;
        result.key = this->key;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool note::operator==(const T& ref) const
    {
        if (key != ref.key) return false;
        return true;
    }

    std::ostream& note::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << key;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct note& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    funcval::operator T()
    {
        T result;
        result.fn = this->fn;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool funcval::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        return true;
    }

    std::ostream& funcval::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct funcval& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    iface::operator T()
    {
        T result;
        result.tab = this->tab;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool iface::operator==(const T& ref) const
    {
        if (tab != ref.tab) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& iface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << tab;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct iface& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    eface::operator T()
    {
        T result;
        result._type = this->_type;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool eface::operator==(const T& ref) const
    {
        if (_type != ref._type) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& eface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _type;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct eface& value)
    {
        return value.PrintTo(os);
    }

    struct eface* efaceOf(go_any* ep)
    {
        return (eface*)(unsafe::Pointer(ep));
    }

    // A guintptr holds a goroutine pointer, but typed as a uintptr
    // to bypass write barriers. It is used in the Gobuf goroutine state
    // and in scheduling lists that are manipulated without a P.
    //
    // The Gobuf.g goroutine pointer is almost always updated by assembly code.
    // In one of the few places it is updated by Go code - func save - it must be
    // treated as a uintptr to avoid a write barrier being emitted at a bad time.
    // Instead of figuring out how to emit the write barriers missing in the
    // assembly manipulation, we change the type of the field to uintptr,
    // so that it does not require write barriers at all.
    //
    // Goroutine structs are published in the allg list and never freed.
    // That will keep the goroutine structs from being collected.
    // There is never a time that Gobuf.g's contain the only references
    // to a goroutine: the publishing of the goroutine in allg comes first.
    // Goroutine pointers are also kept in non-GC-visible places like TLS,
    // so I can't see them ever moving. If we did want to start moving data
    // in the GC, we'd need to allocate the goroutine structs from an
    // alternate arena. Using guintptr doesn't make that problem any worse.
    // Note that pollDesc.rg, pollDesc.wg also store g in uintptr form,
    // so they would need to be updated too if g's start moving.
    //go:nosplit
    struct g* rec::ptr(golang::runtime::guintptr gp)
    {
        return (g*)(unsafe::Pointer(gp));
    }

    //go:nosplit
    void rec::set(golang::runtime::guintptr* gp, struct g* g)
    {
        *gp = guintptr(unsafe::Pointer(g));
    }

    //go:nosplit
    bool rec::cas(golang::runtime::guintptr* gp, golang::runtime::guintptr old, golang::runtime::guintptr go_new)
    {
        return atomic::Casuintptr((uintptr_t*)(unsafe::Pointer(gp)), uintptr_t(old), uintptr_t(go_new));
    }

    //go:nosplit
    runtime::guintptr rec::guintptr(runtime::g* gp)
    {
        return guintptr(unsafe::Pointer(gp));
    }

    // setGNoWB performs *gp = new without a write barrier.
    // For times when it's impractical to use a guintptr.
    //
    //go:nosplit
    //go:nowritebarrier
    void setGNoWB(runtime::g** gp, runtime::g* go_new)
    {
        rec::set(gocpp::recv((runtime::guintptr*)(unsafe::Pointer(gp))), go_new);
    }

    //go:nosplit
    struct p* rec::ptr(golang::runtime::puintptr pp)
    {
        return (p*)(unsafe::Pointer(pp));
    }

    //go:nosplit
    void rec::set(golang::runtime::puintptr* pp, struct p* p)
    {
        *pp = puintptr(unsafe::Pointer(p));
    }

    // muintptr is a *m that is not tracked by the garbage collector.
    //
    // Because we do free Ms, there are some additional constrains on
    // muintptrs:
    //
    //  1. Never hold an muintptr locally across a safe point.
    //
    //  2. Any muintptr in the heap must be owned by the M itself so it can
    //     ensure it is not in use when the last true *m is released.
    //go:nosplit
    struct m* rec::ptr(golang::runtime::muintptr mp)
    {
        return (m*)(unsafe::Pointer(mp));
    }

    //go:nosplit
    void rec::set(golang::runtime::muintptr* mp, struct m* m)
    {
        *mp = muintptr(unsafe::Pointer(m));
    }

    // setMNoWB performs *mp = new without a write barrier.
    // For times when it's impractical to use an muintptr.
    //
    //go:nosplit
    //go:nowritebarrier
    void setMNoWB(runtime::m** mp, runtime::m* go_new)
    {
        rec::set(gocpp::recv((runtime::muintptr*)(unsafe::Pointer(mp))), go_new);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gobuf::operator T()
    {
        T result;
        result.sp = this->sp;
        result.pc = this->pc;
        result.g = this->g;
        result.ctxt = this->ctxt;
        result.ret = this->ret;
        result.lr = this->lr;
        result.bp = this->bp;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gobuf::operator==(const T& ref) const
    {
        if (sp != ref.sp) return false;
        if (pc != ref.pc) return false;
        if (g != ref.g) return false;
        if (ctxt != ref.ctxt) return false;
        if (ret != ref.ret) return false;
        if (lr != ref.lr) return false;
        if (bp != ref.bp) return false;
        return true;
    }

    std::ostream& gobuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << sp;
        os << " " << pc;
        os << " " << g;
        os << " " << ctxt;
        os << " " << ret;
        os << " " << lr;
        os << " " << bp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gobuf& value)
    {
        return value.PrintTo(os);
    }

    // sudog (pseudo-g) represents a g in a wait list, such as for sending/receiving
    // on a channel.
    //
    // sudog is necessary because the g â†” synchronization object relation
    // is many-to-many. A g can be on many wait lists, so there may be
    // many sudogs for one g; and many gs may be waiting on the same
    // synchronization object, so there may be many sudogs for one object.
    //
    // sudogs are allocated from a special pool. Use acquireSudog and
    // releaseSudog to allocate and free them.
    
    template<typename T> requires gocpp::GoStruct<T>
    sudog::operator T()
    {
        T result;
        result.g = this->g;
        result.next = this->next;
        result.prev = this->prev;
        result.elem = this->elem;
        result.acquiretime = this->acquiretime;
        result.releasetime = this->releasetime;
        result.ticket = this->ticket;
        result.isSelect = this->isSelect;
        result.success = this->success;
        result.waiters = this->waiters;
        result.parent = this->parent;
        result.waitlink = this->waitlink;
        result.waittail = this->waittail;
        result.c = this->c;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sudog::operator==(const T& ref) const
    {
        if (g != ref.g) return false;
        if (next != ref.next) return false;
        if (prev != ref.prev) return false;
        if (elem != ref.elem) return false;
        if (acquiretime != ref.acquiretime) return false;
        if (releasetime != ref.releasetime) return false;
        if (ticket != ref.ticket) return false;
        if (isSelect != ref.isSelect) return false;
        if (success != ref.success) return false;
        if (waiters != ref.waiters) return false;
        if (parent != ref.parent) return false;
        if (waitlink != ref.waitlink) return false;
        if (waittail != ref.waittail) return false;
        if (c != ref.c) return false;
        return true;
    }

    std::ostream& sudog::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g;
        os << " " << next;
        os << " " << prev;
        os << " " << elem;
        os << " " << acquiretime;
        os << " " << releasetime;
        os << " " << ticket;
        os << " " << isSelect;
        os << " " << success;
        os << " " << waiters;
        os << " " << parent;
        os << " " << waitlink;
        os << " " << waittail;
        os << " " << c;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sudog& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    libcall::operator T()
    {
        T result;
        result.fn = this->fn;
        result.n = this->n;
        result.args = this->args;
        result.r1 = this->r1;
        result.r2 = this->r2;
        result.err = this->err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool libcall::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (n != ref.n) return false;
        if (args != ref.args) return false;
        if (r1 != ref.r1) return false;
        if (r2 != ref.r2) return false;
        if (err != ref.err) return false;
        return true;
    }

    std::ostream& libcall::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << n;
        os << " " << args;
        os << " " << r1;
        os << " " << r2;
        os << " " << err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct libcall& value)
    {
        return value.PrintTo(os);
    }

    // Stack describes a Go execution stack.
    // The bounds of the stack are exactly [lo, hi),
    // with no implicit data structures on either side.
    
    template<typename T> requires gocpp::GoStruct<T>
    stack::operator T()
    {
        T result;
        result.lo = this->lo;
        result.hi = this->hi;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stack::operator==(const T& ref) const
    {
        if (lo != ref.lo) return false;
        if (hi != ref.hi) return false;
        return true;
    }

    std::ostream& stack::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lo;
        os << " " << hi;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stack& value)
    {
        return value.PrintTo(os);
    }

    // heldLockInfo gives info on a held lock and the rank of that lock
    
    template<typename T> requires gocpp::GoStruct<T>
    heldLockInfo::operator T()
    {
        T result;
        result.lockAddr = this->lockAddr;
        result.rank = this->rank;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heldLockInfo::operator==(const T& ref) const
    {
        if (lockAddr != ref.lockAddr) return false;
        if (rank != ref.rank) return false;
        return true;
    }

    std::ostream& heldLockInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lockAddr;
        os << " " << rank;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heldLockInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    g::operator T()
    {
        T result;
        result.stack = this->stack;
        result.stackguard0 = this->stackguard0;
        result.stackguard1 = this->stackguard1;
        result._panic = this->_panic;
        result._defer = this->_defer;
        result.m = this->m;
        result.sched = this->sched;
        result.syscallsp = this->syscallsp;
        result.syscallpc = this->syscallpc;
        result.stktopsp = this->stktopsp;
        result.param = this->param;
        result.atomicstatus = this->atomicstatus;
        result.stackLock = this->stackLock;
        result.goid = this->goid;
        result.schedlink = this->schedlink;
        result.waitsince = this->waitsince;
        result.waitreason = this->waitreason;
        result.preempt = this->preempt;
        result.preemptStop = this->preemptStop;
        result.preemptShrink = this->preemptShrink;
        result.asyncSafePoint = this->asyncSafePoint;
        result.paniconfault = this->paniconfault;
        result.gcscandone = this->gcscandone;
        result.throwsplit = this->throwsplit;
        result.activeStackChans = this->activeStackChans;
        result.parkingOnChan = this->parkingOnChan;
        result.inMarkAssist = this->inMarkAssist;
        result.coroexit = this->coroexit;
        result.raceignore = this->raceignore;
        result.nocgocallback = this->nocgocallback;
        result.tracking = this->tracking;
        result.trackingSeq = this->trackingSeq;
        result.trackingStamp = this->trackingStamp;
        result.runnableTime = this->runnableTime;
        result.lockedm = this->lockedm;
        result.sig = this->sig;
        result.writebuf = this->writebuf;
        result.sigcode0 = this->sigcode0;
        result.sigcode1 = this->sigcode1;
        result.sigpc = this->sigpc;
        result.parentGoid = this->parentGoid;
        result.gopc = this->gopc;
        result.ancestors = this->ancestors;
        result.startpc = this->startpc;
        result.racectx = this->racectx;
        result.waiting = this->waiting;
        result.cgoCtxt = this->cgoCtxt;
        result.labels = this->labels;
        result.timer = this->timer;
        result.selectDone = this->selectDone;
        result.coroarg = this->coroarg;
        result.goroutineProfiled = this->goroutineProfiled;
        result.trace = this->trace;
        result.gcAssistBytes = this->gcAssistBytes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool g::operator==(const T& ref) const
    {
        if (stack != ref.stack) return false;
        if (stackguard0 != ref.stackguard0) return false;
        if (stackguard1 != ref.stackguard1) return false;
        if (_panic != ref._panic) return false;
        if (_defer != ref._defer) return false;
        if (m != ref.m) return false;
        if (sched != ref.sched) return false;
        if (syscallsp != ref.syscallsp) return false;
        if (syscallpc != ref.syscallpc) return false;
        if (stktopsp != ref.stktopsp) return false;
        if (param != ref.param) return false;
        if (atomicstatus != ref.atomicstatus) return false;
        if (stackLock != ref.stackLock) return false;
        if (goid != ref.goid) return false;
        if (schedlink != ref.schedlink) return false;
        if (waitsince != ref.waitsince) return false;
        if (waitreason != ref.waitreason) return false;
        if (preempt != ref.preempt) return false;
        if (preemptStop != ref.preemptStop) return false;
        if (preemptShrink != ref.preemptShrink) return false;
        if (asyncSafePoint != ref.asyncSafePoint) return false;
        if (paniconfault != ref.paniconfault) return false;
        if (gcscandone != ref.gcscandone) return false;
        if (throwsplit != ref.throwsplit) return false;
        if (activeStackChans != ref.activeStackChans) return false;
        if (parkingOnChan != ref.parkingOnChan) return false;
        if (inMarkAssist != ref.inMarkAssist) return false;
        if (coroexit != ref.coroexit) return false;
        if (raceignore != ref.raceignore) return false;
        if (nocgocallback != ref.nocgocallback) return false;
        if (tracking != ref.tracking) return false;
        if (trackingSeq != ref.trackingSeq) return false;
        if (trackingStamp != ref.trackingStamp) return false;
        if (runnableTime != ref.runnableTime) return false;
        if (lockedm != ref.lockedm) return false;
        if (sig != ref.sig) return false;
        if (writebuf != ref.writebuf) return false;
        if (sigcode0 != ref.sigcode0) return false;
        if (sigcode1 != ref.sigcode1) return false;
        if (sigpc != ref.sigpc) return false;
        if (parentGoid != ref.parentGoid) return false;
        if (gopc != ref.gopc) return false;
        if (ancestors != ref.ancestors) return false;
        if (startpc != ref.startpc) return false;
        if (racectx != ref.racectx) return false;
        if (waiting != ref.waiting) return false;
        if (cgoCtxt != ref.cgoCtxt) return false;
        if (labels != ref.labels) return false;
        if (timer != ref.timer) return false;
        if (selectDone != ref.selectDone) return false;
        if (coroarg != ref.coroarg) return false;
        if (goroutineProfiled != ref.goroutineProfiled) return false;
        if (trace != ref.trace) return false;
        if (gcAssistBytes != ref.gcAssistBytes) return false;
        return true;
    }

    std::ostream& g::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stack;
        os << " " << stackguard0;
        os << " " << stackguard1;
        os << " " << _panic;
        os << " " << _defer;
        os << " " << m;
        os << " " << sched;
        os << " " << syscallsp;
        os << " " << syscallpc;
        os << " " << stktopsp;
        os << " " << param;
        os << " " << atomicstatus;
        os << " " << stackLock;
        os << " " << goid;
        os << " " << schedlink;
        os << " " << waitsince;
        os << " " << waitreason;
        os << " " << preempt;
        os << " " << preemptStop;
        os << " " << preemptShrink;
        os << " " << asyncSafePoint;
        os << " " << paniconfault;
        os << " " << gcscandone;
        os << " " << throwsplit;
        os << " " << activeStackChans;
        os << " " << parkingOnChan;
        os << " " << inMarkAssist;
        os << " " << coroexit;
        os << " " << raceignore;
        os << " " << nocgocallback;
        os << " " << tracking;
        os << " " << trackingSeq;
        os << " " << trackingStamp;
        os << " " << runnableTime;
        os << " " << lockedm;
        os << " " << sig;
        os << " " << writebuf;
        os << " " << sigcode0;
        os << " " << sigcode1;
        os << " " << sigpc;
        os << " " << parentGoid;
        os << " " << gopc;
        os << " " << ancestors;
        os << " " << startpc;
        os << " " << racectx;
        os << " " << waiting;
        os << " " << cgoCtxt;
        os << " " << labels;
        os << " " << timer;
        os << " " << selectDone;
        os << " " << coroarg;
        os << " " << goroutineProfiled;
        os << " " << trace;
        os << " " << gcAssistBytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct g& value)
    {
        return value.PrintTo(os);
    }

    // gTrackingPeriod is the number of transitions out of _Grunning between
    // latency tracking runs.
    // tlsSlots is the number of pointer-sized slots reserved for TLS on some platforms,
    // like Windows.
    // Values for m.freeWait.
    
    template<typename T> requires gocpp::GoStruct<T>
    m::operator T()
    {
        T result;
        result.g0 = this->g0;
        result.morebuf = this->morebuf;
        result.divmod = this->divmod;
        result._1 = this->_1;
        result.procid = this->procid;
        result.gsignal = this->gsignal;
        result.goSigStack = this->goSigStack;
        result.sigmask = this->sigmask;
        result.tls = this->tls;
        result.mstartfn = this->mstartfn;
        result.curg = this->curg;
        result.caughtsig = this->caughtsig;
        result.p = this->p;
        result.nextp = this->nextp;
        result.oldp = this->oldp;
        result.id = this->id;
        result.mallocing = this->mallocing;
        result.throwing = this->throwing;
        result.preemptoff = this->preemptoff;
        result.locks = this->locks;
        result.dying = this->dying;
        result.profilehz = this->profilehz;
        result.spinning = this->spinning;
        result.blocked = this->blocked;
        result.newSigstack = this->newSigstack;
        result.printlock = this->printlock;
        result.incgo = this->incgo;
        result.isextra = this->isextra;
        result.isExtraInC = this->isExtraInC;
        result.isExtraInSig = this->isExtraInSig;
        result.freeWait = this->freeWait;
        result.needextram = this->needextram;
        result.traceback = this->traceback;
        result.ncgocall = this->ncgocall;
        result.ncgo = this->ncgo;
        result.cgoCallersUse = this->cgoCallersUse;
        result.cgoCallers = this->cgoCallers;
        result.park = this->park;
        result.alllink = this->alllink;
        result.schedlink = this->schedlink;
        result.lockedg = this->lockedg;
        result.createstack = this->createstack;
        result.lockedExt = this->lockedExt;
        result.lockedInt = this->lockedInt;
        result.nextwaitm = this->nextwaitm;
        result.mLockProfile = this->mLockProfile;
        result.waitunlockf = this->waitunlockf;
        result.waitlock = this->waitlock;
        result.waitTraceBlockReason = this->waitTraceBlockReason;
        result.waitTraceSkip = this->waitTraceSkip;
        result.syscalltick = this->syscalltick;
        result.freelink = this->freelink;
        result.trace = this->trace;
        result.libcall = this->libcall;
        result.libcallpc = this->libcallpc;
        result.libcallsp = this->libcallsp;
        result.libcallg = this->libcallg;
        result.syscall = this->syscall;
        result.vdsoSP = this->vdsoSP;
        result.vdsoPC = this->vdsoPC;
        result.preemptGen = this->preemptGen;
        result.signalPending = this->signalPending;
        result.pcvalueCache = this->pcvalueCache;
        result.dlogPerM = this->dlogPerM;
        result.mOS = this->mOS;
        result.chacha8 = this->chacha8;
        result.cheaprand = this->cheaprand;
        result.locksHeldLen = this->locksHeldLen;
        result.locksHeld = this->locksHeld;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool m::operator==(const T& ref) const
    {
        if (g0 != ref.g0) return false;
        if (morebuf != ref.morebuf) return false;
        if (divmod != ref.divmod) return false;
        if (_1 != ref._1) return false;
        if (procid != ref.procid) return false;
        if (gsignal != ref.gsignal) return false;
        if (goSigStack != ref.goSigStack) return false;
        if (sigmask != ref.sigmask) return false;
        if (tls != ref.tls) return false;
        if (mstartfn != ref.mstartfn) return false;
        if (curg != ref.curg) return false;
        if (caughtsig != ref.caughtsig) return false;
        if (p != ref.p) return false;
        if (nextp != ref.nextp) return false;
        if (oldp != ref.oldp) return false;
        if (id != ref.id) return false;
        if (mallocing != ref.mallocing) return false;
        if (throwing != ref.throwing) return false;
        if (preemptoff != ref.preemptoff) return false;
        if (locks != ref.locks) return false;
        if (dying != ref.dying) return false;
        if (profilehz != ref.profilehz) return false;
        if (spinning != ref.spinning) return false;
        if (blocked != ref.blocked) return false;
        if (newSigstack != ref.newSigstack) return false;
        if (printlock != ref.printlock) return false;
        if (incgo != ref.incgo) return false;
        if (isextra != ref.isextra) return false;
        if (isExtraInC != ref.isExtraInC) return false;
        if (isExtraInSig != ref.isExtraInSig) return false;
        if (freeWait != ref.freeWait) return false;
        if (needextram != ref.needextram) return false;
        if (traceback != ref.traceback) return false;
        if (ncgocall != ref.ncgocall) return false;
        if (ncgo != ref.ncgo) return false;
        if (cgoCallersUse != ref.cgoCallersUse) return false;
        if (cgoCallers != ref.cgoCallers) return false;
        if (park != ref.park) return false;
        if (alllink != ref.alllink) return false;
        if (schedlink != ref.schedlink) return false;
        if (lockedg != ref.lockedg) return false;
        if (createstack != ref.createstack) return false;
        if (lockedExt != ref.lockedExt) return false;
        if (lockedInt != ref.lockedInt) return false;
        if (nextwaitm != ref.nextwaitm) return false;
        if (mLockProfile != ref.mLockProfile) return false;
        if (waitunlockf != ref.waitunlockf) return false;
        if (waitlock != ref.waitlock) return false;
        if (waitTraceBlockReason != ref.waitTraceBlockReason) return false;
        if (waitTraceSkip != ref.waitTraceSkip) return false;
        if (syscalltick != ref.syscalltick) return false;
        if (freelink != ref.freelink) return false;
        if (trace != ref.trace) return false;
        if (libcall != ref.libcall) return false;
        if (libcallpc != ref.libcallpc) return false;
        if (libcallsp != ref.libcallsp) return false;
        if (libcallg != ref.libcallg) return false;
        if (syscall != ref.syscall) return false;
        if (vdsoSP != ref.vdsoSP) return false;
        if (vdsoPC != ref.vdsoPC) return false;
        if (preemptGen != ref.preemptGen) return false;
        if (signalPending != ref.signalPending) return false;
        if (pcvalueCache != ref.pcvalueCache) return false;
        if (dlogPerM != ref.dlogPerM) return false;
        if (mOS != ref.mOS) return false;
        if (chacha8 != ref.chacha8) return false;
        if (cheaprand != ref.cheaprand) return false;
        if (locksHeldLen != ref.locksHeldLen) return false;
        if (locksHeld != ref.locksHeld) return false;
        return true;
    }

    std::ostream& m::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g0;
        os << " " << morebuf;
        os << " " << divmod;
        os << " " << _1;
        os << " " << procid;
        os << " " << gsignal;
        os << " " << goSigStack;
        os << " " << sigmask;
        os << " " << tls;
        os << " " << mstartfn;
        os << " " << curg;
        os << " " << caughtsig;
        os << " " << p;
        os << " " << nextp;
        os << " " << oldp;
        os << " " << id;
        os << " " << mallocing;
        os << " " << throwing;
        os << " " << preemptoff;
        os << " " << locks;
        os << " " << dying;
        os << " " << profilehz;
        os << " " << spinning;
        os << " " << blocked;
        os << " " << newSigstack;
        os << " " << printlock;
        os << " " << incgo;
        os << " " << isextra;
        os << " " << isExtraInC;
        os << " " << isExtraInSig;
        os << " " << freeWait;
        os << " " << needextram;
        os << " " << traceback;
        os << " " << ncgocall;
        os << " " << ncgo;
        os << " " << cgoCallersUse;
        os << " " << cgoCallers;
        os << " " << park;
        os << " " << alllink;
        os << " " << schedlink;
        os << " " << lockedg;
        os << " " << createstack;
        os << " " << lockedExt;
        os << " " << lockedInt;
        os << " " << nextwaitm;
        os << " " << mLockProfile;
        os << " " << waitunlockf;
        os << " " << waitlock;
        os << " " << waitTraceBlockReason;
        os << " " << waitTraceSkip;
        os << " " << syscalltick;
        os << " " << freelink;
        os << " " << trace;
        os << " " << libcall;
        os << " " << libcallpc;
        os << " " << libcallsp;
        os << " " << libcallg;
        os << " " << syscall;
        os << " " << vdsoSP;
        os << " " << vdsoPC;
        os << " " << preemptGen;
        os << " " << signalPending;
        os << " " << pcvalueCache;
        os << " " << dlogPerM;
        os << " " << mOS;
        os << " " << chacha8;
        os << " " << cheaprand;
        os << " " << locksHeldLen;
        os << " " << locksHeld;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct m& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.gList = this->gList;
        result.n = this->n;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (gList != ref.gList) return false;
        if (n != ref.n) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << gList;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_1::operator T()
    {
        T result;
        result.len = this->len;
        result.buf = this->buf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_1::operator==(const T& ref) const
    {
        if (len != ref.len) return false;
        if (buf != ref.buf) return false;
        return true;
    }

    std::ostream& gocpp_id_1::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << len;
        os << " " << buf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    p::operator T()
    {
        T result;
        result.id = this->id;
        result.status = this->status;
        result.link = this->link;
        result.schedtick = this->schedtick;
        result.syscalltick = this->syscalltick;
        result.sysmontick = this->sysmontick;
        result.m = this->m;
        result.mcache = this->mcache;
        result.pcache = this->pcache;
        result.raceprocctx = this->raceprocctx;
        result.deferpool = this->deferpool;
        result.deferpoolbuf = this->deferpoolbuf;
        result.goidcache = this->goidcache;
        result.goidcacheend = this->goidcacheend;
        result.runqhead = this->runqhead;
        result.runqtail = this->runqtail;
        result.runq = this->runq;
        result.runnext = this->runnext;
        result.gFree = this->gFree;
        result.sudogcache = this->sudogcache;
        result.sudogbuf = this->sudogbuf;
        result.mspancache = this->mspancache;
        result.pinnerCache = this->pinnerCache;
        result.trace = this->trace;
        result.palloc = this->palloc;
        result.timer0When = this->timer0When;
        result.timerModifiedEarliest = this->timerModifiedEarliest;
        result.gcAssistTime = this->gcAssistTime;
        result.gcFractionalMarkTime = this->gcFractionalMarkTime;
        result.limiterEvent = this->limiterEvent;
        result.gcMarkWorkerMode = this->gcMarkWorkerMode;
        result.gcMarkWorkerStartTime = this->gcMarkWorkerStartTime;
        result.gcw = this->gcw;
        result.wbBuf = this->wbBuf;
        result.runSafePointFn = this->runSafePointFn;
        result.statsSeq = this->statsSeq;
        result.timersLock = this->timersLock;
        result.timers = this->timers;
        result.numTimers = this->numTimers;
        result.deletedTimers = this->deletedTimers;
        result.timerRaceCtx = this->timerRaceCtx;
        result.maxStackScanDelta = this->maxStackScanDelta;
        result.scannedStackSize = this->scannedStackSize;
        result.scannedStacks = this->scannedStacks;
        result.preempt = this->preempt;
        result.pageTraceBuf = this->pageTraceBuf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool p::operator==(const T& ref) const
    {
        if (id != ref.id) return false;
        if (status != ref.status) return false;
        if (link != ref.link) return false;
        if (schedtick != ref.schedtick) return false;
        if (syscalltick != ref.syscalltick) return false;
        if (sysmontick != ref.sysmontick) return false;
        if (m != ref.m) return false;
        if (mcache != ref.mcache) return false;
        if (pcache != ref.pcache) return false;
        if (raceprocctx != ref.raceprocctx) return false;
        if (deferpool != ref.deferpool) return false;
        if (deferpoolbuf != ref.deferpoolbuf) return false;
        if (goidcache != ref.goidcache) return false;
        if (goidcacheend != ref.goidcacheend) return false;
        if (runqhead != ref.runqhead) return false;
        if (runqtail != ref.runqtail) return false;
        if (runq != ref.runq) return false;
        if (runnext != ref.runnext) return false;
        if (gFree != ref.gFree) return false;
        if (sudogcache != ref.sudogcache) return false;
        if (sudogbuf != ref.sudogbuf) return false;
        if (mspancache != ref.mspancache) return false;
        if (pinnerCache != ref.pinnerCache) return false;
        if (trace != ref.trace) return false;
        if (palloc != ref.palloc) return false;
        if (timer0When != ref.timer0When) return false;
        if (timerModifiedEarliest != ref.timerModifiedEarliest) return false;
        if (gcAssistTime != ref.gcAssistTime) return false;
        if (gcFractionalMarkTime != ref.gcFractionalMarkTime) return false;
        if (limiterEvent != ref.limiterEvent) return false;
        if (gcMarkWorkerMode != ref.gcMarkWorkerMode) return false;
        if (gcMarkWorkerStartTime != ref.gcMarkWorkerStartTime) return false;
        if (gcw != ref.gcw) return false;
        if (wbBuf != ref.wbBuf) return false;
        if (runSafePointFn != ref.runSafePointFn) return false;
        if (statsSeq != ref.statsSeq) return false;
        if (timersLock != ref.timersLock) return false;
        if (timers != ref.timers) return false;
        if (numTimers != ref.numTimers) return false;
        if (deletedTimers != ref.deletedTimers) return false;
        if (timerRaceCtx != ref.timerRaceCtx) return false;
        if (maxStackScanDelta != ref.maxStackScanDelta) return false;
        if (scannedStackSize != ref.scannedStackSize) return false;
        if (scannedStacks != ref.scannedStacks) return false;
        if (preempt != ref.preempt) return false;
        if (pageTraceBuf != ref.pageTraceBuf) return false;
        return true;
    }

    std::ostream& p::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << id;
        os << " " << status;
        os << " " << link;
        os << " " << schedtick;
        os << " " << syscalltick;
        os << " " << sysmontick;
        os << " " << m;
        os << " " << mcache;
        os << " " << pcache;
        os << " " << raceprocctx;
        os << " " << deferpool;
        os << " " << deferpoolbuf;
        os << " " << goidcache;
        os << " " << goidcacheend;
        os << " " << runqhead;
        os << " " << runqtail;
        os << " " << runq;
        os << " " << runnext;
        os << " " << gFree;
        os << " " << sudogcache;
        os << " " << sudogbuf;
        os << " " << mspancache;
        os << " " << pinnerCache;
        os << " " << trace;
        os << " " << palloc;
        os << " " << timer0When;
        os << " " << timerModifiedEarliest;
        os << " " << gcAssistTime;
        os << " " << gcFractionalMarkTime;
        os << " " << limiterEvent;
        os << " " << gcMarkWorkerMode;
        os << " " << gcMarkWorkerStartTime;
        os << " " << gcw;
        os << " " << wbBuf;
        os << " " << runSafePointFn;
        os << " " << statsSeq;
        os << " " << timersLock;
        os << " " << timers;
        os << " " << numTimers;
        os << " " << deletedTimers;
        os << " " << timerRaceCtx;
        os << " " << maxStackScanDelta;
        os << " " << scannedStackSize;
        os << " " << scannedStacks;
        os << " " << preempt;
        os << " " << pageTraceBuf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct p& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_2::operator T()
    {
        T result;
        result.user = this->user;
        result.runnable = this->runnable;
        result.n = this->n;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_2::operator==(const T& ref) const
    {
        if (user != ref.user) return false;
        if (runnable != ref.runnable) return false;
        if (n != ref.n) return false;
        return true;
    }

    std::ostream& gocpp_id_2::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << user;
        os << " " << runnable;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_3::operator T()
    {
        T result;
        result.lock = this->lock;
        result.stack = this->stack;
        result.noStack = this->noStack;
        result.n = this->n;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_3::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (stack != ref.stack) return false;
        if (noStack != ref.noStack) return false;
        if (n != ref.n) return false;
        return true;
    }

    std::ostream& gocpp_id_3::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << stack;
        os << " " << noStack;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    schedt::operator T()
    {
        T result;
        result.goidgen = this->goidgen;
        result.lastpoll = this->lastpoll;
        result.pollUntil = this->pollUntil;
        result.lock = this->lock;
        result.midle = this->midle;
        result.nmidle = this->nmidle;
        result.nmidlelocked = this->nmidlelocked;
        result.mnext = this->mnext;
        result.maxmcount = this->maxmcount;
        result.nmsys = this->nmsys;
        result.nmfreed = this->nmfreed;
        result.ngsys = this->ngsys;
        result.pidle = this->pidle;
        result.npidle = this->npidle;
        result.nmspinning = this->nmspinning;
        result.needspinning = this->needspinning;
        result.runq = this->runq;
        result.runqsize = this->runqsize;
        result.disable = this->disable;
        result.gFree = this->gFree;
        result.sudoglock = this->sudoglock;
        result.sudogcache = this->sudogcache;
        result.deferlock = this->deferlock;
        result.deferpool = this->deferpool;
        result.freem = this->freem;
        result.gcwaiting = this->gcwaiting;
        result.stopwait = this->stopwait;
        result.stopnote = this->stopnote;
        result.sysmonwait = this->sysmonwait;
        result.sysmonnote = this->sysmonnote;
        result.safePointFn = this->safePointFn;
        result.safePointWait = this->safePointWait;
        result.safePointNote = this->safePointNote;
        result.profilehz = this->profilehz;
        result.procresizetime = this->procresizetime;
        result.totaltime = this->totaltime;
        result.sysmonlock = this->sysmonlock;
        result.timeToRun = this->timeToRun;
        result.idleTime = this->idleTime;
        result.totalMutexWaitTime = this->totalMutexWaitTime;
        result.stwStoppingTimeGC = this->stwStoppingTimeGC;
        result.stwStoppingTimeOther = this->stwStoppingTimeOther;
        result.stwTotalTimeGC = this->stwTotalTimeGC;
        result.stwTotalTimeOther = this->stwTotalTimeOther;
        result.totalRuntimeLockWaitTime = this->totalRuntimeLockWaitTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool schedt::operator==(const T& ref) const
    {
        if (goidgen != ref.goidgen) return false;
        if (lastpoll != ref.lastpoll) return false;
        if (pollUntil != ref.pollUntil) return false;
        if (lock != ref.lock) return false;
        if (midle != ref.midle) return false;
        if (nmidle != ref.nmidle) return false;
        if (nmidlelocked != ref.nmidlelocked) return false;
        if (mnext != ref.mnext) return false;
        if (maxmcount != ref.maxmcount) return false;
        if (nmsys != ref.nmsys) return false;
        if (nmfreed != ref.nmfreed) return false;
        if (ngsys != ref.ngsys) return false;
        if (pidle != ref.pidle) return false;
        if (npidle != ref.npidle) return false;
        if (nmspinning != ref.nmspinning) return false;
        if (needspinning != ref.needspinning) return false;
        if (runq != ref.runq) return false;
        if (runqsize != ref.runqsize) return false;
        if (disable != ref.disable) return false;
        if (gFree != ref.gFree) return false;
        if (sudoglock != ref.sudoglock) return false;
        if (sudogcache != ref.sudogcache) return false;
        if (deferlock != ref.deferlock) return false;
        if (deferpool != ref.deferpool) return false;
        if (freem != ref.freem) return false;
        if (gcwaiting != ref.gcwaiting) return false;
        if (stopwait != ref.stopwait) return false;
        if (stopnote != ref.stopnote) return false;
        if (sysmonwait != ref.sysmonwait) return false;
        if (sysmonnote != ref.sysmonnote) return false;
        if (safePointFn != ref.safePointFn) return false;
        if (safePointWait != ref.safePointWait) return false;
        if (safePointNote != ref.safePointNote) return false;
        if (profilehz != ref.profilehz) return false;
        if (procresizetime != ref.procresizetime) return false;
        if (totaltime != ref.totaltime) return false;
        if (sysmonlock != ref.sysmonlock) return false;
        if (timeToRun != ref.timeToRun) return false;
        if (idleTime != ref.idleTime) return false;
        if (totalMutexWaitTime != ref.totalMutexWaitTime) return false;
        if (stwStoppingTimeGC != ref.stwStoppingTimeGC) return false;
        if (stwStoppingTimeOther != ref.stwStoppingTimeOther) return false;
        if (stwTotalTimeGC != ref.stwTotalTimeGC) return false;
        if (stwTotalTimeOther != ref.stwTotalTimeOther) return false;
        if (totalRuntimeLockWaitTime != ref.totalRuntimeLockWaitTime) return false;
        return true;
    }

    std::ostream& schedt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << goidgen;
        os << " " << lastpoll;
        os << " " << pollUntil;
        os << " " << lock;
        os << " " << midle;
        os << " " << nmidle;
        os << " " << nmidlelocked;
        os << " " << mnext;
        os << " " << maxmcount;
        os << " " << nmsys;
        os << " " << nmfreed;
        os << " " << ngsys;
        os << " " << pidle;
        os << " " << npidle;
        os << " " << nmspinning;
        os << " " << needspinning;
        os << " " << runq;
        os << " " << runqsize;
        os << " " << disable;
        os << " " << gFree;
        os << " " << sudoglock;
        os << " " << sudogcache;
        os << " " << deferlock;
        os << " " << deferpool;
        os << " " << freem;
        os << " " << gcwaiting;
        os << " " << stopwait;
        os << " " << stopnote;
        os << " " << sysmonwait;
        os << " " << sysmonnote;
        os << " " << safePointFn;
        os << " " << safePointWait;
        os << " " << safePointNote;
        os << " " << profilehz;
        os << " " << procresizetime;
        os << " " << totaltime;
        os << " " << sysmonlock;
        os << " " << timeToRun;
        os << " " << idleTime;
        os << " " << totalMutexWaitTime;
        os << " " << stwStoppingTimeGC;
        os << " " << stwStoppingTimeOther;
        os << " " << stwTotalTimeGC;
        os << " " << stwTotalTimeOther;
        os << " " << totalRuntimeLockWaitTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct schedt& value)
    {
        return value.PrintTo(os);
    }

    // Values for the flags field of a sigTabT.
    // Layout of in-memory per-function information prepared by linker
    // See https://golang.org/s/go12symtab.
    // Keep in sync with linker (../cmd/link/internal/ld/pcln.go:/pclntab)
    // and with package debug/gosym and with symtab.go in package runtime.
    
    template<typename T> requires gocpp::GoStruct<T>
    _func::operator T()
    {
        T result;
        result.NotInHeap = this->NotInHeap;
        result.entryOff = this->entryOff;
        result.nameOff = this->nameOff;
        result.args = this->args;
        result.deferreturn = this->deferreturn;
        result.pcsp = this->pcsp;
        result.pcfile = this->pcfile;
        result.pcln = this->pcln;
        result.npcdata = this->npcdata;
        result.cuOffset = this->cuOffset;
        result.startLine = this->startLine;
        result.funcID = this->funcID;
        result.flag = this->flag;
        result._1 = this->_1;
        result.nfuncdata = this->nfuncdata;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool _func::operator==(const T& ref) const
    {
        if (NotInHeap != ref.NotInHeap) return false;
        if (entryOff != ref.entryOff) return false;
        if (nameOff != ref.nameOff) return false;
        if (args != ref.args) return false;
        if (deferreturn != ref.deferreturn) return false;
        if (pcsp != ref.pcsp) return false;
        if (pcfile != ref.pcfile) return false;
        if (pcln != ref.pcln) return false;
        if (npcdata != ref.npcdata) return false;
        if (cuOffset != ref.cuOffset) return false;
        if (startLine != ref.startLine) return false;
        if (funcID != ref.funcID) return false;
        if (flag != ref.flag) return false;
        if (_1 != ref._1) return false;
        if (nfuncdata != ref.nfuncdata) return false;
        return true;
    }

    std::ostream& _func::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << NotInHeap;
        os << " " << entryOff;
        os << " " << nameOff;
        os << " " << args;
        os << " " << deferreturn;
        os << " " << pcsp;
        os << " " << pcfile;
        os << " " << pcln;
        os << " " << npcdata;
        os << " " << cuOffset;
        os << " " << startLine;
        os << " " << funcID;
        os << " " << flag;
        os << " " << _1;
        os << " " << nfuncdata;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _func& value)
    {
        return value.PrintTo(os);
    }

    // Pseudo-Func that is returned for PCs that occur in inlined code.
    // A *Func can be either a *_func or a *funcinl, and they are distinguished
    // by the first uintptr.
    //
    // TODO(austin): Can we merge this with inlinedCall?
    
    template<typename T> requires gocpp::GoStruct<T>
    funcinl::operator T()
    {
        T result;
        result.ones = this->ones;
        result.entry = this->entry;
        result.name = this->name;
        result.file = this->file;
        result.line = this->line;
        result.startLine = this->startLine;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool funcinl::operator==(const T& ref) const
    {
        if (ones != ref.ones) return false;
        if (entry != ref.entry) return false;
        if (name != ref.name) return false;
        if (file != ref.file) return false;
        if (line != ref.line) return false;
        if (startLine != ref.startLine) return false;
        return true;
    }

    std::ostream& funcinl::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ones;
        os << " " << entry;
        os << " " << name;
        os << " " << file;
        os << " " << line;
        os << " " << startLine;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct funcinl& value)
    {
        return value.PrintTo(os);
    }

    // layout of Itab known to compilers
    // allocated in non-garbage-collected memory
    // Needs to be in sync with
    // ../cmd/compile/internal/reflectdata/reflect.go:/^func.WritePluginTable.
    
    template<typename T> requires gocpp::GoStruct<T>
    itab::operator T()
    {
        T result;
        result.inter = this->inter;
        result._type = this->_type;
        result.hash = this->hash;
        result._1 = this->_1;
        result.fun = this->fun;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool itab::operator==(const T& ref) const
    {
        if (inter != ref.inter) return false;
        if (_type != ref._type) return false;
        if (hash != ref.hash) return false;
        if (_1 != ref._1) return false;
        if (fun != ref.fun) return false;
        return true;
    }

    std::ostream& itab::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << inter;
        os << " " << _type;
        os << " " << hash;
        os << " " << _1;
        os << " " << fun;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct itab& value)
    {
        return value.PrintTo(os);
    }

    // Lock-free stack node.
    // Also known to export_test.go.
    
    template<typename T> requires gocpp::GoStruct<T>
    lfnode::operator T()
    {
        T result;
        result.next = this->next;
        result.pushcnt = this->pushcnt;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool lfnode::operator==(const T& ref) const
    {
        if (next != ref.next) return false;
        if (pushcnt != ref.pushcnt) return false;
        return true;
    }

    std::ostream& lfnode::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << " " << pushcnt;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct lfnode& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    forcegcstate::operator T()
    {
        T result;
        result.lock = this->lock;
        result.g = this->g;
        result.idle = this->idle;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool forcegcstate::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (g != ref.g) return false;
        if (idle != ref.idle) return false;
        return true;
    }

    std::ostream& forcegcstate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << g;
        os << " " << idle;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct forcegcstate& value)
    {
        return value.PrintTo(os);
    }

    // A _defer holds an entry on the list of deferred calls.
    // If you add a field here, add code to clear it in deferProcStack.
    // This struct must match the code in cmd/compile/internal/ssagen/ssa.go:deferstruct
    // and cmd/compile/internal/ssagen/ssa.go:(*state).call.
    // Some defers will be allocated on the stack and some on the heap.
    // All defers are logically part of the stack, so write barriers to
    // initialize them are not required. All defers must be manually scanned,
    // and for heap defers, marked.
    
    template<typename T> requires gocpp::GoStruct<T>
    _defer::operator T()
    {
        T result;
        result.heap = this->heap;
        result.rangefunc = this->rangefunc;
        result.sp = this->sp;
        result.pc = this->pc;
        result.fn = this->fn;
        result.link = this->link;
        result.head = this->head;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool _defer::operator==(const T& ref) const
    {
        if (heap != ref.heap) return false;
        if (rangefunc != ref.rangefunc) return false;
        if (sp != ref.sp) return false;
        if (pc != ref.pc) return false;
        if (fn != ref.fn) return false;
        if (link != ref.link) return false;
        if (head != ref.head) return false;
        return true;
    }

    std::ostream& _defer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heap;
        os << " " << rangefunc;
        os << " " << sp;
        os << " " << pc;
        os << " " << fn;
        os << " " << link;
        os << " " << head;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _defer& value)
    {
        return value.PrintTo(os);
    }

    // A _panic holds information about an active panic.
    //
    // A _panic value must only ever live on the stack.
    //
    // The argp and link fields are stack pointers, but don't need special
    // handling during stack growth: because they are pointer-typed and
    // _panic values only live on the stack, regular stack pointer
    // adjustment takes care of them.
    
    template<typename T> requires gocpp::GoStruct<T>
    _panic::operator T()
    {
        T result;
        result.argp = this->argp;
        result.arg = this->arg;
        result.link = this->link;
        result.startPC = this->startPC;
        result.startSP = this->startSP;
        result.sp = this->sp;
        result.lr = this->lr;
        result.fp = this->fp;
        result.retpc = this->retpc;
        result.deferBitsPtr = this->deferBitsPtr;
        result.slotsPtr = this->slotsPtr;
        result.recovered = this->recovered;
        result.goexit = this->goexit;
        result.deferreturn = this->deferreturn;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool _panic::operator==(const T& ref) const
    {
        if (argp != ref.argp) return false;
        if (arg != ref.arg) return false;
        if (link != ref.link) return false;
        if (startPC != ref.startPC) return false;
        if (startSP != ref.startSP) return false;
        if (sp != ref.sp) return false;
        if (lr != ref.lr) return false;
        if (fp != ref.fp) return false;
        if (retpc != ref.retpc) return false;
        if (deferBitsPtr != ref.deferBitsPtr) return false;
        if (slotsPtr != ref.slotsPtr) return false;
        if (recovered != ref.recovered) return false;
        if (goexit != ref.goexit) return false;
        if (deferreturn != ref.deferreturn) return false;
        return true;
    }

    std::ostream& _panic::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << argp;
        os << " " << arg;
        os << " " << link;
        os << " " << startPC;
        os << " " << startSP;
        os << " " << sp;
        os << " " << lr;
        os << " " << fp;
        os << " " << retpc;
        os << " " << deferBitsPtr;
        os << " " << slotsPtr;
        os << " " << recovered;
        os << " " << goexit;
        os << " " << deferreturn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _panic& value)
    {
        return value.PrintTo(os);
    }

    // savedOpenDeferState tracks the extra state from _panic that's
    // necessary for deferreturn to pick up where gopanic left off,
    // without needing to unwind the stack.
    
    template<typename T> requires gocpp::GoStruct<T>
    savedOpenDeferState::operator T()
    {
        T result;
        result.retpc = this->retpc;
        result.deferBitsOffset = this->deferBitsOffset;
        result.slotsOffset = this->slotsOffset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool savedOpenDeferState::operator==(const T& ref) const
    {
        if (retpc != ref.retpc) return false;
        if (deferBitsOffset != ref.deferBitsOffset) return false;
        if (slotsOffset != ref.slotsOffset) return false;
        return true;
    }

    std::ostream& savedOpenDeferState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << retpc;
        os << " " << deferBitsOffset;
        os << " " << slotsOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct savedOpenDeferState& value)
    {
        return value.PrintTo(os);
    }

    // ancestorInfo records details of where a goroutine was started.
    
    template<typename T> requires gocpp::GoStruct<T>
    ancestorInfo::operator T()
    {
        T result;
        result.pcs = this->pcs;
        result.goid = this->goid;
        result.gopc = this->gopc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ancestorInfo::operator==(const T& ref) const
    {
        if (pcs != ref.pcs) return false;
        if (goid != ref.goid) return false;
        if (gopc != ref.gopc) return false;
        return true;
    }

    std::ostream& ancestorInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pcs;
        os << " " << goid;
        os << " " << gopc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ancestorInfo& value)
    {
        return value.PrintTo(os);
    }

    // A waitReason explains why a goroutine has been stopped.
    // See gopark. Do not re-use waitReasons, add new ones.
    gocpp::array<std::string, 37> waitReasonStrings = gocpp::Init<gocpp::array<std::string, 37>>([](auto& x) {
        x[waitReasonZero] = ""s;
        x[waitReasonGCAssistMarking] = "GC assist marking"s;
        x[waitReasonIOWait] = "IO wait"s;
        x[waitReasonChanReceiveNilChan] = "chan receive (nil chan)"s;
        x[waitReasonChanSendNilChan] = "chan send (nil chan)"s;
        x[waitReasonDumpingHeap] = "dumping heap"s;
        x[waitReasonGarbageCollection] = "garbage collection"s;
        x[waitReasonGarbageCollectionScan] = "garbage collection scan"s;
        x[waitReasonPanicWait] = "panicwait"s;
        x[waitReasonSelect] = "select"s;
        x[waitReasonSelectNoCases] = "select (no cases)"s;
        x[waitReasonGCAssistWait] = "GC assist wait"s;
        x[waitReasonGCSweepWait] = "GC sweep wait"s;
        x[waitReasonGCScavengeWait] = "GC scavenge wait"s;
        x[waitReasonChanReceive] = "chan receive"s;
        x[waitReasonChanSend] = "chan send"s;
        x[waitReasonFinalizerWait] = "finalizer wait"s;
        x[waitReasonForceGCIdle] = "force gc (idle)"s;
        x[waitReasonSemacquire] = "semacquire"s;
        x[waitReasonSleep] = "sleep"s;
        x[waitReasonSyncCondWait] = "sync.Cond.Wait"s;
        x[waitReasonSyncMutexLock] = "sync.Mutex.Lock"s;
        x[waitReasonSyncRWMutexRLock] = "sync.RWMutex.RLock"s;
        x[waitReasonSyncRWMutexLock] = "sync.RWMutex.Lock"s;
        x[waitReasonTraceReaderBlocked] = "trace reader (blocked)"s;
        x[waitReasonWaitForGCCycle] = "wait for GC cycle"s;
        x[waitReasonGCWorkerIdle] = "GC worker (idle)"s;
        x[waitReasonGCWorkerActive] = "GC worker (active)"s;
        x[waitReasonPreempted] = "preempted"s;
        x[waitReasonDebugCall] = "debug call"s;
        x[waitReasonGCMarkTermination] = "GC mark termination"s;
        x[waitReasonStoppingTheWorld] = "stopping the world"s;
        x[waitReasonFlushProcCaches] = "flushing proc caches"s;
        x[waitReasonTraceGoroutineStatus] = "trace goroutine status"s;
        x[waitReasonTraceProcStatus] = "trace proc status"s;
        x[waitReasonPageTraceFlush] = "page trace flush"s;
        x[waitReasonCoroutine] = "coroutine"s;
    });
    std::string rec::String(golang::runtime::waitReason w)
    {
        if(w < 0 || w >= waitReason(len(waitReasonStrings)))
        {
            return "unknown wait reason"s;
        }
        return waitReasonStrings[w];
    }

    bool rec::isMutexWait(golang::runtime::waitReason w)
    {
        return w == waitReasonSyncMutexLock || w == waitReasonSyncRWMutexRLock || w == waitReasonSyncRWMutexLock;
    }

    // allpLock protects P-less reads and size changes of allp, idlepMask,
    // and timerpMask, and all writes to allp.
    // len(allp) == gomaxprocs; may change at safe points, otherwise
    // immutable.
    // Bitmask of Ps in _Pidle list, one bit per P. Reads and writes must
    // be atomic. Length may change at safe points.
    //
    // Each P must update only its own bit. In order to maintain
    // consistency, a P going idle must the idle mask simultaneously with
    // updates to the idle P list under the sched.lock, otherwise a racing
    // pidleget may clear the mask before pidleput sets the mask,
    // corrupting the bitmap.
    //
    // N.B., procresize takes ownership of all Ps in stopTheWorldWithSema.
    // Bitmask of Ps that may have a timer, one bit per P. Reads and writes
    // must be atomic. Length may change at safe points.
    // Pool of GC parked background workers. Entries are type
    // *gcBgMarkWorkerNode.
    // Total number of gcBgMarkWorker goroutines. Protected by worldsema.
    // Information about what cpu features are available.
    // Packages outside the runtime should not use these
    // as they are not an external api.
    // Set on startup in asm_{386,amd64}.s
    // set by cmd/link on arm systems
    runtime::m* allm;
    int32_t gomaxprocs;
    int32_t ncpu;
    forcegcstate forcegc;
    schedt sched;
    int32_t newprocs;
    mutex allpLock;
    gocpp::slice<runtime::p*> allp;
    pMask idlepMask;
    pMask timerpMask;
    runtime::lfstack gcBgMarkWorkerPool;
    int32_t gcBgMarkWorkerCount;
    uint32_t processorVersionInfo;
    bool isIntel;
    uint8_t goarm;
    uint8_t goarmsoftfp;
    // Set by the linker so the runtime can determine the buildmode.
    bool islibrary;
    bool isarchive;
    // Must agree with internal/buildcfg.FramePointerEnabled.
    bool framepointer_enabled = GOARCH == "amd64"s || GOARCH == "arm64"s;
}

