// generated by GoCpp from file '$(ImportDir)/image/image.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/image.fwd.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/image/color/ycbcr.h"
#include "golang/image/geom.h"

namespace golang::image
{
    struct Config
    {
        color::Model ColorModel;
        int Width;
        int Height;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Config& value);
    struct Image : gocpp::Interface
    {
        Image(){}
        Image(Image& i) = default;
        Image(const Image& i) = default;
        Image& operator=(Image& i) = default;
        Image& operator=(const Image& i) = default;

        template<typename T>
        Image(T& ref);

        template<typename T>
        Image(const T& ref);

        template<typename T>
        Image(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IImage
        {
            virtual struct color::Model vColorModel() = 0;
            virtual struct Rectangle vBounds() = 0;
            virtual struct color::Color vAt(int x, int y) = 0;
        };

        template<typename T, typename StoreT>
        struct ImageImpl : IImage
        {
            explicit ImageImpl(T* ptr)
            {
                value.reset(ptr);
            }

            struct color::Model vColorModel() override;

            struct Rectangle vBounds() override;

            struct color::Color vAt(int x, int y) override;

            StoreT value;
        };

        std::shared_ptr<IImage> value;
    };

    namespace rec
    {
        struct color::Model ColorModel(const gocpp::PtrRecv<Image, false>& self);
        struct color::Model ColorModel(const gocpp::ObjRecv<Image>& self);

        struct Rectangle Bounds(const gocpp::PtrRecv<Image, false>& self);
        struct Rectangle Bounds(const gocpp::ObjRecv<Image>& self);

        struct color::Color At(const gocpp::PtrRecv<Image, false>& self, int x, int y);
        struct color::Color At(const gocpp::ObjRecv<Image>& self, int x, int y);
    }

    std::ostream& operator<<(std::ostream& os, const struct Image& value);
    struct RGBA64Image : gocpp::Interface
    {
        RGBA64Image(){}
        RGBA64Image(RGBA64Image& i) = default;
        RGBA64Image(const RGBA64Image& i) = default;
        RGBA64Image& operator=(RGBA64Image& i) = default;
        RGBA64Image& operator=(const RGBA64Image& i) = default;

        template<typename T>
        RGBA64Image(T& ref);

        template<typename T>
        RGBA64Image(const T& ref);

        template<typename T>
        RGBA64Image(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IRGBA64Image
        {
            virtual struct color::RGBA64 vRGBA64At(int x, int y) = 0;
        };

        template<typename T, typename StoreT>
        struct RGBA64ImageImpl : IRGBA64Image
        {
            explicit RGBA64ImageImpl(T* ptr)
            {
                value.reset(ptr);
            }

            struct color::RGBA64 vRGBA64At(int x, int y) override;

            StoreT value;
        };

        std::shared_ptr<IRGBA64Image> value;
    };

    namespace rec
    {
        struct color::RGBA64 RGBA64At(const gocpp::PtrRecv<RGBA64Image, false>& self, int x, int y);
        struct color::RGBA64 RGBA64At(const gocpp::ObjRecv<RGBA64Image>& self, int x, int y);
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64Image& value);
    struct PalettedImage : gocpp::Interface
    {
        PalettedImage(){}
        PalettedImage(PalettedImage& i) = default;
        PalettedImage(const PalettedImage& i) = default;
        PalettedImage& operator=(PalettedImage& i) = default;
        PalettedImage& operator=(const PalettedImage& i) = default;

        template<typename T>
        PalettedImage(T& ref);

        template<typename T>
        PalettedImage(const T& ref);

        template<typename T>
        PalettedImage(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IPalettedImage
        {
            virtual uint8_t vColorIndexAt(int x, int y) = 0;
        };

        template<typename T, typename StoreT>
        struct PalettedImageImpl : IPalettedImage
        {
            explicit PalettedImageImpl(T* ptr)
            {
                value.reset(ptr);
            }

            uint8_t vColorIndexAt(int x, int y) override;

            StoreT value;
        };

        std::shared_ptr<IPalettedImage> value;
    };

    namespace rec
    {
        uint8_t ColorIndexAt(const gocpp::PtrRecv<PalettedImage, false>& self, int x, int y);
        uint8_t ColorIndexAt(const gocpp::ObjRecv<PalettedImage>& self, int x, int y);
    }

    std::ostream& operator<<(std::ostream& os, const struct PalettedImage& value);
    int pixelBufferLength(int bytesPerPixel, struct Rectangle r, std::string imageTypeName);
    struct RGBA
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value);
    struct RGBA* NewRGBA(struct Rectangle r);
    struct RGBA64
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value);
    struct RGBA64* NewRGBA64(struct Rectangle r);
    struct NRGBA
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value);
    struct NRGBA* NewNRGBA(struct Rectangle r);
    struct NRGBA64
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value);
    struct NRGBA64* NewNRGBA64(struct Rectangle r);
    struct Alpha
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value);
    struct Alpha* NewAlpha(struct Rectangle r);
    struct Alpha16
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value);
    struct Alpha16* NewAlpha16(struct Rectangle r);
    struct Gray
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Gray& value);
    struct Gray* NewGray(struct Rectangle r);
    struct Gray16
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value);
    struct Gray16* NewGray16(struct Rectangle r);
    struct CMYK
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value);
    struct CMYK* NewCMYK(struct Rectangle r);
    struct Paletted
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;
        color::Palette Palette;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Paletted& value);
    struct Paletted* NewPaletted(struct Rectangle r, color::Palette p);

    namespace rec
    {
        struct color::Model ColorModel(struct RGBA* p);
        struct Rectangle Bounds(struct RGBA* p);
        struct color::Color At(struct RGBA* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct RGBA* p, int x, int y);
        struct color::RGBA RGBAAt(struct RGBA* p, int x, int y);
        int PixOffset(struct RGBA* p, int x, int y);
        void Set(struct RGBA* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct RGBA* p, int x, int y, struct color::RGBA64 c);
        void SetRGBA(struct RGBA* p, int x, int y, struct color::RGBA c);
        struct Image SubImage(struct RGBA* p, struct Rectangle r);
        bool Opaque(struct RGBA* p);
        struct color::Model ColorModel(struct RGBA64* p);
        struct Rectangle Bounds(struct RGBA64* p);
        struct color::Color At(struct RGBA64* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct RGBA64* p, int x, int y);
        int PixOffset(struct RGBA64* p, int x, int y);
        void Set(struct RGBA64* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct RGBA64* p, int x, int y, struct color::RGBA64 c);
        struct Image SubImage(struct RGBA64* p, struct Rectangle r);
        bool Opaque(struct RGBA64* p);
        struct color::Model ColorModel(struct NRGBA* p);
        struct Rectangle Bounds(struct NRGBA* p);
        struct color::Color At(struct NRGBA* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct NRGBA* p, int x, int y);
        struct color::NRGBA NRGBAAt(struct NRGBA* p, int x, int y);
        int PixOffset(struct NRGBA* p, int x, int y);
        void Set(struct NRGBA* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct NRGBA* p, int x, int y, struct color::RGBA64 c);
        void SetNRGBA(struct NRGBA* p, int x, int y, struct color::NRGBA c);
        struct Image SubImage(struct NRGBA* p, struct Rectangle r);
        bool Opaque(struct NRGBA* p);
        struct color::Model ColorModel(struct NRGBA64* p);
        struct Rectangle Bounds(struct NRGBA64* p);
        struct color::Color At(struct NRGBA64* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct NRGBA64* p, int x, int y);
        struct color::NRGBA64 NRGBA64At(struct NRGBA64* p, int x, int y);
        int PixOffset(struct NRGBA64* p, int x, int y);
        void Set(struct NRGBA64* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct NRGBA64* p, int x, int y, struct color::RGBA64 c);
        void SetNRGBA64(struct NRGBA64* p, int x, int y, struct color::NRGBA64 c);
        struct Image SubImage(struct NRGBA64* p, struct Rectangle r);
        bool Opaque(struct NRGBA64* p);
        struct color::Model ColorModel(struct Alpha* p);
        struct Rectangle Bounds(struct Alpha* p);
        struct color::Color At(struct Alpha* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct Alpha* p, int x, int y);
        struct color::Alpha AlphaAt(struct Alpha* p, int x, int y);
        int PixOffset(struct Alpha* p, int x, int y);
        void Set(struct Alpha* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct Alpha* p, int x, int y, struct color::RGBA64 c);
        void SetAlpha(struct Alpha* p, int x, int y, struct color::Alpha c);
        struct Image SubImage(struct Alpha* p, struct Rectangle r);
        bool Opaque(struct Alpha* p);
        struct color::Model ColorModel(struct Alpha16* p);
        struct Rectangle Bounds(struct Alpha16* p);
        struct color::Color At(struct Alpha16* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct Alpha16* p, int x, int y);
        struct color::Alpha16 Alpha16At(struct Alpha16* p, int x, int y);
        int PixOffset(struct Alpha16* p, int x, int y);
        void Set(struct Alpha16* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct Alpha16* p, int x, int y, struct color::RGBA64 c);
        void SetAlpha16(struct Alpha16* p, int x, int y, struct color::Alpha16 c);
        struct Image SubImage(struct Alpha16* p, struct Rectangle r);
        bool Opaque(struct Alpha16* p);
        struct color::Model ColorModel(struct Gray* p);
        struct Rectangle Bounds(struct Gray* p);
        struct color::Color At(struct Gray* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct Gray* p, int x, int y);
        struct color::Gray GrayAt(struct Gray* p, int x, int y);
        int PixOffset(struct Gray* p, int x, int y);
        void Set(struct Gray* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct Gray* p, int x, int y, struct color::RGBA64 c);
        void SetGray(struct Gray* p, int x, int y, struct color::Gray c);
        struct Image SubImage(struct Gray* p, struct Rectangle r);
        bool Opaque(struct Gray* p);
        struct color::Model ColorModel(struct Gray16* p);
        struct Rectangle Bounds(struct Gray16* p);
        struct color::Color At(struct Gray16* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct Gray16* p, int x, int y);
        struct color::Gray16 Gray16At(struct Gray16* p, int x, int y);
        int PixOffset(struct Gray16* p, int x, int y);
        void Set(struct Gray16* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct Gray16* p, int x, int y, struct color::RGBA64 c);
        void SetGray16(struct Gray16* p, int x, int y, struct color::Gray16 c);
        struct Image SubImage(struct Gray16* p, struct Rectangle r);
        bool Opaque(struct Gray16* p);
        struct color::Model ColorModel(struct CMYK* p);
        struct Rectangle Bounds(struct CMYK* p);
        struct color::Color At(struct CMYK* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct CMYK* p, int x, int y);
        struct color::CMYK CMYKAt(struct CMYK* p, int x, int y);
        int PixOffset(struct CMYK* p, int x, int y);
        void Set(struct CMYK* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct CMYK* p, int x, int y, struct color::RGBA64 c);
        void SetCMYK(struct CMYK* p, int x, int y, struct color::CMYK c);
        struct Image SubImage(struct CMYK* p, struct Rectangle r);
        bool Opaque(struct CMYK* p);
        struct color::Model ColorModel(struct Paletted* p);
        struct Rectangle Bounds(struct Paletted* p);
        struct color::Color At(struct Paletted* p, int x, int y);
        struct color::RGBA64 RGBA64At(struct Paletted* p, int x, int y);
        int PixOffset(struct Paletted* p, int x, int y);
        void Set(struct Paletted* p, int x, int y, struct color::Color c);
        void SetRGBA64(struct Paletted* p, int x, int y, struct color::RGBA64 c);
        uint8_t ColorIndexAt(struct Paletted* p, int x, int y);
        void SetColorIndex(struct Paletted* p, int x, int y, uint8_t index);
        struct Image SubImage(struct Paletted* p, struct Rectangle r);
        bool Opaque(struct Paletted* p);
    }
}

