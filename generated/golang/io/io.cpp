// generated by GoCpp from file '$(ImportDir)/io/io.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/io/io.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/sync/cond.h"
#include "golang/sync/pool.h"

namespace golang::io
{
    namespace rec
    {
        using namespace mocklib::rec;
        using sync::rec::Get;
        using sync::rec::Put;
    }

    gocpp::error ErrShortWrite = errors::New("short write");
    gocpp::error errInvalidWrite = errors::New("invalid write result");
    gocpp::error ErrShortBuffer = errors::New("short buffer");
    gocpp::error go_EOF = errors::New("EOF");
    gocpp::error ErrUnexpectedEOF = errors::New("unexpected EOF");
    gocpp::error ErrNoProgress = errors::New("multiple Read calls return no data or error");
    
    template<typename T>
    Reader::Reader(T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(const T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(T* ptr)
    {
        value.reset(new ReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> Reader::ReaderImpl<T, StoreT>::vRead(gocpp::slice<unsigned char> p)
    {
        return rec::Read(gocpp::PtrRecv<T, false>(value.get()), p);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Read(const gocpp::PtrRecv<struct Reader, false>& self, gocpp::slice<unsigned char> p)
        {
            return self.ptr->value->vRead(p);
        }

        std::tuple<int, struct gocpp::error> Read(const gocpp::ObjRecv<struct Reader>& self, gocpp::slice<unsigned char> p)
        {
            return self.obj.value->vRead(p);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Writer::Writer(T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(const T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(T* ptr)
    {
        value.reset(new WriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> Writer::WriterImpl<T, StoreT>::vWrite(gocpp::slice<unsigned char> p)
    {
        return rec::Write(gocpp::PtrRecv<T, false>(value.get()), p);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Write(const gocpp::PtrRecv<struct Writer, false>& self, gocpp::slice<unsigned char> p)
        {
            return self.ptr->value->vWrite(p);
        }

        std::tuple<int, struct gocpp::error> Write(const gocpp::ObjRecv<struct Writer>& self, gocpp::slice<unsigned char> p)
        {
            return self.obj.value->vWrite(p);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Closer::Closer(T& ref)
    {
        value.reset(new CloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Closer::Closer(const T& ref)
    {
        value.reset(new CloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Closer::Closer(T* ptr)
    {
        value.reset(new CloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Closer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error Closer::CloserImpl<T, StoreT>::vClose()
    {
        return rec::Close(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        struct gocpp::error Close(const gocpp::PtrRecv<struct Closer, false>& self)
        {
            return self.ptr->value->vClose();
        }

        struct gocpp::error Close(const gocpp::ObjRecv<struct Closer>& self)
        {
            return self.obj.value->vClose();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Closer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Seeker::Seeker(T& ref)
    {
        value.reset(new SeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Seeker::Seeker(const T& ref)
    {
        value.reset(new SeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Seeker::Seeker(T* ptr)
    {
        value.reset(new SeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Seeker::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, struct gocpp::error> Seeker::SeekerImpl<T, StoreT>::vSeek(int64_t offset, int whence)
    {
        return rec::Seek(gocpp::PtrRecv<T, false>(value.get()), offset, whence);
    }

    namespace rec
    {
        std::tuple<int64_t, struct gocpp::error> Seek(const gocpp::PtrRecv<struct Seeker, false>& self, int64_t offset, int whence)
        {
            return self.ptr->value->vSeek(offset, whence);
        }

        std::tuple<int64_t, struct gocpp::error> Seek(const gocpp::ObjRecv<struct Seeker>& self, int64_t offset, int whence)
        {
            return self.obj.value->vSeek(offset, whence);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Seeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadWriter::ReadWriter(T& ref)
    {
        value.reset(new ReadWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriter::ReadWriter(const T& ref)
    {
        value.reset(new ReadWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriter::ReadWriter(T* ptr)
    {
        value.reset(new ReadWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadCloser::ReadCloser(T& ref)
    {
        value.reset(new ReadCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadCloser::ReadCloser(const T& ref)
    {
        value.reset(new ReadCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadCloser::ReadCloser(T* ptr)
    {
        value.reset(new ReadCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriteCloser::WriteCloser(T& ref)
    {
        value.reset(new WriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteCloser::WriteCloser(const T& ref)
    {
        value.reset(new WriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteCloser::WriteCloser(T* ptr)
    {
        value.reset(new WriteCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriteCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct WriteCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadWriteCloser::ReadWriteCloser(T& ref)
    {
        value.reset(new ReadWriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteCloser::ReadWriteCloser(const T& ref)
    {
        value.reset(new ReadWriteCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteCloser::ReadWriteCloser(T* ptr)
    {
        value.reset(new ReadWriteCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriteCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriteCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadSeeker::ReadSeeker(T& ref)
    {
        value.reset(new ReadSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeeker::ReadSeeker(const T& ref)
    {
        value.reset(new ReadSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeeker::ReadSeeker(T* ptr)
    {
        value.reset(new ReadSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadSeeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadSeekCloser::ReadSeekCloser(T& ref)
    {
        value.reset(new ReadSeekCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeekCloser::ReadSeekCloser(const T& ref)
    {
        value.reset(new ReadSeekCloserImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadSeekCloser::ReadSeekCloser(T* ptr)
    {
        value.reset(new ReadSeekCloserImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadSeekCloser::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadSeekCloser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriteSeeker::WriteSeeker(T& ref)
    {
        value.reset(new WriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteSeeker::WriteSeeker(const T& ref)
    {
        value.reset(new WriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriteSeeker::WriteSeeker(T* ptr)
    {
        value.reset(new WriteSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriteSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct WriteSeeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(T& ref)
    {
        value.reset(new ReadWriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(const T& ref)
    {
        value.reset(new ReadWriteSeekerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadWriteSeeker::ReadWriteSeeker(T* ptr)
    {
        value.reset(new ReadWriteSeekerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadWriteSeeker::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriteSeeker& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReaderFrom::ReaderFrom(T& ref)
    {
        value.reset(new ReaderFromImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderFrom::ReaderFrom(const T& ref)
    {
        value.reset(new ReaderFromImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderFrom::ReaderFrom(T* ptr)
    {
        value.reset(new ReaderFromImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReaderFrom::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, struct gocpp::error> ReaderFrom::ReaderFromImpl<T, StoreT>::vReadFrom(struct Reader r)
    {
        return rec::ReadFrom(gocpp::PtrRecv<T, false>(value.get()), r);
    }

    namespace rec
    {
        std::tuple<int64_t, struct gocpp::error> ReadFrom(const gocpp::PtrRecv<struct ReaderFrom, false>& self, struct Reader r)
        {
            return self.ptr->value->vReadFrom(r);
        }

        std::tuple<int64_t, struct gocpp::error> ReadFrom(const gocpp::ObjRecv<struct ReaderFrom>& self, struct Reader r)
        {
            return self.obj.value->vReadFrom(r);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ReaderFrom& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriterTo::WriterTo(T& ref)
    {
        value.reset(new WriterToImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterTo::WriterTo(const T& ref)
    {
        value.reset(new WriterToImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterTo::WriterTo(T* ptr)
    {
        value.reset(new WriterToImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriterTo::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int64_t, struct gocpp::error> WriterTo::WriterToImpl<T, StoreT>::vWriteTo(struct Writer w)
    {
        return rec::WriteTo(gocpp::PtrRecv<T, false>(value.get()), w);
    }

    namespace rec
    {
        std::tuple<int64_t, struct gocpp::error> WriteTo(const gocpp::PtrRecv<struct WriterTo, false>& self, struct Writer w)
        {
            return self.ptr->value->vWriteTo(w);
        }

        std::tuple<int64_t, struct gocpp::error> WriteTo(const gocpp::ObjRecv<struct WriterTo>& self, struct Writer w)
        {
            return self.obj.value->vWriteTo(w);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct WriterTo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ReaderAt::ReaderAt(T& ref)
    {
        value.reset(new ReaderAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderAt::ReaderAt(const T& ref)
    {
        value.reset(new ReaderAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReaderAt::ReaderAt(T* ptr)
    {
        value.reset(new ReaderAtImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReaderAt::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> ReaderAt::ReaderAtImpl<T, StoreT>::vReadAt(gocpp::slice<unsigned char> p, int64_t off)
    {
        return rec::ReadAt(gocpp::PtrRecv<T, false>(value.get()), p, off);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> ReadAt(const gocpp::PtrRecv<struct ReaderAt, false>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.ptr->value->vReadAt(p, off);
        }

        std::tuple<int, struct gocpp::error> ReadAt(const gocpp::ObjRecv<struct ReaderAt>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.obj.value->vReadAt(p, off);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ReaderAt& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    WriterAt::WriterAt(T& ref)
    {
        value.reset(new WriterAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterAt::WriterAt(const T& ref)
    {
        value.reset(new WriterAtImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    WriterAt::WriterAt(T* ptr)
    {
        value.reset(new WriterAtImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& WriterAt::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> WriterAt::WriterAtImpl<T, StoreT>::vWriteAt(gocpp::slice<unsigned char> p, int64_t off)
    {
        return rec::WriteAt(gocpp::PtrRecv<T, false>(value.get()), p, off);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> WriteAt(const gocpp::PtrRecv<struct WriterAt, false>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.ptr->value->vWriteAt(p, off);
        }

        std::tuple<int, struct gocpp::error> WriteAt(const gocpp::ObjRecv<struct WriterAt>& self, gocpp::slice<unsigned char> p, int64_t off)
        {
            return self.obj.value->vWriteAt(p, off);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct WriterAt& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ByteReader::ByteReader(T& ref)
    {
        value.reset(new ByteReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteReader::ByteReader(const T& ref)
    {
        value.reset(new ByteReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteReader::ByteReader(T* ptr)
    {
        value.reset(new ByteReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteReader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<unsigned char, struct gocpp::error> ByteReader::ByteReaderImpl<T, StoreT>::vReadByte()
    {
        return rec::ReadByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<unsigned char, struct gocpp::error> ReadByte(const gocpp::PtrRecv<struct ByteReader, false>& self)
        {
            return self.ptr->value->vReadByte();
        }

        std::tuple<unsigned char, struct gocpp::error> ReadByte(const gocpp::ObjRecv<struct ByteReader>& self)
        {
            return self.obj.value->vReadByte();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteReader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ByteScanner::ByteScanner(T& ref)
    {
        value.reset(new ByteScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteScanner::ByteScanner(const T& ref)
    {
        value.reset(new ByteScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteScanner::ByteScanner(T* ptr)
    {
        value.reset(new ByteScannerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteScanner::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error ByteScanner::ByteScannerImpl<T, StoreT>::vUnreadByte()
    {
        return rec::UnreadByte(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        struct gocpp::error UnreadByte(const gocpp::PtrRecv<struct ByteScanner, false>& self)
        {
            return self.ptr->value->vUnreadByte();
        }

        struct gocpp::error UnreadByte(const gocpp::ObjRecv<struct ByteScanner>& self)
        {
            return self.obj.value->vUnreadByte();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteScanner& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    ByteWriter::ByteWriter(T& ref)
    {
        value.reset(new ByteWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteWriter::ByteWriter(const T& ref)
    {
        value.reset(new ByteWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteWriter::ByteWriter(T* ptr)
    {
        value.reset(new ByteWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error ByteWriter::ByteWriterImpl<T, StoreT>::vWriteByte(unsigned char c)
    {
        return rec::WriteByte(gocpp::PtrRecv<T, false>(value.get()), c);
    }

    namespace rec
    {
        struct gocpp::error WriteByte(const gocpp::PtrRecv<struct ByteWriter, false>& self, unsigned char c)
        {
            return self.ptr->value->vWriteByte(c);
        }

        struct gocpp::error WriteByte(const gocpp::ObjRecv<struct ByteWriter>& self, unsigned char c)
        {
            return self.obj.value->vWriteByte(c);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteWriter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    RuneReader::RuneReader(T& ref)
    {
        value.reset(new RuneReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneReader::RuneReader(const T& ref)
    {
        value.reset(new RuneReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneReader::RuneReader(T* ptr)
    {
        value.reset(new RuneReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RuneReader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<gocpp::rune, int, struct gocpp::error> RuneReader::RuneReaderImpl<T, StoreT>::vReadRune()
    {
        return rec::ReadRune(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<gocpp::rune, int, struct gocpp::error> ReadRune(const gocpp::PtrRecv<struct RuneReader, false>& self)
        {
            return self.ptr->value->vReadRune();
        }

        std::tuple<gocpp::rune, int, struct gocpp::error> ReadRune(const gocpp::ObjRecv<struct RuneReader>& self)
        {
            return self.obj.value->vReadRune();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct RuneReader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    RuneScanner::RuneScanner(T& ref)
    {
        value.reset(new RuneScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneScanner::RuneScanner(const T& ref)
    {
        value.reset(new RuneScannerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RuneScanner::RuneScanner(T* ptr)
    {
        value.reset(new RuneScannerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RuneScanner::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error RuneScanner::RuneScannerImpl<T, StoreT>::vUnreadRune()
    {
        return rec::UnreadRune(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        struct gocpp::error UnreadRune(const gocpp::PtrRecv<struct RuneScanner, false>& self)
        {
            return self.ptr->value->vUnreadRune();
        }

        struct gocpp::error UnreadRune(const gocpp::ObjRecv<struct RuneScanner>& self)
        {
            return self.obj.value->vUnreadRune();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct RuneScanner& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    StringWriter::StringWriter(T& ref)
    {
        value.reset(new StringWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    StringWriter::StringWriter(const T& ref)
    {
        value.reset(new StringWriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    StringWriter::StringWriter(T* ptr)
    {
        value.reset(new StringWriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& StringWriter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> StringWriter::StringWriterImpl<T, StoreT>::vWriteString(std::string s)
    {
        return rec::WriteString(gocpp::PtrRecv<T, false>(value.get()), s);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> WriteString(const gocpp::PtrRecv<struct StringWriter, false>& self, std::string s)
        {
            return self.ptr->value->vWriteString(s);
        }

        std::tuple<int, struct gocpp::error> WriteString(const gocpp::ObjRecv<struct StringWriter>& self, std::string s)
        {
            return self.obj.value->vWriteString(s);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct StringWriter& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> WriteString(struct Writer w, std::string s)
    {
        int n;
        struct gocpp::error err;
        if(auto [sw, ok] = gocpp::getValue<StringWriter>(w); ok)
        {
            int n;
            struct gocpp::error err;
            return rec::WriteString(gocpp::recv(sw), s);
        }
        return rec::Write(gocpp::recv(w), gocpp::Tag<gocpp::slice<unsigned char>>()(s));
    }

    std::tuple<int, struct gocpp::error> ReadAtLeast(struct Reader r, gocpp::slice<unsigned char> buf, int min)
    {
        int n;
        struct gocpp::error err;
        if(len(buf) < min)
        {
            int n;
            struct gocpp::error err;
            return {0, ErrShortBuffer};
        }
        for(; n < min && err == nullptr; )
        {
            int n;
            struct gocpp::error err;
            int nn = {};
            std::tie(nn, err) = rec::Read(gocpp::recv(r), buf.make_slice(n));
            n += nn;
        }
        if(n >= min)
        {
            int n;
            struct gocpp::error err;
            err = nullptr;
        }
        else
        if(n > 0 && err == go_EOF)
        {
            int n;
            struct gocpp::error err;
            err = ErrUnexpectedEOF;
        }
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> ReadFull(struct Reader r, gocpp::slice<unsigned char> buf)
    {
        int n;
        struct gocpp::error err;
        return ReadAtLeast(r, buf, len(buf));
    }

    std::tuple<int64_t, struct gocpp::error> CopyN(struct Writer dst, struct Reader src, int64_t n)
    {
        int64_t written;
        struct gocpp::error err;
        std::tie(written, err) = Copy(dst, LimitReader(src, n));
        if(written == n)
        {
            int64_t written;
            struct gocpp::error err;
            return {n, nullptr};
        }
        if(written < n && err == nullptr)
        {
            int64_t written;
            struct gocpp::error err;
            err = go_EOF;
        }
        return {written, err};
    }

    std::tuple<int64_t, struct gocpp::error> Copy(struct Writer dst, struct Reader src)
    {
        int64_t written;
        struct gocpp::error err;
        return copyBuffer(dst, src, nullptr);
    }

    std::tuple<int64_t, struct gocpp::error> CopyBuffer(struct Writer dst, struct Reader src, gocpp::slice<unsigned char> buf)
    {
        int64_t written;
        struct gocpp::error err;
        if(buf != nullptr && len(buf) == 0)
        {
            int64_t written;
            struct gocpp::error err;
            gocpp::panic("empty buffer in CopyBuffer");
        }
        return copyBuffer(dst, src, buf);
    }

    std::tuple<int64_t, struct gocpp::error> copyBuffer(struct Writer dst, struct Reader src, gocpp::slice<unsigned char> buf)
    {
        int64_t written;
        struct gocpp::error err;
        if(auto [wt, ok] = gocpp::getValue<WriterTo>(src); ok)
        {
            int64_t written;
            struct gocpp::error err;
            return rec::WriteTo(gocpp::recv(wt), dst);
        }
        if(auto [rt, ok] = gocpp::getValue<ReaderFrom>(dst); ok)
        {
            int64_t written;
            struct gocpp::error err;
            return rec::ReadFrom(gocpp::recv(rt), src);
        }
        if(buf == nullptr)
        {
            int64_t written;
            struct gocpp::error err;
            auto size = 32 * 1024;
            if(auto [l, ok] = gocpp::getValue<LimitedReader*>(src); ok && int64_t(size) > l->N)
            {
                int64_t written;
                struct gocpp::error err;
                if(l->N < 1)
                {
                    int64_t written;
                    struct gocpp::error err;
                    size = 1;
                }
                else
                {
                    int64_t written;
                    struct gocpp::error err;
                    size = int(l->N);
                }
            }
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        }
        for(; ; )
        {
            int64_t written;
            struct gocpp::error err;
            auto [nr, er] = rec::Read(gocpp::recv(src), buf);
            if(nr > 0)
            {
                int64_t written;
                struct gocpp::error err;
                auto [nw, ew] = rec::Write(gocpp::recv(dst), buf.make_slice(0, nr));
                if(nw < 0 || nr < nw)
                {
                    int64_t written;
                    struct gocpp::error err;
                    nw = 0;
                    if(ew == nullptr)
                    {
                        int64_t written;
                        struct gocpp::error err;
                        ew = errInvalidWrite;
                    }
                }
                written += int64_t(nw);
                if(ew != nullptr)
                {
                    int64_t written;
                    struct gocpp::error err;
                    err = ew;
                    break;
                }
                if(nr != nw)
                {
                    int64_t written;
                    struct gocpp::error err;
                    err = ErrShortWrite;
                    break;
                }
            }
            if(er != nullptr)
            {
                int64_t written;
                struct gocpp::error err;
                if(er != go_EOF)
                {
                    int64_t written;
                    struct gocpp::error err;
                    err = er;
                }
                break;
            }
        }
        return {written, err};
    }

    struct Reader LimitReader(struct Reader r, int64_t n)
    {
        return new LimitedReader {r, n};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    LimitedReader::operator T()
    {
        T result;
        result.R = this->R;
        result.N = this->N;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool LimitedReader::operator==(const T& ref) const
    {
        if (R != ref.R) return false;
        if (N != ref.N) return false;
        return true;
    }

    std::ostream& LimitedReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << N;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LimitedReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct LimitedReader* l, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(l->N <= 0)
        {
            int n;
            struct gocpp::error err;
            return {0, go_EOF};
        }
        if(int64_t(len(p)) > l->N)
        {
            int n;
            struct gocpp::error err;
            p = p.make_slice(0, l->N);
        }
        std::tie(n, err) = rec::Read(gocpp::recv(l->R), p);
        l->N -= int64_t(n);
        return {n, err};
    }

    struct SectionReader* NewSectionReader(struct ReaderAt r, int64_t off, int64_t n)
    {
        int64_t remaining = {};
        auto maxint64 = (1 << 63) - 1;
        if(off <= maxint64 - n)
        {
            remaining = n + off;
        }
        else
        {
            remaining = maxint64;
        }
        return new SectionReader {r, off, off, remaining, n};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SectionReader::operator T()
    {
        T result;
        result.r = this->r;
        result.base = this->base;
        result.off = this->off;
        result.limit = this->limit;
        result.n = this->n;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SectionReader::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (base != ref.base) return false;
        if (off != ref.off) return false;
        if (limit != ref.limit) return false;
        if (n != ref.n) return false;
        return true;
    }

    std::ostream& SectionReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << base;
        os << " " << off;
        os << " " << limit;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SectionReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct SectionReader* s, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(s->off >= s->limit)
        {
            int n;
            struct gocpp::error err;
            return {0, go_EOF};
        }
        if(auto max = s->limit - s->off; int64_t(len(p)) > max)
        {
            int n;
            struct gocpp::error err;
            p = p.make_slice(0, max);
        }
        std::tie(n, err) = rec::ReadAt(gocpp::recv(s->r), p, s->off);
        s->off += int64_t(n);
        return {n, err};
    }

    gocpp::error errWhence = errors::New("Seek: invalid whence");
    gocpp::error errOffset = errors::New("Seek: invalid offset");
    std::tuple<int64_t, struct gocpp::error> rec::Seek(struct SectionReader* s, int64_t offset, int whence)
    {
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            else if(condition == SeekStart) { conditionId = 0; }
            else if(condition == SeekCurrent) { conditionId = 1; }
            else if(condition == SeekEnd) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    return {0, errWhence};
                    break;
                case 0:
                    offset += s->base;
                    break;
                case 1:
                    offset += s->off;
                    break;
                case 2:
                    offset += s->limit;
                    break;
            }
        }
        if(offset < s->base)
        {
            return {0, errOffset};
        }
        s->off = offset;
        return {offset - s->base, nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::ReadAt(struct SectionReader* s, gocpp::slice<unsigned char> p, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(off < 0 || off >= rec::Size(gocpp::recv(s)))
        {
            int n;
            struct gocpp::error err;
            return {0, go_EOF};
        }
        off += s->base;
        if(auto max = s->limit - off; int64_t(len(p)) > max)
        {
            int n;
            struct gocpp::error err;
            p = p.make_slice(0, max);
            std::tie(n, err) = rec::ReadAt(gocpp::recv(s->r), p, off);
            if(err == nullptr)
            {
                int n;
                struct gocpp::error err;
                err = go_EOF;
            }
            return {n, err};
        }
        return rec::ReadAt(gocpp::recv(s->r), p, off);
    }

    int64_t rec::Size(struct SectionReader* s)
    {
        return s->limit - s->base;
    }

    std::tuple<struct ReaderAt, int64_t, int64_t> rec::Outer(struct SectionReader* s)
    {
        struct ReaderAt r;
        int64_t off;
        int64_t n;
        return {s->r, s->base, s->n};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    OffsetWriter::operator T()
    {
        T result;
        result.w = this->w;
        result.base = this->base;
        result.off = this->off;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool OffsetWriter::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (base != ref.base) return false;
        if (off != ref.off) return false;
        return true;
    }

    std::ostream& OffsetWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << base;
        os << " " << off;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct OffsetWriter& value)
    {
        return value.PrintTo(os);
    }

    struct OffsetWriter* NewOffsetWriter(struct WriterAt w, int64_t off)
    {
        return new OffsetWriter {w, off, off};
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct OffsetWriter* o, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::WriteAt(gocpp::recv(o->w), p, o->off);
        o->off += int64_t(n);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> rec::WriteAt(struct OffsetWriter* o, gocpp::slice<unsigned char> p, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(off < 0)
        {
            int n;
            struct gocpp::error err;
            return {0, errOffset};
        }
        off += o->base;
        return rec::WriteAt(gocpp::recv(o->w), p, off);
    }

    std::tuple<int64_t, struct gocpp::error> rec::Seek(struct OffsetWriter* o, int64_t offset, int whence)
    {
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            else if(condition == SeekStart) { conditionId = 0; }
            else if(condition == SeekCurrent) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    return {0, errWhence};
                    break;
                case 0:
                    offset += o->base;
                    break;
                case 1:
                    offset += o->off;
                    break;
            }
        }
        if(offset < o->base)
        {
            return {0, errOffset};
        }
        o->off = offset;
        return {offset - o->base, nullptr};
    }

    struct Reader TeeReader(struct Reader r, struct Writer w)
    {
        return new teeReader {r, w};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    teeReader::operator T()
    {
        T result;
        result.r = this->r;
        result.w = this->w;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool teeReader::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (w != ref.w) return false;
        return true;
    }

    std::ostream& teeReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << w;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct teeReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct teeReader* t, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Read(gocpp::recv(t->r), p);
        if(n > 0)
        {
            int n;
            struct gocpp::error err;
            if(auto [n, err] = rec::Write(gocpp::recv(t->w), p.make_slice(0, n)); err != nullptr)
            {
                int n;
                struct gocpp::error err;
                return {n, err};
            }
        }
        return {n, err};
    }

    Writer Discard = discard {};
    
    template<typename T> requires gocpp::GoStruct<T>
    discard::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool discard::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& discard::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct discard& value)
    {
        return value.PrintTo(os);
    }

    ReaderFrom _ = discard {};
    std::tuple<int, struct gocpp::error> rec::Write(discard, gocpp::slice<unsigned char> p)
    {
        return {len(p), nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::WriteString(discard, std::string s)
    {
        return {len(s), nullptr};
    }

    sync::Pool blackHolePool = gocpp::Init<sync::Pool>([](auto& x) {
        x.New = []() mutable -> go_any
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 8192);
            return & b;
        };
    });
    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(discard, struct Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        auto bufp = gocpp::getValue<[]byte*>(rec::Get(gocpp::recv(blackHolePool)));
        auto readSize = 0;
        for(; ; )
        {
            int64_t n;
            struct gocpp::error err;
            std::tie(readSize, err) = rec::Read(gocpp::recv(r), *bufp);
            n += int64_t(readSize);
            if(err != nullptr)
            {
                int64_t n;
                struct gocpp::error err;
                rec::Put(gocpp::recv(blackHolePool), bufp);
                if(err == go_EOF)
                {
                    int64_t n;
                    struct gocpp::error err;
                    return {n, nullptr};
                }
                return {n, err};
            }
        }
    }

    struct ReadCloser NopCloser(struct Reader r)
    {
        if(auto [gocpp_id_1, ok] = gocpp::getValue<WriterTo>(r); ok)
        {
            return nopCloserWriterTo {r};
        }
        return nopCloser {r};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    nopCloser::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool nopCloser::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& nopCloser::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nopCloser& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp::error rec::Close(nopCloser)
    {
        return nullptr;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    nopCloserWriterTo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool nopCloserWriterTo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& nopCloserWriterTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nopCloserWriterTo& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp::error rec::Close(nopCloserWriterTo)
    {
        return nullptr;
    }

    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct nopCloserWriterTo c, struct Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        return rec::WriteTo(gocpp::recv(gocpp::getValue<WriterTo>(c.Reader)), w);
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadAll(struct Reader r)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 512);
        for(; ; )
        {
            auto [n, err] = rec::Read(gocpp::recv(r), b.make_slice(len(b), cap(b)));
            b = b.make_slice(0, len(b) + n);
            if(err != nullptr)
            {
                if(err == go_EOF)
                {
                    err = nullptr;
                }
                return {b, err};
            }
            if(len(b) == cap(b))
            {
                b = append(b, 0).make_slice(0, len(b));
            }
        }
    }

}

