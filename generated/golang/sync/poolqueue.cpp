// generated by GoCpp from file '$(ImportDir)/sync/poolqueue.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/poolqueue.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/doc.h"
#include "golang/sync/atomic/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
    }

    // poolDequeue is a lock-free fixed-size single-producer,
    // multi-consumer queue. The single producer can both push and pop
    // from the head, and consumers can pop from the tail.
    //
    // It has the added feature that it nils out unused slots to avoid
    // unnecessary retention of objects. This is important for sync.Pool,
    // but not typically a property considered in the literature.
    
    template<typename T> requires gocpp::GoStruct<T>
    poolDequeue::operator T()
    {
        T result;
        result.headTail = this->headTail;
        result.vals = this->vals;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolDequeue::operator==(const T& ref) const
    {
        if (headTail != ref.headTail) return false;
        if (vals != ref.vals) return false;
        return true;
    }

    std::ostream& poolDequeue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << headTail;
        os << " " << vals;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolDequeue& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    eface::operator T()
    {
        T result;
        result.typ = this->typ;
        result.val = this->val;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool eface::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (val != ref.val) return false;
        return true;
    }

    std::ostream& eface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << val;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct eface& value)
    {
        return value.PrintTo(os);
    }

    // dequeueLimit is the maximum size of a poolDequeue.
    //
    // This must be at most (1<<dequeueBits)/2 because detecting fullness
    // depends on wrapping around the ring buffer without wrapping around
    // the index. We divide by 4 so this fits in an int on 32-bit.
    struct gocpp_id_0
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // dequeueNil is used in poolDequeue to represent interface{}(nil).
    // Since we use nil to represent empty slots, we need a sentinel value
    // to represent nil.
    std::tuple<uint32_t, uint32_t> rec::unpack(struct poolDequeue* d, uint64_t ptrs)
    {
        uint32_t head;
        uint32_t tail;
        auto mask = (1 << dequeueBits) - 1;
        head = uint32_t((ptrs >> dequeueBits) & mask);
        tail = uint32_t(ptrs & mask);
        return {head, tail};
    }

    uint64_t rec::pack(struct poolDequeue* d, uint32_t head, uint32_t tail)
    {
        auto mask = (1 << dequeueBits) - 1;
        return (uint64_t(head) << dequeueBits) | uint64_t(tail & mask);
    }

    // pushHead adds val at the head of the queue. It returns false if the
    // queue is full. It must only be called by a single producer.
    bool rec::pushHead(struct poolDequeue* d, go_any val)
    {
        auto ptrs = rec::Load(gocpp::recv(d->headTail));
        auto [head, tail] = rec::unpack(gocpp::recv(d), ptrs);
        if((tail + uint32_t(len(d->vals))) & ((1 << dequeueBits) - 1) == head)
        {
            return false;
        }
        auto slot = & d->vals[head & uint32_t(len(d->vals) - 1)];
        auto typ = atomic::LoadPointer(& slot->typ);
        if(typ != nullptr)
        {
            return false;
        }
        if(val == nullptr)
        {
            val = dequeueNil(nullptr);
        }
        *(go_any*)(unsafe::Pointer(slot)) = val;
        rec::Add(gocpp::recv(d->headTail), 1 << dequeueBits);
        return true;
    }

    // popHead removes and returns the element at the head of the queue.
    // It returns false if the queue is empty. It must only be called by a
    // single producer.
    std::tuple<go_any, bool> rec::popHead(struct poolDequeue* d)
    {
        eface* slot = {};
        for(; ; )
        {
            auto ptrs = rec::Load(gocpp::recv(d->headTail));
            auto [head, tail] = rec::unpack(gocpp::recv(d), ptrs);
            if(tail == head)
            {
                return {nullptr, false};
            }
            head--;
            auto ptrs2 = rec::pack(gocpp::recv(d), head, tail);
            if(rec::CompareAndSwap(gocpp::recv(d->headTail), ptrs, ptrs2))
            {
                slot = & d->vals[head & uint32_t(len(d->vals) - 1)];
                break;
            }
        }
        auto val = *(go_any*)(unsafe::Pointer(slot));
        if(val == dequeueNil(nullptr))
        {
            val = nullptr;
        }
        *slot = eface {};
        return {val, true};
    }

    // popTail removes and returns the element at the tail of the queue.
    // It returns false if the queue is empty. It may be called by any
    // number of consumers.
    std::tuple<go_any, bool> rec::popTail(struct poolDequeue* d)
    {
        eface* slot = {};
        for(; ; )
        {
            auto ptrs = rec::Load(gocpp::recv(d->headTail));
            auto [head, tail] = rec::unpack(gocpp::recv(d), ptrs);
            if(tail == head)
            {
                return {nullptr, false};
            }
            auto ptrs2 = rec::pack(gocpp::recv(d), head, tail + 1);
            if(rec::CompareAndSwap(gocpp::recv(d->headTail), ptrs, ptrs2))
            {
                slot = & d->vals[tail & uint32_t(len(d->vals) - 1)];
                break;
            }
        }
        auto val = *(go_any*)(unsafe::Pointer(slot));
        if(val == dequeueNil(nullptr))
        {
            val = nullptr;
        }
        slot->val = nullptr;
        atomic::StorePointer(& slot->typ, nullptr);
        return {val, true};
    }

    // poolChain is a dynamically-sized version of poolDequeue.
    //
    // This is implemented as a doubly-linked list queue of poolDequeues
    // where each dequeue is double the size of the previous one. Once a
    // dequeue fills up, this allocates a new one and only ever pushes to
    // the latest dequeue. Pops happen from the other end of the list and
    // once a dequeue is exhausted, it gets removed from the list.
    
    template<typename T> requires gocpp::GoStruct<T>
    poolChain::operator T()
    {
        T result;
        result.head = this->head;
        result.tail = this->tail;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolChain::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        if (tail != ref.tail) return false;
        return true;
    }

    std::ostream& poolChain::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolChain& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    poolChainElt::operator T()
    {
        T result;
        result.poolDequeue = this->poolDequeue;
        result.next = this->next;
        result.prev = this->prev;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolChainElt::operator==(const T& ref) const
    {
        if (poolDequeue != ref.poolDequeue) return false;
        if (next != ref.next) return false;
        if (prev != ref.prev) return false;
        return true;
    }

    std::ostream& poolChainElt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << poolDequeue;
        os << " " << next;
        os << " " << prev;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolChainElt& value)
    {
        return value.PrintTo(os);
    }

    void storePoolChainElt(struct poolChainElt** pp, struct poolChainElt* v)
    {
        atomic::StorePointer((unsafe::Pointer*)(unsafe::Pointer(pp)), unsafe::Pointer(v));
    }

    struct poolChainElt* loadPoolChainElt(struct poolChainElt** pp)
    {
        return (poolChainElt*)(atomic::LoadPointer((unsafe::Pointer*)(unsafe::Pointer(pp))));
    }

    void rec::pushHead(struct poolChain* c, go_any val)
    {
        auto d = c->head;
        if(d == nullptr)
        {
            // Initialize the chain.
            auto initSize = 8;
            d = new(poolChainElt);
            d->vals = gocpp::make(gocpp::Tag<gocpp::slice<eface>>(), initSize);
            c->head = d;
            storePoolChainElt(& c->tail, d);
        }
        if(rec::pushHead(gocpp::recv(d), val))
        {
            return;
        }
        auto newSize = len(d->vals) * 2;
        if(newSize >= dequeueLimit)
        {
            newSize = dequeueLimit;
        }
        auto d2 = gocpp::InitPtr<poolChainElt>([=](auto& x) {
            x.prev = d;
        });
        d2->vals = gocpp::make(gocpp::Tag<gocpp::slice<eface>>(), newSize);
        c->head = d2;
        storePoolChainElt(& d->next, d2);
        rec::pushHead(gocpp::recv(d2), val);
    }

    std::tuple<go_any, bool> rec::popHead(struct poolChain* c)
    {
        auto d = c->head;
        for(; d != nullptr; )
        {
            if(auto [val, ok] = rec::popHead(gocpp::recv(d)); ok)
            {
                return {val, ok};
            }
            d = loadPoolChainElt(& d->prev);
        }
        return {nullptr, false};
    }

    std::tuple<go_any, bool> rec::popTail(struct poolChain* c)
    {
        auto d = loadPoolChainElt(& c->tail);
        if(d == nullptr)
        {
            return {nullptr, false};
        }
        for(; ; )
        {
            auto d2 = loadPoolChainElt(& d->next);
            if(auto [val, ok] = rec::popTail(gocpp::recv(d)); ok)
            {
                return {val, ok};
            }
            if(d2 == nullptr)
            {
                return {nullptr, false};
            }
            if(atomic::CompareAndSwapPointer((unsafe::Pointer*)(unsafe::Pointer(& c->tail)), unsafe::Pointer(d), unsafe::Pointer(d2)))
            {
                storePoolChainElt(& d2->prev, nullptr);
            }
            d = d2;
        }
    }

}

