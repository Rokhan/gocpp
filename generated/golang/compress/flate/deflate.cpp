// generated by GoCpp from file '$(ImportDir)/compress/flate/deflate.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/deflate.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/token.h"
#include "golang/errors/errors.h"
#include "golang/fmt/errors.h"
// #include "golang/io/io.h"  [Ignored, known errors]
#include "golang/math/const.h"

namespace golang::flate
{
    int NoCompression = 0;
    int BestSpeed = 1;
    int BestCompression = 9;
    int DefaultCompression = - 1;
    int HuffmanOnly = - 2;
    int logWindowSize = 15;
    int windowSize = 1 << logWindowSize;
    int windowMask = windowSize - 1;
    int baseMatchLength = 3;
    int minMatchLength = 4;
    int maxMatchLength = 258;
    int baseMatchOffset = 1;
    int maxMatchOffset = 1 << 15;
    int maxFlateBlockTokens = 1 << 14;
    int maxStoreBlockSize = 65535;
    int hashBits = 17;
    int hashSize = 1 << hashBits;
    int hashMask = (1 << hashBits) - 1;
    int maxHashOffset = 1 << 24;
    int skipNever = math::MaxInt32;
    
    std::ostream& compressionLevel::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << level;
        os << " " << good;
        os << " " << lazy;
        os << " " << nice;
        os << " " << chain;
        os << " " << fastSkipHashing;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const compressionLevel& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<compressionLevel> levels = gocpp::slice<compressionLevel> { {0, 0, 0, 0, 0, 0},  {1, 0, 0, 0, 0, 0},  {2, 4, 0, 16, 8, 5},  {3, 4, 0, 32, 32, 6},  {4, 4, 4, 16, 16, skipNever},  {5, 8, 16, 32, 32, skipNever},  {6, 8, 16, 128, 128, skipNever},  {7, 8, 32, 128, 256, skipNever},  {8, 32, 128, 258, 1024, skipNever},  {9, 32, 258, 258, 4096, skipNever}};
    
    std::ostream& compressor::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << bulkHasher;
        os << " " << fill;
        os << " " << step;
        os << " " << sync;
        os << " " << bestSpeed;
        os << " " << chainHead;
        os << " " << hashHead;
        os << " " << hashPrev;
        os << " " << hashOffset;
        os << " " << index;
        os << " " << window;
        os << " " << windowEnd;
        os << " " << blockStart;
        os << " " << byteAvailable;
        os << " " << tokens;
        os << " " << length;
        os << " " << offset;
        os << " " << maxInsertIndex;
        os << " " << err;
        os << " " << hashMatch;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const compressor& value)
    {
        return value.PrintTo(os);
    }

    int fillDeflate(compressor* d, gocpp::slice<unsigned char> b)
    {
        if(d->index >= 2 * windowSize - (minMatchLength + maxMatchLength))
        {
            copy(d->window, d->window.make_slice(windowSize, 2 * windowSize));
            d->index -= windowSize;
            d->windowEnd -= windowSize;
            if(d->blockStart >= windowSize)
            {
                d->blockStart -= windowSize;
            }
            else
            {
                d->blockStart = math::MaxInt32;
            }
            d->hashOffset += windowSize;
            if(d->hashOffset > maxHashOffset)
            {
                auto delta = d->hashOffset - 1;
                d->hashOffset -= delta;
                d->chainHead -= delta;
                for(auto [i, v] : d->hashPrev.make_slice(0, ))
                {
                    if(int(v) > delta)
                    {
                        d->hashPrev[i] = uint32_t(int(v) - delta);
                    }
                    else
                    {
                        d->hashPrev[i] = 0;
                    }
                }
                for(auto [i, v] : d->hashHead.make_slice(0, ))
                {
                    if(int(v) > delta)
                    {
                        d->hashHead[i] = uint32_t(int(v) - delta);
                    }
                    else
                    {
                        d->hashHead[i] = 0;
                    }
                }
            }
        }
        auto n = copy(d->window.make_slice(d->windowEnd), b);
        d->windowEnd += n;
        return n;
    }

    std::string writeBlock(compressor* d, gocpp::slice<token> tokens, int index)
    {
        if(index > 0)
        {
            gocpp::slice<unsigned char> window = {};
            if(d->blockStart <= index)
            {
                window = d->window.make_slice(d->blockStart, index);
            }
            d->blockStart = index;
            writeBlock(gocpp::recv(d->w), tokens, false, window);
            return d->w->err;
        }
        return nullptr;
    }

    void fillWindow(compressor* d, gocpp::slice<unsigned char> b)
    {
        if(d->compressionLevel.level < 2)
        {
            return;
        }
        if(d->index != 0 || d->windowEnd != 0)
        {
            gocpp::panic("internal error: fillWindow called with stale data");
        }
        if(len(b) > windowSize)
        {
            b = b.make_slice(len(b) - windowSize);
        }
        auto n = copy(d->window, b);
        auto loops = (n + 256 - minMatchLength) / 256;
        for(auto j = 0; j < loops; j++)
        {
            auto index = j * 256;
            auto end = index + 256 + minMatchLength - 1;
            if(end > n)
            {
                end = n;
            }
            auto toCheck = d->window.make_slice(index, end);
            auto dstSize = len(toCheck) - minMatchLength + 1;
            if(dstSize <= 0)
            {
                continue;
            }
            auto dst = d->hashMatch.make_slice(0, dstSize);
            bulkHasher(gocpp::recv(d), toCheck, dst);
            for(auto [i, val] : dst)
            {
                auto di = i + index;
                auto hh = & d->hashHead[val & hashMask];
                d->hashPrev[di & windowMask] = *hh;
                *hh = uint32_t(di + d->hashOffset);
            }
        }
        d->windowEnd = n;
        d->index = n;
    }

    std::tuple<int, int, bool> findMatch(compressor* d, int pos, int prevHead, int prevLength, int lookahead)
    {
        int length;
        int offset;
        bool ok;
        auto minMatchLook = maxMatchLength;
        if(lookahead < minMatchLook)
        {
            int length;
            int offset;
            bool ok;
            minMatchLook = lookahead;
        }
        auto win = d->window.make_slice(0, pos + minMatchLook);
        auto nice = len(win) - pos;
        if(d->nice < nice)
        {
            int length;
            int offset;
            bool ok;
            nice = d->nice;
        }
        auto tries = d->chain;
        length = prevLength;
        if(length >= d->good)
        {
            int length;
            int offset;
            bool ok;
            tries >>= 2;
        }
        auto wEnd = win[pos + length];
        auto wPos = win.make_slice(pos);
        auto minIndex = pos - windowSize;
        for(auto i = prevHead; tries > 0; tries--)
        {
            int length;
            int offset;
            bool ok;
            if(wEnd == win[i + length])
            {
                int length;
                int offset;
                bool ok;
                auto n = matchLen(win.make_slice(i), wPos, minMatchLook);
                if(n > length && (n > minMatchLength || pos - i <= 4096))
                {
                    int length;
                    int offset;
                    bool ok;
                    length = n;
                    offset = pos - i;
                    ok = true;
                    if(n >= nice)
                    {
                        int length;
                        int offset;
                        bool ok;
                        break;
                    }
                    wEnd = win[pos + n];
                }
            }
            if(i == minIndex)
            {
                int length;
                int offset;
                bool ok;
                break;
            }
            i = int(d->hashPrev[i & windowMask]) - d->hashOffset;
            if(i < minIndex || i < 0)
            {
                int length;
                int offset;
                bool ok;
                break;
            }
        }
        return {length, offset, ok};
    }

    std::string writeStoredBlock(compressor* d, gocpp::slice<unsigned char> buf)
    {
        if(writeStoredHeader(gocpp::recv(d->w), len(buf), false); d->w->err != nullptr)
        {
            return d->w->err;
        }
        writeBytes(gocpp::recv(d->w), buf);
        return d->w->err;
    }

    int hashmul = 0x1e35a7bd;
    uint32_t hash4(gocpp::slice<unsigned char> b)
    {
        return ((uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24)) * hashmul) >> (32 - hashBits);
    }

    void bulkHash4(gocpp::slice<unsigned char> b, gocpp::slice<uint32_t> dst)
    {
        if(len(b) < minMatchLength)
        {
            return;
        }
        auto hb = uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
        dst[0] = (hb * hashmul) >> (32 - hashBits);
        auto end = len(b) - minMatchLength + 1;
        for(auto i = 1; i < end; i++)
        {
            hb = (hb << 8) | uint32_t(b[i + 3]);
            dst[i] = (hb * hashmul) >> (32 - hashBits);
        }
    }

    int matchLen(gocpp::slice<unsigned char> a, gocpp::slice<unsigned char> b, int max)
    {
        a = a.make_slice(0, max);
        b = b.make_slice(0, len(a));
        for(auto [i, av] : a)
        {
            if(b[i] != av)
            {
                return i;
            }
        }
        return max;
    }

    void encSpeed(compressor* d)
    {
        if(d->windowEnd < maxStoreBlockSize)
        {
            if(! d->sync)
            {
                return;
            }
            if(d->windowEnd < 128)
            {
                //Go switch emulation
                {
                    int conditionId = -1;
                    if(d->windowEnd == 0) { conditionId = 0; }
                    else if(d->windowEnd <= 16) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                            return;
                            break;
                        case 1:
                            d->err = writeStoredBlock(gocpp::recv(d), d->window.make_slice(0, d->windowEnd));
                            break;
                        default:
                            writeBlockHuff(gocpp::recv(d->w), false, d->window.make_slice(0, d->windowEnd));
                            d->err = d->w->err;
                            break;
                    }
                }
                d->windowEnd = 0;
                reset(gocpp::recv(d->bestSpeed));
                return;
            }
        }
        d->tokens = encode(gocpp::recv(d->bestSpeed), d->tokens.make_slice(0, 0), d->window.make_slice(0, d->windowEnd));
        if(len(d->tokens) > d->windowEnd - (d->windowEnd >> 4))
        {
            writeBlockHuff(gocpp::recv(d->w), false, d->window.make_slice(0, d->windowEnd));
        }
        else
        {
            writeBlockDynamic(gocpp::recv(d->w), d->tokens, false, d->window.make_slice(0, d->windowEnd));
        }
        d->err = d->w->err;
        d->windowEnd = 0;
    }

    void initDeflate(compressor* d)
    {
        d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 2 * windowSize);
        d->hashOffset = 1;
        d->tokens = gocpp::make(gocpp::Tag<gocpp::slice<token>>(), 0, maxFlateBlockTokens + 1);
        d->length = minMatchLength - 1;
        d->offset = 0;
        d->byteAvailable = false;
        d->index = 0;
        d->chainHead = - 1;
        d->bulkHasher = bulkHash4;
    }

    void deflate(compressor* d)
    {
        if(d->windowEnd - d->index < minMatchLength + maxMatchLength && ! d->sync)
        {
            return;
        }
        d->maxInsertIndex = d->windowEnd - (minMatchLength - 1);
        for(; ; )
        {
            if(d->index > d->windowEnd)
            {
                gocpp::panic("index > windowEnd");
            }
            auto lookahead = d->windowEnd - d->index;
            if(lookahead < minMatchLength + maxMatchLength)
            {
                if(! d->sync)
                {
                    goto Loop_break;
                }
                if(d->index > d->windowEnd)
                {
                    gocpp::panic("index > windowEnd");
                }
                if(lookahead == 0)
                {
                    if(d->byteAvailable)
                    {
                        d->tokens = append(d->tokens, literalToken(uint32_t(d->window[d->index - 1])));
                        d->byteAvailable = false;
                    }
                    if(len(d->tokens) > 0)
                    {
                        if(d->err = writeBlock(gocpp::recv(d), d->tokens, d->index); d->err != nullptr)
                        {
                            return;
                        }
                        d->tokens = d->tokens.make_slice(0, 0);
                    }
                    goto Loop_break;
                }
            }
            if(d->index < d->maxInsertIndex)
            {
                auto hash = hash4(d->window.make_slice(d->index, d->index + minMatchLength));
                auto hh = & d->hashHead[hash & hashMask];
                d->chainHead = int(*hh);
                d->hashPrev[d->index & windowMask] = uint32_t(d->chainHead);
                *hh = uint32_t(d->index + d->hashOffset);
            }
            auto prevLength = d->length;
            auto prevOffset = d->offset;
            d->length = minMatchLength - 1;
            d->offset = 0;
            auto minIndex = d->index - windowSize;
            if(minIndex < 0)
            {
                minIndex = 0;
            }
            if(d->chainHead - d->hashOffset >= minIndex && (d->fastSkipHashing != skipNever && lookahead > minMatchLength - 1 || d->fastSkipHashing == skipNever && lookahead > prevLength && prevLength < d->lazy))
            {
                if(auto [newLength, newOffset, ok] = findMatch(gocpp::recv(d), d->index, d->chainHead - d->hashOffset, minMatchLength - 1, lookahead); ok)
                {
                    d->length = newLength;
                    d->offset = newOffset;
                }
            }
            if(d->fastSkipHashing != skipNever && d->length >= minMatchLength || d->fastSkipHashing == skipNever && prevLength >= minMatchLength && d->length <= prevLength)
            {
                if(d->fastSkipHashing != skipNever)
                {
                    d->tokens = append(d->tokens, matchToken(uint32_t(d->length - baseMatchLength), uint32_t(d->offset - baseMatchOffset)));
                }
                else
                {
                    d->tokens = append(d->tokens, matchToken(uint32_t(prevLength - baseMatchLength), uint32_t(prevOffset - baseMatchOffset)));
                }
                if(d->length <= d->fastSkipHashing)
                {
                    int newIndex = {};
                    if(d->fastSkipHashing != skipNever)
                    {
                        newIndex = d->index + d->length;
                    }
                    else
                    {
                        newIndex = d->index + prevLength - 1;
                    }
                    auto index = d->index;
                    for(index++; index < newIndex; index++)
                    {
                        if(index < d->maxInsertIndex)
                        {
                            auto hash = hash4(d->window.make_slice(index, index + minMatchLength));
                            auto hh = & d->hashHead[hash & hashMask];
                            d->hashPrev[index & windowMask] = *hh;
                            *hh = uint32_t(index + d->hashOffset);
                        }
                    }
                    d->index = index;
                    if(d->fastSkipHashing == skipNever)
                    {
                        d->byteAvailable = false;
                        d->length = minMatchLength - 1;
                    }
                }
                else
                {
                    d->index += d->length;
                }
                if(len(d->tokens) == maxFlateBlockTokens)
                {
                    if(d->err = writeBlock(gocpp::recv(d), d->tokens, d->index); d->err != nullptr)
                    {
                        return;
                    }
                    d->tokens = d->tokens.make_slice(0, 0);
                }
            }
            else
            {
                if(d->fastSkipHashing != skipNever || d->byteAvailable)
                {
                    auto i = d->index - 1;
                    if(d->fastSkipHashing != skipNever)
                    {
                        i = d->index;
                    }
                    d->tokens = append(d->tokens, literalToken(uint32_t(d->window[i])));
                    if(len(d->tokens) == maxFlateBlockTokens)
                    {
                        if(d->err = writeBlock(gocpp::recv(d), d->tokens, i + 1); d->err != nullptr)
                        {
                            return;
                        }
                        d->tokens = d->tokens.make_slice(0, 0);
                    }
                }
                d->index++;
                if(d->fastSkipHashing == skipNever)
                {
                    d->byteAvailable = true;
                }
            }
            if(false) {
            Loop_continue:
                continue;
            Loop_break:
                break;
            }
        }
    }

    int fillStore(compressor* d, gocpp::slice<unsigned char> b)
    {
        auto n = copy(d->window.make_slice(d->windowEnd), b);
        d->windowEnd += n;
        return n;
    }

    void store(compressor* d)
    {
        if(d->windowEnd > 0 && (d->windowEnd == maxStoreBlockSize || d->sync))
        {
            d->err = writeStoredBlock(gocpp::recv(d), d->window.make_slice(0, d->windowEnd));
            d->windowEnd = 0;
        }
    }

    void storeHuff(compressor* d)
    {
        if(d->windowEnd < len(d->window) && ! d->sync || d->windowEnd == 0)
        {
            return;
        }
        writeBlockHuff(gocpp::recv(d->w), false, d->window.make_slice(0, d->windowEnd));
        d->err = d->w->err;
        d->windowEnd = 0;
    }

    std::tuple<int, std::string> write(compressor* d, gocpp::slice<unsigned char> b)
    {
        int n;
        std::string err;
        if(d->err != nullptr)
        {
            int n;
            std::string err;
            return {0, d->err};
        }
        n = len(b);
        for(; len(b) > 0; )
        {
            int n;
            std::string err;
            step(gocpp::recv(d), d);
            b = b.make_slice(fill(gocpp::recv(d), d, b));
            if(d->err != nullptr)
            {
                int n;
                std::string err;
                return {0, d->err};
            }
        }
        return {n, nullptr};
    }

    std::string syncFlush(compressor* d)
    {
        if(d->err != nullptr)
        {
            return d->err;
        }
        d->sync = true;
        step(gocpp::recv(d), d);
        if(d->err == nullptr)
        {
            writeStoredHeader(gocpp::recv(d->w), 0, false);
            flush(gocpp::recv(d->w));
            d->err = d->w->err;
        }
        d->sync = false;
        return d->err;
    }

    std::string init(compressor* d, io::Writer w, int level)
    {
        std::string err;
        d->w = newHuffmanBitWriter(w);
        //Go switch emulation
        {
            int conditionId = -1;
            if(level == NoCompression) { conditionId = 0; }
            else if(level == HuffmanOnly) { conditionId = 1; }
            else if(level == BestSpeed) { conditionId = 2; }
            else if(level == DefaultCompression) { conditionId = 3; }
            else if(2 <= level && level <= 9) { conditionId = 4; }
            switch(conditionId)
            {
                std::string err;
                case 0:
                    d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), maxStoreBlockSize);
                    d->fill = (*compressor)->fillStore;
                    d->step = (*compressor)->store;
                    break;
                case 1:
                    d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), maxStoreBlockSize);
                    d->fill = (*compressor)->fillStore;
                    d->step = (*compressor)->storeHuff;
                    break;
                case 2:
                    d->compressionLevel = levels[level];
                    d->window = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), maxStoreBlockSize);
                    d->fill = (*compressor)->fillStore;
                    d->step = (*compressor)->encSpeed;
                    d->bestSpeed = newDeflateFast();
                    d->tokens = gocpp::make(gocpp::Tag<gocpp::slice<token>>(), maxStoreBlockSize);
                    break;
                case 3:
                    level = 6;
                case 4:
                    d->compressionLevel = levels[level];
                    initDeflate(gocpp::recv(d));
                    d->fill = (*compressor)->fillDeflate;
                    d->step = (*compressor)->deflate;
                    break;
                default:
                    return fmt::Errorf("flate: invalid compression level %d: want value in range [-2, 9]", level);
                    break;
            }
        }
        return nullptr;
    }

    void reset(compressor* d, io::Writer w)
    {
        reset(gocpp::recv(d->w), w);
        d->sync = false;
        d->err = nullptr;
        //Go switch emulation
        {
            auto condition = d->compressionLevel.level;
            int conditionId = -1;
            if(condition == NoCompression) { conditionId = 0; }
            else if(condition == BestSpeed) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    d->windowEnd = 0;
                    break;
                case 1:
                    d->windowEnd = 0;
                    d->tokens = d->tokens.make_slice(0, 0);
                    reset(gocpp::recv(d->bestSpeed));
                    break;
                default:
                    d->chainHead = - 1;
                    for(auto [i, gocpp_ignored] : d->hashHead)
                    {
                        d->hashHead[i] = 0;
                    }
                    for(auto [i, gocpp_ignored] : d->hashPrev)
                    {
                        d->hashPrev[i] = 0;
                    }
                    d->hashOffset = 1;
                    std::tie(d->index, d->windowEnd) = std::tuple{0, 0};
                    std::tie(d->blockStart, d->byteAvailable) = std::tuple{0, false};
                    d->tokens = d->tokens.make_slice(0, 0);
                    d->length = minMatchLength - 1;
                    d->offset = 0;
                    d->maxInsertIndex = 0;
                    break;
            }
        }
    }

    std::string close(compressor* d)
    {
        if(d->err == errWriterClosed)
        {
            return nullptr;
        }
        if(d->err != nullptr)
        {
            return d->err;
        }
        d->sync = true;
        step(gocpp::recv(d), d);
        if(d->err != nullptr)
        {
            return d->err;
        }
        if(writeStoredHeader(gocpp::recv(d->w), 0, true); d->w->err != nullptr)
        {
            return d->w->err;
        }
        flush(gocpp::recv(d->w));
        if(d->w->err != nullptr)
        {
            return d->w->err;
        }
        d->err = errWriterClosed;
        return nullptr;
    }

    std::tuple<Writer*, std::string> NewWriter(io::Writer w, int level)
    {
        Writer dw = {};
        if(auto err = init(gocpp::recv(dw.d), w, level); err != nullptr)
        {
            return {nullptr, err};
        }
        return {& dw, nullptr};
    }

    std::tuple<Writer*, std::string> NewWriterDict(io::Writer w, int level, gocpp::slice<unsigned char> dict)
    {
        auto dw = new dictWriter {w};
        auto [zw, err] = NewWriter(dw, level);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        fillWindow(gocpp::recv(zw->d), dict);
        zw->dict = append(zw->dict, dict);
        return {zw, err};
    }

    
    std::ostream& dictWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const dictWriter& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> Write(dictWriter* w, gocpp::slice<unsigned char> b)
    {
        int n;
        std::string err;
        return Write(gocpp::recv(w->w), b);
    }

    std::string errWriterClosed = New(gocpp::recv(errors), "flate: closed writer");
    
    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << d;
        os << " " << dict;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const Writer& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> Write(Writer* w, gocpp::slice<unsigned char> data)
    {
        int n;
        std::string err;
        return write(gocpp::recv(w->d), data);
    }

    std::string Flush(Writer* w)
    {
        return syncFlush(gocpp::recv(w->d));
    }

    std::string Close(Writer* w)
    {
        return close(gocpp::recv(w->d));
    }

    void Reset(Writer* w, io::Writer dst)
    {
        if(auto [dw, ok] = gocpp::getValue<flate.dictWriter*>(w->d.w->writer); ok)
        {
            dw->w = dst;
            reset(gocpp::recv(w->d), dw);
            fillWindow(gocpp::recv(w->d), w->dict);
        }
        else
        {
            reset(gocpp::recv(w->d), dst);
        }
    }

}

