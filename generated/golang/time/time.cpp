// generated by GoCpp from file '$(ImportDir)/time/time.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/time.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/time/format.h"
#include "golang/time/format_rfc3339.h"
#include "golang/time/zoneinfo.h"

// Package time provides functionality for measuring and displaying time.
//
// The calendrical calculations always assume a Gregorian calendar, with
// no leap seconds.
//
// # Monotonic Clocks
//
// Operating systems provide both a “wall clock,” which is subject to
// changes for clock synchronization, and a “monotonic clock,” which is
// not. The general rule is that the wall clock is for telling time and
// the monotonic clock is for measuring time. Rather than split the API,
// in this package the Time returned by time.Now contains both a wall
// clock reading and a monotonic clock reading; later time-telling
// operations use the wall clock reading, but later time-measuring
// operations, specifically comparisons and subtractions, use the
// monotonic clock reading.
//
// For example, this code always computes a positive elapsed time of
// approximately 20 milliseconds, even if the wall clock is changed during
// the operation being timed:
//
//	start := time.Now()
//	... operation that takes 20 milliseconds ...
//	t := time.Now()
//	elapsed := t.Sub(start)
//
// Other idioms, such as time.Since(start), time.Until(deadline), and
// time.Now().Before(deadline), are similarly robust against wall clock
// resets.
//
// The rest of this section gives the precise details of how operations
// use monotonic clocks, but understanding those details is not required
// to use this package.
//
// The Time returned by time.Now contains a monotonic clock reading.
// If Time t has a monotonic clock reading, t.Add adds the same duration to
// both the wall clock and monotonic clock readings to compute the result.
// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
// computations, they always strip any monotonic clock reading from their results.
// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
// of the wall time, they also strip any monotonic clock reading from their results.
// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
//
// If Times t and u both contain monotonic clock readings, the operations
// t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out
// using the monotonic clock readings alone, ignoring the wall clock
// readings. If either t or u contains no monotonic clock reading, these
// operations fall back to using the wall clock readings.
//
// On some systems the monotonic clock will stop if the computer goes to sleep.
// On such a system, t.Sub(u) may not accurately reflect the actual
// time that passed between t and u.
//
// Because the monotonic clock reading has no meaning outside
// the current process, the serialized forms generated by t.GobEncode,
// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
// clock reading, and t.Format provides no format for it. Similarly, the
// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
// t.UnmarshalJSON, and t.UnmarshalText always create times with
// no monotonic clock reading.
//
// The monotonic clock reading exists only in Time values. It is not
// a part of Duration values or the Unix times returned by t.Unix and
// friends.
//
// Note that the Go == operator compares not just the time instant but
// also the Location and the monotonic clock reading. See the
// documentation for the Time type for a discussion of equality
// testing for Time values.
//
// For debugging, the result of t.String does include the monotonic
// clock reading if present. If t != u because of different monotonic clock readings,
// that difference will be visible when printing t.String() and u.String().
//
// # Timer Resolution
//
// Timer resolution varies depending on the Go runtime, the operating system
// and the underlying hardware.
// On Unix, the resolution is approximately 1ms.
// On Windows, the default resolution is approximately 16ms, but
// a higher resolution may be requested using [golang.org/x/sys/windows.TimeBeginPeriod].
namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Time represents an instant in time with nanosecond precision.
    //
    // Programs using times should typically store and pass them as values,
    // not pointers. That is, time variables and struct fields should be of
    // type time.Time, not *time.Time.
    //
    // A Time value can be used by multiple goroutines simultaneously except
    // that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
    // UnmarshalText are not concurrency-safe.
    //
    // Time instants can be compared using the Before, After, and Equal methods.
    // The Sub method subtracts two instants, producing a Duration.
    // The Add method adds a Time and a Duration, producing a Time.
    //
    // The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
    // As this time is unlikely to come up in practice, the IsZero method gives
    // a simple way of detecting a time that has not been initialized explicitly.
    //
    // Each time has an associated Location. The methods Local, UTC, and In return a
    // Time with a specific Location. Changing the Location of a Time value with
    // these methods does not change the actual instant it represents, only the time
    // zone in which to interpret it.
    //
    // Representations of a Time value saved by the GobEncode, MarshalBinary,
    // MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
    // the location name. They therefore lose information about Daylight Saving Time.
    //
    // In addition to the required “wall clock” reading, a Time may contain an optional
    // reading of the current process's monotonic clock, to provide additional precision
    // for comparison or subtraction.
    // See the “Monotonic Clocks” section in the package documentation for details.
    //
    // Note that the Go == operator compares not just the time instant but also the
    // Location and the monotonic clock reading. Therefore, Time values should not
    // be used as map or database keys without first guaranteeing that the
    // identical Location has been set for all values, which can be achieved
    // through use of the UTC or Local method, and that the monotonic clock reading
    // has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
    // to t == u, since t.Equal uses the most accurate comparison available and
    // correctly handles the case when only one of its arguments has a monotonic
    // clock reading.
    
    template<typename T> requires gocpp::GoStruct<T>
    Time::operator T()
    {
        T result;
        result.wall = this->wall;
        result.ext = this->ext;
        result.loc = this->loc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Time::operator==(const T& ref) const
    {
        if (wall != ref.wall) return false;
        if (ext != ref.ext) return false;
        if (loc != ref.loc) return false;
        return true;
    }

    std::ostream& Time::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wall;
        os << " " << ext;
        os << " " << loc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Time& value)
    {
        return value.PrintTo(os);
    }

    // nsec returns the time's nanoseconds.
    int32_t rec::nsec(struct Time* t)
    {
        return int32_t(t->wall & nsecMask);
    }

    // sec returns the time's seconds since Jan 1 year 1.
    int64_t rec::sec(struct Time* t)
    {
        if(t->wall & hasMonotonic != 0)
        {
            return wallToInternal + int64_t((t->wall << 1) >> (nsecShift + 1));
        }
        return t->ext;
    }

    // unixSec returns the time's seconds since Jan 1 1970 (Unix time).
    int64_t rec::unixSec(struct Time* t)
    {
        return rec::sec(gocpp::recv(t)) + internalToUnix;
    }

    // addSec adds d seconds to the time.
    void rec::addSec(struct Time* t, int64_t d)
    {
        if(t->wall & hasMonotonic != 0)
        {
            auto sec = int64_t((t->wall << 1) >> (nsecShift + 1));
            auto dsec = sec + d;
            if(0 <= dsec && dsec <= (1 << 33) - 1)
            {
                t->wall = t->wall & nsecMask | (uint64_t(dsec) << nsecShift) | hasMonotonic;
                return;
            }
            rec::stripMono(gocpp::recv(t));
        }
        auto sum = t->ext + d;
        if((sum > t->ext) == (d > 0))
        {
            t->ext = sum;
        }
        else
        if(d > 0)
        {
            t->ext = (1 << 63) - 1;
        }
        else
        {
            t->ext = - ((1 << 63) - 1);
        }
    }

    // setLoc sets the location associated with the time.
    void rec::setLoc(struct Time* t, struct Location* loc)
    {
        if(loc == & utcLoc)
        {
            loc = nullptr;
        }
        rec::stripMono(gocpp::recv(t));
        t->loc = loc;
    }

    // stripMono strips the monotonic clock reading in t.
    void rec::stripMono(struct Time* t)
    {
        if(t->wall & hasMonotonic != 0)
        {
            t->ext = rec::sec(gocpp::recv(t));
            t->wall &= nsecMask;
        }
    }

    // setMono sets the monotonic clock reading in t.
    // If t cannot hold a monotonic clock reading,
    // because its wall time is too large,
    // setMono is a no-op.
    void rec::setMono(struct Time* t, int64_t m)
    {
        if(t->wall & hasMonotonic == 0)
        {
            auto sec = t->ext;
            if(sec < minWall || maxWall < sec)
            {
                return;
            }
            t->wall |= hasMonotonic | (uint64_t(sec - minWall) << nsecShift);
        }
        t->ext = m;
    }

    // mono returns t's monotonic clock reading.
    // It returns 0 for a missing reading.
    // This function is used only for testing,
    // so it's OK that technically 0 is a valid
    // monotonic clock reading as well.
    int64_t rec::mono(struct Time* t)
    {
        if(t->wall & hasMonotonic == 0)
        {
            return 0;
        }
        return t->ext;
    }

    // After reports whether the time instant t is after u.
    bool rec::After(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return t.ext > u.ext;
        }
        auto ts = rec::sec(gocpp::recv(t));
        auto us = rec::sec(gocpp::recv(u));
        return ts > us || ts == us && rec::nsec(gocpp::recv(t)) > rec::nsec(gocpp::recv(u));
    }

    // Before reports whether the time instant t is before u.
    bool rec::Before(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return t.ext < u.ext;
        }
        auto ts = rec::sec(gocpp::recv(t));
        auto us = rec::sec(gocpp::recv(u));
        return ts < us || ts == us && rec::nsec(gocpp::recv(t)) < rec::nsec(gocpp::recv(u));
    }

    // Compare compares the time instant t with u. If t is before u, it returns -1;
    // if t is after u, it returns +1; if they're the same, it returns 0.
    int rec::Compare(struct Time t, struct Time u)
    {
        int64_t tc = {};
        int64_t uc = {};
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            std::tie(tc, uc) = std::tuple{t.ext, u.ext};
        }
        else
        {
            std::tie(tc, uc) = std::tuple{rec::sec(gocpp::recv(t)), rec::sec(gocpp::recv(u))};
            if(tc == uc)
            {
                std::tie(tc, uc) = std::tuple{int64_t(rec::nsec(gocpp::recv(t))), int64_t(rec::nsec(gocpp::recv(u)))};
            }
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(tc < uc) { conditionId = 0; }
            else if(tc > uc) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return - 1;
                    break;
                case 1:
                    return + 1;
                    break;
            }
        }
        return 0;
    }

    // Equal reports whether t and u represent the same time instant.
    // Two times can be equal even if they are in different locations.
    // For example, 6:00 +0200 and 4:00 UTC are Equal.
    // See the documentation on the Time type for the pitfalls of using == with
    // Time values; most code should use Equal instead.
    bool rec::Equal(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return t.ext == u.ext;
        }
        return rec::sec(gocpp::recv(t)) == rec::sec(gocpp::recv(u)) && rec::nsec(gocpp::recv(t)) == rec::nsec(gocpp::recv(u));
    }

    // A Month specifies a month of the year (January = 1, ...).
    // String returns the English name of the month ("January", "February", ...).
    std::string rec::String(golang::time::Month m)
    {
        if(January <= m && m <= December)
        {
            return longMonthNames[m - 1];
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 20);
        auto n = fmtInt(buf, uint64_t(m));
        return "%!Month("s + std::string(buf.make_slice(n)) + ")"s;
    }

    // A Weekday specifies a day of the week (Sunday = 0, ...).
    // String returns the English name of the day ("Sunday", "Monday", ...).
    std::string rec::String(golang::time::Weekday d)
    {
        if(Sunday <= d && d <= Saturday)
        {
            return longDayNames[d];
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 20);
        auto n = fmtInt(buf, uint64_t(d));
        return "%!Weekday("s + std::string(buf.make_slice(n)) + ")"s;
    }

    // The unsigned zero year for internal calculations.
    // Must be 1 mod 400, and times before it will not compute correctly,
    // but otherwise can be changed at will.
    // The year of the zero Time.
    // Assumed by the unixToInternal computation below.
    // Offsets to convert between internal and absolute or Unix times.
    // IsZero reports whether t represents the zero time instant,
    // January 1, year 1, 00:00:00 UTC.
    bool rec::IsZero(struct Time t)
    {
        return rec::sec(gocpp::recv(t)) == 0 && rec::nsec(gocpp::recv(t)) == 0;
    }

    // abs returns the time t as an absolute time, adjusted by the zone offset.
    // It is called when computing a presentation property like Month or Hour.
    uint64_t rec::abs(struct Time t)
    {
        auto l = t.loc;
        if(l == nullptr || l == & localLoc)
        {
            l = rec::get(gocpp::recv(l));
        }
        auto sec = rec::unixSec(gocpp::recv(t));
        if(l != & utcLoc)
        {
            if(l->cacheZone != nullptr && l->cacheStart <= sec && sec < l->cacheEnd)
            {
                sec += int64_t(l->cacheZone->offset);
            }
            else
            {
                auto [gocpp_id_4, offset, gocpp_id_5, gocpp_id_6, gocpp_id_7] = rec::lookup(gocpp::recv(l), sec);
                sec += int64_t(offset);
            }
        }
        return uint64_t(sec + (unixToInternal + internalToAbsolute));
    }

    // locabs is a combination of the Zone and abs methods,
    // extracting both return values from a single zone lookup.
    std::tuple<std::string, int, uint64_t> rec::locabs(struct Time t)
    {
        std::string name;
        int offset;
        uint64_t abs;
        auto l = t.loc;
        if(l == nullptr || l == & localLoc)
        {
            l = rec::get(gocpp::recv(l));
        }
        auto sec = rec::unixSec(gocpp::recv(t));
        if(l != & utcLoc)
        {
            if(l->cacheZone != nullptr && l->cacheStart <= sec && sec < l->cacheEnd)
            {
                name = l->cacheZone->name;
                offset = l->cacheZone->offset;
            }
            else
            {
                std::tie(name, offset, gocpp_id_8, gocpp_id_9, gocpp_id_10) = rec::lookup(gocpp::recv(l), sec);
            }
            sec += int64_t(offset);
        }
        else
        {
            name = "UTC"s;
        }
        abs = uint64_t(sec + (unixToInternal + internalToAbsolute));
        return {name, offset, abs};
    }

    // Date returns the year, month, and day in which t occurs.
    std::tuple<int, time::Month, int> rec::Date(struct Time t)
    {
        int year;
        time::Month month;
        int day;
        std::tie(year, month, day, gocpp_id_11) = rec::date(gocpp::recv(t), true);
        return {year, month, day};
    }

    // Year returns the year in which t occurs.
    int rec::Year(struct Time t)
    {
        auto [year, gocpp_id_15, gocpp_id_16, gocpp_id_17] = rec::date(gocpp::recv(t), false);
        return year;
    }

    // Month returns the month of the year specified by t.
    time::Month rec::Month(struct Time t)
    {
        auto [gocpp_id_21, month, gocpp_id_22, gocpp_id_23] = rec::date(gocpp::recv(t), true);
        return month;
    }

    // Day returns the day of the month specified by t.
    int rec::Day(struct Time t)
    {
        auto [gocpp_id_27, gocpp_id_28, day, gocpp_id_29] = rec::date(gocpp::recv(t), true);
        return day;
    }

    // Weekday returns the day of the week specified by t.
    time::Weekday rec::Weekday(struct Time t)
    {
        return absWeekday(rec::abs(gocpp::recv(t)));
    }

    // absWeekday is like Weekday but operates on an absolute time.
    time::Weekday absWeekday(uint64_t abs)
    {
        auto sec = (abs + uint64_t(Monday) * secondsPerDay) % secondsPerWeek;
        return Weekday(int(sec) / secondsPerDay);
    }

    // ISOWeek returns the ISO 8601 year and week number in which t occurs.
    // Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
    // week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
    // of year n+1.
    std::tuple<int, int> rec::ISOWeek(struct Time t)
    {
        int year;
        int week;
        auto abs = rec::abs(gocpp::recv(t));
        auto d = Thursday - absWeekday(abs);
        if(d == 4)
        {
            d = - 3;
        }
        abs += uint64_t(d) * secondsPerDay;
        auto [year, gocpp_id_32, gocpp_id_33, yday] = absDate(abs, false);
        return {year, yday / 7 + 1};
    }

    // Clock returns the hour, minute, and second within the day specified by t.
    std::tuple<int, int, int> rec::Clock(struct Time t)
    {
        int hour;
        int min;
        int sec;
        return absClock(rec::abs(gocpp::recv(t)));
    }

    // absClock is like clock but operates on an absolute time.
    std::tuple<int, int, int> absClock(uint64_t abs)
    {
        int hour;
        int min;
        int sec;
        sec = int(abs % secondsPerDay);
        hour = sec / secondsPerHour;
        sec -= hour * secondsPerHour;
        min = sec / secondsPerMinute;
        sec -= min * secondsPerMinute;
        return {hour, min, sec};
    }

    // Hour returns the hour within the day specified by t, in the range [0, 23].
    int rec::Hour(struct Time t)
    {
        return int(rec::abs(gocpp::recv(t)) % secondsPerDay) / secondsPerHour;
    }

    // Minute returns the minute offset within the hour specified by t, in the range [0, 59].
    int rec::Minute(struct Time t)
    {
        return int(rec::abs(gocpp::recv(t)) % secondsPerHour) / secondsPerMinute;
    }

    // Second returns the second offset within the minute specified by t, in the range [0, 59].
    int rec::Second(struct Time t)
    {
        return int(rec::abs(gocpp::recv(t)) % secondsPerMinute);
    }

    // Nanosecond returns the nanosecond offset within the second specified by t,
    // in the range [0, 999999999].
    int rec::Nanosecond(struct Time t)
    {
        return int(rec::nsec(gocpp::recv(t)));
    }

    // YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
    // and [1,366] in leap years.
    int rec::YearDay(struct Time t)
    {
        auto [gocpp_id_37, gocpp_id_38, gocpp_id_39, yday] = rec::date(gocpp::recv(t), false);
        return yday + 1;
    }

    // A Duration represents the elapsed time between two instants
    // as an int64 nanosecond count. The representation limits the
    // largest representable duration to approximately 290 years.
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    // String returns a string representing the duration in the form "72h3m0.5s".
    // Leading zero units are omitted. As a special case, durations less than one
    // second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
    // that the leading digit is non-zero. The zero duration formats as 0s.
    std::string rec::String(golang::time::Duration d)
    {
        // This is inlinable to take advantage of "function outlining".
        // Thus, the caller can decide whether a string must be heap allocated.
        gocpp::array<unsigned char, 32> arr = {};
        auto n = rec::format(gocpp::recv(d), & arr);
        return std::string(arr.make_slice(n));
    }

    // format formats the representation of d into the end of buf and
    // returns the offset of the first character.
    int rec::format(golang::time::Duration d, gocpp::array<unsigned char, 32>* buf)
    {
        auto w = len(buf);
        auto u = uint64_t(d);
        auto neg = d < 0;
        if(neg)
        {
            u = - u;
        }
        if(u < uint64_t(Second))
        {
            // Special case: if duration is smaller than a second,
            // use smaller units, like 1.2ms
            int prec = {};
            w--;
            buf[w] = 's';
            w--;
            //Go switch emulation
            {
                int conditionId = -1;
                if(u == 0) { conditionId = 0; }
                else if(u < uint64_t(Microsecond)) { conditionId = 1; }
                else if(u < uint64_t(Millisecond)) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        buf[w] = '0';
                        return w;
                        break;
                    case 1:
                        prec = 0;
                        buf[w] = 'n';
                        break;
                    case 2:
                        prec = 3;
                        w--;
                        copy(buf.make_slice(w), "µ"s);
                        break;
                    default:
                        prec = 6;
                        buf[w] = 'm';
                        break;
                }
            }
            std::tie(w, u) = fmtFrac(buf.make_slice(0, w), u, prec);
            w = fmtInt(buf.make_slice(0, w), u);
        }
        else
        {
            w--;
            buf[w] = 's';
            std::tie(w, u) = fmtFrac(buf.make_slice(0, w), u, 9);
            w = fmtInt(buf.make_slice(0, w), u % 60);
            u /= 60;
            if(u > 0)
            {
                w--;
                buf[w] = 'm';
                w = fmtInt(buf.make_slice(0, w), u % 60);
                u /= 60;
                if(u > 0)
                {
                    w--;
                    buf[w] = 'h';
                    w = fmtInt(buf.make_slice(0, w), u);
                }
            }
        }
        if(neg)
        {
            w--;
            buf[w] = '-';
        }
        return w;
    }

    // fmtFrac formats the fraction of v/10**prec (e.g., ".12345") into the
    // tail of buf, omitting trailing zeros. It omits the decimal
    // point too when the fraction is 0. It returns the index where the
    // output bytes begin and the value v/10**prec.
    std::tuple<int, uint64_t> fmtFrac(gocpp::slice<unsigned char> buf, uint64_t v, int prec)
    {
        int nw;
        uint64_t nv;
        auto w = len(buf);
        auto print = false;
        for(auto i = 0; i < prec; i++)
        {
            auto digit = v % 10;
            print = print || digit != 0;
            if(print)
            {
                w--;
                buf[w] = (unsigned char)(digit) + '0';
            }
            v /= 10;
        }
        if(print)
        {
            w--;
            buf[w] = '.';
        }
        return {w, v};
    }

    // fmtInt formats v into the tail of buf.
    // It returns the index where the output begins.
    int fmtInt(gocpp::slice<unsigned char> buf, uint64_t v)
    {
        auto w = len(buf);
        if(v == 0)
        {
            w--;
            buf[w] = '0';
        }
        else
        {
            for(; v > 0; )
            {
                w--;
                buf[w] = (unsigned char)(v % 10) + '0';
                v /= 10;
            }
        }
        return w;
    }

    // Nanoseconds returns the duration as an integer nanosecond count.
    int64_t rec::Nanoseconds(golang::time::Duration d)
    {
        return int64_t(d);
    }

    // Microseconds returns the duration as an integer microsecond count.
    int64_t rec::Microseconds(golang::time::Duration d)
    {
        return int64_t(d) / 1e3;
    }

    // Milliseconds returns the duration as an integer millisecond count.
    int64_t rec::Milliseconds(golang::time::Duration d)
    {
        return int64_t(d) / 1e6;
    }

    // Seconds returns the duration as a floating point number of seconds.
    double rec::Seconds(golang::time::Duration d)
    {
        auto sec = d / Second;
        auto nsec = d % Second;
        return double(sec) + double(nsec) / 1e9;
    }

    // Minutes returns the duration as a floating point number of minutes.
    double rec::Minutes(golang::time::Duration d)
    {
        auto min = d / Minute;
        auto nsec = d % Minute;
        return double(min) + double(nsec) / (60 * 1e9);
    }

    // Hours returns the duration as a floating point number of hours.
    double rec::Hours(golang::time::Duration d)
    {
        auto hour = d / Hour;
        auto nsec = d % Hour;
        return double(hour) + double(nsec) / (60 * 60 * 1e9);
    }

    // Truncate returns the result of rounding d toward zero to a multiple of m.
    // If m <= 0, Truncate returns d unchanged.
    time::Duration rec::Truncate(golang::time::Duration d, golang::time::Duration m)
    {
        if(m <= 0)
        {
            return d;
        }
        return d - d % m;
    }

    // lessThanHalf reports whether x+x < y but avoids overflow,
    // assuming x and y are both positive (Duration is signed).
    bool lessThanHalf(golang::time::Duration x, golang::time::Duration y)
    {
        return uint64_t(x) + uint64_t(x) < uint64_t(y);
    }

    // Round returns the result of rounding d to the nearest multiple of m.
    // The rounding behavior for halfway values is to round away from zero.
    // If the result exceeds the maximum (or minimum)
    // value that can be stored in a Duration,
    // Round returns the maximum (or minimum) duration.
    // If m <= 0, Round returns d unchanged.
    time::Duration rec::Round(golang::time::Duration d, golang::time::Duration m)
    {
        if(m <= 0)
        {
            return d;
        }
        auto r = d % m;
        if(d < 0)
        {
            r = - r;
            if(lessThanHalf(r, m))
            {
                return d + r;
            }
            if(auto d1 = d - m + r; d1 < d)
            {
                return d1;
            }
            return minDuration;
        }
        if(lessThanHalf(r, m))
        {
            return d - r;
        }
        if(auto d1 = d + m - r; d1 > d)
        {
            return d1;
        }
        return maxDuration;
    }

    // Abs returns the absolute value of d.
    // As a special case, math.MinInt64 is converted to math.MaxInt64.
    time::Duration rec::Abs(golang::time::Duration d)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(d >= 0) { conditionId = 0; }
            else if(d == minDuration) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return d;
                    break;
                case 1:
                    return maxDuration;
                    break;
                default:
                    return - d;
                    break;
            }
        }
    }

    // Add returns the time t+d.
    struct Time rec::Add(struct Time t, golang::time::Duration d)
    {
        auto dsec = int64_t(d / 1e9);
        auto nsec = rec::nsec(gocpp::recv(t)) + int32_t(d % 1e9);
        if(nsec >= 1e9)
        {
            dsec++;
            nsec -= 1e9;
        }
        else
        if(nsec < 0)
        {
            dsec--;
            nsec += 1e9;
        }
        t.wall = t.wall &^ nsecMask | uint64_t(nsec);
        rec::addSec(gocpp::recv(t), dsec);
        if(t.wall & hasMonotonic != 0)
        {
            auto te = t.ext + int64_t(d);
            if(d < 0 && te > t.ext || d > 0 && te < t.ext)
            {
                rec::stripMono(gocpp::recv(t));
            }
            else
            {
                t.ext = te;
            }
        }
        return t;
    }

    // Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
    // value that can be stored in a Duration, the maximum (or minimum) duration
    // will be returned.
    // To compute t-d for a duration d, use t.Add(-d).
    time::Duration rec::Sub(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return subMono(t.ext, u.ext);
        }
        auto d = Duration(rec::sec(gocpp::recv(t)) - rec::sec(gocpp::recv(u))) * Second + Duration(rec::nsec(gocpp::recv(t)) - rec::nsec(gocpp::recv(u)));
        //Go switch emulation
        {
            int conditionId = -1;
            if(rec::Equal(gocpp::recv(rec::Add(gocpp::recv(u), d)), t)) { conditionId = 0; }
            else if(rec::Before(gocpp::recv(t), u)) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return d;
                    break;
                case 1:
                    return minDuration;
                    break;
                default:
                    return maxDuration;
                    break;
            }
        }
    }

    time::Duration subMono(int64_t t, int64_t u)
    {
        auto d = Duration(t - u);
        if(d < 0 && t > u)
        {
            return maxDuration;
        }
        if(d > 0 && t < u)
        {
            return minDuration;
        }
        return d;
    }

    // Since returns the time elapsed since t.
    // It is shorthand for time.Now().Sub(t).
    time::Duration Since(struct Time t)
    {
        if(t.wall & hasMonotonic != 0)
        {
            return subMono(runtimeNano() - startNano, t.ext);
        }
        return rec::Sub(gocpp::recv(Now()), t);
    }

    // Until returns the duration until t.
    // It is shorthand for t.Sub(time.Now()).
    time::Duration Until(struct Time t)
    {
        if(t.wall & hasMonotonic != 0)
        {
            return subMono(t.ext, runtimeNano() - startNano);
        }
        return rec::Sub(gocpp::recv(t), Now());
    }

    // AddDate returns the time corresponding to adding the
    // given number of years, months, and days to t.
    // For example, AddDate(-1, 2, 3) applied to January 1, 2011
    // returns March 4, 2010.
    //
    // Note that dates are fundamentally coupled to timezones, and calendrical
    // periods like days don't have fixed durations. AddDate uses the Location of
    // the Time value to determine these durations. That means that the same
    // AddDate arguments can produce a different shift in absolute time depending on
    // the base Time value and its Location. For example, AddDate(0, 0, 1) applied
    // to 12:00 on March 27 always returns 12:00 on March 28. At some locations and
    // in some years this is a 24 hour shift. In others it's a 23 hour shift due to
    // daylight savings time transitions.
    //
    // AddDate normalizes its result in the same way that Date does,
    // so, for example, adding one month to October 31 yields
    // December 1, the normalized form for November 31.
    struct Time rec::AddDate(struct Time t, int years, int months, int days)
    {
        auto [year, month, day] = rec::Date(gocpp::recv(t));
        auto [hour, min, sec] = rec::Clock(gocpp::recv(t));
        return Date(year + years, month + Month(months), day + days, hour, min, sec, int(rec::nsec(gocpp::recv(t))), rec::Location(gocpp::recv(t)));
    }

    // date computes the year, day of year, and when full=true,
    // the month and day in which t occurs.
    std::tuple<int, time::Month, int, int> rec::date(struct Time t, bool full)
    {
        int year;
        time::Month month;
        int day;
        int yday;
        return absDate(rec::abs(gocpp::recv(t)), full);
    }

    // absDate is like date but operates on an absolute time.
    std::tuple<int, time::Month, int, int> absDate(uint64_t abs, bool full)
    {
        int year;
        time::Month month;
        int day;
        int yday;
        auto d = abs / secondsPerDay;
        auto n = d / daysPer400Years;
        auto y = 400 * n;
        d -= daysPer400Years * n;
        n = d / daysPer100Years;
        n -= n >> 2;
        y += 100 * n;
        d -= daysPer100Years * n;
        n = d / daysPer4Years;
        y += 4 * n;
        d -= daysPer4Years * n;
        n = d / 365;
        n -= n >> 2;
        y += n;
        d -= 365 * n;
        year = int(int64_t(y) + absoluteZeroYear);
        yday = int(d);
        if(! full)
        {
            return {year, month, day, yday};
        }
        day = yday;
        if(isLeap(year))
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if(day > 31 + 29 - 1) { conditionId = 0; }
                else if(day == 31 + 29 - 1) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        day--;
                        break;
                    case 1:
                        month = February;
                        day = 29;
                        return {year, month, day, yday};
                        break;
                }
            }
        }
        month = Month(day / 31);
        auto end = int(daysBefore[month + 1]);
        int begin = {};
        if(day >= end)
        {
            month++;
            begin = end;
        }
        else
        {
            begin = int(daysBefore[month]);
        }
        month++;
        day = day - begin + 1;
        return {year, month, day, yday};
    }

    // daysBefore[m] counts the number of days in a non-leap year
    // before month m begins. There is an entry for m=12, counting
    // the number of days before January of next year (365).
    gocpp::array<int32_t, 13> daysBefore = gocpp::array<int32_t, 13> {0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31};
    int daysIn(golang::time::Month m, int year)
    {
        if(m == February && isLeap(year))
        {
            return 29;
        }
        return int(daysBefore[m] - daysBefore[m - 1]);
    }

    // daysSinceEpoch takes a year and returns the number of days from
    // the absolute epoch to the start of that year.
    // This is basically (year - zeroYear) * 365, but accounting for leap days.
    uint64_t daysSinceEpoch(int year)
    {
        auto y = uint64_t(int64_t(year) - absoluteZeroYear);
        auto n = y / 400;
        y -= 400 * n;
        auto d = daysPer400Years * n;
        n = y / 100;
        y -= 100 * n;
        d += daysPer100Years * n;
        n = y / 4;
        y -= 4 * n;
        d += daysPer4Years * n;
        n = y;
        d += 365 * n;
        return d;
    }

    // Provided by package runtime.
    std::tuple<int64_t, int32_t, int64_t> now()
    /* convertBlockStmt, nil block */;

    // runtimeNano returns the current value of the runtime clock in nanoseconds.
    //
    //go:linkname runtimeNano runtime.nanotime
    int64_t runtimeNano()
    /* convertBlockStmt, nil block */;

    // Monotonic times are reported as offsets from startNano.
    // We initialize startNano to runtimeNano() - 1 so that on systems where
    // monotonic time resolution is fairly low (e.g. Windows 2008
    // which appears to have a default resolution of 15ms),
    // we avoid ever reporting a monotonic time of 0.
    // (Callers may want to use 0 as "time not set".)
    int64_t startNano = runtimeNano() - 1;
    // Now returns the current local time.
    struct Time Now()
    {
        auto [sec, nsec, mono] = now();
        mono -= startNano;
        sec += unixToInternal - minWall;
        if((uint64_t(sec) >> 33) != 0)
        {
            return Time {uint64_t(nsec), sec + minWall, Local};
        }
        return Time {hasMonotonic | (uint64_t(sec) << nsecShift) | uint64_t(nsec), mono, Local};
    }

    struct Time unixTime(int64_t sec, int32_t nsec)
    {
        return Time {uint64_t(nsec), sec + unixToInternal, Local};
    }

    // UTC returns t with the location set to UTC.
    struct Time rec::UTC(struct Time t)
    {
        rec::setLoc(gocpp::recv(t), & utcLoc);
        return t;
    }

    // Local returns t with the location set to local time.
    struct Time rec::Local(struct Time t)
    {
        rec::setLoc(gocpp::recv(t), Local);
        return t;
    }

    // In returns a copy of t representing the same time instant, but
    // with the copy's location information set to loc for display
    // purposes.
    //
    // In panics if loc is nil.
    struct Time rec::In(struct Time t, struct Location* loc)
    {
        if(loc == nullptr)
        {
            gocpp::panic("time: missing Location in call to Time.In"s);
        }
        rec::setLoc(gocpp::recv(t), loc);
        return t;
    }

    // Location returns the time zone information associated with t.
    struct Location* rec::Location(struct Time t)
    {
        auto l = t.loc;
        if(l == nullptr)
        {
            l = UTC;
        }
        return l;
    }

    // Zone computes the time zone in effect at time t, returning the abbreviated
    // name of the zone (such as "CET") and its offset in seconds east of UTC.
    std::tuple<std::string, int> rec::Zone(struct Time t)
    {
        std::string name;
        int offset;
        std::tie(name, offset, gocpp_id_40, gocpp_id_41, gocpp_id_42) = rec::lookup(gocpp::recv(t.loc), rec::unixSec(gocpp::recv(t)));
        return {name, offset};
    }

    // ZoneBounds returns the bounds of the time zone in effect at time t.
    // The zone begins at start and the next zone begins at end.
    // If the zone begins at the beginning of time, start will be returned as a zero Time.
    // If the zone goes on forever, end will be returned as a zero Time.
    // The Location of the returned times will be the same as t.
    std::tuple<struct Time, struct Time> rec::ZoneBounds(struct Time t)
    {
        struct Time start;
        struct Time end;
        auto [gocpp_id_46, gocpp_id_47, startSec, endSec, gocpp_id_48] = rec::lookup(gocpp::recv(t.loc), rec::unixSec(gocpp::recv(t)));
        if(startSec != alpha)
        {
            start = unixTime(startSec, 0);
            rec::setLoc(gocpp::recv(start), t.loc);
        }
        if(endSec != omega)
        {
            end = unixTime(endSec, 0);
            rec::setLoc(gocpp::recv(end), t.loc);
        }
        return {start, end};
    }

    // Unix returns t as a Unix time, the number of seconds elapsed
    // since January 1, 1970 UTC. The result does not depend on the
    // location associated with t.
    // Unix-like operating systems often record time as a 32-bit
    // count of seconds, but since the method here returns a 64-bit
    // value it is valid for billions of years into the past or future.
    int64_t rec::Unix(struct Time t)
    {
        return rec::unixSec(gocpp::recv(t));
    }

    // UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
    // January 1, 1970 UTC. The result is undefined if the Unix time in
    // milliseconds cannot be represented by an int64 (a date more than 292 million
    // years before or after 1970). The result does not depend on the
    // location associated with t.
    int64_t rec::UnixMilli(struct Time t)
    {
        return rec::unixSec(gocpp::recv(t)) * 1e3 + int64_t(rec::nsec(gocpp::recv(t))) / 1e6;
    }

    // UnixMicro returns t as a Unix time, the number of microseconds elapsed since
    // January 1, 1970 UTC. The result is undefined if the Unix time in
    // microseconds cannot be represented by an int64 (a date before year -290307 or
    // after year 294246). The result does not depend on the location associated
    // with t.
    int64_t rec::UnixMicro(struct Time t)
    {
        return rec::unixSec(gocpp::recv(t)) * 1e6 + int64_t(rec::nsec(gocpp::recv(t))) / 1e3;
    }

    // UnixNano returns t as a Unix time, the number of nanoseconds elapsed
    // since January 1, 1970 UTC. The result is undefined if the Unix time
    // in nanoseconds cannot be represented by an int64 (a date before the year
    // 1678 or after 2262). Note that this means the result of calling UnixNano
    // on the zero Time is undefined. The result does not depend on the
    // location associated with t.
    int64_t rec::UnixNano(struct Time t)
    {
        return (rec::unixSec(gocpp::recv(t))) * 1e9 + int64_t(rec::nsec(gocpp::recv(t)));
    }

    // MarshalBinary implements the encoding.BinaryMarshaler interface.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalBinary(struct Time t)
    {
        int16_t offsetMin = {};
        int8_t offsetSec = {};
        auto version = timeBinaryVersionV1;
        if(rec::Location(gocpp::recv(t)) == UTC)
        {
            offsetMin = - 1;
        }
        else
        {
            auto [gocpp_id_50, offset] = rec::Zone(gocpp::recv(t));
            if(offset % 60 != 0)
            {
                version = timeBinaryVersionV2;
                offsetSec = int8_t(offset % 60);
            }
            offset /= 60;
            if(offset < - 32768 || offset == - 1 || offset > 32767)
            {
                return {nullptr, errors::New("Time.MarshalBinary: unexpected zone offset"s)};
            }
            offsetMin = int16_t(offset);
        }
        auto sec = rec::sec(gocpp::recv(t));
        auto nsec = rec::nsec(gocpp::recv(t));
        auto enc = gocpp::slice<unsigned char> {version, (unsigned char)(sec >> 56), (unsigned char)(sec >> 48), (unsigned char)(sec >> 40), (unsigned char)(sec >> 32), (unsigned char)(sec >> 24), (unsigned char)(sec >> 16), (unsigned char)(sec >> 8), (unsigned char)(sec), (unsigned char)(nsec >> 24), (unsigned char)(nsec >> 16), (unsigned char)(nsec >> 8), (unsigned char)(nsec), (unsigned char)(offsetMin >> 8), (unsigned char)(offsetMin)};
        if(version == timeBinaryVersionV2)
        {
            enc = append(enc, (unsigned char)(offsetSec));
        }
        return {enc, nullptr};
    }

    // UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.
    struct gocpp::error rec::UnmarshalBinary(struct Time* t, gocpp::slice<unsigned char> data)
    {
        auto buf = data;
        if(len(buf) == 0)
        {
            return errors::New("Time.UnmarshalBinary: no data"s);
        }
        auto version = buf[0];
        if(version != timeBinaryVersionV1 && version != timeBinaryVersionV2)
        {
            return errors::New("Time.UnmarshalBinary: unsupported version"s);
        }
        auto wantLen = 1 + 8 + 4 + 2;
        if(version == timeBinaryVersionV2)
        {
            wantLen++;
        }
        if(len(buf) != wantLen)
        {
            return errors::New("Time.UnmarshalBinary: invalid length"s);
        }
        buf = buf.make_slice(1);
        auto sec = int64_t(buf[7]) | (int64_t(buf[6]) << 8) | (int64_t(buf[5]) << 16) | (int64_t(buf[4]) << 24) | (int64_t(buf[3]) << 32) | (int64_t(buf[2]) << 40) | (int64_t(buf[1]) << 48) | (int64_t(buf[0]) << 56);
        buf = buf.make_slice(8);
        auto nsec = int32_t(buf[3]) | (int32_t(buf[2]) << 8) | (int32_t(buf[1]) << 16) | (int32_t(buf[0]) << 24);
        buf = buf.make_slice(4);
        auto offset = int(int16_t(buf[1]) | (int16_t(buf[0]) << 8)) * 60;
        if(version == timeBinaryVersionV2)
        {
            offset += int(buf[2]);
        }
        *t = Time {};
        t->wall = uint64_t(nsec);
        t->ext = sec;
        if(offset == - 1 * 60)
        {
            rec::setLoc(gocpp::recv(t), & utcLoc);
        }
        else
        if(auto [gocpp_id_55, localoff, gocpp_id_56, gocpp_id_57, gocpp_id_58] = rec::lookup(gocpp::recv(Local), rec::unixSec(gocpp::recv(t))); offset == localoff)
        {
            rec::setLoc(gocpp::recv(t), Local);
        }
        else
        {
            rec::setLoc(gocpp::recv(t), FixedZone(""s, offset));
        }
        return nullptr;
    }

    // GobEncode implements the gob.GobEncoder interface.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::GobEncode(struct Time t)
    {
        return rec::MarshalBinary(gocpp::recv(t));
    }

    // GobDecode implements the gob.GobDecoder interface.
    struct gocpp::error rec::GobDecode(struct Time* t, gocpp::slice<unsigned char> data)
    {
        return rec::UnmarshalBinary(gocpp::recv(t), data);
    }

    // MarshalJSON implements the json.Marshaler interface.
    // The time is a quoted string in the RFC 3339 format with sub-second precision.
    // If the timestamp cannot be represented as valid RFC 3339
    // (e.g., the year is out of range), then an error is reported.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalJSON(struct Time t)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(RFC3339Nano) + len(""""s));
        b = append(b, '"');
        gocpp::error err;
        std::tie(b, err) = rec::appendStrictRFC3339(gocpp::recv(t), b);
        b = append(b, '"');
        if(err != nullptr)
        {
            return {nullptr, errors::New("Time.MarshalJSON: "s + rec::Error(gocpp::recv(err)))};
        }
        return {b, nullptr};
    }

    // UnmarshalJSON implements the json.Unmarshaler interface.
    // The time must be a quoted string in the RFC 3339 format.
    struct gocpp::error rec::UnmarshalJSON(struct Time* t, gocpp::slice<unsigned char> data)
    {
        if(std::string(data) == "null"s)
        {
            return nullptr;
        }
        if(len(data) < 2 || data[0] != '"' || data[len(data) - 1] != '"')
        {
            return errors::New("Time.UnmarshalJSON: input is not a JSON string"s);
        }
        data = data.make_slice(len("""s), len(data) - len("""s));
        gocpp::error err = {};
        std::tie(*t, err) = parseStrictRFC3339(data);
        return err;
    }

    // MarshalText implements the encoding.TextMarshaler interface.
    // The time is formatted in RFC 3339 format with sub-second precision.
    // If the timestamp cannot be represented as valid RFC 3339
    // (e.g., the year is out of range), then an error is reported.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalText(struct Time t)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(RFC3339Nano));
        gocpp::error err;
        std::tie(b, err) = rec::appendStrictRFC3339(gocpp::recv(t), b);
        if(err != nullptr)
        {
            return {nullptr, errors::New("Time.MarshalText: "s + rec::Error(gocpp::recv(err)))};
        }
        return {b, nullptr};
    }

    // UnmarshalText implements the encoding.TextUnmarshaler interface.
    // The time must be in the RFC 3339 format.
    struct gocpp::error rec::UnmarshalText(struct Time* t, gocpp::slice<unsigned char> data)
    {
        gocpp::error err = {};
        std::tie(*t, err) = parseStrictRFC3339(data);
        return err;
    }

    // Unix returns the local Time corresponding to the given Unix time,
    // sec seconds and nsec nanoseconds since January 1, 1970 UTC.
    // It is valid to pass nsec outside the range [0, 999999999].
    // Not all sec values have a corresponding time value. One such
    // value is 1<<63-1 (the largest int64 value).
    struct Time Unix(int64_t sec, int64_t nsec)
    {
        if(nsec < 0 || nsec >= 1e9)
        {
            auto n = nsec / 1e9;
            sec += n;
            nsec -= n * 1e9;
            if(nsec < 0)
            {
                nsec += 1e9;
                sec--;
            }
        }
        return unixTime(sec, int32_t(nsec));
    }

    // UnixMilli returns the local Time corresponding to the given Unix time,
    // msec milliseconds since January 1, 1970 UTC.
    struct Time UnixMilli(int64_t msec)
    {
        return Unix(msec / 1e3, (msec % 1e3) * 1e6);
    }

    // UnixMicro returns the local Time corresponding to the given Unix time,
    // usec microseconds since January 1, 1970 UTC.
    struct Time UnixMicro(int64_t usec)
    {
        return Unix(usec / 1e6, (usec % 1e6) * 1e3);
    }

    // IsDST reports whether the time in the configured location is in Daylight Savings Time.
    bool rec::IsDST(struct Time t)
    {
        auto [gocpp_id_63, gocpp_id_64, gocpp_id_65, gocpp_id_66, isDST] = rec::lookup(gocpp::recv(t.loc), rec::Unix(gocpp::recv(t)));
        return isDST;
    }

    bool isLeap(int year)
    {
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
    }

    // norm returns nhi, nlo such that
    //
    //	hi * base + lo == nhi * base + nlo
    //	0 <= nlo < base
    std::tuple<int, int> norm(int hi, int lo, int base)
    {
        int nhi;
        int nlo;
        if(lo < 0)
        {
            auto n = (- lo - 1) / base + 1;
            hi -= n;
            lo += n * base;
        }
        if(lo >= base)
        {
            auto n = lo / base;
            hi += n;
            lo -= n * base;
        }
        return {hi, lo};
    }

    // Date returns the Time corresponding to
    //
    //	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
    //
    // in the appropriate zone for that time in the given location.
    //
    // The month, day, hour, min, sec, and nsec values may be outside
    // their usual ranges and will be normalized during the conversion.
    // For example, October 32 converts to November 1.
    //
    // A daylight savings time transition skips or repeats times.
    // For example, in the United States, March 13, 2011 2:15am never occurred,
    // while November 6, 2011 1:15am occurred twice. In such cases, the
    // choice of time zone, and therefore the time, is not well-defined.
    // Date returns a time that is correct in one of the two zones involved
    // in the transition, but it does not guarantee which.
    //
    // Date panics if loc is nil.
    struct Time Date(int year, golang::time::Month month, int day, int hour, int min, int sec, int nsec, struct Location* loc)
    {
        if(loc == nullptr)
        {
            gocpp::panic("time: missing Location in call to Date"s);
        }
        auto m = int(month) - 1;
        std::tie(year, m) = norm(year, m, 12);
        month = Month(m) + 1;
        std::tie(sec, nsec) = norm(sec, nsec, 1e9);
        std::tie(min, sec) = norm(min, sec, 60);
        std::tie(hour, min) = norm(hour, min, 60);
        std::tie(day, hour) = norm(day, hour, 24);
        auto d = daysSinceEpoch(year);
        d += uint64_t(daysBefore[month - 1]);
        if(isLeap(year) && month >= March)
        {
            d++;
        }
        d += uint64_t(day - 1);
        auto abs = d * secondsPerDay;
        abs += uint64_t(hour * secondsPerHour + min * secondsPerMinute + sec);
        auto unix = int64_t(abs) + (absoluteToInternal + internalToUnix);
        auto [gocpp_id_69, offset, start, end, gocpp_id_70] = rec::lookup(gocpp::recv(loc), unix);
        if(offset != 0)
        {
            auto utc = unix - int64_t(offset);
            if(utc < start || utc >= end)
            {
                std::tie(gocpp_id_71, offset, gocpp_id_72, gocpp_id_73, gocpp_id_74) = rec::lookup(gocpp::recv(loc), utc);
            }
            unix -= int64_t(offset);
        }
        auto t = unixTime(unix, int32_t(nsec));
        rec::setLoc(gocpp::recv(t), loc);
        return t;
    }

    // Truncate returns the result of rounding t down to a multiple of d (since the zero time).
    // If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.
    //
    // Truncate operates on the time as an absolute duration since the
    // zero time; it does not operate on the presentation form of the
    // time. Thus, Truncate(Hour) may return a time with a non-zero
    // minute, depending on the time's Location.
    struct Time rec::Truncate(struct Time t, golang::time::Duration d)
    {
        rec::stripMono(gocpp::recv(t));
        if(d <= 0)
        {
            return t;
        }
        auto [gocpp_id_76, r] = div(t, d);
        return rec::Add(gocpp::recv(t), - r);
    }

    // Round returns the result of rounding t to the nearest multiple of d (since the zero time).
    // The rounding behavior for halfway values is to round up.
    // If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.
    //
    // Round operates on the time as an absolute duration since the
    // zero time; it does not operate on the presentation form of the
    // time. Thus, Round(Hour) may return a time with a non-zero
    // minute, depending on the time's Location.
    struct Time rec::Round(struct Time t, golang::time::Duration d)
    {
        rec::stripMono(gocpp::recv(t));
        if(d <= 0)
        {
            return t;
        }
        auto [gocpp_id_78, r] = div(t, d);
        if(lessThanHalf(r, d))
        {
            return rec::Add(gocpp::recv(t), - r);
        }
        return rec::Add(gocpp::recv(t), d - r);
    }

    // div divides t by d and returns the quotient parity and remainder.
    // We don't use the quotient parity anymore (round half up instead of round to even)
    // but it's still here in case we change our minds.
    std::tuple<int, time::Duration> div(struct Time t, golang::time::Duration d)
    {
        int qmod2;
        time::Duration r;
        auto neg = false;
        auto nsec = rec::nsec(gocpp::recv(t));
        auto sec = rec::sec(gocpp::recv(t));
        if(sec < 0)
        {
            neg = true;
            sec = - sec;
            nsec = - nsec;
            if(nsec < 0)
            {
                nsec += 1e9;
                sec--;
            }
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(d < Second && Second % (d + d) == 0) { conditionId = 0; }
            else if(d % Second == 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    qmod2 = int(nsec / int32_t(d)) & 1;
                    r = Duration(nsec % int32_t(d));
                    break;
                case 1:
                    auto d1 = int64_t(d / Second);
                    qmod2 = int(sec / d1) & 1;
                    r = Duration(sec % d1) * Second + Duration(nsec);
                    break;
                default:
                    auto sec = uint64_t(sec);
                    auto tmp = (sec >> 32) * 1e9;
                    auto u1 = tmp >> 32;
                    auto u0 = tmp << 32;
                    tmp = (sec & 0xFFFFFFFF) * 1e9;
                    uint64_t u0x;
                    std::tie(u0x, u0) = std::tuple{u0, u0 + tmp};
                    if(u0 < u0x)
                    {
                        u1++;
                    }
                    std::tie(u0x, u0) = std::tuple{u0, u0 + uint64_t(nsec)};
                    if(u0 < u0x)
                    {
                        u1++;
                    }
                    auto d1 = uint64_t(d);
                    for(; (d1 >> 63) != 1; )
                    {
                        d1 <<= 1;
                    }
                    auto d0 = uint64_t(0);
                    for(; ; )
                    {
                        qmod2 = 0;
                        if(u1 > d1 || u1 == d1 && u0 >= d0)
                        {
                            qmod2 = 1;
                            std::tie(u0x, u0) = std::tuple{u0, u0 - d0};
                            if(u0 > u0x)
                            {
                                u1--;
                            }
                            u1 -= d1;
                        }
                        if(d1 == 0 && d0 == uint64_t(d))
                        {
                            break;
                        }
                        d0 >>= 1;
                        d0 |= (d1 & 1) << 63;
                        d1 >>= 1;
                    }
                    r = Duration(u0);
                    break;
            }
        }
        if(neg && r != 0)
        {
            qmod2 ^= 1;
            r = d - r;
        }
        return {qmod2, r};
    }

}

