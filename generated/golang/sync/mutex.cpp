// generated by GoCpp from file '$(ImportDir)/sync/mutex.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/mutex.h"
#include "gocpp/support.h"

// #include "golang/internal/race/norace.h"  [Ignored, known errors]
// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
// #include "golang/sync/runtime.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    void go_throw(std::string)
    /* convertBlockStmt, nil block */;

    void fatal(std::string)
    /* convertBlockStmt, nil block */;

    
    std::ostream& Mutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << state;
        os << " " << sema;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Mutex& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Locker::Locker(T& ref)
    {
        value.reset(new LockerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Locker::Locker(const T& ref)
    {
        value.reset(new LockerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Locker::Locker(T* ptr)
    {
        value.reset(new LockerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Locker::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Locker::LockerImpl<T, StoreT>::vLock()
    {
        return Lock(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void Locker::LockerImpl<T, StoreT>::vUnlock()
    {
        return Unlock(gocpp::PtrRecv<T, false>(value.get()));
    }

    void Lock(const gocpp::PtrRecv<Locker, false>& self)
    {
        return self.ptr->value->vLock();
    }

    void Lock(const gocpp::ObjRecv<Locker>& self)
    {
        return self.obj.value->vLock();
    }

    void Unlock(const gocpp::PtrRecv<Locker, false>& self)
    {
        return self.ptr->value->vUnlock();
    }

    void Unlock(const gocpp::ObjRecv<Locker>& self)
    {
        return self.obj.value->vUnlock();
    }

    std::ostream& operator<<(std::ostream& os, const struct Locker& value)
    {
        return value.PrintTo(os);
    }

    int mutexLocked = 1 << 0;
    int mutexWoken = 1 << 1;
    int mutexStarving = 1 << 2;
    int mutexWaiterShift = 3;
    double starvationThresholdNs = 1e6;
    void Lock(struct Mutex* m)
    {
        if(CompareAndSwapInt32(gocpp::recv(atomic), & m->state, 0, mutexLocked))
        {
            if(race.Enabled)
            {
                Acquire(gocpp::recv(race), Pointer(gocpp::recv(unsafe), m));
            }
            return;
        }
        lockSlow(gocpp::recv(m));
    }

    bool TryLock(struct Mutex* m)
    {
        auto old = m->state;
        if(old & (mutexLocked | mutexStarving) != 0)
        {
            return false;
        }
        if(! CompareAndSwapInt32(gocpp::recv(atomic), & m->state, old, old | mutexLocked))
        {
            return false;
        }
        if(race.Enabled)
        {
            Acquire(gocpp::recv(race), Pointer(gocpp::recv(unsafe), m));
        }
        return true;
    }

    void lockSlow(struct Mutex* m)
    {
        int64_t waitStartTime = {};
        auto starving = false;
        auto awoke = false;
        auto iter = 0;
        auto old = m->state;
        for(; ; )
        {
            if(old & (mutexLocked | mutexStarving) == mutexLocked && runtime_canSpin(iter))
            {
                if(! awoke && old & mutexWoken == 0 && (old >> mutexWaiterShift) != 0 && CompareAndSwapInt32(gocpp::recv(atomic), & m->state, old, old | mutexWoken))
                {
                    awoke = true;
                }
                runtime_doSpin();
                iter++;
                old = m->state;
                continue;
            }
            auto go_new = old;
            if(old & mutexStarving == 0)
            {
                go_new |= mutexLocked;
            }
            if(old & (mutexLocked | mutexStarving) != 0)
            {
                go_new += 1 << mutexWaiterShift;
            }
            if(starving && old & mutexLocked != 0)
            {
                go_new |= mutexStarving;
            }
            if(awoke)
            {
                if(go_new & mutexWoken == 0)
                {
                    go_throw("sync: inconsistent mutex state");
                }
                go_new &^= mutexWoken;
            }
            if(CompareAndSwapInt32(gocpp::recv(atomic), & m->state, old, go_new))
            {
                if(old & (mutexLocked | mutexStarving) == 0)
                {
                    break;
                }
                auto queueLifo = waitStartTime != 0;
                if(waitStartTime == 0)
                {
                    waitStartTime = runtime_nanotime();
                }
                runtime_SemacquireMutex(& m->sema, queueLifo, 1);
                starving = starving || runtime_nanotime() - waitStartTime > starvationThresholdNs;
                old = m->state;
                if(old & mutexStarving != 0)
                {
                    if(old & (mutexLocked | mutexWoken) != 0 || (old >> mutexWaiterShift) == 0)
                    {
                        go_throw("sync: inconsistent mutex state");
                    }
                    auto delta = int32(mutexLocked - (1 << mutexWaiterShift));
                    if(! starving || (old >> mutexWaiterShift) == 1)
                    {
                        delta -= mutexStarving;
                    }
                    AddInt32(gocpp::recv(atomic), & m->state, delta);
                    break;
                }
                awoke = true;
                iter = 0;
            }
            else
            {
                old = m->state;
            }
        }
        if(race.Enabled)
        {
            Acquire(gocpp::recv(race), Pointer(gocpp::recv(unsafe), m));
        }
    }

    void Unlock(struct Mutex* m)
    {
        if(race.Enabled)
        {
            _ = m->state;
            Release(gocpp::recv(race), Pointer(gocpp::recv(unsafe), m));
        }
        auto go_new = AddInt32(gocpp::recv(atomic), & m->state, - mutexLocked);
        if(go_new != 0)
        {
            unlockSlow(gocpp::recv(m), go_new);
        }
    }

    void unlockSlow(struct Mutex* m, int32_t go_new)
    {
        if((go_new + mutexLocked) & mutexLocked == 0)
        {
            fatal("sync: unlock of unlocked mutex");
        }
        if(go_new & mutexStarving == 0)
        {
            auto old = go_new;
            for(; ; )
            {
                if((old >> mutexWaiterShift) == 0 || old & (mutexLocked | mutexWoken | mutexStarving) != 0)
                {
                    return;
                }
                go_new = (old - (1 << mutexWaiterShift)) | mutexWoken;
                if(CompareAndSwapInt32(gocpp::recv(atomic), & m->state, old, go_new))
                {
                    runtime_Semrelease(& m->sema, false, 1);
                    return;
                }
                old = m->state;
            }
        }
        else
        {
            runtime_Semrelease(& m->sema, true, 1);
        }
    }

}

