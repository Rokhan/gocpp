// generated by GoCpp from file '$(ImportDir)/runtime/symtab.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/symtab.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtabinl.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Frames::operator T()
    {
        T result;
        result.callers = this->callers;
        result.frames = this->frames;
        result.frameStore = this->frameStore;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Frames::operator==(const T& ref) const
    {
        if (callers != ref.callers) return false;
        if (frames != ref.frames) return false;
        if (frameStore != ref.frameStore) return false;
        return true;
    }

    std::ostream& Frames::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << callers;
        os << " " << frames;
        os << " " << frameStore;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Frames& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Frame::operator T()
    {
        T result;
        result.PC = this->PC;
        result.Func = this->Func;
        result.Function = this->Function;
        result.File = this->File;
        result.Line = this->Line;
        result.startLine = this->startLine;
        result.Entry = this->Entry;
        result.funcInfo = this->funcInfo;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Frame::operator==(const T& ref) const
    {
        if (PC != ref.PC) return false;
        if (Func != ref.Func) return false;
        if (Function != ref.Function) return false;
        if (File != ref.File) return false;
        if (Line != ref.Line) return false;
        if (startLine != ref.startLine) return false;
        if (Entry != ref.Entry) return false;
        if (funcInfo != ref.funcInfo) return false;
        return true;
    }

    std::ostream& Frame::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PC;
        os << " " << Func;
        os << " " << Function;
        os << " " << File;
        os << " " << Line;
        os << " " << startLine;
        os << " " << Entry;
        os << " " << funcInfo;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Frame& value)
    {
        return value.PrintTo(os);
    }

    struct Frames* CallersFrames(gocpp::slice<uintptr_t> callers)
    {
        auto f = gocpp::InitPtr<Frames>([=](auto& x) {
            x.callers = callers;
        });
        f->frames = f->frameStore.make_slice(0, 0);
        return f;
    }

    std::tuple<struct Frame, bool> rec::Next(struct Frames* ci)
    {
        struct Frame frame;
        bool more;
        for(; len(ci->frames) < 2; )
        {
            struct Frame frame;
            bool more;
            if(len(ci->callers) == 0)
            {
                struct Frame frame;
                bool more;
                break;
            }
            auto pc = ci->callers[0];
            ci->callers = ci->callers.make_slice(1);
            auto funcInfo = findfunc(pc);
            if(! rec::valid(gocpp::recv(funcInfo)))
            {
                struct Frame frame;
                bool more;
                if(cgoSymbolizer != nullptr)
                {
                    struct Frame frame;
                    bool more;
                    ci->frames = append(ci->frames, expandCgoFrames(pc));
                }
                continue;
            }
            auto f = rec::_Func(gocpp::recv(funcInfo));
            auto entry = rec::Entry(gocpp::recv(f));
            if(pc > entry)
            {
                struct Frame frame;
                bool more;
                pc--;
            }
            auto [u, uf] = newInlineUnwinder(funcInfo, pc);
            auto sf = rec::srcFunc(gocpp::recv(u), uf);
            if(rec::isInlined(gocpp::recv(u), uf))
            {
                struct Frame frame;
                bool more;
                f = nullptr;
            }
            ci->frames = append(ci->frames, gocpp::Init<Frame>([=](auto& x) {
                x.PC = pc;
                x.Func = f;
                x.Function = funcNameForPrint(rec::name(gocpp::recv(sf)));
                x.Entry = entry;
                x.startLine = int(sf.startLine);
                x.funcInfo = funcInfo;
            }));
        }
        //Go switch emulation
        {
            auto condition = len(ci->frames);
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                struct Frame frame;
                bool more;
                case 0:
                    return {frame, more};
                    break;
                case 1:
                    frame = ci->frames[0];
                    ci->frames = ci->frameStore.make_slice(0, 0);
                    break;
                case 2:
                    frame = ci->frames[0];
                    ci->frameStore[0] = ci->frames[1];
                    ci->frames = ci->frameStore.make_slice(0, 1);
                    break;
                default:
                    frame = ci->frames[0];
                    ci->frames = ci->frames.make_slice(1);
                    break;
            }
        }
        more = len(ci->frames) > 0;
        if(rec::valid(gocpp::recv(frame.funcInfo)))
        {
            struct Frame frame;
            bool more;
            auto [file, line] = funcline1(frame.funcInfo, frame.PC, false);
            std::tie(frame.File, frame.Line) = std::tuple{file, int(line)};
        }
        return {frame, more};
    }

    int runtime_FrameStartLine(struct Frame* f)
    {
        return f->startLine;
    }

    std::string runtime_FrameSymbolName(struct Frame* f)
    {
        if(! rec::valid(gocpp::recv(f->funcInfo)))
        {
            return f->Function;
        }
        auto [u, uf] = newInlineUnwinder(f->funcInfo, f->PC);
        auto sf = rec::srcFunc(gocpp::recv(u), uf);
        return rec::name(gocpp::recv(sf));
    }

    gocpp::slice<uintptr_t> runtime_expandFinalInlineFrame(gocpp::slice<uintptr_t> stk)
    {
        if(len(stk) == 0)
        {
            return stk;
        }
        auto pc = stk[len(stk) - 1];
        auto tracepc = pc - 1;
        auto f = findfunc(tracepc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return stk;
        }
        auto [u, uf] = newInlineUnwinder(f, tracepc);
        if(! rec::isInlined(gocpp::recv(u), uf))
        {
            return stk;
        }
        auto calleeID = abi::FuncIDNormal;
        stk = stk.make_slice(0, len(stk) - 1);
        for(; rec::valid(gocpp::recv(uf)); uf = rec::next(gocpp::recv(u), uf))
        {
            auto funcID = rec::srcFunc(gocpp::recv(u), uf).funcID;
            if(funcID == abi::FuncIDWrapper && elideWrapperCalling(calleeID))
            {
            }
            else
            {
                stk = append(stk, uf.pc + 1);
            }
            calleeID = funcID;
        }
        return stk;
    }

    gocpp::slice<Frame> expandCgoFrames(uintptr_t pc)
    {
        auto arg = gocpp::Init<cgoSymbolizerArg>([=](auto& x) {
            x.pc = pc;
        });
        callCgoSymbolizer(& arg);
        if(arg.file == nullptr && arg.funcName == nullptr)
        {
            return nullptr;
        }
        gocpp::slice<Frame> frames = {};
        for(; ; )
        {
            frames = append(frames, gocpp::Init<Frame>([=](auto& x) {
                x.PC = pc;
                x.Func = nullptr;
                x.Function = gostring(arg.funcName);
                x.File = gostring(arg.file);
                x.Line = int(arg.lineno);
                x.Entry = arg.entry;
            }));
            if(arg.more == 0)
            {
                break;
            }
            callCgoSymbolizer(& arg);
        }
        arg.pc = 0;
        callCgoSymbolizer(& arg);
        return frames;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    Func::operator T()
    {
        T result;
        result.opaque = this->opaque;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Func::operator==(const T& ref) const
    {
        if (opaque != ref.opaque) return false;
        return true;
    }

    std::ostream& Func::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << opaque;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Func& value)
    {
        return value.PrintTo(os);
    }

    struct _func* rec::raw(struct Func* f)
    {
        return (_func*)(unsafe::Pointer(f));
    }

    struct funcInfo rec::funcInfo(struct Func* f)
    {
        return rec::funcInfo(gocpp::recv(rec::raw(gocpp::recv(f))));
    }

    struct funcInfo rec::funcInfo(struct _func* f)
    {
        auto ptr = uintptr_t(unsafe::Pointer(f));
        moduledata* mod = {};
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(len(datap->pclntable) == 0)
            {
                continue;
            }
            auto base = uintptr_t(unsafe::Pointer(& datap->pclntable[0]));
            if(base <= ptr && ptr < base + uintptr_t(len(datap->pclntable)))
            {
                mod = datap;
                break;
            }
        }
        return funcInfo {f, mod};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pcHeader::operator T()
    {
        T result;
        result.magic = this->magic;
        result.pad1 = this->pad1;
        result.pad2 = this->pad2;
        result.minLC = this->minLC;
        result.ptrSize = this->ptrSize;
        result.nfunc = this->nfunc;
        result.nfiles = this->nfiles;
        result.textStart = this->textStart;
        result.funcnameOffset = this->funcnameOffset;
        result.cuOffset = this->cuOffset;
        result.filetabOffset = this->filetabOffset;
        result.pctabOffset = this->pctabOffset;
        result.pclnOffset = this->pclnOffset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pcHeader::operator==(const T& ref) const
    {
        if (magic != ref.magic) return false;
        if (pad1 != ref.pad1) return false;
        if (pad2 != ref.pad2) return false;
        if (minLC != ref.minLC) return false;
        if (ptrSize != ref.ptrSize) return false;
        if (nfunc != ref.nfunc) return false;
        if (nfiles != ref.nfiles) return false;
        if (textStart != ref.textStart) return false;
        if (funcnameOffset != ref.funcnameOffset) return false;
        if (cuOffset != ref.cuOffset) return false;
        if (filetabOffset != ref.filetabOffset) return false;
        if (pctabOffset != ref.pctabOffset) return false;
        if (pclnOffset != ref.pclnOffset) return false;
        return true;
    }

    std::ostream& pcHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << magic;
        os << " " << pad1;
        os << " " << pad2;
        os << " " << minLC;
        os << " " << ptrSize;
        os << " " << nfunc;
        os << " " << nfiles;
        os << " " << textStart;
        os << " " << funcnameOffset;
        os << " " << cuOffset;
        os << " " << filetabOffset;
        os << " " << pctabOffset;
        os << " " << pclnOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pcHeader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    moduledata::operator T()
    {
        T result;
        result.pcHeader = this->pcHeader;
        result.funcnametab = this->funcnametab;
        result.cutab = this->cutab;
        result.filetab = this->filetab;
        result.pctab = this->pctab;
        result.pclntable = this->pclntable;
        result.ftab = this->ftab;
        result.findfunctab = this->findfunctab;
        result.minpc = this->minpc;
        result.maxpc = this->maxpc;
        result.text = this->text;
        result.etext = this->etext;
        result.noptrdata = this->noptrdata;
        result.enoptrdata = this->enoptrdata;
        result.data = this->data;
        result.edata = this->edata;
        result.bss = this->bss;
        result.ebss = this->ebss;
        result.noptrbss = this->noptrbss;
        result.enoptrbss = this->enoptrbss;
        result.covctrs = this->covctrs;
        result.ecovctrs = this->ecovctrs;
        result.end = this->end;
        result.gcdata = this->gcdata;
        result.gcbss = this->gcbss;
        result.types = this->types;
        result.etypes = this->etypes;
        result.rodata = this->rodata;
        result.gofunc = this->gofunc;
        result.textsectmap = this->textsectmap;
        result.typelinks = this->typelinks;
        result.itablinks = this->itablinks;
        result.ptab = this->ptab;
        result.pluginpath = this->pluginpath;
        result.pkghashes = this->pkghashes;
        result.inittasks = this->inittasks;
        result.modulename = this->modulename;
        result.modulehashes = this->modulehashes;
        result.hasmain = this->hasmain;
        result.gcdatamask = this->gcdatamask;
        result.gcbssmask = this->gcbssmask;
        result.typemap = this->typemap;
        result.bad = this->bad;
        result.next = this->next;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool moduledata::operator==(const T& ref) const
    {
        if (pcHeader != ref.pcHeader) return false;
        if (funcnametab != ref.funcnametab) return false;
        if (cutab != ref.cutab) return false;
        if (filetab != ref.filetab) return false;
        if (pctab != ref.pctab) return false;
        if (pclntable != ref.pclntable) return false;
        if (ftab != ref.ftab) return false;
        if (findfunctab != ref.findfunctab) return false;
        if (minpc != ref.minpc) return false;
        if (maxpc != ref.maxpc) return false;
        if (text != ref.text) return false;
        if (etext != ref.etext) return false;
        if (noptrdata != ref.noptrdata) return false;
        if (enoptrdata != ref.enoptrdata) return false;
        if (data != ref.data) return false;
        if (edata != ref.edata) return false;
        if (bss != ref.bss) return false;
        if (ebss != ref.ebss) return false;
        if (noptrbss != ref.noptrbss) return false;
        if (enoptrbss != ref.enoptrbss) return false;
        if (covctrs != ref.covctrs) return false;
        if (ecovctrs != ref.ecovctrs) return false;
        if (end != ref.end) return false;
        if (gcdata != ref.gcdata) return false;
        if (gcbss != ref.gcbss) return false;
        if (types != ref.types) return false;
        if (etypes != ref.etypes) return false;
        if (rodata != ref.rodata) return false;
        if (gofunc != ref.gofunc) return false;
        if (textsectmap != ref.textsectmap) return false;
        if (typelinks != ref.typelinks) return false;
        if (itablinks != ref.itablinks) return false;
        if (ptab != ref.ptab) return false;
        if (pluginpath != ref.pluginpath) return false;
        if (pkghashes != ref.pkghashes) return false;
        if (inittasks != ref.inittasks) return false;
        if (modulename != ref.modulename) return false;
        if (modulehashes != ref.modulehashes) return false;
        if (hasmain != ref.hasmain) return false;
        if (gcdatamask != ref.gcdatamask) return false;
        if (gcbssmask != ref.gcbssmask) return false;
        if (typemap != ref.typemap) return false;
        if (bad != ref.bad) return false;
        if (next != ref.next) return false;
        return true;
    }

    std::ostream& moduledata::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pcHeader;
        os << " " << funcnametab;
        os << " " << cutab;
        os << " " << filetab;
        os << " " << pctab;
        os << " " << pclntable;
        os << " " << ftab;
        os << " " << findfunctab;
        os << " " << minpc;
        os << " " << maxpc;
        os << " " << text;
        os << " " << etext;
        os << " " << noptrdata;
        os << " " << enoptrdata;
        os << " " << data;
        os << " " << edata;
        os << " " << bss;
        os << " " << ebss;
        os << " " << noptrbss;
        os << " " << enoptrbss;
        os << " " << covctrs;
        os << " " << ecovctrs;
        os << " " << end;
        os << " " << gcdata;
        os << " " << gcbss;
        os << " " << types;
        os << " " << etypes;
        os << " " << rodata;
        os << " " << gofunc;
        os << " " << textsectmap;
        os << " " << typelinks;
        os << " " << itablinks;
        os << " " << ptab;
        os << " " << pluginpath;
        os << " " << pkghashes;
        os << " " << inittasks;
        os << " " << modulename;
        os << " " << modulehashes;
        os << " " << hasmain;
        os << " " << gcdatamask;
        os << " " << gcbssmask;
        os << " " << typemap;
        os << " " << bad;
        os << " " << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct moduledata& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    modulehash::operator T()
    {
        T result;
        result.modulename = this->modulename;
        result.linktimehash = this->linktimehash;
        result.runtimehash = this->runtimehash;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool modulehash::operator==(const T& ref) const
    {
        if (modulename != ref.modulename) return false;
        if (linktimehash != ref.linktimehash) return false;
        if (runtimehash != ref.runtimehash) return false;
        return true;
    }

    std::ostream& modulehash::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << modulename;
        os << " " << linktimehash;
        os << " " << runtimehash;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct modulehash& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<gocpp::map<runtime::typeOff, runtime::_type*>> pinnedTypemaps;
    moduledata firstmoduledata;
    moduledata* lastmoduledatap;
    gocpp::slice<moduledata*>* modulesSlice;
    gocpp::slice<moduledata*> activeModules()
    {
        auto p = (gocpp::slice<moduledata*>*)(atomic::Loadp(unsafe::Pointer(& modulesSlice)));
        if(p == nullptr)
        {
            return nullptr;
        }
        return *p;
    }

    void modulesinit()
    {
        auto modules = new(gocpp::Tag<gocpp::slice<moduledata*>>());
        for(auto md = & firstmoduledata; md != nullptr; md = md->next)
        {
            if(md->bad)
            {
                continue;
            }
            *modules = append(*modules, md);
            if(md->gcdatamask == (bitvector {}))
            {
                auto scanDataSize = md->edata - md->data;
                md->gcdatamask = progToPointerMask((unsigned char*)(unsafe::Pointer(md->gcdata)), scanDataSize);
                auto scanBSSSize = md->ebss - md->bss;
                md->gcbssmask = progToPointerMask((unsigned char*)(unsafe::Pointer(md->gcbss)), scanBSSSize);
                rec::addGlobals(gocpp::recv(gcController), int64_t(scanDataSize + scanBSSSize));
            }
        }
        for(auto [i, md] : *modules)
        {
            if(md->hasmain != 0)
            {
                (*modules)[0] = md;
                (*modules)[i] = & firstmoduledata;
                break;
            }
        }
        atomicstorep(unsafe::Pointer(& modulesSlice), unsafe::Pointer(modules));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    functab::operator T()
    {
        T result;
        result.entryoff = this->entryoff;
        result.funcoff = this->funcoff;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool functab::operator==(const T& ref) const
    {
        if (entryoff != ref.entryoff) return false;
        if (funcoff != ref.funcoff) return false;
        return true;
    }

    std::ostream& functab::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << entryoff;
        os << " " << funcoff;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct functab& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    textsect::operator T()
    {
        T result;
        result.vaddr = this->vaddr;
        result.end = this->end;
        result.baseaddr = this->baseaddr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool textsect::operator==(const T& ref) const
    {
        if (vaddr != ref.vaddr) return false;
        if (end != ref.end) return false;
        if (baseaddr != ref.baseaddr) return false;
        return true;
    }

    std::ostream& textsect::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << vaddr;
        os << " " << end;
        os << " " << baseaddr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct textsect& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    findfuncbucket::operator T()
    {
        T result;
        result.idx = this->idx;
        result.subbuckets = this->subbuckets;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool findfuncbucket::operator==(const T& ref) const
    {
        if (idx != ref.idx) return false;
        if (subbuckets != ref.subbuckets) return false;
        return true;
    }

    std::ostream& findfuncbucket::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << idx;
        os << " " << subbuckets;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct findfuncbucket& value)
    {
        return value.PrintTo(os);
    }

    void moduledataverify()
    {
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            moduledataverify1(datap);
        }
    }

    void moduledataverify1(struct moduledata* datap)
    {
        auto hdr = datap->pcHeader;
        if(hdr->magic != 0xfffffff1 || hdr->pad1 != 0 || hdr->pad2 != 0 || hdr->minLC != sys::PCQuantum || hdr->ptrSize != goarch::PtrSize || hdr->textStart != datap->text)
        {
            println("runtime: pcHeader: magic=", hex(hdr->magic), "pad1=", hdr->pad1, "pad2=", hdr->pad2, "minLC=", hdr->minLC, "ptrSize=", hdr->ptrSize, "pcHeader.textStart=", hex(hdr->textStart), "text=", hex(datap->text), "pluginpath=", datap->pluginpath);
            go_throw("invalid function symbol table");
        }
        auto nftab = len(datap->ftab) - 1;
        for(auto i = 0; i < nftab; i++)
        {
            if(datap->ftab[i].entryoff > datap->ftab[i + 1].entryoff)
            {
                auto f1 = funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[datap->ftab[i].funcoff])), datap};
                auto f2 = funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[datap->ftab[i + 1].funcoff])), datap};
                auto f2name = "end";
                if(i + 1 < nftab)
                {
                    f2name = funcname(f2);
                }
                println("function symbol table not sorted by PC offset:", hex(datap->ftab[i].entryoff), funcname(f1), ">", hex(datap->ftab[i + 1].entryoff), f2name, ", plugin:", datap->pluginpath);
                for(auto j = 0; j <= i; j++)
                {
                    println("\t", hex(datap->ftab[j].entryoff), funcname(funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[datap->ftab[j].funcoff])), datap}));
                }
                if(GOOS == "aix" && isarchive)
                {
                    println("-Wl,-bnoobjreorder is mandatory on aix/ppc64 with c-archive");
                }
                go_throw("invalid runtime symbol table");
            }
        }
        auto min = rec::textAddr(gocpp::recv(datap), datap->ftab[0].entryoff);
        auto max = rec::textAddr(gocpp::recv(datap), datap->ftab[nftab].entryoff);
        if(datap->minpc != min || datap->maxpc != max)
        {
            println("minpc=", hex(datap->minpc), "min=", hex(min), "maxpc=", hex(datap->maxpc), "max=", hex(max));
            go_throw("minpc or maxpc invalid");
        }
        for(auto [gocpp_ignored, modulehash] : datap->modulehashes)
        {
            if(modulehash.linktimehash != *modulehash.runtimehash)
            {
                println("abi mismatch detected between", datap->modulename, "and", modulehash.modulename);
                go_throw("abi mismatch");
            }
        }
    }

    uintptr_t rec::textAddr(struct moduledata* md, uint32_t off32)
    {
        auto off = uintptr_t(off32);
        auto res = md->text + off;
        if(len(md->textsectmap) > 1)
        {
            for(auto [i, sect] : md->textsectmap)
            {
                if(off >= sect.vaddr && off < sect.end || (i == len(md->textsectmap) - 1 && off == sect.end))
                {
                    res = sect.baseaddr + off - sect.vaddr;
                    break;
                }
            }
            if(res > md->etext && GOARCH != "wasm")
            {
                println("runtime: textAddr", hex(res), "out of range", hex(md->text), "-", hex(md->etext));
                go_throw("runtime: text offset out of range");
            }
        }
        return res;
    }

    std::tuple<uint32_t, bool> rec::textOff(struct moduledata* md, uintptr_t pc)
    {
        auto res = uint32_t(pc - md->text);
        if(len(md->textsectmap) > 1)
        {
            for(auto [i, sect] : md->textsectmap)
            {
                if(sect.baseaddr > pc)
                {
                    return {0, false};
                }
                auto end = sect.baseaddr + (sect.end - sect.vaddr);
                if(i == len(md->textsectmap) - 1)
                {
                    end++;
                }
                if(pc < end)
                {
                    res = uint32_t(pc - sect.baseaddr + sect.vaddr);
                    break;
                }
            }
        }
        return {res, true};
    }

    std::string rec::funcName(struct moduledata* md, int32_t nameOff)
    {
        if(nameOff == 0)
        {
            return "";
        }
        return gostringnocopy(& md->funcnametab[nameOff]);
    }

    struct Func* FuncForPC(uintptr_t pc)
    {
        auto f = findfunc(pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return nullptr;
        }
        auto [u, uf] = newInlineUnwinder(f, pc);
        if(! rec::isInlined(gocpp::recv(u), uf))
        {
            return rec::_Func(gocpp::recv(f));
        }
        auto sf = rec::srcFunc(gocpp::recv(u), uf);
        auto [file, line] = rec::fileLine(gocpp::recv(u), uf);
        auto fi = gocpp::InitPtr<funcinl>([=](auto& x) {
            x.ones = ~ uint32_t(0);
            x.entry = rec::entry(gocpp::recv(f));
            x.name = rec::name(gocpp::recv(sf));
            x.file = file;
            x.line = int32_t(line);
            x.startLine = sf.startLine;
        });
        return (Func*)(unsafe::Pointer(fi));
    }

    std::string rec::Name(struct Func* f)
    {
        if(f == nullptr)
        {
            return "";
        }
        auto fn = rec::raw(gocpp::recv(f));
        if(rec::isInlined(gocpp::recv(fn)))
        {
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return funcNameForPrint(fi->name);
        }
        return funcNameForPrint(funcname(rec::funcInfo(gocpp::recv(f))));
    }

    uintptr_t rec::Entry(struct Func* f)
    {
        auto fn = rec::raw(gocpp::recv(f));
        if(rec::isInlined(gocpp::recv(fn)))
        {
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return fi->entry;
        }
        return rec::entry(gocpp::recv(rec::funcInfo(gocpp::recv(fn))));
    }

    std::tuple<std::string, int> rec::FileLine(struct Func* f, uintptr_t pc)
    {
        std::string file;
        int line;
        auto fn = rec::raw(gocpp::recv(f));
        if(rec::isInlined(gocpp::recv(fn)))
        {
            std::string file;
            int line;
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return {fi->file, int(fi->line)};
        }
        auto [file, line32] = funcline1(rec::funcInfo(gocpp::recv(f)), pc, false);
        return {file, int(line32)};
    }

    int32_t rec::startLine(struct Func* f)
    {
        auto fn = rec::raw(gocpp::recv(f));
        if(rec::isInlined(gocpp::recv(fn)))
        {
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return fi->startLine;
        }
        return rec::funcInfo(gocpp::recv(fn)).startLine;
    }

    struct moduledata* findmoduledatap(uintptr_t pc)
    {
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(datap->minpc <= pc && pc < datap->maxpc)
            {
                return datap;
            }
        }
        return nullptr;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    funcInfo::operator T()
    {
        T result;
        result.datap = this->datap;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool funcInfo::operator==(const T& ref) const
    {
        if (datap != ref.datap) return false;
        return true;
    }

    std::ostream& funcInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << datap;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct funcInfo& value)
    {
        return value.PrintTo(os);
    }

    bool rec::valid(struct funcInfo f)
    {
        return f._func != nullptr;
    }

    struct Func* rec::_Func(struct funcInfo f)
    {
        return (Func*)(unsafe::Pointer(f._func));
    }

    bool rec::isInlined(struct _func* f)
    {
        return f->entryOff == ~ uint32_t(0);
    }

    uintptr_t rec::entry(struct funcInfo f)
    {
        return rec::textAddr(gocpp::recv(f.datap), f.entryOff);
    }

    struct funcInfo findfunc(uintptr_t pc)
    {
        auto datap = findmoduledatap(pc);
        if(datap == nullptr)
        {
            return funcInfo {};
        }
        auto nsub = uintptr_t(len(findfuncbucket {}.subbuckets));
        auto [pcOff, ok] = rec::textOff(gocpp::recv(datap), pc);
        if(! ok)
        {
            return funcInfo {};
        }
        auto x = uintptr_t(pcOff) + datap->text - datap->minpc;
        auto b = x / pcbucketsize;
        auto i = x % pcbucketsize / (pcbucketsize / nsub);
        auto ffb = (findfuncbucket*)(add(unsafe::Pointer(datap->findfunctab), b * gocpp::Sizeof<findfuncbucket>()));
        auto idx = ffb->idx + uint32_t(ffb->subbuckets[i]);
        for(; datap->ftab[idx + 1].entryoff <= pcOff; )
        {
            idx++;
        }
        auto funcoff = datap->ftab[idx].funcoff;
        return funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[funcoff])), datap};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    srcFunc::operator T()
    {
        T result;
        result.datap = this->datap;
        result.nameOff = this->nameOff;
        result.startLine = this->startLine;
        result.funcID = this->funcID;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool srcFunc::operator==(const T& ref) const
    {
        if (datap != ref.datap) return false;
        if (nameOff != ref.nameOff) return false;
        if (startLine != ref.startLine) return false;
        if (funcID != ref.funcID) return false;
        return true;
    }

    std::ostream& srcFunc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << datap;
        os << " " << nameOff;
        os << " " << startLine;
        os << " " << funcID;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct srcFunc& value)
    {
        return value.PrintTo(os);
    }

    struct srcFunc rec::srcFunc(struct funcInfo f)
    {
        if(! rec::valid(gocpp::recv(f)))
        {
            return srcFunc {};
        }
        return srcFunc {f.datap, f.nameOff, f.startLine, f.funcID};
    }

    std::string rec::name(struct srcFunc s)
    {
        if(s.datap == nullptr)
        {
            return "";
        }
        return rec::funcName(gocpp::recv(s.datap), s.nameOff);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pcvalueCache::operator T()
    {
        T result;
        result.entries = this->entries;
        result.inUse = this->inUse;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pcvalueCache::operator==(const T& ref) const
    {
        if (entries != ref.entries) return false;
        if (inUse != ref.inUse) return false;
        return true;
    }

    std::ostream& pcvalueCache::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << entries;
        os << " " << inUse;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCache& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pcvalueCacheEnt::operator T()
    {
        T result;
        result.targetpc = this->targetpc;
        result.off = this->off;
        result.val = this->val;
        result.valPC = this->valPC;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pcvalueCacheEnt::operator==(const T& ref) const
    {
        if (targetpc != ref.targetpc) return false;
        if (off != ref.off) return false;
        if (val != ref.val) return false;
        if (valPC != ref.valPC) return false;
        return true;
    }

    std::ostream& pcvalueCacheEnt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << targetpc;
        os << " " << off;
        os << " " << val;
        os << " " << valPC;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCacheEnt& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t pcvalueCacheKey(uintptr_t targetpc)
    {
        return (targetpc / goarch::PtrSize) % uintptr_t(len(pcvalueCache {}.entries));
    }

    std::tuple<int32_t, uintptr_t> pcvalue(struct funcInfo f, uint32_t off, uintptr_t targetpc, bool strict)
    {
        auto debugCheckCache = false;
        if(off == 0)
        {
            return {- 1, 0};
        }
        int32_t checkVal = {};
        uintptr_t checkPC = {};
        auto ck = pcvalueCacheKey(targetpc);
        {
            auto mp = acquirem();
            auto cache = & mp->pcvalueCache;
            cache->inUse++;
            if(cache->inUse == 1)
            {
                for(auto [i, gocpp_ignored] : cache->entries[ck])
                {
                    auto ent = & cache->entries[ck][i];
                    if(ent->off == off && ent->targetpc == targetpc)
                    {
                        auto [val, pc] = std::tuple{ent->val, ent->valPC};
                        if(debugCheckCache)
                        {
                            std::tie(checkVal, checkPC) = std::tuple{ent->val, ent->valPC};
                            break;
                        }
                        else
                        {
                            cache->inUse--;
                            releasem(mp);
                            return {val, pc};
                        }
                    }
                }
            }
            else
            if(debugCheckCache && (cache->inUse < 1 || cache->inUse > 2))
            {
                go_throw("cache.inUse out of range");
            }
            cache->inUse--;
            releasem(mp);
        }
        if(! rec::valid(gocpp::recv(f)))
        {
            if(strict && rec::Load(gocpp::recv(panicking)) == 0)
            {
                println("runtime: no module data for", hex(rec::entry(gocpp::recv(f))));
                go_throw("no module data");
            }
            return {- 1, 0};
        }
        auto datap = f.datap;
        auto p = datap->pctab.make_slice(off);
        auto pc = rec::entry(gocpp::recv(f));
        auto prevpc = pc;
        auto val = int32_t(- 1);
        for(; ; )
        {
            bool ok = {};
            std::tie(p, ok) = step(p, & pc, & val, pc == rec::entry(gocpp::recv(f)));
            if(! ok)
            {
                break;
            }
            if(targetpc < pc)
            {
                if(debugCheckCache && checkPC != 0)
                {
                    if(checkVal != val || checkPC != prevpc)
                    {
                        print("runtime: table value ", val, "@", prevpc, " != cache value ", checkVal, "@", checkPC, " at PC ", targetpc, " off ", off, "\n");
                        go_throw("bad pcvalue cache");
                    }
                }
                else
                {
                    auto mp = acquirem();
                    auto cache = & mp->pcvalueCache;
                    cache->inUse++;
                    if(cache->inUse == 1)
                    {
                        auto e = & cache->entries[ck];
                        auto ci = cheaprandn(uint32_t(len(cache->entries[ck])));
                        e[ci] = e[0];
                        e[0] = gocpp::Init<pcvalueCacheEnt>([=](auto& x) {
                            x.targetpc = targetpc;
                            x.off = off;
                            x.val = val;
                            x.valPC = prevpc;
                        });
                    }
                    cache->inUse--;
                    releasem(mp);
                }
                return {val, prevpc};
            }
            prevpc = pc;
        }
        if(rec::Load(gocpp::recv(panicking)) != 0 || ! strict)
        {
            return {- 1, 0};
        }
        print("runtime: invalid pc-encoded table f=", funcname(f), " pc=", hex(pc), " targetpc=", hex(targetpc), " tab=", p, "\n");
        p = datap->pctab.make_slice(off);
        pc = rec::entry(gocpp::recv(f));
        val = - 1;
        for(; ; )
        {
            bool ok = {};
            std::tie(p, ok) = step(p, & pc, & val, pc == rec::entry(gocpp::recv(f)));
            if(! ok)
            {
                break;
            }
            print("\tvalue=", val, " until pc=", hex(pc), "\n");
        }
        go_throw("invalid runtime symbol table");
        return {- 1, 0};
    }

    std::string funcname(struct funcInfo f)
    {
        if(! rec::valid(gocpp::recv(f)))
        {
            return "";
        }
        return rec::funcName(gocpp::recv(f.datap), f.nameOff);
    }

    std::string funcpkgpath(struct funcInfo f)
    {
        auto name = funcNameForPrint(funcname(f));
        auto i = len(name) - 1;
        for(; i > 0; i--)
        {
            if(name[i] == '/')
            {
                break;
            }
        }
        for(; i < len(name); i++)
        {
            if(name[i] == '.')
            {
                break;
            }
        }
        return name.make_slice(0, i);
    }

    std::string funcfile(struct funcInfo f, int32_t fileno)
    {
        auto datap = f.datap;
        if(! rec::valid(gocpp::recv(f)))
        {
            return "?";
        }
        if(auto fileoff = datap->cutab[f.cuOffset + uint32_t(fileno)]; fileoff != ~ uint32_t(0))
        {
            return gostringnocopy(& datap->filetab[fileoff]);
        }
        return "?";
    }

    std::tuple<std::string, int32_t> funcline1(struct funcInfo f, uintptr_t targetpc, bool strict)
    {
        std::string file;
        int32_t line;
        auto datap = f.datap;
        if(! rec::valid(gocpp::recv(f)))
        {
            std::string file;
            int32_t line;
            return {"?", 0};
        }
        auto [fileno, gocpp_id_2] = pcvalue(f, f.pcfile, targetpc, strict);
        std::tie(line, gocpp_id_3) = pcvalue(f, f.pcln, targetpc, strict);
        if(fileno == - 1 || line == - 1 || int(fileno) >= len(datap->filetab))
        {
            std::string file;
            int32_t line;
            return {"?", 0};
        }
        file = funcfile(f, fileno);
        return {file, line};
    }

    std::tuple<std::string, int32_t> funcline(struct funcInfo f, uintptr_t targetpc)
    {
        std::string file;
        int32_t line;
        return funcline1(f, targetpc, true);
    }

    int32_t funcspdelta(struct funcInfo f, uintptr_t targetpc)
    {
        auto [x, gocpp_id_5] = pcvalue(f, f.pcsp, targetpc, true);
        if(debugPcln && x & (goarch::PtrSize - 1) != 0)
        {
            print("invalid spdelta ", funcname(f), " ", hex(rec::entry(gocpp::recv(f))), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n");
            go_throw("bad spdelta");
        }
        return x;
    }

    int32_t funcMaxSPDelta(struct funcInfo f)
    {
        auto datap = f.datap;
        auto p = datap->pctab.make_slice(f.pcsp);
        auto pc = rec::entry(gocpp::recv(f));
        auto val = int32_t(- 1);
        auto most = int32_t(0);
        for(; ; )
        {
            bool ok = {};
            std::tie(p, ok) = step(p, & pc, & val, pc == rec::entry(gocpp::recv(f)));
            if(! ok)
            {
                return most;
            }
            most = gocpp::max(most, val);
        }
    }

    uint32_t pcdatastart(struct funcInfo f, uint32_t table)
    {
        return *(uint32_t*)(add(unsafe::Pointer(& f.nfuncdata), gocpp::Sizeof<uint8_t>() + uintptr_t(table) * 4));
    }

    int32_t pcdatavalue(struct funcInfo f, uint32_t table, uintptr_t targetpc)
    {
        if(table >= f.npcdata)
        {
            return - 1;
        }
        auto [r, gocpp_id_7] = pcvalue(f, pcdatastart(f, table), targetpc, true);
        return r;
    }

    int32_t pcdatavalue1(struct funcInfo f, uint32_t table, uintptr_t targetpc, bool strict)
    {
        if(table >= f.npcdata)
        {
            return - 1;
        }
        auto [r, gocpp_id_9] = pcvalue(f, pcdatastart(f, table), targetpc, strict);
        return r;
    }

    std::tuple<int32_t, uintptr_t> pcdatavalue2(struct funcInfo f, uint32_t table, uintptr_t targetpc)
    {
        if(table >= f.npcdata)
        {
            return {- 1, 0};
        }
        return pcvalue(f, pcdatastart(f, table), targetpc, true);
    }

    unsafe::Pointer funcdata(struct funcInfo f, uint8_t i)
    {
        if(i < 0 || i >= f.nfuncdata)
        {
            return nullptr;
        }
        auto base = f.datap->gofunc;
        auto p = uintptr_t(unsafe::Pointer(& f.nfuncdata)) + gocpp::Sizeof<uint8_t>() + uintptr_t(f.npcdata) * 4 + uintptr_t(i) * 4;
        auto off = *(uint32_t*)(unsafe::Pointer(p));
        uintptr_t mask = {};
        if(off == ~ uint32_t(0))
        {
            mask = 1;
        }
        mask--;
        auto raw = base + uintptr_t(off);
        return unsafe::Pointer(raw & mask);
    }

    std::tuple<gocpp::slice<unsigned char>, bool> step(gocpp::slice<unsigned char> p, uintptr_t* pc, int32_t* val, bool first)
    {
        gocpp::slice<unsigned char> newp;
        bool ok;
        auto uvdelta = uint32_t(p[0]);
        if(uvdelta == 0 && ! first)
        {
            gocpp::slice<unsigned char> newp;
            bool ok;
            return {nullptr, false};
        }
        auto n = uint32_t(1);
        if(uvdelta & 0x80 != 0)
        {
            gocpp::slice<unsigned char> newp;
            bool ok;
            std::tie(n, uvdelta) = readvarint(p);
        }
        *val += int32_t(- (uvdelta & 1) ^ (uvdelta >> 1));
        p = p.make_slice(n);
        auto pcdelta = uint32_t(p[0]);
        n = 1;
        if(pcdelta & 0x80 != 0)
        {
            gocpp::slice<unsigned char> newp;
            bool ok;
            std::tie(n, pcdelta) = readvarint(p);
        }
        p = p.make_slice(n);
        *pc += uintptr_t(pcdelta * sys::PCQuantum);
        return {p, true};
    }

    std::tuple<uint32_t, uint32_t> readvarint(gocpp::slice<unsigned char> p)
    {
        uint32_t read;
        uint32_t val;
        uint32_t v = {};
        uint32_t shift = {};
        uint32_t n = {};
        for(; ; )
        {
            uint32_t read;
            uint32_t val;
            auto b = p[n];
            n++;
            v |= uint32_t(b & 0x7F) << (shift & 31);
            if(b & 0x80 == 0)
            {
                uint32_t read;
                uint32_t val;
                break;
            }
            shift += 7;
        }
        return {n, v};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    stackmap::operator T()
    {
        T result;
        result.n = this->n;
        result.nbit = this->nbit;
        result.bytedata = this->bytedata;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stackmap::operator==(const T& ref) const
    {
        if (n != ref.n) return false;
        if (nbit != ref.nbit) return false;
        if (bytedata != ref.bytedata) return false;
        return true;
    }

    std::ostream& stackmap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << n;
        os << " " << nbit;
        os << " " << bytedata;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stackmap& value)
    {
        return value.PrintTo(os);
    }

    struct bitvector stackmapdata(struct stackmap* stkmap, int32_t n)
    {
        if(stackDebug > 0 && (n < 0 || n >= stkmap->n))
        {
            go_throw("stackmapdata: index out of range");
        }
        return bitvector {stkmap->nbit, addb(& stkmap->bytedata[0], uintptr_t(n * ((stkmap->nbit + 7) >> 3)))};
    }

}

