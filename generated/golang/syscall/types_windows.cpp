// generated by GoCpp from file '$(ImportDir)/syscall/types_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/types_windows.h"
#include "gocpp/support.h"

#include "golang/syscall/syscall_windows.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Windows errors.
    // Invented values to support what package os expects.
    // More invented values for signals
    gocpp::array<gocpp::string, 16> signals = gocpp::Init<gocpp::array<gocpp::string, 16>>([](auto& x) {
        x[1] = "hangup"_s;
        x[2] = "interrupt"_s;
        x[3] = "quit"_s;
        x[4] = "illegal instruction"_s;
        x[5] = "trace/breakpoint trap"_s;
        x[6] = "aborted"_s;
        x[7] = "bus error"_s;
        x[8] = "floating point exception"_s;
        x[9] = "killed"_s;
        x[10] = "user defined signal 1"_s;
        x[11] = "segmentation fault"_s;
        x[12] = "user defined signal 2"_s;
        x[13] = "broken pipe"_s;
        x[14] = "alarm clock"_s;
        x[15] = "terminated"_s;
    });
    // flags for CreateToolhelp32Snapshot
    // do not reorder
    // do not reorder
    // wincrypt.h
    gocpp::slice<unsigned char> OID_PKIX_KP_SERVER_AUTH = gocpp::slice<unsigned char>("1.3.6.1.5.5.7.3.1\x00"_s);
    gocpp::slice<unsigned char> OID_SERVER_GATED_CRYPTO = gocpp::slice<unsigned char>("1.3.6.1.4.1.311.10.3.3\x00"_s);
    gocpp::slice<unsigned char> OID_SGC_NETSCAPE = gocpp::slice<unsigned char>("2.16.840.1.113730.4.1\x00"_s);
    struct gocpp_id_0
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // Pointer represents a pointer to an arbitrary Windows type.
    //
    // Pointer-typed fields may point to one of many different types. It's
    // up to the caller to provide a pointer to the appropriate type, cast
    // to Pointer. The caller must obey the unsafe.Pointer rules while
    // doing so.
    // Invented values to support what package os expects.
    
    template<typename T> requires gocpp::GoStruct<T>
    Timeval::operator T()
    {
        T result;
        result.Sec = this->Sec;
        result.Usec = this->Usec;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Timeval::operator==(const T& ref) const
    {
        if (Sec != ref.Sec) return false;
        if (Usec != ref.Usec) return false;
        return true;
    }

    std::ostream& Timeval::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Sec;
        os << " " << Usec;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Timeval& value)
    {
        return value.PrintTo(os);
    }

    int64_t rec::Nanoseconds(struct Timeval* tv)
    {
        return (int64_t(tv->Sec) * 1e6 + int64_t(tv->Usec)) * 1e3;
    }

    struct Timeval NsecToTimeval(int64_t nsec)
    {
        struct Timeval tv;
        tv->Sec = int32_t(nsec / 1e9);
        tv->Usec = int32_t(nsec % 1e9 / 1e3);
        return tv;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SecurityAttributes::operator T()
    {
        T result;
        result.Length = this->Length;
        result.SecurityDescriptor = this->SecurityDescriptor;
        result.InheritHandle = this->InheritHandle;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SecurityAttributes::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (SecurityDescriptor != ref.SecurityDescriptor) return false;
        if (InheritHandle != ref.InheritHandle) return false;
        return true;
    }

    std::ostream& SecurityAttributes::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << SecurityDescriptor;
        os << " " << InheritHandle;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SecurityAttributes& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Overlapped::operator T()
    {
        T result;
        result.Internal = this->Internal;
        result.InternalHigh = this->InternalHigh;
        result.Offset = this->Offset;
        result.OffsetHigh = this->OffsetHigh;
        result.HEvent = this->HEvent;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Overlapped::operator==(const T& ref) const
    {
        if (Internal != ref.Internal) return false;
        if (InternalHigh != ref.InternalHigh) return false;
        if (Offset != ref.Offset) return false;
        if (OffsetHigh != ref.OffsetHigh) return false;
        if (HEvent != ref.HEvent) return false;
        return true;
    }

    std::ostream& Overlapped::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Internal;
        os << " " << InternalHigh;
        os << " " << Offset;
        os << " " << OffsetHigh;
        os << " " << HEvent;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Overlapped& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    FileNotifyInformation::operator T()
    {
        T result;
        result.NextEntryOffset = this->NextEntryOffset;
        result.Action = this->Action;
        result.FileNameLength = this->FileNameLength;
        result.FileName = this->FileName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool FileNotifyInformation::operator==(const T& ref) const
    {
        if (NextEntryOffset != ref.NextEntryOffset) return false;
        if (Action != ref.Action) return false;
        if (FileNameLength != ref.FileNameLength) return false;
        if (FileName != ref.FileName) return false;
        return true;
    }

    std::ostream& FileNotifyInformation::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << NextEntryOffset;
        os << " " << Action;
        os << " " << FileNameLength;
        os << " " << FileName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct FileNotifyInformation& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Filetime::operator T()
    {
        T result;
        result.LowDateTime = this->LowDateTime;
        result.HighDateTime = this->HighDateTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Filetime::operator==(const T& ref) const
    {
        if (LowDateTime != ref.LowDateTime) return false;
        if (HighDateTime != ref.HighDateTime) return false;
        return true;
    }

    std::ostream& Filetime::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << LowDateTime;
        os << " " << HighDateTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Filetime& value)
    {
        return value.PrintTo(os);
    }

    // Nanoseconds returns Filetime ft in nanoseconds
    // since Epoch (00:00:00 UTC, January 1, 1970).
    int64_t rec::Nanoseconds(struct Filetime* ft)
    {
        auto nsec = (int64_t(ft->HighDateTime) << 32) + int64_t(ft->LowDateTime);
        nsec -= 116444736000000000;
        nsec *= 100;
        return nsec;
    }

    struct Filetime NsecToFiletime(int64_t nsec)
    {
        struct Filetime ft;
        nsec /= 100;
        nsec += 116444736000000000;
        ft->LowDateTime = uint32_t(nsec & 0xffffffff);
        ft->HighDateTime = uint32_t((nsec >> 32) & 0xffffffff);
        return ft;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Win32finddata::operator T()
    {
        T result;
        result.FileAttributes = this->FileAttributes;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.FileSizeHigh = this->FileSizeHigh;
        result.FileSizeLow = this->FileSizeLow;
        result.Reserved0 = this->Reserved0;
        result.Reserved1 = this->Reserved1;
        result.FileName = this->FileName;
        result.AlternateFileName = this->AlternateFileName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Win32finddata::operator==(const T& ref) const
    {
        if (FileAttributes != ref.FileAttributes) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (FileSizeHigh != ref.FileSizeHigh) return false;
        if (FileSizeLow != ref.FileSizeLow) return false;
        if (Reserved0 != ref.Reserved0) return false;
        if (Reserved1 != ref.Reserved1) return false;
        if (FileName != ref.FileName) return false;
        if (AlternateFileName != ref.AlternateFileName) return false;
        return true;
    }

    std::ostream& Win32finddata::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << FileAttributes;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << FileSizeHigh;
        os << " " << FileSizeLow;
        os << " " << Reserved0;
        os << " " << Reserved1;
        os << " " << FileName;
        os << " " << AlternateFileName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Win32finddata& value)
    {
        return value.PrintTo(os);
    }

    // This is the actual system call structure.
    // Win32finddata is what we committed to in Go 1.
    
    template<typename T> requires gocpp::GoStruct<T>
    win32finddata1::operator T()
    {
        T result;
        result.FileAttributes = this->FileAttributes;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.FileSizeHigh = this->FileSizeHigh;
        result.FileSizeLow = this->FileSizeLow;
        result.Reserved0 = this->Reserved0;
        result.Reserved1 = this->Reserved1;
        result.FileName = this->FileName;
        result.AlternateFileName = this->AlternateFileName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool win32finddata1::operator==(const T& ref) const
    {
        if (FileAttributes != ref.FileAttributes) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (FileSizeHigh != ref.FileSizeHigh) return false;
        if (FileSizeLow != ref.FileSizeLow) return false;
        if (Reserved0 != ref.Reserved0) return false;
        if (Reserved1 != ref.Reserved1) return false;
        if (FileName != ref.FileName) return false;
        if (AlternateFileName != ref.AlternateFileName) return false;
        return true;
    }

    std::ostream& win32finddata1::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << FileAttributes;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << FileSizeHigh;
        os << " " << FileSizeLow;
        os << " " << Reserved0;
        os << " " << Reserved1;
        os << " " << FileName;
        os << " " << AlternateFileName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct win32finddata1& value)
    {
        return value.PrintTo(os);
    }

    void copyFindData(struct Win32finddata* dst, struct win32finddata1* src)
    {
        dst->FileAttributes = src->FileAttributes;
        dst->CreationTime = src->CreationTime;
        dst->LastAccessTime = src->LastAccessTime;
        dst->LastWriteTime = src->LastWriteTime;
        dst->FileSizeHigh = src->FileSizeHigh;
        dst->FileSizeLow = src->FileSizeLow;
        dst->Reserved0 = src->Reserved0;
        dst->Reserved1 = src->Reserved1;
        copy(dst->FileName.make_slice(0), src->FileName.make_slice(0));
        copy(dst->AlternateFileName.make_slice(0), src->AlternateFileName.make_slice(0));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ByHandleFileInformation::operator T()
    {
        T result;
        result.FileAttributes = this->FileAttributes;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.VolumeSerialNumber = this->VolumeSerialNumber;
        result.FileSizeHigh = this->FileSizeHigh;
        result.FileSizeLow = this->FileSizeLow;
        result.NumberOfLinks = this->NumberOfLinks;
        result.FileIndexHigh = this->FileIndexHigh;
        result.FileIndexLow = this->FileIndexLow;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ByHandleFileInformation::operator==(const T& ref) const
    {
        if (FileAttributes != ref.FileAttributes) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (VolumeSerialNumber != ref.VolumeSerialNumber) return false;
        if (FileSizeHigh != ref.FileSizeHigh) return false;
        if (FileSizeLow != ref.FileSizeLow) return false;
        if (NumberOfLinks != ref.NumberOfLinks) return false;
        if (FileIndexHigh != ref.FileIndexHigh) return false;
        if (FileIndexLow != ref.FileIndexLow) return false;
        return true;
    }

    std::ostream& ByHandleFileInformation::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << FileAttributes;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << VolumeSerialNumber;
        os << " " << FileSizeHigh;
        os << " " << FileSizeLow;
        os << " " << NumberOfLinks;
        os << " " << FileIndexHigh;
        os << " " << FileIndexLow;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ByHandleFileInformation& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Win32FileAttributeData::operator T()
    {
        T result;
        result.FileAttributes = this->FileAttributes;
        result.CreationTime = this->CreationTime;
        result.LastAccessTime = this->LastAccessTime;
        result.LastWriteTime = this->LastWriteTime;
        result.FileSizeHigh = this->FileSizeHigh;
        result.FileSizeLow = this->FileSizeLow;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Win32FileAttributeData::operator==(const T& ref) const
    {
        if (FileAttributes != ref.FileAttributes) return false;
        if (CreationTime != ref.CreationTime) return false;
        if (LastAccessTime != ref.LastAccessTime) return false;
        if (LastWriteTime != ref.LastWriteTime) return false;
        if (FileSizeHigh != ref.FileSizeHigh) return false;
        if (FileSizeLow != ref.FileSizeLow) return false;
        return true;
    }

    std::ostream& Win32FileAttributeData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << FileAttributes;
        os << " " << CreationTime;
        os << " " << LastAccessTime;
        os << " " << LastWriteTime;
        os << " " << FileSizeHigh;
        os << " " << FileSizeLow;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Win32FileAttributeData& value)
    {
        return value.PrintTo(os);
    }

    // ShowWindow constants
    // winuser.h
    
    template<typename T> requires gocpp::GoStruct<T>
    StartupInfo::operator T()
    {
        T result;
        result.Cb = this->Cb;
        result._1 = this->_1;
        result.Desktop = this->Desktop;
        result.Title = this->Title;
        result.X = this->X;
        result.Y = this->Y;
        result.XSize = this->XSize;
        result.YSize = this->YSize;
        result.XCountChars = this->XCountChars;
        result.YCountChars = this->YCountChars;
        result.FillAttribute = this->FillAttribute;
        result.Flags = this->Flags;
        result.ShowWindow = this->ShowWindow;
        result._2 = this->_2;
        result._3 = this->_3;
        result.StdInput = this->StdInput;
        result.StdOutput = this->StdOutput;
        result.StdErr = this->StdErr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StartupInfo::operator==(const T& ref) const
    {
        if (Cb != ref.Cb) return false;
        if (_1 != ref._1) return false;
        if (Desktop != ref.Desktop) return false;
        if (Title != ref.Title) return false;
        if (X != ref.X) return false;
        if (Y != ref.Y) return false;
        if (XSize != ref.XSize) return false;
        if (YSize != ref.YSize) return false;
        if (XCountChars != ref.XCountChars) return false;
        if (YCountChars != ref.YCountChars) return false;
        if (FillAttribute != ref.FillAttribute) return false;
        if (Flags != ref.Flags) return false;
        if (ShowWindow != ref.ShowWindow) return false;
        if (_2 != ref._2) return false;
        if (_3 != ref._3) return false;
        if (StdInput != ref.StdInput) return false;
        if (StdOutput != ref.StdOutput) return false;
        if (StdErr != ref.StdErr) return false;
        return true;
    }

    std::ostream& StartupInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Cb;
        os << " " << _1;
        os << " " << Desktop;
        os << " " << Title;
        os << " " << X;
        os << " " << Y;
        os << " " << XSize;
        os << " " << YSize;
        os << " " << XCountChars;
        os << " " << YCountChars;
        os << " " << FillAttribute;
        os << " " << Flags;
        os << " " << ShowWindow;
        os << " " << _2;
        os << " " << _3;
        os << " " << StdInput;
        os << " " << StdOutput;
        os << " " << StdErr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StartupInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    _PROC_THREAD_ATTRIBUTE_LIST::operator T()
    {
        T result;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool _PROC_THREAD_ATTRIBUTE_LIST::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& _PROC_THREAD_ATTRIBUTE_LIST::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _PROC_THREAD_ATTRIBUTE_LIST& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    _STARTUPINFOEXW::operator T()
    {
        T result;
        result.StartupInfo = this->StartupInfo;
        result.ProcThreadAttributeList = this->ProcThreadAttributeList;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool _STARTUPINFOEXW::operator==(const T& ref) const
    {
        if (StartupInfo != ref.StartupInfo) return false;
        if (ProcThreadAttributeList != ref.ProcThreadAttributeList) return false;
        return true;
    }

    std::ostream& _STARTUPINFOEXW::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << StartupInfo;
        os << " " << ProcThreadAttributeList;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct _STARTUPINFOEXW& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ProcessInformation::operator T()
    {
        T result;
        result.Process = this->Process;
        result.Thread = this->Thread;
        result.ProcessId = this->ProcessId;
        result.ThreadId = this->ThreadId;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ProcessInformation::operator==(const T& ref) const
    {
        if (Process != ref.Process) return false;
        if (Thread != ref.Thread) return false;
        if (ProcessId != ref.ProcessId) return false;
        if (ThreadId != ref.ThreadId) return false;
        return true;
    }

    std::ostream& ProcessInformation::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Process;
        os << " " << Thread;
        os << " " << ProcessId;
        os << " " << ThreadId;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ProcessInformation& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ProcessEntry32::operator T()
    {
        T result;
        result.Size = this->Size;
        result.Usage = this->Usage;
        result.ProcessID = this->ProcessID;
        result.DefaultHeapID = this->DefaultHeapID;
        result.ModuleID = this->ModuleID;
        result.Threads = this->Threads;
        result.ParentProcessID = this->ParentProcessID;
        result.PriClassBase = this->PriClassBase;
        result.Flags = this->Flags;
        result.ExeFile = this->ExeFile;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ProcessEntry32::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (Usage != ref.Usage) return false;
        if (ProcessID != ref.ProcessID) return false;
        if (DefaultHeapID != ref.DefaultHeapID) return false;
        if (ModuleID != ref.ModuleID) return false;
        if (Threads != ref.Threads) return false;
        if (ParentProcessID != ref.ParentProcessID) return false;
        if (PriClassBase != ref.PriClassBase) return false;
        if (Flags != ref.Flags) return false;
        if (ExeFile != ref.ExeFile) return false;
        return true;
    }

    std::ostream& ProcessEntry32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << Usage;
        os << " " << ProcessID;
        os << " " << DefaultHeapID;
        os << " " << ModuleID;
        os << " " << Threads;
        os << " " << ParentProcessID;
        os << " " << PriClassBase;
        os << " " << Flags;
        os << " " << ExeFile;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ProcessEntry32& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Systemtime::operator T()
    {
        T result;
        result.Year = this->Year;
        result.Month = this->Month;
        result.DayOfWeek = this->DayOfWeek;
        result.Day = this->Day;
        result.Hour = this->Hour;
        result.Minute = this->Minute;
        result.Second = this->Second;
        result.Milliseconds = this->Milliseconds;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Systemtime::operator==(const T& ref) const
    {
        if (Year != ref.Year) return false;
        if (Month != ref.Month) return false;
        if (DayOfWeek != ref.DayOfWeek) return false;
        if (Day != ref.Day) return false;
        if (Hour != ref.Hour) return false;
        if (Minute != ref.Minute) return false;
        if (Second != ref.Second) return false;
        if (Milliseconds != ref.Milliseconds) return false;
        return true;
    }

    std::ostream& Systemtime::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Year;
        os << " " << Month;
        os << " " << DayOfWeek;
        os << " " << Day;
        os << " " << Hour;
        os << " " << Minute;
        os << " " << Second;
        os << " " << Milliseconds;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Systemtime& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Timezoneinformation::operator T()
    {
        T result;
        result.Bias = this->Bias;
        result.StandardName = this->StandardName;
        result.StandardDate = this->StandardDate;
        result.StandardBias = this->StandardBias;
        result.DaylightName = this->DaylightName;
        result.DaylightDate = this->DaylightDate;
        result.DaylightBias = this->DaylightBias;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Timezoneinformation::operator==(const T& ref) const
    {
        if (Bias != ref.Bias) return false;
        if (StandardName != ref.StandardName) return false;
        if (StandardDate != ref.StandardDate) return false;
        if (StandardBias != ref.StandardBias) return false;
        if (DaylightName != ref.DaylightName) return false;
        if (DaylightDate != ref.DaylightDate) return false;
        if (DaylightBias != ref.DaylightBias) return false;
        return true;
    }

    std::ostream& Timezoneinformation::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Bias;
        os << " " << StandardName;
        os << " " << StandardDate;
        os << " " << StandardBias;
        os << " " << DaylightName;
        os << " " << DaylightDate;
        os << " " << DaylightBias;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Timezoneinformation& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    WSABuf::operator T()
    {
        T result;
        result.Len = this->Len;
        result.Buf = this->Buf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WSABuf::operator==(const T& ref) const
    {
        if (Len != ref.Len) return false;
        if (Buf != ref.Buf) return false;
        return true;
    }

    std::ostream& WSABuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Len;
        os << " " << Buf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WSABuf& value)
    {
        return value.PrintTo(os);
    }

    // Invented values to support what package os expects.
    
    template<typename T> requires gocpp::GoStruct<T>
    Hostent::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Aliases = this->Aliases;
        result.AddrType = this->AddrType;
        result.Length = this->Length;
        result.AddrList = this->AddrList;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Hostent::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Aliases != ref.Aliases) return false;
        if (AddrType != ref.AddrType) return false;
        if (Length != ref.Length) return false;
        if (AddrList != ref.AddrList) return false;
        return true;
    }

    std::ostream& Hostent::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Aliases;
        os << " " << AddrType;
        os << " " << Length;
        os << " " << AddrList;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Hostent& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Protoent::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Aliases = this->Aliases;
        result.Proto = this->Proto;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Protoent::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Aliases != ref.Aliases) return false;
        if (Proto != ref.Proto) return false;
        return true;
    }

    std::ostream& Protoent::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Aliases;
        os << " " << Proto;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Protoent& value)
    {
        return value.PrintTo(os);
    }

    // flags inside DNSRecord.Dw
    
    template<typename T> requires gocpp::GoStruct<T>
    DNSSRVData::operator T()
    {
        T result;
        result.Target = this->Target;
        result.Priority = this->Priority;
        result.Weight = this->Weight;
        result.Port = this->Port;
        result.Pad = this->Pad;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DNSSRVData::operator==(const T& ref) const
    {
        if (Target != ref.Target) return false;
        if (Priority != ref.Priority) return false;
        if (Weight != ref.Weight) return false;
        if (Port != ref.Port) return false;
        if (Pad != ref.Pad) return false;
        return true;
    }

    std::ostream& DNSSRVData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Target;
        os << " " << Priority;
        os << " " << Weight;
        os << " " << Port;
        os << " " << Pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DNSSRVData& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    DNSPTRData::operator T()
    {
        T result;
        result.Host = this->Host;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DNSPTRData::operator==(const T& ref) const
    {
        if (Host != ref.Host) return false;
        return true;
    }

    std::ostream& DNSPTRData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Host;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DNSPTRData& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    DNSMXData::operator T()
    {
        T result;
        result.NameExchange = this->NameExchange;
        result.Preference = this->Preference;
        result.Pad = this->Pad;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DNSMXData::operator==(const T& ref) const
    {
        if (NameExchange != ref.NameExchange) return false;
        if (Preference != ref.Preference) return false;
        if (Pad != ref.Pad) return false;
        return true;
    }

    std::ostream& DNSMXData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << NameExchange;
        os << " " << Preference;
        os << " " << Pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DNSMXData& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    DNSTXTData::operator T()
    {
        T result;
        result.StringCount = this->StringCount;
        result.StringArray = this->StringArray;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DNSTXTData::operator==(const T& ref) const
    {
        if (StringCount != ref.StringCount) return false;
        if (StringArray != ref.StringArray) return false;
        return true;
    }

    std::ostream& DNSTXTData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << StringCount;
        os << " " << StringArray;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DNSTXTData& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    DNSRecord::operator T()
    {
        T result;
        result.Next = this->Next;
        result.Name = this->Name;
        result.Type = this->Type;
        result.Length = this->Length;
        result.Dw = this->Dw;
        result.Ttl = this->Ttl;
        result.Reserved = this->Reserved;
        result.Data = this->Data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool DNSRecord::operator==(const T& ref) const
    {
        if (Next != ref.Next) return false;
        if (Name != ref.Name) return false;
        if (Type != ref.Type) return false;
        if (Length != ref.Length) return false;
        if (Dw != ref.Dw) return false;
        if (Ttl != ref.Ttl) return false;
        if (Reserved != ref.Reserved) return false;
        if (Data != ref.Data) return false;
        return true;
    }

    std::ostream& DNSRecord::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Next;
        os << " " << Name;
        os << " " << Type;
        os << " " << Length;
        os << " " << Dw;
        os << " " << Ttl;
        os << " " << Reserved;
        os << " " << Data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DNSRecord& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    TransmitFileBuffers::operator T()
    {
        T result;
        result.Head = this->Head;
        result.HeadLength = this->HeadLength;
        result.Tail = this->Tail;
        result.TailLength = this->TailLength;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool TransmitFileBuffers::operator==(const T& ref) const
    {
        if (Head != ref.Head) return false;
        if (HeadLength != ref.HeadLength) return false;
        if (Tail != ref.Tail) return false;
        if (TailLength != ref.TailLength) return false;
        return true;
    }

    std::ostream& TransmitFileBuffers::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Head;
        os << " " << HeadLength;
        os << " " << Tail;
        os << " " << TailLength;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct TransmitFileBuffers& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    InterfaceInfo::operator T()
    {
        T result;
        result.Flags = this->Flags;
        result.Address = this->Address;
        result.BroadcastAddress = this->BroadcastAddress;
        result.Netmask = this->Netmask;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool InterfaceInfo::operator==(const T& ref) const
    {
        if (Flags != ref.Flags) return false;
        if (Address != ref.Address) return false;
        if (BroadcastAddress != ref.BroadcastAddress) return false;
        if (Netmask != ref.Netmask) return false;
        return true;
    }

    std::ostream& InterfaceInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Flags;
        os << " " << Address;
        os << " " << BroadcastAddress;
        os << " " << Netmask;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct InterfaceInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAddressString::operator T()
    {
        T result;
        result.String = this->String;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAddressString::operator==(const T& ref) const
    {
        if (String != ref.String) return false;
        return true;
    }

    std::ostream& IpAddressString::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << String;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAddressString& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAddrString::operator T()
    {
        T result;
        result.Next = this->Next;
        result.IpAddress = this->IpAddress;
        result.IpMask = this->IpMask;
        result.Context = this->Context;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAddrString::operator==(const T& ref) const
    {
        if (Next != ref.Next) return false;
        if (IpAddress != ref.IpAddress) return false;
        if (IpMask != ref.IpMask) return false;
        if (Context != ref.Context) return false;
        return true;
    }

    std::ostream& IpAddrString::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Next;
        os << " " << IpAddress;
        os << " " << IpMask;
        os << " " << Context;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAddrString& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IpAdapterInfo::operator T()
    {
        T result;
        result.Next = this->Next;
        result.ComboIndex = this->ComboIndex;
        result.AdapterName = this->AdapterName;
        result.Description = this->Description;
        result.AddressLength = this->AddressLength;
        result.Address = this->Address;
        result.Index = this->Index;
        result.Type = this->Type;
        result.DhcpEnabled = this->DhcpEnabled;
        result.CurrentIpAddress = this->CurrentIpAddress;
        result.IpAddressList = this->IpAddressList;
        result.GatewayList = this->GatewayList;
        result.DhcpServer = this->DhcpServer;
        result.HaveWins = this->HaveWins;
        result.PrimaryWinsServer = this->PrimaryWinsServer;
        result.SecondaryWinsServer = this->SecondaryWinsServer;
        result.LeaseObtained = this->LeaseObtained;
        result.LeaseExpires = this->LeaseExpires;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IpAdapterInfo::operator==(const T& ref) const
    {
        if (Next != ref.Next) return false;
        if (ComboIndex != ref.ComboIndex) return false;
        if (AdapterName != ref.AdapterName) return false;
        if (Description != ref.Description) return false;
        if (AddressLength != ref.AddressLength) return false;
        if (Address != ref.Address) return false;
        if (Index != ref.Index) return false;
        if (Type != ref.Type) return false;
        if (DhcpEnabled != ref.DhcpEnabled) return false;
        if (CurrentIpAddress != ref.CurrentIpAddress) return false;
        if (IpAddressList != ref.IpAddressList) return false;
        if (GatewayList != ref.GatewayList) return false;
        if (DhcpServer != ref.DhcpServer) return false;
        if (HaveWins != ref.HaveWins) return false;
        if (PrimaryWinsServer != ref.PrimaryWinsServer) return false;
        if (SecondaryWinsServer != ref.SecondaryWinsServer) return false;
        if (LeaseObtained != ref.LeaseObtained) return false;
        if (LeaseExpires != ref.LeaseExpires) return false;
        return true;
    }

    std::ostream& IpAdapterInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Next;
        os << " " << ComboIndex;
        os << " " << AdapterName;
        os << " " << Description;
        os << " " << AddressLength;
        os << " " << Address;
        os << " " << Index;
        os << " " << Type;
        os << " " << DhcpEnabled;
        os << " " << CurrentIpAddress;
        os << " " << IpAddressList;
        os << " " << GatewayList;
        os << " " << DhcpServer;
        os << " " << HaveWins;
        os << " " << PrimaryWinsServer;
        os << " " << SecondaryWinsServer;
        os << " " << LeaseObtained;
        os << " " << LeaseExpires;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IpAdapterInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    MibIfRow::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Index = this->Index;
        result.Type = this->Type;
        result.Mtu = this->Mtu;
        result.Speed = this->Speed;
        result.PhysAddrLen = this->PhysAddrLen;
        result.PhysAddr = this->PhysAddr;
        result.AdminStatus = this->AdminStatus;
        result.OperStatus = this->OperStatus;
        result.LastChange = this->LastChange;
        result.InOctets = this->InOctets;
        result.InUcastPkts = this->InUcastPkts;
        result.InNUcastPkts = this->InNUcastPkts;
        result.InDiscards = this->InDiscards;
        result.InErrors = this->InErrors;
        result.InUnknownProtos = this->InUnknownProtos;
        result.OutOctets = this->OutOctets;
        result.OutUcastPkts = this->OutUcastPkts;
        result.OutNUcastPkts = this->OutNUcastPkts;
        result.OutDiscards = this->OutDiscards;
        result.OutErrors = this->OutErrors;
        result.OutQLen = this->OutQLen;
        result.DescrLen = this->DescrLen;
        result.Descr = this->Descr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool MibIfRow::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Index != ref.Index) return false;
        if (Type != ref.Type) return false;
        if (Mtu != ref.Mtu) return false;
        if (Speed != ref.Speed) return false;
        if (PhysAddrLen != ref.PhysAddrLen) return false;
        if (PhysAddr != ref.PhysAddr) return false;
        if (AdminStatus != ref.AdminStatus) return false;
        if (OperStatus != ref.OperStatus) return false;
        if (LastChange != ref.LastChange) return false;
        if (InOctets != ref.InOctets) return false;
        if (InUcastPkts != ref.InUcastPkts) return false;
        if (InNUcastPkts != ref.InNUcastPkts) return false;
        if (InDiscards != ref.InDiscards) return false;
        if (InErrors != ref.InErrors) return false;
        if (InUnknownProtos != ref.InUnknownProtos) return false;
        if (OutOctets != ref.OutOctets) return false;
        if (OutUcastPkts != ref.OutUcastPkts) return false;
        if (OutNUcastPkts != ref.OutNUcastPkts) return false;
        if (OutDiscards != ref.OutDiscards) return false;
        if (OutErrors != ref.OutErrors) return false;
        if (OutQLen != ref.OutQLen) return false;
        if (DescrLen != ref.DescrLen) return false;
        if (Descr != ref.Descr) return false;
        return true;
    }

    std::ostream& MibIfRow::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Index;
        os << " " << Type;
        os << " " << Mtu;
        os << " " << Speed;
        os << " " << PhysAddrLen;
        os << " " << PhysAddr;
        os << " " << AdminStatus;
        os << " " << OperStatus;
        os << " " << LastChange;
        os << " " << InOctets;
        os << " " << InUcastPkts;
        os << " " << InNUcastPkts;
        os << " " << InDiscards;
        os << " " << InErrors;
        os << " " << InUnknownProtos;
        os << " " << OutOctets;
        os << " " << OutUcastPkts;
        os << " " << OutNUcastPkts;
        os << " " << OutDiscards;
        os << " " << OutErrors;
        os << " " << OutQLen;
        os << " " << DescrLen;
        os << " " << Descr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MibIfRow& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertInfo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertInfo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& CertInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertContext::operator T()
    {
        T result;
        result.EncodingType = this->EncodingType;
        result.EncodedCert = this->EncodedCert;
        result.Length = this->Length;
        result.CertInfo = this->CertInfo;
        result.Store = this->Store;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertContext::operator==(const T& ref) const
    {
        if (EncodingType != ref.EncodingType) return false;
        if (EncodedCert != ref.EncodedCert) return false;
        if (Length != ref.Length) return false;
        if (CertInfo != ref.CertInfo) return false;
        if (Store != ref.Store) return false;
        return true;
    }

    std::ostream& CertContext::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << EncodingType;
        os << " " << EncodedCert;
        os << " " << Length;
        os << " " << CertInfo;
        os << " " << Store;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertContext& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertChainContext::operator T()
    {
        T result;
        result.Size = this->Size;
        result.TrustStatus = this->TrustStatus;
        result.ChainCount = this->ChainCount;
        result.Chains = this->Chains;
        result.LowerQualityChainCount = this->LowerQualityChainCount;
        result.LowerQualityChains = this->LowerQualityChains;
        result.HasRevocationFreshnessTime = this->HasRevocationFreshnessTime;
        result.RevocationFreshnessTime = this->RevocationFreshnessTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertChainContext::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (TrustStatus != ref.TrustStatus) return false;
        if (ChainCount != ref.ChainCount) return false;
        if (Chains != ref.Chains) return false;
        if (LowerQualityChainCount != ref.LowerQualityChainCount) return false;
        if (LowerQualityChains != ref.LowerQualityChains) return false;
        if (HasRevocationFreshnessTime != ref.HasRevocationFreshnessTime) return false;
        if (RevocationFreshnessTime != ref.RevocationFreshnessTime) return false;
        return true;
    }

    std::ostream& CertChainContext::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << TrustStatus;
        os << " " << ChainCount;
        os << " " << Chains;
        os << " " << LowerQualityChainCount;
        os << " " << LowerQualityChains;
        os << " " << HasRevocationFreshnessTime;
        os << " " << RevocationFreshnessTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertChainContext& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertTrustListInfo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertTrustListInfo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& CertTrustListInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertTrustListInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertSimpleChain::operator T()
    {
        T result;
        result.Size = this->Size;
        result.TrustStatus = this->TrustStatus;
        result.NumElements = this->NumElements;
        result.Elements = this->Elements;
        result.TrustListInfo = this->TrustListInfo;
        result.HasRevocationFreshnessTime = this->HasRevocationFreshnessTime;
        result.RevocationFreshnessTime = this->RevocationFreshnessTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertSimpleChain::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (TrustStatus != ref.TrustStatus) return false;
        if (NumElements != ref.NumElements) return false;
        if (Elements != ref.Elements) return false;
        if (TrustListInfo != ref.TrustListInfo) return false;
        if (HasRevocationFreshnessTime != ref.HasRevocationFreshnessTime) return false;
        if (RevocationFreshnessTime != ref.RevocationFreshnessTime) return false;
        return true;
    }

    std::ostream& CertSimpleChain::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << TrustStatus;
        os << " " << NumElements;
        os << " " << Elements;
        os << " " << TrustListInfo;
        os << " " << HasRevocationFreshnessTime;
        os << " " << RevocationFreshnessTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertSimpleChain& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertChainElement::operator T()
    {
        T result;
        result.Size = this->Size;
        result.CertContext = this->CertContext;
        result.TrustStatus = this->TrustStatus;
        result.RevocationInfo = this->RevocationInfo;
        result.IssuanceUsage = this->IssuanceUsage;
        result.ApplicationUsage = this->ApplicationUsage;
        result.ExtendedErrorInfo = this->ExtendedErrorInfo;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertChainElement::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (CertContext != ref.CertContext) return false;
        if (TrustStatus != ref.TrustStatus) return false;
        if (RevocationInfo != ref.RevocationInfo) return false;
        if (IssuanceUsage != ref.IssuanceUsage) return false;
        if (ApplicationUsage != ref.ApplicationUsage) return false;
        if (ExtendedErrorInfo != ref.ExtendedErrorInfo) return false;
        return true;
    }

    std::ostream& CertChainElement::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << CertContext;
        os << " " << TrustStatus;
        os << " " << RevocationInfo;
        os << " " << IssuanceUsage;
        os << " " << ApplicationUsage;
        os << " " << ExtendedErrorInfo;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertChainElement& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertRevocationCrlInfo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertRevocationCrlInfo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& CertRevocationCrlInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertRevocationCrlInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertRevocationInfo::operator T()
    {
        T result;
        result.Size = this->Size;
        result.RevocationResult = this->RevocationResult;
        result.RevocationOid = this->RevocationOid;
        result.OidSpecificInfo = this->OidSpecificInfo;
        result.HasFreshnessTime = this->HasFreshnessTime;
        result.FreshnessTime = this->FreshnessTime;
        result.CrlInfo = this->CrlInfo;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertRevocationInfo::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (RevocationResult != ref.RevocationResult) return false;
        if (RevocationOid != ref.RevocationOid) return false;
        if (OidSpecificInfo != ref.OidSpecificInfo) return false;
        if (HasFreshnessTime != ref.HasFreshnessTime) return false;
        if (FreshnessTime != ref.FreshnessTime) return false;
        if (CrlInfo != ref.CrlInfo) return false;
        return true;
    }

    std::ostream& CertRevocationInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << RevocationResult;
        os << " " << RevocationOid;
        os << " " << OidSpecificInfo;
        os << " " << HasFreshnessTime;
        os << " " << FreshnessTime;
        os << " " << CrlInfo;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertRevocationInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertTrustStatus::operator T()
    {
        T result;
        result.ErrorStatus = this->ErrorStatus;
        result.InfoStatus = this->InfoStatus;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertTrustStatus::operator==(const T& ref) const
    {
        if (ErrorStatus != ref.ErrorStatus) return false;
        if (InfoStatus != ref.InfoStatus) return false;
        return true;
    }

    std::ostream& CertTrustStatus::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ErrorStatus;
        os << " " << InfoStatus;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertTrustStatus& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertUsageMatch::operator T()
    {
        T result;
        result.Type = this->Type;
        result.Usage = this->Usage;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertUsageMatch::operator==(const T& ref) const
    {
        if (Type != ref.Type) return false;
        if (Usage != ref.Usage) return false;
        return true;
    }

    std::ostream& CertUsageMatch::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Type;
        os << " " << Usage;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertUsageMatch& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertEnhKeyUsage::operator T()
    {
        T result;
        result.Length = this->Length;
        result.UsageIdentifiers = this->UsageIdentifiers;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertEnhKeyUsage::operator==(const T& ref) const
    {
        if (Length != ref.Length) return false;
        if (UsageIdentifiers != ref.UsageIdentifiers) return false;
        return true;
    }

    std::ostream& CertEnhKeyUsage::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Length;
        os << " " << UsageIdentifiers;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertEnhKeyUsage& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertChainPara::operator T()
    {
        T result;
        result.Size = this->Size;
        result.RequestedUsage = this->RequestedUsage;
        result.RequstedIssuancePolicy = this->RequstedIssuancePolicy;
        result.URLRetrievalTimeout = this->URLRetrievalTimeout;
        result.CheckRevocationFreshnessTime = this->CheckRevocationFreshnessTime;
        result.RevocationFreshnessTime = this->RevocationFreshnessTime;
        result.CacheResync = this->CacheResync;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertChainPara::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (RequestedUsage != ref.RequestedUsage) return false;
        if (RequstedIssuancePolicy != ref.RequstedIssuancePolicy) return false;
        if (URLRetrievalTimeout != ref.URLRetrievalTimeout) return false;
        if (CheckRevocationFreshnessTime != ref.CheckRevocationFreshnessTime) return false;
        if (RevocationFreshnessTime != ref.RevocationFreshnessTime) return false;
        if (CacheResync != ref.CacheResync) return false;
        return true;
    }

    std::ostream& CertChainPara::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << RequestedUsage;
        os << " " << RequstedIssuancePolicy;
        os << " " << URLRetrievalTimeout;
        os << " " << CheckRevocationFreshnessTime;
        os << " " << RevocationFreshnessTime;
        os << " " << CacheResync;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertChainPara& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertChainPolicyPara::operator T()
    {
        T result;
        result.Size = this->Size;
        result.Flags = this->Flags;
        result.ExtraPolicyPara = this->ExtraPolicyPara;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertChainPolicyPara::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (Flags != ref.Flags) return false;
        if (ExtraPolicyPara != ref.ExtraPolicyPara) return false;
        return true;
    }

    std::ostream& CertChainPolicyPara::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << Flags;
        os << " " << ExtraPolicyPara;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertChainPolicyPara& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SSLExtraCertChainPolicyPara::operator T()
    {
        T result;
        result.Size = this->Size;
        result.AuthType = this->AuthType;
        result.Checks = this->Checks;
        result.ServerName = this->ServerName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SSLExtraCertChainPolicyPara::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (AuthType != ref.AuthType) return false;
        if (Checks != ref.Checks) return false;
        if (ServerName != ref.ServerName) return false;
        return true;
    }

    std::ostream& SSLExtraCertChainPolicyPara::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << AuthType;
        os << " " << Checks;
        os << " " << ServerName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SSLExtraCertChainPolicyPara& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CertChainPolicyStatus::operator T()
    {
        T result;
        result.Size = this->Size;
        result.Error = this->Error;
        result.ChainIndex = this->ChainIndex;
        result.ElementIndex = this->ElementIndex;
        result.ExtraPolicyStatus = this->ExtraPolicyStatus;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CertChainPolicyStatus::operator==(const T& ref) const
    {
        if (Size != ref.Size) return false;
        if (Error != ref.Error) return false;
        if (ChainIndex != ref.ChainIndex) return false;
        if (ElementIndex != ref.ElementIndex) return false;
        if (ExtraPolicyStatus != ref.ExtraPolicyStatus) return false;
        return true;
    }

    std::ostream& CertChainPolicyStatus::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Size;
        os << " " << Error;
        os << " " << ChainIndex;
        os << " " << ElementIndex;
        os << " " << ExtraPolicyStatus;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CertChainPolicyStatus& value)
    {
        return value.PrintTo(os);
    }

    // do not reorder
    // do not reorder
    
    template<typename T> requires gocpp::GoStruct<T>
    AddrinfoW::operator T()
    {
        T result;
        result.Flags = this->Flags;
        result.Family = this->Family;
        result.Socktype = this->Socktype;
        result.Protocol = this->Protocol;
        result.Addrlen = this->Addrlen;
        result.Canonname = this->Canonname;
        result.Addr = this->Addr;
        result.Next = this->Next;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool AddrinfoW::operator==(const T& ref) const
    {
        if (Flags != ref.Flags) return false;
        if (Family != ref.Family) return false;
        if (Socktype != ref.Socktype) return false;
        if (Protocol != ref.Protocol) return false;
        if (Addrlen != ref.Addrlen) return false;
        if (Canonname != ref.Canonname) return false;
        if (Addr != ref.Addr) return false;
        if (Next != ref.Next) return false;
        return true;
    }

    std::ostream& AddrinfoW::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Flags;
        os << " " << Family;
        os << " " << Socktype;
        os << " " << Protocol;
        os << " " << Addrlen;
        os << " " << Canonname;
        os << " " << Addr;
        os << " " << Next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct AddrinfoW& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    GUID::operator T()
    {
        T result;
        result.Data1 = this->Data1;
        result.Data2 = this->Data2;
        result.Data3 = this->Data3;
        result.Data4 = this->Data4;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool GUID::operator==(const T& ref) const
    {
        if (Data1 != ref.Data1) return false;
        if (Data2 != ref.Data2) return false;
        if (Data3 != ref.Data3) return false;
        if (Data4 != ref.Data4) return false;
        return true;
    }

    std::ostream& GUID::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Data1;
        os << " " << Data2;
        os << " " << Data3;
        os << " " << Data4;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct GUID& value)
    {
        return value.PrintTo(os);
    }

    GUID WSAID_CONNECTEX = GUID {0x25a207b9, 0xddf3, 0x4660, gocpp::array<unsigned char, 8> {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}};
    
    template<typename T> requires gocpp::GoStruct<T>
    WSAProtocolInfo::operator T()
    {
        T result;
        result.ServiceFlags1 = this->ServiceFlags1;
        result.ServiceFlags2 = this->ServiceFlags2;
        result.ServiceFlags3 = this->ServiceFlags3;
        result.ServiceFlags4 = this->ServiceFlags4;
        result.ProviderFlags = this->ProviderFlags;
        result.ProviderId = this->ProviderId;
        result.CatalogEntryId = this->CatalogEntryId;
        result.ProtocolChain = this->ProtocolChain;
        result.Version = this->Version;
        result.AddressFamily = this->AddressFamily;
        result.MaxSockAddr = this->MaxSockAddr;
        result.MinSockAddr = this->MinSockAddr;
        result.SocketType = this->SocketType;
        result.Protocol = this->Protocol;
        result.ProtocolMaxOffset = this->ProtocolMaxOffset;
        result.NetworkByteOrder = this->NetworkByteOrder;
        result.SecurityScheme = this->SecurityScheme;
        result.MessageSize = this->MessageSize;
        result.ProviderReserved = this->ProviderReserved;
        result.ProtocolName = this->ProtocolName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WSAProtocolInfo::operator==(const T& ref) const
    {
        if (ServiceFlags1 != ref.ServiceFlags1) return false;
        if (ServiceFlags2 != ref.ServiceFlags2) return false;
        if (ServiceFlags3 != ref.ServiceFlags3) return false;
        if (ServiceFlags4 != ref.ServiceFlags4) return false;
        if (ProviderFlags != ref.ProviderFlags) return false;
        if (ProviderId != ref.ProviderId) return false;
        if (CatalogEntryId != ref.CatalogEntryId) return false;
        if (ProtocolChain != ref.ProtocolChain) return false;
        if (Version != ref.Version) return false;
        if (AddressFamily != ref.AddressFamily) return false;
        if (MaxSockAddr != ref.MaxSockAddr) return false;
        if (MinSockAddr != ref.MinSockAddr) return false;
        if (SocketType != ref.SocketType) return false;
        if (Protocol != ref.Protocol) return false;
        if (ProtocolMaxOffset != ref.ProtocolMaxOffset) return false;
        if (NetworkByteOrder != ref.NetworkByteOrder) return false;
        if (SecurityScheme != ref.SecurityScheme) return false;
        if (MessageSize != ref.MessageSize) return false;
        if (ProviderReserved != ref.ProviderReserved) return false;
        if (ProtocolName != ref.ProtocolName) return false;
        return true;
    }

    std::ostream& WSAProtocolInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ServiceFlags1;
        os << " " << ServiceFlags2;
        os << " " << ServiceFlags3;
        os << " " << ServiceFlags4;
        os << " " << ProviderFlags;
        os << " " << ProviderId;
        os << " " << CatalogEntryId;
        os << " " << ProtocolChain;
        os << " " << Version;
        os << " " << AddressFamily;
        os << " " << MaxSockAddr;
        os << " " << MinSockAddr;
        os << " " << SocketType;
        os << " " << Protocol;
        os << " " << ProtocolMaxOffset;
        os << " " << NetworkByteOrder;
        os << " " << SecurityScheme;
        os << " " << MessageSize;
        os << " " << ProviderReserved;
        os << " " << ProtocolName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WSAProtocolInfo& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    WSAProtocolChain::operator T()
    {
        T result;
        result.ChainLen = this->ChainLen;
        result.ChainEntries = this->ChainEntries;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WSAProtocolChain::operator==(const T& ref) const
    {
        if (ChainLen != ref.ChainLen) return false;
        if (ChainEntries != ref.ChainEntries) return false;
        return true;
    }

    std::ostream& WSAProtocolChain::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ChainLen;
        os << " " << ChainEntries;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WSAProtocolChain& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    TCPKeepalive::operator T()
    {
        T result;
        result.OnOff = this->OnOff;
        result.Time = this->Time;
        result.Interval = this->Interval;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool TCPKeepalive::operator==(const T& ref) const
    {
        if (OnOff != ref.OnOff) return false;
        if (Time != ref.Time) return false;
        if (Interval != ref.Interval) return false;
        return true;
    }

    std::ostream& TCPKeepalive::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << OnOff;
        os << " " << Time;
        os << " " << Interval;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct TCPKeepalive& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    symbolicLinkReparseBuffer::operator T()
    {
        T result;
        result.SubstituteNameOffset = this->SubstituteNameOffset;
        result.SubstituteNameLength = this->SubstituteNameLength;
        result.PrintNameOffset = this->PrintNameOffset;
        result.PrintNameLength = this->PrintNameLength;
        result.Flags = this->Flags;
        result.PathBuffer = this->PathBuffer;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool symbolicLinkReparseBuffer::operator==(const T& ref) const
    {
        if (SubstituteNameOffset != ref.SubstituteNameOffset) return false;
        if (SubstituteNameLength != ref.SubstituteNameLength) return false;
        if (PrintNameOffset != ref.PrintNameOffset) return false;
        if (PrintNameLength != ref.PrintNameLength) return false;
        if (Flags != ref.Flags) return false;
        if (PathBuffer != ref.PathBuffer) return false;
        return true;
    }

    std::ostream& symbolicLinkReparseBuffer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << SubstituteNameOffset;
        os << " " << SubstituteNameLength;
        os << " " << PrintNameOffset;
        os << " " << PrintNameLength;
        os << " " << Flags;
        os << " " << PathBuffer;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct symbolicLinkReparseBuffer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mountPointReparseBuffer::operator T()
    {
        T result;
        result.SubstituteNameOffset = this->SubstituteNameOffset;
        result.SubstituteNameLength = this->SubstituteNameLength;
        result.PrintNameOffset = this->PrintNameOffset;
        result.PrintNameLength = this->PrintNameLength;
        result.PathBuffer = this->PathBuffer;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mountPointReparseBuffer::operator==(const T& ref) const
    {
        if (SubstituteNameOffset != ref.SubstituteNameOffset) return false;
        if (SubstituteNameLength != ref.SubstituteNameLength) return false;
        if (PrintNameOffset != ref.PrintNameOffset) return false;
        if (PrintNameLength != ref.PrintNameLength) return false;
        if (PathBuffer != ref.PathBuffer) return false;
        return true;
    }

    std::ostream& mountPointReparseBuffer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << SubstituteNameOffset;
        os << " " << SubstituteNameLength;
        os << " " << PrintNameOffset;
        os << " " << PrintNameLength;
        os << " " << PathBuffer;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mountPointReparseBuffer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    reparseDataBuffer::operator T()
    {
        T result;
        result.ReparseTag = this->ReparseTag;
        result.ReparseDataLength = this->ReparseDataLength;
        result.Reserved = this->Reserved;
        result.reparseBuffer = this->reparseBuffer;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool reparseDataBuffer::operator==(const T& ref) const
    {
        if (ReparseTag != ref.ReparseTag) return false;
        if (ReparseDataLength != ref.ReparseDataLength) return false;
        if (Reserved != ref.Reserved) return false;
        if (reparseBuffer != ref.reparseBuffer) return false;
        return true;
    }

    std::ostream& reparseDataBuffer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ReparseTag;
        os << " " << ReparseDataLength;
        os << " " << Reserved;
        os << " " << reparseBuffer;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct reparseDataBuffer& value)
    {
        return value.PrintTo(os);
    }

}

