// generated by GoCpp from file '$(ImportDir)/runtime/symtab.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/symtab.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"

namespace golang::runtime
{
    struct Frames* CallersFrames(gocpp::slice<uintptr_t> callers);
    int runtime_FrameStartLine(struct Frame* f);
    std::string runtime_FrameSymbolName(struct Frame* f);
    gocpp::slice<uintptr_t> runtime_expandFinalInlineFrame(gocpp::slice<uintptr_t> stk);
    gocpp::slice<Frame> expandCgoFrames(uintptr_t pc);
    struct gocpp_id_0
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    struct pcHeader
    {
        uint32_t magic;
        uint8_t pad1;
        uint8_t pad2;
        uint8_t minLC;
        uint8_t ptrSize;
        int nfunc;
        unsigned int nfiles;
        uintptr_t textStart;
        uintptr_t funcnameOffset;
        uintptr_t cuOffset;
        uintptr_t filetabOffset;
        uintptr_t pctabOffset;
        uintptr_t pclnOffset;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pcHeader& value);
    struct modulehash
    {
        std::string modulename;
        std::string linktimehash;
        std::string* runtimehash;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct modulehash& value);
    extern gocpp::slice<gocpp::map<runtime::typeOff, runtime::_type*>> pinnedTypemaps;
    gocpp::slice<moduledata*> activeModules();
    void modulesinit();
    struct functab
    {
        uint32_t entryoff;
        uint32_t funcoff;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct functab& value);
    struct textsect
    {
        uintptr_t vaddr;
        uintptr_t end;
        uintptr_t baseaddr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct textsect& value);
    struct findfuncbucket
    {
        uint32_t idx;
        gocpp::array<unsigned char, 16> subbuckets;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct findfuncbucket& value);
    void moduledataverify();
    void moduledataverify1(struct moduledata* datap);
    struct Func* FuncForPC(uintptr_t pc);
    struct moduledata* findmoduledatap(uintptr_t pc);
    struct funcInfo
    {
        _func* _func;
        moduledata* datap;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct funcInfo& value);
    struct funcInfo findfunc(uintptr_t pc);
    struct srcFunc
    {
        moduledata* datap;
        int32_t nameOff;
        int32_t startLine;
        abi::FuncID funcID;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct srcFunc& value);
    struct pcvalueCacheEnt
    {
        uintptr_t targetpc;
        uint32_t off;
        int32_t val;
        uintptr_t valPC;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCacheEnt& value);
    uintptr_t pcvalueCacheKey(uintptr_t targetpc);
    std::tuple<int32_t, uintptr_t> pcvalue(struct funcInfo f, uint32_t off, uintptr_t targetpc, bool strict);
    std::string funcname(struct funcInfo f);
    std::string funcpkgpath(struct funcInfo f);
    std::string funcfile(struct funcInfo f, int32_t fileno);
    std::tuple<std::string, int32_t> funcline1(struct funcInfo f, uintptr_t targetpc, bool strict);
    std::tuple<std::string, int32_t> funcline(struct funcInfo f, uintptr_t targetpc);
    int32_t funcspdelta(struct funcInfo f, uintptr_t targetpc);
    int32_t funcMaxSPDelta(struct funcInfo f);
    uint32_t pcdatastart(struct funcInfo f, uint32_t table);
    int32_t pcdatavalue(struct funcInfo f, uint32_t table, uintptr_t targetpc);
    int32_t pcdatavalue1(struct funcInfo f, uint32_t table, uintptr_t targetpc, bool strict);
    std::tuple<int32_t, uintptr_t> pcdatavalue2(struct funcInfo f, uint32_t table, uintptr_t targetpc);
    unsafe::Pointer funcdata(struct funcInfo f, uint8_t i);
    std::tuple<gocpp::slice<unsigned char>, bool> step(gocpp::slice<unsigned char> p, uintptr_t* pc, int32_t* val, bool first);
    std::tuple<uint32_t, uint32_t> readvarint(gocpp::slice<unsigned char> p);
    struct stackmap
    {
        int32_t n;
        int32_t nbit;
        gocpp::array<unsigned char, 1> bytedata;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackmap& value);
    struct bitvector stackmapdata(struct stackmap* stkmap, int32_t n);
    struct Frame
    {
        uintptr_t PC;
        Func* Func;
        std::string Function;
        std::string File;
        int Line;
        int startLine;
        uintptr_t Entry;
        funcInfo funcInfo;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Frame& value);
    struct Func
    {
        gocpp_id_0 opaque;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Func& value);
    struct moduledata
    {
        sys::NotInHeap NotInHeap;
        pcHeader* pcHeader;
        gocpp::slice<unsigned char> funcnametab;
        gocpp::slice<uint32_t> cutab;
        gocpp::slice<unsigned char> filetab;
        gocpp::slice<unsigned char> pctab;
        gocpp::slice<unsigned char> pclntable;
        gocpp::slice<functab> ftab;
        uintptr_t findfunctab;
        uintptr_t minpc;
        uintptr_t maxpc;
        uintptr_t text;
        uintptr_t etext;
        uintptr_t noptrdata;
        uintptr_t enoptrdata;
        uintptr_t data;
        uintptr_t edata;
        uintptr_t bss;
        uintptr_t ebss;
        uintptr_t noptrbss;
        uintptr_t enoptrbss;
        uintptr_t covctrs;
        uintptr_t ecovctrs;
        uintptr_t end;
        uintptr_t gcdata;
        uintptr_t gcbss;
        uintptr_t types;
        uintptr_t etypes;
        uintptr_t rodata;
        uintptr_t gofunc;
        gocpp::slice<textsect> textsectmap;
        gocpp::slice<int32_t> typelinks;
        gocpp::slice<itab*> itablinks;
        gocpp::slice<ptabEntry> ptab;
        std::string pluginpath;
        gocpp::slice<modulehash> pkghashes;
        gocpp::slice<initTask*> inittasks;
        std::string modulename;
        gocpp::slice<modulehash> modulehashes;
        uint8_t hasmain;
        bitvector gcdatamask;
        bitvector gcbssmask;
        gocpp::map<golang::runtime::typeOff, golang::runtime::_type*> typemap;
        bool bad;
        moduledata* next;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct moduledata& value);
    struct pcvalueCache
    {
        gocpp::array<gocpp::array<pcvalueCacheEnt, 8>, 2> entries;
        int inUse;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCache& value);
    struct Frames
    {
        gocpp::slice<uintptr_t> callers;
        gocpp::slice<Frame> frames;
        gocpp::array<Frame, 2> frameStore;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Frames& value);
    extern moduledata firstmoduledata;
    extern moduledata* lastmoduledatap;
    extern gocpp::slice<moduledata*>* modulesSlice;

    namespace rec
    {
        std::tuple<struct Frame, bool> Next(struct Frames* ci);
        struct _func* raw(struct Func* f);
        struct funcInfo funcInfo(struct Func* f);
        struct funcInfo funcInfo(struct _func* f);
        uintptr_t textAddr(struct moduledata* md, uint32_t off32);
        std::tuple<uint32_t, bool> textOff(struct moduledata* md, uintptr_t pc);
        std::string funcName(struct moduledata* md, int32_t nameOff);
        std::string Name(struct Func* f);
        uintptr_t Entry(struct Func* f);
        std::tuple<std::string, int> FileLine(struct Func* f, uintptr_t pc);
        int32_t startLine(struct Func* f);
        bool valid(struct funcInfo f);
        struct Func* _Func(struct funcInfo f);
        bool isInlined(struct _func* f);
        uintptr_t entry(struct funcInfo f);
        struct srcFunc srcFunc(struct funcInfo f);
        std::string name(struct srcFunc s);
    }
}

