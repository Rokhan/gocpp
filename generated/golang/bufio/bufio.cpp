// generated by GoCpp from file '$(ImportDir)/bufio/bufio.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bufio/bufio.h"
#include "gocpp/support.h"

#include "golang/bytes/bytes.h"
#include "golang/errors/errors.h"
#include "golang/io/io.h"
#include "golang/strings/builder.h"
#include "golang/unicode/utf8/utf8.h"

// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer
// object, creating another object (Reader or Writer) that also implements
// the interface but provides buffering and some help for textual I/O.
namespace golang::bufio
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Read;
        using io::rec::ReadFrom;
        using io::rec::Write;
        using io::rec::WriteString;
        using io::rec::WriteTo;
        using strings::rec::Grow;
        using strings::rec::String;
        using strings::rec::Write;
    }

    gocpp::error ErrInvalidUnreadByte = errors::New("bufio: invalid use of UnreadByte"s);
    gocpp::error ErrInvalidUnreadRune = errors::New("bufio: invalid use of UnreadRune"s);
    gocpp::error ErrBufferFull = errors::New("bufio: buffer full"s);
    gocpp::error ErrNegativeCount = errors::New("bufio: negative count"s);
    // Reader implements buffering for an io.Reader object.
    
    template<typename T> requires gocpp::GoStruct<T>
    Reader::operator T()
    {
        T result;
        result.buf = this->buf;
        result.rd = this->rd;
        result.r = this->r;
        result.w = this->w;
        result.err = this->err;
        result.lastByte = this->lastByte;
        result.lastRuneSize = this->lastRuneSize;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Reader::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (rd != ref.rd) return false;
        if (r != ref.r) return false;
        if (w != ref.w) return false;
        if (err != ref.err) return false;
        if (lastByte != ref.lastByte) return false;
        if (lastRuneSize != ref.lastRuneSize) return false;
        return true;
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << rd;
        os << " " << r;
        os << " " << w;
        os << " " << err;
        os << " " << lastByte;
        os << " " << lastRuneSize;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    // NewReaderSize returns a new [Reader] whose buffer has at least the specified
    // size. If the argument io.Reader is already a [Reader] with large enough
    // size, it returns the underlying [Reader].
    struct Reader* NewReaderSize(io::Reader rd, int size)
    {
        auto [b, ok] = gocpp::getValue<Reader*>(rd);
        if(ok && len(b->buf) >= size)
        {
            return b;
        }
        auto r = new(Reader);
        rec::reset(gocpp::recv(r), gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), gocpp::max(size, minReadBufferSize)), rd);
        return r;
    }

    // NewReader returns a new [Reader] whose buffer has the default size.
    struct Reader* NewReader(io::Reader rd)
    {
        return NewReaderSize(rd, defaultBufSize);
    }

    // Size returns the size of the underlying buffer in bytes.
    int rec::Size(struct Reader* b)
    {
        return len(b->buf);
    }

    // Reset discards any buffered data, resets all state, and switches
    // the buffered reader to read from r.
    // Calling Reset on the zero value of [Reader] initializes the internal buffer
    // to the default size.
    // Calling b.Reset(b) (that is, resetting a [Reader] to itself) does nothing.
    void rec::Reset(struct Reader* b, io::Reader r)
    {
        if(b == r)
        {
            return;
        }
        if(b->buf == nullptr)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), defaultBufSize);
        }
        rec::reset(gocpp::recv(b), b->buf, r);
    }

    void rec::reset(struct Reader* b, gocpp::slice<unsigned char> buf, io::Reader r)
    {
        *b = gocpp::Init<Reader>([=](auto& x) {
            x.buf = buf;
            x.rd = r;
            x.lastByte = - 1;
            x.lastRuneSize = - 1;
        });
    }

    gocpp::error errNegativeRead = errors::New("bufio: reader returned negative count from Read"s);
    // fill reads a new chunk into the buffer.
    void rec::fill(struct Reader* b)
    {
        if(b->r > 0)
        {
            copy(b->buf, b->buf.make_slice(b->r, b->w));
            b->w -= b->r;
            b->r = 0;
        }
        if(b->w >= len(b->buf))
        {
            gocpp::panic("bufio: tried to fill full buffer"s);
        }
        for(auto i = maxConsecutiveEmptyReads; i > 0; i--)
        {
            auto [n, err] = rec::Read(gocpp::recv(b->rd), b->buf.make_slice(b->w));
            if(n < 0)
            {
                gocpp::panic(errNegativeRead);
            }
            b->w += n;
            if(err != nullptr)
            {
                b->err = err;
                return;
            }
            if(n > 0)
            {
                return;
            }
        }
        b->err = io::ErrNoProgress;
    }

    struct gocpp::error rec::readErr(struct Reader* b)
    {
        auto err = b->err;
        b->err = nullptr;
        return err;
    }

    // Peek returns the next n bytes without advancing the reader. The bytes stop
    // being valid at the next read call. If Peek returns fewer than n bytes, it
    // also returns an error explaining why the read is short. The error is
    // [ErrBufferFull] if n is larger than b's buffer size.
    //
    // Calling Peek prevents a [Reader.UnreadByte] or [Reader.UnreadRune] call from succeeding
    // until the next read operation.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::Peek(struct Reader* b, int n)
    {
        if(n < 0)
        {
            return {nullptr, ErrNegativeCount};
        }
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        for(; b->w - b->r < n && b->w - b->r < len(b->buf) && b->err == nullptr; )
        {
            rec::fill(gocpp::recv(b));
        }
        if(n > len(b->buf))
        {
            return {b->buf.make_slice(b->r, b->w), ErrBufferFull};
        }
        // 0 <= n <= len(b.buf)
        gocpp::error err = {};
        if(auto avail = b->w - b->r; avail < n)
        {
            n = avail;
            err = rec::readErr(gocpp::recv(b));
            if(err == nullptr)
            {
                err = ErrBufferFull;
            }
        }
        return {b->buf.make_slice(b->r, b->r + n), err};
    }

    // Discard skips the next n bytes, returning the number of bytes discarded.
    //
    // If Discard skips fewer than n bytes, it also returns an error.
    // If 0 <= n <= b.Buffered(), Discard is guaranteed to succeed without
    // reading from the underlying io.Reader.
    std::tuple<int, struct gocpp::error> rec::Discard(struct Reader* b, int n)
    {
        int discarded;
        struct gocpp::error err;
        if(n < 0)
        {
            return {0, ErrNegativeCount};
        }
        if(n == 0)
        {
            return {discarded, err};
        }
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        auto remain = n;
        for(; ; )
        {
            auto skip = rec::Buffered(gocpp::recv(b));
            if(skip == 0)
            {
                rec::fill(gocpp::recv(b));
                skip = rec::Buffered(gocpp::recv(b));
            }
            if(skip > remain)
            {
                skip = remain;
            }
            b->r += skip;
            remain -= skip;
            if(remain == 0)
            {
                return {n, nullptr};
            }
            if(b->err != nullptr)
            {
                return {n - remain, rec::readErr(gocpp::recv(b))};
            }
        }
    }

    // Read reads data into p.
    // It returns the number of bytes read into p.
    // The bytes are taken from at most one Read on the underlying [Reader],
    // hence n may be less than len(p).
    // To read exactly len(p) bytes, use io.ReadFull(b, p).
    // If the underlying [Reader] can return a non-zero count with io.EOF,
    // then this Read method can do so as well; see the [io.Reader] docs.
    std::tuple<int, struct gocpp::error> rec::Read(struct Reader* b, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        n = len(p);
        if(n == 0)
        {
            if(rec::Buffered(gocpp::recv(b)) > 0)
            {
                return {0, nullptr};
            }
            return {0, rec::readErr(gocpp::recv(b))};
        }
        if(b->r == b->w)
        {
            if(b->err != nullptr)
            {
                return {0, rec::readErr(gocpp::recv(b))};
            }
            if(len(p) >= len(b->buf))
            {
                std::tie(n, b->err) = rec::Read(gocpp::recv(b->rd), p);
                if(n < 0)
                {
                    gocpp::panic(errNegativeRead);
                }
                if(n > 0)
                {
                    b->lastByte = int(p[n - 1]);
                    b->lastRuneSize = - 1;
                }
                return {n, rec::readErr(gocpp::recv(b))};
            }
            b->r = 0;
            b->w = 0;
            std::tie(n, b->err) = rec::Read(gocpp::recv(b->rd), b->buf);
            if(n < 0)
            {
                gocpp::panic(errNegativeRead);
            }
            if(n == 0)
            {
                return {0, rec::readErr(gocpp::recv(b))};
            }
            b->w += n;
        }
        n = copy(p, b->buf.make_slice(b->r, b->w));
        b->r += n;
        b->lastByte = int(b->buf[b->r - 1]);
        b->lastRuneSize = - 1;
        return {n, nullptr};
    }

    // ReadByte reads and returns a single byte.
    // If no byte is available, returns an error.
    std::tuple<unsigned char, struct gocpp::error> rec::ReadByte(struct Reader* b)
    {
        b->lastRuneSize = - 1;
        for(; b->r == b->w; )
        {
            if(b->err != nullptr)
            {
                return {0, rec::readErr(gocpp::recv(b))};
            }
            rec::fill(gocpp::recv(b));
        }
        auto c = b->buf[b->r];
        b->r++;
        b->lastByte = int(c);
        return {c, nullptr};
    }

    // UnreadByte unreads the last byte. Only the most recently read byte can be unread.
    //
    // UnreadByte returns an error if the most recent method called on the
    // [Reader] was not a read operation. Notably, [Reader.Peek], [Reader.Discard], and [Reader.WriteTo] are not
    // considered read operations.
    struct gocpp::error rec::UnreadByte(struct Reader* b)
    {
        if(b->lastByte < 0 || b->r == 0 && b->w > 0)
        {
            return ErrInvalidUnreadByte;
        }
        if(b->r > 0)
        {
            b->r--;
        }
        else
        {
            b->w = 1;
        }
        b->buf[b->r] = (unsigned char)(b->lastByte);
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        return nullptr;
    }

    // ReadRune reads a single UTF-8 encoded Unicode character and returns the
    // rune and its size in bytes. If the encoded rune is invalid, it consumes one byte
    // and returns unicode.ReplacementChar (U+FFFD) with a size of 1.
    std::tuple<gocpp::rune, int, struct gocpp::error> rec::ReadRune(struct Reader* b)
    {
        gocpp::rune r;
        int size;
        struct gocpp::error err;
        for(; b->r + utf8::UTFMax > b->w && ! utf8::FullRune(b->buf.make_slice(b->r, b->w)) && b->err == nullptr && b->w - b->r < len(b->buf); )
        {
            rec::fill(gocpp::recv(b));
        }
        b->lastRuneSize = - 1;
        if(b->r == b->w)
        {
            return {0, 0, rec::readErr(gocpp::recv(b))};
        }
        std::tie(r, size) = std::tuple{gocpp::rune(b->buf[b->r]), 1};
        if(r >= utf8::RuneSelf)
        {
            std::tie(r, size) = utf8::DecodeRune(b->buf.make_slice(b->r, b->w));
        }
        b->r += size;
        b->lastByte = int(b->buf[b->r - 1]);
        b->lastRuneSize = size;
        return {r, size, nullptr};
    }

    // UnreadRune unreads the last rune. If the most recent method called on
    // the [Reader] was not a [Reader.ReadRune], [Reader.UnreadRune] returns an error. (In this
    // regard it is stricter than [Reader.UnreadByte], which will unread the last byte
    // from any read operation.)
    struct gocpp::error rec::UnreadRune(struct Reader* b)
    {
        if(b->lastRuneSize < 0 || b->r < b->lastRuneSize)
        {
            return ErrInvalidUnreadRune;
        }
        b->r -= b->lastRuneSize;
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        return nullptr;
    }

    // Buffered returns the number of bytes that can be read from the current buffer.
    int rec::Buffered(struct Reader* b)
    {
        return b->w - b->r;
    }

    // ReadSlice reads until the first occurrence of delim in the input,
    // returning a slice pointing at the bytes in the buffer.
    // The bytes stop being valid at the next read.
    // If ReadSlice encounters an error before finding a delimiter,
    // it returns all the data in the buffer and the error itself (often io.EOF).
    // ReadSlice fails with error [ErrBufferFull] if the buffer fills without a delim.
    // Because the data returned from ReadSlice will be overwritten
    // by the next I/O operation, most clients should use
    // [Reader.ReadBytes] or ReadString instead.
    // ReadSlice returns err != nil if and only if line does not end in delim.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadSlice(struct Reader* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        struct gocpp::error err;
        auto s = 0;
        for(; ; )
        {
            if(auto i = bytes::IndexByte(b->buf.make_slice(b->r + s, b->w), delim); i >= 0)
            {
                i += s;
                line = b->buf.make_slice(b->r, b->r + i + 1);
                b->r += i + 1;
                break;
            }
            if(b->err != nullptr)
            {
                line = b->buf.make_slice(b->r, b->w);
                b->r = b->w;
                err = rec::readErr(gocpp::recv(b));
                break;
            }
            if(rec::Buffered(gocpp::recv(b)) >= len(b->buf))
            {
                b->r = b->w;
                line = b->buf;
                err = ErrBufferFull;
                break;
            }
            s = b->w - b->r;
            rec::fill(gocpp::recv(b));
        }
        if(auto i = len(line) - 1; i >= 0)
        {
            b->lastByte = int(line[i]);
            b->lastRuneSize = - 1;
        }
        return {line, err};
    }

    // ReadLine is a low-level line-reading primitive. Most callers should use
    // [Reader.ReadBytes]('\n') or [Reader.ReadString]('\n') instead or use a [Scanner].
    //
    // ReadLine tries to return a single line, not including the end-of-line bytes.
    // If the line was too long for the buffer then isPrefix is set and the
    // beginning of the line is returned. The rest of the line will be returned
    // from future calls. isPrefix will be false when returning the last fragment
    // of the line. The returned buffer is only valid until the next call to
    // ReadLine. ReadLine either returns a non-nil line or it returns an error,
    // never both.
    //
    // The text returned from ReadLine does not include the line end ("\r\n" or "\n").
    // No indication or error is given if the input ends without a final line end.
    // Calling [Reader.UnreadByte] after ReadLine will always unread the last byte read
    // (possibly a character belonging to the line end) even if that byte is not
    // part of the line returned by ReadLine.
    std::tuple<gocpp::slice<unsigned char>, bool, struct gocpp::error> rec::ReadLine(struct Reader* b)
    {
        gocpp::slice<unsigned char> line;
        bool isPrefix;
        struct gocpp::error err;
        std::tie(line, err) = rec::ReadSlice(gocpp::recv(b), '\n');
        if(err == ErrBufferFull)
        {
            if(len(line) > 0 && line[len(line) - 1] == '\r')
            {
                if(b->r == 0)
                {
                    gocpp::panic("bufio: tried to rewind past start of buffer"s);
                }
                b->r--;
                line = line.make_slice(0, len(line) - 1);
            }
            return {line, true, nullptr};
        }
        if(len(line) == 0)
        {
            if(err != nullptr)
            {
                line = nullptr;
            }
            return {line, isPrefix, err};
        }
        err = nullptr;
        if(line[len(line) - 1] == '\n')
        {
            auto drop = 1;
            if(len(line) > 1 && line[len(line) - 2] == '\r')
            {
                drop = 2;
            }
            line = line.make_slice(0, len(line) - drop);
        }
        return {line, isPrefix, err};
    }

    // collectFragments reads until the first occurrence of delim in the input. It
    // returns (slice of full buffers, remaining bytes before delim, total number
    // of bytes in the combined first two elements, error).
    // The complete result is equal to
    // `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a
    // length of `totalLen`. The result is structured in this way to allow callers
    // to minimize allocations and copies.
    std::tuple<gocpp::slice<gocpp::slice<unsigned char>>, gocpp::slice<unsigned char>, int, struct gocpp::error> rec::collectFragments(struct Reader* b, unsigned char delim)
    {
        gocpp::slice<gocpp::slice<unsigned char>> fullBuffers;
        gocpp::slice<unsigned char> finalFragment;
        int totalLen;
        struct gocpp::error err;
        gocpp::slice<unsigned char> frag = {};
        for(; ; )
        {
            gocpp::error e = {};
            std::tie(frag, e) = rec::ReadSlice(gocpp::recv(b), delim);
            if(e == nullptr)
            {
                break;
            }
            if(e != ErrBufferFull)
            {
                err = e;
                break;
            }
            auto buf = bytes::Clone(frag);
            fullBuffers = append(fullBuffers, buf);
            totalLen += len(buf);
        }
        totalLen += len(frag);
        return {fullBuffers, frag, totalLen, err};
    }

    // ReadBytes reads until the first occurrence of delim in the input,
    // returning a slice containing the data up to and including the delimiter.
    // If ReadBytes encounters an error before finding a delimiter,
    // it returns the data read before the error and the error itself (often io.EOF).
    // ReadBytes returns err != nil if and only if the returned data does not end in
    // delim.
    // For simple uses, a Scanner may be more convenient.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadBytes(struct Reader* b, unsigned char delim)
    {
        auto [full, frag, n, err] = rec::collectFragments(gocpp::recv(b), delim);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
        n = 0;
        for(auto [i, gocpp_ignored] : full)
        {
            n += copy(buf.make_slice(n), full[i]);
        }
        copy(buf.make_slice(n), frag);
        return {buf, err};
    }

    // ReadString reads until the first occurrence of delim in the input,
    // returning a string containing the data up to and including the delimiter.
    // If ReadString encounters an error before finding a delimiter,
    // it returns the data read before the error and the error itself (often io.EOF).
    // ReadString returns err != nil if and only if the returned data does not end in
    // delim.
    // For simple uses, a Scanner may be more convenient.
    std::tuple<std::string, struct gocpp::error> rec::ReadString(struct Reader* b, unsigned char delim)
    {
        auto [full, frag, n, err] = rec::collectFragments(gocpp::recv(b), delim);
        // Allocate new buffer to hold the full pieces and the fragment.
        strings::Builder buf = {};
        rec::Grow(gocpp::recv(buf), n);
        for(auto [gocpp_ignored, fb] : full)
        {
            rec::Write(gocpp::recv(buf), fb);
        }
        rec::Write(gocpp::recv(buf), frag);
        return {rec::String(gocpp::recv(buf)), err};
    }

    // WriteTo implements io.WriterTo.
    // This may make multiple calls to the [Reader.Read] method of the underlying [Reader].
    // If the underlying reader supports the [Reader.WriteTo] method,
    // this calls the underlying [Reader.WriteTo] without buffering.
    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct Reader* b, io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        std::tie(n, err) = rec::writeBuf(gocpp::recv(b), w);
        if(err != nullptr)
        {
            return {n, err};
        }
        if(auto [r, ok] = gocpp::getValue<io::WriterTo>(b->rd); ok)
        {
            auto [m, err] = rec::WriteTo(gocpp::recv(r), w);
            n += m;
            return {n, err};
        }
        {
            auto [w_tmp, ok] = gocpp::getValue<io::ReaderFrom>(w);
            if(auto& w = w_tmp; ok)
            {
                auto [m, err] = rec::ReadFrom(gocpp::recv(w), b->rd);
                n += m;
                return {n, err};
            }
        }
        if(b->w - b->r < len(b->buf))
        {
            rec::fill(gocpp::recv(b));
        }
        for(; b->r < b->w; )
        {
            auto [m, err] = rec::writeBuf(gocpp::recv(b), w);
            n += m;
            if(err != nullptr)
            {
                return {n, err};
            }
            rec::fill(gocpp::recv(b));
        }
        if(b->err == io::go_EOF)
        {
            b->err = nullptr;
        }
        return {n, rec::readErr(gocpp::recv(b))};
    }

    gocpp::error errNegativeWrite = errors::New("bufio: writer returned negative count from Write"s);
    // writeBuf writes the [Reader]'s buffer to the writer.
    std::tuple<int64_t, struct gocpp::error> rec::writeBuf(struct Reader* b, io::Writer w)
    {
        auto [n, err] = rec::Write(gocpp::recv(w), b->buf.make_slice(b->r, b->w));
        if(n < 0)
        {
            gocpp::panic(errNegativeWrite);
        }
        b->r += n;
        return {int64_t(n), err};
    }

    // Writer implements buffering for an [io.Writer] object.
    // If an error occurs writing to a [Writer], no more data will be
    // accepted and all subsequent writes, and [Writer.Flush], will return the error.
    // After all data has been written, the client should call the
    // [Writer.Flush] method to guarantee all data has been forwarded to
    // the underlying [io.Writer].
    
    template<typename T> requires gocpp::GoStruct<T>
    Writer::operator T()
    {
        T result;
        result.err = this->err;
        result.buf = this->buf;
        result.n = this->n;
        result.wr = this->wr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Writer::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (buf != ref.buf) return false;
        if (n != ref.n) return false;
        if (wr != ref.wr) return false;
        return true;
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << buf;
        os << " " << n;
        os << " " << wr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    // NewWriterSize returns a new [Writer] whose buffer has at least the specified
    // size. If the argument io.Writer is already a [Writer] with large enough
    // size, it returns the underlying [Writer].
    struct Writer* NewWriterSize(io::Writer w, int size)
    {
        auto [b, ok] = gocpp::getValue<Writer*>(w);
        if(ok && len(b->buf) >= size)
        {
            return b;
        }
        if(size <= 0)
        {
            size = defaultBufSize;
        }
        return gocpp::InitPtr<Writer>([=](auto& x) {
            x.buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
            x.wr = w;
        });
    }

    // NewWriter returns a new [Writer] whose buffer has the default size.
    // If the argument io.Writer is already a [Writer] with large enough buffer size,
    // it returns the underlying [Writer].
    struct Writer* NewWriter(io::Writer w)
    {
        return NewWriterSize(w, defaultBufSize);
    }

    // Size returns the size of the underlying buffer in bytes.
    int rec::Size(struct Writer* b)
    {
        return len(b->buf);
    }

    // Reset discards any unflushed buffered data, clears any error, and
    // resets b to write its output to w.
    // Calling Reset on the zero value of [Writer] initializes the internal buffer
    // to the default size.
    // Calling w.Reset(w) (that is, resetting a [Writer] to itself) does nothing.
    void rec::Reset(struct Writer* b, io::Writer w)
    {
        if(b == w)
        {
            return;
        }
        if(b->buf == nullptr)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), defaultBufSize);
        }
        b->err = nullptr;
        b->n = 0;
        b->wr = w;
    }

    // Flush writes any buffered data to the underlying [io.Writer].
    struct gocpp::error rec::Flush(struct Writer* b)
    {
        if(b->err != nullptr)
        {
            return b->err;
        }
        if(b->n == 0)
        {
            return nullptr;
        }
        auto [n, err] = rec::Write(gocpp::recv(b->wr), b->buf.make_slice(0, b->n));
        if(n < b->n && err == nullptr)
        {
            err = io::ErrShortWrite;
        }
        if(err != nullptr)
        {
            if(n > 0 && n < b->n)
            {
                copy(b->buf.make_slice(0, b->n - n), b->buf.make_slice(n, b->n));
            }
            b->n -= n;
            b->err = err;
            return err;
        }
        b->n = 0;
        return nullptr;
    }

    // Available returns how many bytes are unused in the buffer.
    int rec::Available(struct Writer* b)
    {
        return len(b->buf) - b->n;
    }

    // AvailableBuffer returns an empty buffer with b.Available() capacity.
    // This buffer is intended to be appended to and
    // passed to an immediately succeeding [Writer.Write] call.
    // The buffer is only valid until the next write operation on b.
    gocpp::slice<unsigned char> rec::AvailableBuffer(struct Writer* b)
    {
        return b->buf.make_slice(b->n).make_slice(0, 0);
    }

    // Buffered returns the number of bytes that have been written into the current buffer.
    int rec::Buffered(struct Writer* b)
    {
        return b->n;
    }

    // Write writes the contents of p into the buffer.
    // It returns the number of bytes written.
    // If nn < len(p), it also returns an error explaining
    // why the write is short.
    std::tuple<int, struct gocpp::error> rec::Write(struct Writer* b, gocpp::slice<unsigned char> p)
    {
        int nn;
        struct gocpp::error err;
        for(; len(p) > rec::Available(gocpp::recv(b)) && b->err == nullptr; )
        {
            int n = {};
            if(rec::Buffered(gocpp::recv(b)) == 0)
            {
                std::tie(n, b->err) = rec::Write(gocpp::recv(b->wr), p);
            }
            else
            {
                n = copy(b->buf.make_slice(b->n), p);
                b->n += n;
                rec::Flush(gocpp::recv(b));
            }
            nn += n;
            p = p.make_slice(n);
        }
        if(b->err != nullptr)
        {
            return {nn, b->err};
        }
        auto n = copy(b->buf.make_slice(b->n), p);
        b->n += n;
        nn += n;
        return {nn, nullptr};
    }

    // WriteByte writes a single byte.
    struct gocpp::error rec::WriteByte(struct Writer* b, unsigned char c)
    {
        if(b->err != nullptr)
        {
            return b->err;
        }
        if(rec::Available(gocpp::recv(b)) <= 0 && rec::Flush(gocpp::recv(b)) != nullptr)
        {
            return b->err;
        }
        b->buf[b->n] = c;
        b->n++;
        return nullptr;
    }

    // WriteRune writes a single Unicode code point, returning
    // the number of bytes written and any error.
    std::tuple<int, struct gocpp::error> rec::WriteRune(struct Writer* b, gocpp::rune r)
    {
        int size;
        struct gocpp::error err;
        if(uint32_t(r) < utf8::RuneSelf)
        {
            err = rec::WriteByte(gocpp::recv(b), (unsigned char)(r));
            if(err != nullptr)
            {
                return {0, err};
            }
            return {1, nullptr};
        }
        if(b->err != nullptr)
        {
            return {0, b->err};
        }
        auto n = rec::Available(gocpp::recv(b));
        if(n < utf8::UTFMax)
        {
            if(rec::Flush(gocpp::recv(b)); b->err != nullptr)
            {
                return {0, b->err};
            }
            n = rec::Available(gocpp::recv(b));
            if(n < utf8::UTFMax)
            {
                return rec::WriteString(gocpp::recv(b), std::string(r));
            }
        }
        size = utf8::EncodeRune(b->buf.make_slice(b->n), r);
        b->n += size;
        return {size, nullptr};
    }

    // WriteString writes a string.
    // It returns the number of bytes written.
    // If the count is less than len(s), it also returns an error explaining
    // why the write is short.
    std::tuple<int, struct gocpp::error> rec::WriteString(struct Writer* b, std::string s)
    {
        io::StringWriter sw = {};
        auto tryStringWriter = true;
        auto nn = 0;
        for(; len(s) > rec::Available(gocpp::recv(b)) && b->err == nullptr; )
        {
            int n = {};
            if(rec::Buffered(gocpp::recv(b)) == 0 && sw == nullptr && tryStringWriter)
            {
                std::tie(sw, tryStringWriter) = gocpp::getValue<io::StringWriter>(b->wr);
            }
            if(rec::Buffered(gocpp::recv(b)) == 0 && tryStringWriter)
            {
                std::tie(n, b->err) = rec::WriteString(gocpp::recv(sw), s);
            }
            else
            {
                n = copy(b->buf.make_slice(b->n), s);
                b->n += n;
                rec::Flush(gocpp::recv(b));
            }
            nn += n;
            s = s.make_slice(n);
        }
        if(b->err != nullptr)
        {
            return {nn, b->err};
        }
        auto n = copy(b->buf.make_slice(b->n), s);
        b->n += n;
        nn += n;
        return {nn, nullptr};
    }

    // ReadFrom implements [io.ReaderFrom]. If the underlying writer
    // supports the ReadFrom method, this calls the underlying ReadFrom.
    // If there is buffered data and an underlying ReadFrom, this fills
    // the buffer and writes it before calling ReadFrom.
    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(struct Writer* b, io::Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        if(b->err != nullptr)
        {
            return {0, b->err};
        }
        auto [readerFrom, readerFromOK] = gocpp::getValue<io::ReaderFrom>(b->wr);
        int m = {};
        for(; ; )
        {
            if(rec::Available(gocpp::recv(b)) == 0)
            {
                if(auto err1 = rec::Flush(gocpp::recv(b)); err1 != nullptr)
                {
                    return {n, err1};
                }
            }
            if(readerFromOK && rec::Buffered(gocpp::recv(b)) == 0)
            {
                auto [nn, err] = rec::ReadFrom(gocpp::recv(readerFrom), r);
                b->err = err;
                n += nn;
                return {n, err};
            }
            auto nr = 0;
            for(; nr < maxConsecutiveEmptyReads; )
            {
                std::tie(m, err) = rec::Read(gocpp::recv(r), b->buf.make_slice(b->n));
                if(m != 0 || err != nullptr)
                {
                    break;
                }
                nr++;
            }
            if(nr == maxConsecutiveEmptyReads)
            {
                return {n, io::ErrNoProgress};
            }
            b->n += m;
            n += int64_t(m);
            if(err != nullptr)
            {
                break;
            }
        }
        if(err == io::go_EOF)
        {
            if(rec::Available(gocpp::recv(b)) == 0)
            {
                err = rec::Flush(gocpp::recv(b));
            }
            else
            {
                err = nullptr;
            }
        }
        return {n, err};
    }

    // ReadWriter stores pointers to a [Reader] and a [Writer].
    // It implements [io.ReadWriter].
    
    template<typename T> requires gocpp::GoStruct<T>
    ReadWriter::operator T()
    {
        T result;
        result.Reader = this->Reader;
        result.Writer = this->Writer;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ReadWriter::operator==(const T& ref) const
    {
        if (Reader != ref.Reader) return false;
        if (Writer != ref.Writer) return false;
        return true;
    }

    std::ostream& ReadWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Reader;
        os << " " << Writer;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriter& value)
    {
        return value.PrintTo(os);
    }

    // NewReadWriter allocates a new [ReadWriter] that dispatches to r and w.
    struct ReadWriter* NewReadWriter(struct Reader* r, struct Writer* w)
    {
        return new ReadWriter {r, w};
    }

}

