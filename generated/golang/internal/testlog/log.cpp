// generated by GoCpp from file '$(ImportDir)/internal/testlog/log.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/testlog/log.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/value.h"

// Package testlog provides a back-channel communication path
// between tests and package os, so that cmd/go can see which
// environment variables and files a test consults.
namespace golang::testlog
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // Interface is the interface required of test loggers.
    // The os package will invoke the interface's methods to indicate that
    // it is inspecting the given environment variables or files.
    // Multiple goroutines may call these methods simultaneously.
    
    template<typename T>
    Interface::Interface(T& ref)
    {
        value.reset(new InterfaceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Interface::Interface(const T& ref)
    {
        value.reset(new InterfaceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Interface::Interface(T* ptr)
    {
        value.reset(new InterfaceImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Interface::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vGetenv(gocpp::string key)
    {
        return rec::Getenv(gocpp::PtrRecv<T, false>(value.get()), key);
    }
    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vStat(gocpp::string file)
    {
        return rec::Stat(gocpp::PtrRecv<T, false>(value.get()), file);
    }
    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vOpen(gocpp::string file)
    {
        return rec::Open(gocpp::PtrRecv<T, false>(value.get()), file);
    }
    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vChdir(gocpp::string dir)
    {
        return rec::Chdir(gocpp::PtrRecv<T, false>(value.get()), dir);
    }

    namespace rec
    {
        void Getenv(const gocpp::PtrRecv<struct Interface, false>& self, gocpp::string key)
        {
            return self.ptr->value->vGetenv(key);
        }

        void Getenv(const gocpp::ObjRecv<struct Interface>& self, gocpp::string key)
        {
            return self.obj.value->vGetenv(key);
        }

        void Stat(const gocpp::PtrRecv<struct Interface, false>& self, gocpp::string file)
        {
            return self.ptr->value->vStat(file);
        }

        void Stat(const gocpp::ObjRecv<struct Interface>& self, gocpp::string file)
        {
            return self.obj.value->vStat(file);
        }

        void Open(const gocpp::PtrRecv<struct Interface, false>& self, gocpp::string file)
        {
            return self.ptr->value->vOpen(file);
        }

        void Open(const gocpp::ObjRecv<struct Interface>& self, gocpp::string file)
        {
            return self.obj.value->vOpen(file);
        }

        void Chdir(const gocpp::PtrRecv<struct Interface, false>& self, gocpp::string dir)
        {
            return self.ptr->value->vChdir(dir);
        }

        void Chdir(const gocpp::ObjRecv<struct Interface>& self, gocpp::string dir)
        {
            return self.obj.value->vChdir(dir);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Interface& value)
    {
        return value.PrintTo(os);
    }

    // logger is the current logger Interface.
    // We use an atomic.Value in case test startup
    // is racing with goroutines started during init.
    // That must not cause a race detector failure,
    // although it will still result in limited visibility
    // into exactly what those goroutines do.
    atomic::Value logger;
    // SetLogger sets the test logger implementation for the current process.
    // It must be called only once, at process startup.
    void SetLogger(struct Interface impl)
    {
        if(rec::Load(gocpp::recv(logger)) != nullptr)
        {
            gocpp::panic("testlog: SetLogger must be called only once"_s);
        }
        rec::Store(gocpp::recv(logger), & impl);
    }

    // Logger returns the current test logger implementation.
    // It returns nil if there is no logger.
    struct Interface Logger()
    {
        auto impl = rec::Load(gocpp::recv(logger));
        if(impl == nullptr)
        {
            return nullptr;
        }
        return *gocpp::getValue<Interface*>(impl);
    }

    // Getenv calls Logger().Getenv, if a logger has been set.
    void Getenv(gocpp::string name)
    {
        if(auto log = Logger(); log != nullptr)
        {
            rec::Getenv(gocpp::recv(log), name);
        }
    }

    // Open calls Logger().Open, if a logger has been set.
    void Open(gocpp::string name)
    {
        if(auto log = Logger(); log != nullptr)
        {
            rec::Open(gocpp::recv(log), name);
        }
    }

    // Stat calls Logger().Stat, if a logger has been set.
    void Stat(gocpp::string name)
    {
        if(auto log = Logger(); log != nullptr)
        {
            rec::Stat(gocpp::recv(log), name);
        }
    }

}

