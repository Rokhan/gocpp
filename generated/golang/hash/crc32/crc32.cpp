// generated by GoCpp from file '$(ImportDir)/hash/crc32/crc32.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/hash/crc32/crc32.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/hash/crc32/crc32_amd64.h"
#include "golang/hash/crc32/crc32_generic.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

// Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32,
// checksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for
// information.
//
// Polynomials are represented in LSB-first form also known as reversed representation.
//
// See https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials
// for information.
namespace golang::crc32
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using sync::rec::Do;
    }

    // The size of a CRC-32 checksum in bytes.
    // Predefined polynomials.
    // IEEE is by far and away the most common CRC-32 polynomial.
    // Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...
    // Castagnoli's polynomial, used in iSCSI.
    // Has better error detection characteristics than IEEE.
    // https://dx.doi.org/10.1109/26.231911
    // Koopman's polynomial.
    // Also has better error detection characteristics than IEEE.
    // https://dx.doi.org/10.1109/DSN.2002.1028931
    // Table is a 256-word table representing the polynomial for efficient processing.
    // castagnoliTable points to a lazily initialized Table for the Castagnoli
    // polynomial. MakeTable will always return this value when asked to make a
    // Castagnoli table so we can compare against it to find when the caller is
    // using this polynomial.
    crc32::Table* castagnoliTable;
    slicing8Table* castagnoliTable8;
    std::function<uint32_t (uint32_t crc, gocpp::slice<unsigned char> p)> updateCastagnoli;
    sync::Once castagnoliOnce;
    atomic::Bool haveCastagnoli;
    void castagnoliInit()
    {
        castagnoliTable = simpleMakeTable(Castagnoli);
        if(archAvailableCastagnoli())
        {
            archInitCastagnoli();
            updateCastagnoli = archUpdateCastagnoli;
        }
        else
        {
            castagnoliTable8 = slicingMakeTable(Castagnoli);
            updateCastagnoli = [=](uint32_t crc, gocpp::slice<unsigned char> p) mutable -> uint32_t
            {
                return slicingUpdate(crc, castagnoliTable8, p);
            };
        }
        rec::Store(gocpp::recv(haveCastagnoli), true);
    }

    // IEEETable is the table for the [IEEE] polynomial.
    Table* IEEETable = simpleMakeTable(IEEE);
    // ieeeTable8 is the slicing8Table for IEEE
    slicing8Table* ieeeTable8;
    std::function<uint32_t (uint32_t crc, gocpp::slice<unsigned char> p)> updateIEEE;
    sync::Once ieeeOnce;
    void ieeeInit()
    {
        if(archAvailableIEEE())
        {
            archInitIEEE();
            updateIEEE = archUpdateIEEE;
        }
        else
        {
            ieeeTable8 = slicingMakeTable(IEEE);
            updateIEEE = [=](uint32_t crc, gocpp::slice<unsigned char> p) mutable -> uint32_t
            {
                return slicingUpdate(crc, ieeeTable8, p);
            };
        }
    }

    // MakeTable returns a [Table] constructed from the specified polynomial.
    // The contents of this [Table] must not be modified.
    crc32::Table* MakeTable(uint32_t poly)
    {
        //Go switch emulation
        {
            auto condition = poly;
            int conditionId = -1;
            if(condition == IEEE) { conditionId = 0; }
            else if(condition == Castagnoli) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    rec::Do(gocpp::recv(ieeeOnce), ieeeInit);
                    return IEEETable;
                    break;
                case 1:
                    rec::Do(gocpp::recv(castagnoliOnce), castagnoliInit);
                    return castagnoliTable;
                    break;
                default:
                    return simpleMakeTable(poly);
                    break;
            }
        }
    }

    // digest represents the partial evaluation of a checksum.
    
    template<typename T> requires gocpp::GoStruct<T>
    digest::operator T()
    {
        T result;
        result.crc = this->crc;
        result.tab = this->tab;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool digest::operator==(const T& ref) const
    {
        if (crc != ref.crc) return false;
        if (tab != ref.tab) return false;
        return true;
    }

    std::ostream& digest::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << crc;
        os << " " << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct digest& value)
    {
        return value.PrintTo(os);
    }

    // New creates a new [hash.Hash32] computing the CRC-32 checksum using the
    // polynomial represented by the [Table]. Its Sum method will lay the
    // value out in big-endian byte order. The returned Hash32 also
    // implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to
    // marshal and unmarshal the internal state of the hash.
    hash::Hash32 New(golang::crc32::Table* tab)
    {
        if(tab == IEEETable)
        {
            rec::Do(gocpp::recv(ieeeOnce), ieeeInit);
        }
        return new digest {0, tab};
    }

    // NewIEEE creates a new [hash.Hash32] computing the CRC-32 checksum using
    // the [IEEE] polynomial. Its Sum method will lay the value out in
    // big-endian byte order. The returned Hash32 also implements
    // [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal
    // and unmarshal the internal state of the hash.
    hash::Hash32 NewIEEE()
    {
        return New(IEEETable);
    }

    int rec::Size(struct digest* d)
    {
        return Size;
    }

    int rec::BlockSize(struct digest* d)
    {
        return 1;
    }

    void rec::Reset(struct digest* d)
    {
        d->crc = 0;
    }

    std::string magic = "crc\x01"s;
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalBinary(struct digest* d)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, marshaledSize);
        b = append(b, magic);
        b = appendUint32(b, tableSum(d->tab));
        b = appendUint32(b, d->crc);
        return {b, nullptr};
    }

    struct gocpp::error rec::UnmarshalBinary(struct digest* d, gocpp::slice<unsigned char> b)
    {
        if(len(b) < len(magic) || std::string(b.make_slice(0, len(magic))) != magic)
        {
            return errors::New("hash/crc32: invalid hash state identifier"s);
        }
        if(len(b) != marshaledSize)
        {
            return errors::New("hash/crc32: invalid hash state size"s);
        }
        if(tableSum(d->tab) != readUint32(b.make_slice(4)))
        {
            return errors::New("hash/crc32: tables do not match"s);
        }
        d->crc = readUint32(b.make_slice(8));
        return nullptr;
    }

    // appendUint32 is semantically the same as [binary.BigEndian.AppendUint32]
    // We copied this function because we can not import "encoding/binary" here.
    gocpp::slice<unsigned char> appendUint32(gocpp::slice<unsigned char> b, uint32_t x)
    {
        return append(b, (unsigned char)(x >> 24), (unsigned char)(x >> 16), (unsigned char)(x >> 8), (unsigned char)(x));
    }

    // readUint32 is semantically the same as [binary.BigEndian.Uint32]
    // We copied this function because we can not import "encoding/binary" here.
    uint32_t readUint32(gocpp::slice<unsigned char> b)
    {
        _ = b[3];
        return uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
    }

    uint32_t update(uint32_t crc, golang::crc32::Table* tab, gocpp::slice<unsigned char> p, bool checkInitIEEE)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(rec::Load(gocpp::recv(haveCastagnoli)) && tab == castagnoliTable) { conditionId = 0; }
            else if(tab == IEEETable) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return updateCastagnoli(crc, p);
                    break;
                case 1:
                    if(checkInitIEEE)
                    {
                        rec::Do(gocpp::recv(ieeeOnce), ieeeInit);
                    }
                    return updateIEEE(crc, p);
                    break;
                default:
                    return simpleUpdate(crc, tab, p);
                    break;
            }
        }
    }

    // Update returns the result of adding the bytes in p to the crc.
    uint32_t Update(uint32_t crc, golang::crc32::Table* tab, gocpp::slice<unsigned char> p)
    {
        return update(crc, tab, p, true);
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct digest* d, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        d->crc = update(d->crc, d->tab, p, false);
        return {len(p), nullptr};
    }

    uint32_t rec::Sum32(struct digest* d)
    {
        return d->crc;
    }

    gocpp::slice<unsigned char> rec::Sum(struct digest* d, gocpp::slice<unsigned char> in)
    {
        auto s = rec::Sum32(gocpp::recv(d));
        return append(in, (unsigned char)(s >> 24), (unsigned char)(s >> 16), (unsigned char)(s >> 8), (unsigned char)(s));
    }

    // Checksum returns the CRC-32 checksum of data
    // using the polynomial represented by the [Table].
    uint32_t Checksum(gocpp::slice<unsigned char> data, golang::crc32::Table* tab)
    {
        return Update(0, tab, data);
    }

    // ChecksumIEEE returns the CRC-32 checksum of data
    // using the [IEEE] polynomial.
    uint32_t ChecksumIEEE(gocpp::slice<unsigned char> data)
    {
        rec::Do(gocpp::recv(ieeeOnce), ieeeInit);
        return updateIEEE(0, data);
    }

    // tableSum returns the IEEE checksum of table t.
    uint32_t tableSum(golang::crc32::Table* t)
    {
        gocpp::array<unsigned char, 1024> a = {};
        auto b = a.make_slice(0, 0);
        if(t != nullptr)
        {
            for(auto [gocpp_ignored, x] : t)
            {
                b = appendUint32(b, x);
            }
        }
        return ChecksumIEEE(b);
    }

}

