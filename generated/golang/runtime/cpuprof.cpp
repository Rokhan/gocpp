// generated by GoCpp from file '$(ImportDir)/runtime/cpuprof.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/cpuprof.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/time_nofake.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    cpuProfile::operator T()
    {
        T result;
        result.lock = this->lock;
        result.on = this->on;
        result.log = this->log;
        result.extra = this->extra;
        result.numExtra = this->numExtra;
        result.lostExtra = this->lostExtra;
        result.lostAtomic = this->lostAtomic;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cpuProfile::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (on != ref.on) return false;
        if (log != ref.log) return false;
        if (extra != ref.extra) return false;
        if (numExtra != ref.numExtra) return false;
        if (lostExtra != ref.lostExtra) return false;
        if (lostAtomic != ref.lostAtomic) return false;
        return true;
    }

    std::ostream& cpuProfile::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << on;
        os << " " << log;
        os << " " << extra;
        os << " " << numExtra;
        os << " " << lostExtra;
        os << " " << lostAtomic;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuProfile& value)
    {
        return value.PrintTo(os);
    }

    cpuProfile cpuprof;
    void SetCPUProfileRate(int hz)
    {
        if(hz < 0)
        {
            hz = 0;
        }
        if(hz > 1000000)
        {
            hz = 1000000;
        }
        lock(& cpuprof.lock);
        if(hz > 0)
        {
            if(cpuprof.on || cpuprof.log != nullptr)
            {
                print("runtime: cannot set cpu profile rate until previous profile has finished.\n");
                unlock(& cpuprof.lock);
                return;
            }
            cpuprof.on = true;
            cpuprof.log = newProfBuf(1, profBufWordCount, profBufTagCount);
            auto hdr = gocpp::array<uint64_t, 1> {uint64_t(hz)};
            rec::write(gocpp::recv(cpuprof.log), nullptr, nanotime(), hdr.make_slice(0, ), nullptr);
            setcpuprofilerate(int32_t(hz));
        }
        else
        if(cpuprof.on)
        {
            setcpuprofilerate(0);
            cpuprof.on = false;
            rec::addExtra(gocpp::recv(cpuprof));
            rec::close(gocpp::recv(cpuprof.log));
        }
        unlock(& cpuprof.lock);
    }

    void rec::add(struct cpuProfile* p, unsafe::Pointer* tagPtr, gocpp::slice<uintptr_t> stk)
    {
        for(; ! rec::CompareAndSwap(gocpp::recv(prof.signalLock), 0, 1); )
        {
            osyield();
        }
        if(rec::Load(gocpp::recv(prof.hz)) != 0)
        {
            if(p->numExtra > 0 || p->lostExtra > 0 || p->lostAtomic > 0)
            {
                rec::addExtra(gocpp::recv(p));
            }
            auto hdr = gocpp::array<uint64_t, 1> {1};
            rec::write(gocpp::recv(cpuprof.log), tagPtr, nanotime(), hdr.make_slice(0, ), stk);
        }
        rec::Store(gocpp::recv(prof.signalLock), 0);
    }

    void rec::addNonGo(struct cpuProfile* p, gocpp::slice<uintptr_t> stk)
    {
        for(; ! rec::CompareAndSwap(gocpp::recv(prof.signalLock), 0, 1); )
        {
            osyield();
        }
        if(cpuprof.numExtra + 1 + len(stk) < len(cpuprof.extra))
        {
            auto i = cpuprof.numExtra;
            cpuprof.extra[i] = uintptr_t(1 + len(stk));
            copy(cpuprof.extra.make_slice(i + 1), stk);
            cpuprof.numExtra += 1 + len(stk);
        }
        else
        {
            cpuprof.lostExtra++;
        }
        rec::Store(gocpp::recv(prof.signalLock), 0);
    }

    void rec::addExtra(struct cpuProfile* p)
    {
        auto hdr = gocpp::array<uint64_t, 1> {1};
        for(auto i = 0; i < p->numExtra; )
        {
            rec::write(gocpp::recv(p->log), nullptr, 0, hdr.make_slice(0, ), p->extra.make_slice(i + 1, i + int(p->extra[i])));
            i += int(p->extra[i]);
        }
        p->numExtra = 0;
        if(p->lostExtra > 0)
        {
            auto hdr = gocpp::array<uint64_t, 1> {p->lostExtra};
            auto lostStk = gocpp::array<uintptr_t, 2> {abi::FuncPCABIInternal(_LostExternalCode) + sys::PCQuantum, abi::FuncPCABIInternal(_ExternalCode) + sys::PCQuantum};
            rec::write(gocpp::recv(p->log), nullptr, 0, hdr.make_slice(0, ), lostStk.make_slice(0, ));
            p->lostExtra = 0;
        }
        if(p->lostAtomic > 0)
        {
            auto hdr = gocpp::array<uint64_t, 1> {p->lostAtomic};
            auto lostStk = gocpp::array<uintptr_t, 2> {abi::FuncPCABIInternal(_LostSIGPROFDuringAtomic64) + sys::PCQuantum, abi::FuncPCABIInternal(_System) + sys::PCQuantum};
            rec::write(gocpp::recv(p->log), nullptr, 0, hdr.make_slice(0, ), lostStk.make_slice(0, ));
            p->lostAtomic = 0;
        }
    }

    gocpp::slice<unsigned char> CPUProfile()
    {
        gocpp::panic("CPUProfile no longer available");
    }

    int64_t runtime_pprof_runtime_cyclesPerSecond()
    {
        return ticksPerSecond();
    }

    std::tuple<gocpp::slice<uint64_t>, gocpp::slice<unsafe::Pointer>, bool> runtime_pprof_readProfile()
    {
        lock(& cpuprof.lock);
        auto log = cpuprof.log;
        unlock(& cpuprof.lock);
        auto readMode = profBufBlocking;
        if(GOOS == "darwin" || GOOS == "ios")
        {
            readMode = profBufNonBlocking;
        }
        auto [data, tags, eof] = rec::read(gocpp::recv(log), readMode);
        if(len(data) == 0 && eof)
        {
            lock(& cpuprof.lock);
            cpuprof.log = nullptr;
            unlock(& cpuprof.lock);
        }
        return {data, tags, eof};
    }

}

