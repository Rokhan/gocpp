// generated by GoCpp from file '$(ImportDir)/unicode/utf8/utf8.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/unicode/utf8/utf8.h"
#include "gocpp/support.h"

namespace golang::utf8
{
    char RuneError = '\uFFFD';
    int RuneSelf = 0x80;
    char MaxRune = '\U0010FFFF';
    int UTFMax = 4;
    int surrogateMin = 0xD800;
    int surrogateMax = 0xDFFF;
    int t1 = 0b00000000;
    int tx = 0b10000000;
    int t2 = 0b11000000;
    int t3 = 0b11100000;
    int t4 = 0b11110000;
    int t5 = 0b11111000;
    int maskx = 0b00111111;
    int mask2 = 0b00011111;
    int mask3 = 0b00001111;
    int mask4 = 0b00000111;
    int rune1Max = (1 << 7) - 1;
    int rune2Max = (1 << 11) - 1;
    int rune3Max = (1 << 16) - 1;
    int locb = 0b10000000;
    int hicb = 0b10111111;
    int xx = 0xF1;
    int as = 0xF0;
    int s1 = 0x02;
    int s2 = 0x13;
    int s3 = 0x03;
    int s4 = 0x23;
    int s5 = 0x34;
    int s6 = 0x04;
    int s7 = 0x44;
    gocpp::array<uint8_t, 256> first = gocpp::array<uint8_t, 256> {as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx};
    
    std::ostream& acceptRange::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lo;
        os << " " << hi;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct acceptRange& value)
    {
        return value.PrintTo(os);
    }

    gocpp::array<acceptRange, 16> acceptRanges = gocpp::Init<gocpp::array<acceptRange, 16>>([](gocpp::array<acceptRange, 16>& x) { x.0 =  {locb, hicb}; x.1 =  {0xA0, hicb}; x.2 =  {locb, 0x9F}; x.3 =  {0x90, hicb}; x.4 =  {locb, 0x8F}; });
    bool FullRune(gocpp::slice<unsigned char> p)
    {
        auto n = len(p);
        if(n == 0)
        {
            return false;
        }
        auto x = first[p[0]];
        if(n >= int(x & 7))
        {
            return true;
        }
        auto accept = acceptRanges[x >> 4];
        if(n > 1 && (p[1] < accept.lo || accept.hi < p[1]))
        {
            return true;
        }
        else
        if(n > 2 && (p[2] < locb || hicb < p[2]))
        {
            return true;
        }
        return false;
    }

    bool FullRuneInString(std::string s)
    {
        auto n = len(s);
        if(n == 0)
        {
            return false;
        }
        auto x = first[s[0]];
        if(n >= int(x & 7))
        {
            return true;
        }
        auto accept = acceptRanges[x >> 4];
        if(n > 1 && (s[1] < accept.lo || accept.hi < s[1]))
        {
            return true;
        }
        else
        if(n > 2 && (s[2] < locb || hicb < s[2]))
        {
            return true;
        }
        return false;
    }

    std::tuple<gocpp::rune, int> DecodeRune(gocpp::slice<unsigned char> p)
    {
        gocpp::rune r;
        int size;
        auto n = len(p);
        if(n < 1)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 0};
        }
        auto p0 = p[0];
        auto x = first[p0];
        if(x >= as)
        {
            gocpp::rune r;
            int size;
            auto mask = (rune(x) << 31) >> 31;
            return {rune(p[0]) &^ mask | RuneError & mask, 1};
        }
        auto sz = int(x & 7);
        auto accept = acceptRanges[x >> 4];
        if(n < sz)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        auto b1 = p[1];
        if(b1 < accept.lo || accept.hi < b1)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        if(sz <= 2)
        {
            gocpp::rune r;
            int size;
            return {(rune(p0 & mask2) << 6) | rune(b1 & maskx), 2};
        }
        auto b2 = p[2];
        if(b2 < locb || hicb < b2)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        if(sz <= 3)
        {
            gocpp::rune r;
            int size;
            return {(rune(p0 & mask3) << 12) | (rune(b1 & maskx) << 6) | rune(b2 & maskx), 3};
        }
        auto b3 = p[3];
        if(b3 < locb || hicb < b3)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        return {(rune(p0 & mask4) << 18) | (rune(b1 & maskx) << 12) | (rune(b2 & maskx) << 6) | rune(b3 & maskx), 4};
    }

    std::tuple<gocpp::rune, int> DecodeRuneInString(std::string s)
    {
        gocpp::rune r;
        int size;
        auto n = len(s);
        if(n < 1)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 0};
        }
        auto s0 = s[0];
        auto x = first[s0];
        if(x >= as)
        {
            gocpp::rune r;
            int size;
            auto mask = (rune(x) << 31) >> 31;
            return {rune(s[0]) &^ mask | RuneError & mask, 1};
        }
        auto sz = int(x & 7);
        auto accept = acceptRanges[x >> 4];
        if(n < sz)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        auto s1 = s[1];
        if(s1 < accept.lo || accept.hi < s1)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        if(sz <= 2)
        {
            gocpp::rune r;
            int size;
            return {(rune(s0 & mask2) << 6) | rune(s1 & maskx), 2};
        }
        auto s2 = s[2];
        if(s2 < locb || hicb < s2)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        if(sz <= 3)
        {
            gocpp::rune r;
            int size;
            return {(rune(s0 & mask3) << 12) | (rune(s1 & maskx) << 6) | rune(s2 & maskx), 3};
        }
        auto s3 = s[3];
        if(s3 < locb || hicb < s3)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        return {(rune(s0 & mask4) << 18) | (rune(s1 & maskx) << 12) | (rune(s2 & maskx) << 6) | rune(s3 & maskx), 4};
    }

    std::tuple<gocpp::rune, int> DecodeLastRune(gocpp::slice<unsigned char> p)
    {
        gocpp::rune r;
        int size;
        auto end = len(p);
        if(end == 0)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 0};
        }
        auto start = end - 1;
        r = rune(p[start]);
        if(r < RuneSelf)
        {
            gocpp::rune r;
            int size;
            return {r, 1};
        }
        auto lim = end - UTFMax;
        if(lim < 0)
        {
            gocpp::rune r;
            int size;
            lim = 0;
        }
        for(start--; start >= lim; start--)
        {
            gocpp::rune r;
            int size;
            if(RuneStart(p[start]))
            {
                gocpp::rune r;
                int size;
                break;
            }
        }
        if(start < 0)
        {
            gocpp::rune r;
            int size;
            start = 0;
        }
        std::tie(r, size) = DecodeRune(p.make_slice(start, end));
        if(start + size != end)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        return {r, size};
    }

    std::tuple<gocpp::rune, int> DecodeLastRuneInString(std::string s)
    {
        gocpp::rune r;
        int size;
        auto end = len(s);
        if(end == 0)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 0};
        }
        auto start = end - 1;
        r = rune(s[start]);
        if(r < RuneSelf)
        {
            gocpp::rune r;
            int size;
            return {r, 1};
        }
        auto lim = end - UTFMax;
        if(lim < 0)
        {
            gocpp::rune r;
            int size;
            lim = 0;
        }
        for(start--; start >= lim; start--)
        {
            gocpp::rune r;
            int size;
            if(RuneStart(s[start]))
            {
                gocpp::rune r;
                int size;
                break;
            }
        }
        if(start < 0)
        {
            gocpp::rune r;
            int size;
            start = 0;
        }
        std::tie(r, size) = DecodeRuneInString(s.make_slice(start, end));
        if(start + size != end)
        {
            gocpp::rune r;
            int size;
            return {RuneError, 1};
        }
        return {r, size};
    }

    int RuneLen(gocpp::rune r)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(r < 0) { conditionId = 0; }
            else if(r <= rune1Max) { conditionId = 1; }
            else if(r <= rune2Max) { conditionId = 2; }
            else if(surrogateMin <= r && r <= surrogateMax) { conditionId = 3; }
            else if(r <= rune3Max) { conditionId = 4; }
            else if(r <= MaxRune) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                    return - 1;
                    break;
                case 1:
                    return 1;
                    break;
                case 2:
                    return 2;
                    break;
                case 3:
                    return - 1;
                    break;
                case 4:
                    return 3;
                    break;
                case 5:
                    return 4;
                    break;
            }
        }
        return - 1;
    }

    int EncodeRune(gocpp::slice<unsigned char> p, gocpp::rune r)
    {
        //Go switch emulation
        {
            auto i = uint32_t(r);
            int conditionId = -1;
            if(i <= rune1Max) { conditionId = 0; }
            else if(i <= rune2Max) { conditionId = 1; }
            else if(i > MaxRune) { conditionId = 2; }
            else if(surrogateMin <= i && i <= surrogateMax) { conditionId = 3; }
            else if(i <= rune3Max) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    p[0] = byte(r);
                    return 1;
                    break;
                case 1:
                    _ = p[1];
                    p[0] = t2 | byte(r >> 6);
                    p[1] = tx | byte(r) & maskx;
                    return 2;
                    break;
                case 2:
                case 3:
                    r = RuneError;
                case 4:
                    _ = p[2];
                    p[0] = t3 | byte(r >> 12);
                    p[1] = tx | byte(r >> 6) & maskx;
                    p[2] = tx | byte(r) & maskx;
                    return 3;
                    break;
                default:
                    _ = p[3];
                    p[0] = t4 | byte(r >> 18);
                    p[1] = tx | byte(r >> 12) & maskx;
                    p[2] = tx | byte(r >> 6) & maskx;
                    p[3] = tx | byte(r) & maskx;
                    return 4;
                    break;
            }
        }
    }

    gocpp::slice<unsigned char> AppendRune(gocpp::slice<unsigned char> p, gocpp::rune r)
    {
        if(uint32_t(r) <= rune1Max)
        {
            return append(p, byte(r));
        }
        return appendRuneNonASCII(p, r);
    }

    gocpp::slice<unsigned char> appendRuneNonASCII(gocpp::slice<unsigned char> p, gocpp::rune r)
    {
        //Go switch emulation
        {
            auto i = uint32_t(r);
            int conditionId = -1;
            if(i <= rune2Max) { conditionId = 0; }
            else if(i > MaxRune) { conditionId = 1; }
            else if(surrogateMin <= i && i <= surrogateMax) { conditionId = 2; }
            else if(i <= rune3Max) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return append(p, t2 | byte(r >> 6), tx | byte(r) & maskx);
                    break;
                case 1:
                case 2:
                    r = RuneError;
                case 3:
                    return append(p, t3 | byte(r >> 12), tx | byte(r >> 6) & maskx, tx | byte(r) & maskx);
                    break;
                default:
                    return append(p, t4 | byte(r >> 18), tx | byte(r >> 12) & maskx, tx | byte(r >> 6) & maskx, tx | byte(r) & maskx);
                    break;
            }
        }
    }

    int RuneCount(gocpp::slice<unsigned char> p)
    {
        auto np = len(p);
        int n = {};
        for(auto i = 0; i < np; )
        {
            n++;
            auto c = p[i];
            if(c < RuneSelf)
            {
                i++;
                continue;
            }
            auto x = first[c];
            if(x == xx)
            {
                i++;
                continue;
            }
            auto size = int(x & 7);
            if(i + size > np)
            {
                i++;
                continue;
            }
            auto accept = acceptRanges[x >> 4];
            if(auto c = p[i + 1]; c < accept.lo || accept.hi < c)
            {
                size = 1;
            }
            else
            if(size == 2)
            {
            }
            else
            if(auto c = p[i + 2]; c < locb || hicb < c)
            {
                size = 1;
            }
            else
            if(size == 3)
            {
            }
            else
            if(auto c = p[i + 3]; c < locb || hicb < c)
            {
                size = 1;
            }
            i += size;
        }
        return n;
    }

    int RuneCountInString(std::string s)
    {
        int n;
        auto ns = len(s);
        for(auto i = 0; i < ns; n++)
        {
            int n;
            auto c = s[i];
            if(c < RuneSelf)
            {
                int n;
                i++;
                continue;
            }
            auto x = first[c];
            if(x == xx)
            {
                int n;
                i++;
                continue;
            }
            auto size = int(x & 7);
            if(i + size > ns)
            {
                int n;
                i++;
                continue;
            }
            auto accept = acceptRanges[x >> 4];
            if(auto c = s[i + 1]; c < accept.lo || accept.hi < c)
            {
                int n;
                size = 1;
            }
            else
            if(size == 2)
            {
                int n;
            }
            else
            if(auto c = s[i + 2]; c < locb || hicb < c)
            {
                int n;
                size = 1;
            }
            else
            if(size == 3)
            {
                int n;
            }
            else
            if(auto c = s[i + 3]; c < locb || hicb < c)
            {
                int n;
                size = 1;
            }
            i += size;
        }
        return n;
    }

    bool RuneStart(unsigned char b)
    {
        return b & 0xC0 != 0x80;
    }

    bool Valid(gocpp::slice<unsigned char> p)
    {
        p = p.make_slice(, len(p), len(p));
        for(; len(p) >= 8; )
        {
            auto first32 = uint32_t(p[0]) | (uint32_t(p[1]) << 8) | (uint32_t(p[2]) << 16) | (uint32_t(p[3]) << 24);
            auto second32 = uint32_t(p[4]) | (uint32_t(p[5]) << 8) | (uint32_t(p[6]) << 16) | (uint32_t(p[7]) << 24);
            if((first32 | second32) & 0x80808080 != 0)
            {
                break;
            }
            p = p.make_slice(8);
        }
        auto n = len(p);
        for(auto i = 0; i < n; )
        {
            auto pi = p[i];
            if(pi < RuneSelf)
            {
                i++;
                continue;
            }
            auto x = first[pi];
            if(x == xx)
            {
                return false;
            }
            auto size = int(x & 7);
            if(i + size > n)
            {
                return false;
            }
            auto accept = acceptRanges[x >> 4];
            if(auto c = p[i + 1]; c < accept.lo || accept.hi < c)
            {
                return false;
            }
            else
            if(size == 2)
            {
            }
            else
            if(auto c = p[i + 2]; c < locb || hicb < c)
            {
                return false;
            }
            else
            if(size == 3)
            {
            }
            else
            if(auto c = p[i + 3]; c < locb || hicb < c)
            {
                return false;
            }
            i += size;
        }
        return true;
    }

    bool ValidString(std::string s)
    {
        for(; len(s) >= 8; )
        {
            auto first32 = uint32_t(s[0]) | (uint32_t(s[1]) << 8) | (uint32_t(s[2]) << 16) | (uint32_t(s[3]) << 24);
            auto second32 = uint32_t(s[4]) | (uint32_t(s[5]) << 8) | (uint32_t(s[6]) << 16) | (uint32_t(s[7]) << 24);
            if((first32 | second32) & 0x80808080 != 0)
            {
                break;
            }
            s = s.make_slice(8);
        }
        auto n = len(s);
        for(auto i = 0; i < n; )
        {
            auto si = s[i];
            if(si < RuneSelf)
            {
                i++;
                continue;
            }
            auto x = first[si];
            if(x == xx)
            {
                return false;
            }
            auto size = int(x & 7);
            if(i + size > n)
            {
                return false;
            }
            auto accept = acceptRanges[x >> 4];
            if(auto c = s[i + 1]; c < accept.lo || accept.hi < c)
            {
                return false;
            }
            else
            if(size == 2)
            {
            }
            else
            if(auto c = s[i + 2]; c < locb || hicb < c)
            {
                return false;
            }
            else
            if(size == 3)
            {
            }
            else
            if(auto c = s[i + 3]; c < locb || hicb < c)
            {
                return false;
            }
            i += size;
        }
        return true;
    }

    bool ValidRune(gocpp::rune r)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(0 <= r && r < surrogateMin) { conditionId = 0; }
            else if(surrogateMax < r && r <= MaxRune) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return true;
                    break;
                case 1:
                    return true;
                    break;
            }
        }
        return false;
    }

}

