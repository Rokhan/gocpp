// generated by GoCpp from file '$(ImportDir)/runtime/rand.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/rand.h"
#include "gocpp/support.h"

#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/zgoarch_amd64.h"
#include "golang/runtime/internal/math/math.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    gocpp::slice<unsigned char> startupRand;
    struct gocpp_id_0
    {
        mutex lock;
        gocpp::array<unsigned char, 32> seed;
        chacha8rand::State state;
        bool init;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << seed;
            os << " " << state;
            os << " " << init;
            os << '}';
            return os;
        }
    };
    gocpp_id_0 globalRand;
    bool readRandomFailed;
    void randinit()
    {
        lock(& globalRand.lock);
        if(globalRand.init)
        {
            fatal("randinit twice");
        }
        auto seed = & globalRand.seed;
        if(startupRand != nullptr)
        {
            for(auto [i, c] : startupRand)
            {
                seed[i % len(seed)] ^= c;
            }
            clear(startupRand);
            startupRand = nullptr;
        }
        else
        {
            if(readRandom(seed.make_slice(0, )) != len(seed))
            {
                readRandomFailed = true;
                readTimeRandom(seed.make_slice(0, ));
            }
        }
        Init(gocpp::recv(globalRand.state), *seed);
        clear(seed.make_slice(0, ));
        globalRand.init = true;
        unlock(& globalRand.lock);
    }

    void readTimeRandom(gocpp::slice<unsigned char> r)
    {
        auto v = uint64_t(nanotime());
        for(; len(r) > 0; )
        {
            v ^= 0xa0761d6478bd642f;
            v *= 0xe7037ed1a0b428db;
            auto size = 8;
            if(len(r) < 8)
            {
                size = len(r);
            }
            for(auto i = 0; i < size; i++)
            {
                r[i] ^= byte(v >> (8 * i));
            }
            r = r.make_slice(size);
            v = (v >> 32) | (v << 32);
        }
    }

    uint64_t bootstrapRand()
    {
        lock(& globalRand.lock);
        if(! globalRand.init)
        {
            fatal("randinit missed");
        }
        for(; ; )
        {
            if(auto [x, ok] = Next(gocpp::recv(globalRand.state)); ok)
            {
                unlock(& globalRand.lock);
                return x;
            }
            Refill(gocpp::recv(globalRand.state));
        }
    }

    void bootstrapRandReseed()
    {
        lock(& globalRand.lock);
        if(! globalRand.init)
        {
            fatal("randinit missed");
        }
        Reseed(gocpp::recv(globalRand.state));
        unlock(& globalRand.lock);
    }

    uint32_t rand32()
    {
        return uint32_t(rand());
    }

    uint64_t rand()
    {
        auto mp = getg()->m;
        auto c = & mp->chacha8;
        for(; ; )
        {
            auto [x, ok] = Next(gocpp::recv(c));
            if(ok)
            {
                return x;
            }
            mp->locks++;
            Refill(gocpp::recv(c));
            mp->locks--;
        }
    }

    void mrandinit(m* mp)
    {
        gocpp::array<uint64_t, 4> seed = {};
        for(auto [i, gocpp_ignored] : seed)
        {
            seed[i] = bootstrapRand();
        }
        bootstrapRandReseed();
        Init64(gocpp::recv(mp->chacha8), seed);
        mp->cheaprand = rand();
    }

    uint32_t randn(uint32_t n)
    {
        return uint32_t((uint64_t(uint32_t(rand())) * uint64_t(n)) >> 32);
    }

    uint32_t cheaprand()
    {
        auto mp = getg()->m;
        if(goarch.IsAmd64 | goarch.IsArm64 | goarch.IsPpc64 | goarch.IsPpc64le | goarch.IsMips64 | goarch.IsMips64le | goarch.IsS390x | goarch.IsRiscv64 | goarch.IsLoong64 == 1)
        {
            mp->cheaprand += 0xa0761d6478bd642f;
            auto [hi, lo] = math::Mul64(mp->cheaprand, mp->cheaprand ^ 0xe7037ed1a0b428db);
            return uint32_t(hi ^ lo);
        }
        auto t = (*gocpp::Tag<gocpp::array<uint32_t, 2>>())(Pointer(gocpp::recv(unsafe), & mp->cheaprand));
        auto [s1, s0] = std::tuple{t[0], t[1]};
        s1 ^= s1 << 17;
        s1 = s1 ^ s0 ^ (s1 >> 7) ^ (s0 >> 16);
        std::tie(t[0], t[1]) = std::tuple{s0, s1};
        return s0 + s1;
    }

    int64_t cheaprand64()
    {
        return (int64(cheaprand()) << 31) ^ int64(cheaprand());
    }

    uint32_t cheaprandn(uint32_t n)
    {
        return uint32_t((uint64_t(cheaprand()) * uint64_t(n)) >> 32);
    }

    uint32_t legacy_fastrand()
    {
        return uint32_t(rand());
    }

    uint32_t legacy_fastrandn(uint32_t n)
    {
        return randn(n);
    }

    uint64_t legacy_fastrand64()
    {
        return rand();
    }

}

