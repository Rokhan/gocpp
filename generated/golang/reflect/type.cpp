// generated by GoCpp from file '$(ImportDir)/reflect/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/type.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/map.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/reflect/abi.h"
// #include "golang/reflect/value.h"  [Ignored, known errors]
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"
#include "golang/sync/atomic/type.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/utf8/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace goarch::rec;
        using namespace reflect::rec;
        using namespace strconv::rec;
        using namespace sync::rec;
        using namespace unicode::rec;
        using namespace unsafe::rec;
        using namespace utf8::rec;
    }

    
    template<typename T>
    Type::Type(T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(const T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(T* ptr)
    {
        value.reset(new TypeImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Type::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vAlign()
    {
        return rec::Align(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vFieldAlign()
    {
        return rec::FieldAlign(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Method Type::TypeImpl<T, StoreT>::vMethod(int)
    {
        return rec::Method(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<struct Method, bool> Type::TypeImpl<T, StoreT>::vMethodByName(std::string)
    {
        return rec::MethodByName(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumMethod()
    {
        return rec::NumMethod(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vPkgPath()
    {
        return rec::PkgPath(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uintptr_t Type::TypeImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    reflect::Kind Type::TypeImpl<T, StoreT>::vKind()
    {
        return rec::Kind(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vImplements(struct Type u)
    {
        return rec::Implements(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vAssignableTo(struct Type u)
    {
        return rec::AssignableTo(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vConvertibleTo(struct Type u)
    {
        return rec::ConvertibleTo(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vComparable()
    {
        return rec::Comparable(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vBits()
    {
        return rec::Bits(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    reflect::ChanDir Type::TypeImpl<T, StoreT>::vChanDir()
    {
        return rec::ChanDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vIsVariadic()
    {
        return rec::IsVariadic(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vElem()
    {
        return rec::Elem(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct StructField Type::TypeImpl<T, StoreT>::vField(int i)
    {
        return rec::Field(gocpp::PtrRecv<T, false>(value.get()), i);
    }
    template<typename T, typename StoreT>
    struct StructField Type::TypeImpl<T, StoreT>::vFieldByIndex(gocpp::slice<int> index)
    {
        return rec::FieldByIndex(gocpp::PtrRecv<T, false>(value.get()), index);
    }
    template<typename T, typename StoreT>
    std::tuple<struct StructField, bool> Type::TypeImpl<T, StoreT>::vFieldByName(std::string name)
    {
        return rec::FieldByName(gocpp::PtrRecv<T, false>(value.get()), name);
    }
    template<typename T, typename StoreT>
    std::tuple<struct StructField, bool> Type::TypeImpl<T, StoreT>::vFieldByNameFunc(std::function<bool (std::string)> match)
    {
        return rec::FieldByNameFunc(gocpp::PtrRecv<T, false>(value.get()), match);
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vIn(int i)
    {
        return rec::In(gocpp::PtrRecv<T, false>(value.get()), i);
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vKey()
    {
        return rec::Key(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vLen()
    {
        return rec::Len(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumField()
    {
        return rec::NumField(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumIn()
    {
        return rec::NumIn(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumOut()
    {
        return rec::NumOut(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vOut(int i)
    {
        return rec::Out(gocpp::PtrRecv<T, false>(value.get()), i);
    }
    template<typename T, typename StoreT>
    struct abi::Type* Type::TypeImpl<T, StoreT>::vcommon()
    {
        return rec::common(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct uncommonType* Type::TypeImpl<T, StoreT>::vuncommon()
    {
        return rec::uncommon(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        int Align(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vAlign();
        }

        int Align(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vAlign();
        }

        int FieldAlign(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vFieldAlign();
        }

        int FieldAlign(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vFieldAlign();
        }

        struct Method Method(const gocpp::PtrRecv<Type, false>& self, int)
        {
            return self.ptr->value->vMethod();
        }

        struct Method Method(const gocpp::ObjRecv<Type>& self, int)
        {
            return self.obj.value->vMethod();
        }

        std::tuple<struct Method, bool> MethodByName(const gocpp::PtrRecv<Type, false>& self, std::string)
        {
            return self.ptr->value->vMethodByName();
        }

        std::tuple<struct Method, bool> MethodByName(const gocpp::ObjRecv<Type>& self, std::string)
        {
            return self.obj.value->vMethodByName();
        }

        int NumMethod(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vNumMethod();
        }

        int NumMethod(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vNumMethod();
        }

        std::string Name(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vName();
        }

        std::string Name(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vName();
        }

        std::string PkgPath(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vPkgPath();
        }

        std::string PkgPath(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vPkgPath();
        }

        uintptr_t Size(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vSize();
        }

        uintptr_t Size(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vSize();
        }

        std::string String(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vString();
        }

        reflect::Kind Kind(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vKind();
        }

        reflect::Kind Kind(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vKind();
        }

        bool Implements(const gocpp::PtrRecv<Type, false>& self, struct Type u)
        {
            return self.ptr->value->vImplements(u);
        }

        bool Implements(const gocpp::ObjRecv<Type>& self, struct Type u)
        {
            return self.obj.value->vImplements(u);
        }

        bool AssignableTo(const gocpp::PtrRecv<Type, false>& self, struct Type u)
        {
            return self.ptr->value->vAssignableTo(u);
        }

        bool AssignableTo(const gocpp::ObjRecv<Type>& self, struct Type u)
        {
            return self.obj.value->vAssignableTo(u);
        }

        bool ConvertibleTo(const gocpp::PtrRecv<Type, false>& self, struct Type u)
        {
            return self.ptr->value->vConvertibleTo(u);
        }

        bool ConvertibleTo(const gocpp::ObjRecv<Type>& self, struct Type u)
        {
            return self.obj.value->vConvertibleTo(u);
        }

        bool Comparable(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vComparable();
        }

        bool Comparable(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vComparable();
        }

        int Bits(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vBits();
        }

        int Bits(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vBits();
        }

        reflect::ChanDir ChanDir(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vChanDir();
        }

        reflect::ChanDir ChanDir(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vChanDir();
        }

        bool IsVariadic(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vIsVariadic();
        }

        bool IsVariadic(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vIsVariadic();
        }

        struct Type Elem(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vElem();
        }

        struct Type Elem(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vElem();
        }

        struct StructField Field(const gocpp::PtrRecv<Type, false>& self, int i)
        {
            return self.ptr->value->vField(i);
        }

        struct StructField Field(const gocpp::ObjRecv<Type>& self, int i)
        {
            return self.obj.value->vField(i);
        }

        struct StructField FieldByIndex(const gocpp::PtrRecv<Type, false>& self, gocpp::slice<int> index)
        {
            return self.ptr->value->vFieldByIndex(index);
        }

        struct StructField FieldByIndex(const gocpp::ObjRecv<Type>& self, gocpp::slice<int> index)
        {
            return self.obj.value->vFieldByIndex(index);
        }

        std::tuple<struct StructField, bool> FieldByName(const gocpp::PtrRecv<Type, false>& self, std::string name)
        {
            return self.ptr->value->vFieldByName(name);
        }

        std::tuple<struct StructField, bool> FieldByName(const gocpp::ObjRecv<Type>& self, std::string name)
        {
            return self.obj.value->vFieldByName(name);
        }

        std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::PtrRecv<Type, false>& self, std::function<bool (std::string)> match)
        {
            return self.ptr->value->vFieldByNameFunc(match);
        }

        std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::ObjRecv<Type>& self, std::function<bool (std::string)> match)
        {
            return self.obj.value->vFieldByNameFunc(match);
        }

        struct Type In(const gocpp::PtrRecv<Type, false>& self, int i)
        {
            return self.ptr->value->vIn(i);
        }

        struct Type In(const gocpp::ObjRecv<Type>& self, int i)
        {
            return self.obj.value->vIn(i);
        }

        struct Type Key(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vKey();
        }

        struct Type Key(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vKey();
        }

        int Len(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vLen();
        }

        int Len(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vLen();
        }

        int NumField(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vNumField();
        }

        int NumField(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vNumField();
        }

        int NumIn(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vNumIn();
        }

        int NumIn(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vNumIn();
        }

        int NumOut(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vNumOut();
        }

        int NumOut(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vNumOut();
        }

        struct Type Out(const gocpp::PtrRecv<Type, false>& self, int i)
        {
            return self.ptr->value->vOut(i);
        }

        struct Type Out(const gocpp::ObjRecv<Type>& self, int i)
        {
            return self.obj.value->vOut(i);
        }

        struct abi::Type* common(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vcommon();
        }

        struct abi::Type* common(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vcommon();
        }

        struct uncommonType* uncommon(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vuncommon();
        }

        struct uncommonType* uncommon(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vuncommon();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    common::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool common::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& common::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct common& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    rtype::operator T()
    {
        T result;
        result.t = this->t;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool rtype::operator==(const T& ref) const
    {
        if (t != ref.t) return false;
        return true;
    }

    std::ostream& rtype::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << t;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rtype& value)
    {
        return value.PrintTo(os);
    }

    struct abi::Type* rec::common(struct rtype* t)
    {
        return & t->t;
    }

    struct abi::UncommonType* rec::uncommon(struct rtype* t)
    {
        return rec::Uncommon(gocpp::recv(t->t));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    interfaceType::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool interfaceType::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& interfaceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct interfaceType& value)
    {
        return value.PrintTo(os);
    }

    struct abi::Name rec::nameOff(struct interfaceType* t, abi::aNameOff off)
    {
        return rec::nameOff(gocpp::recv(toRType(& t->Type)), off);
    }

    struct abi::Name nameOffFor(struct abi::Type* t, abi::aNameOff off)
    {
        return rec::nameOff(gocpp::recv(toRType(t)), off);
    }

    struct abi::Type* typeOffFor(struct abi::Type* t, abi::aTypeOff off)
    {
        return rec::typeOff(gocpp::recv(toRType(t)), off);
    }

    struct abi::Type* rec::typeOff(struct interfaceType* t, abi::aTypeOff off)
    {
        return rec::typeOff(gocpp::recv(toRType(& t->Type)), off);
    }

    struct abi::Type* rec::common(struct interfaceType* t)
    {
        return & t->Type;
    }

    struct abi::UncommonType* rec::uncommon(struct interfaceType* t)
    {
        return rec::Uncommon(gocpp::recv(t));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mapType::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mapType::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& mapType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mapType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ptrType::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ptrType::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& ptrType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ptrType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    sliceType::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sliceType::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& sliceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sliceType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    structType::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool structType::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& structType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structType& value)
    {
        return value.PrintTo(os);
    }

    std::string pkgPath(struct abi::Name n)
    {
        if(n->Bytes == nullptr || *rec::DataChecked(gocpp::recv(n), 0, "name flag field") & (1 << 2) == 0)
        {
            return "";
        }
        auto [i, l] = rec::ReadVarint(gocpp::recv(n), 1);
        auto off = 1 + i + l;
        if(rec::HasTag(gocpp::recv(n)))
        {
            auto [i2, l2] = rec::ReadVarint(gocpp::recv(n), off);
            off += i2 + l2;
        }
        int32_t nameOff = {};
        copy((gocpp::array<unsigned char, 4>*)(unsafe::Pointer(& nameOff)).make_slice(0, ), (gocpp::array<unsigned char, 4>*)(unsafe::Pointer(rec::DataChecked(gocpp::recv(n), off, "name offset field"))).make_slice(0, ));
        auto pkgPathName = gocpp::Init<abi::Name>([](abi::Name& x) { x.Bytes = (unsigned char*)(resolveTypeOff(unsafe::Pointer(n->Bytes), nameOff)); });
        return rec::Name(gocpp::recv(pkgPathName));
    }

    struct abi::Name newName(std::string n, std::string tag, bool exported, bool embedded)
    {
        return abi::NewName(n, tag, exported, embedded);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Method::operator T()
    {
        T result;
        result.Name = this->Name;
        result.PkgPath = this->PkgPath;
        result.Type = this->Type;
        result.Func = this->Func;
        result.Index = this->Index;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Method::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (PkgPath != ref.PkgPath) return false;
        if (Type != ref.Type) return false;
        if (Func != ref.Func) return false;
        if (Index != ref.Index) return false;
        return true;
    }

    std::ostream& Method::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << PkgPath;
        os << " " << Type;
        os << " " << Func;
        os << " " << Index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Method& value)
    {
        return value.PrintTo(os);
    }

    bool rec::IsExported(struct Method m)
    {
        return m.PkgPath == "";
    }

    std::string rec::String(reflect::Kind k)
    {
        if((unsigned int)(k) < (unsigned int)(len(kindNames)))
        {
            return kindNames[(unsigned int)(k)];
        }
        return "kind" + strconv::Itoa(int(k));
    }

    gocpp::slice<std::string> kindNames = gocpp::Init<gocpp::slice<std::string>>([](gocpp::slice<std::string>& x) { x.Invalid = "invalid"; x.Bool = "bool"; x.Int = "int"; x.Int8 = "int8"; x.Int16 = "int16"; x.Int32 = "int32"; x.Int64 = "int64"; x.Uint = "uint"; x.Uint8 = "uint8"; x.Uint16 = "uint16"; x.Uint32 = "uint32"; x.Uint64 = "uint64"; x.Uintptr = "uintptr"; x.Float32 = "float32"; x.Float64 = "float64"; x.Complex64 = "complex64"; x.Complex128 = "complex128"; x.Array = "array"; x.Chan = "chan"; x.Func = "func"; x.Interface = "interface"; x.Map = "map"; x.Pointer = "ptr"; x.Slice = "slice"; x.String = "string"; x.Struct = "struct"; x.UnsafePointer = "unsafe.Pointer"; });
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer resolveTextOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    int32_t addReflectOff(unsafe::Pointer ptr)
    /* convertBlockStmt, nil block */;

    abi::aNameOff resolveReflectName(struct abi::Name n)
    {
        return aNameOff(addReflectOff(unsafe::Pointer(n->Bytes)));
    }

    abi::aTypeOff resolveReflectType(struct abi::Type* t)
    {
        return aTypeOff(addReflectOff(unsafe::Pointer(t)));
    }

    abi::aTextOff resolveReflectText(unsafe::Pointer ptr)
    {
        return aTextOff(addReflectOff(ptr));
    }

    struct abi::Name rec::nameOff(struct rtype* t, abi::aNameOff off)
    {
        return gocpp::Init<abi::Name>([](abi::Name& x) { x.Bytes = (unsigned char*)(resolveNameOff(unsafe::Pointer(t), int32_t(off))); });
    }

    struct abi::Type* rec::typeOff(struct rtype* t, abi::aTypeOff off)
    {
        return (abi::Type*)(resolveTypeOff(unsafe::Pointer(t), int32_t(off)));
    }

    unsafe::Pointer rec::textOff(struct rtype* t, abi::aTextOff off)
    {
        return resolveTextOff(unsafe::Pointer(t), int32_t(off));
    }

    unsafe::Pointer textOffFor(struct abi::Type* t, abi::aTextOff off)
    {
        return rec::textOff(gocpp::recv(toRType(t)), off);
    }

    std::string rec::String(struct rtype* t)
    {
        auto s = rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), t->t.Str)));
        if(t->t.TFlag & abi::TFlagExtraStar != 0)
        {
            return s.make_slice(1);
        }
        return s;
    }

    uintptr_t rec::Size(struct rtype* t)
    {
        return rec::Size(gocpp::recv(t->t));
    }

    int rec::Bits(struct rtype* t)
    {
        if(t == nullptr)
        {
            gocpp::panic("reflect: Bits of nil Type");
        }
        auto k = rec::Kind(gocpp::recv(t));
        if(k < Int || k > Complex128)
        {
            gocpp::panic("reflect: Bits of non-arithmetic Type " + rec::String(gocpp::recv(t)));
        }
        return int(t->t.Size_) * 8;
    }

    int rec::Align(struct rtype* t)
    {
        return rec::Align(gocpp::recv(t->t));
    }

    int rec::FieldAlign(struct rtype* t)
    {
        return rec::FieldAlign(gocpp::recv(t->t));
    }

    reflect::Kind rec::Kind(struct rtype* t)
    {
        return Kind(rec::Kind(gocpp::recv(t->t)));
    }

    gocpp::slice<abi::Method> rec::exportedMethods(struct rtype* t)
    {
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return nullptr;
        }
        return rec::ExportedMethods(gocpp::recv(ut));
    }

    int rec::NumMethod(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return rec::NumMethod(gocpp::recv(tt));
        }
        return len(rec::exportedMethods(gocpp::recv(t)));
    }

    struct Method rec::Method(struct rtype* t, int i)
    {
        struct Method m;
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            struct Method m;
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return rec::Method(gocpp::recv(tt), i);
        }
        auto methods = rec::exportedMethods(gocpp::recv(t));
        if(i < 0 || i >= len(methods))
        {
            struct Method m;
            gocpp::panic("reflect: Method index out of range");
        }
        auto p = methods[i];
        auto pname = rec::nameOff(gocpp::recv(t), p.Name);
        m.Name = rec::Name(gocpp::recv(pname));
        auto fl = flag(Func);
        auto mtyp = rec::typeOff(gocpp::recv(t), p.Mtyp);
        auto ft = (funcType*)(unsafe::Pointer(mtyp));
        auto in = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), 0, 1 + rec::NumIn(gocpp::recv(ft)));
        in = append(in, t);
        for(auto [gocpp_ignored, arg] : rec::InSlice(gocpp::recv(ft)))
        {
            struct Method m;
            in = append(in, toRType(arg));
        }
        auto out = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), 0, rec::NumOut(gocpp::recv(ft)));
        for(auto [gocpp_ignored, ret] : rec::OutSlice(gocpp::recv(ft)))
        {
            struct Method m;
            out = append(out, toRType(ret));
        }
        auto mt = FuncOf(in, out, rec::IsVariadic(gocpp::recv(ft)));
        m.Type = mt;
        auto tfn = rec::textOff(gocpp::recv(t), p.Tfn);
        auto fn = unsafe::Pointer(& tfn);
        m.Func = Value {& gocpp::getValue<rtype*>(mt)->t, fn, fl};
        m.Index = i;
        return m;
    }

    std::tuple<struct Method, bool> rec::MethodByName(struct rtype* t, std::string name)
    {
        struct Method m;
        bool ok;
        if(rec::Kind(gocpp::recv(t)) == Interface)
        {
            struct Method m;
            bool ok;
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return rec::MethodByName(gocpp::recv(tt), name);
        }
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            struct Method m;
            bool ok;
            return {Method {}, false};
        }
        auto methods = rec::ExportedMethods(gocpp::recv(ut));
        auto [i, j] = std::tuple{0, len(methods)};
        for(; i < j; )
        {
            struct Method m;
            bool ok;
            auto h = int((unsigned int)(i + j) >> 1);
            if(! (rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), methods[h].Name))) >= name))
            {
                struct Method m;
                bool ok;
                i = h + 1;
            }
            else
            {
                struct Method m;
                bool ok;
                j = h;
            }
        }
        if(i < len(methods) && name == rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), methods[i].Name))))
        {
            struct Method m;
            bool ok;
            return {rec::Method(gocpp::recv(t), i), true};
        }
        return {Method {}, false};
    }

    std::string rec::PkgPath(struct rtype* t)
    {
        if(t->t.TFlag & abi::TFlagNamed == 0)
        {
            return "";
        }
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return "";
        }
        return rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), ut->PkgPath)));
    }

    std::string pkgPathFor(struct abi::Type* t)
    {
        return rec::PkgPath(gocpp::recv(toRType(t)));
    }

    std::string rec::Name(struct rtype* t)
    {
        if(! rec::HasName(gocpp::recv(t->t)))
        {
            return "";
        }
        auto s = rec::String(gocpp::recv(t));
        auto i = len(s) - 1;
        auto sqBrackets = 0;
        for(; i >= 0 && (s[i] != '.' || sqBrackets != 0); )
        {
            //Go switch emulation
            {
                auto condition = s[i];
                int conditionId = -1;
                if(condition == ']') { conditionId = 0; }
                else if(condition == '[') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        sqBrackets++;
                        break;
                    case 1:
                        sqBrackets--;
                        break;
                }
            }
            i--;
        }
        return s.make_slice(i + 1);
    }

    std::string nameFor(struct abi::Type* t)
    {
        return rec::Name(gocpp::recv(toRType(t)));
    }

    reflect::ChanDir rec::ChanDir(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Chan)
        {
            gocpp::panic("reflect: ChanDir of non-chan type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::ChanType*)(unsafe::Pointer(t));
        return ChanDir(tt->Dir);
    }

    struct rtype* toRType(struct abi::Type* t)
    {
        return (rtype*)(unsafe::Pointer(t));
    }

    struct abi::Type* elem(struct abi::Type* t)
    {
        auto et = rec::Elem(gocpp::recv(t));
        if(et != nullptr)
        {
            return et;
        }
        gocpp::panic("reflect: Elem of invalid type " + stringFor(t));
    }

    struct Type rec::Elem(struct rtype* t)
    {
        return toType(elem(rec::common(gocpp::recv(t))));
    }

    struct StructField rec::Field(struct rtype* t, int i)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: Field of non-struct type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::Field(gocpp::recv(tt), i);
    }

    struct StructField rec::FieldByIndex(struct rtype* t, gocpp::slice<int> index)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByIndex of non-struct type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::FieldByIndex(gocpp::recv(tt), index);
    }

    std::tuple<struct StructField, bool> rec::FieldByName(struct rtype* t, std::string name)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByName of non-struct type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::FieldByName(gocpp::recv(tt), name);
    }

    std::tuple<struct StructField, bool> rec::FieldByNameFunc(struct rtype* t, std::function<bool (std::string)> match)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByNameFunc of non-struct type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return rec::FieldByNameFunc(gocpp::recv(tt), match);
    }

    struct Type rec::Key(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Map)
        {
            gocpp::panic("reflect: Key of non-map type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (mapType*)(unsafe::Pointer(t));
        return toType(tt->Key);
    }

    int rec::Len(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Array)
        {
            gocpp::panic("reflect: Len of non-array type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (arrayType*)(unsafe::Pointer(t));
        return int(tt->Len);
    }

    int rec::NumField(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: NumField of non-struct type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return len(tt->Fields);
    }

    struct Type rec::In(struct rtype* t, int i)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: In of non-func type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return toType(rec::InSlice(gocpp::recv(tt))[i]);
    }

    int rec::NumIn(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: NumIn of non-func type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return rec::NumIn(gocpp::recv(tt));
    }

    int rec::NumOut(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: NumOut of non-func type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return rec::NumOut(gocpp::recv(tt));
    }

    struct Type rec::Out(struct rtype* t, int i)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: Out of non-func type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return toType(rec::OutSlice(gocpp::recv(tt))[i]);
    }

    bool rec::IsVariadic(struct rtype* t)
    {
        if(rec::Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: IsVariadic of non-func type " + rec::String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return rec::IsVariadic(gocpp::recv(tt));
    }

    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    std::string rec::String(reflect::ChanDir d)
    {
        //Go switch emulation
        {
            auto condition = d;
            int conditionId = -1;
            if(condition == SendDir) { conditionId = 0; }
            else if(condition == RecvDir) { conditionId = 1; }
            else if(condition == BothDir) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return "chan<-";
                    break;
                case 1:
                    return "<-chan";
                    break;
                case 2:
                    return "chan";
                    break;
            }
        }
        return "ChanDir" + strconv::Itoa(int(d));
    }

    struct Method rec::Method(struct interfaceType* t, int i)
    {
        struct Method m;
        if(i < 0 || i >= len(t->Methods))
        {
            struct Method m;
            return m;
        }
        auto p = & t->Methods[i];
        auto pname = rec::nameOff(gocpp::recv(t), p->Name);
        m.Name = rec::Name(gocpp::recv(pname));
        if(! rec::IsExported(gocpp::recv(pname)))
        {
            struct Method m;
            m.PkgPath = pkgPath(pname);
            if(m.PkgPath == "")
            {
                struct Method m;
                m.PkgPath = rec::Name(gocpp::recv(t->PkgPath));
            }
        }
        m.Type = toType(rec::typeOff(gocpp::recv(t), p->Typ));
        m.Index = i;
        return m;
    }

    int rec::NumMethod(struct interfaceType* t)
    {
        return len(t->Methods);
    }

    std::tuple<struct Method, bool> rec::MethodByName(struct interfaceType* t, std::string name)
    {
        struct Method m;
        bool ok;
        if(t == nullptr)
        {
            struct Method m;
            bool ok;
            return {m, ok};
        }
        abi::Imethod* p = {};
        for(auto [i, gocpp_ignored] : t->Methods)
        {
            struct Method m;
            bool ok;
            p = & t->Methods[i];
            if(rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), p->Name))) == name)
            {
                struct Method m;
                bool ok;
                return {rec::Method(gocpp::recv(t), i), true};
            }
        }
        return {m, ok};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    StructField::operator T()
    {
        T result;
        result.Name = this->Name;
        result.PkgPath = this->PkgPath;
        result.Type = this->Type;
        result.Tag = this->Tag;
        result.Offset = this->Offset;
        result.Index = this->Index;
        result.Anonymous = this->Anonymous;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StructField::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (PkgPath != ref.PkgPath) return false;
        if (Type != ref.Type) return false;
        if (Tag != ref.Tag) return false;
        if (Offset != ref.Offset) return false;
        if (Index != ref.Index) return false;
        if (Anonymous != ref.Anonymous) return false;
        return true;
    }

    std::ostream& StructField::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << PkgPath;
        os << " " << Type;
        os << " " << Tag;
        os << " " << Offset;
        os << " " << Index;
        os << " " << Anonymous;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructField& value)
    {
        return value.PrintTo(os);
    }

    bool rec::IsExported(struct StructField f)
    {
        return f.PkgPath == "";
    }

    std::string rec::Get(reflect::StructTag tag, std::string key)
    {
        auto [v, gocpp_id_1] = rec::Lookup(gocpp::recv(tag), key);
        return v;
    }

    std::tuple<std::string, bool> rec::Lookup(reflect::StructTag tag, std::string key)
    {
        std::string value;
        bool ok;
        for(; tag != ""; )
        {
            std::string value;
            bool ok;
            auto i = 0;
            for(; i < len(tag) && tag[i] == ' '; )
            {
                std::string value;
                bool ok;
                i++;
            }
            tag = tag.make_slice(i);
            if(tag == "")
            {
                std::string value;
                bool ok;
                break;
            }
            i = 0;
            for(; i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '"' && tag[i] != 0x7f; )
            {
                std::string value;
                bool ok;
                i++;
            }
            if(i == 0 || i + 1 >= len(tag) || tag[i] != ':' || tag[i + 1] != '"')
            {
                std::string value;
                bool ok;
                break;
            }
            auto name = string(tag.make_slice(0, i));
            tag = tag.make_slice(i + 1);
            i = 1;
            for(; i < len(tag) && tag[i] != '"'; )
            {
                std::string value;
                bool ok;
                if(tag[i] == '\\')
                {
                    std::string value;
                    bool ok;
                    i++;
                }
                i++;
            }
            if(i >= len(tag))
            {
                std::string value;
                bool ok;
                break;
            }
            auto qvalue = string(tag.make_slice(0, i + 1));
            tag = tag.make_slice(i + 1);
            if(key == name)
            {
                std::string value;
                bool ok;
                auto [value, err] = strconv::Unquote(qvalue);
                if(err != nullptr)
                {
                    std::string value;
                    bool ok;
                    break;
                }
                return {value, true};
            }
        }
        return {"", false};
    }

    struct StructField rec::Field(struct structType* t, int i)
    {
        struct StructField f;
        if(i < 0 || i >= len(t->Fields))
        {
            struct StructField f;
            gocpp::panic("reflect: Field index out of bounds");
        }
        auto p = & t->Fields[i];
        f.Type = toType(p->Typ);
        f.Name = rec::Name(gocpp::recv(p->Name));
        f.Anonymous = rec::Embedded(gocpp::recv(p));
        if(! rec::IsExported(gocpp::recv(p->Name)))
        {
            struct StructField f;
            f.PkgPath = rec::Name(gocpp::recv(t->PkgPath));
        }
        if(auto tag = rec::Tag(gocpp::recv(p->Name)); tag != "")
        {
            struct StructField f;
            f.Tag = StructTag(tag);
        }
        f.Offset = p->Offset;
        f.Index = gocpp::slice<int> {i};
        return f;
    }

    struct StructField rec::FieldByIndex(struct structType* t, gocpp::slice<int> index)
    {
        struct StructField f;
        f.Type = toType(& t->Type);
        for(auto [i, x] : index)
        {
            struct StructField f;
            if(i > 0)
            {
                struct StructField f;
                auto ft = f.Type;
                if(rec::Kind(gocpp::recv(ft)) == Pointer && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(ft)))) == Struct)
                {
                    struct StructField f;
                    ft = rec::Elem(gocpp::recv(ft));
                }
                f.Type = ft;
            }
            f = rec::Field(gocpp::recv(f.Type), x);
        }
        return f;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    fieldScan::operator T()
    {
        T result;
        result.typ = this->typ;
        result.index = this->index;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fieldScan::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (index != ref.index) return false;
        return true;
    }

    std::ostream& fieldScan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fieldScan& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<struct StructField, bool> rec::FieldByNameFunc(struct structType* t, std::function<bool (std::string)> match)
    {
        struct StructField result;
        bool ok;
        auto current = gocpp::slice<fieldScan> {};
        auto next = gocpp::slice<fieldScan> {gocpp::Init<>([](& x) { x.typ = t; })};
        gocpp::map<structType*, int> nextCount = {};
        auto visited = gocpp::map<structType*, bool> {};
        for(; len(next) > 0; )
        {
            struct StructField result;
            bool ok;
            std::tie(current, next) = std::tuple{next, current.make_slice(0, 0)};
            auto count = nextCount;
            nextCount = nullptr;
            for(auto [gocpp_ignored, scan] : current)
            {
                struct StructField result;
                bool ok;
                auto t = scan.typ;
                if(visited[t])
                {
                    struct StructField result;
                    bool ok;
                    continue;
                }
                visited[t] = true;
                for(auto [i, gocpp_ignored] : t->Fields)
                {
                    struct StructField result;
                    bool ok;
                    auto f = & t->Fields[i];
                    auto fname = rec::Name(gocpp::recv(f->Name));
                    abi::Type* ntyp = {};
                    if(rec::Embedded(gocpp::recv(f)))
                    {
                        struct StructField result;
                        bool ok;
                        ntyp = f->Typ;
                        if(rec::Kind(gocpp::recv(ntyp)) == abi::Pointer)
                        {
                            struct StructField result;
                            bool ok;
                            ntyp = rec::Elem(gocpp::recv(ntyp));
                        }
                    }
                    if(match(fname))
                    {
                        struct StructField result;
                        bool ok;
                        if(count[t] > 1 || ok)
                        {
                            struct StructField result;
                            bool ok;
                            return {StructField {}, false};
                        }
                        result = rec::Field(gocpp::recv(t), i);
                        result.Index = nullptr;
                        result.Index = append(result.Index, scan.index);
                        result.Index = append(result.Index, i);
                        ok = true;
                        continue;
                    }
                    if(ok || ntyp == nullptr || rec::Kind(gocpp::recv(ntyp)) != abi::Struct)
                    {
                        struct StructField result;
                        bool ok;
                        continue;
                    }
                    auto styp = (structType*)(unsafe::Pointer(ntyp));
                    if(nextCount[styp] > 0)
                    {
                        struct StructField result;
                        bool ok;
                        nextCount[styp] = 2;
                        continue;
                    }
                    if(nextCount == nullptr)
                    {
                        struct StructField result;
                        bool ok;
                        nextCount = gocpp::map<structType*, int> {};
                    }
                    nextCount[styp] = 1;
                    if(count[t] > 1)
                    {
                        struct StructField result;
                        bool ok;
                        nextCount[styp] = 2;
                    }
                    gocpp::slice<int> index = {};
                    index = append(index, scan.index);
                    index = append(index, i);
                    next = append(next, fieldScan {styp, index});
                }
            }
            if(ok)
            {
                struct StructField result;
                bool ok;
                break;
            }
        }
        return {result, ok};
    }

    std::tuple<struct StructField, bool> rec::FieldByName(struct structType* t, std::string name)
    {
        struct StructField f;
        bool present;
        auto hasEmbeds = false;
        if(name != "")
        {
            struct StructField f;
            bool present;
            for(auto [i, gocpp_ignored] : t->Fields)
            {
                struct StructField f;
                bool present;
                auto tf = & t->Fields[i];
                if(rec::Name(gocpp::recv(tf->Name)) == name)
                {
                    struct StructField f;
                    bool present;
                    return {rec::Field(gocpp::recv(t), i), true};
                }
                if(rec::Embedded(gocpp::recv(tf)))
                {
                    struct StructField f;
                    bool present;
                    hasEmbeds = true;
                }
            }
        }
        if(! hasEmbeds)
        {
            struct StructField f;
            bool present;
            return {f, present};
        }
        return rec::FieldByNameFunc(gocpp::recv(t), [=](std::string s) mutable -> bool
        {
            return s == name;
        });
    }

    struct Type TypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return toType((abi::Type*)(noescape(unsafe::Pointer(eface.typ))));
    }

    struct abi::Type* rtypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return eface.typ;
    }

    sync::Map ptrMap;
    struct Type PtrTo(struct Type t)
    {
        return PointerTo(t);
    }

    struct Type PointerTo(struct Type t)
    {
        return toRType(rec::ptrTo(gocpp::recv(gocpp::getValue<rtype*>(t))));
    }

    struct abi::Type* rec::ptrTo(struct rtype* t)
    {
        auto at = & t->t;
        if(at->PtrToThis != 0)
        {
            return rec::typeOff(gocpp::recv(t), at->PtrToThis);
        }
        if(auto [pi, ok] = rec::Load(gocpp::recv(ptrMap), t); ok)
        {
            return & gocpp::getValue<ptrType*>(pi)->Type;
        }
        auto s = "*" + rec::String(gocpp::recv(t));
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto p = (ptrType*)(unsafe::Pointer(tt));
            if(p->Elem != & t->t)
            {
                continue;
            }
            auto [pi, gocpp_id_3] = rec::LoadOrStore(gocpp::recv(ptrMap), t, p);
            return & gocpp::getValue<ptrType*>(pi)->Type;
        }
        go_any iptr = (unsafe::Pointer*)(nullptr);
        auto prototype = *(ptrType**)(unsafe::Pointer(& iptr));
        auto pp = *prototype;
        pp.Str = resolveReflectName(newName(s, "", false, false));
        pp.PtrToThis = 0;
        pp.Hash = fnv1(t->t.Hash, '*');
        pp.Elem = at;
        auto [pi, gocpp_id_5] = rec::LoadOrStore(gocpp::recv(ptrMap), t, & pp);
        return & gocpp::getValue<ptrType*>(pi)->Type;
    }

    struct abi::Type* ptrTo(struct abi::Type* t)
    {
        return rec::ptrTo(gocpp::recv(toRType(t)));
    }

    uint32_t fnv1(uint32_t x, gocpp::slice<unsigned char> list)
    {
        for(auto [gocpp_ignored, b] : list)
        {
            x = x * 16777619 ^ uint32_t(b);
        }
        return x;
    }

    bool rec::Implements(struct rtype* t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.Implements");
        }
        if(rec::Kind(gocpp::recv(u)) != Interface)
        {
            gocpp::panic("reflect: non-interface type passed to Type.Implements");
        }
        return implements(rec::common(gocpp::recv(u)), rec::common(gocpp::recv(t)));
    }

    bool rec::AssignableTo(struct rtype* t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.AssignableTo");
        }
        auto uu = rec::common(gocpp::recv(u));
        return directlyAssignable(uu, rec::common(gocpp::recv(t))) || implements(uu, rec::common(gocpp::recv(t)));
    }

    bool rec::ConvertibleTo(struct rtype* t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.ConvertibleTo");
        }
        return convertOp(rec::common(gocpp::recv(u)), rec::common(gocpp::recv(t))) != nullptr;
    }

    bool rec::Comparable(struct rtype* t)
    {
        return t->t.Equal != nullptr;
    }

    bool implements(struct abi::Type* T, struct abi::Type* V)
    {
        if(rec::Kind(gocpp::recv(T)) != abi::Interface)
        {
            return false;
        }
        auto t = (interfaceType*)(unsafe::Pointer(T));
        if(len(t->Methods) == 0)
        {
            return true;
        }
        if(rec::Kind(gocpp::recv(V)) == abi::Interface)
        {
            auto v = (interfaceType*)(unsafe::Pointer(V));
            auto i = 0;
            for(auto j = 0; j < len(v->Methods); j++)
            {
                auto tm = & t->Methods[i];
                auto tmName = rec::nameOff(gocpp::recv(t), tm->Name);
                auto vm = & v->Methods[j];
                auto vmName = nameOffFor(V, vm->Name);
                if(rec::Name(gocpp::recv(vmName)) == rec::Name(gocpp::recv(tmName)) && typeOffFor(V, vm->Typ) == rec::typeOff(gocpp::recv(t), tm->Typ))
                {
                    if(! rec::IsExported(gocpp::recv(tmName)))
                    {
                        auto tmPkgPath = pkgPath(tmName);
                        if(tmPkgPath == "")
                        {
                            tmPkgPath = rec::Name(gocpp::recv(t->PkgPath));
                        }
                        auto vmPkgPath = pkgPath(vmName);
                        if(vmPkgPath == "")
                        {
                            vmPkgPath = rec::Name(gocpp::recv(v->PkgPath));
                        }
                        if(tmPkgPath != vmPkgPath)
                        {
                            continue;
                        }
                    }
                    if(i++; i >= len(t->Methods))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        auto v = rec::Uncommon(gocpp::recv(V));
        if(v == nullptr)
        {
            return false;
        }
        auto i = 0;
        auto vmethods = rec::Methods(gocpp::recv(v));
        for(auto j = 0; j < int(v->Mcount); j++)
        {
            auto tm = & t->Methods[i];
            auto tmName = rec::nameOff(gocpp::recv(t), tm->Name);
            auto vm = vmethods[j];
            auto vmName = nameOffFor(V, vm.Name);
            if(rec::Name(gocpp::recv(vmName)) == rec::Name(gocpp::recv(tmName)) && typeOffFor(V, vm.Mtyp) == rec::typeOff(gocpp::recv(t), tm->Typ))
            {
                if(! rec::IsExported(gocpp::recv(tmName)))
                {
                    auto tmPkgPath = pkgPath(tmName);
                    if(tmPkgPath == "")
                    {
                        tmPkgPath = rec::Name(gocpp::recv(t->PkgPath));
                    }
                    auto vmPkgPath = pkgPath(vmName);
                    if(vmPkgPath == "")
                    {
                        vmPkgPath = rec::Name(gocpp::recv(nameOffFor(V, v->PkgPath)));
                    }
                    if(tmPkgPath != vmPkgPath)
                    {
                        continue;
                    }
                }
                if(i++; i >= len(t->Methods))
                {
                    return true;
                }
            }
        }
        return false;
    }

    bool specialChannelAssignability(struct abi::Type* T, struct abi::Type* V)
    {
        return rec::ChanDir(gocpp::recv(V)) == abi::BothDir && (nameFor(T) == "" || nameFor(V) == "") && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), true);
    }

    bool directlyAssignable(struct abi::Type* T, struct abi::Type* V)
    {
        if(T == V)
        {
            return true;
        }
        if(rec::HasName(gocpp::recv(T)) && rec::HasName(gocpp::recv(V)) || rec::Kind(gocpp::recv(T)) != rec::Kind(gocpp::recv(V)))
        {
            return false;
        }
        if(rec::Kind(gocpp::recv(T)) == abi::Chan && specialChannelAssignability(T, V))
        {
            return true;
        }
        return haveIdenticalUnderlyingType(T, V, true);
    }

    bool haveIdenticalType(struct abi::Type* T, struct abi::Type* V, bool cmpTags)
    {
        if(cmpTags)
        {
            return T == V;
        }
        if(nameFor(T) != nameFor(V) || rec::Kind(gocpp::recv(T)) != rec::Kind(gocpp::recv(V)) || pkgPathFor(T) != pkgPathFor(V))
        {
            return false;
        }
        return haveIdenticalUnderlyingType(T, V, false);
    }

    bool haveIdenticalUnderlyingType(struct abi::Type* T, struct abi::Type* V, bool cmpTags)
    {
        if(T == V)
        {
            return true;
        }
        auto kind = Kind(rec::Kind(gocpp::recv(T)));
        if(kind != Kind(rec::Kind(gocpp::recv(V))))
        {
            return false;
        }
        if(Bool <= kind && kind <= Complex128 || kind == String || kind == UnsafePointer)
        {
            return true;
        }
        //Go switch emulation
        {
            auto condition = kind;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Func) { conditionId = 2; }
            else if(condition == Interface) { conditionId = 3; }
            else if(condition == Map) { conditionId = 4; }
            else if(condition == Pointer) { conditionId = 5; }
            else if(condition == Slice) { conditionId = 6; }
            else if(condition == Struct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return rec::Len(gocpp::recv(T)) == rec::Len(gocpp::recv(V)) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 1:
                    return rec::ChanDir(gocpp::recv(V)) == rec::ChanDir(gocpp::recv(T)) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 2:
                    auto t = (funcType*)(unsafe::Pointer(T));
                    auto v = (funcType*)(unsafe::Pointer(V));
                    if(t->OutCount != v->OutCount || t->InCount != v->InCount)
                    {
                        return false;
                    }
                    for(auto i = 0; i < rec::NumIn(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(rec::In(gocpp::recv(t), i), rec::In(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    for(auto i = 0; i < rec::NumOut(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(rec::Out(gocpp::recv(t), i), rec::Out(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 3:
                    auto t = (interfaceType*)(unsafe::Pointer(T));
                    auto v = (interfaceType*)(unsafe::Pointer(V));
                    if(len(t->Methods) == 0 && len(v->Methods) == 0)
                    {
                        return true;
                    }
                    return false;
                    break;
                case 4:
                    return haveIdenticalType(rec::Key(gocpp::recv(T)), rec::Key(gocpp::recv(V)), cmpTags) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 5:
                case 6:
                    return haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 7:
                    auto t = (structType*)(unsafe::Pointer(T));
                    auto v = (structType*)(unsafe::Pointer(V));
                    if(len(t->Fields) != len(v->Fields))
                    {
                        return false;
                    }
                    if(rec::Name(gocpp::recv(t->PkgPath)) != rec::Name(gocpp::recv(v->PkgPath)))
                    {
                        return false;
                    }
                    for(auto [i, gocpp_ignored] : t->Fields)
                    {
                        auto tf = & t->Fields[i];
                        auto vf = & v->Fields[i];
                        if(rec::Name(gocpp::recv(tf->Name)) != rec::Name(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(! haveIdenticalType(tf->Typ, vf->Typ, cmpTags))
                        {
                            return false;
                        }
                        if(cmpTags && rec::Tag(gocpp::recv(tf->Name)) != rec::Tag(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(tf->Offset != vf->Offset)
                        {
                            return false;
                        }
                        if(rec::Embedded(gocpp::recv(tf)) != rec::Embedded(gocpp::recv(vf)))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
            }
        }
        return false;
    }

    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> typelinks()
    /* convertBlockStmt, nil block */;

    struct abi::Type* rtypeOff(unsafe::Pointer section, int32_t off)
    {
        return (abi::Type*)(add(section, uintptr_t(off), "sizeof(rtype) > 0"));
    }

    gocpp::slice<abi::Type*> typesByString(std::string s)
    {
        auto [sections, offset] = typelinks();
        gocpp::slice<abi::Type*> ret = {};
        for(auto [offsI, offs] : offset)
        {
            auto section = sections[offsI];
            auto [i, j] = std::tuple{0, len(offs)};
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(! (stringFor(rtypeOff(section, offs[h])) >= s))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto j = i; j < len(offs); j++)
            {
                auto typ = rtypeOff(section, offs[j]);
                if(stringFor(typ) != s)
                {
                    break;
                }
                ret = append(ret, typ);
            }
        }
        return ret;
    }

    sync::Map lookupCache;
    
    template<typename T> requires gocpp::GoStruct<T>
    cacheKey::operator T()
    {
        T result;
        result.kind = this->kind;
        result.t1 = this->t1;
        result.t2 = this->t2;
        result.extra = this->extra;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cacheKey::operator==(const T& ref) const
    {
        if (kind != ref.kind) return false;
        if (t1 != ref.t1) return false;
        if (t2 != ref.t2) return false;
        if (extra != ref.extra) return false;
        return true;
    }

    std::ostream& cacheKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << t1;
        os << " " << t2;
        os << " " << extra;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cacheKey& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_6
    {
        sync::Map m;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.m = this->m;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (m != ref.m) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << m;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_6 funcLookupCache;
    struct Type ChanOf(reflect::ChanDir dir, struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ckey = cacheKey {Chan, typ, nullptr, uintptr_t(dir)};
        if(auto [ch, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<rtype*>(ch);
        }
        if(typ->Size_ >= (1 << 16))
        {
            gocpp::panic("reflect.ChanOf: element size too large");
        }
        std::string s = {};
        //Go switch emulation
        {
            auto condition = dir;
            int conditionId = -1;
            else if(condition == SendDir) { conditionId = 0; }
            else if(condition == RecvDir) { conditionId = 1; }
            else if(condition == BothDir) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    gocpp::panic("reflect.ChanOf: invalid dir");
                    break;
                case 0:
                    s = "chan<- " + stringFor(typ);
                    break;
                case 1:
                    s = "<-chan " + stringFor(typ);
                    break;
                case 2:
                    auto typeStr = stringFor(typ);
                    if(typeStr[0] == '<')
                    {
                        s = "chan (" + typeStr + ")";
                    }
                    else
                    {
                        s = "chan " + typeStr;
                    }
                    break;
            }
        }
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto ch = (chanType*)(unsafe::Pointer(tt));
            if(ch->Elem == typ && ch->Dir == abi::ChanDir(dir))
            {
                auto [ti, gocpp_id_8] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any ichan = (gocpp::channel<unsafe::Pointer>)(nullptr);
        auto prototype = *(chanType**)(unsafe::Pointer(& ichan));
        auto ch = *prototype;
        ch.TFlag = abi::TFlagRegularMemory;
        ch.Dir = abi::ChanDir(dir);
        ch.Str = resolveReflectName(newName(s, "", false, false));
        ch.Hash = fnv1(typ->Hash, 'c', unsigned char(dir));
        ch.Elem = typ;
        auto [ti, gocpp_id_10] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& ch.Type));
        return gocpp::getValue<Type>(ti);
    }

    struct Type MapOf(struct Type key, struct Type elem)
    {
        auto ktyp = rec::common(gocpp::recv(key));
        auto etyp = rec::common(gocpp::recv(elem));
        if(ktyp->Equal == nullptr)
        {
            gocpp::panic("reflect.MapOf: invalid key type " + stringFor(ktyp));
        }
        auto ckey = cacheKey {Map, ktyp, etyp, 0};
        if(auto [mt, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(mt);
        }
        auto s = "map[" + stringFor(ktyp) + "]" + stringFor(etyp);
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto mt = (mapType*)(unsafe::Pointer(tt));
            if(mt->Key == ktyp && mt->Elem == etyp)
            {
                auto [ti, gocpp_id_12] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any imap = (gocpp::map<unsafe::Pointer, unsafe::Pointer>)(nullptr);
        auto mt = **(mapType**)(unsafe::Pointer(& imap));
        mt.Str = resolveReflectName(newName(s, "", false, false));
        mt.TFlag = 0;
        mt.Hash = fnv1(etyp->Hash, 'm', unsigned char(ktyp->Hash >> 24), unsigned char(ktyp->Hash >> 16), unsigned char(ktyp->Hash >> 8), unsigned char(ktyp->Hash));
        mt.Key = ktyp;
        mt.Elem = etyp;
        mt.Bucket = bucketOf(ktyp, etyp);
        mt.Hasher = [=](unsafe::Pointer p, uintptr_t seed) mutable -> uintptr_t
        {
            return typehash(ktyp, p, seed);
        };
        mt.Flags = 0;
        if(ktyp->Size_ > maxKeySize)
        {
            mt.KeySize = uint8_t(goarch::PtrSize);
            mt.Flags |= 1;
        }
        else
        {
            mt.KeySize = uint8_t(ktyp->Size_);
        }
        if(etyp->Size_ > maxValSize)
        {
            mt.ValueSize = uint8_t(goarch::PtrSize);
            mt.Flags |= 2;
        }
        else
        {
            mt.MapType.ValueSize = uint8_t(etyp->Size_);
        }
        mt.MapType.BucketSize = uint16_t(mt.Bucket->Size_);
        if(isReflexive(ktyp))
        {
            mt.Flags |= 4;
        }
        if(needKeyUpdate(ktyp))
        {
            mt.Flags |= 8;
        }
        if(hashMightPanic(ktyp))
        {
            mt.Flags |= 16;
        }
        mt.PtrToThis = 0;
        auto [ti, gocpp_id_14] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& mt.Type));
        return gocpp::getValue<Type>(ti);
    }

    gocpp::slice<Type> funcTypes;
    mocklib::Mutex funcTypesMutex;
    struct Type initFuncTypes(int n)
    {
        gocpp::Defer defer;
        try
        {
            rec::Lock(gocpp::recv(funcTypesMutex));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(funcTypesMutex)); });
            if(n >= len(funcTypes))
            {
                auto newFuncTypes = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), n + 1);
                copy(newFuncTypes, funcTypes);
                funcTypes = newFuncTypes;
            }
            if(funcTypes[n] != nullptr)
            {
                return funcTypes[n];
            }
            funcTypes[n] = StructOf(gocpp::slice<StructField> {gocpp::Init<>([](& x) { x.Name = "FuncType"; x.Type = TypeOf(funcType {}); }), gocpp::Init<>([](& x) { x.Name = "Args"; x.Type = ArrayOf(n, TypeOf(new rtype {})); })});
            return funcTypes[n];
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct Type FuncOf(gocpp::slice<Type> in, gocpp::slice<Type> out, bool variadic)
    {
        gocpp::Defer defer;
        try
        {
            if(variadic && (len(in) == 0 || rec::Kind(gocpp::recv(in[len(in) - 1])) != Slice))
            {
                gocpp::panic("reflect.FuncOf: last arg of variadic func must be slice");
            }
            go_any ifunc = (std::function<void ()>)(nullptr);
            auto prototype = *(funcType**)(unsafe::Pointer(& ifunc));
            auto n = len(in) + len(out);
            if(n > 128)
            {
                gocpp::panic("reflect.FuncOf: too many arguments");
            }
            auto o = rec::Elem(gocpp::recv(New(initFuncTypes(n))));
            auto ft = (funcType*)(unsafe::Pointer(rec::Pointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(o), 0)))))));
            auto args = unsafe::Slice((rtype**)(unsafe::Pointer(rec::Pointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(o), 1))))))), n).make_slice(0, 0, n);
            *ft = *prototype;
            uint32_t hash = {};
            for(auto [gocpp_ignored, in] : in)
            {
                auto t = gocpp::getValue<rtype*>(in);
                args = append(args, t);
                hash = fnv1(hash, unsigned char(t->t.Hash >> 24), unsigned char(t->t.Hash >> 16), unsigned char(t->t.Hash >> 8), unsigned char(t->t.Hash));
            }
            if(variadic)
            {
                hash = fnv1(hash, 'v');
            }
            hash = fnv1(hash, '.');
            for(auto [gocpp_ignored, out] : out)
            {
                auto t = gocpp::getValue<rtype*>(out);
                args = append(args, t);
                hash = fnv1(hash, unsigned char(t->t.Hash >> 24), unsigned char(t->t.Hash >> 16), unsigned char(t->t.Hash >> 8), unsigned char(t->t.Hash));
            }
            ft->TFlag = 0;
            ft->Hash = hash;
            ft->InCount = uint16_t(len(in));
            ft->OutCount = uint16_t(len(out));
            if(variadic)
            {
                ft->OutCount |= 1 << 15;
            }
            if(auto [ts, ok] = rec::Load(gocpp::recv(funcLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, t] : gocpp::getValue<abi::Type>>(ts))
                {
                    if(haveIdenticalUnderlyingType(& ft->Type, t, true))
                    {
                        return toRType(t);
                    }
                }
            }
            rec::Lock(gocpp::recv(funcLookupCache));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(funcLookupCache)); });
            if(auto [ts, ok] = rec::Load(gocpp::recv(funcLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, t] : gocpp::getValue<abi::Type>>(ts))
                {
                    if(haveIdenticalUnderlyingType(& ft->Type, t, true))
                    {
                        return toRType(t);
                    }
                }
            }
            auto addToCache = [=](struct abi::Type* tt) mutable -> struct Type
            {
                gocpp::slice<abi::Type*> rts = {};
                if(auto [rti, ok] = rec::Load(gocpp::recv(funcLookupCache.m), hash); ok)
                {
                    rts = gocpp::getValue<abi::Type>>(rti);
                }
                rec::Store(gocpp::recv(funcLookupCache.m), hash, append(rts, tt));
                return toType(tt);
            };
            auto str = funcStr(ft);
            for(auto [gocpp_ignored, tt] : typesByString(str))
            {
                if(haveIdenticalUnderlyingType(& ft->Type, tt, true))
                {
                    return addToCache(tt);
                }
            }
            ft->Str = resolveReflectName(newName(str, "", false, false));
            ft->PtrToThis = 0;
            return addToCache(& ft->Type);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::string stringFor(struct abi::Type* t)
    {
        return rec::String(gocpp::recv(toRType(t)));
    }

    std::string funcStr(struct funcType* ft)
    {
        auto repr = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 64);
        repr = append(repr, "func(");
        for(auto [i, t] : rec::InSlice(gocpp::recv(ft)))
        {
            if(i > 0)
            {
                repr = append(repr, ", ");
            }
            if(rec::IsVariadic(gocpp::recv(ft)) && i == int(ft->InCount) - 1)
            {
                repr = append(repr, "...");
                repr = append(repr, stringFor((sliceType*)(unsafe::Pointer(t))->Elem));
            }
            else
            {
                repr = append(repr, stringFor(t));
            }
        }
        repr = append(repr, ')');
        auto out = rec::OutSlice(gocpp::recv(ft));
        if(len(out) == 1)
        {
            repr = append(repr, ' ');
        }
        else
        if(len(out) > 1)
        {
            repr = append(repr, " (");
        }
        for(auto [i, t] : out)
        {
            if(i > 0)
            {
                repr = append(repr, ", ");
            }
            repr = append(repr, stringFor(t));
        }
        if(len(out) > 1)
        {
            repr = append(repr, ')');
        }
        return string(repr);
    }

    bool isReflexive(struct abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            if(condition == Int) { conditionId = 1; }
            if(condition == Int8) { conditionId = 2; }
            if(condition == Int16) { conditionId = 3; }
            if(condition == Int32) { conditionId = 4; }
            if(condition == Int64) { conditionId = 5; }
            if(condition == Uint) { conditionId = 6; }
            if(condition == Uint8) { conditionId = 7; }
            if(condition == Uint16) { conditionId = 8; }
            if(condition == Uint32) { conditionId = 9; }
            if(condition == Uint64) { conditionId = 10; }
            if(condition == Uintptr) { conditionId = 11; }
            if(condition == Chan) { conditionId = 12; }
            if(condition == Pointer) { conditionId = 13; }
            if(condition == String) { conditionId = 14; }
            if(condition == UnsafePointer) { conditionId = 15; }
            else if(condition == Float32) { conditionId = 16; }
            else if(condition == Float64) { conditionId = 17; }
            else if(condition == Complex64) { conditionId = 18; }
            else if(condition == Complex128) { conditionId = 19; }
            else if(condition == Interface) { conditionId = 20; }
            else if(condition == Array) { conditionId = 21; }
            else if(condition == Struct) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    return true;
                    break;
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    return false;
                    break;
                case 21:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    return isReflexive(tt->Elem);
                    break;
                case 22:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : tt->Fields)
                    {
                        if(! isReflexive(f.Typ))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                default:
                    gocpp::panic("isReflexive called on non-key type " + stringFor(t));
                    break;
            }
        }
    }

    bool needKeyUpdate(struct abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            if(condition == Int) { conditionId = 1; }
            if(condition == Int8) { conditionId = 2; }
            if(condition == Int16) { conditionId = 3; }
            if(condition == Int32) { conditionId = 4; }
            if(condition == Int64) { conditionId = 5; }
            if(condition == Uint) { conditionId = 6; }
            if(condition == Uint8) { conditionId = 7; }
            if(condition == Uint16) { conditionId = 8; }
            if(condition == Uint32) { conditionId = 9; }
            if(condition == Uint64) { conditionId = 10; }
            if(condition == Uintptr) { conditionId = 11; }
            if(condition == Chan) { conditionId = 12; }
            if(condition == Pointer) { conditionId = 13; }
            if(condition == UnsafePointer) { conditionId = 14; }
            else if(condition == Float32) { conditionId = 15; }
            else if(condition == Float64) { conditionId = 16; }
            else if(condition == Complex64) { conditionId = 17; }
            else if(condition == Complex128) { conditionId = 18; }
            else if(condition == Interface) { conditionId = 19; }
            else if(condition == String) { conditionId = 20; }
            else if(condition == Array) { conditionId = 21; }
            else if(condition == Struct) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    return false;
                    break;
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    return true;
                    break;
                case 21:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    return needKeyUpdate(tt->Elem);
                    break;
                case 22:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : tt->Fields)
                    {
                        if(needKeyUpdate(f.Typ))
                        {
                            return true;
                        }
                    }
                    return false;
                    break;
                default:
                    gocpp::panic("needKeyUpdate called on non-key type " + stringFor(t));
                    break;
            }
        }
    }

    bool hashMightPanic(struct abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Interface) { conditionId = 0; }
            else if(condition == Array) { conditionId = 1; }
            else if(condition == Struct) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return true;
                    break;
                case 1:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    return hashMightPanic(tt->Elem);
                    break;
                case 2:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : tt->Fields)
                    {
                        if(hashMightPanic(f.Typ))
                        {
                            return true;
                        }
                    }
                    return false;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    struct abi::Type* bucketOf(struct abi::Type* ktyp, struct abi::Type* etyp)
    {
        if(ktyp->Size_ > maxKeySize)
        {
            ktyp = ptrTo(ktyp);
        }
        if(etyp->Size_ > maxValSize)
        {
            etyp = ptrTo(etyp);
        }
        unsigned char* gcdata = {};
        uintptr_t ptrdata = {};
        auto size = bucketSize * (1 + ktyp->Size_ + etyp->Size_) + goarch::PtrSize;
        if(size & uintptr_t(ktyp->Align_ - 1) != 0 || size & uintptr_t(etyp->Align_ - 1) != 0)
        {
            gocpp::panic("reflect: bad size computation in MapOf");
        }
        if(ktyp->PtrBytes != 0 || etyp->PtrBytes != 0)
        {
            auto nptr = (bucketSize * (1 + ktyp->Size_ + etyp->Size_) + goarch::PtrSize) / goarch::PtrSize;
            auto n = (nptr + 7) / 8;
            n = (n + goarch::PtrSize - 1) &^ (goarch::PtrSize - 1);
            auto mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            auto base = bucketSize / goarch::PtrSize;
            if(ktyp->PtrBytes != 0)
            {
                emitGCMask(mask, base, ktyp, bucketSize);
            }
            base += bucketSize * ktyp->Size_ / goarch::PtrSize;
            if(etyp->PtrBytes != 0)
            {
                emitGCMask(mask, base, etyp, bucketSize);
            }
            base += bucketSize * etyp->Size_ / goarch::PtrSize;
            auto word = base;
            mask[word / 8] |= 1 << (word % 8);
            gcdata = & mask[0];
            ptrdata = (word + 1) * goarch::PtrSize;
            if(ptrdata != size)
            {
                gocpp::panic("reflect: bad layout computation in MapOf");
            }
        }
        auto b = gocpp::InitPtr<abi::Type>([](abi::Type& x) { x.Align_ = goarch::PtrSize; x.Size_ = size; x.Kind_ = uint8_t(Struct); x.PtrBytes = ptrdata; x.GCData = gcdata; });
        auto s = "bucket(" + stringFor(ktyp) + "," + stringFor(etyp) + ")";
        b->Str = resolveReflectName(newName(s, "", false, false));
        return b;
    }

    gocpp::slice<unsigned char> rec::gcSlice(struct rtype* t, uintptr_t begin, uintptr_t end)
    {
        return (gocpp::array<unsigned char, 1 << 30>*)(unsafe::Pointer(t->t.GCData)).make_slice(begin, end, end);
    }

    void emitGCMask(gocpp::slice<unsigned char> out, uintptr_t base, struct abi::Type* typ, uintptr_t n)
    {
        if(typ->Kind_ & kindGCProg != 0)
        {
            gocpp::panic("reflect: unexpected GC program");
        }
        auto ptrs = typ->PtrBytes / goarch::PtrSize;
        auto words = typ->Size_ / goarch::PtrSize;
        auto mask = rec::GcSlice(gocpp::recv(typ), 0, (ptrs + 7) / 8);
        for(auto j = uintptr_t(0); j < ptrs; j++)
        {
            if((mask[j / 8] >> (j % 8)) & 1 != 0)
            {
                for(auto i = uintptr_t(0); i < n; i++)
                {
                    auto k = base + i * words + j;
                    out[k / 8] |= 1 << (k % 8);
                }
            }
        }
    }

    gocpp::slice<unsigned char> appendGCProg(gocpp::slice<unsigned char> dst, struct abi::Type* typ)
    {
        if(typ->Kind_ & kindGCProg != 0)
        {
            auto n = uintptr_t(*(uint32_t*)(unsafe::Pointer(typ->GCData)));
            auto prog = rec::GcSlice(gocpp::recv(typ), 4, 4 + n - 1);
            return append(dst, prog);
        }
        auto ptrs = typ->PtrBytes / goarch::PtrSize;
        auto mask = rec::GcSlice(gocpp::recv(typ), 0, (ptrs + 7) / 8);
        for(; ptrs > 120; ptrs -= 120)
        {
            dst = append(dst, 120);
            dst = append(dst, mask.make_slice(0, 15));
            mask = mask.make_slice(15);
        }
        dst = append(dst, unsigned char(ptrs));
        dst = append(dst, mask);
        return dst;
    }

    struct Type SliceOf(struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ckey = cacheKey {Slice, typ, nullptr, 0};
        if(auto [slice, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(slice);
        }
        auto s = "[]" + stringFor(typ);
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto slice = (sliceType*)(unsafe::Pointer(tt));
            if(slice->Elem == typ)
            {
                auto [ti, gocpp_id_16] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any islice = (gocpp::slice<unsafe::Pointer>)(nullptr);
        auto prototype = *(sliceType**)(unsafe::Pointer(& islice));
        auto slice = *prototype;
        slice.TFlag = 0;
        slice.Str = resolveReflectName(newName(s, "", false, false));
        slice.Hash = fnv1(typ->Hash, '[');
        slice.Elem = typ;
        slice.PtrToThis = 0;
        auto [ti, gocpp_id_18] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& slice.Type));
        return gocpp::getValue<Type>(ti);
    }

    struct gocpp_id_19
    {
        sync::Map m;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.m = this->m;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (m != ref.m) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << m;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_19& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_19 structLookupCache;
    
    template<typename T> requires gocpp::GoStruct<T>
    structTypeUncommon::operator T()
    {
        T result;
        result.u = this->u;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool structTypeUncommon::operator==(const T& ref) const
    {
        if (u != ref.u) return false;
        return true;
    }

    std::ostream& structTypeUncommon::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value)
    {
        return value.PrintTo(os);
    }

    bool isLetter(gocpp::rune ch)
    {
        return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= utf8::RuneSelf && unicode::IsLetter(ch);
    }

    bool isValidFieldName(std::string fieldName)
    {
        for(auto [i, c] : fieldName)
        {
            if(i == 0 && ! isLetter(c))
            {
                return false;
            }
            if(! (isLetter(c) || unicode::IsDigit(c)))
            {
                return false;
            }
        }
        return len(fieldName) > 0;
    }

    struct gocpp_id_20
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_20& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_23
            {

                using isGoStruct = void;

                template<typename T> requires gocpp::GoStruct<T>
                operator T()
                {
                    T result;
                    return result;
                }

                template<typename T> requires gocpp::GoStruct<T>
                bool operator==(const T& ref) const
                {
                    return true;
                }

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_23& value)
            {
                return value.PrintTo(os);
            }


    struct gocpp_id_24
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_24& value)
        {
            return value.PrintTo(os);
        }


    struct Type StructOf(gocpp::slice<StructField> fields)
    {
        gocpp::Defer defer;
        try
        {
            auto hash = fnv1(0, gocpp::Tag<gocpp::slice<unsigned char>>()("struct {"));
            uintptr_t size = fnv1(0, gocpp::Tag<gocpp::slice<unsigned char>>()("struct {"));
            uint8_t typalign = fnv1(0, gocpp::Tag<gocpp::slice<unsigned char>>()("struct {"));
            auto comparable = true;
            gocpp::slice<abi::Method> methods = true;
            auto fs = gocpp::make(gocpp::Tag<gocpp::slice<structField>>(), len(fields));
            auto repr = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 64);
            auto fset = gocpp::map<std::string, gocpp_id_20> {};
            auto hasGCProg = false;
            auto lastzero = uintptr_t(0);
            repr = append(repr, "struct {");
            auto pkgpath = "";
            for(auto [i, field] : fields)
            {
                if(field.Name == "")
                {
                    gocpp::panic("reflect.StructOf: field " + strconv::Itoa(i) + " has no name");
                }
                if(! isValidFieldName(field.Name))
                {
                    gocpp::panic("reflect.StructOf: field " + strconv::Itoa(i) + " has invalid name");
                }
                if(field.Type == nullptr)
                {
                    gocpp::panic("reflect.StructOf: field " + strconv::Itoa(i) + " has no type");
                }
                auto [f, fpkgpath] = runtimeStructField(field);
                auto ft = f.Typ;
                if(ft->Kind_ & kindGCProg != 0)
                {
                    hasGCProg = true;
                }
                if(fpkgpath != "")
                {
                    if(pkgpath == "")
                    {
                        pkgpath = fpkgpath;
                    }
                    else
                    if(pkgpath != fpkgpath)
                    {
                        gocpp::panic("reflect.Struct: fields with different PkgPath " + pkgpath + " and " + fpkgpath);
                    }
                }
                auto name = rec::Name(gocpp::recv(f.Name));
                hash = fnv1(hash, gocpp::Tag<gocpp::slice<unsigned char>>()(name));
                repr = append(repr, (" " + name));
                if(rec::Embedded(gocpp::recv(f)))
                {
                    if(rec::Kind(gocpp::recv(f.Typ)) == abi::Pointer)
                    {
                        auto elem = rec::Elem(gocpp::recv(ft));
                        if(auto k = rec::Kind(gocpp::recv(elem)); k == abi::Pointer || k == abi::Interface)
                        {
                            gocpp::panic("reflect.StructOf: illegal embedded field type " + stringFor(ft));
                        }
                    }
                    //Go switch emulation
                    {
                        auto condition = Kind(rec::Kind(gocpp::recv(f.Typ)));
                        int conditionId = -1;
                        if(condition == Interface) { conditionId = 0; }
                        else if(condition == Pointer) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                auto ift = (interfaceType*)(unsafe::Pointer(ft));
                                for(auto [gocpp_ignored, m] : ift->Methods)
                                {
                                    if(pkgPath(rec::nameOff(gocpp::recv(ift), m.Name)) != "")
                                    {
                                        gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                    }
                                    auto fnStub = resolveReflectText(unsafe::Pointer(abi::FuncPCABIInternal(embeddedIfaceMethStub)));
                                    methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(rec::nameOff(gocpp::recv(ift), m.Name)); x.Mtyp = resolveReflectType(rec::typeOff(gocpp::recv(ift), m.Typ)); x.Ifn = fnStub; x.Tfn = fnStub; }));
                                }
                                break;
                            case 1:
                                auto ptr = (ptrType*)(unsafe::Pointer(ft));
                                if(auto unt = rec::Uncommon(gocpp::recv(ptr)); unt != nullptr)
                                {
                                    if(i > 0 && unt->Mcount > 0)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented if type is not first field");
                                    }
                                    if(len(fields) > 1)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented if there is more than one field");
                                    }
                                    for(auto [gocpp_ignored, m] : rec::Methods(gocpp::recv(unt)))
                                    {
                                        auto mname = nameOffFor(ft, m.Name);
                                        if(pkgPath(mname) != "")
                                        {
                                            gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                        }
                                        methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(mname); x.Mtyp = resolveReflectType(typeOffFor(ft, m.Mtyp)); x.Ifn = resolveReflectText(textOffFor(ft, m.Ifn)); x.Tfn = resolveReflectText(textOffFor(ft, m.Tfn)); }));
                                    }
                                }
                                if(auto unt = rec::Uncommon(gocpp::recv(ptr->Elem)); unt != nullptr)
                                {
                                    for(auto [gocpp_ignored, m] : rec::Methods(gocpp::recv(unt)))
                                    {
                                        auto mname = nameOffFor(ft, m.Name);
                                        if(pkgPath(mname) != "")
                                        {
                                            gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                        }
                                        methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(mname); x.Mtyp = resolveReflectType(typeOffFor(ptr->Elem, m.Mtyp)); x.Ifn = resolveReflectText(textOffFor(ptr->Elem, m.Ifn)); x.Tfn = resolveReflectText(textOffFor(ptr->Elem, m.Tfn)); }));
                                    }
                                }
                                break;
                            default:
                                if(auto unt = rec::Uncommon(gocpp::recv(ft)); unt != nullptr)
                                {
                                    if(i > 0 && unt->Mcount > 0)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented if type is not first field");
                                    }
                                    if(len(fields) > 1 && ft->Kind_ & kindDirectIface != 0)
                                    {
                                        gocpp::panic("reflect: embedded type with methods not implemented for non-pointer type");
                                    }
                                    for(auto [gocpp_ignored, m] : rec::Methods(gocpp::recv(unt)))
                                    {
                                        auto mname = nameOffFor(ft, m.Name);
                                        if(pkgPath(mname) != "")
                                        {
                                            gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                        }
                                        methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(mname); x.Mtyp = resolveReflectType(typeOffFor(ft, m.Mtyp)); x.Ifn = resolveReflectText(textOffFor(ft, m.Ifn)); x.Tfn = resolveReflectText(textOffFor(ft, m.Tfn)); }));
                                    }
                                }
                                break;
                        }
                    }
                }
                if(auto [gocpp_id_22, dup] = fset[name]; dup && name != "_")
                {
                    gocpp::panic("reflect.StructOf: duplicate field " + name);
                }
                fset[name] = gocpp_id_23 {};
                hash = fnv1(hash, unsigned char(ft->Hash >> 24), unsigned char(ft->Hash >> 16), unsigned char(ft->Hash >> 8), unsigned char(ft->Hash));
                repr = append(repr, (" " + stringFor(ft)));
                if(rec::HasTag(gocpp::recv(f.Name)))
                {
                    hash = fnv1(hash, gocpp::Tag<gocpp::slice<unsigned char>>()(rec::Tag(gocpp::recv(f.Name))));
                    repr = append(repr, (" " + strconv::Quote(rec::Tag(gocpp::recv(f.Name)))));
                }
                if(i < len(fields) - 1)
                {
                    repr = append(repr, ';');
                }
                comparable = comparable && (ft->Equal != nullptr);
                auto offset = align(size, uintptr_t(ft->Align_));
                if(offset < size)
                {
                    gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
                }
                if(ft->Align_ > typalign)
                {
                    typalign = ft->Align_;
                }
                size = offset + ft->Size_;
                if(size < offset)
                {
                    gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
                }
                f.Offset = offset;
                if(ft->Size_ == 0)
                {
                    lastzero = size;
                }
                fs[i] = f;
            }
            if(size > 0 && lastzero == size)
            {
                size++;
                if(size == 0)
                {
                    gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
                }
            }
            structType* typ = {};
            uncommonType* ut = {};
            if(len(methods) == 0)
            {
                auto t = go_new(structTypeUncommon);
                typ = & t->structType;
                ut = & t->u;
            }
            else
            {
                auto tt = New(StructOf(gocpp::slice<StructField> {gocpp::Init<>([](& x) { x.Name = "S"; x.Type = TypeOf(structType {}); }), gocpp::Init<>([](& x) { x.Name = "U"; x.Type = TypeOf(uncommonType {}); }), gocpp::Init<>([](& x) { x.Name = "M"; x.Type = ArrayOf(len(methods), TypeOf(methods[0])); })}));
                typ = (structType*)(rec::UnsafePointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(rec::Elem(gocpp::recv(tt))), 0))))));
                ut = (uncommonType*)(rec::UnsafePointer(gocpp::recv(rec::Addr(gocpp::recv(rec::Field(gocpp::recv(rec::Elem(gocpp::recv(tt))), 1))))));
                copy(gocpp::getValue<abi::Method>>(rec::Interface(gocpp::recv(rec::Slice(gocpp::recv(rec::Field(gocpp::recv(rec::Elem(gocpp::recv(tt))), 2)), 0, len(methods))))), methods);
            }
            ut->Mcount = uint16_t(len(methods));
            ut->Xcount = ut->Mcount;
            ut->Moff = uint32_t(gocpp::Sizeof<uncommonType>());
            if(len(fs) > 0)
            {
                repr = append(repr, ' ');
            }
            repr = append(repr, '}');
            hash = fnv1(hash, '}');
            auto str = string(repr);
            auto s = align(size, uintptr_t(typalign));
            if(s < size)
            {
                gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
            }
            size = s;
            go_any istruct = gocpp_id_24 {};
            auto prototype = *(structType**)(unsafe::Pointer(& istruct));
            *typ = *prototype;
            typ->Fields = fs;
            if(pkgpath != "")
            {
                typ->PkgPath = newName(pkgpath, "", false, false);
            }
            if(auto [ts, ok] = rec::Load(gocpp::recv(structLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, st] : gocpp::getValue<gocpp::slice<reflect::Type>>(ts))
                {
                    auto t = rec::common(gocpp::recv(st));
                    if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                    {
                        return toType(t);
                    }
                }
            }
            rec::Lock(gocpp::recv(structLookupCache));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(structLookupCache)); });
            if(auto [ts, ok] = rec::Load(gocpp::recv(structLookupCache.m), hash); ok)
            {
                for(auto [gocpp_ignored, st] : gocpp::getValue<gocpp::slice<reflect::Type>>(ts))
                {
                    auto t = rec::common(gocpp::recv(st));
                    if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                    {
                        return toType(t);
                    }
                }
            }
            auto addToCache = [=](struct Type t) mutable -> struct Type
            {
                gocpp::slice<Type> ts = {};
                if(auto [ti, ok] = rec::Load(gocpp::recv(structLookupCache.m), hash); ok)
                {
                    ts = gocpp::getValue<gocpp::slice<reflect::Type>>(ti);
                }
                rec::Store(gocpp::recv(structLookupCache.m), hash, append(ts, t));
                return t;
            };
            for(auto [gocpp_ignored, t] : typesByString(str))
            {
                if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                {
                    return addToCache(toType(t));
                }
            }
            typ->Str = resolveReflectName(newName(str, "", false, false));
            typ->TFlag = 0;
            typ->Hash = hash;
            typ->Size_ = size;
            typ->PtrBytes = typeptrdata(& typ->Type);
            typ->Align_ = typalign;
            typ->FieldAlign_ = typalign;
            typ->PtrToThis = 0;
            if(len(methods) > 0)
            {
                typ->TFlag |= abi::TFlagUncommon;
            }
            if(hasGCProg)
            {
                auto lastPtrField = 0;
                for(auto [i, ft] : fs)
                {
                    if(rec::Pointers(gocpp::recv(ft->Typ)))
                    {
                        lastPtrField = i;
                    }
                }
                auto prog = gocpp::slice<unsigned char> {0, 0, 0, 0};
                uintptr_t off = {};
                for(auto [i, ft] : fs)
                {
                    if(i > lastPtrField)
                    {
                        break;
                    }
                    if(! rec::Pointers(gocpp::recv(ft->Typ)))
                    {
                        continue;
                    }
                    if(ft->Offset > off)
                    {
                        auto n = (ft->Offset - off) / goarch::PtrSize;
                        prog = append(prog, 0x01, 0x00);
                        if(n > 1)
                        {
                            prog = append(prog, 0x81);
                            prog = appendVarint(prog, n - 1);
                        }
                        off = ft->Offset;
                    }
                    prog = appendGCProg(prog, ft->Typ);
                    off += ft->Typ->PtrBytes;
                }
                prog = append(prog, 0);
                *(uint32_t*)(unsafe::Pointer(& prog[0])) = uint32_t(len(prog) - 4);
                typ->Kind_ |= kindGCProg;
                typ->GCData = & prog[0];
            }
            else
            {
                typ->Kind_ &^= kindGCProg;
                auto bv = go_new(bitVector);
                addTypeBits(bv, 0, & typ->Type);
                if(len(bv->data) > 0)
                {
                    typ->GCData = & bv->data[0];
                }
            }
            typ->Equal = nullptr;
            if(comparable)
            {
                typ->Equal = [=](unsafe::Pointer p, unsafe::Pointer q) mutable -> bool
                {
                    for(auto [gocpp_ignored, ft] : typ->Fields)
                    {
                        auto pi = add(p, ft->Offset, "&x.field safe");
                        auto qi = add(q, ft->Offset, "&x.field safe");
                        if(! rec::Equal(gocpp::recv(ft->Typ), pi, qi))
                        {
                            return false;
                        }
                    }
                    return true;
                };
            }
            //Go switch emulation
            {
                int conditionId = -1;
                if(len(fs) == 1 && ! ifaceIndir(fs[0].Typ)) { conditionId = 0; }
                switch(conditionId)
                {
                    case 0:
                        typ->Kind_ |= kindDirectIface;
                        break;
                    default:
                        typ->Kind_ &^= kindDirectIface;
                        break;
                }
            }
            return addToCache(toType(& typ->Type));
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void embeddedIfaceMethStub()
    {
        gocpp::panic("reflect: StructOf does not support methods of embedded interfaces");
    }

    std::tuple<struct structField, std::string> runtimeStructField(struct StructField field)
    {
        if(field.Anonymous && field.PkgPath != "")
        {
            gocpp::panic("reflect.StructOf: field \"" + field.Name + "\" is anonymous but has PkgPath set");
        }
        if(rec::IsExported(gocpp::recv(field)))
        {
            auto c = field.Name[0];
            if('a' <= c && c <= 'z' || c == '_')
            {
                gocpp::panic("reflect.StructOf: field \"" + field.Name + "\" is unexported but missing PkgPath");
            }
        }
        resolveReflectType(rec::common(gocpp::recv(field.Type)));
        auto f = gocpp::Init<structField>([](structField& x) { x.Name = newName(field.Name, string(field.Tag), rec::IsExported(gocpp::recv(field)), field.Anonymous); x.Typ = rec::common(gocpp::recv(field.Type)); x.Offset = 0; });
        return {f, field.PkgPath};
    }

    uintptr_t typeptrdata(struct abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == abi::Struct) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    auto st = (structType*)(unsafe::Pointer(t));
                    auto field = - 1;
                    for(auto [i, gocpp_ignored] : st->Fields)
                    {
                        auto ft = st->Fields[i].Typ;
                        if(rec::Pointers(gocpp::recv(ft)))
                        {
                            field = i;
                        }
                    }
                    if(field == - 1)
                    {
                        return 0;
                    }
                    auto f = st->Fields[field];
                    return f.Offset + f.Typ->PtrBytes;
                    break;
                default:
                    gocpp::panic("reflect.typeptrdata: unexpected type, " + stringFor(t));
                    break;
            }
        }
    }

    struct Type ArrayOf(int length, struct Type elem)
    {
        if(length < 0)
        {
            gocpp::panic("reflect: negative length passed to ArrayOf");
        }
        auto typ = rec::common(gocpp::recv(elem));
        auto ckey = cacheKey {Array, typ, nullptr, uintptr_t(length)};
        if(auto [array, ok] = rec::Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(array);
        }
        auto s = "[" + strconv::Itoa(length) + "]" + stringFor(typ);
        for(auto [gocpp_ignored, tt] : typesByString(s))
        {
            auto array = (arrayType*)(unsafe::Pointer(tt));
            if(array->Elem == typ)
            {
                auto [ti, gocpp_id_26] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any iarray = gocpp::array<unsafe::Pointer, 1> {};
        auto prototype = *(arrayType**)(unsafe::Pointer(& iarray));
        auto array = *prototype;
        array.TFlag = typ->TFlag & abi::TFlagRegularMemory;
        array.Str = resolveReflectName(newName(s, "", false, false));
        array.Hash = fnv1(typ->Hash, '[');
        for(auto n = uint32_t(length); n > 0; n >>= 8)
        {
            array.Hash = fnv1(array.Hash, unsigned char(n));
        }
        array.Hash = fnv1(array.Hash, ']');
        array.Elem = typ;
        array.PtrToThis = 0;
        if(typ->Size_ > 0)
        {
            auto max = ~ uintptr_t(0) / typ->Size_;
            if(uintptr_t(length) > max)
            {
                gocpp::panic("reflect.ArrayOf: array size would exceed virtual address space");
            }
        }
        array.Size_ = typ->Size_ * uintptr_t(length);
        if(length > 0 && typ->PtrBytes != 0)
        {
            array.PtrBytes = typ->Size_ * uintptr_t(length - 1) + typ->PtrBytes;
        }
        array.Align_ = typ->Align_;
        array.FieldAlign_ = typ->FieldAlign_;
        array.Len = uintptr_t(length);
        array.Slice = & (gocpp::getValue<rtype*>(SliceOf(elem))->t);
        //Go switch emulation
        {
            int conditionId = -1;
            if(typ->PtrBytes == 0 || array.Size_ == 0) { conditionId = 0; }
            else if(length == 1) { conditionId = 1; }
            else if(typ->Kind_ & kindGCProg == 0 && array.Size_ <= maxPtrmaskBytes * 8 * goarch::PtrSize) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    array.GCData = nullptr;
                    array.PtrBytes = 0;
                    break;
                case 1:
                    array.Kind_ |= typ->Kind_ & kindGCProg;
                    array.GCData = typ->GCData;
                    array.PtrBytes = typ->PtrBytes;
                    break;
                case 2:
                    auto n = (array.PtrBytes / goarch::PtrSize + 7) / 8;
                    n = (n + goarch::PtrSize - 1) &^ (goarch::PtrSize - 1);
                    auto mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
                    emitGCMask(mask, 0, typ, array.Len);
                    array.GCData = & mask[0];
                    break;
                default:
                    auto prog = gocpp::slice<unsigned char> {0, 0, 0, 0};
                    prog = appendGCProg(prog, typ);
                    auto elemPtrs = typ->PtrBytes / goarch::PtrSize;
                    auto elemWords = typ->Size_ / goarch::PtrSize;
                    if(elemPtrs < elemWords)
                    {
                        prog = append(prog, 0x01, 0x00);
                        if(elemPtrs + 1 < elemWords)
                        {
                            prog = append(prog, 0x81);
                            prog = appendVarint(prog, elemWords - elemPtrs - 1);
                        }
                    }
                    if(elemWords < 0x80)
                    {
                        prog = append(prog, unsigned char(elemWords | 0x80));
                    }
                    else
                    {
                        prog = append(prog, 0x80);
                        prog = appendVarint(prog, elemWords);
                    }
                    prog = appendVarint(prog, uintptr_t(length) - 1);
                    prog = append(prog, 0);
                    *(uint32_t*)(unsafe::Pointer(& prog[0])) = uint32_t(len(prog) - 4);
                    array.Kind_ |= kindGCProg;
                    array.GCData = & prog[0];
                    array.PtrBytes = array.Size_;
                    break;
            }
        }
        auto etyp = typ;
        auto esize = rec::Size(gocpp::recv(etyp));
        array.Equal = nullptr;
        if(auto eequal = etyp->Equal; eequal != nullptr)
        {
            array.Equal = [=](unsafe::Pointer p, unsafe::Pointer q) mutable -> bool
            {
                for(auto i = 0; i < length; i++)
                {
                    auto pi = arrayAt(p, i, esize, "i < length");
                    auto qi = arrayAt(q, i, esize, "i < length");
                    if(! eequal(pi, qi))
                    {
                        return false;
                    }
                }
                return true;
            };
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(length == 1 && ! ifaceIndir(typ)) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    array.Kind_ |= kindDirectIface;
                    break;
                default:
                    array.Kind_ &^= kindDirectIface;
                    break;
            }
        }
        auto [ti, gocpp_id_28] = rec::LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& array.Type));
        return gocpp::getValue<Type>(ti);
    }

    gocpp::slice<unsigned char> appendVarint(gocpp::slice<unsigned char> x, uintptr_t v)
    {
        for(; v >= 0x80; v >>= 7)
        {
            x = append(x, unsigned char(v | 0x80));
        }
        x = append(x, unsigned char(v));
        return x;
    }

    struct Type toType(struct abi::Type* t)
    {
        if(t == nullptr)
        {
            return nullptr;
        }
        return toRType(t);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    layoutKey::operator T()
    {
        T result;
        result.ftyp = this->ftyp;
        result.rcvr = this->rcvr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool layoutKey::operator==(const T& ref) const
    {
        if (ftyp != ref.ftyp) return false;
        if (rcvr != ref.rcvr) return false;
        return true;
    }

    std::ostream& layoutKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ftyp;
        os << " " << rcvr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct layoutKey& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    layoutType::operator T()
    {
        T result;
        result.t = this->t;
        result.framePool = this->framePool;
        result.abid = this->abid;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool layoutType::operator==(const T& ref) const
    {
        if (t != ref.t) return false;
        if (framePool != ref.framePool) return false;
        if (abid != ref.abid) return false;
        return true;
    }

    std::ostream& layoutType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << t;
        os << " " << framePool;
        os << " " << abid;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct layoutType& value)
    {
        return value.PrintTo(os);
    }

    sync::Map layoutCache;
    std::tuple<struct abi::Type*, struct sync::Pool*, struct abiDesc> funcLayout(struct funcType* t, struct abi::Type* rcvr)
    {
        struct abi::Type* frametype;
        struct sync::Pool* framePool;
        struct abiDesc abid;
        if(rec::Kind(gocpp::recv(t)) != abi::Func)
        {
            struct abi::Type* frametype;
            struct sync::Pool* framePool;
            struct abiDesc abid;
            gocpp::panic("reflect: funcLayout of non-func type " + stringFor(& t->Type));
        }
        if(rcvr != nullptr && rec::Kind(gocpp::recv(rcvr)) == abi::Interface)
        {
            struct abi::Type* frametype;
            struct sync::Pool* framePool;
            struct abiDesc abid;
            gocpp::panic("reflect: funcLayout with interface receiver " + stringFor(rcvr));
        }
        auto k = layoutKey {t, rcvr};
        if(auto [lti, ok] = rec::Load(gocpp::recv(layoutCache), k); ok)
        {
            struct abi::Type* frametype;
            struct sync::Pool* framePool;
            struct abiDesc abid;
            auto lt = gocpp::getValue<layoutType>(lti);
            return {lt.t, lt.framePool, lt.abid};
        }
        abid = newAbiDesc(t, rcvr);
        auto x = gocpp::InitPtr<abi::Type>([](abi::Type& x) { x.Align_ = goarch::PtrSize; x.Size_ = align(abid.retOffset + abid.ret.stackBytes, goarch::PtrSize); x.PtrBytes = uintptr_t(abid.stackPtrs->n) * goarch::PtrSize; });
        if(abid.stackPtrs->n > 0)
        {
            struct abi::Type* frametype;
            struct sync::Pool* framePool;
            struct abiDesc abid;
            x->GCData = & abid.stackPtrs->data[0];
        }
        std::string s = {};
        if(rcvr != nullptr)
        {
            struct abi::Type* frametype;
            struct sync::Pool* framePool;
            struct abiDesc abid;
            s = "methodargs(" + stringFor(rcvr) + ")(" + stringFor(& t->Type) + ")";
        }
        else
        {
            struct abi::Type* frametype;
            struct sync::Pool* framePool;
            struct abiDesc abid;
            s = "funcargs(" + stringFor(& t->Type) + ")";
        }
        x->Str = resolveReflectName(newName(s, "", false, false));
        framePool = gocpp::InitPtr<sync::Pool>([](sync::Pool& x) { x.New = [=]() mutable -> go_any
        {
            return unsafe_New(x);
        }; });
        auto [lti, gocpp_id_30] = rec::LoadOrStore(gocpp::recv(layoutCache), k, gocpp::Init<layoutType>([](layoutType& x) { x.t = x; x.framePool = framePool; x.abid = abid; }));
        auto lt = gocpp::getValue<layoutType>(lti);
        return {lt.t, lt.framePool, lt.abid};
    }

    bool ifaceIndir(struct abi::Type* t)
    {
        return t->Kind_ & kindDirectIface == 0;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    bitVector::operator T()
    {
        T result;
        result.n = this->n;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool bitVector::operator==(const T& ref) const
    {
        if (n != ref.n) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& bitVector::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << n;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct bitVector& value)
    {
        return value.PrintTo(os);
    }

    void rec::append(struct bitVector* bv, uint8_t bit)
    {
        if(bv->n % (8 * goarch::PtrSize) == 0)
        {
            for(auto i = 0; i < goarch::PtrSize; i++)
            {
                bv->data = append(bv->data, 0);
            }
        }
        bv->data[bv->n / 8] |= bit << (bv->n % 8);
        bv->n++;
    }

    void addTypeBits(struct bitVector* bv, uintptr_t offset, struct abi::Type* t)
    {
        if(t->PtrBytes == 0)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = Kind(t->Kind_ & kindMask);
            int conditionId = -1;
            if(condition == Chan) { conditionId = 0; }
            if(condition == Func) { conditionId = 1; }
            if(condition == Map) { conditionId = 2; }
            if(condition == Pointer) { conditionId = 3; }
            if(condition == Slice) { conditionId = 4; }
            if(condition == String) { conditionId = 5; }
            if(condition == UnsafePointer) { conditionId = 6; }
            else if(condition == Interface) { conditionId = 7; }
            else if(condition == Array) { conditionId = 8; }
            else if(condition == Struct) { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    for(; bv->n < uint32_t(offset / uintptr_t(goarch::PtrSize)); )
                    {
                        rec::append(gocpp::recv(bv), 0);
                    }
                    rec::append(gocpp::recv(bv), 1);
                    break;
                case 7:
                    for(; bv->n < uint32_t(offset / uintptr_t(goarch::PtrSize)); )
                    {
                        rec::append(gocpp::recv(bv), 0);
                    }
                    rec::append(gocpp::recv(bv), 1);
                    rec::append(gocpp::recv(bv), 1);
                    break;
                case 8:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    for(auto i = 0; i < int(tt->Len); i++)
                    {
                        addTypeBits(bv, offset + uintptr_t(i) * tt->Elem->Size_, tt->Elem);
                    }
                    break;
                case 9:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [i, gocpp_ignored] : tt->Fields)
                    {
                        auto f = & tt->Fields[i];
                        addTypeBits(bv, offset + f->Offset, f->Typ);
                    }
                    break;
            }
        }
    }

    struct Type TypeFor()
    {
        return rec::Elem(gocpp::recv(TypeOf((T*)(nullptr))));
    }

}

