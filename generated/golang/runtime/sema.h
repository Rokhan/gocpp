// generated by GoCpp from file '$(ImportDir)/runtime/sema.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/sema.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/cpu/cpu_x86.h"
#include "golang/runtime/cputicks.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mprof.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    struct semaRoot
    {
        mutex lock;
        sudog* treap;
        atomic::Uint32 nwait;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct semaRoot& value);
    semaRoot* rootFor(semTable* t, uint32_t* addr);
    void sync_runtime_Semacquire(uint32_t* addr);
    void poll_runtime_Semacquire(uint32_t* addr);
    void sync_runtime_Semrelease(uint32_t* addr, bool handoff, int skipframes);
    void sync_runtime_SemacquireMutex(uint32_t* addr, bool lifo, int skipframes);
    void sync_runtime_SemacquireRWMutexR(uint32_t* addr, bool lifo, int skipframes);
    void sync_runtime_SemacquireRWMutex(uint32_t* addr, bool lifo, int skipframes);
    void poll_runtime_Semrelease(uint32_t* addr);
    void readyWithTime(sudog* s, int traceskip);
    void semacquire(uint32_t* addr);
    void semacquire1(uint32_t* addr, bool lifo, semaProfileFlags profile, int skipframes, waitReason reason);
    void semrelease(uint32_t* addr);
    void semrelease1(uint32_t* addr, bool handoff, int skipframes);
    bool cansemacquire(uint32_t* addr);
    void queue(struct semaRoot* root, uint32_t* addr, sudog* s, bool lifo);
    std::tuple<sudog*, int64_t, int64_t> dequeue(struct semaRoot* root, uint32_t* addr);
    void rotateLeft(struct semaRoot* root, sudog* x);
    void rotateRight(struct semaRoot* root, sudog* y);
    struct notifyList
    {
        atomic::Uint32 wait;
        uint32_t notify;
        mutex lock;
        sudog* head;
        sudog* tail;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct notifyList& value);
    bool less(uint32_t a, uint32_t b);
    uint32_t notifyListAdd(notifyList* l);
    void notifyListWait(notifyList* l, uint32_t t);
    void notifyListNotifyAll(notifyList* l);
    void notifyListNotifyOne(notifyList* l);
    void notifyListCheck(uintptr_t sz);
    int64_t sync_nanotime();
}

