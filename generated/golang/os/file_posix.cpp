// generated by GoCpp from file '$(ImportDir)/os/file_posix.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file_posix.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_fsync_windows.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_posix.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir_windows.h"
#include "golang/os/error.h"
#include "golang/os/file.h"
#include "golang/os/file_windows.h"
#include "golang/os/path_windows.h"
#include "golang/os/types.h"
#include "golang/runtime/mfinal.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using fs::rec::Perm;
        using poll::rec::Fchdir;
        using poll::rec::Fchmod;
        using poll::rec::Fchown;
        using poll::rec::Fsync;
        using poll::rec::Ftruncate;
        using poll::rec::Pread;
        using poll::rec::Pwrite;
        using poll::rec::Read;
        using poll::rec::SetDeadline;
        using poll::rec::SetReadDeadline;
        using poll::rec::SetWriteDeadline;
        using poll::rec::Write;
        using time::rec::IsZero;
        using time::rec::UnixNano;
    }

    // Close closes the File, rendering it unusable for I/O.
    // On files that support SetDeadline, any pending I/O operations will
    // be canceled and return immediately with an ErrClosed error.
    // Close will return an error if it has already been called.
    struct gocpp::error rec::Close(struct File* f)
    {
        if(f == nullptr)
        {
            return ErrInvalid;
        }
        return rec::close(gocpp::recv(f->file));
    }

    // read reads up to len(b) bytes from the File.
    // It returns the number of bytes read and an error, if any.
    std::tuple<int, struct gocpp::error> rec::read(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Read(gocpp::recv(f->pfd), b);
        runtime::KeepAlive(f);
        return {n, err};
    }

    // pread reads len(b) bytes from the File starting at byte offset off.
    // It returns the number of bytes read and the error, if any.
    // EOF is signaled by a zero count with err set to nil.
    std::tuple<int, struct gocpp::error> rec::pread(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Pread(gocpp::recv(f->pfd), b, off);
        runtime::KeepAlive(f);
        return {n, err};
    }

    // write writes len(b) bytes to the File.
    // It returns the number of bytes written and an error, if any.
    std::tuple<int, struct gocpp::error> rec::write(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Write(gocpp::recv(f->pfd), b);
        runtime::KeepAlive(f);
        return {n, err};
    }

    // pwrite writes len(b) bytes to the File starting at byte offset off.
    // It returns the number of bytes written and an error, if any.
    std::tuple<int, struct gocpp::error> rec::pwrite(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Pwrite(gocpp::recv(f->pfd), b, off);
        runtime::KeepAlive(f);
        return {n, err};
    }

    // syscallMode returns the syscall-specific mode bits from Go's portable mode bits.
    uint32_t syscallMode(golang::os::FileMode i)
    {
        uint32_t o;
        o |= uint32_t(rec::Perm(gocpp::recv(i)));
        if(i & ModeSetuid != 0)
        {
            o |= syscall::S_ISUID;
        }
        if(i & ModeSetgid != 0)
        {
            o |= syscall::S_ISGID;
        }
        if(i & ModeSticky != 0)
        {
            o |= syscall::S_ISVTX;
        }
        return o;
    }

    // See docs in file.go:Chmod.
    struct gocpp::error chmod(std::string name, golang::os::FileMode mode)
    {
        auto longName = fixLongPath(name);
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Chmod(longName, syscallMode(mode));
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chmod"s;
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    // See docs in file.go:(*File).Chmod.
    struct gocpp::error rec::chmod(struct File* f, golang::os::FileMode mode)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "chmod"s); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fchmod(gocpp::recv(f->pfd), syscallMode(mode)); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "chmod"s, e);
        }
        return nullptr;
    }

    // Chown changes the numeric uid and gid of the named file.
    // If the file is a symbolic link, it changes the uid and gid of the link's target.
    // A uid or gid of -1 means to not change that value.
    // If there is an error, it will be of type *PathError.
    //
    // On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or
    // EPLAN9 error, wrapped in *PathError.
    struct gocpp::error Chown(std::string name, int uid, int gid)
    {
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Chown(name, uid, gid);
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chown"s;
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    // Lchown changes the numeric uid and gid of the named file.
    // If the file is a symbolic link, it changes the uid and gid of the link itself.
    // If there is an error, it will be of type *PathError.
    //
    // On Windows, it always returns the syscall.EWINDOWS error, wrapped
    // in *PathError.
    struct gocpp::error Lchown(std::string name, int uid, int gid)
    {
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Lchown(name, uid, gid);
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "lchown"s;
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    // Chown changes the numeric uid and gid of the named file.
    // If there is an error, it will be of type *PathError.
    //
    // On Windows, it always returns the syscall.EWINDOWS error, wrapped
    // in *PathError.
    struct gocpp::error rec::Chown(struct File* f, int uid, int gid)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "chown"s); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fchown(gocpp::recv(f->pfd), uid, gid); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "chown"s, e);
        }
        return nullptr;
    }

    // Truncate changes the size of the file.
    // It does not change the I/O offset.
    // If there is an error, it will be of type *PathError.
    struct gocpp::error rec::Truncate(struct File* f, int64_t size)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "truncate"s); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Ftruncate(gocpp::recv(f->pfd), size); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "truncate"s, e);
        }
        return nullptr;
    }

    // Sync commits the current contents of the file to stable storage.
    // Typically, this means flushing the file system's in-memory copy
    // of recently written data to disk.
    struct gocpp::error rec::Sync(struct File* f)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "sync"s); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fsync(gocpp::recv(f->pfd)); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "sync"s, e);
        }
        return nullptr;
    }

    // Chtimes changes the access and modification times of the named
    // file, similar to the Unix utime() or utimes() functions.
    // A zero time.Time value will leave the corresponding file time unchanged.
    //
    // The underlying filesystem may truncate or round the values to a
    // less precise time unit.
    // If there is an error, it will be of type *PathError.
    struct gocpp::error Chtimes(std::string name, mocklib::Date atime, mocklib::Date mtime)
    {
        gocpp::array<syscall::Timespec, 2> utimes = {};
        auto set = [=](int i, mocklib::Date t) mutable -> void
        {
            if(rec::IsZero(gocpp::recv(t)))
            {
                utimes[i] = gocpp::Init<syscall::Timespec>([=](auto& x) {
                    x.Sec = _UTIME_OMIT;
                    x.Nsec = _UTIME_OMIT;
                });
            }
            else
            {
                utimes[i] = syscall::NsecToTimespec(rec::UnixNano(gocpp::recv(t)));
            }
        };
        set(0, atime);
        set(1, mtime);
        if(auto e = syscall::UtimesNano(fixLongPath(name), utimes.make_slice(0)); e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chtimes"s;
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    // Chdir changes the current working directory to the file,
    // which must be a directory.
    // If there is an error, it will be of type *PathError.
    struct gocpp::error rec::Chdir(struct File* f)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "chdir"s); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fchdir(gocpp::recv(f->pfd)); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "chdir"s, e);
        }
        return nullptr;
    }

    // setDeadline sets the read and write deadline.
    struct gocpp::error rec::setDeadline(struct File* f, mocklib::Date t)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SetDeadline"s); err != nullptr)
        {
            return err;
        }
        return rec::SetDeadline(gocpp::recv(f->pfd), t);
    }

    // setReadDeadline sets the read deadline.
    struct gocpp::error rec::setReadDeadline(struct File* f, mocklib::Date t)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SetReadDeadline"s); err != nullptr)
        {
            return err;
        }
        return rec::SetReadDeadline(gocpp::recv(f->pfd), t);
    }

    // setWriteDeadline sets the write deadline.
    struct gocpp::error rec::setWriteDeadline(struct File* f, mocklib::Date t)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SetWriteDeadline"s); err != nullptr)
        {
            return err;
        }
        return rec::SetWriteDeadline(gocpp::recv(f->pfd), t);
    }

    // checkValid checks whether f is valid for use.
    // If not, it returns an appropriate error, perhaps incorporating the operation name op.
    struct gocpp::error rec::checkValid(struct File* f, std::string op)
    {
        if(f == nullptr)
        {
            return ErrInvalid;
        }
        return nullptr;
    }

    // ignoringEINTR makes a function call and repeats it if it returns an
    // EINTR error. This appears to be required even though we install all
    // signal handlers with SA_RESTART: see #22838, #38033, #38836, #40846.
    // Also #20400 and #36644 are issues in which a signal handler is
    // installed without setting SA_RESTART. None of these are the common case,
    // but there are enough of them that it seems that we can't avoid
    // an EINTR loop.
    struct gocpp::error ignoringEINTR(std::function<struct gocpp::error ()> fn)
    {
        for(; ; )
        {
            auto err = fn();
            if(err != syscall::go_EINTR)
            {
                return err;
            }
        }
    }

}

