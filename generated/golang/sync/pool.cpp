// generated by GoCpp from file '$(ImportDir)/sync/pool.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/pool.h"
#include "gocpp/support.h"

// #include "golang/internal/race/norace.h"  [Ignored, known errors]
#include "golang/runtime/debug.h"
// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/atomic/type.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/mutex.h"
#include "golang/sync/poolqueue.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Pool::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.local = this->local;
        result.localSize = this->localSize;
        result.victim = this->victim;
        result.victimSize = this->victimSize;
        result.New = this->New;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Pool::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (local != ref.local) return false;
        if (localSize != ref.localSize) return false;
        if (victim != ref.victim) return false;
        if (victimSize != ref.victimSize) return false;
        if (New != ref.New) return false;
        return true;
    }

    std::ostream& Pool::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << local;
        os << " " << localSize;
        os << " " << victim;
        os << " " << victimSize;
        os << " " << New;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Pool& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    poolLocalInternal::operator T()
    {
        T result;
        result.go_private = this->go_private;
        result.shared = this->shared;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolLocalInternal::operator==(const T& ref) const
    {
        if (go_private != ref.go_private) return false;
        if (shared != ref.shared) return false;
        return true;
    }

    std::ostream& poolLocalInternal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << go_private;
        os << " " << shared;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolLocalInternal& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    poolLocal::operator T()
    {
        T result;
        result.pad = this->pad;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolLocal::operator==(const T& ref) const
    {
        if (pad != ref.pad) return false;
        return true;
    }

    std::ostream& poolLocal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolLocal& value)
    {
        return value.PrintTo(os);
    }

    uint32_t runtime_randn(uint32_t n)
    /* convertBlockStmt, nil block */;

    gocpp::array<uint64_t, 128> poolRaceHash;
    unsafe::Pointer poolRaceAddr(go_any x)
    {
        auto ptr = uintptr_t((gocpp::array<unsafe::Pointer, 2>*)(unsafe::Pointer(& x))[1]);
        auto h = uint32_t((uint64_t(uint32_t(ptr)) * 0x85ebca6b) >> 16);
        return unsafe::Pointer(& poolRaceHash[h % uint32_t(len(poolRaceHash))]);
    }

    void Put(struct Pool* p, go_any x)
    {
        if(x == nullptr)
        {
            return;
        }
        if(race::Enabled)
        {
            if(runtime_randn(4) == 0)
            {
                return;
            }
            race::ReleaseMerge(poolRaceAddr(x));
            race::Disable();
        }
        auto [l, gocpp_id_1] = pin(gocpp::recv(p));
        if(l->go_private == nullptr)
        {
            l->go_private = x;
        }
        else
        {
            pushHead(gocpp::recv(l->shared), x);
        }
        runtime_procUnpin();
        if(race::Enabled)
        {
            race::Enable();
        }
    }

    go_any Get(struct Pool* p)
    {
        if(race::Enabled)
        {
            race::Disable();
        }
        auto [l, pid] = pin(gocpp::recv(p));
        auto x = l->go_private;
        l->go_private = nullptr;
        if(x == nullptr)
        {
            std::tie(x, gocpp_id_2) = popHead(gocpp::recv(l->shared));
            if(x == nullptr)
            {
                x = getSlow(gocpp::recv(p), pid);
            }
        }
        runtime_procUnpin();
        if(race::Enabled)
        {
            race::Enable();
            if(x != nullptr)
            {
                race::Acquire(poolRaceAddr(x));
            }
        }
        if(x == nullptr && p->New != nullptr)
        {
            x = New(gocpp::recv(p));
        }
        return x;
    }

    go_any getSlow(struct Pool* p, int pid)
    {
        auto size = runtime_LoadAcquintptr(& p->localSize);
        auto locals = p->local;
        for(auto i = 0; i < int(size); i++)
        {
            auto l = indexLocal(locals, (pid + i + 1) % int(size));
            if(auto [x, gocpp_id_4] = popTail(gocpp::recv(l->shared)); x != nullptr)
            {
                return x;
            }
        }
        size = atomic::LoadUintptr(& p->victimSize);
        if(uintptr_t(pid) >= size)
        {
            return nullptr;
        }
        locals = p->victim;
        auto l = indexLocal(locals, pid);
        if(auto x = l->go_private; x != nullptr)
        {
            l->go_private = nullptr;
            return x;
        }
        for(auto i = 0; i < int(size); i++)
        {
            auto l = indexLocal(locals, (pid + i) % int(size));
            if(auto [x, gocpp_id_6] = popTail(gocpp::recv(l->shared)); x != nullptr)
            {
                return x;
            }
        }
        atomic::StoreUintptr(& p->victimSize, 0);
        return nullptr;
    }

    std::tuple<poolLocal*, int> pin(struct Pool* p)
    {
        if(p == nullptr)
        {
            gocpp::panic("nil Pool");
        }
        auto pid = runtime_procPin();
        auto s = runtime_LoadAcquintptr(& p->localSize);
        auto l = p->local;
        if(uintptr_t(pid) < s)
        {
            return {indexLocal(l, pid), pid};
        }
        return pinSlow(gocpp::recv(p));
    }

    std::tuple<poolLocal*, int> pinSlow(struct Pool* p)
    {
        gocpp::Defer defer;
        runtime_procUnpin();
        Lock(gocpp::recv(allPoolsMu));
        defer.push_back([=]{ Unlock(gocpp::recv(allPoolsMu)); });
        auto pid = runtime_procPin();
        auto s = p->localSize;
        auto l = p->local;
        if(uintptr_t(pid) < s)
        {
            return {indexLocal(l, pid), pid};
        }
        if(p->local == nullptr)
        {
            allPools = append(allPools, p);
        }
        auto size = runtime::GOMAXPROCS(0);
        auto local = gocpp::make(gocpp::Tag<gocpp::slice<poolLocal>>(), size);
        atomic::StorePointer(& p->local, unsafe::Pointer(& local[0]));
        runtime_StoreReluintptr(& p->localSize, uintptr_t(size));
        return {& local[pid], pid};
    }

    void poolCleanup()
    {
        for(auto [_, p] : oldPools)
        {
            p->victim = nullptr;
            p->victimSize = 0;
        }
        for(auto [_, p] : allPools)
        {
            p->victim = p->local;
            p->victimSize = p->localSize;
            p->local = nullptr;
            p->localSize = 0;
        }
        std::tie(oldPools, allPools) = std::tuple{allPools, nullptr};
    }

    Mutex allPoolsMu;
    gocpp::slice<Pool*> allPools;
    gocpp::slice<Pool*> oldPools;
    void init()
    {
        runtime_registerPoolCleanup(poolCleanup);
    }

    poolLocal* indexLocal(unsafe::Pointer l, int i)
    {
        auto lp = unsafe::Pointer(uintptr_t(l) + uintptr_t(i) * gocpp::Sizeof<poolLocal>());
        return (poolLocal*)(lp);
    }

    void runtime_registerPoolCleanup(std::function<void ()> cleanup)
    /* convertBlockStmt, nil block */;

    int runtime_procPin()
    /* convertBlockStmt, nil block */;

    void runtime_procUnpin()
    /* convertBlockStmt, nil block */;

    uintptr_t runtime_LoadAcquintptr(uintptr_t* ptr)
    /* convertBlockStmt, nil block */;

    uintptr_t runtime_StoreReluintptr(uintptr_t* ptr, uintptr_t val)
    /* convertBlockStmt, nil block */;

}

