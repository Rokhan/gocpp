// generated by GoCpp from file '$(ImportDir)/runtime/internal/sys/nih.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/internal/sys/nih.h"
#include "gocpp/support.h"

namespace golang::sys
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // NOTE: keep in sync with cmd/compile/internal/types.CalcSize
    // to make the compiler recognize this as an intrinsic type.
    
    template<typename T> requires gocpp::GoStruct<T>
    nih::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool nih::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& nih::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nih& value)
    {
        return value.PrintTo(os);
    }

    // NotInHeap is a type must never be allocated from the GC'd heap or on the stack,
    // and is called not-in-heap.
    //
    // Other types can embed NotInHeap to make it not-in-heap. Specifically, pointers
    // to these types must always fail the `runtime.inheap` check. The type may be used
    // for global variables, or for objects in unmanaged memory (e.g., allocated with
    // `sysAlloc`, `persistentalloc`, r`fixalloc`, or from a manually-managed span).
    //
    // Specifically:
    //
    // 1. `new(T)`, `make([]T)`, `append([]T, ...)` and implicit heap
    // allocation of T are disallowed. (Though implicit allocations are
    // disallowed in the runtime anyway.)
    //
    // 2. A pointer to a regular type (other than `unsafe.Pointer`) cannot be
    // converted to a pointer to a not-in-heap type, even if they have the
    // same underlying type.
    //
    // 3. Any type that containing a not-in-heap type is itself considered as not-in-heap.
    //
    // - Structs and arrays are not-in-heap if their elements are not-in-heap.
    // - Maps and channels contains no-in-heap types are disallowed.
    //
    // 4. Write barriers on pointers to not-in-heap types can be omitted.
    //
    // The last point is the real benefit of NotInHeap. The runtime uses
    // it for low-level internal structures to avoid memory barriers in the
    // scheduler and the memory allocator where they are illegal or simply
    // inefficient. This mechanism is reasonably safe and does not compromise
    // the readability of the runtime.
    
    template<typename T> requires gocpp::GoStruct<T>
    NotInHeap::operator T()
    {
        T result;
        result._1 = this->_1;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NotInHeap::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        return true;
    }

    std::ostream& NotInHeap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NotInHeap& value)
    {
        return value.PrintTo(os);
    }

}

