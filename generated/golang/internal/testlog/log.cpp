// generated by GoCpp from file '$(ImportDir)/internal/testlog/log.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/testlog/log.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/value.h"

namespace golang::testlog
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace atomic::rec;
    }

    
    template<typename T>
    Interface::Interface(T& ref)
    {
        value.reset(new InterfaceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Interface::Interface(const T& ref)
    {
        value.reset(new InterfaceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Interface::Interface(T* ptr)
    {
        value.reset(new InterfaceImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Interface::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vGetenv(std::string key)
    {
        return rec::Getenv(gocpp::PtrRecv<T, false>(value.get()), key);
    }
    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vStat(std::string file)
    {
        return rec::Stat(gocpp::PtrRecv<T, false>(value.get()), file);
    }
    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vOpen(std::string file)
    {
        return rec::Open(gocpp::PtrRecv<T, false>(value.get()), file);
    }
    template<typename T, typename StoreT>
    void Interface::InterfaceImpl<T, StoreT>::vChdir(std::string dir)
    {
        return rec::Chdir(gocpp::PtrRecv<T, false>(value.get()), dir);
    }

    namespace rec
    {
        void Getenv(const gocpp::PtrRecv<struct Interface, false>& self, std::string key)
        {
            return self.ptr->value->vGetenv(key);
        }

        void Getenv(const gocpp::ObjRecv<struct Interface>& self, std::string key)
        {
            return self.obj.value->vGetenv(key);
        }

        void Stat(const gocpp::PtrRecv<struct Interface, false>& self, std::string file)
        {
            return self.ptr->value->vStat(file);
        }

        void Stat(const gocpp::ObjRecv<struct Interface>& self, std::string file)
        {
            return self.obj.value->vStat(file);
        }

        void Open(const gocpp::PtrRecv<struct Interface, false>& self, std::string file)
        {
            return self.ptr->value->vOpen(file);
        }

        void Open(const gocpp::ObjRecv<struct Interface>& self, std::string file)
        {
            return self.obj.value->vOpen(file);
        }

        void Chdir(const gocpp::PtrRecv<struct Interface, false>& self, std::string dir)
        {
            return self.ptr->value->vChdir(dir);
        }

        void Chdir(const gocpp::ObjRecv<struct Interface>& self, std::string dir)
        {
            return self.obj.value->vChdir(dir);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Interface& value)
    {
        return value.PrintTo(os);
    }

    atomic::Value logger;
    void SetLogger(struct Interface impl)
    {
        if(rec::Load(gocpp::recv(logger)) != nullptr)
        {
            gocpp::panic("testlog: SetLogger must be called only once");
        }
        rec::Store(gocpp::recv(logger), & impl);
    }

    struct Interface Logger()
    {
        auto impl = rec::Load(gocpp::recv(logger));
        if(impl == nullptr)
        {
            return nullptr;
        }
        return *gocpp::getValue<Interface*>(impl);
    }

    void Getenv(std::string name)
    {
        if(auto log = Logger(); log != nullptr)
        {
            rec::Getenv(gocpp::recv(log), name);
        }
    }

    void Open(std::string name)
    {
        if(auto log = Logger(); log != nullptr)
        {
            rec::Open(gocpp::recv(log), name);
        }
    }

    void Stat(std::string name)
    {
        if(auto log = Logger(); log != nullptr)
        {
            rec::Stat(gocpp::recv(log), name);
        }
    }

}

