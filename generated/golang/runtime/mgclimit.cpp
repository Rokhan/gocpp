// generated by GoCpp from file '$(ImportDir)/runtime/mgclimit.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgclimit.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using atomic::rec::Swap;
    }

    // gcCPULimiter is a mechanism to limit GC CPU utilization in situations
    // where it might become excessive and inhibit application progress (e.g.
    // a death spiral).
    //
    // The core of the limiter is a leaky bucket mechanism that fills with GC
    // CPU time and drains with mutator time. Because the bucket fills and
    // drains with time directly (i.e. without any weighting), this effectively
    // sets a very conservative limit of 50%. This limit could be enforced directly,
    // however, but the purpose of the bucket is to accommodate spikes in GC CPU
    // utilization without hurting throughput.
    //
    // Note that the bucket in the leaky bucket mechanism can never go negative,
    // so the GC never gets credit for a lot of CPU time spent without the GC
    // running. This is intentional, as an application that stays idle for, say,
    // an entire day, could build up enough credit to fail to prevent a death
    // spiral the following day. The bucket's capacity is the GC's only leeway.
    //
    // The capacity thus also sets the window the limiter considers. For example,
    // if the capacity of the bucket is 1 cpu-second, then the limiter will not
    // kick in until at least 1 full cpu-second in the last 2 cpu-second window
    // is spent on GC CPU time.
    gcCPULimiterState gcCPULimiter;
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.fill = this->fill;
        result.capacity = this->capacity;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (fill != ref.fill) return false;
        if (capacity != ref.capacity) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fill;
        os << " " << capacity;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    gcCPULimiterState::operator T()
    {
        T result;
        result.lock = this->lock;
        result.enabled = this->enabled;
        result.bucket = this->bucket;
        result.overflow = this->overflow;
        result.gcEnabled = this->gcEnabled;
        result.transitioning = this->transitioning;
        result.assistTimePool = this->assistTimePool;
        result.idleMarkTimePool = this->idleMarkTimePool;
        result.idleTimePool = this->idleTimePool;
        result.lastUpdate = this->lastUpdate;
        result.lastEnabledCycle = this->lastEnabledCycle;
        result.nprocs = this->nprocs;
        result.test = this->test;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcCPULimiterState::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (enabled != ref.enabled) return false;
        if (bucket != ref.bucket) return false;
        if (overflow != ref.overflow) return false;
        if (gcEnabled != ref.gcEnabled) return false;
        if (transitioning != ref.transitioning) return false;
        if (assistTimePool != ref.assistTimePool) return false;
        if (idleMarkTimePool != ref.idleMarkTimePool) return false;
        if (idleTimePool != ref.idleTimePool) return false;
        if (lastUpdate != ref.lastUpdate) return false;
        if (lastEnabledCycle != ref.lastEnabledCycle) return false;
        if (nprocs != ref.nprocs) return false;
        if (test != ref.test) return false;
        return true;
    }

    std::ostream& gcCPULimiterState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << enabled;
        os << " " << bucket;
        os << " " << overflow;
        os << " " << gcEnabled;
        os << " " << transitioning;
        os << " " << assistTimePool;
        os << " " << idleMarkTimePool;
        os << " " << idleTimePool;
        os << " " << lastUpdate;
        os << " " << lastEnabledCycle;
        os << " " << nprocs;
        os << " " << test;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcCPULimiterState& value)
    {
        return value.PrintTo(os);
    }

    // limiting returns true if the CPU limiter is currently enabled, meaning the Go GC
    // should take action to limit CPU utilization.
    //
    // It is safe to call concurrently with other operations.
    bool rec::limiting(struct gcCPULimiterState* l)
    {
        return rec::Load(gocpp::recv(l->enabled));
    }

    // startGCTransition notifies the limiter of a GC transition.
    //
    // This call takes ownership of the limiter and disables all other means of
    // updating the limiter. Release ownership by calling finishGCTransition.
    //
    // It is safe to call concurrently with other operations.
    void rec::startGCTransition(struct gcCPULimiterState* l, bool enableGC, int64_t now)
    {
        if(! rec::tryLock(gocpp::recv(l)))
        {
            go_throw("failed to acquire lock to start a GC transition"s);
        }
        if(l->gcEnabled == enableGC)
        {
            go_throw("transitioning GC to the same state as before?"s);
        }
        rec::updateLocked(gocpp::recv(l), now);
        l->gcEnabled = enableGC;
        l->transitioning = true;
    }

    // finishGCTransition notifies the limiter that the GC transition is complete
    // and releases ownership of it. It also accumulates STW time in the bucket.
    // now must be the timestamp from the end of the STW pause.
    void rec::finishGCTransition(struct gcCPULimiterState* l, int64_t now)
    {
        if(! l->transitioning)
        {
            go_throw("finishGCTransition called without starting one?"s);
        }
        if(auto lastUpdate = rec::Load(gocpp::recv(l->lastUpdate)); now >= lastUpdate)
        {
            rec::accumulate(gocpp::recv(l), 0, (now - lastUpdate) * int64_t(l->nprocs));
        }
        rec::Store(gocpp::recv(l->lastUpdate), now);
        l->transitioning = false;
        rec::unlock(gocpp::recv(l));
    }

    // gcCPULimiterUpdatePeriod dictates the maximum amount of wall-clock time
    // we can go before updating the limiter.
    // needUpdate returns true if the limiter's maximum update period has been
    // exceeded, and so would benefit from an update.
    bool rec::needUpdate(struct gcCPULimiterState* l, int64_t now)
    {
        return now - rec::Load(gocpp::recv(l->lastUpdate)) > gcCPULimiterUpdatePeriod;
    }

    // addAssistTime notifies the limiter of additional assist time. It will be
    // included in the next update.
    void rec::addAssistTime(struct gcCPULimiterState* l, int64_t t)
    {
        rec::Add(gocpp::recv(l->assistTimePool), t);
    }

    // addIdleTime notifies the limiter of additional time a P spent on the idle list. It will be
    // subtracted from the total CPU time in the next update.
    void rec::addIdleTime(struct gcCPULimiterState* l, int64_t t)
    {
        rec::Add(gocpp::recv(l->idleTimePool), t);
    }

    // update updates the bucket given runtime-specific information. now is the
    // current monotonic time in nanoseconds.
    //
    // This is safe to call concurrently with other operations, except *GCTransition.
    void rec::update(struct gcCPULimiterState* l, int64_t now)
    {
        if(! rec::tryLock(gocpp::recv(l)))
        {
            return;
        }
        if(l->transitioning)
        {
            go_throw("update during transition"s);
        }
        rec::updateLocked(gocpp::recv(l), now);
        rec::unlock(gocpp::recv(l));
    }

    // updateLocked is the implementation of update. l.lock must be held.
    void rec::updateLocked(struct gcCPULimiterState* l, int64_t now)
    {
        auto lastUpdate = rec::Load(gocpp::recv(l->lastUpdate));
        if(now < lastUpdate)
        {
            return;
        }
        auto windowTotalTime = (now - lastUpdate) * int64_t(l->nprocs);
        rec::Store(gocpp::recv(l->lastUpdate), now);
        auto assistTime = rec::Load(gocpp::recv(l->assistTimePool));
        if(assistTime != 0)
        {
            rec::Add(gocpp::recv(l->assistTimePool), - assistTime);
        }
        auto idleTime = rec::Load(gocpp::recv(l->idleTimePool));
        if(idleTime != 0)
        {
            rec::Add(gocpp::recv(l->idleTimePool), - idleTime);
        }
        if(! l->test)
        {
            auto mp = acquirem();
            for(auto [gocpp_ignored, pp] : allp)
            {
                auto [typ, duration] = rec::consume(gocpp::recv(pp->limiterEvent), now);
                //Go switch emulation
                {
                    auto condition = typ;
                    int conditionId = -1;
                    if(condition == limiterEventIdleMarkWork) { conditionId = 0; }
                    else if(condition == limiterEventIdle) { conditionId = 1; }
                    else if(condition == limiterEventMarkAssist) { conditionId = 2; }
                    else if(condition == limiterEventScavengeAssist) { conditionId = 3; }
                    else if(condition == limiterEventNone) { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                            idleTime += duration;
                            rec::Add(gocpp::recv(sched.idleTime), duration);
                            break;
                        case 2:
                        case 3:
                            assistTime += duration;
                            break;
                        case 4:
                            break;
                            break;
                        default:
                            go_throw("invalid limiter event type found"s);
                            break;
                    }
                }
            }
            releasem(mp);
        }
        auto windowGCTime = assistTime;
        if(l->gcEnabled)
        {
            windowGCTime += int64_t(double(windowTotalTime) * gcBackgroundUtilization);
        }
        windowTotalTime -= idleTime;
        rec::accumulate(gocpp::recv(l), windowTotalTime - windowGCTime, windowGCTime);
    }

    // accumulate adds time to the bucket and signals whether the limiter is enabled.
    //
    // This is an internal function that deals just with the bucket. Prefer update.
    // l.lock must be held.
    void rec::accumulate(struct gcCPULimiterState* l, int64_t mutatorTime, int64_t gcTime)
    {
        auto headroom = l->bucket.capacity - l->bucket.fill;
        auto enabled = headroom == 0;
        auto change = gcTime - mutatorTime;
        if(change > 0 && headroom <= uint64_t(change))
        {
            l->overflow += uint64_t(change) - headroom;
            l->bucket.fill = l->bucket.capacity;
            if(! enabled)
            {
                rec::Store(gocpp::recv(l->enabled), true);
                rec::Store(gocpp::recv(l->lastEnabledCycle), memstats.numgc + 1);
            }
            return;
        }
        if(change < 0 && l->bucket.fill <= uint64_t(- change))
        {
            l->bucket.fill = 0;
        }
        else
        {
            l->bucket.fill -= uint64_t(- change);
        }
        if(change != 0 && enabled)
        {
            rec::Store(gocpp::recv(l->enabled), false);
        }
    }

    // tryLock attempts to lock l. Returns true on success.
    bool rec::tryLock(struct gcCPULimiterState* l)
    {
        return rec::CompareAndSwap(gocpp::recv(l->lock), 0, 1);
    }

    // unlock releases the lock on l. Must be called if tryLock returns true.
    void rec::unlock(struct gcCPULimiterState* l)
    {
        auto old = rec::Swap(gocpp::recv(l->lock), 0);
        if(old != 1)
        {
            go_throw("double unlock"s);
        }
    }

    // capacityPerProc is the limiter's bucket capacity for each P in GOMAXPROCS.
    // resetCapacity updates the capacity based on GOMAXPROCS. Must not be called
    // while the GC is enabled.
    //
    // It is safe to call concurrently with other operations.
    void rec::resetCapacity(struct gcCPULimiterState* l, int64_t now, int32_t nprocs)
    {
        if(! rec::tryLock(gocpp::recv(l)))
        {
            go_throw("failed to acquire lock to reset capacity"s);
        }
        rec::updateLocked(gocpp::recv(l), now);
        l->nprocs = nprocs;
        l->bucket.capacity = uint64_t(nprocs) * capacityPerProc;
        if(l->bucket.fill > l->bucket.capacity)
        {
            l->bucket.fill = l->bucket.capacity;
            rec::Store(gocpp::recv(l->enabled), true);
            rec::Store(gocpp::recv(l->lastEnabledCycle), memstats.numgc + 1);
        }
        else
        if(l->bucket.fill < l->bucket.capacity)
        {
            rec::Store(gocpp::recv(l->enabled), false);
        }
        rec::unlock(gocpp::recv(l));
    }

    // limiterEventType indicates the type of an event occurring on some P.
    //
    // These events represent the full set of events that the GC CPU limiter tracks
    // to execute its function.
    //
    // This type may use no more than limiterEventBits bits of information.
    // limiterEventTypeMask is a mask for the bits in p.limiterEventStart that represent
    // the event type. The rest of the bits of that field represent a timestamp.
    // limiterEventStamp is a nanotime timestamp packed with a limiterEventType.
    // makeLimiterEventStamp creates a new stamp from the event type and the current timestamp.
    runtime::limiterEventStamp makeLimiterEventStamp(golang::runtime::limiterEventType typ, int64_t now)
    {
        return limiterEventStamp((uint64_t(typ) << (64 - limiterEventBits)) | (uint64_t(now) &^ limiterEventTypeMask));
    }

    // duration computes the difference between now and the start time stored in the stamp.
    //
    // Returns 0 if the difference is negative, which may happen if now is stale or if the
    // before and after timestamps cross a 2^(64-limiterEventBits) boundary.
    int64_t rec::duration(golang::runtime::limiterEventStamp s, int64_t now)
    {
        auto start = int64_t((uint64_t(now) & limiterEventTypeMask) | (uint64_t(s) &^ limiterEventTypeMask));
        if(now < start)
        {
            return 0;
        }
        return now - start;
    }

    // type extracts the event type from the stamp.
    runtime::limiterEventType rec::typ(golang::runtime::limiterEventStamp s)
    {
        return limiterEventType(s >> (64 - limiterEventBits));
    }

    // limiterEvent represents tracking state for an event tracked by the GC CPU limiter.
    
    template<typename T> requires gocpp::GoStruct<T>
    limiterEvent::operator T()
    {
        T result;
        result.stamp = this->stamp;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool limiterEvent::operator==(const T& ref) const
    {
        if (stamp != ref.stamp) return false;
        return true;
    }

    std::ostream& limiterEvent::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stamp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct limiterEvent& value)
    {
        return value.PrintTo(os);
    }

    // start begins tracking a new limiter event of the current type. If an event
    // is already in flight, then a new event cannot begin because the current time is
    // already being attributed to that event. In this case, this function returns false.
    // Otherwise, it returns true.
    //
    // The caller must be non-preemptible until at least stop is called or this function
    // returns false. Because this is trying to measure "on-CPU" time of some event, getting
    // scheduled away during it can mean that whatever we're measuring isn't a reflection
    // of "on-CPU" time. The OS could deschedule us at any time, but we want to maintain as
    // close of an approximation as we can.
    bool rec::start(struct limiterEvent* e, golang::runtime::limiterEventType typ, int64_t now)
    {
        if(rec::typ(gocpp::recv(limiterEventStamp(rec::Load(gocpp::recv(e->stamp))))) != limiterEventNone)
        {
            return false;
        }
        rec::Store(gocpp::recv(e->stamp), uint64_t(makeLimiterEventStamp(typ, now)));
        return true;
    }

    // consume acquires the partial event CPU time from any in-flight event.
    // It achieves this by storing the current time as the new event time.
    //
    // Returns the type of the in-flight event, as well as how long it's currently been
    // executing for. Returns limiterEventNone if no event is active.
    std::tuple<runtime::limiterEventType, int64_t> rec::consume(struct limiterEvent* e, int64_t now)
    {
        runtime::limiterEventType typ;
        int64_t duration;
        for(; ; )
        {
            auto old = limiterEventStamp(rec::Load(gocpp::recv(e->stamp)));
            typ = rec::typ(gocpp::recv(old));
            if(typ == limiterEventNone)
            {
                return {typ, duration};
            }
            duration = rec::duration(gocpp::recv(old), now);
            if(duration == 0)
            {
                return {limiterEventNone, 0};
            }
            auto go_new = makeLimiterEventStamp(typ, now);
            if(rec::CompareAndSwap(gocpp::recv(e->stamp), uint64_t(old), uint64_t(go_new)))
            {
                break;
            }
        }
        return {typ, duration};
    }

    // stop stops the active limiter event. Throws if the
    //
    // The caller must be non-preemptible across the event. See start as to why.
    void rec::stop(struct limiterEvent* e, golang::runtime::limiterEventType typ, int64_t now)
    {
        runtime::limiterEventStamp stamp = {};
        for(; ; )
        {
            stamp = limiterEventStamp(rec::Load(gocpp::recv(e->stamp)));
            if(rec::typ(gocpp::recv(stamp)) != typ)
            {
                print("runtime: want="s, typ, " got="s, rec::typ(gocpp::recv(stamp)), "\n"s);
                go_throw("limiterEvent.stop: found wrong event in p's limiter event slot"s);
            }
            if(rec::CompareAndSwap(gocpp::recv(e->stamp), uint64_t(stamp), uint64_t(limiterEventStampNone)))
            {
                break;
            }
        }
        auto duration = rec::duration(gocpp::recv(stamp), now);
        if(duration == 0)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == limiterEventIdleMarkWork) { conditionId = 0; }
            else if(condition == limiterEventIdle) { conditionId = 1; }
            else if(condition == limiterEventMarkAssist) { conditionId = 2; }
            else if(condition == limiterEventScavengeAssist) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    rec::addIdleTime(gocpp::recv(gcCPULimiter), duration);
                    break;
                case 1:
                    rec::addIdleTime(gocpp::recv(gcCPULimiter), duration);
                    rec::Add(gocpp::recv(sched.idleTime), duration);
                    break;
                case 2:
                case 3:
                    rec::addAssistTime(gocpp::recv(gcCPULimiter), duration);
                    break;
                default:
                    go_throw("limiterEvent.stop: invalid limiter event type found"s);
                    break;
            }
        }
    }

}

