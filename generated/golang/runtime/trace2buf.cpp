// generated by GoCpp from file '$(ImportDir)/runtime/trace2buf.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2buf.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mem.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/trace2event.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    int traceBytesPerNumber = 10;
    
    std::ostream& traceWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceWriter& value)
    {
        return value.PrintTo(os);
    }

    traceWriter writer(struct traceLocker tl)
    {
        return gocpp::Init<traceWriter>([](traceWriter& x) { x.traceLocker = tl; x.traceBuf = tl.mp->trace.buf[tl.gen % 2]; });
    }

    traceWriter unsafeTraceWriter(uintptr_t gen, traceBuf* buf)
    {
        return gocpp::Init<traceWriter>([](traceWriter& x) { x.traceLocker = gocpp::Init<traceLocker>([](traceLocker& x) { x.gen = gen; }); x.traceBuf = buf; });
    }

    void end(struct traceWriter w)
    {
        if(w.mp == nullptr)
        {
            return;
        }
        w.mp->trace.buf[w.gen % 2] = w.traceBuf;
    }

    std::tuple<traceWriter, bool> ensure(struct traceWriter w, int maxSize)
    {
        auto refill = w.traceBuf == nullptr || ! available(gocpp::recv(w), maxSize);
        if(refill)
        {
            w = refill(gocpp::recv(w));
        }
        return {w, refill};
    }

    traceWriter flush(struct traceWriter w)
    {
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(w.traceBuf != nullptr)
            {
                traceBufFlush(w.traceBuf, w.gen);
            }
            unlock(& trace.lock);
        }
);
        w.traceBuf = nullptr;
        return w;
    }

    traceWriter refill(struct traceWriter w)
    {
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(w.traceBuf != nullptr)
            {
                traceBufFlush(w.traceBuf, w.gen);
            }
            if(trace.empty != nullptr)
            {
                w.traceBuf = trace.empty;
                trace.empty = w.traceBuf->link;
                unlock(& trace.lock);
            }
            else
            {
                unlock(& trace.lock);
                w.traceBuf = (traceBuf*)(sysAlloc(Sizeof(gocpp::recv(unsafe), traceBuf {}), & memstats.other_sys));
                if(w.traceBuf == nullptr)
                {
                    go_throw("trace: out of memory");
                }
            }
        }
);
        auto ts = traceClockNow();
        if(ts <= w.traceBuf->lastTime)
        {
            ts = w.traceBuf->lastTime + 1;
        }
        w.traceBuf->lastTime = ts;
        w.traceBuf->link = nullptr;
        w.traceBuf->pos = 0;
        auto mID = ^ uint64_t(0);
        if(w.mp != nullptr)
        {
            mID = uint64_t(w.mp->procid);
        }
        byte(gocpp::recv(w), byte(traceEvEventBatch));
        varint(gocpp::recv(w), uint64_t(w.gen));
        varint(gocpp::recv(w), uint64_t(mID));
        varint(gocpp::recv(w), uint64_t(ts));
        w.traceBuf->lenPos = varintReserve(gocpp::recv(w));
        return w;
    }

    
    std::ostream& traceBufQueue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBufQueue& value)
    {
        return value.PrintTo(os);
    }

    void push(struct traceBufQueue* q, traceBuf* buf)
    {
        buf->link = nullptr;
        if(q->head == nullptr)
        {
            q->head = buf;
        }
        else
        {
            q->tail->link = buf;
        }
        q->tail = buf;
    }

    traceBuf* pop(struct traceBufQueue* q)
    {
        auto buf = q->head;
        if(buf == nullptr)
        {
            return nullptr;
        }
        q->head = buf->link;
        if(q->head == nullptr)
        {
            q->tail = nullptr;
        }
        buf->link = nullptr;
        return buf;
    }

    bool empty(struct traceBufQueue* q)
    {
        return q->head == nullptr;
    }

    
    std::ostream& traceBufHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << link;
        os << " " << lastTime;
        os << " " << pos;
        os << " " << lenPos;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBufHeader& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& traceBuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << arr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBuf& value)
    {
        return value.PrintTo(os);
    }

    void byte(struct traceBuf* buf, unsigned char v)
    {
        buf->arr[buf->pos] = v;
        buf->pos++;
    }

    void varint(struct traceBuf* buf, uint64_t v)
    {
        auto pos = buf->pos;
        auto arr = buf->arr.make_slice(pos, pos + traceBytesPerNumber);
        for(auto [i, gocpp_ignored] : arr)
        {
            if(v < 0x80)
            {
                pos += i + 1;
                arr[i] = byte(v);
                break;
            }
            arr[i] = 0x80 | byte(v);
            v >>= 7;
        }
        buf->pos = pos;
    }

    int varintReserve(struct traceBuf* buf)
    {
        auto p = buf->pos;
        buf->pos += traceBytesPerNumber;
        return p;
    }

    void stringData(struct traceBuf* buf, std::string s)
    {
        buf->pos += copy(buf->arr.make_slice(buf->pos), s);
    }

    bool available(struct traceBuf* buf, int size)
    {
        return len(buf->arr) - buf->pos >= size;
    }

    void varintAt(struct traceBuf* buf, int pos, uint64_t v)
    {
        for(auto i = 0; i < traceBytesPerNumber; i++)
        {
            if(i < traceBytesPerNumber - 1)
            {
                buf->arr[pos] = 0x80 | byte(v);
            }
            else
            {
                buf->arr[pos] = byte(v);
            }
            v >>= 7;
            pos++;
        }
        if(v != 0)
        {
            go_throw("v could not fit in traceBytesPerNumber");
        }
    }

    void traceBufFlush(traceBuf* buf, uintptr_t gen)
    {
        assertLockHeld(& trace.lock);
        varintAt(gocpp::recv(buf), buf->lenPos, uint64_t(buf->pos - (buf->lenPos + traceBytesPerNumber)));
        push(gocpp::recv(trace.full[gen % 2]), buf);
        if(! Load(gocpp::recv(trace.workAvailable)))
        {
            Store(gocpp::recv(trace.workAvailable), true);
        }
    }

}

