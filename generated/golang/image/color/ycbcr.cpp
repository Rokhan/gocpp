// generated by GoCpp from file '$(ImportDir)/image/color/ycbcr.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/color/ycbcr.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"

namespace golang::color
{
    std::tuple<uint8_t, uint8_t, uint8_t> RGBToYCbCr(uint8_t r, uint8_t g, uint8_t b)
    {
        auto r1 = int32_t(r);
        auto g1 = int32_t(g);
        auto b1 = int32_t(b);
        auto yy = (19595 * r1 + 38470 * g1 + 7471 * b1 + (1 << 15)) >> 16;
        auto cb = - 11056 * r1 - 21712 * g1 + 32768 * b1 + (257 << 15);
        if(uint32_t(cb) & 0xff000000 == 0)
        {
            cb >>= 16;
        }
        else
        {
            cb = ~ (cb >> 31);
        }
        auto cr = 32768 * r1 - 27440 * g1 - 5328 * b1 + (257 << 15);
        if(uint32_t(cr) & 0xff000000 == 0)
        {
            cr >>= 16;
        }
        else
        {
            cr = ~ (cr >> 31);
        }
        return {uint8_t(yy), uint8_t(cb), uint8_t(cr)};
    }

    std::tuple<uint8_t, uint8_t, uint8_t> YCbCrToRGB(uint8_t y, uint8_t cb, uint8_t cr)
    {
        auto yy1 = int32_t(y) * 0x10101;
        auto cb1 = int32_t(cb) - 128;
        auto cr1 = int32_t(cr) - 128;
        auto r = yy1 + 91881 * cr1;
        if(uint32_t(r) & 0xff000000 == 0)
        {
            r >>= 16;
        }
        else
        {
            r = ~ (r >> 31);
        }
        auto g = yy1 - 22554 * cb1 - 46802 * cr1;
        if(uint32_t(g) & 0xff000000 == 0)
        {
            g >>= 16;
        }
        else
        {
            g = ~ (g >> 31);
        }
        auto b = yy1 + 116130 * cb1;
        if(uint32_t(b) & 0xff000000 == 0)
        {
            b >>= 16;
        }
        else
        {
            b = ~ (b >> 31);
        }
        return {uint8_t(r), uint8_t(g), uint8_t(b)};
    }

    
    template<typename T>
    YCbCr::operator T()
    {
        T result;
        result.Y = this->Y;
        result.Cb = this->Cb;
        result.Cr = this->Cr;
        return result;
    }

    template<typename T>
    bool YCbCr::operator==(const T& ref) const
    {
        if (Y != ref.Y) return false;
        if (Cb != ref.Cb) return false;
        if (Cr != ref.Cr) return false;
        return true;
    }

    std::ostream& YCbCr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Y;
        os << " " << Cb;
        os << " " << Cr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct YCbCr& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct YCbCr c)
    {
        auto yy1 = int32_t(c.Y) * 0x10101;
        auto cb1 = int32_t(c.Cb) - 128;
        auto cr1 = int32_t(c.Cr) - 128;
        auto r = yy1 + 91881 * cr1;
        if(uint32_t(r) & 0xff000000 == 0)
        {
            r >>= 8;
        }
        else
        {
            r = ~ (r >> 31) & 0xffff;
        }
        auto g = yy1 - 22554 * cb1 - 46802 * cr1;
        if(uint32_t(g) & 0xff000000 == 0)
        {
            g >>= 8;
        }
        else
        {
            g = ~ (g >> 31) & 0xffff;
        }
        auto b = yy1 + 116130 * cb1;
        if(uint32_t(b) & 0xff000000 == 0)
        {
            b >>= 8;
        }
        else
        {
            b = ~ (b >> 31) & 0xffff;
        }
        return {uint32_t(r), uint32_t(g), uint32_t(b), 0xffff};
    }

    Model YCbCrModel = ModelFunc(yCbCrModel);
    Color yCbCrModel(Color c)
    {
        if(auto [gocpp_id_1, ok] = gocpp::getValue<YCbCr>(c); ok)
        {
            return c;
        }
        auto [r, g, b, gocpp_id_3] = RGBA(gocpp::recv(c));
        auto [y, u, v] = RGBToYCbCr(uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8));
        return YCbCr {y, u, v};
    }

    
    template<typename T>
    NYCbCrA::operator T()
    {
        T result;
        result.A = this->A;
        return result;
    }

    template<typename T>
    bool NYCbCrA::operator==(const T& ref) const
    {
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& NYCbCrA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NYCbCrA& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct NYCbCrA c)
    {
        auto yy1 = int32_t(c.Y) * 0x10101;
        auto cb1 = int32_t(c.Cb) - 128;
        auto cr1 = int32_t(c.Cr) - 128;
        auto r = yy1 + 91881 * cr1;
        if(uint32_t(r) & 0xff000000 == 0)
        {
            r >>= 8;
        }
        else
        {
            r = ~ (r >> 31) & 0xffff;
        }
        auto g = yy1 - 22554 * cb1 - 46802 * cr1;
        if(uint32_t(g) & 0xff000000 == 0)
        {
            g >>= 8;
        }
        else
        {
            g = ~ (g >> 31) & 0xffff;
        }
        auto b = yy1 + 116130 * cb1;
        if(uint32_t(b) & 0xff000000 == 0)
        {
            b >>= 8;
        }
        else
        {
            b = ~ (b >> 31) & 0xffff;
        }
        auto a = uint32_t(c.A) * 0x101;
        return {uint32_t(r) * a / 0xffff, uint32_t(g) * a / 0xffff, uint32_t(b) * a / 0xffff, a};
    }

    Model NYCbCrAModel = ModelFunc(nYCbCrAModel);
    Color nYCbCrAModel(Color c)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_4 = gocpp::type_info(c);
            int conditionId = -1;
            if(gocpp_id_4 == typeid(NYCbCrA)) { conditionId = 0; }
            else if(gocpp_id_4 == typeid(YCbCr)) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                {
                    NYCbCrA c = gocpp::any_cast<NYCbCrA>(c);
                    return c;
                    break;
                }
                case 1:
                {
                    YCbCr c = gocpp::any_cast<YCbCr>(c);
                    return NYCbCrA {c, 0xff};
                    break;
                }
            }
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        if(a != 0)
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto [y, u, v] = RGBToYCbCr(uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8));
        return NYCbCrA {gocpp::Init<YCbCr>([](YCbCr& x) { x.Y = y; x.Cb = u; x.Cr = v; }), uint8_t(a >> 8)};
    }

    std::tuple<uint8_t, uint8_t, uint8_t, uint8_t> RGBToCMYK(uint8_t r, uint8_t g, uint8_t b)
    {
        auto rr = uint32_t(r);
        auto gg = uint32_t(g);
        auto bb = uint32_t(b);
        auto w = rr;
        if(w < gg)
        {
            w = gg;
        }
        if(w < bb)
        {
            w = bb;
        }
        if(w == 0)
        {
            return {0, 0, 0, 0xff};
        }
        auto c = (w - rr) * 0xff / w;
        auto m = (w - gg) * 0xff / w;
        auto y = (w - bb) * 0xff / w;
        return {uint8_t(c), uint8_t(m), uint8_t(y), uint8_t(0xff - w)};
    }

    std::tuple<uint8_t, uint8_t, uint8_t> CMYKToRGB(uint8_t c, uint8_t m, uint8_t y, uint8_t k)
    {
        auto w = 0xffff - uint32_t(k) * 0x101;
        auto r = (0xffff - uint32_t(c) * 0x101) * w / 0xffff;
        auto g = (0xffff - uint32_t(m) * 0x101) * w / 0xffff;
        auto b = (0xffff - uint32_t(y) * 0x101) * w / 0xffff;
        return {uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8)};
    }

    
    template<typename T>
    CMYK::operator T()
    {
        T result;
        result.C = this->C;
        result.M = this->M;
        result.Y = this->Y;
        result.K = this->K;
        return result;
    }

    template<typename T>
    bool CMYK::operator==(const T& ref) const
    {
        if (C != ref.C) return false;
        if (M != ref.M) return false;
        if (Y != ref.Y) return false;
        if (K != ref.K) return false;
        return true;
    }

    std::ostream& CMYK::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << C;
        os << " " << M;
        os << " " << Y;
        os << " " << K;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct CMYK c)
    {
        auto w = 0xffff - uint32_t(c.K) * 0x101;
        auto r = (0xffff - uint32_t(c.C) * 0x101) * w / 0xffff;
        auto g = (0xffff - uint32_t(c.M) * 0x101) * w / 0xffff;
        auto b = (0xffff - uint32_t(c.Y) * 0x101) * w / 0xffff;
        return {r, g, b, 0xffff};
    }

    Model CMYKModel = ModelFunc(cmykModel);
    Color cmykModel(Color c)
    {
        if(auto [gocpp_id_6, ok] = gocpp::getValue<CMYK>(c); ok)
        {
            return c;
        }
        auto [r, g, b, gocpp_id_8] = RGBA(gocpp::recv(c));
        auto [cc, mm, yy, kk] = RGBToCMYK(uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8));
        return CMYK {cc, mm, yy, kk};
    }

}

