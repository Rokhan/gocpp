// generated by GoCpp from file '$(ImportDir)/runtime/time.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/time.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct timer
    {
        puintptr pp;
        int64_t when;
        int64_t period;
        std::function<void (go_any, uintptr_t)> f;
        go_any arg;
        uintptr_t seq;
        int64_t nextwhen;
        atomic::Uint32 status;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct timer& value);
    void timeSleep(int64_t ns);
    bool resetForSleep(g* gp, unsafe::Pointer ut);
    void startTimer(timer* t);
    bool stopTimer(timer* t);
    bool resetTimer(timer* t, int64_t when);
    void modTimer(timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq);
    void goroutineReady(go_any arg, uintptr_t seq);
    void addtimer(timer* t);
    void doaddtimer(p* pp, timer* t);
    bool deltimer(timer* t);
    int dodeltimer(p* pp, int i);
    void dodeltimer0(p* pp);
    bool modtimer(timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq);
    bool resettimer(timer* t, int64_t when);
    void cleantimers(p* pp);
    void moveTimers(p* pp, gocpp::slice<timer*> timers);
    void adjusttimers(p* pp, int64_t now);
    void addAdjustedTimers(p* pp, gocpp::slice<timer*> moved);
    int64_t nobarrierWakeTime(p* pp);
    int64_t runtimer(p* pp, int64_t now);
    void runOneTimer(p* pp, timer* t, int64_t now);
    void clearDeletedTimers(p* pp);
    void verifyTimerHeap(p* pp);
    void updateTimer0When(p* pp);
    void updateTimerModifiedEarliest(p* pp, int64_t nextwhen);
    int64_t timeSleepUntil();
    int siftupTimer(gocpp::slice<timer*> t, int i);
    void siftdownTimer(gocpp::slice<timer*> t, int i);
    void badTimer();
}

