// generated by GoCpp from file '$(ImportDir)/time/zoneinfo.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/zoneinfo.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/syscall/env_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo_read.h"
#include "golang/time/zoneinfo_windows.h"

namespace golang::time
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Location::operator T()
    {
        T result;
        result.name = this->name;
        result.zone = this->zone;
        result.tx = this->tx;
        result.extend = this->extend;
        result.cacheStart = this->cacheStart;
        result.cacheEnd = this->cacheEnd;
        result.cacheZone = this->cacheZone;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Location::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (zone != ref.zone) return false;
        if (tx != ref.tx) return false;
        if (extend != ref.extend) return false;
        if (cacheStart != ref.cacheStart) return false;
        if (cacheEnd != ref.cacheEnd) return false;
        if (cacheZone != ref.cacheZone) return false;
        return true;
    }

    std::ostream& Location::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << zone;
        os << " " << tx;
        os << " " << extend;
        os << " " << cacheStart;
        os << " " << cacheEnd;
        os << " " << cacheZone;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Location& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    zone::operator T()
    {
        T result;
        result.name = this->name;
        result.offset = this->offset;
        result.isDST = this->isDST;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool zone::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (offset != ref.offset) return false;
        if (isDST != ref.isDST) return false;
        return true;
    }

    std::ostream& zone::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << offset;
        os << " " << isDST;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct zone& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    zoneTrans::operator T()
    {
        T result;
        result.when = this->when;
        result.index = this->index;
        result.isstd = this->isstd;
        result.isutc = this->isutc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool zoneTrans::operator==(const T& ref) const
    {
        if (when != ref.when) return false;
        if (index != ref.index) return false;
        if (isstd != ref.isstd) return false;
        if (isutc != ref.isutc) return false;
        return true;
    }

    std::ostream& zoneTrans::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << when;
        os << " " << index;
        os << " " << isstd;
        os << " " << isutc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct zoneTrans& value)
    {
        return value.PrintTo(os);
    }

    Location* UTC = & utcLoc;
    Location utcLoc = gocpp::Init<Location>([](Location& x) { x.name = "UTC"; });
    Location* Local = & localLoc;
    Location localLoc;
    sync::Once localOnce;
    struct Location* get(struct Location* l)
    {
        if(l == nullptr)
        {
            return & utcLoc;
        }
        if(l == & localLoc)
        {
            Do(gocpp::recv(localOnce), initLocal);
        }
        return l;
    }

    std::string String(struct Location* l)
    {
        return get(gocpp::recv(l))->name;
    }

    gocpp::slice<Location*> unnamedFixedZones;
    sync::Once unnamedFixedZonesOnce;
    struct Location* FixedZone(std::string name, int offset)
    {
        auto hoursBeforeUTC = 12;
        auto hoursAfterUTC = 14;
        auto hour = offset / 60 / 60;
        if(name == "" && - hoursBeforeUTC <= hour && hour <= + hoursAfterUTC && hour * 60 * 60 == offset)
        {
            Do(gocpp::recv(unnamedFixedZonesOnce), [=]() mutable -> void
            {
                unnamedFixedZones = gocpp::make(gocpp::Tag<gocpp::slice<Location*>>(), hoursBeforeUTC + 1 + hoursAfterUTC);
                for(auto hr = - hoursBeforeUTC; hr <= + hoursAfterUTC; hr++)
                {
                    unnamedFixedZones[hr + hoursBeforeUTC] = fixedZone("", hr * 60 * 60);
                }
            });
            return unnamedFixedZones[hour + hoursBeforeUTC];
        }
        return fixedZone(name, offset);
    }

    struct Location* fixedZone(std::string name, int offset)
    {
        auto l = gocpp::InitPtr<Location>([](Location& x) { x.name = name; x.zone = gocpp::slice<zone> { {name, offset, false}}; x.tx = gocpp::slice<zoneTrans> { {alpha, 0, false, false}}; x.cacheStart = alpha; x.cacheEnd = omega; });
        l->cacheZone = & l->zone[0];
        return l;
    }

    std::tuple<std::string, int, int64_t, int64_t, bool> lookup(struct Location* l, int64_t sec)
    {
        std::string name;
        int offset;
        int64_t start;
        int64_t end;
        bool isDST;
        l = get(gocpp::recv(l));
        if(len(l->zone) == 0)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            name = "UTC";
            offset = 0;
            start = alpha;
            end = omega;
            isDST = false;
            return {name, offset, start, end, isDST};
        }
        if(auto zone = l->cacheZone; zone != nullptr && l->cacheStart <= sec && sec < l->cacheEnd)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            name = zone->name;
            offset = zone->offset;
            start = l->cacheStart;
            end = l->cacheEnd;
            isDST = zone->isDST;
            return {name, offset, start, end, isDST};
        }
        if(len(l->tx) == 0 || sec < l->tx[0].when)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            auto zone = & l->zone[lookupFirstZone(gocpp::recv(l))];
            name = zone->name;
            offset = zone->offset;
            start = alpha;
            if(len(l->tx) > 0)
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                end = l->tx[0].when;
            }
            else
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                end = omega;
            }
            isDST = zone->isDST;
            return {name, offset, start, end, isDST};
        }
        auto tx = l->tx;
        end = omega;
        auto lo = 0;
        auto hi = len(tx);
        for(; hi - lo > 1; )
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto lim = tx[m].when;
            if(sec < lim)
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                end = lim;
                hi = m;
            }
            else
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                lo = m;
            }
        }
        auto zone = & l->zone[tx[lo].index];
        name = zone->name;
        offset = zone->offset;
        start = tx[lo].when;
        isDST = zone->isDST;
        if(lo == len(tx) - 1 && l->extend != "")
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            if(auto [ename, eoffset, estart, eend, eisDST, ok] = tzset(l->extend, start, sec); ok)
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                return {ename, eoffset, estart, eend, eisDST};
            }
        }
        return {name, offset, start, end, isDST};
    }

    int lookupFirstZone(struct Location* l)
    {
        if(! firstZoneUsed(gocpp::recv(l)))
        {
            return 0;
        }
        if(len(l->tx) > 0 && l->zone[l->tx[0].index].isDST)
        {
            for(auto zi = int(l->tx[0].index) - 1; zi >= 0; zi--)
            {
                if(! l->zone[zi].isDST)
                {
                    return zi;
                }
            }
        }
        for(auto [zi, gocpp_ignored] : l->zone)
        {
            if(! l->zone[zi].isDST)
            {
                return zi;
            }
        }
        return 0;
    }

    bool firstZoneUsed(struct Location* l)
    {
        for(auto [gocpp_ignored, tx] : l->tx)
        {
            if(tx.index == 0)
            {
                return true;
            }
        }
        return false;
    }

    std::tuple<std::string, int, int64_t, int64_t, bool, bool> tzset(std::string s, int64_t lastTxSec, int64_t sec)
    {
        std::string name;
        int offset;
        int64_t start;
        int64_t end;
        bool isDST;
        bool ok;
        std::string stdName = {};
        std::string dstName = {};
        int stdOffset = {};
        int dstOffset = {};
        std::tie(stdName, s, ok) = tzsetName(s);
        if(ok)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            std::tie(stdOffset, s, ok) = tzsetOffset(s);
        }
        if(! ok)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {"", 0, 0, 0, false, false};
        }
        stdOffset = - stdOffset;
        if(len(s) == 0 || s[0] == ',')
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {stdName, stdOffset, lastTxSec, omega, false, true};
        }
        std::tie(dstName, s, ok) = tzsetName(s);
        if(ok)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            if(len(s) == 0 || s[0] == ',')
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                bool ok;
                dstOffset = stdOffset + secondsPerHour;
            }
            else
            {
                std::string name;
                int offset;
                int64_t start;
                int64_t end;
                bool isDST;
                bool ok;
                std::tie(dstOffset, s, ok) = tzsetOffset(s);
                dstOffset = - dstOffset;
            }
        }
        if(! ok)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {"", 0, 0, 0, false, false};
        }
        if(len(s) == 0)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            s = ",M3.2.0,M11.1.0";
        }
        if(s[0] != ',' && s[0] != ';')
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {"", 0, 0, 0, false, false};
        }
        s = s.make_slice(1);
        rule startRule = {};
        rule endRule = {};
        std::tie(startRule, s, ok) = tzsetRule(s);
        if(! ok || len(s) == 0 || s[0] != ',')
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {"", 0, 0, 0, false, false};
        }
        s = s.make_slice(1);
        std::tie(endRule, s, ok) = tzsetRule(s);
        if(! ok || len(s) > 0)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {"", 0, 0, 0, false, false};
        }
        auto [year, gocpp_id_2, gocpp_id_3, yday] = absDate(uint64_t(sec + unixToInternal + internalToAbsolute), false);
        auto ysec = int64_t(yday * secondsPerDay) + sec % secondsPerDay;
        auto d = daysSinceEpoch(year);
        auto abs = int64_t(d * secondsPerDay);
        abs += absoluteToInternal + internalToUnix;
        auto startSec = int64_t(tzruleTime(year, startRule, stdOffset));
        auto endSec = int64_t(tzruleTime(year, endRule, dstOffset));
        auto [dstIsDST, stdIsDST] = std::tuple{true, false};
        if(endSec < startSec)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            std::tie(startSec, endSec) = std::tuple{endSec, startSec};
            std::tie(stdName, dstName) = std::tuple{dstName, stdName};
            std::tie(stdOffset, dstOffset) = std::tuple{dstOffset, stdOffset};
            std::tie(stdIsDST, dstIsDST) = std::tuple{dstIsDST, stdIsDST};
        }
        if(ysec < startSec)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {stdName, stdOffset, abs, startSec + abs, stdIsDST, true};
        }
        else
        if(ysec >= endSec)
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {stdName, stdOffset, endSec + abs, abs + 365 * secondsPerDay, stdIsDST, true};
        }
        else
        {
            std::string name;
            int offset;
            int64_t start;
            int64_t end;
            bool isDST;
            bool ok;
            return {dstName, dstOffset, startSec + abs, endSec + abs, dstIsDST, true};
        }
    }

    std::tuple<std::string, std::string, bool> tzsetName(std::string s)
    {
        if(len(s) == 0)
        {
            return {"", "", false};
        }
        if(s[0] != '<')
        {
            for(auto [i, r] : s)
            {
                //Go switch emulation
                {
                    auto condition = r;
                    int conditionId = -1;
                    if(condition == '0') { conditionId = 0; }
                    if(condition == '1') { conditionId = 1; }
                    if(condition == '2') { conditionId = 2; }
                    if(condition == '3') { conditionId = 3; }
                    if(condition == '4') { conditionId = 4; }
                    if(condition == '5') { conditionId = 5; }
                    if(condition == '6') { conditionId = 6; }
                    if(condition == '7') { conditionId = 7; }
                    if(condition == '8') { conditionId = 8; }
                    if(condition == '9') { conditionId = 9; }
                    if(condition == ',') { conditionId = 10; }
                    if(condition == '-') { conditionId = 11; }
                    if(condition == '+') { conditionId = 12; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                            if(i < 3)
                            {
                                return {"", "", false};
                            }
                            return {s.make_slice(0, i), s.make_slice(i), true};
                            break;
                    }
                }
            }
            if(len(s) < 3)
            {
                return {"", "", false};
            }
            return {s, "", true};
        }
        else
        {
            for(auto [i, r] : s)
            {
                if(r == '>')
                {
                    return {s.make_slice(1, i), s.make_slice(i + 1), true};
                }
            }
            return {"", "", false};
        }
    }

    std::tuple<int, std::string, bool> tzsetOffset(std::string s)
    {
        int offset;
        std::string rest;
        bool ok;
        if(len(s) == 0)
        {
            int offset;
            std::string rest;
            bool ok;
            return {0, "", false};
        }
        auto neg = false;
        if(s[0] == '+')
        {
            int offset;
            std::string rest;
            bool ok;
            s = s.make_slice(1);
        }
        else
        if(s[0] == '-')
        {
            int offset;
            std::string rest;
            bool ok;
            s = s.make_slice(1);
            neg = true;
        }
        int hours = {};
        std::tie(hours, s, ok) = tzsetNum(s, 0, 24 * 7);
        if(! ok)
        {
            int offset;
            std::string rest;
            bool ok;
            return {0, "", false};
        }
        auto off = hours * secondsPerHour;
        if(len(s) == 0 || s[0] != ':')
        {
            int offset;
            std::string rest;
            bool ok;
            if(neg)
            {
                int offset;
                std::string rest;
                bool ok;
                off = - off;
            }
            return {off, s, true};
        }
        int mins = {};
        std::tie(mins, s, ok) = tzsetNum(s.make_slice(1), 0, 59);
        if(! ok)
        {
            int offset;
            std::string rest;
            bool ok;
            return {0, "", false};
        }
        off += mins * secondsPerMinute;
        if(len(s) == 0 || s[0] != ':')
        {
            int offset;
            std::string rest;
            bool ok;
            if(neg)
            {
                int offset;
                std::string rest;
                bool ok;
                off = - off;
            }
            return {off, s, true};
        }
        int secs = {};
        std::tie(secs, s, ok) = tzsetNum(s.make_slice(1), 0, 59);
        if(! ok)
        {
            int offset;
            std::string rest;
            bool ok;
            return {0, "", false};
        }
        off += secs;
        if(neg)
        {
            int offset;
            std::string rest;
            bool ok;
            off = - off;
        }
        return {off, s, true};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    rule::operator T()
    {
        T result;
        result.kind = this->kind;
        result.day = this->day;
        result.week = this->week;
        result.mon = this->mon;
        result.time = this->time;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool rule::operator==(const T& ref) const
    {
        if (kind != ref.kind) return false;
        if (day != ref.day) return false;
        if (week != ref.week) return false;
        if (mon != ref.mon) return false;
        if (time != ref.time) return false;
        return true;
    }

    std::ostream& rule::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << day;
        os << " " << week;
        os << " " << mon;
        os << " " << time;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rule& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<struct rule, std::string, bool> tzsetRule(std::string s)
    {
        rule r = {};
        if(len(s) == 0)
        {
            return {rule {}, "", false};
        }
        auto ok = false;
        if(s[0] == 'J')
        {
            int jday = {};
            std::tie(jday, s, ok) = tzsetNum(s.make_slice(1), 1, 365);
            if(! ok)
            {
                return {rule {}, "", false};
            }
            r.kind = ruleJulian;
            r.day = jday;
        }
        else
        if(s[0] == 'M')
        {
            int mon = {};
            std::tie(mon, s, ok) = tzsetNum(s.make_slice(1), 1, 12);
            if(! ok || len(s) == 0 || s[0] != '.')
            {
                return {rule {}, "", false};
            }
            int week = {};
            std::tie(week, s, ok) = tzsetNum(s.make_slice(1), 1, 5);
            if(! ok || len(s) == 0 || s[0] != '.')
            {
                return {rule {}, "", false};
            }
            int day = {};
            std::tie(day, s, ok) = tzsetNum(s.make_slice(1), 0, 6);
            if(! ok)
            {
                return {rule {}, "", false};
            }
            r.kind = ruleMonthWeekDay;
            r.day = day;
            r.week = week;
            r.mon = mon;
        }
        else
        {
            int day = {};
            std::tie(day, s, ok) = tzsetNum(s, 0, 365);
            if(! ok)
            {
                return {rule {}, "", false};
            }
            r.kind = ruleDOY;
            r.day = day;
        }
        if(len(s) == 0 || s[0] != '/')
        {
            r.time = 2 * secondsPerHour;
            return {r, s, true};
        }
        int offset;
        std::string s;
        std::tie(offset, s, ok) = tzsetOffset(s.make_slice(1));
        if(! ok)
        {
            return {rule {}, "", false};
        }
        r.time = offset;
        return {r, s, true};
    }

    std::tuple<int, std::string, bool> tzsetNum(std::string s, int min, int max)
    {
        int num;
        std::string rest;
        bool ok;
        if(len(s) == 0)
        {
            int num;
            std::string rest;
            bool ok;
            return {0, "", false};
        }
        num = 0;
        for(auto [i, r] : s)
        {
            int num;
            std::string rest;
            bool ok;
            if(r < '0' || r > '9')
            {
                int num;
                std::string rest;
                bool ok;
                if(i == 0 || num < min)
                {
                    int num;
                    std::string rest;
                    bool ok;
                    return {0, "", false};
                }
                return {num, s.make_slice(i), true};
            }
            num *= 10;
            num += int(r) - '0';
            if(num > max)
            {
                int num;
                std::string rest;
                bool ok;
                return {0, "", false};
            }
        }
        if(num < min)
        {
            int num;
            std::string rest;
            bool ok;
            return {0, "", false};
        }
        return {num, "", true};
    }

    int tzruleTime(int year, struct rule r, int off)
    {
        int s = {};
        //Go switch emulation
        {
            auto condition = r.kind;
            int conditionId = -1;
            if(condition == ruleJulian) { conditionId = 0; }
            else if(condition == ruleDOY) { conditionId = 1; }
            else if(condition == ruleMonthWeekDay) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    s = (r.day - 1) * secondsPerDay;
                    if(isLeap(year) && r.day >= 60)
                    {
                        s += secondsPerDay;
                    }
                    break;
                case 1:
                    s = r.day * secondsPerDay;
                    break;
                case 2:
                    auto m1 = (r.mon + 9) % 12 + 1;
                    auto yy0 = year;
                    if(r.mon <= 2)
                    {
                        yy0--;
                    }
                    auto yy1 = yy0 / 100;
                    auto yy2 = yy0 % 100;
                    auto dow = ((26 * m1 - 2) / 10 + 1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
                    if(dow < 0)
                    {
                        dow += 7;
                    }
                    auto d = r.day - dow;
                    if(d < 0)
                    {
                        d += 7;
                    }
                    for(auto i = 1; i < r.week; i++)
                    {
                        if(d + 7 >= daysIn(Month(r.mon), year))
                        {
                            break;
                        }
                        d += 7;
                    }
                    d += int(daysBefore[r.mon - 1]);
                    if(isLeap(year) && r.mon > 2)
                    {
                        d++;
                    }
                    s = d * secondsPerDay;
                    break;
            }
        }
        return s + r.time - off;
    }

    std::tuple<int, bool> lookupName(struct Location* l, std::string name, int64_t unix)
    {
        int offset;
        bool ok;
        l = get(gocpp::recv(l));
        for(auto [i, gocpp_ignored] : l->zone)
        {
            int offset;
            bool ok;
            auto zone = & l->zone[i];
            if(zone->name == name)
            {
                int offset;
                bool ok;
                auto [nam, offset, gocpp_id_7, gocpp_id_8, gocpp_id_9] = lookup(gocpp::recv(l), unix - int64_t(zone->offset));
                if(nam == zone->name)
                {
                    int offset;
                    bool ok;
                    return {offset, true};
                }
            }
        }
        for(auto [i, gocpp_ignored] : l->zone)
        {
            int offset;
            bool ok;
            auto zone = & l->zone[i];
            if(zone->name == name)
            {
                int offset;
                bool ok;
                return {zone->offset, true};
            }
        }
        return {offset, ok};
    }

    gocpp::error errLocation = errors::New("time: invalid location name");
    std::string* zoneinfo;
    sync::Once zoneinfoOnce;
    std::tuple<struct Location*, struct gocpp::error> LoadLocation(std::string name)
    {
        if(name == "" || name == "UTC")
        {
            return {UTC, nullptr};
        }
        if(name == "Local")
        {
            return {Local, nullptr};
        }
        if(containsDotDot(name) || name[0] == '/' || name[0] == '\\')
        {
            return {nullptr, errLocation};
        }
        Do(gocpp::recv(zoneinfoOnce), [=]() mutable -> void
        {
            auto [env, gocpp_id_11] = syscall::Getenv("ZONEINFO");
            zoneinfo = & env;
        });
        gocpp::error firstErr = {};
        if(*zoneinfo != "")
        {
            if(auto [zoneData, err] = loadTzinfoFromDirOrZip(*zoneinfo, name); err == nullptr)
            {
                if(auto [z, err] = LoadLocationFromTZData(name, zoneData); err == nullptr)
                {
                    return {z, nullptr};
                }
                firstErr = err;
            }
            else
            if(err != syscall::ENOENT)
            {
                firstErr = err;
            }
        }
        if(auto [z, err] = loadLocation(name, platformZoneSources); err == nullptr)
        {
            return {z, nullptr};
        }
        else
        if(firstErr == nullptr)
        {
            firstErr = err;
        }
        return {nullptr, firstErr};
    }

    bool containsDotDot(std::string s)
    {
        if(len(s) < 2)
        {
            return false;
        }
        for(auto i = 0; i < len(s) - 1; i++)
        {
            if(s[i] == '.' && s[i + 1] == '.')
            {
                return true;
            }
        }
        return false;
    }

}

