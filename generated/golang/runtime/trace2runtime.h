// generated by GoCpp from file '$(ImportDir)/runtime/trace2runtime.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2runtime.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct gTraceState
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gTraceState& value);
    void reset(struct gTraceState* s);
    struct mTraceState
    {
        atomic::Uintptr seqlock;
        gocpp::array<traceBuf*, 2> buf;
        m* link;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mTraceState& value);
    struct pTraceState
    {
        int64_t mSyscallID;
        bool maySweep;
        bool inSweep;
        uintptr_t swept;
        uintptr_t reclaimed;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pTraceState& value);
    void traceLockInit();
    void lockRankMayTraceFlush();
    extern gocpp::array_base<std::string> traceBlockReasonStrings;
    extern gocpp::array_base<std::string> traceGoStopReasonStrings;
    bool traceEnabled();
    bool traceShuttingDown();
    struct traceLocker
    {
        m* mp;
        uintptr_t gen;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct traceLocker& value);
    traceLocker traceAcquire();
    traceLocker traceAcquireEnabled();
    bool ok(struct traceLocker tl);
    void traceRelease(traceLocker tl);
    void traceExitingSyscall();
    void traceExitedSyscall();
    void Gomaxprocs(struct traceLocker tl, int32_t procs);
    void ProcStart(struct traceLocker tl);
    void ProcStop(struct traceLocker tl, p* pp);
    void GCActive(struct traceLocker tl);
    void GCStart(struct traceLocker tl);
    void GCDone(struct traceLocker tl);
    void STWStart(struct traceLocker tl, stwReason reason);
    void STWDone(struct traceLocker tl);
    void GCSweepStart(struct traceLocker tl);
    void GCSweepSpan(struct traceLocker tl, uintptr_t bytesSwept);
    void GCSweepDone(struct traceLocker tl);
    void GCMarkAssistStart(struct traceLocker tl);
    void GCMarkAssistDone(struct traceLocker tl);
    void GoCreate(struct traceLocker tl, g* newg, uintptr_t pc);
    void GoStart(struct traceLocker tl);
    void GoEnd(struct traceLocker tl);
    void GoSched(struct traceLocker tl);
    void GoPreempt(struct traceLocker tl);
    void GoStop(struct traceLocker tl, traceGoStopReason reason);
    void GoPark(struct traceLocker tl, traceBlockReason reason, int skip);
    void GoUnpark(struct traceLocker tl, g* gp, int skip);
    void GoSysCall(struct traceLocker tl);
    void GoSysExit(struct traceLocker tl, bool lostP);
    void ProcSteal(struct traceLocker tl, p* pp, bool inSyscall);
    void GoSysBlock(struct traceLocker tl, p* pp);
    void HeapAlloc(struct traceLocker tl, uint64_t live);
    void HeapGoal(struct traceLocker tl);
    void OneNewExtraM(struct traceLocker tl, g* _);
    void GoCreateSyscall(struct traceLocker tl, g* gp);
    void GoDestroySyscall(struct traceLocker tl);
    void trace_userTaskCreate(uint64_t id, uint64_t parentID, std::string taskType);
    void trace_userTaskEnd(uint64_t id);
    void trace_userRegion(uint64_t id, uint64_t mode, std::string name);
    void trace_userLog(uint64_t id, std::string category, std::string message);
    void traceProcFree(p* _);
    void traceThreadDestroy(m* mp);
    void RecordSyscallExitedTime(struct traceLocker _, g* _, p* _);
}

