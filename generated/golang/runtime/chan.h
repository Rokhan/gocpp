// generated by GoCpp from file '$(ImportDir)/runtime/chan.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/chan.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct waitq
    {
        sudog* first;
        sudog* last;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct waitq& value);
    struct hchan* reflect_makechan(golang::runtime::chantype* t, int size);
    struct hchan* makechan64(golang::runtime::chantype* t, int64_t size);
    struct hchan* makechan(golang::runtime::chantype* t, int size);
    unsafe::Pointer chanbuf(struct hchan* c, unsigned int i);
    bool full(struct hchan* c);
    void chansend1(struct hchan* c, unsafe::Pointer elem);
    bool chansend(struct hchan* c, unsafe::Pointer ep, bool block, uintptr_t callerpc);
    void send(struct hchan* c, struct sudog* sg, unsafe::Pointer ep, std::function<void ()> unlockf, int skip);
    void sendDirect(golang::runtime::_type* t, struct sudog* sg, unsafe::Pointer src);
    void recvDirect(golang::runtime::_type* t, struct sudog* sg, unsafe::Pointer dst);
    void closechan(struct hchan* c);
    bool empty(struct hchan* c);
    void chanrecv1(struct hchan* c, unsafe::Pointer elem);
    bool chanrecv2(struct hchan* c, unsafe::Pointer elem);
    std::tuple<bool, bool> chanrecv(struct hchan* c, unsafe::Pointer ep, bool block);
    void recv(struct hchan* c, struct sudog* sg, unsafe::Pointer ep, std::function<void ()> unlockf, int skip);
    bool chanparkcommit(struct g* gp, unsafe::Pointer chanLock);
    bool selectnbsend(struct hchan* c, unsafe::Pointer elem);
    std::tuple<bool, bool> selectnbrecv(unsafe::Pointer elem, struct hchan* c);
    bool reflect_chansend(struct hchan* c, unsafe::Pointer elem, bool nb);
    std::tuple<bool, bool> reflect_chanrecv(struct hchan* c, bool nb, unsafe::Pointer elem);
    int reflect_chanlen(struct hchan* c);
    int reflectlite_chanlen(struct hchan* c);
    int reflect_chancap(struct hchan* c);
    void reflect_chanclose(struct hchan* c);
    void racesync(struct hchan* c, struct sudog* sg);
    void racenotify(struct hchan* c, unsigned int idx, struct sudog* sg);
    struct hchan
    {
        unsigned int qcount;
        unsigned int dataqsiz;
        unsafe::Pointer buf;
        uint16_t elemsize;
        uint32_t closed;
        golang::runtime::_type* elemtype;
        unsigned int sendx;
        unsigned int recvx;
        /* waitq recvq; [Known incomplete type] */
        /* waitq sendq; [Known incomplete type] */
        mutex lock;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hchan& value);

    namespace rec
    {
        void enqueue(struct waitq* q, struct sudog* sgp);
        struct sudog* dequeue(struct waitq* q);
        unsafe::Pointer raceaddr(struct hchan* c);
    }
}

