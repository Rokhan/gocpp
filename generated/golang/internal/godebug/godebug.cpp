// generated by GoCpp from file '$(ImportDir)/internal/godebug/godebug.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/godebug/godebug.h"
#include "gocpp/support.h"

#include "golang/internal/bisect/bisect.h"
#include "golang/internal/godebugs/table.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/unsafe/unsafe.h"

namespace golang::godebug
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Setting::operator T()
    {
        T result;
        result.name = this->name;
        result.once = this->once;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Setting::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (once != ref.once) return false;
        return true;
    }

    std::ostream& Setting::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << once;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Setting& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    setting::operator T()
    {
        T result;
        result.value = this->value;
        result.nonDefaultOnce = this->nonDefaultOnce;
        result.nonDefault = this->nonDefault;
        result.info = this->info;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool setting::operator==(const T& ref) const
    {
        if (value != ref.value) return false;
        if (nonDefaultOnce != ref.nonDefaultOnce) return false;
        if (nonDefault != ref.nonDefault) return false;
        if (info != ref.info) return false;
        return true;
    }

    std::ostream& setting::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << value;
        os << " " << nonDefaultOnce;
        os << " " << nonDefault;
        os << " " << info;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct setting& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    value::operator T()
    {
        T result;
        result.text = this->text;
        result.bisect = this->bisect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool value::operator==(const T& ref) const
    {
        if (text != ref.text) return false;
        if (bisect != ref.bisect) return false;
        return true;
    }

    std::ostream& value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << text;
        os << " " << bisect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct value& value)
    {
        return value.PrintTo(os);
    }

    Setting* New(std::string name)
    {
        return gocpp::InitPtr<Setting>([](Setting& x) { x.name = name; });
    }

    std::string Name(struct Setting* s)
    {
        if(s->name != "" && s->name[0] == '#')
        {
            return s->name.make_slice(1);
        }
        return s->name;
    }

    bool Undocumented(struct Setting* s)
    {
        return s->name != "" && s->name[0] == '#';
    }

    std::string String(struct Setting* s)
    {
        return Name(gocpp::recv(s)) + "=" + Value(gocpp::recv(s));
    }

    void IncNonDefault(struct Setting* s)
    {
        Do(gocpp::recv(s->nonDefaultOnce), s->go_register);
        Add(gocpp::recv(s->nonDefault), 1);
    }

    void go_register(struct Setting* s)
    {
        if(s->info == nullptr || s->info->Opaque)
        {
            gocpp::panic("godebug: unexpected IncNonDefault of " + s->name);
        }
        registerMetric("/godebug/non-default-behavior/" + Name(gocpp::recv(s)) + ":events", s->nonDefault.Load);
    }

    sync::Map cache;
    value empty;
    std::string Value(struct Setting* s)
    {
        Do(gocpp::recv(s->once), [=]() mutable -> void
        {
            s->setting = lookup(Name(gocpp::recv(s)));
            if(s->info == nullptr && ! Undocumented(gocpp::recv(s)))
            {
                gocpp::panic("godebug: Value of name not listed in godebugs.All: " + s->name);
            }
        });
        auto v = *Load(gocpp::recv(s->value));
        if(v.bisect != nullptr && ! Stack(gocpp::recv(v.bisect), & stderr))
        {
            return "";
        }
        return v.text;
    }

    setting* lookup(std::string name)
    {
        if(auto [v, ok] = Load(gocpp::recv(cache), name); ok)
        {
            return gocpp::getValue<setting*>(v);
        }
        auto s = go_new(setting);
        s->info = godebugs::Lookup(name);
        Store(gocpp::recv(s->value), & empty);
        if(auto [v, loaded] = LoadOrStore(gocpp::recv(cache), name, s); loaded)
        {
            return gocpp::getValue<setting*>(v);
        }
        return s;
    }

    void setUpdate(std::function<void (std::string, std::string)> update)
    /* convertBlockStmt, nil block */;

    void registerMetric(std::string name, std::function<uint64_t ()> read)
    /* convertBlockStmt, nil block */;

    void setNewIncNonDefault(std::function<std::function<void ()> (std::string)> newIncNonDefault)
    /* convertBlockStmt, nil block */;

    void init()
    {
        setUpdate(update);
        setNewIncNonDefault(newIncNonDefault);
    }

    std::function<void ()> newIncNonDefault(std::string name)
    {
        auto s = New(name);
        Value(gocpp::recv(s));
        return s->IncNonDefault;
    }

    mocklib::Mutex updateMu;
    void update(std::string def, std::string env)
    {
        gocpp::Defer defer;
        Lock(gocpp::recv(updateMu));
        defer.push_back([=]{ Unlock(gocpp::recv(updateMu)); });
        auto did = gocpp::make(gocpp::Tag<gocpp::map<std::string, bool>>());
        parse(did, env);
        parse(did, def);
        Range(gocpp::recv(cache), [=](go_any name, go_any s) mutable -> bool
        {
            if(! did[gocpp::getValue<std::string>(name)])
            {
                Store(gocpp::recv(gocpp::getValue<setting*>(s)->value), & empty);
            }
            return true;
        });
    }

    void parse(gocpp::map<std::string, bool> did, std::string s)
    {
        auto end = len(s);
        auto eq = - 1;
        for(auto i = end - 1; i >= - 1; i--)
        {
            if(i == - 1 || s[i] == ',')
            {
                if(eq >= 0)
                {
                    auto [name, arg] = std::tuple{s.make_slice(i + 1, eq), s.make_slice(eq + 1, end)};
                    if(! did[name])
                    {
                        did[name] = true;
                        auto v = gocpp::InitPtr<value>([](value& x) { x.text = arg; });
                        for(auto j = 0; j < len(arg); j++)
                        {
                            if(arg[j] == '#')
                            {
                                v->text = arg.make_slice(0, j);
                                std::tie(v->bisect, gocpp_id_0) = bisect::New(arg.make_slice(j + 1));
                                break;
                            }
                        }
                        Store(gocpp::recv(lookup(name)->value), v);
                    }
                }
                eq = - 1;
                end = i;
            }
            else
            if(s[i] == '=')
            {
                eq = i;
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeStderr::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeStderr::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& runtimeStderr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeStderr& value)
    {
        return value.PrintTo(os);
    }

    runtimeStderr stderr;
    std::tuple<int, std::string> Write(runtimeStderr*, gocpp::slice<unsigned char> b)
    {
        if(len(b) > 0)
        {
            write(2, unsafe::Pointer(& b[0]), int32_t(len(b)));
        }
        return {len(b), nullptr};
    }

    int32_t write(uintptr_t fd, unsafe::Pointer p, int32_t n)
    /* convertBlockStmt, nil block */;

}

