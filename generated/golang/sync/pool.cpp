// generated by GoCpp from file '$(ImportDir)/sync/pool.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/pool.h"
#include "gocpp/support.h"

// #include "golang/internal/race/norace.h"  [Ignored, known errors]
#include "golang/runtime/debug.h"
// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/cond.h"
#include "golang/sync/mutex.h"
#include "golang/sync/poolqueue.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    std::ostream& Pool::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << local;
        os << " " << localSize;
        os << " " << victim;
        os << " " << victimSize;
        os << " " << New;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const Pool& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& poolLocalInternal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << private;
        os << " " << shared;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const poolLocalInternal& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& poolLocal::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const poolLocal& value)
    {
        return value.PrintTo(os);
    }

    uint32_t runtime_randn(uint32_t n)
    /* convertBlockStmt, nil block */;

    gocpp::array<uint64_t, 128> poolRaceHash;
    unsafe::Pointer poolRaceAddr(any x)
    {
        auto ptr = uintptr((*gocpp::Tag<gocpp::array<unsafe::Pointer, 2>>())(Pointer(gocpp::recv(unsafe), & x))[1]);
        auto h = uint32_t((uint64_t(uint32_t(ptr)) * 0x85ebca6b) >> 16);
        return Pointer(gocpp::recv(unsafe), & poolRaceHash[h % uint32_t(len(poolRaceHash))]);
    }

    void Put(Pool* p, any x)
    {
        if(x == nullptr)
        {
            return;
        }
        if(race.Enabled)
        {
            if(runtime_randn(4) == 0)
            {
                return;
            }
            ReleaseMerge(gocpp::recv(race), poolRaceAddr(x));
            Disable(gocpp::recv(race));
        }
        auto [l, _] = pin(gocpp::recv(p));
        if(l->private == nullptr)
        {
            l->private = x;
        }
        else
        {
            pushHead(gocpp::recv(l->shared), x);
        }
        runtime_procUnpin();
        if(race.Enabled)
        {
            Enable(gocpp::recv(race));
        }
    }

    any Get(Pool* p)
    {
        if(race.Enabled)
        {
            Disable(gocpp::recv(race));
        }
        auto [l, pid] = pin(gocpp::recv(p));
        auto x = l->private;
        l->private = nullptr;
        if(x == nullptr)
        {
            std::tie(x, _) = popHead(gocpp::recv(l->shared));
            if(x == nullptr)
            {
                x = getSlow(gocpp::recv(p), pid);
            }
        }
        runtime_procUnpin();
        if(race.Enabled)
        {
            Enable(gocpp::recv(race));
            if(x != nullptr)
            {
                Acquire(gocpp::recv(race), poolRaceAddr(x));
            }
        }
        if(x == nullptr && p->New != nullptr)
        {
            x = New(gocpp::recv(p));
        }
        return x;
    }

    any getSlow(Pool* p, int pid)
    {
        auto size = runtime_LoadAcquintptr(& p->localSize);
        auto locals = p->local;
        for(auto i = 0; i < int(size); i++)
        {
            auto l = indexLocal(locals, (pid + i + 1) % int(size));
            if(auto [x, _] = popTail(gocpp::recv(l->shared)); x != nullptr)
            {
                return x;
            }
        }
        size = LoadUintptr(gocpp::recv(atomic), & p->victimSize);
        if(uintptr(pid) >= size)
        {
            return nullptr;
        }
        locals = p->victim;
        auto l = indexLocal(locals, pid);
        if(auto x = l->private; x != nullptr)
        {
            l->private = nullptr;
            return x;
        }
        for(auto i = 0; i < int(size); i++)
        {
            auto l = indexLocal(locals, (pid + i) % int(size));
            if(auto [x, _] = popTail(gocpp::recv(l->shared)); x != nullptr)
            {
                return x;
            }
        }
        StoreUintptr(gocpp::recv(atomic), & p->victimSize, 0);
        return nullptr;
    }

    std::tuple<poolLocal*, int> pin(Pool* p)
    {
        if(p == nullptr)
        {
            gocpp::panic("nil Pool");
        }
        auto pid = runtime_procPin();
        auto s = runtime_LoadAcquintptr(& p->localSize);
        auto l = p->local;
        if(uintptr(pid) < s)
        {
            return {indexLocal(l, pid), pid};
        }
        return pinSlow(gocpp::recv(p));
    }

    std::tuple<poolLocal*, int> pinSlow(Pool* p)
    {
        gocpp::Defer defer;
        runtime_procUnpin();
        Lock(gocpp::recv(allPoolsMu));
        defer.push_back([=]{ Unlock(gocpp::recv(allPoolsMu)); });
        auto pid = runtime_procPin();
        auto s = p->localSize;
        auto l = p->local;
        if(uintptr(pid) < s)
        {
            return {indexLocal(l, pid), pid};
        }
        if(p->local == nullptr)
        {
            allPools = append(allPools, p);
        }
        auto size = runtime::GOMAXPROCS(0);
        auto local = gocpp::make(gocpp::Tag<gocpp::slice<poolLocal>>(), size);
        StorePointer(gocpp::recv(atomic), & p->local, Pointer(gocpp::recv(unsafe), & local[0]));
        runtime_StoreReluintptr(& p->localSize, uintptr(size));
        return {& local[pid], pid};
    }

    void poolCleanup()
    {
        for(auto [_, p] : oldPools)
        {
            p->victim = nullptr;
            p->victimSize = 0;
        }
        for(auto [_, p] : allPools)
        {
            p->victim = p->local;
            p->victimSize = p->localSize;
            p->local = nullptr;
            p->localSize = 0;
        }
        std::tie(oldPools, allPools) = std::tuple{allPools, nullptr};
    }

    Mutex allPoolsMu;
    gocpp::slice<Pool*> allPools;
    gocpp::slice<Pool*> oldPools;
    void init()
    {
        runtime_registerPoolCleanup(poolCleanup);
    }

    poolLocal* indexLocal(unsafe::Pointer l, int i)
    {
        auto lp = Pointer(gocpp::recv(unsafe), uintptr(l) + uintptr(i) * Sizeof(gocpp::recv(unsafe), poolLocal {}));
        return (*poolLocal)(lp);
    }

    void runtime_registerPoolCleanup(std::function<void ()> cleanup)
    /* convertBlockStmt, nil block */;

    int runtime_procPin()
    /* convertBlockStmt, nil block */;

    void runtime_procUnpin()
    /* convertBlockStmt, nil block */;

    uintptr_t runtime_LoadAcquintptr(uintptr_t* ptr)
    /* convertBlockStmt, nil block */;

    uintptr_t runtime_StoreReluintptr(uintptr_t* ptr, uintptr_t val)
    /* convertBlockStmt, nil block */;

}

