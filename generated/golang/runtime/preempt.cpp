// generated by GoCpp from file '$(ImportDir)/runtime/preempt.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/preempt.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/symtabinl.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    suspendGState::operator T()
    {
        T result;
        result.g = this->g;
        result.dead = this->dead;
        result.stopped = this->stopped;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool suspendGState::operator==(const T& ref) const
    {
        if (g != ref.g) return false;
        if (dead != ref.dead) return false;
        if (stopped != ref.stopped) return false;
        return true;
    }

    std::ostream& suspendGState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g;
        os << " " << dead;
        os << " " << stopped;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct suspendGState& value)
    {
        return value.PrintTo(os);
    }

    struct suspendGState suspendG(struct g* gp)
    {
        if(auto mp = getg()->m; mp->curg != nullptr && readgstatus(mp->curg) == _Grunning)
        {
            go_throw("suspendG from non-preemptible goroutine");
        }
        auto yieldDelay = 10 * 1000;
        int64_t nextYield = {};
        auto stopped = false;
        m* asyncM = {};
        uint32_t asyncGen = {};
        int64_t nextPreemptM = {};
        for(auto i = 0; ; i++)
        {
            //Go switch emulation
            {
                auto s = readgstatus(gp);
                auto condition = s;
                int conditionId = -1;
                if(condition == _Gdead) { conditionId = 0; }
                else if(condition == _Gcopystack) { conditionId = 1; }
                else if(condition == _Gpreempted) { conditionId = 2; }
                else if(condition == _Grunnable) { conditionId = 3; }
                else if(condition == _Gsyscall) { conditionId = 4; }
                else if(condition == _Gwaiting) { conditionId = 5; }
                else if(condition == _Grunning) { conditionId = 6; }
                switch(conditionId)
                {
                    default:
                        if(s & _Gscan != 0)
                        {
                            break;
                        }
                        dumpgstatus(gp);
                        go_throw("invalid g status");
                        break;
                    case 0:
                        return gocpp::Init<suspendGState>([=](auto& x) {
                            x.dead = true;
                        });
                        break;
                    case 1:
                        break;
                    case 2:
                        if(! casGFromPreempted(gp, _Gpreempted, _Gwaiting))
                        {
                            break;
                        }
                        stopped = true;
                        s = _Gwaiting;
                    case 3:
                    case 4:
                    case 5:
                        if(! castogscanstatus(gp, s, s | _Gscan))
                        {
                            break;
                        }
                        gp->preemptStop = false;
                        gp->preempt = false;
                        gp->stackguard0 = gp->stack.lo + stackGuard;
                        return gocpp::Init<suspendGState>([=](auto& x) {
                            x.g = gp;
                            x.stopped = stopped;
                        });
                        break;
                    case 6:
                        if(gp->preemptStop && gp->preempt && gp->stackguard0 == stackPreempt && asyncM == gp->m && rec::Load(gocpp::recv(asyncM->preemptGen)) == asyncGen)
                        {
                            break;
                        }
                        if(! castogscanstatus(gp, _Grunning, _Gscanrunning))
                        {
                            break;
                        }
                        gp->preemptStop = true;
                        gp->preempt = true;
                        gp->stackguard0 = stackPreempt;
                        auto asyncM2 = gp->m;
                        auto asyncGen2 = rec::Load(gocpp::recv(asyncM2->preemptGen));
                        auto needAsync = asyncM != asyncM2 || asyncGen != asyncGen2;
                        asyncM = asyncM2;
                        asyncGen = asyncGen2;
                        casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning);
                        if(preemptMSupported && debug.asyncpreemptoff == 0 && needAsync)
                        {
                            auto now = nanotime();
                            if(now >= nextPreemptM)
                            {
                                nextPreemptM = now + yieldDelay / 2;
                                preemptM(asyncM);
                            }
                        }
                        break;
                }
            }
            if(i == 0)
            {
                nextYield = nanotime() + yieldDelay;
            }
            if(nanotime() < nextYield)
            {
                procyield(10);
            }
            else
            {
                osyield();
                nextYield = nanotime() + yieldDelay / 2;
            }
        }
    }

    void resumeG(struct suspendGState state)
    {
        if(state.dead)
        {
            return;
        }
        auto gp = state.g;
        //Go switch emulation
        {
            auto s = readgstatus(gp);
            auto condition = s;
            int conditionId = -1;
            if(condition == _Grunnable | _Gscan) { conditionId = 0; }
            else if(condition == _Gwaiting | _Gscan) { conditionId = 1; }
            else if(condition == _Gsyscall | _Gscan) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    dumpgstatus(gp);
                    go_throw("unexpected g status");
                    break;
                case 0:
                case 1:
                case 2:
                    casfrom_Gscanstatus(gp, s, s &^ _Gscan);
                    break;
            }
        }
        if(state.stopped)
        {
            ready(gp, 0, true);
        }
    }

    bool canPreemptM(struct m* mp)
    {
        return mp->locks == 0 && mp->mallocing == 0 && mp->preemptoff == "" && rec::ptr(gocpp::recv(mp->p))->status == _Prunning;
    }

    void asyncPreempt()
    /* convertBlockStmt, nil block */;

    void asyncPreempt2()
    {
        auto gp = getg();
        gp->asyncSafePoint = true;
        if(gp->preemptStop)
        {
            mcall(preemptPark);
        }
        else
        {
            mcall(gopreempt_m);
        }
        gp->asyncSafePoint = false;
    }

    uintptr_t asyncPreemptStack = ~ uintptr_t(0);
    void init()
    {
        auto f = findfunc(abi::FuncPCABI0(asyncPreempt));
        auto total = funcMaxSPDelta(f);
        f = findfunc(abi::FuncPCABIInternal(asyncPreempt2));
        total += funcMaxSPDelta(f);
        asyncPreemptStack = uintptr_t(total) + 8 * goarch::PtrSize;
        if(asyncPreemptStack > stackNosplit)
        {
            print("runtime: asyncPreemptStack=", asyncPreemptStack, "\n");
            go_throw("async stack too large");
        }
    }

    bool wantAsyncPreempt(struct g* gp)
    {
        return (gp->preempt || gp->m->p != 0 && rec::ptr(gocpp::recv(gp->m->p))->preempt) && readgstatus(gp) &^ _Gscan == _Grunning;
    }

    std::tuple<bool, uintptr_t> isAsyncSafePoint(struct g* gp, uintptr_t pc, uintptr_t sp, uintptr_t lr)
    {
        auto mp = gp->m;
        if(mp->curg != gp)
        {
            return {false, 0};
        }
        if(mp->p == 0 || ! canPreemptM(mp))
        {
            return {false, 0};
        }
        if(sp < gp->stack.lo || sp - gp->stack.lo < asyncPreemptStack)
        {
            return {false, 0};
        }
        auto f = findfunc(pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return {false, 0};
        }
        if((GOARCH == "mips" || GOARCH == "mipsle" || GOARCH == "mips64" || GOARCH == "mips64le") && lr == pc + 8 && funcspdelta(f, pc) == 0)
        {
            return {false, 0};
        }
        auto [up, startpc] = pcdatavalue2(f, abi::PCDATA_UnsafePoint, pc);
        if(up == abi::UnsafePointUnsafe)
        {
            return {false, 0};
        }
        if(auto fd = funcdata(f, abi::FUNCDATA_LocalsPointerMaps); fd == nullptr || f.flag & abi::FuncFlagAsm != 0)
        {
            return {false, 0};
        }
        auto [u, uf] = newInlineUnwinder(f, pc);
        auto name = rec::name(gocpp::recv(rec::srcFunc(gocpp::recv(u), uf)));
        if(hasPrefix(name, "runtime.") || hasPrefix(name, "runtime/internal/") || hasPrefix(name, "reflect."))
        {
            return {false, 0};
        }
        //Go switch emulation
        {
            auto condition = up;
            int conditionId = -1;
            if(condition == abi::UnsafePointRestart1) { conditionId = 0; }
            else if(condition == abi::UnsafePointRestart2) { conditionId = 1; }
            else if(condition == abi::UnsafePointRestartAtEntry) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    if(startpc == 0 || startpc > pc || pc - startpc > 20)
                    {
                        go_throw("bad restart PC");
                    }
                    return {true, startpc};
                    break;
                case 2:
                    return {true, rec::entry(gocpp::recv(f))};
                    break;
            }
        }
        return {true, pc};
    }

}

