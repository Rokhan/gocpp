// generated by GoCpp from file '$(ImportDir)/runtime/trace2string.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2string.h"
#include "gocpp/support.h"

// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
// #include "golang/runtime/trace2map.h"  [Ignored, known errors]

namespace golang::runtime
{
    int maxTraceStringLen = 1024;
    
    std::ostream& traceStringTable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << buf;
        os << " " << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceStringTable& value)
    {
        return value.PrintTo(os);
    }

    uint64_t put(struct traceStringTable* t, uintptr_t gen, std::string s)
    {
        auto ss = stringStructOf(& s);
        auto [id, added] = put(gocpp::recv(t->tab), ss->str, uintptr(ss->len));
        if(added)
        {
            systemstack([=]() mutable -> void
            {
                writeString(gocpp::recv(t), gen, id, s);
            }
);
        }
        return id;
    }

    uint64_t emit(struct traceStringTable* t, uintptr_t gen, std::string s)
    {
        auto id = stealID(gocpp::recv(t->tab));
        systemstack([=]() mutable -> void
        {
            writeString(gocpp::recv(t), gen, id, s);
        }
);
        return id;
    }

    void writeString(struct traceStringTable* t, uintptr_t gen, uint64_t id, std::string s)
    {
        if(len(s) > maxTraceStringLen)
        {
            s = s.make_slice(0, maxTraceStringLen);
        }
        lock(& t->lock);
        auto w = unsafeTraceWriter(gen, t->buf);
        bool flushed = {};
        std::tie(w, flushed) = ensure(gocpp::recv(w), 2 + 2 * traceBytesPerNumber + len(s));
        if(flushed)
        {
            byte(gocpp::recv(w), byte(traceEvStrings));
        }
        byte(gocpp::recv(w), byte(traceEvString));
        varint(gocpp::recv(w), id);
        varint(gocpp::recv(w), uint64_t(len(s)));
        stringData(gocpp::recv(w), s);
        t->buf = w.traceBuf;
        unlock(& t->lock);
    }

    void reset(struct traceStringTable* t, uintptr_t gen)
    {
        if(t->buf != nullptr)
        {
            lock(& trace.lock);
            traceBufFlush(t->buf, gen);
            unlock(& trace.lock);
            t->buf = nullptr;
        }
        lock(& t->tab.lock);
        reset(gocpp::recv(t->tab));
        unlock(& t->tab.lock);
    }

}

