package main

import (
	"fmt"
	"io"
)

func generatedMessage(out io.Writer, cv *cppConverter) {
	fmt.Fprintf(out, "// generated by GoCpp from file '%v.go'\n", cv.srcBaseName)
}

func printCppIntro(cv *cppConverter, pkgInfos []*pkgInfo, receiversElts set[string]) {
	out := cv.cpp.out
	generatedMessage(out, cv)
	//temporarily blindly add "includes" and "using"
	fmt.Fprintf(out, "#include <complex>\n")
	fmt.Fprintf(out, "#include <functional>\n")
	fmt.Fprintf(out, "#include <iostream>\n")
	fmt.Fprintf(out, "#include <iomanip>\n")
	fmt.Fprintf(out, "#include <map>\n")
	fmt.Fprintf(out, "#include <string>\n")
	fmt.Fprintf(out, "#include <tuple>\n")
	fmt.Fprintf(out, "#include <vector>\n")
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, "#include \"%s.h\"\n", cv.baseName)
	fmt.Fprintf(out, "#include \"%s.h\"\n", cv.shared.supportHeader)
	fmt.Fprintf(out, "\n")

	includeDependencies(out, cv.shared.globalSubDir, pkgInfos, UsesTag, ".h")

	cv.ConvertDoc(cv.astFile.Doc)
	// Put everything generated in "golang" namespace
	fmt.Fprintf(out, "namespace golang::%v\n", cv.namespace)
	fmt.Fprintf(out, "{\n")

	fmt.Fprintf(out, "    namespace %s\n", recNs)
	fmt.Fprintf(out, "    {\n")
	fmt.Fprintf(out, "        using namespace mocklib::%s;\n", recNs)
	for _, elt := range mocklibReceiverElts {
		fmt.Fprintf(out, "        using mocklib::%s::%s;\n", recNs, elt)
	}
	for _, elt := range toSortedList(receiversElts) {
		fmt.Fprintf(out, "        using %s;\n", elt)
	}
	fmt.Fprintf(out, "    }\n\n")

	cv.cpp.indent++
}

func printCppOutro(cv *cppConverter) {
	out := cv.cpp.out
	// Closing golang namespace
	cv.cpp.indent--
	fmt.Fprintf(out, "}\n")
	fmt.Fprintf(out, "\n")

	if cv.hasMain {
		// TODO: manage main parameters
		fmt.Fprintf(out, "int main()\n")
		fmt.Fprintf(out, "{\n")
		fmt.Fprintf(out, "    try\n")
		fmt.Fprintf(out, "    {\n")
		fmt.Fprintf(out, "        std::cout << std::boolalpha << std::setprecision(5) << std::fixed;\n")
		fmt.Fprintf(out, "        golang::%v::main();\n", cv.namespace)
		fmt.Fprintf(out, "        return 0;\n")
		fmt.Fprintf(out, "    }\n")
		fmt.Fprintf(out, "    catch(const gocpp::GoPanic& ex)\n")
		fmt.Fprintf(out, "    {\n")
		fmt.Fprintf(out, "        std::cout << \"Panic: \" << ex.what() << std::endl;\n")
		fmt.Fprintf(out, "        return -1;\n")
		fmt.Fprintf(out, "    }\n")
		fmt.Fprintf(out, "}\n")
	}
}

func printHppIntro(cv *cppConverter, pkgInfos []*pkgInfo) {
	out := cv.hpp.out
	generatedMessage(out, cv)
	//temporarily blindly add "includes" and "using"
	fmt.Fprintf(out, "#pragma once\n")
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, "#include <functional>\n")
	fmt.Fprintf(out, "#include <string>\n")
	fmt.Fprintf(out, "#include <tuple>\n")
	fmt.Fprintf(out, "#include <vector>\n")
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, "#include \"%s.fwd.h\"\n", cv.baseName)
	fmt.Fprintf(out, "#include \"%s.h\"\n", cv.shared.supportHeader)
	fmt.Fprintf(out, "\n")

	// Can we do something with ".fwd.h" in some situations ?
	includeDependencies(out, cv.shared.globalSubDir, pkgInfos, DefsTag, ".h")

	// Put everything generated in "golang" namespace
	fmt.Fprintf(out, "namespace golang::%v\n", cv.namespace)
	fmt.Fprintf(out, "{\n")
	cv.hpp.indent++
}

func printHppOutro(cv *cppConverter) {
	out := cv.hpp.out
	// Closing golang namespace
	cv.hpp.indent--
	fmt.Fprintf(out, "}\n")
	fmt.Fprintf(out, "\n")
}

func printFwdIntro(cv *cppConverter /*, pkgInfos []*pkgInfo*/) {
	out := cv.fwd.out
	generatedMessage(out, cv)
	fmt.Fprintf(out, "#pragma once\n")
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, "#include \"%s.fwd.h\"\n", cv.shared.supportHeader)
	fmt.Fprintf(out, "\n")

	cv.fwd.indent++
}

func printFwdOutro(cv *cppConverter, inNamespace bool) {
	//ensure namespace is closed at end
	if inNamespace {
		fmt.Fprintf(cv.fwd.out, "}\n")
	}
	// Close golang namespace
	cv.fwd.indent--
}
