// generated by GoCpp from file '$(ImportDir)/errors/wrap.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/errors/wrap.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/reflectlite/type.h"
#include "golang/internal/reflectlite/value.h"

namespace golang::errors
{
    struct gocpp::error Unwrap(struct gocpp::error err);
    struct gocpp_id_0 : gocpp::Interface
    {
        gocpp_id_0(){}
        gocpp_id_0(gocpp_id_0& i) = default;
        gocpp_id_0(const gocpp_id_0& i) = default;
        gocpp_id_0& operator=(gocpp_id_0& i) = default;
        gocpp_id_0& operator=(const gocpp_id_0& i) = default;

        template<typename T>
        gocpp_id_0(T& ref);

        template<typename T>
        gocpp_id_0(const T& ref);

        template<typename T>
        gocpp_id_0(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_0
        {
            virtual struct gocpp::error vUnwrap() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_0Impl : Igocpp_id_0
        {
            explicit gocpp_id_0Impl(T* ptr)
            {
                value.reset(ptr);
            }

            struct gocpp::error vUnwrap() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_0> value;
    };

    struct gocpp::error Unwrap(const gocpp::PtrRecv<gocpp_id_0, false>& self);
    struct gocpp::error Unwrap(const gocpp::ObjRecv<gocpp_id_0>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    bool Is(struct gocpp::error err, struct gocpp::error target);
    bool is(struct gocpp::error err, struct gocpp::error target, bool targetComparable);
    struct gocpp_id_1 : gocpp::Interface
    {
        gocpp_id_1(){}
        gocpp_id_1(gocpp_id_1& i) = default;
        gocpp_id_1(const gocpp_id_1& i) = default;
        gocpp_id_1& operator=(gocpp_id_1& i) = default;
        gocpp_id_1& operator=(const gocpp_id_1& i) = default;

        template<typename T>
        gocpp_id_1(T& ref);

        template<typename T>
        gocpp_id_1(const T& ref);

        template<typename T>
        gocpp_id_1(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_1
        {
            virtual bool vIs(gocpp::error) = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_1Impl : Igocpp_id_1
        {
            explicit gocpp_id_1Impl(T* ptr)
            {
                value.reset(ptr);
            }

            bool vIs(gocpp::error) override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_1> value;
    };

    bool Is(const gocpp::PtrRecv<gocpp_id_1, false>& self, gocpp::error);
    bool Is(const gocpp::ObjRecv<gocpp_id_1>& self, gocpp::error);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value);
    struct gocpp_id_3 : gocpp::Interface
    {
        gocpp_id_3(){}
        gocpp_id_3(gocpp_id_3& i) = default;
        gocpp_id_3(const gocpp_id_3& i) = default;
        gocpp_id_3& operator=(gocpp_id_3& i) = default;
        gocpp_id_3& operator=(const gocpp_id_3& i) = default;

        template<typename T>
        gocpp_id_3(T& ref);

        template<typename T>
        gocpp_id_3(const T& ref);

        template<typename T>
        gocpp_id_3(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_3
        {
            virtual struct gocpp::error vUnwrap() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_3Impl : Igocpp_id_3
        {
            explicit gocpp_id_3Impl(T* ptr)
            {
                value.reset(ptr);
            }

            struct gocpp::error vUnwrap() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_3> value;
    };

    struct gocpp::error Unwrap(const gocpp::PtrRecv<gocpp_id_3, false>& self);
    struct gocpp::error Unwrap(const gocpp::ObjRecv<gocpp_id_3>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value);
    struct gocpp_id_4 : gocpp::Interface
    {
        gocpp_id_4(){}
        gocpp_id_4(gocpp_id_4& i) = default;
        gocpp_id_4(const gocpp_id_4& i) = default;
        gocpp_id_4& operator=(gocpp_id_4& i) = default;
        gocpp_id_4& operator=(const gocpp_id_4& i) = default;

        template<typename T>
        gocpp_id_4(T& ref);

        template<typename T>
        gocpp_id_4(const T& ref);

        template<typename T>
        gocpp_id_4(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_4
        {
            virtual gocpp::slice<gocpp::error> vUnwrap() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_4Impl : Igocpp_id_4
        {
            explicit gocpp_id_4Impl(T* ptr)
            {
                value.reset(ptr);
            }

            gocpp::slice<gocpp::error> vUnwrap() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_4> value;
    };

    gocpp::slice<gocpp::error> Unwrap(const gocpp::PtrRecv<gocpp_id_4, false>& self);
    gocpp::slice<gocpp::error> Unwrap(const gocpp::ObjRecv<gocpp_id_4>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_4& value);
    bool As(struct gocpp::error err, go_any target);
    bool as(struct gocpp::error err, go_any target, struct reflectlite::Value targetVal, struct reflectlite::Type targetType);
    struct gocpp_id_5 : gocpp::Interface
    {
        gocpp_id_5(){}
        gocpp_id_5(gocpp_id_5& i) = default;
        gocpp_id_5(const gocpp_id_5& i) = default;
        gocpp_id_5& operator=(gocpp_id_5& i) = default;
        gocpp_id_5& operator=(const gocpp_id_5& i) = default;

        template<typename T>
        gocpp_id_5(T& ref);

        template<typename T>
        gocpp_id_5(const T& ref);

        template<typename T>
        gocpp_id_5(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_5
        {
            virtual bool vAs(go_any) = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_5Impl : Igocpp_id_5
        {
            explicit gocpp_id_5Impl(T* ptr)
            {
                value.reset(ptr);
            }

            bool vAs(go_any) override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_5> value;
    };

    bool As(const gocpp::PtrRecv<gocpp_id_5, false>& self, go_any);
    bool As(const gocpp::ObjRecv<gocpp_id_5>& self, go_any);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_5& value);
    struct gocpp_id_7 : gocpp::Interface
    {
        gocpp_id_7(){}
        gocpp_id_7(gocpp_id_7& i) = default;
        gocpp_id_7(const gocpp_id_7& i) = default;
        gocpp_id_7& operator=(gocpp_id_7& i) = default;
        gocpp_id_7& operator=(const gocpp_id_7& i) = default;

        template<typename T>
        gocpp_id_7(T& ref);

        template<typename T>
        gocpp_id_7(const T& ref);

        template<typename T>
        gocpp_id_7(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_7
        {
            virtual struct gocpp::error vUnwrap() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_7Impl : Igocpp_id_7
        {
            explicit gocpp_id_7Impl(T* ptr)
            {
                value.reset(ptr);
            }

            struct gocpp::error vUnwrap() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_7> value;
    };

    struct gocpp::error Unwrap(const gocpp::PtrRecv<gocpp_id_7, false>& self);
    struct gocpp::error Unwrap(const gocpp::ObjRecv<gocpp_id_7>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value);
    struct gocpp_id_8 : gocpp::Interface
    {
        gocpp_id_8(){}
        gocpp_id_8(gocpp_id_8& i) = default;
        gocpp_id_8(const gocpp_id_8& i) = default;
        gocpp_id_8& operator=(gocpp_id_8& i) = default;
        gocpp_id_8& operator=(const gocpp_id_8& i) = default;

        template<typename T>
        gocpp_id_8(T& ref);

        template<typename T>
        gocpp_id_8(const T& ref);

        template<typename T>
        gocpp_id_8(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_8
        {
            virtual gocpp::slice<gocpp::error> vUnwrap() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_8Impl : Igocpp_id_8
        {
            explicit gocpp_id_8Impl(T* ptr)
            {
                value.reset(ptr);
            }

            gocpp::slice<gocpp::error> vUnwrap() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_8> value;
    };

    gocpp::slice<gocpp::error> Unwrap(const gocpp::PtrRecv<gocpp_id_8, false>& self);
    gocpp::slice<gocpp::error> Unwrap(const gocpp::ObjRecv<gocpp_id_8>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_8& value);
    extern reflectlite::Type errorType;
}

