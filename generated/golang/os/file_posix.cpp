// generated by GoCpp from file '$(ImportDir)/os/file_posix.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file_posix.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_fsync_windows.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_posix.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir_windows.h"
#include "golang/os/error.h"
#include "golang/os/file.h"
#include "golang/os/file_windows.h"
#include "golang/os/path_windows.h"
#include "golang/os/types.h"
#include "golang/runtime/mfinal.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace fs::rec;
        using namespace os::rec;
        using namespace poll::rec;
        using namespace runtime::rec;
        using namespace sync::rec;
        using namespace syscall::rec;
        using namespace time::rec;
        using namespace windows::rec;
    }

    struct gocpp::error rec::Close(struct File* f)
    {
        if(f == nullptr)
        {
            return ErrInvalid;
        }
        return rec::close(gocpp::recv(f->file));
    }

    std::tuple<int, struct gocpp::error> rec::read(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Read(gocpp::recv(f->pfd), b);
        runtime::KeepAlive(f);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> rec::pread(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Pread(gocpp::recv(f->pfd), b, off);
        runtime::KeepAlive(f);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> rec::write(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Write(gocpp::recv(f->pfd), b);
        runtime::KeepAlive(f);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> rec::pwrite(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = rec::Pwrite(gocpp::recv(f->pfd), b, off);
        runtime::KeepAlive(f);
        return {n, err};
    }

    uint32_t syscallMode(golang::os::FileMode i)
    {
        uint32_t o;
        o |= uint32_t(rec::Perm(gocpp::recv(i)));
        if(i & ModeSetuid != 0)
        {
            uint32_t o;
            o |= syscall::S_ISUID;
        }
        if(i & ModeSetgid != 0)
        {
            uint32_t o;
            o |= syscall::S_ISGID;
        }
        if(i & ModeSticky != 0)
        {
            uint32_t o;
            o |= syscall::S_ISVTX;
        }
        return o;
    }

    struct gocpp::error chmod(std::string name, golang::os::FileMode mode)
    {
        auto longName = fixLongPath(name);
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Chmod(longName, syscallMode(mode));
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chmod";
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    struct gocpp::error rec::chmod(struct File* f, golang::os::FileMode mode)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "chmod"); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fchmod(gocpp::recv(f->pfd), syscallMode(mode)); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "chmod", e);
        }
        return nullptr;
    }

    struct gocpp::error Chown(std::string name, int uid, int gid)
    {
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Chown(name, uid, gid);
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chown";
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    struct gocpp::error Lchown(std::string name, int uid, int gid)
    {
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Lchown(name, uid, gid);
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "lchown";
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    struct gocpp::error rec::Chown(struct File* f, int uid, int gid)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "chown"); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fchown(gocpp::recv(f->pfd), uid, gid); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "chown", e);
        }
        return nullptr;
    }

    struct gocpp::error rec::Truncate(struct File* f, int64_t size)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "truncate"); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Ftruncate(gocpp::recv(f->pfd), size); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "truncate", e);
        }
        return nullptr;
    }

    struct gocpp::error rec::Sync(struct File* f)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "sync"); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fsync(gocpp::recv(f->pfd)); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "sync", e);
        }
        return nullptr;
    }

    struct gocpp::error Chtimes(std::string name, mocklib::Date atime, mocklib::Date mtime)
    {
        gocpp::array<syscall::Timespec, 2> utimes = {};
        auto set = [=](int i, mocklib::Date t) mutable -> void
        {
            if(rec::IsZero(gocpp::recv(t)))
            {
                utimes[i] = gocpp::Init<syscall::Timespec>([=](auto& x) {
                    x.Sec = _UTIME_OMIT;
                    x.Nsec = _UTIME_OMIT;
                });
            }
            else
            {
                utimes[i] = syscall::NsecToTimespec(rec::UnixNano(gocpp::recv(t)));
            }
        };
        set(0, atime);
        set(1, mtime);
        if(auto e = syscall::UtimesNano(fixLongPath(name), utimes.make_slice(0)); e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chtimes";
                x.Path = name;
                x.Err = e;
            });
        }
        return nullptr;
    }

    struct gocpp::error rec::Chdir(struct File* f)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "chdir"); err != nullptr)
        {
            return err;
        }
        if(auto e = rec::Fchdir(gocpp::recv(f->pfd)); e != nullptr)
        {
            return rec::wrapErr(gocpp::recv(f), "chdir", e);
        }
        return nullptr;
    }

    struct gocpp::error rec::setDeadline(struct File* f, mocklib::Date t)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SetDeadline"); err != nullptr)
        {
            return err;
        }
        return rec::SetDeadline(gocpp::recv(f->pfd), t);
    }

    struct gocpp::error rec::setReadDeadline(struct File* f, mocklib::Date t)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SetReadDeadline"); err != nullptr)
        {
            return err;
        }
        return rec::SetReadDeadline(gocpp::recv(f->pfd), t);
    }

    struct gocpp::error rec::setWriteDeadline(struct File* f, mocklib::Date t)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SetWriteDeadline"); err != nullptr)
        {
            return err;
        }
        return rec::SetWriteDeadline(gocpp::recv(f->pfd), t);
    }

    struct gocpp::error rec::checkValid(struct File* f, std::string op)
    {
        if(f == nullptr)
        {
            return ErrInvalid;
        }
        return nullptr;
    }

    struct gocpp::error ignoringEINTR(std::function<struct gocpp::error ()> fn)
    {
        for(; ; )
        {
            auto err = fn();
            if(err != syscall::go_EINTR)
            {
                return err;
            }
        }
    }

}

