// generated by GoCpp from file '$(ImportDir)/runtime/trace2.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mem.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
// #include "golang/runtime/preempt.h"  [Ignored, known errors]
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/race0.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/sema.h"  [Ignored, known errors]
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2cpu.h"
#include "golang/runtime/trace2event.h"
// #include "golang/runtime/trace2map.h"  [Ignored, known errors]
// #include "golang/runtime/trace2region.h"  [Ignored, known errors]
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_1::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_1::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_1::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
    {
        return value.PrintTo(os);
    }


    struct gocpp_id_0
    {
        mutex lock;
        traceBuf* reading;
        traceBuf* empty;
        gocpp::array<traceBufQueue, 2> full;
        atomic::Bool workAvailable;
        atomic::Uintptr readerGen;
        atomic::Uintptr flushedGen;
        bool headerWritten;
        gocpp::array<uint32_t, 2> doneSema;
        gocpp::array<traceStackTable, 2> stackTab;
        gocpp::array<traceStringTable, 2> stringTab;
        gocpp::array<profBuf*, 2> cpuLogRead;
        atomic::Uint32 signalLock;
        gocpp::array<atomic::Pointer<profBuf>, 2> cpuLogWrite;
        wakeableSleep* cpuSleep;
        gocpp::channel<gocpp_id_1> cpuLogDone;
        gocpp::array<traceBuf*, 2> cpuBuf;
        atomic::Pointer<g> reader;
        gocpp::array<gocpp::array<golang::runtime::traceArg, len(gcMarkWorkerModeStrings)>, 2> markWorkerLabels;
        gocpp::array<gocpp::array<golang::runtime::traceArg, len(traceGoStopReasonStrings)>, 2> goStopReasons;
        gocpp::array<gocpp::array<golang::runtime::traceArg, len(traceBlockReasonStrings)>, 2> goBlockReasons;
        atomic::Uintptr gen;
        uintptr_t lastNonZeroGen;
        atomic::Bool shutdown;
        atomic::Int32 exitingSyscall;
        uint64_t seqGC;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.lock = this->lock;
            result.reading = this->reading;
            result.empty = this->empty;
            result.full = this->full;
            result.workAvailable = this->workAvailable;
            result.readerGen = this->readerGen;
            result.flushedGen = this->flushedGen;
            result.headerWritten = this->headerWritten;
            result.doneSema = this->doneSema;
            result.stackTab = this->stackTab;
            result.stringTab = this->stringTab;
            result.cpuLogRead = this->cpuLogRead;
            result.signalLock = this->signalLock;
            result.cpuLogWrite = this->cpuLogWrite;
            result.cpuSleep = this->cpuSleep;
            result.cpuLogDone = this->cpuLogDone;
            result.cpuBuf = this->cpuBuf;
            result.reader = this->reader;
            result.markWorkerLabels = this->markWorkerLabels;
            result.goStopReasons = this->goStopReasons;
            result.goBlockReasons = this->goBlockReasons;
            result.gen = this->gen;
            result.lastNonZeroGen = this->lastNonZeroGen;
            result.shutdown = this->shutdown;
            result.exitingSyscall = this->exitingSyscall;
            result.seqGC = this->seqGC;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (lock != ref.lock) return false;
            if (reading != ref.reading) return false;
            if (empty != ref.empty) return false;
            if (full != ref.full) return false;
            if (workAvailable != ref.workAvailable) return false;
            if (readerGen != ref.readerGen) return false;
            if (flushedGen != ref.flushedGen) return false;
            if (headerWritten != ref.headerWritten) return false;
            if (doneSema != ref.doneSema) return false;
            if (stackTab != ref.stackTab) return false;
            if (stringTab != ref.stringTab) return false;
            if (cpuLogRead != ref.cpuLogRead) return false;
            if (signalLock != ref.signalLock) return false;
            if (cpuLogWrite != ref.cpuLogWrite) return false;
            if (cpuSleep != ref.cpuSleep) return false;
            if (cpuLogDone != ref.cpuLogDone) return false;
            if (cpuBuf != ref.cpuBuf) return false;
            if (reader != ref.reader) return false;
            if (markWorkerLabels != ref.markWorkerLabels) return false;
            if (goStopReasons != ref.goStopReasons) return false;
            if (goBlockReasons != ref.goBlockReasons) return false;
            if (gen != ref.gen) return false;
            if (lastNonZeroGen != ref.lastNonZeroGen) return false;
            if (shutdown != ref.shutdown) return false;
            if (exitingSyscall != ref.exitingSyscall) return false;
            if (seqGC != ref.seqGC) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << reading;
            os << " " << empty;
            os << " " << full;
            os << " " << workAvailable;
            os << " " << readerGen;
            os << " " << flushedGen;
            os << " " << headerWritten;
            os << " " << doneSema;
            os << " " << stackTab;
            os << " " << stringTab;
            os << " " << cpuLogRead;
            os << " " << signalLock;
            os << " " << cpuLogWrite;
            os << " " << cpuSleep;
            os << " " << cpuLogDone;
            os << " " << cpuBuf;
            os << " " << reader;
            os << " " << markWorkerLabels;
            os << " " << goStopReasons;
            os << " " << goBlockReasons;
            os << " " << gen;
            os << " " << lastNonZeroGen;
            os << " " << shutdown;
            os << " " << exitingSyscall;
            os << " " << seqGC;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 trace;
    uint32_t traceAdvanceSema = 1;
    uint32_t traceShutdownSema = 1;
    struct gocpp::error StartTrace()
    {
        if(traceEnabled() || traceShuttingDown())
        {
            return errorString("tracing is already enabled");
        }
        semacquire(& traceShutdownSema);
        semrelease(& traceShutdownSema);
        semacquire(& traceAdvanceSema);
        traceInitReadCPU();
        auto firstGen = traceNextGen(trace.lastNonZeroGen);
        trace.seqGC = 1;
        trace.headerWritten = false;
        rec::Store(gocpp::recv(trace.readerGen), firstGen);
        rec::Store(gocpp::recv(trace.flushedGen), 0);
        traceRegisterLabelsAndReasons(firstGen);
        auto stw = stopTheWorld(stwStartTrace);
        lock(& sched.sysmonlock);
        for(auto [gocpp_ignored, pp] : allp)
        {
            pp->trace.mSyscallID = - 1;
        }
        rec::Store(gocpp::recv(trace.gen), firstGen);
        for(; rec::Load(gocpp::recv(trace.exitingSyscall)) != 0; )
        {
            osyield();
        }
        auto tl = traceAcquire();
        rec::Gomaxprocs(gocpp::recv(tl), gomaxprocs);
        rec::STWStart(gocpp::recv(tl), stwStartTrace);
        if(gcphase == _GCmark || gcphase == _GCmarktermination)
        {
            rec::GCActive(gocpp::recv(tl));
        }
        rec::HeapGoal(gocpp::recv(tl));
        for(auto [gocpp_ignored, pp] : allp)
        {
            rec::end(gocpp::recv(rec::writeProcStatusForP(gocpp::recv(rec::writer(gocpp::recv(tl))), pp, pp == rec::ptr(gocpp::recv(tl.mp->p)))));
        }
        traceRelease(tl);
        unlock(& sched.sysmonlock);
        startTheWorld(stw);
        traceStartReadCPU();
        rec::start(gocpp::recv(traceAdvancer));
        semrelease(& traceAdvanceSema);
        return nullptr;
    }

    void StopTrace()
    {
        traceAdvance(true);
    }

    void traceAdvance(bool stopTrace)
    {
        semacquire(& traceAdvanceSema);
        auto gen = rec::Load(gocpp::recv(trace.gen));
        if(gen == 0)
        {
            semrelease(& traceAdvanceSema);
            return;
        }
        traceFrequency(gen);
        
        template<typename T> requires gocpp::GoStruct<T>
        untracedG::operator T()
        {
            T result;
            result.gp = this->gp;
            result.goid = this->goid;
            result.mid = this->mid;
            result.status = this->status;
            result.waitreason = this->waitreason;
            result.inMarkAssist = this->inMarkAssist;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool untracedG::operator==(const T& ref) const
        {
            if (gp != ref.gp) return false;
            if (goid != ref.goid) return false;
            if (mid != ref.mid) return false;
            if (status != ref.status) return false;
            if (waitreason != ref.waitreason) return false;
            if (inMarkAssist != ref.inMarkAssist) return false;
            return true;
        }

        std::ostream& untracedG::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << gp;
            os << " " << goid;
            os << " " << mid;
            os << " " << status;
            os << " " << waitreason;
            os << " " << inMarkAssist;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct untracedG& value)
        {
            return value.PrintTo(os);
        }

        gocpp::slice<untracedG> untracedGs = {};
        forEachGRace([=](struct g* gp) mutable -> void
        {
            rec::readyNextGen(gocpp::recv(gp->trace), gen);
            if(rec::statusWasTraced(gocpp::recv(gp->trace), gen))
            {
                return;
            }
            auto ug = gocpp::Init<untracedG>([](untracedG& x) { x.gp = gp; x.mid = - 1; });
            systemstack([=]() mutable -> void
            {
                auto me = getg()->m->curg;
                casGToWaiting(me, _Grunning, waitReasonTraceGoroutineStatus);
                auto s = suspendG(gp);
                if(! s.dead)
                {
                    ug.goid = s.g->goid;
                    if(s.g->m != nullptr)
                    {
                        ug.mid = int64_t(s.g->m->procid);
                    }
                    ug.status = readgstatus(s.g) &^ _Gscan;
                    ug.waitreason = s.g->waitreason;
                    ug.inMarkAssist = s.g->inMarkAssist;
                }
                resumeG(s);
                casgstatus(me, _Gwaiting, _Grunning);
            });
            if(ug.goid != 0)
            {
                untracedGs = append(untracedGs, ug);
            }
        });
        if(! stopTrace)
        {
            traceRegisterLabelsAndReasons(traceNextGen(gen));
        }
        semacquire(& worldsema);
        auto mp = acquirem();
        trace.lastNonZeroGen = gen;
        if(stopTrace)
        {
            systemstack([=]() mutable -> void
            {
                lock(& trace.lock);
                rec::Store(gocpp::recv(trace.shutdown), true);
                rec::Store(gocpp::recv(trace.gen), 0);
                unlock(& trace.lock);
            });
        }
        else
        {
            rec::Store(gocpp::recv(trace.gen), traceNextGen(gen));
        }
        if(! stopTrace)
        {
            auto tl = traceAcquire();
            rec::Gomaxprocs(gocpp::recv(tl), gomaxprocs);
            traceRelease(tl);
        }
        if(! stopTrace && (gcphase == _GCmark || gcphase == _GCmarktermination))
        {
            auto tl = traceAcquire();
            rec::GCActive(gocpp::recv(tl));
            traceRelease(tl);
        }
        releasem(mp);
        semrelease(& worldsema);
        lock(& sched.lock);
        auto mToFlush = allm;
        for(auto mp = mToFlush; mp != nullptr; mp = mp->alllink)
        {
            mp->trace.link = mp->alllink;
        }
        for(auto mp = sched.freem; mp != nullptr; mp = mp->freelink)
        {
            mp->trace.link = mToFlush;
            mToFlush = mp;
        }
        unlock(& sched.lock);
        auto debugDeadlock = false;
        systemstack([=]() mutable -> void
        {
            auto i = 0;
            auto detectedDeadlock = false;
            for(; mToFlush != nullptr; )
            {
                auto prev = & mToFlush;
                for(auto mp = *prev; mp != nullptr; )
                {
                    if(rec::Load(gocpp::recv(mp->trace.seqlock)) % 2 != 0)
                    {
                        prev = & mp->trace.link;
                        mp = mp->trace.link;
                        continue;
                    }
                    lock(& trace.lock);
                    auto bufp = & mp->trace.buf[gen % 2];
                    if(*bufp != nullptr)
                    {
                        traceBufFlush(*bufp, gen);
                        *bufp = nullptr;
                    }
                    unlock(& trace.lock);
                    *prev = mp->trace.link;
                    mp->trace.link = nullptr;
                    mp = *prev;
                }
                if(mToFlush != nullptr)
                {
                    osyield();
                }
                if(debugDeadlock)
                {
                    if(i > 100000 && ! detectedDeadlock)
                    {
                        detectedDeadlock = true;
                        println("runtime: failing to flush");
                        for(auto mp = mToFlush; mp != nullptr; mp = mp->trace.link)
                        {
                            print("runtime: m=", mp->id, "\n");
                        }
                    }
                    i++;
                }
            }
        });
        auto statusWriter = unsafeTraceWriter(gen, nullptr);
        for(auto [gocpp_ignored, ug] : untracedGs)
        {
            if(rec::statusWasTraced(gocpp::recv(ug.gp->trace), gen))
            {
                continue;
            }
            auto status = goStatusToTraceGoStatus(ug.status, ug.waitreason);
            statusWriter = rec::writeGoStatus(gocpp::recv(statusWriter), ug.goid, ug.mid, status, ug.inMarkAssist);
        }
        rec::end(gocpp::recv(rec::flush(gocpp::recv(statusWriter))));
        traceReadCPU(gen);
        systemstack([=]() mutable -> void
        {
            traceCPUFlush(gen);
            rec::dump(gocpp::recv(trace.stackTab[gen % 2]), gen);
            rec::reset(gocpp::recv(trace.stringTab[gen % 2]), gen);
            lock(& trace.lock);
            rec::Store(gocpp::recv(trace.flushedGen), gen);
            unlock(& trace.lock);
        });
        if(stopTrace)
        {
            semacquire(& traceShutdownSema);
            traceStopReadCPU();
        }
        else
        {
            semacquire(& worldsema);
            forEachP(waitReasonTraceProcStatus, [=](struct p* pp) mutable -> void
            {
                auto tl = traceAcquire();
                if(! rec::statusWasTraced(gocpp::recv(pp->trace), tl.gen))
                {
                    rec::end(gocpp::recv(rec::writeProcStatusForP(gocpp::recv(rec::writer(gocpp::recv(tl))), pp, false)));
                }
                traceRelease(tl);
            });
            for(auto [gocpp_ignored, pp] : allp.make_slice(len(allp), cap(allp)))
            {
                rec::readyNextGen(gocpp::recv(pp->trace), traceNextGen(gen));
            }
            semrelease(& worldsema);
        }
        semacquire(& trace.doneSema[gen % 2]);
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& trace.doneSema[gen % 2]));
        }
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(! rec::empty(gocpp::recv(trace.full[gen % 2])))
            {
                go_throw("trace: non-empty full trace buffer for done generation");
            }
            if(stopTrace)
            {
                if(! rec::empty(gocpp::recv(trace.full[1 - (gen % 2)])))
                {
                    go_throw("trace: non-empty full trace buffer for next generation");
                }
                if(trace.reading != nullptr || rec::Load(gocpp::recv(trace.reader)) != nullptr)
                {
                    go_throw("trace: reading after shutdown");
                }
                for(; trace.empty != nullptr; )
                {
                    auto buf = trace.empty;
                    trace.empty = buf->link;
                    sysFree(unsafe::Pointer(buf), gocpp::Sizeof<traceBuf>(), & memstats.other_sys);
                }
                trace.headerWritten = false;
                rec::Store(gocpp::recv(trace.shutdown), false);
            }
            unlock(& trace.lock);
        });
        if(stopTrace)
        {
            auto mp = acquirem();
            for(auto [gocpp_ignored, pp] : allp.make_slice(0, cap(allp)))
            {
                pp->trace.inSweep = false;
                pp->trace.maySweep = false;
                pp->trace.swept = 0;
                pp->trace.reclaimed = 0;
            }
            releasem(mp);
        }
        semrelease1(& traceAdvanceSema, true, 0);
        if(stopTrace)
        {
            rec::stop(gocpp::recv(traceAdvancer));
            semrelease(& traceShutdownSema);
        }
    }

    uintptr_t traceNextGen(uintptr_t gen)
    {
        if(gen == ~ uintptr_t(0))
        {
            return 4;
        }
        return gen + 1;
    }

    void traceRegisterLabelsAndReasons(uintptr_t gen)
    {
        for(auto [i, label] : gcMarkWorkerModeStrings.make_slice(0, ))
        {
            trace.markWorkerLabels[gen % 2][i] = traceArg(rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, label));
        }
        for(auto [i, str] : traceBlockReasonStrings.make_slice(0, ))
        {
            trace.goBlockReasons[gen % 2][i] = traceArg(rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, str));
        }
        for(auto [i, str] : traceGoStopReasonStrings.make_slice(0, ))
        {
            trace.goStopReasons[gen % 2][i] = traceArg(rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, str));
        }
    }

    gocpp::slice<unsigned char> ReadTrace()
    {
        top:
        gocpp::slice<unsigned char> buf = {};
        bool park = {};
        systemstack([=]() mutable -> void
        {
            std::tie(buf, park) = readTrace0();
        });
        if(park)
        {
            gopark([=](struct g* gp, unsafe::Pointer _) mutable -> bool
            {
                if(! rec::CompareAndSwapNoWB(gocpp::recv(trace.reader), nullptr, gp))
                {
                    return false;
                }
                if(auto g2 = traceReader(); gp == g2)
                {
                    return false;
                }
                else
                if(g2 != nullptr)
                {
                    printlock();
                    println("runtime: got trace reader", g2, g2->goid);
                    go_throw("unexpected trace reader");
                }
                return true;
            }, nullptr, waitReasonTraceReaderBlocked, traceBlockSystemGoroutine, 2);
            goto top;
        }
        return buf;
    }

    std::tuple<gocpp::slice<unsigned char>, bool> readTrace0()
    {
        gocpp::Defer defer;
        try
        {
            gocpp::slice<unsigned char> buf;
            bool park;
            if(raceenabled)
            {
                gocpp::slice<unsigned char> buf;
                bool park;
                if(getg()->racectx != 0)
                {
                    gocpp::slice<unsigned char> buf;
                    bool park;
                    go_throw("expected racectx == 0");
                }
                getg()->racectx = getg()->m->curg->racectx;
                defer.push_back([=]{ [=]() mutable -> void
                {
                    getg()->racectx = 0;
                }(); });
            }
            lock(& trace.lock);
            if(rec::Load(gocpp::recv(trace.reader)) != nullptr)
            {
                gocpp::slice<unsigned char> buf;
                bool park;
                unlock(& trace.lock);
                println("runtime: ReadTrace called from multiple goroutines simultaneously");
                return {nullptr, false};
            }
            if(auto buf = trace.reading; buf != nullptr)
            {
                gocpp::slice<unsigned char> buf;
                bool park;
                buf->link = trace.empty;
                trace.empty = buf;
                trace.reading = nullptr;
            }
            if(! trace.headerWritten)
            {
                gocpp::slice<unsigned char> buf;
                bool park;
                trace.headerWritten = true;
                unlock(& trace.lock);
                return {gocpp::Tag<gocpp::slice<unsigned char>>()("go 1.22 trace\x00\x00\x00"), false};
            }
            if(rec::Load(gocpp::recv(trace.readerGen)) == 0)
            {
                gocpp::slice<unsigned char> buf;
                bool park;
                rec::Store(gocpp::recv(trace.readerGen), 1);
            }
            uintptr_t gen = {};
            for(; ; )
            {
                gocpp::slice<unsigned char> buf;
                bool park;
                assertLockHeld(& trace.lock);
                gen = rec::Load(gocpp::recv(trace.readerGen));
                if(! rec::empty(gocpp::recv(trace.full[gen % 2])))
                {
                    gocpp::slice<unsigned char> buf;
                    bool park;
                    break;
                }
                if(rec::Load(gocpp::recv(trace.flushedGen)) == gen)
                {
                    gocpp::slice<unsigned char> buf;
                    bool park;
                    if(rec::Load(gocpp::recv(trace.shutdown)))
                    {
                        gocpp::slice<unsigned char> buf;
                        bool park;
                        unlock(& trace.lock);
                        if(raceenabled)
                        {
                            gocpp::slice<unsigned char> buf;
                            bool park;
                            racerelease(unsafe::Pointer(& trace.doneSema[gen % 2]));
                        }
                        semrelease(& trace.doneSema[gen % 2]);
                        return {nullptr, false};
                    }
                    rec::Store(gocpp::recv(trace.readerGen), rec::Load(gocpp::recv(trace.gen)));
                    unlock(& trace.lock);
                    if(raceenabled)
                    {
                        gocpp::slice<unsigned char> buf;
                        bool park;
                        racerelease(unsafe::Pointer(& trace.doneSema[gen % 2]));
                    }
                    semrelease(& trace.doneSema[gen % 2]);
                    lock(& trace.lock);
                    continue;
                }
                rec::Store(gocpp::recv(trace.workAvailable), false);
                unlock(& trace.lock);
                return {nullptr, true};
            }
            auto tbuf = rec::pop(gocpp::recv(trace.full[gen % 2]));
            trace.reading = tbuf;
            unlock(& trace.lock);
            return {tbuf->arr.make_slice(0, tbuf->pos), false};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct g* traceReader()
    {
        auto gp = traceReaderAvailable();
        if(gp == nullptr || ! rec::CompareAndSwapNoWB(gocpp::recv(trace.reader), gp, nullptr))
        {
            return nullptr;
        }
        return gp;
    }

    struct g* traceReaderAvailable()
    {
        if(rec::Load(gocpp::recv(trace.flushedGen)) == rec::Load(gocpp::recv(trace.readerGen)) || rec::Load(gocpp::recv(trace.workAvailable)) || rec::Load(gocpp::recv(trace.shutdown)))
        {
            return rec::Load(gocpp::recv(trace.reader));
        }
        return nullptr;
    }

    traceAdvancerState traceAdvancer;
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_2::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_2::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_2::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    traceAdvancerState::operator T()
    {
        T result;
        result.timer = this->timer;
        result.done = this->done;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceAdvancerState::operator==(const T& ref) const
    {
        if (timer != ref.timer) return false;
        if (done != ref.done) return false;
        return true;
    }

    std::ostream& traceAdvancerState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << timer;
        os << " " << done;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceAdvancerState& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_3
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_4
            {

                using isGoStruct = void;

                template<typename T> requires gocpp::GoStruct<T>
                operator T()
                {
                    T result;
                    return result;
                }

                template<typename T> requires gocpp::GoStruct<T>
                bool operator==(const T& ref) const
                {
                    return true;
                }

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_4& value)
            {
                return value.PrintTo(os);
            }


    void rec::start(struct traceAdvancerState* s)
    {
        s->done = gocpp::make(gocpp::Tag<gocpp::channel<gocpp_id_3>>());
        s->timer = newWakeableSleep();
        gocpp::go([&]{ [=]() mutable -> void
        {
            for(; traceEnabled(); )
            {
                rec::sleep(gocpp::recv(s->timer), int64_t(debug.traceadvanceperiod));
                traceAdvance(false);
            }
            s->done.send(gocpp_id_4 {});
        }(); });
    }

    void rec::stop(struct traceAdvancerState* s)
    {
        rec::wake(gocpp::recv(s->timer));
        s->done.recv();
        close(s->done);
        rec::close(gocpp::recv(s->timer));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_5::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_5::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_5::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_5& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    wakeableSleep::operator T()
    {
        T result;
        result.timer = this->timer;
        result.lock = this->lock;
        result.wakeup = this->wakeup;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool wakeableSleep::operator==(const T& ref) const
    {
        if (timer != ref.timer) return false;
        if (lock != ref.lock) return false;
        if (wakeup != ref.wakeup) return false;
        return true;
    }

    std::ostream& wakeableSleep::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << timer;
        os << " " << lock;
        os << " " << wakeup;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct wakeableSleep& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_6
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value)
        {
            return value.PrintTo(os);
        }


    struct wakeableSleep* newWakeableSleep()
    {
        auto s = go_new(wakeableSleep);
        lockInit(& s->lock, lockRankWakeableSleep);
        s->wakeup = gocpp::make(gocpp::Tag<gocpp::channel<gocpp_id_6>>(), 1);
        s->timer = go_new(timer);
        s->timer->arg = s;
        s->timer->f = [=](go_any s, uintptr_t _) mutable -> void
        {
            rec::wake(gocpp::recv(gocpp::getValue<wakeableSleep*>(s)));
        };
        return s;
    }

    void rec::sleep(struct wakeableSleep* s, int64_t ns)
    {
        resetTimer(s->timer, nanotime() + ns);
        lock(& s->lock);
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& s->lock));
        }
        auto wakeup = s->wakeup;
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(& s->lock));
        }
        unlock(& s->lock);
        wakeup.recv();
        stopTimer(s->timer);
    }

    struct gocpp_id_7
                {

                    using isGoStruct = void;

                    template<typename T> requires gocpp::GoStruct<T>
                    operator T()
                    {
                        T result;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool operator==(const T& ref) const
                    {
                        return true;
                    }

                    std::ostream& PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << '}';
                        return os;
                    }
                };

                std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value)
                {
                    return value.PrintTo(os);
                }


    void rec::wake(struct wakeableSleep* s)
    {
        lock(& s->lock);
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& s->lock));
        }
        if(s->wakeup != nullptr)
        {
            //Go select emulation
            {
                int conditionId = -1;
                if(s->wakeup.trySend(gocpp_id_7 {})) { conditionId = 0; }
                switch(conditionId)
                {
                    case 0:
                        break;
                    default:
                        break;
                }
            }
            std::this_thread::yield();
        }
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(& s->lock));
        }
        unlock(& s->lock);
    }

    void rec::close(struct wakeableSleep* s)
    {
        lock(& s->lock);
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& s->lock));
        }
        auto wakeup = s->wakeup;
        s->wakeup = nullptr;
        close(wakeup);
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(& s->lock));
        }
        unlock(& s->lock);
        return;
    }

}

