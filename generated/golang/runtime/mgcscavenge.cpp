// generated by GoCpp from file '$(ImportDir)/runtime/mgcscavenge.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcscavenge.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goos/zgoos_windows.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/float.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagealloc_64bit.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace cpu::rec;
        using namespace goos::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    uint64_t heapRetained()
    {
        return rec::load(gocpp::recv(gcController.heapInUse)) + rec::load(gocpp::recv(gcController.heapFree));
    }

    void gcPaceScavenger(int64_t memoryLimit, uint64_t heapGoal, uint64_t lastHeapGoal)
    {
        assertWorldStoppedOrLockHeld(& mheap_.lock);
        auto memoryLimitGoal = uint64_t(double(memoryLimit) * (1 - reduceExtraPercent / 100.0));
        auto mappedReady = rec::Load(gocpp::recv(gcController.mappedReady));
        if(mappedReady <= memoryLimitGoal)
        {
            rec::Store(gocpp::recv(scavenge.memoryLimitGoal), ~ uint64_t(0));
        }
        else
        {
            rec::Store(gocpp::recv(scavenge.memoryLimitGoal), memoryLimitGoal);
        }
        if(lastHeapGoal == 0)
        {
            rec::Store(gocpp::recv(scavenge.gcPercentGoal), ~ uint64_t(0));
            return;
        }
        auto goalRatio = double(heapGoal) / double(lastHeapGoal);
        auto gcPercentGoal = uint64_t(double(memstats.lastHeapInUse) * goalRatio);
        gcPercentGoal += gcPercentGoal / (1.0 / (retainExtraPercent / 100.0));
        gcPercentGoal = (gcPercentGoal + uint64_t(physPageSize) - 1) &^ (uint64_t(physPageSize) - 1);
        auto heapRetainedNow = heapRetained();
        if(heapRetainedNow <= gcPercentGoal || heapRetainedNow - gcPercentGoal < uint64_t(physPageSize))
        {
            rec::Store(gocpp::recv(scavenge.gcPercentGoal), ~ uint64_t(0));
        }
        else
        {
            rec::Store(gocpp::recv(scavenge.gcPercentGoal), gcPercentGoal);
        }
    }

    struct gocpp_id_0
    {
        atomic::Uint64 gcPercentGoal;
        atomic::Uint64 memoryLimitGoal;
        atomic::Int64 assistTime;
        atomic::Int64 backgroundTime;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.gcPercentGoal = this->gcPercentGoal;
            result.memoryLimitGoal = this->memoryLimitGoal;
            result.assistTime = this->assistTime;
            result.backgroundTime = this->backgroundTime;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (gcPercentGoal != ref.gcPercentGoal) return false;
            if (memoryLimitGoal != ref.memoryLimitGoal) return false;
            if (assistTime != ref.assistTime) return false;
            if (backgroundTime != ref.backgroundTime) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << gcPercentGoal;
            os << " " << memoryLimitGoal;
            os << " " << assistTime;
            os << " " << backgroundTime;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 scavenge;
    scavengerState scavenger;
    
    template<typename T> requires gocpp::GoStruct<T>
    scavengerState::operator T()
    {
        T result;
        result.lock = this->lock;
        result.g = this->g;
        result.parked = this->parked;
        result.timer = this->timer;
        result.sysmonWake = this->sysmonWake;
        result.targetCPUFraction = this->targetCPUFraction;
        result.sleepRatio = this->sleepRatio;
        result.sleepController = this->sleepController;
        result.controllerCooldown = this->controllerCooldown;
        result.printControllerReset = this->printControllerReset;
        result.sleepStub = this->sleepStub;
        result.scavenge = this->scavenge;
        result.shouldStop = this->shouldStop;
        result.gomaxprocs = this->gomaxprocs;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool scavengerState::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (g != ref.g) return false;
        if (parked != ref.parked) return false;
        if (timer != ref.timer) return false;
        if (sysmonWake != ref.sysmonWake) return false;
        if (targetCPUFraction != ref.targetCPUFraction) return false;
        if (sleepRatio != ref.sleepRatio) return false;
        if (sleepController != ref.sleepController) return false;
        if (controllerCooldown != ref.controllerCooldown) return false;
        if (printControllerReset != ref.printControllerReset) return false;
        if (sleepStub != ref.sleepStub) return false;
        if (scavenge != ref.scavenge) return false;
        if (shouldStop != ref.shouldStop) return false;
        if (gomaxprocs != ref.gomaxprocs) return false;
        return true;
    }

    std::ostream& scavengerState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << g;
        os << " " << parked;
        os << " " << timer;
        os << " " << sysmonWake;
        os << " " << targetCPUFraction;
        os << " " << sleepRatio;
        os << " " << sleepController;
        os << " " << controllerCooldown;
        os << " " << printControllerReset;
        os << " " << sleepStub;
        os << " " << scavenge;
        os << " " << shouldStop;
        os << " " << gomaxprocs;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct scavengerState& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct scavengerState* s)
    {
        if(s->g != nullptr)
        {
            go_throw("scavenger state is already wired");
        }
        lockInit(& s->lock, lockRankScavenge);
        s->g = getg();
        s->timer = go_new(timer);
        s->timer->arg = s;
        s->timer->f = [=](go_any s, uintptr_t _1) mutable -> void
        {
            rec::wake(gocpp::recv(gocpp::getValue<scavengerState*>(s)));
        };
        s->sleepController = gocpp::Init<piController>([](auto& x) {
            x.kp = 0.3375;
            x.ti = 3.2e6;
            x.tt = 1e9;
            x.min = 0.001;
            x.max = 1000.0;
        });
        s->sleepRatio = startingScavSleepRatio;
        if(s->scavenge == nullptr)
        {
            s->scavenge = [=](uintptr_t n) mutable -> std::tuple<uintptr_t, int64_t>
            {
                auto start = nanotime();
                auto r = rec::scavenge(gocpp::recv(mheap_.pages), n, nullptr, false);
                auto end = nanotime();
                if(start >= end)
                {
                    return {r, 0};
                }
                rec::Add(gocpp::recv(scavenge.backgroundTime), end - start);
                return {r, end - start};
            };
        }
        if(s->shouldStop == nullptr)
        {
            s->shouldStop = [=]() mutable -> bool
            {
                return heapRetained() <= rec::Load(gocpp::recv(scavenge.gcPercentGoal)) && rec::Load(gocpp::recv(gcController.mappedReady)) <= rec::Load(gocpp::recv(scavenge.memoryLimitGoal));
            };
        }
        if(s->gomaxprocs == nullptr)
        {
            s->gomaxprocs = [=]() mutable -> int32_t
            {
                return gomaxprocs;
            };
        }
    }

    void rec::park(struct scavengerState* s)
    {
        lock(& s->lock);
        if(getg() != s->g)
        {
            go_throw("tried to park scavenger from another goroutine");
        }
        s->parked = true;
        goparkunlock(& s->lock, waitReasonGCScavengeWait, traceBlockSystemGoroutine, 2);
    }

    void rec::ready(struct scavengerState* s)
    {
        rec::Store(gocpp::recv(s->sysmonWake), 1);
    }

    void rec::wake(struct scavengerState* s)
    {
        lock(& s->lock);
        if(s->parked)
        {
            rec::Store(gocpp::recv(s->sysmonWake), 0);
            s->parked = false;
            gList list = {};
            rec::push(gocpp::recv(list), s->g);
            injectglist(& list);
        }
        unlock(& s->lock);
    }

    void rec::sleep(struct scavengerState* s, double worked)
    {
        lock(& s->lock);
        if(getg() != s->g)
        {
            go_throw("tried to sleep scavenger from another goroutine");
        }
        if(worked < minScavWorkTime)
        {
            worked = minScavWorkTime;
        }
        worked *= 1 + scavengeCostRatio;
        auto sleepTime = int64_t(worked / s->sleepRatio);
        int64_t slept = {};
        if(s->sleepStub == nullptr)
        {
            auto start = nanotime();
            resetTimer(s->timer, start + sleepTime);
            s->parked = true;
            goparkunlock(& s->lock, waitReasonSleep, traceBlockSleep, 2);
            slept = nanotime() - start;
            lock(& s->lock);
            stopTimer(s->timer);
            unlock(& s->lock);
        }
        else
        {
            unlock(& s->lock);
            slept = rec::sleepStub(gocpp::recv(s), sleepTime);
        }
        if(s->controllerCooldown > 0)
        {
            auto t = slept + int64_t(worked);
            if(t > s->controllerCooldown)
            {
                s->controllerCooldown = 0;
            }
            else
            {
                s->controllerCooldown -= t;
            }
            return;
        }
        auto idealFraction = double(scavengePercent) / 100.0;
        auto cpuFraction = worked / ((double(slept) + worked) * double(rec::gomaxprocs(gocpp::recv(s))));
        bool ok = {};
        std::tie(s->sleepRatio, ok) = rec::next(gocpp::recv(s->sleepController), cpuFraction, idealFraction, double(slept) + worked);
        if(! ok)
        {
            s->sleepRatio = startingScavSleepRatio;
            s->controllerCooldown = 5e9;
            rec::controllerFailed(gocpp::recv(s));
        }
    }

    void rec::controllerFailed(struct scavengerState* s)
    {
        lock(& s->lock);
        s->printControllerReset = true;
        unlock(& s->lock);
    }

    std::tuple<uintptr_t, double> rec::run(struct scavengerState* s)
    {
        uintptr_t released;
        double worked;
        lock(& s->lock);
        if(getg() != s->g)
        {
            uintptr_t released;
            double worked;
            go_throw("tried to run scavenger from another goroutine");
        }
        unlock(& s->lock);
        for(; worked < minScavWorkTime; )
        {
            uintptr_t released;
            double worked;
            if(rec::shouldStop(gocpp::recv(s)))
            {
                uintptr_t released;
                double worked;
                break;
            }
            auto scavengeQuantum = 64 << 10;
            auto [r, duration] = rec::scavenge(gocpp::recv(s), scavengeQuantum);
            auto approxWorkedNSPerPhysicalPage = 10e3;
            if(duration == 0)
            {
                uintptr_t released;
                double worked;
                worked += approxWorkedNSPerPhysicalPage * double(r / physPageSize);
            }
            else
            {
                uintptr_t released;
                double worked;
                worked += double(duration);
            }
            released += r;
            if(r < scavengeQuantum)
            {
                uintptr_t released;
                double worked;
                break;
            }
            if(faketime != 0)
            {
                uintptr_t released;
                double worked;
                break;
            }
        }
        if(released > 0 && released < physPageSize)
        {
            uintptr_t released;
            double worked;
            go_throw("released less than one physical page of memory");
        }
        return {released, worked};
    }

    void bgscavenge(gocpp::channel<int> c)
    {
        rec::init(gocpp::recv(scavenger));
        c.send(1);
        rec::park(gocpp::recv(scavenger));
        for(; ; )
        {
            auto [released, workTime] = rec::run(gocpp::recv(scavenger));
            if(released == 0)
            {
                rec::park(gocpp::recv(scavenger));
                continue;
            }
            rec::Add(gocpp::recv(mheap_.pages.scav.releasedBg), released);
            rec::sleep(gocpp::recv(scavenger), workTime);
        }
    }

    uintptr_t rec::scavenge(struct pageAlloc* p, uintptr_t nbytes, std::function<bool ()> shouldStop, bool force)
    {
        auto released = uintptr_t(0);
        for(; released < nbytes; )
        {
            auto [ci, pageIdx] = rec::find(gocpp::recv(p->scav.index), force);
            if(ci == 0)
            {
                break;
            }
            systemstack([=]() mutable -> void
            {
                released += rec::scavengeOne(gocpp::recv(p), ci, pageIdx, nbytes - released);
            });
            if(shouldStop != nullptr && shouldStop())
            {
                break;
            }
        }
        return released;
    }

    void printScavTrace(uintptr_t releasedBg, uintptr_t releasedEager, bool forced)
    {
        assertLockHeld(& scavenger.lock);
        printlock();
        print("scav ", releasedBg >> 10, " KiB work (bg), ", releasedEager >> 10, " KiB work (eager), ", rec::load(gocpp::recv(gcController.heapReleased)) >> 10, " KiB now, ", (rec::load(gocpp::recv(gcController.heapInUse)) * 100) / heapRetained(), "% util");
        if(forced)
        {
            print(" (forced)");
        }
        else
        if(scavenger.printControllerReset)
        {
            print(" [controller reset]");
            scavenger.printControllerReset = false;
        }
        println();
        printunlock();
    }

    uintptr_t rec::scavengeOne(struct pageAlloc* p, golang::runtime::chunkIdx ci, unsigned int searchIdx, uintptr_t max)
    {
        auto maxPages = max / pageSize;
        if(max % pageSize != 0)
        {
            maxPages++;
        }
        auto minPages = physPageSize / pageSize;
        if(minPages < 1)
        {
            minPages = 1;
        }
        lock(p->mheapLock);
        if(rec::max(gocpp::recv(p->summary[len(p->summary) - 1][ci])) >= (unsigned int)(minPages))
        {
            auto [base, npages] = rec::findScavengeCandidate(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)), searchIdx, minPages, maxPages);
            if(npages != 0)
            {
                auto addr = chunkBase(ci) + uintptr_t(base) * pageSize;
                rec::allocRange(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)), base, npages);
                rec::update(gocpp::recv(p), addr, uintptr_t(npages), true, true);
                unlock(p->mheapLock);
                if(! p->test)
                {
                    pageTraceScav(rec::ptr(gocpp::recv(getg()->m->p)), 0, addr, uintptr_t(npages));
                    sysUnused(unsafe::Pointer(addr), uintptr_t(npages) * pageSize);
                    auto nbytes = int64_t(npages * pageSize);
                    rec::add(gocpp::recv(gcController.heapReleased), nbytes);
                    rec::add(gocpp::recv(gcController.heapFree), - nbytes);
                    auto stats = rec::acquire(gocpp::recv(memstats.heapStats));
                    atomic::Xaddint64(& stats->committed, - nbytes);
                    atomic::Xaddint64(& stats->released, nbytes);
                    rec::release(gocpp::recv(memstats.heapStats));
                }
                lock(p->mheapLock);
                if(auto b = (offAddr {addr}); rec::lessThan(gocpp::recv(b), p->searchAddr))
                {
                    p->searchAddr = b;
                }
                rec::free(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)), base, npages);
                rec::update(gocpp::recv(p), addr, uintptr_t(npages), true, false);
                rec::setRange(gocpp::recv(rec::chunkOf(gocpp::recv(p), ci)->scavenged), base, npages);
                unlock(p->mheapLock);
                return uintptr_t(npages) * pageSize;
            }
        }
        rec::setEmpty(gocpp::recv(p->scav.index), ci);
        unlock(p->mheapLock);
        return 0;
    }

    uint64_t fillAligned(uint64_t x, unsigned int m)
    {
        auto apply = [=](uint64_t x, uint64_t c) mutable -> uint64_t
        {
            return ~ ((((x & c) + c) | x) | c);
        };
        //Go switch emulation
        {
            auto condition = m;
            int conditionId = -1;
            if(condition == 1) { conditionId = 0; }
            else if(condition == 2) { conditionId = 1; }
            else if(condition == 4) { conditionId = 2; }
            else if(condition == 8) { conditionId = 3; }
            else if(condition == 16) { conditionId = 4; }
            else if(condition == 32) { conditionId = 5; }
            else if(condition == 64) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    return x;
                    break;
                case 1:
                    x = apply(x, 0x5555555555555555);
                    break;
                case 2:
                    x = apply(x, 0x7777777777777777);
                    break;
                case 3:
                    x = apply(x, 0x7f7f7f7f7f7f7f7f);
                    break;
                case 4:
                    x = apply(x, 0x7fff7fff7fff7fff);
                    break;
                case 5:
                    x = apply(x, 0x7fffffff7fffffff);
                    break;
                case 6:
                    x = apply(x, 0x7fffffffffffffff);
                    break;
                default:
                    go_throw("bad m value");
                    break;
            }
        }
        return ~ ((x - (x >> (m - 1))) | x);
    }

    std::tuple<unsigned int, unsigned int> rec::findScavengeCandidate(struct pallocData* m, unsigned int searchIdx, uintptr_t minimum, uintptr_t max)
    {
        if(minimum & (minimum - 1) != 0 || minimum == 0)
        {
            print("runtime: min = ", minimum, "\n");
            go_throw("min must be a non-zero power of 2");
        }
        else
        if(minimum > maxPagesPerPhysPage)
        {
            print("runtime: min = ", minimum, "\n");
            go_throw("min too large");
        }
        if(max == 0)
        {
            max = minimum;
        }
        else
        {
            max = alignUp(max, minimum);
        }
        auto i = int(searchIdx / 64);
        for(; i >= 0; i--)
        {
            auto x = fillAligned(m->scavenged[i] | m->pallocBits[i], (unsigned int)(minimum));
            if(x != ~ uint64_t(0))
            {
                break;
            }
        }
        if(i < 0)
        {
            return {0, 0};
        }
        auto x = fillAligned(m->scavenged[i] | m->pallocBits[i], (unsigned int)(minimum));
        auto z1 = (unsigned int)(sys::LeadingZeros64(~ x));
        auto [run, end] = std::tuple{(unsigned int)(0), (unsigned int)(i) * 64 + (64 - z1)};
        if((x << z1) != 0)
        {
            run = (unsigned int)(sys::LeadingZeros64(x << z1));
        }
        else
        {
            run = 64 - z1;
            for(auto j = i - 1; j >= 0; j--)
            {
                auto x = fillAligned(m->scavenged[j] | m->pallocBits[j], (unsigned int)(minimum));
                run += (unsigned int)(sys::LeadingZeros64(x));
                if(x != 0)
                {
                    break;
                }
            }
        }
        auto size = min(run, (unsigned int)(max));
        auto start = end - size;
        if(physHugePageSize > pageSize && physHugePageSize > physPageSize)
        {
            auto pagesPerHugePage = physHugePageSize / pageSize;
            auto hugePageAbove = (unsigned int)(alignUp(uintptr_t(start), pagesPerHugePage));
            if(hugePageAbove <= end)
            {
                auto hugePageBelow = (unsigned int)(alignDown(uintptr_t(start), pagesPerHugePage));
                if(hugePageBelow >= end - run)
                {
                    size = size + (start - hugePageBelow);
                    start = hugePageBelow;
                }
            }
        }
        return {start, size};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    scavengeIndex::operator T()
    {
        T result;
        result.chunks = this->chunks;
        result.min = this->min;
        result.max = this->max;
        result.minHeapIdx = this->minHeapIdx;
        result.searchAddrBg = this->searchAddrBg;
        result.searchAddrForce = this->searchAddrForce;
        result.freeHWM = this->freeHWM;
        result.gen = this->gen;
        result.test = this->test;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool scavengeIndex::operator==(const T& ref) const
    {
        if (chunks != ref.chunks) return false;
        if (min != ref.min) return false;
        if (max != ref.max) return false;
        if (minHeapIdx != ref.minHeapIdx) return false;
        if (searchAddrBg != ref.searchAddrBg) return false;
        if (searchAddrForce != ref.searchAddrForce) return false;
        if (freeHWM != ref.freeHWM) return false;
        if (gen != ref.gen) return false;
        if (test != ref.test) return false;
        return true;
    }

    std::ostream& scavengeIndex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << chunks;
        os << " " << min;
        os << " " << max;
        os << " " << minHeapIdx;
        os << " " << searchAddrBg;
        os << " " << searchAddrForce;
        os << " " << freeHWM;
        os << " " << gen;
        os << " " << test;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct scavengeIndex& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t rec::init(struct scavengeIndex* s, bool test, golang::runtime::sysMemStat* sysStat)
    {
        rec::Clear(gocpp::recv(s->searchAddrBg));
        rec::Clear(gocpp::recv(s->searchAddrForce));
        s->freeHWM = minOffAddr;
        s->test = test;
        return rec::sysInit(gocpp::recv(s), test, sysStat);
    }

    uintptr_t rec::grow(struct scavengeIndex* s, uintptr_t base, uintptr_t limit, golang::runtime::sysMemStat* sysStat)
    {
        auto minHeapIdx = rec::Load(gocpp::recv(s->minHeapIdx));
        if(auto baseIdx = uintptr_t(chunkIndex(base)); minHeapIdx == 0 || baseIdx < minHeapIdx)
        {
            rec::Store(gocpp::recv(s->minHeapIdx), baseIdx);
        }
        return rec::sysGrow(gocpp::recv(s), base, limit, sysStat);
    }

    std::tuple<runtime::chunkIdx, unsigned int> rec::find(struct scavengeIndex* s, bool force)
    {
        auto cursor = & s->searchAddrBg;
        if(force)
        {
            cursor = & s->searchAddrForce;
        }
        auto [searchAddr, marked] = rec::Load(gocpp::recv(cursor));
        if(searchAddr == rec::addr(gocpp::recv(minOffAddr)))
        {
            return {0, 0};
        }
        auto gen = s->gen;
        auto min = chunkIdx(rec::Load(gocpp::recv(s->minHeapIdx)));
        auto start = chunkIndex(searchAddr);
        for(auto i = start; i >= min; i--)
        {
            if(! rec::shouldScavenge(gocpp::recv(rec::load(gocpp::recv(s->chunks[i]))), gen, force))
            {
                continue;
            }
            if(i == start)
            {
                return {i, chunkPageIndex(searchAddr)};
            }
            auto newSearchAddr = chunkBase(i) + pallocChunkBytes - pageSize;
            if(marked)
            {
                rec::StoreUnmark(gocpp::recv(cursor), searchAddr, newSearchAddr);
            }
            else
            {
                rec::StoreMin(gocpp::recv(cursor), newSearchAddr);
            }
            return {i, pallocChunkPages - 1};
        }
        rec::Clear(gocpp::recv(cursor));
        return {0, 0};
    }

    void rec::alloc(struct scavengeIndex* s, golang::runtime::chunkIdx ci, unsigned int npages)
    {
        auto sc = rec::load(gocpp::recv(s->chunks[ci]));
        rec::alloc(gocpp::recv(sc), npages, s->gen);
        rec::store(gocpp::recv(s->chunks[ci]), sc);
    }

    void rec::free(struct scavengeIndex* s, golang::runtime::chunkIdx ci, unsigned int page, unsigned int npages)
    {
        auto sc = rec::load(gocpp::recv(s->chunks[ci]));
        rec::free(gocpp::recv(sc), npages, s->gen);
        rec::store(gocpp::recv(s->chunks[ci]), sc);
        auto addr = chunkBase(ci) + uintptr_t(page + npages - 1) * pageSize;
        if(rec::lessThan(gocpp::recv(s->freeHWM), offAddr {addr}))
        {
            s->freeHWM = offAddr {addr};
        }
        auto [searchAddr, gocpp_id_2] = rec::Load(gocpp::recv(s->searchAddrForce));
        if(rec::lessThan(gocpp::recv((offAddr {searchAddr})), offAddr {addr}))
        {
            rec::StoreMarked(gocpp::recv(s->searchAddrForce), addr);
        }
    }

    void rec::nextGen(struct scavengeIndex* s)
    {
        s->gen++;
        auto [searchAddr, gocpp_id_4] = rec::Load(gocpp::recv(s->searchAddrBg));
        if(rec::lessThan(gocpp::recv((offAddr {searchAddr})), s->freeHWM))
        {
            rec::StoreMarked(gocpp::recv(s->searchAddrBg), rec::addr(gocpp::recv(s->freeHWM)));
        }
        s->freeHWM = minOffAddr;
    }

    void rec::setEmpty(struct scavengeIndex* s, golang::runtime::chunkIdx ci)
    {
        auto val = rec::load(gocpp::recv(s->chunks[ci]));
        rec::setEmpty(gocpp::recv(val));
        rec::store(gocpp::recv(s->chunks[ci]), val);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    atomicScavChunkData::operator T()
    {
        T result;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicScavChunkData::operator==(const T& ref) const
    {
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& atomicScavChunkData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicScavChunkData& value)
    {
        return value.PrintTo(os);
    }

    struct scavChunkData rec::load(struct atomicScavChunkData* sc)
    {
        return unpackScavChunkData(rec::Load(gocpp::recv(sc->value)));
    }

    void rec::store(struct atomicScavChunkData* sc, struct scavChunkData ssc)
    {
        rec::Store(gocpp::recv(sc->value), rec::pack(gocpp::recv(ssc)));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    scavChunkData::operator T()
    {
        T result;
        result.inUse = this->inUse;
        result.lastInUse = this->lastInUse;
        result.gen = this->gen;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool scavChunkData::operator==(const T& ref) const
    {
        if (inUse != ref.inUse) return false;
        if (lastInUse != ref.lastInUse) return false;
        if (gen != ref.gen) return false;
        return true;
    }

    std::ostream& scavChunkData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << inUse;
        os << " " << lastInUse;
        os << " " << gen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct scavChunkData& value)
    {
        return value.PrintTo(os);
    }

    struct scavChunkData unpackScavChunkData(uint64_t sc)
    {
        return gocpp::Init<scavChunkData>([](auto& x) {
            x.inUse = uint16_t(sc);
            x.lastInUse = uint16_t(sc >> 16) & scavChunkInUseMask;
            x.gen = uint32_t(sc >> 32);
            x.scavChunkFlags = scavChunkFlags(uint8_t(sc >> (16 + logScavChunkInUseMax)) & scavChunkFlagsMask);
        });
    }

    uint64_t rec::pack(struct scavChunkData sc)
    {
        return uint64_t(sc.inUse) | (uint64_t(sc.lastInUse) << 16) | (uint64_t(sc.scavChunkFlags) << (16 + logScavChunkInUseMax)) | (uint64_t(sc.gen) << 32);
    }

    bool rec::isEmpty(golang::runtime::scavChunkFlags* sc)
    {
        return (*sc) & scavChunkHasFree == 0;
    }

    void rec::setEmpty(golang::runtime::scavChunkFlags* sc)
    {
        *sc &^= scavChunkHasFree;
    }

    void rec::setNonEmpty(golang::runtime::scavChunkFlags* sc)
    {
        *sc |= scavChunkHasFree;
    }

    bool rec::shouldScavenge(struct scavChunkData sc, uint32_t currGen, bool force)
    {
        if(rec::isEmpty(gocpp::recv(sc)))
        {
            return false;
        }
        if(force)
        {
            return true;
        }
        if(sc.gen == currGen)
        {
            return sc.inUse < scavChunkHiOccPages && sc.lastInUse < scavChunkHiOccPages;
        }
        return sc.inUse < scavChunkHiOccPages;
    }

    void rec::alloc(struct scavChunkData* sc, unsigned int npages, uint32_t newGen)
    {
        if((unsigned int)(sc->inUse) + npages > pallocChunkPages)
        {
            print("runtime: inUse=", sc->inUse, " npages=", npages, "\n");
            go_throw("too many pages allocated in chunk?");
        }
        if(sc->gen != newGen)
        {
            sc->lastInUse = sc->inUse;
            sc->gen = newGen;
        }
        sc->inUse += uint16_t(npages);
        if(sc->inUse == pallocChunkPages)
        {
            rec::setEmpty(gocpp::recv(sc));
        }
    }

    void rec::free(struct scavChunkData* sc, unsigned int npages, uint32_t newGen)
    {
        if((unsigned int)(sc->inUse) < npages)
        {
            print("runtime: inUse=", sc->inUse, " npages=", npages, "\n");
            go_throw("allocated pages below zero?");
        }
        if(sc->gen != newGen)
        {
            sc->lastInUse = sc->inUse;
            sc->gen = newGen;
        }
        sc->inUse -= uint16_t(npages);
        rec::setNonEmpty(gocpp::recv(sc));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    piController::operator T()
    {
        T result;
        result.kp = this->kp;
        result.ti = this->ti;
        result.tt = this->tt;
        result.min = this->min;
        result.max = this->max;
        result.errIntegral = this->errIntegral;
        result.errOverflow = this->errOverflow;
        result.inputOverflow = this->inputOverflow;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool piController::operator==(const T& ref) const
    {
        if (kp != ref.kp) return false;
        if (ti != ref.ti) return false;
        if (tt != ref.tt) return false;
        if (min != ref.min) return false;
        if (max != ref.max) return false;
        if (errIntegral != ref.errIntegral) return false;
        if (errOverflow != ref.errOverflow) return false;
        if (inputOverflow != ref.inputOverflow) return false;
        return true;
    }

    std::ostream& piController::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kp;
        os << " " << ti;
        os << " " << tt;
        os << " " << min;
        os << " " << max;
        os << " " << errIntegral;
        os << " " << errOverflow;
        os << " " << inputOverflow;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct piController& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<double, bool> rec::next(struct piController* c, double input, double setpoint, double period)
    {
        auto prop = c->kp * (setpoint - input);
        auto rawOutput = prop + c->errIntegral;
        auto output = rawOutput;
        if(isInf(output) || isNaN(output))
        {
            rec::reset(gocpp::recv(c));
            c->inputOverflow = true;
            return {c->min, false};
        }
        if(output < c->min)
        {
            output = c->min;
        }
        else
        if(output > c->max)
        {
            output = c->max;
        }
        if(c->ti != 0 && c->tt != 0)
        {
            c->errIntegral += (c->kp * period / c->ti) * (setpoint - input) + (period / c->tt) * (output - rawOutput);
            if(isInf(c->errIntegral) || isNaN(c->errIntegral))
            {
                rec::reset(gocpp::recv(c));
                c->errOverflow = true;
                return {c->min, false};
            }
        }
        return {output, true};
    }

    void rec::reset(struct piController* c)
    {
        c->errIntegral = 0;
    }

}

