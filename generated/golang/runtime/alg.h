// generated by GoCpp from file '$(ImportDir)/runtime/alg.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/alg.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    uintptr_t memhash0(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t memhash8(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t memhash16(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t memhash128(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t memhash_varlen(gocpp::unsafe_pointer p, uintptr_t h);
    extern bool useAeshash;
    uintptr_t memhash(gocpp::unsafe_pointer p, uintptr_t h, uintptr_t s);
    uintptr_t memhash32(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t memhash64(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t strhash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t strhashFallback(gocpp::unsafe_pointer a, uintptr_t h);
    uintptr_t f32hash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t f64hash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t c64hash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t c128hash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t interhash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t nilinterhash(gocpp::unsafe_pointer p, uintptr_t h);
    uintptr_t typehash(golang::runtime::_type* t, gocpp::unsafe_pointer p, uintptr_t h);
    struct gocpp::error mapKeyError(golang::runtime::maptype* t, gocpp::unsafe_pointer p);
    struct gocpp::error mapKeyError2(golang::runtime::_type* t, gocpp::unsafe_pointer p);
    uintptr_t reflect_typehash(golang::runtime::_type* t, gocpp::unsafe_pointer p, uintptr_t h);
    bool memequal0(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool memequal8(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool memequal16(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool memequal32(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool memequal64(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool memequal128(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool f32equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool f64equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool c64equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool c128equal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool strequal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool interequal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool nilinterequal(gocpp::unsafe_pointer p, gocpp::unsafe_pointer q);
    bool efaceeq(golang::runtime::_type* t, gocpp::unsafe_pointer x, gocpp::unsafe_pointer y);
    bool ifaceeq(struct itab* tab, gocpp::unsafe_pointer x, gocpp::unsafe_pointer y);
    uintptr_t stringHash(gocpp::string s, uintptr_t seed);
    uintptr_t bytesHash(gocpp::slice<unsigned char> b, uintptr_t seed);
    uintptr_t int32Hash(uint32_t i, uintptr_t seed);
    uintptr_t int64Hash(uint64_t i, uintptr_t seed);
    uintptr_t efaceHash(go_any i, uintptr_t seed);
    struct gocpp_id_0 : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        gocpp_id_0(){}
        gocpp_id_0(gocpp_id_0& i) = default;
        gocpp_id_0(const gocpp_id_0& i) = default;
        gocpp_id_0& operator=(gocpp_id_0& i) = default;
        gocpp_id_0& operator=(const gocpp_id_0& i) = default;

        template<typename T>
        gocpp_id_0(T& ref);

        template<typename T>
        gocpp_id_0(const T& ref);

        template<typename T>
        gocpp_id_0(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_0
        {
            virtual void vF() = 0;
            virtual void* getPtr() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_0Impl : Igocpp_id_0
        {
            explicit gocpp_id_0Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vF() override;

            void* getPtr() override
            {
                return value.get();
            }

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_0> value;
    };

    namespace rec
    {
        void F(const gocpp::PtrRecv<struct gocpp_id_0, false>& self);
        void F(const gocpp::ObjRecv<struct gocpp_id_0>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    uintptr_t ifaceHash(gocpp_id_0 i, uintptr_t seed);
    extern gocpp::array<unsigned char, hashRandomBytes> aeskeysched;
    extern gocpp::array<uintptr_t, 4> hashkey;
    void alginit();
    void initAlgAES();
    uint32_t readUnaligned32(gocpp::unsafe_pointer p);
    uint64_t readUnaligned64(gocpp::unsafe_pointer p);

    namespace rec
    {
    }
}

