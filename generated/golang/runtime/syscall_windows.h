// generated by GoCpp from file '$(ImportDir)/runtime/syscall_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/syscall_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    void cbsLock();
    void cbsUnlock();
    struct winCallback
    {
        funcval* fn;
        uintptr_t retPop;
        abiDesc abiMap;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct winCallback& value);
    struct abiPart
    {
        golang::runtime::abiPartKind kind;
        uintptr_t srcStackOffset;
        uintptr_t dstStackOffset;
        int dstRegister;
        uintptr_t len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct abiPart& value);
    struct abiDesc
    {
        gocpp::slice<abiPart> parts;
        uintptr_t srcStackSize;
        uintptr_t dstStackSize;
        uintptr_t dstSpill;
        int dstRegisters;
        uintptr_t retOffset;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct abiDesc& value);
    struct winCallbackKey
    {
        funcval* fn;
        bool cdecl;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct winCallbackKey& value);
    void callbackasm();
    uintptr_t callbackasmAddr(int i);
    uintptr_t compileCallback(struct eface fn, bool cdecl);
    struct callbackArgs
    {
        uintptr_t index;
        unsafe::Pointer args;
        uintptr_t result;
        uintptr_t retPop;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct callbackArgs& value);
    void callbackWrap(struct callbackArgs* a);
    std::tuple<uintptr_t, uintptr_t> syscall_loadsystemlibrary(uint16_t* filename);
    std::tuple<uintptr_t, uintptr_t> syscall_loadlibrary(uint16_t* filename);
    std::tuple<uintptr_t, uintptr_t> syscall_getprocaddress(uintptr_t handle, unsigned char* procname);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall6(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall9(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall12(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall15(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_Syscall18(uintptr_t fn, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15, uintptr_t a16, uintptr_t a17, uintptr_t a18);
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_SyscallN(uintptr_t trap, gocpp::slice<uintptr_t> args);
    
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_SyscallN(uintptr_t trap, Args... args)
    {
        return syscall_SyscallN(trap, gocpp::ToSlice<uintptr_t>(args...));
    }
    
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, uintptr_t> syscall_SyscallN(uintptr_t trap, uintptr_t value, Args... args)
    {
        return syscall_SyscallN(trap, gocpp::ToSlice<uintptr_t>(value, args...));
    }

    namespace rec
    {
        bool tryMerge(struct abiPart* a, struct abiPart b);
        void assignArg(struct abiDesc* p, golang::runtime::_type* t);
        bool tryRegAssignArg(struct abiDesc* p, golang::runtime::_type* t, uintptr_t offset);
        bool assignReg(struct abiDesc* p, uintptr_t size, uintptr_t offset);
    }
}

