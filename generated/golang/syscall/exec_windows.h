// generated by GoCpp from file '$(ImportDir)/syscall/exec_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/exec_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/rwmutex.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"

namespace golang::syscall
{
    std::string EscapeArg(std::string s);
    gocpp::slice<unsigned char> appendEscapeArg(gocpp::slice<unsigned char> b, std::string s);
    std::string makeCmdLine(gocpp::slice<std::string> args);
    std::tuple<gocpp::slice<uint16_t>, struct gocpp::error> createEnvBlock(gocpp::slice<std::string> envv);
    void CloseOnExec(Handle fd);
    struct gocpp::error SetNonblock(Handle fd, bool nonblocking);
    std::tuple<std::string, struct gocpp::error> FullPath(std::string name);
    bool isSlash(uint8_t c);
    std::tuple<std::string, struct gocpp::error> normalizeDir(std::string dir);
    int volToUpper(int ch);
    std::tuple<std::string, struct gocpp::error> joinExeDirAndFName(std::string dir, std::string p);
    struct ProcAttr
    {
        std::string Dir;
        gocpp::slice<std::string> Env;
        gocpp::slice<uintptr_t> Files;
        SysProcAttr* Sys;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ProcAttr& value);
    struct SysProcAttr
    {
        bool HideWindow;
        std::string CmdLine;
        uint32_t CreationFlags;
        Token Token;
        SecurityAttributes* ProcessAttributes;
        SecurityAttributes* ThreadAttributes;
        bool NoInheritHandles;
        gocpp::slice<Handle> AdditionalInheritedHandles;
        Handle ParentProcess;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SysProcAttr& value);
    std::tuple<int, uintptr_t, struct gocpp::error> StartProcess(std::string argv0, gocpp::slice<std::string> argv, struct ProcAttr* attr);
    struct gocpp::error Exec(std::string argv0, gocpp::slice<std::string> argv, gocpp::slice<std::string> envv);
}

