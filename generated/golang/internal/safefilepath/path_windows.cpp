// generated by GoCpp from file '$(ImportDir)/internal/safefilepath/path_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/safefilepath/path_windows.h"
#include "gocpp/support.h"

#include "golang/syscall/exec_windows.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::safefilepath
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    std::tuple<gocpp::string, struct gocpp::error> fromFS(gocpp::string path)
    {
        if(! utf8::ValidString(path))
        {
            return {""_s, errInvalidPath};
        }
        for(; len(path) > 1 && path[0] == '/' && path[1] == '/'; )
        {
            path = path.make_slice(1);
        }
        auto containsSlash = false;
        for(auto p = path; p != ""_s; )
        {
            auto i = 0;
            for(; i < len(p) && p[i] != '/'; )
            {
                //Go switch emulation
                {
                    auto condition = p[i];
                    int conditionId = -1;
                    if(condition == 0) { conditionId = 0; }
                    else if(condition == '\\') { conditionId = 1; }
                    else if(condition == ':') { conditionId = 2; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                        case 2:
                            return {""_s, errInvalidPath};
                            break;
                    }
                }
                i++;
            }
            auto part = p.make_slice(0, i);
            if(i < len(p))
            {
                containsSlash = true;
                p = p.make_slice(i + 1);
            }
            else
            {
                p = ""_s;
            }
            if(IsReservedName(part))
            {
                return {""_s, errInvalidPath};
            }
        }
        if(containsSlash)
        {
            auto buf = gocpp::slice<unsigned char>(path);
            for(auto [i, b] : buf)
            {
                if(b == '/')
                {
                    buf[i] = '\\';
                }
            }
            path = gocpp::string(buf);
        }
        return {path, nullptr};
    }

    // IsReservedName reports if name is a Windows reserved device name.
    // It does not detect names with an extension, which are also reserved on some Windows versions.
    //
    // For details, search for PRN in
    // https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file.
    bool IsReservedName(gocpp::string name)
    {
        auto base = name;
        for(auto i = 0; i < len(base); i++)
        {
            //Go switch emulation
            {
                auto condition = base[i];
                int conditionId = -1;
                if(condition == ':') { conditionId = 0; }
                else if(condition == '.') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        base = base.make_slice(0, i);
                        break;
                }
            }
        }
        for(; len(base) > 0 && base[len(base) - 1] == ' '; )
        {
            base = base.make_slice(0, len(base) - 1);
        }
        if(! isReservedBaseName(base))
        {
            return false;
        }
        if(len(base) == len(name))
        {
            return true;
        }
        if(auto [p, gocpp_id_0] = syscall::FullPath(name); len(p) >= 4 && p.make_slice(0, 4) == "\\\\.\\"_s)
        {
            return true;
        }
        return false;
    }

    bool isReservedBaseName(gocpp::string name)
    {
        if(len(name) == 3)
        {
            //Go switch emulation
            {
                auto condition = gocpp::string(gocpp::slice<unsigned char> {toUpper(name[0]), toUpper(name[1]), toUpper(name[2])});
                int conditionId = -1;
                if(condition == "CON"_s) { conditionId = 0; }
                else if(condition == "PRN"_s) { conditionId = 1; }
                else if(condition == "AUX"_s) { conditionId = 2; }
                else if(condition == "NUL"_s) { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        return true;
                        break;
                }
            }
        }
        if(len(name) >= 4)
        {
            //Go switch emulation
            {
                auto condition = gocpp::string(gocpp::slice<unsigned char> {toUpper(name[0]), toUpper(name[1]), toUpper(name[2])});
                int conditionId = -1;
                if(condition == "COM"_s) { conditionId = 0; }
                else if(condition == "LPT"_s) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        if(len(name) == 4 && '1' <= name[3] && name[3] <= '9')
                        {
                            return true;
                        }
                        //Go switch emulation
                        {
                            auto condition = name.make_slice(3);
                            int conditionId = -1;
                            if(condition == "\u00b2"_s) { conditionId = 0; }
                            else if(condition == "\u00b3"_s) { conditionId = 1; }
                            else if(condition == "\u00b9"_s) { conditionId = 2; }
                            switch(conditionId)
                            {
                                case 0:
                                case 1:
                                case 2:
                                    return true;
                                    break;
                            }
                        }
                        return false;
                        break;
                }
            }
        }
        if(len(name) == 6 && name[5] == '$' && equalFold(name, "CONIN$"_s))
        {
            return true;
        }
        if(len(name) == 7 && name[6] == '$' && equalFold(name, "CONOUT$"_s))
        {
            return true;
        }
        return false;
    }

    bool equalFold(gocpp::string a, gocpp::string b)
    {
        if(len(a) != len(b))
        {
            return false;
        }
        for(auto i = 0; i < len(a); i++)
        {
            if(toUpper(a[i]) != toUpper(b[i]))
            {
                return false;
            }
        }
        return true;
    }

    unsigned char toUpper(unsigned char c)
    {
        if('a' <= c && c <= 'z')
        {
            return c - ('a' - 'A');
        }
        return c;
    }

}

