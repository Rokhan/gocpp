// generated by GoCpp from file '$(ImportDir)/sort/sort.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sort/sort.fwd.h"
#include "gocpp/support.h"


namespace golang::sort
{
    struct Interface : gocpp::Interface
    {
        Interface(){}
        Interface(Interface& i) = default;
        Interface(const Interface& i) = default;
        Interface& operator=(Interface& i) = default;
        Interface& operator=(const Interface& i) = default;

        template<typename T>
        Interface(T& ref);

        template<typename T>
        Interface(const T& ref);

        template<typename T>
        Interface(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IInterface
        {
            virtual int vLen() = 0;
            virtual bool vLess(int i, int j) = 0;
            virtual void vSwap(int i, int j) = 0;
        };

        template<typename T, typename StoreT>
        struct InterfaceImpl : IInterface
        {
            explicit InterfaceImpl(T* ptr)
            {
                value.reset(ptr);
            }

            int vLen() override;

            bool vLess(int i, int j) override;

            void vSwap(int i, int j) override;

            StoreT value;
        };

        std::shared_ptr<IInterface> value;
    };

    int Len(const gocpp::PtrRecv<Interface, false>& self);
    int Len(const gocpp::ObjRecv<Interface>& self);

    bool Less(const gocpp::PtrRecv<Interface, false>& self, int i, int j);
    bool Less(const gocpp::ObjRecv<Interface>& self, int i, int j);

    void Swap(const gocpp::PtrRecv<Interface, false>& self, int i, int j);
    void Swap(const gocpp::ObjRecv<Interface>& self, int i, int j);

    std::ostream& operator<<(std::ostream& os, const struct Interface& value);
    void Sort(struct Interface data);
    uint64_t Next(xorshift* r);
    unsigned int nextPowerOfTwo(int length);
    struct lessSwap
    {
        std::function<bool (int i, int j)> Less;
        std::function<void (int i, int j)> Swap;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct lessSwap& value);
    struct reverse
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct reverse& value);
    bool Less(struct reverse r, int i, int j);
    struct Interface Reverse(struct Interface data);
    bool IsSorted(struct Interface data);
    int Len(IntSlice x);
    bool Less(IntSlice x, int i, int j);
    void Swap(IntSlice x, int i, int j);
    void Sort(IntSlice x);
    int Len(Float64Slice x);
    bool Less(Float64Slice x, int i, int j);
    void Swap(Float64Slice x, int i, int j);
    bool isNaN(double f);
    void Sort(Float64Slice x);
    int Len(StringSlice x);
    bool Less(StringSlice x, int i, int j);
    void Swap(StringSlice x, int i, int j);
    void Sort(StringSlice x);
    void Ints(gocpp::slice<int> x);
    void Float64s(gocpp::slice<double> x);
    void Strings(gocpp::slice<std::string> x);
    bool IntsAreSorted(gocpp::slice<int> x);
    bool Float64sAreSorted(gocpp::slice<double> x);
    bool StringsAreSorted(gocpp::slice<std::string> x);
    void Stable(struct Interface data);
}

