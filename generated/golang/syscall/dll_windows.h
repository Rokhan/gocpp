// generated by GoCpp from file '$(ImportDir)/syscall/dll_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/dll_windows.fwd.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    struct DLLError
    {
        std::string Err;
        std::string ObjName;
        std::string Msg;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct DLLError& value);
    std::string Error(struct DLLError* e);
    std::string Unwrap(struct DLLError* e);
    std::tuple<uintptr_t, uintptr_t, Errno> Syscall(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3);
    std::tuple<uintptr_t, uintptr_t, Errno> Syscall6(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6);
    std::tuple<uintptr_t, uintptr_t, Errno> Syscall9(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9);
    std::tuple<uintptr_t, uintptr_t, Errno> Syscall12(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12);
    std::tuple<uintptr_t, uintptr_t, Errno> Syscall15(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15);
    std::tuple<uintptr_t, uintptr_t, Errno> Syscall18(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15, uintptr_t a16, uintptr_t a17, uintptr_t a18);
    std::tuple<uintptr_t, uintptr_t, Errno> SyscallN(uintptr_t trap, gocpp::slice<uintptr_t> args);
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, Errno> SyscallN(uintptr_t trap, Args... args)
    {
        return SyscallN(trap, gocpp::ToSlice<uintptr_t>(args...));
    }

    std::tuple<uintptr_t, Errno> loadlibrary(uint16_t* filename);
    std::tuple<uintptr_t, Errno> loadsystemlibrary(uint16_t* filename);
    std::tuple<uintptr_t, Errno> getprocaddress(uintptr_t handle, uint8_t* procname);
    struct DLL
    {
        std::string Name;
        Handle Handle;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct DLL& value);
    std::tuple<DLL*, std::string> LoadDLL(std::string name);
    DLL* MustLoadDLL(std::string name);
    std::tuple<Proc*, std::string> FindProc(struct DLL* d, std::string name);
    Proc* MustFindProc(struct DLL* d, std::string name);
    std::string Release(struct DLL* d);
    struct Proc
    {
        DLL* Dll;
        std::string Name;
        uintptr_t addr;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Proc& value);
    uintptr_t Addr(struct Proc* p);
    std::tuple<uintptr_t, uintptr_t, std::string> Call(struct Proc* p, gocpp::slice<uintptr_t> a);
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, std::string> Call(struct Proc* p, Args... a)
    {
        return Call(p, gocpp::ToSlice<uintptr_t>(a...));
    }

    struct LazyDLL
    {
        mocklib::Mutex mu;
        DLL* dll;
        std::string Name;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct LazyDLL& value);
    std::string Load(struct LazyDLL* d);
    void mustLoad(struct LazyDLL* d);
    uintptr_t Handle(struct LazyDLL* d);
    LazyProc* NewProc(struct LazyDLL* d, std::string name);
    LazyDLL* NewLazyDLL(std::string name);
    struct LazyProc
    {
        mocklib::Mutex mu;
        std::string Name;
        LazyDLL* l;
        Proc* proc;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct LazyProc& value);
    std::string Find(struct LazyProc* p);
    void mustFind(struct LazyProc* p);
    uintptr_t Addr(struct LazyProc* p);
    std::tuple<uintptr_t, uintptr_t, std::string> Call(struct LazyProc* p, gocpp::slice<uintptr_t> a);
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, std::string> Call(struct LazyProc* p, Args... a)
    {
        return Call(p, gocpp::ToSlice<uintptr_t>(a...));
    }

}

