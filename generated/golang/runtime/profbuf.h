// generated by GoCpp from file '$(ImportDir)/runtime/profbuf.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/profbuf.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    struct profBuf
    {
        runtime::profAtomic r;
        runtime::profAtomic w;
        atomic::Uint64 overflow;
        atomic::Uint64 overflowTime;
        atomic::Uint32 eof;
        uintptr_t hdrsize;
        gocpp::slice<uint64_t> data;
        gocpp::slice<unsafe::Pointer> tags;
        runtime::profIndex rNext;
        gocpp::slice<uint64_t> overflowBuf;
        /* note wait; [Known incomplete type] */

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct profBuf& value);
    int countSub(uint32_t x, uint32_t y);
    struct profBuf* newProfBuf(int hdrsize, int bufwords, int tags);

    namespace rec
    {
        runtime::profIndex load(runtime::profAtomic* x);
        void store(runtime::profAtomic* x, runtime::profIndex go_new);
        bool cas(runtime::profAtomic* x, runtime::profIndex old, runtime::profIndex go_new);
        uint32_t dataCount(runtime::profIndex x);
        uint32_t tagCount(runtime::profIndex x);
        runtime::profIndex addCountsAndClearFlags(runtime::profIndex x, int data, int tag);
        bool hasOverflow(struct profBuf* b);
        std::tuple<uint32_t, uint64_t> takeOverflow(struct profBuf* b);
        void incrementOverflow(struct profBuf* b, int64_t now);
        bool canWriteRecord(struct profBuf* b, int nstk);
        bool canWriteTwoRecords(struct profBuf* b, int nstk1, int nstk2);
        void write(struct profBuf* b, unsafe::Pointer* tagPtr, int64_t now, gocpp::slice<uint64_t> hdr, gocpp::slice<uintptr_t> stk);
        void close(struct profBuf* b);
        void wakeupExtra(struct profBuf* b);
        std::tuple<gocpp::slice<uint64_t>, gocpp::slice<unsafe::Pointer>, bool> read(struct profBuf* b, runtime::profBufReadMode mode);
    }
}

