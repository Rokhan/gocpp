// generated by GoCpp from file '$(ImportDir)/strconv/atoi.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/atoi.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"

namespace golang::strconv
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // lower(c) is a lower-case letter if and only if
    // c is either that lower-case letter or the equivalent upper-case letter.
    // Instead of writing c == 'x' || c == 'X' one can write lower(c) == 'x'.
    // Note that lower of non-letters can produce other non-letters.
    unsigned char lower(unsigned char c)
    {
        return c | ('x' - 'X');
    }

    // ErrRange indicates that a value is out of range for the target type.
    gocpp::error ErrRange = errors::New("value out of range"s);
    // ErrSyntax indicates that a value does not have the right syntax for the target type.
    gocpp::error ErrSyntax = errors::New("invalid syntax"s);
    // A NumError records a failed conversion.
    
    template<typename T> requires gocpp::GoStruct<T>
    NumError::operator T()
    {
        T result;
        result.Func = this->Func;
        result.Num = this->Num;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NumError::operator==(const T& ref) const
    {
        if (Func != ref.Func) return false;
        if (Num != ref.Num) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& NumError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Func;
        os << " " << Num;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NumError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct NumError* e)
    {
        return "strconv."s + e->Func + ": "s + "parsing "s + Quote(e->Num) + ": "s + rec::Error(gocpp::recv(e->Err));
    }

    struct gocpp::error rec::Unwrap(struct NumError* e)
    {
        return e->Err;
    }

    // cloneString returns a string copy of x.
    //
    // All ParseXXX functions allow the input string to escape to the error value.
    // This hurts strconv.ParseXXX(string(b)) calls where b is []byte since
    // the conversion from []byte must allocate a string on the heap.
    // If we assume errors are infrequent, then we can avoid escaping the input
    // back to the output by copying it first. This allows the compiler to call
    // strconv.ParseXXX without a heap allocation for most []byte to string
    // conversions, since it can now prove that the string cannot escape Parse.
    //
    // TODO: Use strings.Clone instead? However, we cannot depend on "strings"
    // since it incurs a transitive dependency on "unicode".
    // Either move strings.Clone to an internal/bytealg or make the
    // "strings" to "unicode" dependency lighter (see https://go.dev/issue/54098).
    std::string cloneString(std::string x)
    {
        return std::string(gocpp::slice<unsigned char>(x));
    }

    struct NumError* syntaxError(std::string fn, std::string str)
    {
        return new NumError {fn, cloneString(str), ErrSyntax};
    }

    struct NumError* rangeError(std::string fn, std::string str)
    {
        return new NumError {fn, cloneString(str), ErrRange};
    }

    struct NumError* baseError(std::string fn, std::string str, int base)
    {
        return new NumError {fn, cloneString(str), errors::New("invalid base "s + Itoa(base))};
    }

    struct NumError* bitSizeError(std::string fn, std::string str, int bitSize)
    {
        return new NumError {fn, cloneString(str), errors::New("invalid bit size "s + Itoa(bitSize))};
    }

    // IntSize is the size in bits of an int or uint value.
    // ParseUint is like ParseInt but for unsigned numbers.
    //
    // A sign prefix is not permitted.
    std::tuple<uint64_t, struct gocpp::error> ParseUint(std::string s, int base, int bitSize)
    {
        auto fnParseUint = "ParseUint"s;
        if(s == ""s)
        {
            return {0, syntaxError(fnParseUint, s)};
        }
        auto base0 = base == 0;
        auto s0 = s;
        //Go switch emulation
        {
            int conditionId = -1;
            if(2 <= base && base <= 36) { conditionId = 0; }
            else if(base == 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    break;
                case 1:
                    base = 10;
                    if(s[0] == '0')
                    {
                        //Go switch emulation
                        {
                            int conditionId = -1;
                            if(len(s) >= 3 && lower(s[1]) == 'b') { conditionId = 0; }
                            else if(len(s) >= 3 && lower(s[1]) == 'o') { conditionId = 1; }
                            else if(len(s) >= 3 && lower(s[1]) == 'x') { conditionId = 2; }
                            switch(conditionId)
                            {
                                case 0:
                                    base = 2;
                                    s = s.make_slice(2);
                                    break;
                                case 1:
                                    base = 8;
                                    s = s.make_slice(2);
                                    break;
                                case 2:
                                    base = 16;
                                    s = s.make_slice(2);
                                    break;
                                default:
                                    base = 8;
                                    s = s.make_slice(1);
                                    break;
                            }
                        }
                    }
                    break;
                default:
                    return {0, baseError(fnParseUint, s0, base)};
                    break;
            }
        }
        if(bitSize == 0)
        {
            bitSize = IntSize;
        }
        else
        if(bitSize < 0 || bitSize > 64)
        {
            return {0, bitSizeError(fnParseUint, s0, bitSize)};
        }
        // Cutoff is the smallest number such that cutoff*base > maxUint64.
        // Use compile-time constants for common cases.
        uint64_t cutoff = {};
        //Go switch emulation
        {
            auto condition = base;
            int conditionId = -1;
            if(condition == 10) { conditionId = 0; }
            else if(condition == 16) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    cutoff = maxUint64 / 10 + 1;
                    break;
                case 1:
                    cutoff = maxUint64 / 16 + 1;
                    break;
                default:
                    cutoff = maxUint64 / uint64_t(base) + 1;
                    break;
            }
        }
        auto maxVal = (uint64_t(1) << (unsigned int)(bitSize)) - 1;
        auto underscores = false;
        uint64_t n = {};
        for(auto [gocpp_ignored, c] : gocpp::slice<unsigned char>(s))
        {
            unsigned char d = {};
            //Go switch emulation
            {
                int conditionId = -1;
                if(c == '_' && base0) { conditionId = 0; }
                else if('0' <= c && c <= '9') { conditionId = 1; }
                else if('a' <= lower(c) && lower(c) <= 'z') { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        underscores = true;
                        continue;
                        break;
                    case 1:
                        d = c - '0';
                        break;
                    case 2:
                        d = lower(c) - 'a' + 10;
                        break;
                    default:
                        return {0, syntaxError(fnParseUint, s0)};
                        break;
                }
            }
            if(d >= (unsigned char)(base))
            {
                return {0, syntaxError(fnParseUint, s0)};
            }
            if(n >= cutoff)
            {
                return {maxVal, rangeError(fnParseUint, s0)};
            }
            n *= uint64_t(base);
            auto n1 = n + uint64_t(d);
            if(n1 < n || n1 > maxVal)
            {
                return {maxVal, rangeError(fnParseUint, s0)};
            }
            n = n1;
        }
        if(underscores && ! underscoreOK(s0))
        {
            return {0, syntaxError(fnParseUint, s0)};
        }
        return {n, nullptr};
    }

    // ParseInt interprets a string s in the given base (0, 2 to 36) and
    // bit size (0 to 64) and returns the corresponding value i.
    //
    // The string may begin with a leading sign: "+" or "-".
    //
    // If the base argument is 0, the true base is implied by the string's
    // prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o",
    // 16 for "0x", and 10 otherwise. Also, for argument base 0 only,
    // underscore characters are permitted as defined by the Go syntax for
    // [integer literals].
    //
    // The bitSize argument specifies the integer type
    // that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
    // correspond to int, int8, int16, int32, and int64.
    // If bitSize is below 0 or above 64, an error is returned.
    //
    // The errors that ParseInt returns have concrete type *NumError
    // and include err.Num = s. If s is empty or contains invalid
    // digits, err.Err = ErrSyntax and the returned value is 0;
    // if the value corresponding to s cannot be represented by a
    // signed integer of the given size, err.Err = ErrRange and the
    // returned value is the maximum magnitude integer of the
    // appropriate bitSize and sign.
    //
    // [integer literals]: https://go.dev/ref/spec#Integer_literals
    std::tuple<int64_t, struct gocpp::error> ParseInt(std::string s, int base, int bitSize)
    {
        int64_t i;
        struct gocpp::error err;
        auto fnParseInt = "ParseInt"s;
        if(s == ""s)
        {
            return {0, syntaxError(fnParseInt, s)};
        }
        auto s0 = s;
        auto neg = false;
        if(s[0] == '+')
        {
            s = s.make_slice(1);
        }
        else
        if(s[0] == '-')
        {
            neg = true;
            s = s.make_slice(1);
        }
        // Convert unsigned and check range.
        uint64_t un = {};
        std::tie(un, err) = ParseUint(s, base, bitSize);
        if(err != nullptr && gocpp::getValue<NumError*>(err)->Err != ErrRange)
        {
            gocpp::getValue<NumError*>(err)->Func = fnParseInt;
            gocpp::getValue<NumError*>(err)->Num = cloneString(s0);
            return {0, err};
        }
        if(bitSize == 0)
        {
            bitSize = IntSize;
        }
        auto cutoff = uint64_t(1 << (unsigned int)(bitSize - 1));
        if(! neg && un >= cutoff)
        {
            return {int64_t(cutoff - 1), rangeError(fnParseInt, s0)};
        }
        if(neg && un > cutoff)
        {
            return {- int64_t(cutoff), rangeError(fnParseInt, s0)};
        }
        auto n = int64_t(un);
        if(neg)
        {
            n = - n;
        }
        return {n, nullptr};
    }

    // Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.
    std::tuple<int, struct gocpp::error> Atoi(std::string s)
    {
        auto fnAtoi = "Atoi"s;
        auto sLen = len(s);
        if(intSize == 32 && (0 < sLen && sLen < 10) || intSize == 64 && (0 < sLen && sLen < 19))
        {
            auto s0 = s;
            if(s[0] == '-' || s[0] == '+')
            {
                s = s.make_slice(1);
                if(len(s) < 1)
                {
                    return {0, syntaxError(fnAtoi, s0)};
                }
            }
            auto n = 0;
            for(auto [gocpp_ignored, ch] : gocpp::slice<unsigned char>(s))
            {
                ch -= '0';
                if(ch > 9)
                {
                    return {0, syntaxError(fnAtoi, s0)};
                }
                n = n * 10 + int(ch);
            }
            if(s0[0] == '-')
            {
                n = - n;
            }
            return {n, nullptr};
        }
        auto [i64, err] = ParseInt(s, 10, 0);
        if(auto [nerr, ok] = gocpp::getValue<NumError*>(err); ok)
        {
            nerr->Func = fnAtoi;
        }
        return {int(i64), err};
    }

    // underscoreOK reports whether the underscores in s are allowed.
    // Checking them in this one function lets all the parsers skip over them simply.
    // Underscore must appear only between digits or between a base prefix and a digit.
    bool underscoreOK(std::string s)
    {
        auto saw = '^';
        auto i = 0;
        if(len(s) >= 1 && (s[0] == '-' || s[0] == '+'))
        {
            s = s.make_slice(1);
        }
        auto hex = false;
        if(len(s) >= 2 && s[0] == '0' && (lower(s[1]) == 'b' || lower(s[1]) == 'o' || lower(s[1]) == 'x'))
        {
            i = 2;
            saw = '0';
            hex = lower(s[1]) == 'x';
        }
        for(; i < len(s); i++)
        {
            if('0' <= s[i] && s[i] <= '9' || hex && 'a' <= lower(s[i]) && lower(s[i]) <= 'f')
            {
                saw = '0';
                continue;
            }
            if(s[i] == '_')
            {
                if(saw != '0')
                {
                    return false;
                }
                saw = '_';
                continue;
            }
            if(saw == '_')
            {
                return false;
            }
            saw = '!';
        }
        return saw != '_';
    }

}

