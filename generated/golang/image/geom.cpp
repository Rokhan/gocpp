// generated by GoCpp from file '$(ImportDir)/image/geom.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/geom.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/math/bits/bits.h"
#include "golang/strconv/itoa.h"

namespace golang::image
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Point is an X, Y coordinate pair. The axes increase right and down.
    
    template<typename T> requires gocpp::GoStruct<T>
    Point::operator T()
    {
        T result;
        result.X = this->X;
        result.Y = this->Y;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Point::operator==(const T& ref) const
    {
        if (X != ref.X) return false;
        if (Y != ref.Y) return false;
        return true;
    }

    std::ostream& Point::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << X;
        os << " " << Y;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Point& value)
    {
        return value.PrintTo(os);
    }

    // String returns a string representation of p like "(3,4)".
    gocpp::string rec::String(struct Point p)
    {
        return "("_s + strconv::Itoa(p.X) + ","_s + strconv::Itoa(p.Y) + ")"_s;
    }

    // Add returns the vector p+q.
    struct Point rec::Add(struct Point p, struct Point q)
    {
        return Point {p.X + q.X, p.Y + q.Y};
    }

    // Sub returns the vector p-q.
    struct Point rec::Sub(struct Point p, struct Point q)
    {
        return Point {p.X - q.X, p.Y - q.Y};
    }

    // Mul returns the vector p*k.
    struct Point rec::Mul(struct Point p, int k)
    {
        return Point {p.X * k, p.Y * k};
    }

    // Div returns the vector p/k.
    struct Point rec::Div(struct Point p, int k)
    {
        return Point {p.X / k, p.Y / k};
    }

    // In reports whether p is in r.
    bool rec::In(struct Point p, struct Rectangle r)
    {
        return r.Min.X <= p.X && p.X < r.Max.X && r.Min.Y <= p.Y && p.Y < r.Max.Y;
    }

    // Mod returns the point q in r such that p.X-q.X is a multiple of r's width
    // and p.Y-q.Y is a multiple of r's height.
    struct Point rec::Mod(struct Point p, struct Rectangle r)
    {
        auto [w, h] = std::tuple{rec::Dx(gocpp::recv(r)), rec::Dy(gocpp::recv(r))};
        p = rec::Sub(gocpp::recv(p), r.Min);
        p.X = p.X % w;
        if(p.X < 0)
        {
            p.X += w;
        }
        p.Y = p.Y % h;
        if(p.Y < 0)
        {
            p.Y += h;
        }
        return rec::Add(gocpp::recv(p), r.Min);
    }

    // Eq reports whether p and q are equal.
    bool rec::Eq(struct Point p, struct Point q)
    {
        return p == q;
    }

    // ZP is the zero [Point].
    //
    // Deprecated: Use a literal [image.Point] instead.
    Point ZP;
    // Pt is shorthand for [Point]{X, Y}.
    struct Point Pt(int X, int Y)
    {
        return Point {X, Y};
    }

    // A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y.
    // It is well-formed if Min.X <= Max.X and likewise for Y. Points are always
    // well-formed. A rectangle's methods always return well-formed outputs for
    // well-formed inputs.
    //
    // A Rectangle is also an [Image] whose bounds are the rectangle itself. At
    // returns color.Opaque for points in the rectangle and color.Transparent
    // otherwise.
    
    template<typename T> requires gocpp::GoStruct<T>
    Rectangle::operator T()
    {
        T result;
        result.Min = this->Min;
        result.Max = this->Max;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rectangle::operator==(const T& ref) const
    {
        if (Min != ref.Min) return false;
        if (Max != ref.Max) return false;
        return true;
    }

    std::ostream& Rectangle::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Min;
        os << " " << Max;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rectangle& value)
    {
        return value.PrintTo(os);
    }

    // String returns a string representation of r like "(3,4)-(6,5)".
    gocpp::string rec::String(struct Rectangle r)
    {
        return rec::String(gocpp::recv(r.Min)) + "-"_s + rec::String(gocpp::recv(r.Max));
    }

    // Dx returns r's width.
    int rec::Dx(struct Rectangle r)
    {
        return r.Max.X - r.Min.X;
    }

    // Dy returns r's height.
    int rec::Dy(struct Rectangle r)
    {
        return r.Max.Y - r.Min.Y;
    }

    // Size returns r's width and height.
    struct Point rec::Size(struct Rectangle r)
    {
        return Point {r.Max.X - r.Min.X, r.Max.Y - r.Min.Y};
    }

    // Add returns the rectangle r translated by p.
    struct Rectangle rec::Add(struct Rectangle r, struct Point p)
    {
        return Rectangle {Point {r.Min.X + p.X, r.Min.Y + p.Y}, Point {r.Max.X + p.X, r.Max.Y + p.Y}};
    }

    // Sub returns the rectangle r translated by -p.
    struct Rectangle rec::Sub(struct Rectangle r, struct Point p)
    {
        return Rectangle {Point {r.Min.X - p.X, r.Min.Y - p.Y}, Point {r.Max.X - p.X, r.Max.Y - p.Y}};
    }

    // Inset returns the rectangle r inset by n, which may be negative. If either
    // of r's dimensions is less than 2*n then an empty rectangle near the center
    // of r will be returned.
    struct Rectangle rec::Inset(struct Rectangle r, int n)
    {
        if(rec::Dx(gocpp::recv(r)) < 2 * n)
        {
            r.Min.X = (r.Min.X + r.Max.X) / 2;
            r.Max.X = r.Min.X;
        }
        else
        {
            r.Min.X += n;
            r.Max.X -= n;
        }
        if(rec::Dy(gocpp::recv(r)) < 2 * n)
        {
            r.Min.Y = (r.Min.Y + r.Max.Y) / 2;
            r.Max.Y = r.Min.Y;
        }
        else
        {
            r.Min.Y += n;
            r.Max.Y -= n;
        }
        return r;
    }

    // Intersect returns the largest rectangle contained by both r and s. If the
    // two rectangles do not overlap then the zero rectangle will be returned.
    struct Rectangle rec::Intersect(struct Rectangle r, struct Rectangle s)
    {
        if(r.Min.X < s.Min.X)
        {
            r.Min.X = s.Min.X;
        }
        if(r.Min.Y < s.Min.Y)
        {
            r.Min.Y = s.Min.Y;
        }
        if(r.Max.X > s.Max.X)
        {
            r.Max.X = s.Max.X;
        }
        if(r.Max.Y > s.Max.Y)
        {
            r.Max.Y = s.Max.Y;
        }
        if(rec::Empty(gocpp::recv(r)))
        {
            return ZR;
        }
        return r;
    }

    // Union returns the smallest rectangle that contains both r and s.
    struct Rectangle rec::Union(struct Rectangle r, struct Rectangle s)
    {
        if(rec::Empty(gocpp::recv(r)))
        {
            return s;
        }
        if(rec::Empty(gocpp::recv(s)))
        {
            return r;
        }
        if(r.Min.X > s.Min.X)
        {
            r.Min.X = s.Min.X;
        }
        if(r.Min.Y > s.Min.Y)
        {
            r.Min.Y = s.Min.Y;
        }
        if(r.Max.X < s.Max.X)
        {
            r.Max.X = s.Max.X;
        }
        if(r.Max.Y < s.Max.Y)
        {
            r.Max.Y = s.Max.Y;
        }
        return r;
    }

    // Empty reports whether the rectangle contains no points.
    bool rec::Empty(struct Rectangle r)
    {
        return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y;
    }

    // Eq reports whether r and s contain the same set of points. All empty
    // rectangles are considered equal.
    bool rec::Eq(struct Rectangle r, struct Rectangle s)
    {
        return r == s || rec::Empty(gocpp::recv(r)) && rec::Empty(gocpp::recv(s));
    }

    // Overlaps reports whether r and s have a non-empty intersection.
    bool rec::Overlaps(struct Rectangle r, struct Rectangle s)
    {
        return ! rec::Empty(gocpp::recv(r)) && ! rec::Empty(gocpp::recv(s)) && r.Min.X < s.Max.X && s.Min.X < r.Max.X && r.Min.Y < s.Max.Y && s.Min.Y < r.Max.Y;
    }

    // In reports whether every point in r is in s.
    bool rec::In(struct Rectangle r, struct Rectangle s)
    {
        if(rec::Empty(gocpp::recv(r)))
        {
            return true;
        }
        return s.Min.X <= r.Min.X && r.Max.X <= s.Max.X && s.Min.Y <= r.Min.Y && r.Max.Y <= s.Max.Y;
    }

    // Canon returns the canonical version of r. The returned rectangle has minimum
    // and maximum coordinates swapped if necessary so that it is well-formed.
    struct Rectangle rec::Canon(struct Rectangle r)
    {
        if(r.Max.X < r.Min.X)
        {
            std::tie(r.Min.X, r.Max.X) = std::tuple{r.Max.X, r.Min.X};
        }
        if(r.Max.Y < r.Min.Y)
        {
            std::tie(r.Min.Y, r.Max.Y) = std::tuple{r.Max.Y, r.Min.Y};
        }
        return r;
    }

    // At implements the [Image] interface.
    color::Color rec::At(struct Rectangle r, int x, int y)
    {
        if(rec::In(gocpp::recv((Point {x, y})), r))
        {
            return color::Opaque;
        }
        return color::Transparent;
    }

    // RGBA64At implements the [RGBA64Image] interface.
    color::RGBA64 rec::RGBA64At(struct Rectangle r, int x, int y)
    {
        if(rec::In(gocpp::recv((Point {x, y})), r))
        {
            return color::RGBA64 {0xffff, 0xffff, 0xffff, 0xffff};
        }
        return color::RGBA64 {};
    }

    // Bounds implements the [Image] interface.
    struct Rectangle rec::Bounds(struct Rectangle r)
    {
        return r;
    }

    // ColorModel implements the [Image] interface.
    color::Model rec::ColorModel(struct Rectangle r)
    {
        return color::Alpha16Model;
    }

    // ZR is the zero [Rectangle].
    //
    // Deprecated: Use a literal [image.Rectangle] instead.
    Rectangle ZR;
    // Rect is shorthand for [Rectangle]{Pt(x0, y0), [Pt](x1, y1)}. The returned
    // rectangle has minimum and maximum coordinates swapped if necessary so that
    // it is well-formed.
    struct Rectangle Rect(int x0, int y0, int x1, int y1)
    {
        if(x0 > x1)
        {
            std::tie(x0, x1) = std::tuple{x1, x0};
        }
        if(y0 > y1)
        {
            std::tie(y0, y1) = std::tuple{y1, y0};
        }
        return Rectangle {Point {x0, y0}, Point {x1, y1}};
    }

    // mul3NonNeg returns (x * y * z), unless at least one argument is negative or
    // if the computation overflows the int type, in which case it returns -1.
    int mul3NonNeg(int x, int y, int z)
    {
        if((x < 0) || (y < 0) || (z < 0))
        {
            return - 1;
        }
        auto [hi, lo] = bits::Mul64(uint64_t(x), uint64_t(y));
        if(hi != 0)
        {
            return - 1;
        }
        std::tie(hi, lo) = bits::Mul64(lo, uint64_t(z));
        if(hi != 0)
        {
            return - 1;
        }
        auto a = int(lo);
        if((a < 0) || (uint64_t(a) != lo))
        {
            return - 1;
        }
        return a;
    }

    // add2NonNeg returns (x + y), unless at least one argument is negative or if
    // the computation overflows the int type, in which case it returns -1.
    int add2NonNeg(int x, int y)
    {
        if((x < 0) || (y < 0))
        {
            return - 1;
        }
        auto a = x + y;
        if(a < 0)
        {
            return - 1;
        }
        return a;
    }

}

