// generated by GoCpp from file '$(ImportDir)/runtime/runtime2.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime2.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct gocpp_id_1
    {
        int len;
        gocpp::array<mspan*, 128> buf;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value);
    struct ancestorInfo
    {
        gocpp::slice<uintptr_t> pcs;
        uint64_t goid;
        uintptr_t gopc;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ancestorInfo& value);
    struct funcval
    {
        uintptr_t fn;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct funcval& value);
    struct iface
    {
        itab* tab;
        unsafe::Pointer data;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct iface& value);
    struct eface
    {
        golang::runtime::_type* _type;
        unsafe::Pointer data;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct eface& value);
    extern gocpp::array<std::string, 37> waitReasonStrings;
    struct mutex
    {
        uintptr_t key;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mutex& value);
    struct gocpp_id_0
    {
        int32_t n;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    struct gobuf
    {
        uintptr_t sp;
        uintptr_t pc;
        golang::runtime::guintptr g;
        unsafe::Pointer ctxt;
        uintptr_t ret;
        uintptr_t lr;
        uintptr_t bp;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gobuf& value);
    struct sudog
    {
        g* g;
        sudog* next;
        sudog* prev;
        unsafe::Pointer elem;
        int64_t acquiretime;
        int64_t releasetime;
        uint32_t ticket;
        bool isSelect;
        bool success;
        uint16_t waiters;
        sudog* parent;
        sudog* waitlink;
        sudog* waittail;
        hchan* c;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sudog& value);
    struct libcall
    {
        uintptr_t fn;
        uintptr_t n;
        uintptr_t args;
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct libcall& value);
    struct stack
    {
        uintptr_t lo;
        uintptr_t hi;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stack& value);
    struct heldLockInfo
    {
        uintptr_t lockAddr;
        golang::runtime::lockRank rank;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heldLockInfo& value);
    struct savedOpenDeferState
    {
        uintptr_t retpc;
        uintptr_t deferBitsOffset;
        uintptr_t slotsOffset;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct savedOpenDeferState& value);
    extern bool framepointer_enabled;
    struct note
    {
        uintptr_t key;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct note& value);
    struct _panic
    {
        unsafe::Pointer argp;
        go_any arg;
        _panic* link;
        uintptr_t startPC;
        unsafe::Pointer startSP;
        unsafe::Pointer sp;
        uintptr_t lr;
        unsafe::Pointer fp;
        uintptr_t retpc;
        uint8_t* deferBitsPtr;
        unsafe::Pointer slotsPtr;
        bool recovered;
        bool goexit;
        bool deferreturn;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct _panic& value);
    struct _defer
    {
        bool heap;
        bool rangefunc;
        uintptr_t sp;
        uintptr_t pc;
        std::function<void ()> fn;
        _defer* link;
        atomic::Pointer<_defer>* head;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct _defer& value);
    struct gocpp_id_2
    {
        bool user;
        gQueue runnable;
        int32_t n;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value);
    struct lfnode
    {
        uint64_t next;
        uintptr_t pushcnt;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct lfnode& value);
    struct itab
    {
        golang::runtime::interfacetype* inter;
        golang::runtime::_type* _type;
        uint32_t hash;
        gocpp::array<unsigned char, 4> _1;
        gocpp::array<uintptr_t, 1> fun;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct itab& value);
    struct _func
    {
        uint32_t entryOff;
        int32_t nameOff;
        int32_t args;
        uint32_t deferreturn;
        uint32_t pcsp;
        uint32_t pcfile;
        uint32_t pcln;
        uint32_t npcdata;
        uint32_t cuOffset;
        int32_t startLine;
        abi::FuncID funcID;
        abi::FuncFlag flag;
        gocpp::array<unsigned char, 1> _1;
        uint8_t nfuncdata;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct _func& value);
    struct funcinl
    {
        uint32_t ones;
        uintptr_t entry;
        std::string name;
        std::string file;
        int32_t line;
        int32_t startLine;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct funcinl& value);
    struct eface* efaceOf(go_any* ep);
    void setGNoWB(struct g** gp, struct g* go_new);
    void setMNoWB(struct m** mp, struct m* go_new);
    struct gocpp_id_3
    {
        mutex lock;
        gList stack;
        gList noStack;
        int32_t n;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value);
    struct forcegcstate
    {
        mutex lock;
        g* g;
        atomic::Bool idle;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct forcegcstate& value);
    struct p
    {
        int32_t id;
        uint32_t status;
        golang::runtime::puintptr link;
        uint32_t schedtick;
        uint32_t syscalltick;
        sysmontick sysmontick;
        golang::runtime::muintptr m;
        mcache* mcache;
        pageCache pcache;
        uintptr_t raceprocctx;
        gocpp::slice<_defer*> deferpool;
        gocpp::array<_defer*, 32> deferpoolbuf;
        uint64_t goidcache;
        uint64_t goidcacheend;
        uint32_t runqhead;
        uint32_t runqtail;
        gocpp::array<golang::runtime::guintptr, 256> runq;
        golang::runtime::guintptr runnext;
        gocpp_id_0 gFree;
        gocpp::slice<sudog*> sudogcache;
        gocpp::array<sudog*, 128> sudogbuf;
        gocpp_id_1 mspancache;
        pinner* pinnerCache;
        pTraceState trace;
        persistentAlloc palloc;
        atomic::Int64 timer0When;
        atomic::Int64 timerModifiedEarliest;
        int64_t gcAssistTime;
        int64_t gcFractionalMarkTime;
        limiterEvent limiterEvent;
        golang::runtime::gcMarkWorkerMode gcMarkWorkerMode;
        int64_t gcMarkWorkerStartTime;
        gcWork gcw;
        wbBuf wbBuf;
        uint32_t runSafePointFn;
        atomic::Uint32 statsSeq;
        mutex timersLock;
        gocpp::slice<timer*> timers;
        atomic::Uint32 numTimers;
        atomic::Uint32 deletedTimers;
        uintptr_t timerRaceCtx;
        int64_t maxStackScanDelta;
        uint64_t scannedStackSize;
        uint64_t scannedStacks;
        bool preempt;
        pageTraceBuf pageTraceBuf;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct p& value);
    struct g
    {
        stack stack;
        uintptr_t stackguard0;
        uintptr_t stackguard1;
        _panic* _panic;
        _defer* _defer;
        m* m;
        gobuf sched;
        uintptr_t syscallsp;
        uintptr_t syscallpc;
        uintptr_t stktopsp;
        unsafe::Pointer param;
        atomic::Uint32 atomicstatus;
        uint32_t stackLock;
        uint64_t goid;
        golang::runtime::guintptr schedlink;
        int64_t waitsince;
        golang::runtime::waitReason waitreason;
        bool preempt;
        bool preemptStop;
        bool preemptShrink;
        bool asyncSafePoint;
        bool paniconfault;
        bool gcscandone;
        bool throwsplit;
        bool activeStackChans;
        atomic::Bool parkingOnChan;
        bool inMarkAssist;
        bool coroexit;
        int8_t raceignore;
        bool nocgocallback;
        bool tracking;
        uint8_t trackingSeq;
        int64_t trackingStamp;
        int64_t runnableTime;
        golang::runtime::muintptr lockedm;
        uint32_t sig;
        gocpp::slice<unsigned char> writebuf;
        uintptr_t sigcode0;
        uintptr_t sigcode1;
        uintptr_t sigpc;
        uint64_t parentGoid;
        uintptr_t gopc;
        gocpp::slice<ancestorInfo>* ancestors;
        uintptr_t startpc;
        uintptr_t racectx;
        sudog* waiting;
        gocpp::slice<uintptr_t> cgoCtxt;
        unsafe::Pointer labels;
        timer* timer;
        atomic::Uint32 selectDone;
        coro* coroarg;
        goroutineProfileStateHolder goroutineProfiled;
        gTraceState trace;
        int64_t gcAssistBytes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct g& value);
    struct m
    {
        g* g0;
        gobuf morebuf;
        uint32_t divmod;
        uint32_t _1;
        uint64_t procid;
        g* gsignal;
        gsignalStack goSigStack;
        sigset sigmask;
        gocpp::array<uintptr_t, tlsSlots> tls;
        std::function<void ()> mstartfn;
        g* curg;
        golang::runtime::guintptr caughtsig;
        golang::runtime::puintptr p;
        golang::runtime::puintptr nextp;
        golang::runtime::puintptr oldp;
        int64_t id;
        int32_t mallocing;
        golang::runtime::throwType throwing;
        std::string preemptoff;
        int32_t locks;
        int32_t dying;
        int32_t profilehz;
        bool spinning;
        bool blocked;
        bool newSigstack;
        int8_t printlock;
        bool incgo;
        bool isextra;
        bool isExtraInC;
        bool isExtraInSig;
        atomic::Uint32 freeWait;
        bool needextram;
        uint8_t traceback;
        uint64_t ncgocall;
        int32_t ncgo;
        atomic::Uint32 cgoCallersUse;
        cgoCallers* cgoCallers;
        note park;
        m* alllink;
        golang::runtime::muintptr schedlink;
        golang::runtime::guintptr lockedg;
        gocpp::array<uintptr_t, 32> createstack;
        uint32_t lockedExt;
        uint32_t lockedInt;
        golang::runtime::muintptr nextwaitm;
        mLockProfile mLockProfile;
        std::function<bool (g*, unsafe::Pointer)> waitunlockf;
        unsafe::Pointer waitlock;
        golang::runtime::traceBlockReason waitTraceBlockReason;
        int waitTraceSkip;
        uint32_t syscalltick;
        m* freelink;
        mTraceState trace;
        libcall libcall;
        uintptr_t libcallpc;
        uintptr_t libcallsp;
        golang::runtime::guintptr libcallg;
        libcall syscall;
        uintptr_t vdsoSP;
        uintptr_t vdsoPC;
        atomic::Uint32 preemptGen;
        atomic::Uint32 signalPending;
        pcvalueCache pcvalueCache;
        chacha8rand::State chacha8;
        uint64_t cheaprand;
        int locksHeldLen;
        gocpp::array<heldLockInfo, 10> locksHeld;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct m& value);
    struct schedt
    {
        atomic::Uint64 goidgen;
        atomic::Int64 lastpoll;
        atomic::Int64 pollUntil;
        mutex lock;
        golang::runtime::muintptr midle;
        int32_t nmidle;
        int32_t nmidlelocked;
        int64_t mnext;
        int32_t maxmcount;
        int32_t nmsys;
        int64_t nmfreed;
        atomic::Int32 ngsys;
        golang::runtime::puintptr pidle;
        atomic::Int32 npidle;
        atomic::Int32 nmspinning;
        atomic::Uint32 needspinning;
        gQueue runq;
        int32_t runqsize;
        gocpp_id_2 disable;
        gocpp_id_3 gFree;
        mutex sudoglock;
        sudog* sudogcache;
        mutex deferlock;
        _defer* deferpool;
        m* freem;
        atomic::Bool gcwaiting;
        int32_t stopwait;
        note stopnote;
        atomic::Bool sysmonwait;
        note sysmonnote;
        std::function<void (p*)> safePointFn;
        int32_t safePointWait;
        note safePointNote;
        int32_t profilehz;
        int64_t procresizetime;
        int64_t totaltime;
        mutex sysmonlock;
        timeHistogram timeToRun;
        atomic::Int64 idleTime;
        atomic::Int64 totalMutexWaitTime;
        timeHistogram stwStoppingTimeGC;
        timeHistogram stwStoppingTimeOther;
        timeHistogram stwTotalTimeGC;
        timeHistogram stwTotalTimeOther;
        atomic::Int64 totalRuntimeLockWaitTime;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct schedt& value);

    namespace rec
    {
        struct g* ptr(golang::runtime::guintptr gp);
        void set(golang::runtime::guintptr* gp, struct g* g);
        bool cas(golang::runtime::guintptr* gp, golang::runtime::guintptr old, golang::runtime::guintptr go_new);
        runtime::guintptr guintptr(struct g* gp);
        struct p* ptr(golang::runtime::puintptr pp);
        void set(golang::runtime::puintptr* pp, struct p* p);
        struct m* ptr(golang::runtime::muintptr mp);
        void set(golang::runtime::muintptr* mp, struct m* m);
        std::string String(golang::runtime::waitReason w);
        bool isMutexWait(golang::runtime::waitReason w);
    }
}

