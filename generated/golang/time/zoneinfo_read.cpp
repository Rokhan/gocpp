// generated by GoCpp from file '$(ImportDir)/time/zoneinfo_read.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/zoneinfo_read.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/runtime/extern.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/sys_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/time/zoneinfo_goroot.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // registerLoadFromEmbeddedTZData is called by the time/tzdata package,
    // if it is imported.
    void registerLoadFromEmbeddedTZData(std::function<std::tuple<gocpp::string, struct gocpp::error> (gocpp::string _1)> f)
    {
        loadFromEmbeddedTZData = f;
    }

    // loadFromEmbeddedTZData is used to load a specific tzdata file
    // from tzdata information embedded in the binary itself.
    // This is set when the time/tzdata package is imported,
    // via registerLoadFromEmbeddedTzdata.
    std::function<std::tuple<gocpp::string, struct gocpp::error> (gocpp::string zipname)> loadFromEmbeddedTZData;
    // maxFileSize is the max permitted size of files read by readFile.
    // As reference, the zoneinfo.zip distributed by Go is ~350 KB,
    // so 10MB is overkill.
    gocpp::string rec::Error(golang::time::fileSizeError f)
    {
        return "time: file "_s + gocpp::string(f) + " is too large"_s;
    }

    // Copies of io.Seek* constants to avoid importing "io":
    // Simple I/O interface to binary blob of data.
    
    template<typename T> requires gocpp::GoStruct<T>
    dataIO::operator T()
    {
        T result;
        result.p = this->p;
        result.error = this->error;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dataIO::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        if (error != ref.error) return false;
        return true;
    }

    std::ostream& dataIO::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << " " << error;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dataIO& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<unsigned char> rec::read(golang::time::dataIO* d, int n)
    {
        if(len(d->p) < n)
        {
            d->p = nullptr;
            d->error = true;
            return nullptr;
        }
        auto p = d->p.make_slice(0, n);
        d->p = d->p.make_slice(n);
        return p;
    }

    std::tuple<uint32_t, bool> rec::big4(golang::time::dataIO* d)
    {
        uint32_t n;
        bool ok;
        auto p = rec::read(gocpp::recv(d), 4);
        if(len(p) < 4)
        {
            d->error = true;
            return {0, false};
        }
        return {uint32_t(p[3]) | (uint32_t(p[2]) << 8) | (uint32_t(p[1]) << 16) | (uint32_t(p[0]) << 24), true};
    }

    std::tuple<uint64_t, bool> rec::big8(golang::time::dataIO* d)
    {
        uint64_t n;
        bool ok;
        auto [n1, ok1] = rec::big4(gocpp::recv(d));
        auto [n2, ok2] = rec::big4(gocpp::recv(d));
        if(! ok1 || ! ok2)
        {
            d->error = true;
            return {0, false};
        }
        return {(uint64_t(n1) << 32) | uint64_t(n2), true};
    }

    std::tuple<unsigned char, bool> rec::byte(golang::time::dataIO* d)
    {
        unsigned char n;
        bool ok;
        auto p = rec::read(gocpp::recv(d), 1);
        if(len(p) < 1)
        {
            d->error = true;
            return {0, false};
        }
        return {p[0], true};
    }

    // rest returns the rest of the data in the buffer.
    gocpp::slice<unsigned char> rec::rest(golang::time::dataIO* d)
    {
        auto r = d->p;
        d->p = nullptr;
        return r;
    }

    // Make a string by stopping at the first NUL
    gocpp::string byteString(gocpp::slice<unsigned char> p)
    {
        for(auto i = 0; i < len(p); i++)
        {
            if(p[i] == 0)
            {
                return gocpp::string(p.make_slice(0, i));
            }
        }
        return gocpp::string(p);
    }

    gocpp::error errBadData = errors::New("malformed time zone information"_s);
    // LoadLocationFromTZData returns a Location with the given name
    // initialized from the IANA Time Zone database-formatted data.
    // The data should be in the format of a standard IANA time zone file
    // (for example, the content of /etc/localtime on Unix systems).
    std::tuple<struct Location*, struct gocpp::error> LoadLocationFromTZData(gocpp::string name, gocpp::slice<unsigned char> data)
    {
        auto d = dataIO {data, false};
        if(auto magic = rec::read(gocpp::recv(d), 4); gocpp::string(magic) != "TZif"_s)
        {
            return {nullptr, errBadData};
        }
        // 1-byte version, then 15 bytes of padding
        int version = {};
        gocpp::slice<unsigned char> p = {};
        if(p = rec::read(gocpp::recv(d), 16); len(p) != 16)
        {
            return {nullptr, errBadData};
        }
        else
        {
            //Go switch emulation
            {
                auto condition = p[0];
                int conditionId = -1;
                if(condition == 0) { conditionId = 0; }
                else if(condition == '2') { conditionId = 1; }
                else if(condition == '3') { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        version = 1;
                        break;
                    case 1:
                        version = 2;
                        break;
                    case 2:
                        version = 3;
                        break;
                    default:
                        return {nullptr, errBadData};
                        break;
                }
            }
        }
        // six big-endian 32-bit integers:
        //	number of UTC/local indicators
        //	number of standard/wall indicators
        //	number of leap seconds
        //	number of transition times
        //	number of local time zones
        //	number of characters of time zone abbrev strings
        auto NUTCLocal = 0;
        auto NStdWall = 1;
        auto NLeap = 2;
        auto NTime = 3;
        auto NZone = 4;
        auto NChar = 5;
        gocpp::array<int, 6> n = {};
        for(auto i = 0; i < 6; i++)
        {
            auto [nn, ok] = rec::big4(gocpp::recv(d));
            if(! ok)
            {
                return {nullptr, errBadData};
            }
            if(uint32_t(int(nn)) != nn)
            {
                return {nullptr, errBadData};
            }
            n[i] = int(nn);
        }
        auto is64 = false;
        if(version > 1)
        {
            auto skip = n[NTime] * 4 + n[NTime] + n[NZone] * 6 + n[NChar] + n[NLeap] * 8 + n[NStdWall] + n[NUTCLocal];
            skip += 4 + 16;
            rec::read(gocpp::recv(d), skip);
            is64 = true;
            for(auto i = 0; i < 6; i++)
            {
                auto [nn, ok] = rec::big4(gocpp::recv(d));
                if(! ok)
                {
                    return {nullptr, errBadData};
                }
                if(uint32_t(int(nn)) != nn)
                {
                    return {nullptr, errBadData};
                }
                n[i] = int(nn);
            }
        }
        auto size = 4;
        if(is64)
        {
            size = 8;
        }
        auto txtimes = dataIO {rec::read(gocpp::recv(d), n[NTime] * size), false};
        auto txzones = rec::read(gocpp::recv(d), n[NTime]);
        auto zonedata = dataIO {rec::read(gocpp::recv(d), n[NZone] * 6), false};
        auto abbrev = rec::read(gocpp::recv(d), n[NChar]);
        rec::read(gocpp::recv(d), n[NLeap] * (size + 4));
        auto isstd = rec::read(gocpp::recv(d), n[NStdWall]);
        auto isutc = rec::read(gocpp::recv(d), n[NUTCLocal]);
        if(d.error)
        {
            return {nullptr, errBadData};
        }
        gocpp::string extend = {};
        auto rest = rec::rest(gocpp::recv(d));
        if(len(rest) > 2 && rest[0] == '\n' && rest[len(rest) - 1] == '\n')
        {
            extend = gocpp::string(rest.make_slice(1, len(rest) - 1));
        }
        auto nzone = n[NZone];
        if(nzone == 0)
        {
            return {nullptr, errBadData};
        }
        auto zones = gocpp::make(gocpp::Tag<gocpp::slice<zone>>(), nzone);
        for(auto [i, gocpp_ignored] : zones)
        {
            bool ok = {};
            uint32_t n = {};
            if(std::tie(n, ok) = rec::big4(gocpp::recv(zonedata)); ! ok)
            {
                return {nullptr, errBadData};
            }
            if(uint32_t(int(n)) != n)
            {
                return {nullptr, errBadData};
            }
            zones[i].offset = int(int32_t(n));
            unsigned char b = {};
            if(std::tie(b, ok) = rec::byte(gocpp::recv(zonedata)); ! ok)
            {
                return {nullptr, errBadData};
            }
            zones[i].isDST = b != 0;
            if(std::tie(b, ok) = rec::byte(gocpp::recv(zonedata)); ! ok || int(b) >= len(abbrev))
            {
                return {nullptr, errBadData};
            }
            zones[i].name = byteString(abbrev.make_slice(b));
            if(mocklib::GOOS == "aix"_s && len(name) > 8 && (name.make_slice(0, 8) == "Etc/GMT+"_s || name.make_slice(0, 8) == "Etc/GMT-"_s))
            {
                if(name != "Etc/GMT+0"_s)
                {
                    zones[i].name = name.make_slice(4);
                }
            }
        }
        auto tx = gocpp::make(gocpp::Tag<gocpp::slice<zoneTrans>>(), n[NTime]);
        for(auto [i, gocpp_ignored] : tx)
        {
            int64_t n = {};
            if(! is64)
            {
                if(auto [n4, ok] = rec::big4(gocpp::recv(txtimes)); ! ok)
                {
                    return {nullptr, errBadData};
                }
                else
                {
                    n = int64_t(int32_t(n4));
                }
            }
            else
            {
                if(auto [n8, ok] = rec::big8(gocpp::recv(txtimes)); ! ok)
                {
                    return {nullptr, errBadData};
                }
                else
                {
                    n = int64_t(n8);
                }
            }
            tx[i].when = n;
            if(int(txzones[i]) >= len(zones))
            {
                return {nullptr, errBadData};
            }
            tx[i].index = txzones[i];
            if(i < len(isstd))
            {
                tx[i].isstd = isstd[i] != 0;
            }
            if(i < len(isutc))
            {
                tx[i].isutc = isutc[i] != 0;
            }
        }
        if(len(tx) == 0)
        {
            tx = append(tx, gocpp::Init<zoneTrans>([=](auto& x) {
                x.when = alpha;
                x.index = 0;
            }));
        }
        auto l = gocpp::InitPtr<Location>([=](auto& x) {
            x.zone = zones;
            x.tx = tx;
            x.name = name;
            x.extend = extend;
        });
        auto [sec, gocpp_id_0, gocpp_id_1] = now();
        for(auto [i, gocpp_ignored] : tx)
        {
            if(tx[i].when <= sec && (i + 1 == len(tx) || sec < tx[i + 1].when))
            {
                l->cacheStart = tx[i].when;
                l->cacheEnd = omega;
                l->cacheZone = & l->zone[tx[i].index];
                if(i + 1 < len(tx))
                {
                    l->cacheEnd = tx[i + 1].when;
                }
                else
                if(l->extend != ""_s)
                {
                    if(auto [name, offset, estart, eend, isDST, ok] = tzset(l->extend, l->cacheStart, sec); ok)
                    {
                        l->cacheStart = estart;
                        l->cacheEnd = eend;
                        if(auto zoneIdx = findZone(l->zone, name, offset, isDST); zoneIdx != - 1)
                        {
                            l->cacheZone = & l->zone[zoneIdx];
                        }
                        else
                        {
                            l->cacheZone = gocpp::InitPtr<zone>([=](auto& x) {
                                x.name = name;
                                x.offset = offset;
                                x.isDST = isDST;
                            });
                        }
                    }
                }
                break;
            }
        }
        return {l, nullptr};
    }

    int findZone(gocpp::slice<zone> zones, gocpp::string name, int offset, bool isDST)
    {
        for(auto [i, z] : zones)
        {
            if(z.name == name && z.offset == offset && z.isDST == isDST)
            {
                return i;
            }
        }
        return - 1;
    }

    // loadTzinfoFromDirOrZip returns the contents of the file with the given name
    // in dir. dir can either be an uncompressed zip file, or a directory.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> loadTzinfoFromDirOrZip(gocpp::string dir, gocpp::string name)
    {
        if(len(dir) > 4 && dir.make_slice(len(dir) - 4) == ".zip"_s)
        {
            return loadTzinfoFromZip(dir, name);
        }
        if(dir != ""_s)
        {
            name = dir + "/"_s + name;
        }
        return readFile(name);
    }

    // get4 returns the little-endian 32-bit value in b.
    int get4(gocpp::slice<unsigned char> b)
    {
        if(len(b) < 4)
        {
            return 0;
        }
        return int(b[0]) | (int(b[1]) << 8) | (int(b[2]) << 16) | (int(b[3]) << 24);
    }

    // get2 returns the little-endian 16-bit value in b.
    int get2(gocpp::slice<unsigned char> b)
    {
        if(len(b) < 2)
        {
            return 0;
        }
        return int(b[0]) | (int(b[1]) << 8);
    }

    // loadTzinfoFromZip returns the contents of the file with the given name
    // in the given uncompressed zip file.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> loadTzinfoFromZip(gocpp::string zipfile, gocpp::string name)
    {
        gocpp::Defer defer;
        try
        {
            auto [fd, err] = open(zipfile);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ closefd(fd); });
            auto zecheader = 0x06054b50;
            auto zcheader = 0x02014b50;
            auto ztailsize = 22;
            auto zheadersize = 30;
            auto zheader = 0x04034b50;
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), ztailsize);
            if(auto err = preadn(fd, buf, - ztailsize); err != nullptr || get4(buf) != zecheader)
            {
                return {nullptr, errors::New("corrupt zip file "_s + zipfile)};
            }
            auto n = get2(buf.make_slice(10));
            auto size = get4(buf.make_slice(12));
            auto off = get4(buf.make_slice(16));
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
            if(auto err = preadn(fd, buf, off); err != nullptr)
            {
                return {nullptr, errors::New("corrupt zip file "_s + zipfile)};
            }
            for(auto i = 0; i < n; i++)
            {
                if(get4(buf) != zcheader)
                {
                    break;
                }
                auto meth = get2(buf.make_slice(10));
                auto size = get4(buf.make_slice(24));
                auto namelen = get2(buf.make_slice(28));
                auto xlen = get2(buf.make_slice(30));
                auto fclen = get2(buf.make_slice(32));
                auto off = get4(buf.make_slice(42));
                auto zname = buf.make_slice(46, 46 + namelen);
                buf = buf.make_slice(46 + namelen + xlen + fclen);
                if(gocpp::string(zname) != name)
                {
                    continue;
                }
                if(meth != 0)
                {
                    return {nullptr, errors::New("unsupported compression for "_s + name + " in "_s + zipfile)};
                }
                buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), zheadersize + namelen);
                if(auto err = preadn(fd, buf, off); err != nullptr || get4(buf) != zheader || get2(buf.make_slice(8)) != meth || get2(buf.make_slice(26)) != namelen || gocpp::string(buf.make_slice(30, 30 + namelen)) != name)
                {
                    return {nullptr, errors::New("corrupt zip file "_s + zipfile)};
                }
                xlen = get2(buf.make_slice(28));
                buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
                if(auto err = preadn(fd, buf, off + 30 + namelen + xlen); err != nullptr)
                {
                    return {nullptr, errors::New("corrupt zip file "_s + zipfile)};
                }
                return {buf, nullptr};
            }
            return {nullptr, syscall::go_ENOENT};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // loadTzinfoFromTzdata returns the time zone information of the time zone
    // with the given name, from a tzdata database file as they are typically
    // found on android.
    std::function<std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> (gocpp::string file, gocpp::string name)> loadTzinfoFromTzdata;
    // loadTzinfo returns the time zone information of the time zone
    // with the given name, from a given source. A source may be a
    // timezone database directory, tzdata database file or an uncompressed
    // zip file, containing the contents of such a directory.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> loadTzinfo(gocpp::string name, gocpp::string source)
    {
        if(len(source) >= 6 && source.make_slice(len(source) - 6) == "tzdata"_s)
        {
            return loadTzinfoFromTzdata(source, name);
        }
        return loadTzinfoFromDirOrZip(source, name);
    }

    // loadLocation returns the Location with the given name from one of
    // the specified sources. See loadTzinfo for a list of supported sources.
    // The first timezone data matching the given name that is successfully loaded
    // and parsed is returned as a Location.
    std::tuple<struct Location*, struct gocpp::error> loadLocation(gocpp::string name, gocpp::slice<gocpp::string> sources)
    {
        struct Location* z;
        struct gocpp::error firstErr;
        for(auto [gocpp_ignored, source] : sources)
        {
            auto [zoneData, err] = loadTzinfo(name, source);
            if(err == nullptr)
            {
                if(std::tie(z, err) = LoadLocationFromTZData(name, zoneData); err == nullptr)
                {
                    return {z, nullptr};
                }
            }
            if(firstErr == nullptr && err != syscall::go_ENOENT)
            {
                firstErr = err;
            }
        }
        if(loadFromEmbeddedTZData != nullptr)
        {
            auto [zoneData, err] = loadFromEmbeddedTZData(name);
            if(err == nullptr)
            {
                if(std::tie(z, err) = LoadLocationFromTZData(name, gocpp::slice<unsigned char>(zoneData)); err == nullptr)
                {
                    return {z, nullptr};
                }
            }
            if(firstErr == nullptr && err != syscall::go_ENOENT)
            {
                firstErr = err;
            }
        }
        if(auto [source, ok] = gorootZoneSource(runtime::GOROOT()); ok)
        {
            auto [zoneData, err] = loadTzinfo(name, source);
            if(err == nullptr)
            {
                if(std::tie(z, err) = LoadLocationFromTZData(name, zoneData); err == nullptr)
                {
                    return {z, nullptr};
                }
            }
            if(firstErr == nullptr && err != syscall::go_ENOENT)
            {
                firstErr = err;
            }
        }
        if(firstErr != nullptr)
        {
            return {nullptr, firstErr};
        }
        return {nullptr, errors::New("unknown time zone "_s + name)};
    }

    // readFile reads and returns the content of the named file.
    // It is a trivial implementation of os.ReadFile, reimplemented
    // here to avoid depending on io/ioutil or os.
    // It returns an error if name exceeds maxFileSize bytes.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> readFile(gocpp::string name)
    {
        gocpp::Defer defer;
        try
        {
            auto [f, err] = open(name);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ closefd(f); });
            gocpp::array<unsigned char, 4096> buf = {};
            gocpp::slice<unsigned char> ret = {};
            int n = {};
            for(; ; )
            {
                std::tie(n, err) = read(f, buf.make_slice(0));
                if(n > 0)
                {
                    ret = append(ret, buf.make_slice(0, n));
                }
                if(n == 0 || err != nullptr)
                {
                    break;
                }
                if(len(ret) > maxFileSize)
                {
                    return {nullptr, fileSizeError(name)};
                }
            }
            return {ret, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

