// generated by GoCpp from file '$(ImportDir)/hash/adler32/adler32.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/hash/adler32/adler32.h"
#include "gocpp/support.h"

#include "golang/hash/hash.h"
#include "golang/errors/errors.h"

namespace golang::adler32
{
    int mod = 65521;
    int nmax = 5552;
    int Size = 4;
    // using digest = uint32_t;
    void Reset(digest* d)
    {
        *d = 1;
    }

    hash::Hash32 New()
    {
        auto d = go_new(digest);
        Reset(gocpp::recv(d));
        return d;
    }

    int Size(digest* d)
    {
        return Size;
    }

    int BlockSize(digest* d)
    {
        return 4;
    }

    std::string magic = "adl\x01";
    int marshaledSize = len(magic) + 4;
    std::tuple<gocpp::slice<unsigned char>, std::string> MarshalBinary(digest* d)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, marshaledSize);
        b = append(b, magic);
        b = appendUint32(b, uint32_t(*d));
        return {b, nullptr};
    }

    std::string UnmarshalBinary(digest* d, gocpp::slice<unsigned char> b)
    {
        if(len(b) < len(magic) || string(b.make_slice(0, len(magic))) != magic)
        {
            return New(gocpp::recv(errors), "hash/adler32: invalid hash state identifier");
        }
        if(len(b) != marshaledSize)
        {
            return New(gocpp::recv(errors), "hash/adler32: invalid hash state size");
        }
        *d = digest(readUint32(b.make_slice(len(magic))));
        return nullptr;
    }

    gocpp::slice<unsigned char> appendUint32(gocpp::slice<unsigned char> b, uint32_t x)
    {
        return append(b, byte(x >> 24), byte(x >> 16), byte(x >> 8), byte(x));
    }

    uint32_t readUint32(gocpp::slice<unsigned char> b)
    {
        _ = b[3];
        return uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
    }

    digest update(digest d, gocpp::slice<unsigned char> p)
    {
        auto [s1, s2] = std::tuple{uint32_t(d & 0xffff), uint32_t(d >> 16)};
        for(; len(p) > 0; )
        {
            gocpp::slice<unsigned char> q = {};
            if(len(p) > nmax)
            {
                std::tie(p, q) = std::tuple{p.make_slice(0, nmax), p.make_slice(nmax)};
            }
            for(; len(p) >= 4; )
            {
                s1 += uint32_t(p[0]);
                s2 += s1;
                s1 += uint32_t(p[1]);
                s2 += s1;
                s1 += uint32_t(p[2]);
                s2 += s1;
                s1 += uint32_t(p[3]);
                s2 += s1;
                p = p.make_slice(4);
            }
            for(auto [_, x] : p)
            {
                s1 += uint32_t(x);
                s2 += s1;
            }
            s1 %= mod;
            s2 %= mod;
            p = q;
        }
        return digest((s2 << 16) | s1);
    }

    std::tuple<int, std::string> Write(digest* d, gocpp::slice<unsigned char> p)
    {
        int nn;
        std::string err;
        *d = update(*d, p);
        return {len(p), nullptr};
    }

    uint32_t Sum32(digest* d)
    {
        return uint32_t(*d);
    }

    gocpp::slice<unsigned char> Sum(digest* d, gocpp::slice<unsigned char> in)
    {
        auto s = uint32_t(*d);
        return append(in, byte(s >> 24), byte(s >> 16), byte(s >> 8), byte(s));
    }

    uint32_t Checksum(gocpp::slice<unsigned char> data)
    {
        return uint32_t(update(1, data));
    }

}

