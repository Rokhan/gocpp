// generated by GoCpp from file '$(ImportDir)/runtime/rwmutex.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/rwmutex.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    rwmutex::operator T()
    {
        T result;
        result.rLock = this->rLock;
        result.readers = this->readers;
        result.readerPass = this->readerPass;
        result.wLock = this->wLock;
        result.writer = this->writer;
        result.readerCount = this->readerCount;
        result.readerWait = this->readerWait;
        result.readRank = this->readRank;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool rwmutex::operator==(const T& ref) const
    {
        if (rLock != ref.rLock) return false;
        if (readers != ref.readers) return false;
        if (readerPass != ref.readerPass) return false;
        if (wLock != ref.wLock) return false;
        if (writer != ref.writer) return false;
        if (readerCount != ref.readerCount) return false;
        if (readerWait != ref.readerWait) return false;
        if (readRank != ref.readRank) return false;
        return true;
    }

    std::ostream& rwmutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << rLock;
        os << " " << readers;
        os << " " << readerPass;
        os << " " << wLock;
        os << " " << writer;
        os << " " << readerCount;
        os << " " << readerWait;
        os << " " << readRank;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rwmutex& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct rwmutex* rw, golang::runtime::lockRank readRank, golang::runtime::lockRank readRankInternal, golang::runtime::lockRank writeRank)
    {
        rw->readRank = readRank;
        lockInit(& rw->rLock, readRankInternal);
        lockInit(& rw->wLock, writeRank);
    }

    void rec::rlock(struct rwmutex* rw)
    {
        acquirem();
        acquireLockRank(rw->readRank);
        lockWithRankMayAcquire(& rw->rLock, getLockRank(& rw->rLock));
        if(rec::Add(gocpp::recv(rw->readerCount), 1) < 0)
        {
            systemstack([=]() mutable -> void
            {
                lock(& rw->rLock);
                if(rw->readerPass > 0)
                {
                    rw->readerPass -= 1;
                    unlock(& rw->rLock);
                }
                else
                {
                    auto m = getg()->m;
                    m->schedlink = rw->readers;
                    rec::set(gocpp::recv(rw->readers), m);
                    unlock(& rw->rLock);
                    notesleep(& m->park);
                    noteclear(& m->park);
                }
            });
        }
    }

    void rec::runlock(struct rwmutex* rw)
    {
        if(auto r = rec::Add(gocpp::recv(rw->readerCount), - 1); r < 0)
        {
            if(r + 1 == 0 || r + 1 == - rwmutexMaxReaders)
            {
                go_throw("runlock of unlocked rwmutex"s);
            }
            if(rec::Add(gocpp::recv(rw->readerWait), - 1) == 0)
            {
                lock(& rw->rLock);
                auto w = rec::ptr(gocpp::recv(rw->writer));
                if(w != nullptr)
                {
                    notewakeup(& w->park);
                }
                unlock(& rw->rLock);
            }
        }
        releaseLockRank(rw->readRank);
        releasem(getg()->m);
    }

    void rec::lock(struct rwmutex* rw)
    {
        lock(& rw->wLock);
        auto m = getg()->m;
        auto r = rec::Add(gocpp::recv(rw->readerCount), - rwmutexMaxReaders) + rwmutexMaxReaders;
        lock(& rw->rLock);
        if(r != 0 && rec::Add(gocpp::recv(rw->readerWait), r) != 0)
        {
            systemstack([=]() mutable -> void
            {
                rec::set(gocpp::recv(rw->writer), m);
                unlock(& rw->rLock);
                notesleep(& m->park);
                noteclear(& m->park);
            });
        }
        else
        {
            unlock(& rw->rLock);
        }
    }

    void rec::unlock(struct rwmutex* rw)
    {
        auto r = rec::Add(gocpp::recv(rw->readerCount), rwmutexMaxReaders);
        if(r >= rwmutexMaxReaders)
        {
            go_throw("unlock of unlocked rwmutex"s);
        }
        lock(& rw->rLock);
        for(; rec::ptr(gocpp::recv(rw->readers)) != nullptr; )
        {
            auto reader = rec::ptr(gocpp::recv(rw->readers));
            rw->readers = reader->schedlink;
            rec::set(gocpp::recv(reader->schedlink), nullptr);
            notewakeup(& reader->park);
            r -= 1;
        }
        rw->readerPass += uint32_t(r);
        unlock(& rw->rLock);
        unlock(& rw->wLock);
    }

}

