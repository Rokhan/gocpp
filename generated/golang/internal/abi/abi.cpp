// generated by GoCpp from file '$(ImportDir)/internal/abi/abi.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/abi.h"
#include "gocpp/support.h"

#include "golang/unsafe/unsafe.h"
#include "golang/internal/abi/abi_amd64.h"
// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]

namespace golang::abi
{
    
    std::ostream& RegArgs::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Ints;
        os << " " << Floats;
        os << " " << Ptrs;
        os << " " << ReturnIsPtr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const RegArgs& value)
    {
        return value.PrintTo(os);
    }

    void Dump(RegArgs* r)
    {
        print("Ints:");
        for(auto [_, x] : r->Ints)
        {
            print(" ", x);
        }
        println();
        print("Floats:");
        for(auto [_, x] : r->Floats)
        {
            print(" ", x);
        }
        println();
        print("Ptrs:");
        for(auto [_, x] : r->Ptrs)
        {
            print(" ", x);
        }
        println();
    }

    unsafe::Pointer IntRegArgAddr(RegArgs* r, int reg, uintptr_t argSize)
    {
        if(argSize > goarch.PtrSize || argSize == 0 || argSize & (argSize - 1) != 0)
        {
            gocpp::panic("invalid argSize");
        }
        auto offset = uintptr(0);
        if(goarch.BigEndian)
        {
            offset = goarch.PtrSize - argSize;
        }
        return Pointer(gocpp::recv(unsafe), uintptr(Pointer(gocpp::recv(unsafe), & r->Ints[reg])) + offset);
    }

    void Set(IntArgRegBitmap* b, int i)
    {
        b[i / 8] |= uint8_t(1) << (i % 8);
    }

    bool Get(IntArgRegBitmap* b, int i)
    {
        return b[i / 8] & (uint8_t(1) << (i % 8)) != 0;
    }

}

