// generated by GoCpp from file '$(ImportDir)/runtime/cpuprof.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/cpuprof.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/time_nofake.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // profBufWordCount is the size of the CPU profile buffer's storage for the
    // header and stack of each sample, measured in 64-bit words. Every sample
    // has a required header of two words. With a small additional header (a
    // word or two) and stacks at the profiler's maximum length of 64 frames,
    // that capacity can support 1900 samples or 19 thread-seconds at a 100 Hz
    // sample rate, at a cost of 1 MiB.
    // profBufTagCount is the size of the CPU profile buffer's storage for the
    // goroutine tags associated with each sample. A capacity of 1<<14 means
    // room for 16k samples, or 160 thread-seconds at a 100 Hz sample rate.
    
    template<typename T> requires gocpp::GoStruct<T>
    cpuProfile::operator T()
    {
        T result;
        result.lock = this->lock;
        result.on = this->on;
        result.log = this->log;
        result.extra = this->extra;
        result.numExtra = this->numExtra;
        result.lostExtra = this->lostExtra;
        result.lostAtomic = this->lostAtomic;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cpuProfile::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (on != ref.on) return false;
        if (log != ref.log) return false;
        if (extra != ref.extra) return false;
        if (numExtra != ref.numExtra) return false;
        if (lostExtra != ref.lostExtra) return false;
        if (lostAtomic != ref.lostAtomic) return false;
        return true;
    }

    std::ostream& cpuProfile::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << on;
        os << " " << log;
        os << " " << extra;
        os << " " << numExtra;
        os << " " << lostExtra;
        os << " " << lostAtomic;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuProfile& value)
    {
        return value.PrintTo(os);
    }

    cpuProfile cpuprof;
    // SetCPUProfileRate sets the CPU profiling rate to hz samples per second.
    // If hz <= 0, SetCPUProfileRate turns off profiling.
    // If the profiler is on, the rate cannot be changed without first turning it off.
    //
    // Most clients should use the [runtime/pprof] package or
    // the [testing] package's -test.cpuprofile flag instead of calling
    // SetCPUProfileRate directly.
    void SetCPUProfileRate(int hz)
    {
        if(hz < 0)
        {
            hz = 0;
        }
        if(hz > 1000000)
        {
            hz = 1000000;
        }
        lock(& cpuprof.lock);
        if(hz > 0)
        {
            if(cpuprof.on || cpuprof.log != nullptr)
            {
                print("runtime: cannot set cpu profile rate until previous profile has finished.\n"s);
                unlock(& cpuprof.lock);
                return;
            }
            cpuprof.on = true;
            cpuprof.log = newProfBuf(1, profBufWordCount, profBufTagCount);
            auto hdr = gocpp::array<uint64_t, 1> {uint64_t(hz)};
            rec::write(gocpp::recv(cpuprof.log), nullptr, nanotime(), hdr.make_slice(0), nullptr);
            setcpuprofilerate(int32_t(hz));
        }
        else
        if(cpuprof.on)
        {
            setcpuprofilerate(0);
            cpuprof.on = false;
            rec::addExtra(gocpp::recv(cpuprof));
            rec::close(gocpp::recv(cpuprof.log));
        }
        unlock(& cpuprof.lock);
    }

    // add adds the stack trace to the profile.
    // It is called from signal handlers and other limited environments
    // and cannot allocate memory or acquire locks that might be
    // held at the time of the signal, nor can it use substantial amounts
    // of stack.
    //
    //go:nowritebarrierrec
    void rec::add(struct cpuProfile* p, unsafe::Pointer* tagPtr, gocpp::slice<uintptr_t> stk)
    {
        for(; ! rec::CompareAndSwap(gocpp::recv(prof.signalLock), 0, 1); )
        {
            osyield();
        }
        if(rec::Load(gocpp::recv(prof.hz)) != 0)
        {
            if(p->numExtra > 0 || p->lostExtra > 0 || p->lostAtomic > 0)
            {
                rec::addExtra(gocpp::recv(p));
            }
            auto hdr = gocpp::array<uint64_t, 1> {1};
            rec::write(gocpp::recv(cpuprof.log), tagPtr, nanotime(), hdr.make_slice(0), stk);
        }
        rec::Store(gocpp::recv(prof.signalLock), 0);
    }

    // addNonGo adds the non-Go stack trace to the profile.
    // It is called from a non-Go thread, so we cannot use much stack at all,
    // nor do anything that needs a g or an m.
    // In particular, we can't call cpuprof.log.write.
    // Instead, we copy the stack into cpuprof.extra,
    // which will be drained the next time a Go thread
    // gets the signal handling event.
    //
    //go:nosplit
    //go:nowritebarrierrec
    void rec::addNonGo(struct cpuProfile* p, gocpp::slice<uintptr_t> stk)
    {
        for(; ! rec::CompareAndSwap(gocpp::recv(prof.signalLock), 0, 1); )
        {
            osyield();
        }
        if(cpuprof.numExtra + 1 + len(stk) < len(cpuprof.extra))
        {
            auto i = cpuprof.numExtra;
            cpuprof.extra[i] = uintptr_t(1 + len(stk));
            copy(cpuprof.extra.make_slice(i + 1), stk);
            cpuprof.numExtra += 1 + len(stk);
        }
        else
        {
            cpuprof.lostExtra++;
        }
        rec::Store(gocpp::recv(prof.signalLock), 0);
    }

    // addExtra adds the "extra" profiling events,
    // queued by addNonGo, to the profile log.
    // addExtra is called either from a signal handler on a Go thread
    // or from an ordinary goroutine; either way it can use stack
    // and has a g. The world may be stopped, though.
    void rec::addExtra(struct cpuProfile* p)
    {
        auto hdr = gocpp::array<uint64_t, 1> {1};
        for(auto i = 0; i < p->numExtra; )
        {
            rec::write(gocpp::recv(p->log), nullptr, 0, hdr.make_slice(0), p->extra.make_slice(i + 1, i + int(p->extra[i])));
            i += int(p->extra[i]);
        }
        p->numExtra = 0;
        if(p->lostExtra > 0)
        {
            auto hdr = gocpp::array<uint64_t, 1> {p->lostExtra};
            auto lostStk = gocpp::array<uintptr_t, 2> {abi::FuncPCABIInternal(_LostExternalCode) + sys::PCQuantum, abi::FuncPCABIInternal(_ExternalCode) + sys::PCQuantum};
            rec::write(gocpp::recv(p->log), nullptr, 0, hdr.make_slice(0), lostStk.make_slice(0));
            p->lostExtra = 0;
        }
        if(p->lostAtomic > 0)
        {
            auto hdr = gocpp::array<uint64_t, 1> {p->lostAtomic};
            auto lostStk = gocpp::array<uintptr_t, 2> {abi::FuncPCABIInternal(_LostSIGPROFDuringAtomic64) + sys::PCQuantum, abi::FuncPCABIInternal(_System) + sys::PCQuantum};
            rec::write(gocpp::recv(p->log), nullptr, 0, hdr.make_slice(0), lostStk.make_slice(0));
            p->lostAtomic = 0;
        }
    }

    // CPUProfile panics.
    // It formerly provided raw access to chunks of
    // a pprof-format profile generated by the runtime.
    // The details of generating that format have changed,
    // so this functionality has been removed.
    //
    // Deprecated: Use the [runtime/pprof] package,
    // or the handlers in the [net/http/pprof] package,
    // or the [testing] package's -test.cpuprofile flag instead.
    gocpp::slice<unsigned char> CPUProfile()
    {
        gocpp::panic("CPUProfile no longer available"s);
    }

    //go:linkname runtime_pprof_runtime_cyclesPerSecond runtime/pprof.runtime_cyclesPerSecond
    int64_t runtime_pprof_runtime_cyclesPerSecond()
    {
        return ticksPerSecond();
    }

    // readProfile, provided to runtime/pprof, returns the next chunk of
    // binary CPU profiling stack trace data, blocking until data is available.
    // If profiling is turned off and all the profile data accumulated while it was
    // on has been returned, readProfile returns eof=true.
    // The caller must save the returned data and tags before calling readProfile again.
    // The returned data contains a whole number of records, and tags contains
    // exactly one entry per record.
    //
    //go:linkname runtime_pprof_readProfile runtime/pprof.readProfile
    std::tuple<gocpp::slice<uint64_t>, gocpp::slice<unsafe::Pointer>, bool> runtime_pprof_readProfile()
    {
        lock(& cpuprof.lock);
        auto log = cpuprof.log;
        unlock(& cpuprof.lock);
        auto readMode = profBufBlocking;
        if(GOOS == "darwin"s || GOOS == "ios"s)
        {
            readMode = profBufNonBlocking;
        }
        auto [data, tags, eof] = rec::read(gocpp::recv(log), readMode);
        if(len(data) == 0 && eof)
        {
            lock(& cpuprof.lock);
            cpuprof.log = nullptr;
            unlock(& cpuprof.lock);
        }
        return {data, tags, eof};
    }

}

