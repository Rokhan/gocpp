// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/value.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/reflectlite/type.h"
#include "golang/internal/unsafeheader/unsafeheader.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/symtab.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflectlite
{
    namespace rec
    {
        using namespace mocklib::rec;
        using abi::rec::Kind;
        using abi::rec::NumMethod;
        using abi::rec::Pointers;
        using abi::rec::Size;
        using abi::rec::String;
        using runtime::rec::Name;
    }

    // Value is the reflection interface to a Go value.
    //
    // Not all methods apply to all kinds of values. Restrictions,
    // if any, are noted in the documentation for each method.
    // Use the Kind method to find out the kind of value before
    // calling kind-specific methods. Calling a method
    // inappropriate to the kind of type causes a run time panic.
    //
    // The zero Value represents no value.
    // Its IsValid method returns false, its Kind method returns Invalid,
    // its String method returns "<invalid Value>", and all other methods panic.
    // Most functions and methods never return an invalid value.
    // If one does, its documentation states the conditions explicitly.
    //
    // A Value can be used concurrently by multiple goroutines provided that
    // the underlying Go value can be used concurrently for the equivalent
    // direct operations.
    //
    // To compare two Values, compare the results of the Interface method.
    // Using == on two Values does not compare the underlying values
    // they represent.
    
    template<typename T> requires gocpp::GoStruct<T>
    Value::operator T()
    {
        T result;
        result.typ_ = this->typ_;
        result.ptr = this->ptr;
        result.flag = this->flag;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Value::operator==(const T& ref) const
    {
        if (typ_ != ref.typ_) return false;
        if (ptr != ref.ptr) return false;
        if (flag != ref.flag) return false;
        return true;
    }

    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ_;
        os << " " << ptr;
        os << " " << flag;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Value& value)
    {
        return value.PrintTo(os);
    }

    reflectlite::Kind rec::kind(golang::reflectlite::flag f)
    {
        return Kind(f & flagKindMask);
    }

    reflectlite::flag rec::ro(golang::reflectlite::flag f)
    {
        if(f & flagRO != 0)
        {
            return flagStickyRO;
        }
        return 0;
    }

    abi::Type* rec::typ(struct Value v)
    {
        return (abi::Type*)(noescape(unsafe::Pointer(v.typ_)));
    }

    // pointer returns the underlying pointer represented by v.
    // v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer
    unsafe::Pointer rec::pointer(struct Value v)
    {
        if(rec::Size(gocpp::recv(rec::typ(gocpp::recv(v)))) != goarch::PtrSize || ! rec::Pointers(gocpp::recv(rec::typ(gocpp::recv(v)))))
        {
            gocpp::panic("can't call pointer on a non-pointer Value"s);
        }
        if(v.flag & flagIndir != 0)
        {
            return *(unsafe::Pointer*)(v.ptr);
        }
        return v.ptr;
    }

    // packEface converts v to the empty interface.
    go_any packEface(struct Value v)
    {
        auto t = rec::typ(gocpp::recv(v));
        go_any i = {};
        auto e = (emptyInterface*)(unsafe::Pointer(& i));
        //Go switch emulation
        {
            int conditionId = -1;
            if(ifaceIndir(t)) { conditionId = 0; }
            else if(v.flag & flagIndir != 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(v.flag & flagIndir == 0)
                    {
                        gocpp::panic("bad indir"s);
                    }
                    auto ptr = v.ptr;
                    if(v.flag & flagAddr != 0)
                    {
                        auto c = unsafe_New(t);
                        typedmemmove(t, c, ptr);
                        ptr = c;
                    }
                    e->word = ptr;
                    break;
                case 1:
                    e->word = *(unsafe::Pointer*)(v.ptr);
                    break;
                default:
                    e->word = v.ptr;
                    break;
            }
        }
        e->typ = t;
        return i;
    }

    // unpackEface converts the empty interface i to a Value.
    struct Value unpackEface(go_any i)
    {
        auto e = (emptyInterface*)(unsafe::Pointer(& i));
        auto t = e->typ;
        if(t == nullptr)
        {
            return Value {};
        }
        auto f = flag(rec::Kind(gocpp::recv(t)));
        if(ifaceIndir(t))
        {
            f |= flagIndir;
        }
        return Value {t, e->word, f};
    }

    // A ValueError occurs when a Value method is invoked on
    // a Value that does not support it. Such cases are documented
    // in the description of each method.
    
    template<typename T> requires gocpp::GoStruct<T>
    ValueError::operator T()
    {
        T result;
        result.Method = this->Method;
        result.Kind = this->Kind;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ValueError::operator==(const T& ref) const
    {
        if (Method != ref.Method) return false;
        if (Kind != ref.Kind) return false;
        return true;
    }

    std::ostream& ValueError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Method;
        os << " " << Kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct ValueError* e)
    {
        if(e->Kind == 0)
        {
            return "reflect: call of "s + e->Method + " on zero Value"s;
        }
        return "reflect: call of "s + e->Method + " on "s + rec::String(gocpp::recv(e->Kind)) + " Value"s;
    }

    // methodName returns the name of the calling method,
    // assumed to be two stack frames above.
    std::string methodName()
    {
        auto [pc, gocpp_id_0, gocpp_id_1, gocpp_id_2] = runtime::Caller(2);
        auto f = runtime::FuncForPC(pc);
        if(f == nullptr)
        {
            return "unknown method"s;
        }
        return rec::Name(gocpp::recv(f));
    }

    // emptyInterface is the header for an interface{} value.
    
    template<typename T> requires gocpp::GoStruct<T>
    emptyInterface::operator T()
    {
        T result;
        result.typ = this->typ;
        result.word = this->word;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool emptyInterface::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (word != ref.word) return false;
        return true;
    }

    std::ostream& emptyInterface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << word;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value)
    {
        return value.PrintTo(os);
    }

    // mustBeExported panics if f records that the value was obtained using
    // an unexported field.
    void rec::mustBeExported(golang::reflectlite::flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {methodName(), 0});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: "s + methodName() + " using value obtained using unexported field"s);
        }
    }

    // mustBeAssignable panics if f records that the value is not assignable,
    // which is to say that either it was obtained using an unexported field
    // or it is not addressable.
    void rec::mustBeAssignable(golang::reflectlite::flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {methodName(), abi::Invalid});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: "s + methodName() + " using value obtained using unexported field"s);
        }
        if(f & flagAddr == 0)
        {
            gocpp::panic("reflect: "s + methodName() + " using unaddressable value"s);
        }
    }

    // CanSet reports whether the value of v can be changed.
    // A Value can be changed only if it is addressable and was not
    // obtained by the use of unexported struct fields.
    // If CanSet returns false, calling Set or any type-specific
    // setter (e.g., SetBool, SetInt) will panic.
    bool rec::CanSet(struct Value v)
    {
        return v.flag & (flagAddr | flagRO) == flagAddr;
    }

    
                        template<typename T>
                        gocpp_id_3::gocpp_id_3(T& ref)
                        {
                            value.reset(new gocpp_id_3Impl<T, std::unique_ptr<T>>(new T(ref)));
                        }

                        template<typename T>
                        gocpp_id_3::gocpp_id_3(const T& ref)
                        {
                            value.reset(new gocpp_id_3Impl<T, std::unique_ptr<T>>(new T(ref)));
                        }

                        template<typename T>
                        gocpp_id_3::gocpp_id_3(T* ptr)
                        {
                            value.reset(new gocpp_id_3Impl<T, gocpp::ptr<T>>(ptr));
                        }

                        std::ostream& gocpp_id_3::PrintTo(std::ostream& os) const
                        {
                            return os;
                        }

                        template<typename T, typename StoreT>
                        void gocpp_id_3::gocpp_id_3Impl<T, StoreT>::vM()
                        {
                            return rec::M(gocpp::PtrRecv<T, false>(value.get()));
                        }

                        namespace rec
                        {
                            void M(const gocpp::PtrRecv<struct gocpp_id_3, false>& self)
                            {
                                return self.ptr->value->vM();
                            }

                            void M(const gocpp::ObjRecv<struct gocpp_id_3>& self)
                            {
                                return self.obj.value->vM();
                            }
                        }

                        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value)
                        {
                            return value.PrintTo(os);
                        }


    // Elem returns the value that the interface v contains
    // or that the pointer v points to.
    // It panics if v's Kind is not Interface or Pointer.
    // It returns the zero Value if v is nil.
    struct Value rec::Elem(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == abi::Interface) { conditionId = 0; }
            else if(condition == abi::Pointer) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    go_any eface = {};
                    if(rec::NumMethod(gocpp::recv(rec::typ(gocpp::recv(v)))) == 0)
                    {
                        eface = *(go_any*)(v.ptr);
                    }
                    else
                    {
                        eface = (go_any)(*(gocpp_id_3*)(v.ptr));
                    }
                    auto x = unpackEface(eface);
                    if(x.flag != 0)
                    {
                        x.flag |= rec::ro(gocpp::recv(v.flag));
                    }
                    return x;
                    break;
                case 1:
                    auto ptr = v.ptr;
                    if(v.flag & flagIndir != 0)
                    {
                        ptr = *(unsafe::Pointer*)(ptr);
                    }
                    if(ptr == nullptr)
                    {
                        return Value {};
                    }
                    auto tt = (reflectlite::ptrType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    auto typ = tt->Elem;
                    auto fl = v.flag & flagRO | flagIndir | flagAddr;
                    fl |= flag(rec::Kind(gocpp::recv(typ)));
                    return Value {typ, ptr, fl};
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflectlite.Value.Elem"s, rec::kind(gocpp::recv(v))});
    }

    
            template<typename T>
            gocpp_id_4::gocpp_id_4(T& ref)
            {
                value.reset(new gocpp_id_4Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_4::gocpp_id_4(const T& ref)
            {
                value.reset(new gocpp_id_4Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_4::gocpp_id_4(T* ptr)
            {
                value.reset(new gocpp_id_4Impl<T, gocpp::ptr<T>>(ptr));
            }

            std::ostream& gocpp_id_4::PrintTo(std::ostream& os) const
            {
                return os;
            }

            template<typename T, typename StoreT>
            void gocpp_id_4::gocpp_id_4Impl<T, StoreT>::vM()
            {
                return rec::M(gocpp::PtrRecv<T, false>(value.get()));
            }

            namespace rec
            {
                void M(const gocpp::PtrRecv<struct gocpp_id_4, false>& self)
                {
                    return self.ptr->value->vM();
                }

                void M(const gocpp::ObjRecv<struct gocpp_id_4>& self)
                {
                    return self.obj.value->vM();
                }
            }

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_4& value)
            {
                return value.PrintTo(os);
            }


    go_any valueInterface(struct Value v)
    {
        if(v.flag == 0)
        {
            gocpp::panic(new ValueError {"reflectlite.Value.Interface"s, 0});
        }
        if(rec::kind(gocpp::recv(v)) == abi::Interface)
        {
            if(rec::numMethod(gocpp::recv(v)) == 0)
            {
                return *(go_any*)(v.ptr);
            }
            return *(gocpp_id_4*)(v.ptr);
        }
        return packEface(v);
    }

    // IsNil reports whether its argument v is nil. The argument must be
    // a chan, func, interface, map, pointer, or slice value; if it is
    // not, IsNil panics. Note that IsNil is not always equivalent to a
    // regular comparison with nil in Go. For example, if v was created
    // by calling ValueOf with an uninitialized interface variable i,
    // i==nil will be true but v.IsNil will panic as v will be the zero
    // Value.
    bool rec::IsNil(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == abi::Chan) { conditionId = 0; }
            else if(condition == abi::Func) { conditionId = 1; }
            else if(condition == abi::Map) { conditionId = 2; }
            else if(condition == abi::Pointer) { conditionId = 3; }
            else if(condition == abi::UnsafePointer) { conditionId = 4; }
            else if(condition == abi::Interface) { conditionId = 5; }
            else if(condition == abi::Slice) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    auto ptr = v.ptr;
                    if(v.flag & flagIndir != 0)
                    {
                        ptr = *(unsafe::Pointer*)(ptr);
                    }
                    return ptr == nullptr;
                    break;
                case 5:
                case 6:
                    return *(unsafe::Pointer*)(v.ptr) == nullptr;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflectlite.Value.IsNil"s, rec::kind(gocpp::recv(v))});
    }

    // IsValid reports whether v represents a value.
    // It returns false if v is the zero Value.
    // If IsValid returns false, all other methods except String panic.
    // Most functions and methods never return an invalid Value.
    // If one does, its documentation states the conditions explicitly.
    bool rec::IsValid(struct Value v)
    {
        return v.flag != 0;
    }

    // Kind returns v's Kind.
    // If v is the zero Value (IsValid returns false), Kind returns Invalid.
    reflectlite::Kind rec::Kind(struct Value v)
    {
        return rec::kind(gocpp::recv(v));
    }

    //go:noescape
    int chanlen(unsafe::Pointer)
    /* convertBlockStmt, nil block */;

    //go:noescape
    int maplen(unsafe::Pointer)
    /* convertBlockStmt, nil block */;

    // Len returns v's length.
    // It panics if v's Kind is not Array, Chan, Map, Slice, or String.
    int rec::Len(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == abi::Array) { conditionId = 0; }
            else if(condition == abi::Chan) { conditionId = 1; }
            else if(condition == abi::Map) { conditionId = 2; }
            else if(condition == abi::Slice) { conditionId = 3; }
            else if(condition == abi::String) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    auto tt = (reflectlite::arrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    return int(tt->Len);
                    break;
                case 1:
                    return chanlen(rec::pointer(gocpp::recv(v)));
                    break;
                case 2:
                    return maplen(rec::pointer(gocpp::recv(v)));
                    break;
                case 3:
                    return (unsafeheader::Slice*)(v.ptr)->Len;
                    break;
                case 4:
                    return (unsafeheader::String*)(v.ptr)->Len;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Len"s, rec::kind(gocpp::recv(v))});
    }

    // NumMethod returns the number of exported methods in the value's method set.
    int rec::numMethod(struct Value v)
    {
        if(rec::typ(gocpp::recv(v)) == nullptr)
        {
            gocpp::panic(new ValueError {"reflectlite.Value.NumMethod"s, abi::Invalid});
        }
        return rec::NumMethod(gocpp::recv(rec::typ(gocpp::recv(v))));
    }

    // Set assigns x to the value v.
    // It panics if CanSet returns false.
    // As in Go, x's value must be assignable to v's type.
    void rec::Set(struct Value v, struct Value x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBeExported(gocpp::recv(x));
        unsafe::Pointer target = {};
        if(rec::kind(gocpp::recv(v)) == abi::Interface)
        {
            target = v.ptr;
        }
        x = rec::assignTo(gocpp::recv(x), "reflectlite.Set"s, rec::typ(gocpp::recv(v)), target);
        if(x.flag & flagIndir != 0)
        {
            typedmemmove(rec::typ(gocpp::recv(v)), v.ptr, x.ptr);
        }
        else
        {
            *(unsafe::Pointer*)(v.ptr) = x.ptr;
        }
    }

    // Type returns v's type.
    struct Type rec::Type(struct Value v)
    {
        auto f = v.flag;
        if(f == 0)
        {
            gocpp::panic(new ValueError {"reflectlite.Value.Type"s, abi::Invalid});
        }
        return toRType(rec::typ(gocpp::recv(v)));
    }

    //go:noescape
    unsafe::Pointer unsafe_New(abi::Type*)
    /* convertBlockStmt, nil block */;

    // ValueOf returns a new Value initialized to the concrete value
    // stored in the interface i. ValueOf(nil) returns the zero Value.
    struct Value ValueOf(go_any i)
    {
        if(i == nullptr)
        {
            return Value {};
        }
        return unpackEface(i);
    }

    // assignTo returns a value v that can be assigned directly to typ.
    // It panics if v is not assignable to typ.
    // For a conversion to an interface type, target is a suggested scratch space to use.
    struct Value rec::assignTo(struct Value v, std::string context, abi::Type* dst, unsafe::Pointer target)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(directlyAssignable(dst, rec::typ(gocpp::recv(v)))) { conditionId = 0; }
            else if(implements(dst, rec::typ(gocpp::recv(v)))) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    auto fl = v.flag & (flagAddr | flagIndir) | rec::ro(gocpp::recv(v.flag));
                    fl |= flag(rec::Kind(gocpp::recv(dst)));
                    return Value {dst, v.ptr, fl};
                    break;
                case 1:
                    if(target == nullptr)
                    {
                        target = unsafe_New(dst);
                    }
                    if(rec::Kind(gocpp::recv(v)) == abi::Interface && rec::IsNil(gocpp::recv(v)))
                    {
                        return Value {dst, nullptr, flag(abi::Interface)};
                    }
                    auto x = valueInterface(v);
                    if(rec::NumMethod(gocpp::recv(dst)) == 0)
                    {
                        *(go_any*)(target) = x;
                    }
                    else
                    {
                        ifaceE2I(dst, x, target);
                    }
                    return Value {dst, target, flagIndir | flag(abi::Interface)};
                    break;
            }
        }
        gocpp::panic(context + ": value of type "s + rec::String(gocpp::recv(toRType(rec::typ(gocpp::recv(v))))) + " is not assignable to type "s + rec::String(gocpp::recv(toRType(dst))));
    }

    // arrayAt returns the i-th element of p,
    // an array whose elements are eltSize bytes wide.
    // The array pointed at by p must have at least i+1 elements:
    // it is invalid (but impossible to check here) to pass i >= len,
    // because then the result will point outside the array.
    // whySafe must explain why i < len. (Passing "i < len" is fine;
    // the benefit is to surface this assumption at the call site.)
    unsafe::Pointer arrayAt(unsafe::Pointer p, int i, uintptr_t eltSize, std::string whySafe)
    {
        return add(p, uintptr_t(i) * eltSize, "i < len"s);
    }

    void ifaceE2I(abi::Type* t, go_any src, unsafe::Pointer dst)
    /* convertBlockStmt, nil block */;

    // typedmemmove copies a value of type t to dst from src.
    //
    //go:noescape
    void typedmemmove(abi::Type* t, unsafe::Pointer dst, unsafe::Pointer src)
    /* convertBlockStmt, nil block */;

    // Dummy annotation marking that the value x escapes,
    // for use in cases where the reflect code is so clever that
    // the compiler cannot follow.
    void escapes(go_any x)
    {
        if(dummy.b)
        {
            dummy.x = x;
        }
    }

    struct gocpp_id_5
    {
        bool b;
        go_any x;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.b = this->b;
            result.x = this->x;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (b != ref.b) return false;
            if (x != ref.x) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << b;
            os << " " << x;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_5& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_5 dummy;
    //go:nosplit
    unsafe::Pointer noescape(unsafe::Pointer p)
    {
        auto x = uintptr_t(p);
        return unsafe::Pointer(x ^ 0);
    }

}

