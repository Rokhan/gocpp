// generated by GoCpp from file '$(ImportDir)/runtime/internal/atomic/types.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/internal/atomic/types.fwd.h"
#include "gocpp/support.h"


namespace golang::atomic
{
    void storePointer(gocpp::unsafe_pointer* ptr, gocpp::unsafe_pointer go_new);
    bool casPointer(gocpp::unsafe_pointer* ptr, gocpp::unsafe_pointer old, gocpp::unsafe_pointer go_new);
    struct noCopy
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value);
    struct align64
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct align64& value);
    struct Int32
    {
        noCopy noCopy;
        int32_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Int32& value);
    struct Int64
    {
        noCopy noCopy;
        align64 _1;
        int64_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Int64& value);
    struct Uint8
    {
        noCopy noCopy;
        uint8_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uint8& value);
    struct Uint32
    {
        noCopy noCopy;
        uint32_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uint32& value);
    struct Uint64
    {
        noCopy noCopy;
        align64 _1;
        uint64_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uint64& value);
    struct Uintptr
    {
        noCopy noCopy;
        uintptr_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uintptr& value);
    struct UnsafePointer
    {
        noCopy noCopy;
        gocpp::unsafe_pointer value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct UnsafePointer& value);
    struct Bool
    {
        Uint8 u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Bool& value);
    struct Float64
    {
        Uint64 u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Float64& value);
    template<typename T> 
    struct Pointer
    {
        UnsafePointer u;

        using isGoStruct = void;

        template<typename U> requires gocpp::GoStruct<U>
        operator U();

        template<typename U> requires gocpp::GoStruct<U>
        bool operator==(const U& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const struct Pointer<T>& value);

    namespace rec
    {
        int32_t Load(golang::atomic::Int32* i);
        void Store(golang::atomic::Int32* i, int32_t value);
        bool CompareAndSwap(golang::atomic::Int32* i, int32_t old, int32_t go_new);
        int32_t Swap(golang::atomic::Int32* i, int32_t go_new);
        int32_t Add(golang::atomic::Int32* i, int32_t delta);
        int64_t Load(golang::atomic::Int64* i);
        void Store(golang::atomic::Int64* i, int64_t value);
        bool CompareAndSwap(golang::atomic::Int64* i, int64_t old, int64_t go_new);
        int64_t Swap(golang::atomic::Int64* i, int64_t go_new);
        int64_t Add(golang::atomic::Int64* i, int64_t delta);
        uint8_t Load(golang::atomic::Uint8* u);
        void Store(golang::atomic::Uint8* u, uint8_t value);
        void And(golang::atomic::Uint8* u, uint8_t value);
        void Or(golang::atomic::Uint8* u, uint8_t value);
        bool Load(golang::atomic::Bool* b);
        void Store(golang::atomic::Bool* b, bool value);
        uint32_t Load(golang::atomic::Uint32* u);
        uint32_t LoadAcquire(golang::atomic::Uint32* u);
        void Store(golang::atomic::Uint32* u, uint32_t value);
        void StoreRelease(golang::atomic::Uint32* u, uint32_t value);
        bool CompareAndSwap(golang::atomic::Uint32* u, uint32_t old, uint32_t go_new);
        bool CompareAndSwapRelease(golang::atomic::Uint32* u, uint32_t old, uint32_t go_new);
        uint32_t Swap(golang::atomic::Uint32* u, uint32_t value);
        void And(golang::atomic::Uint32* u, uint32_t value);
        void Or(golang::atomic::Uint32* u, uint32_t value);
        uint32_t Add(golang::atomic::Uint32* u, int32_t delta);
        uint64_t Load(golang::atomic::Uint64* u);
        void Store(golang::atomic::Uint64* u, uint64_t value);
        bool CompareAndSwap(golang::atomic::Uint64* u, uint64_t old, uint64_t go_new);
        uint64_t Swap(golang::atomic::Uint64* u, uint64_t value);
        uint64_t Add(golang::atomic::Uint64* u, int64_t delta);
        uintptr_t Load(golang::atomic::Uintptr* u);
        uintptr_t LoadAcquire(golang::atomic::Uintptr* u);
        void Store(golang::atomic::Uintptr* u, uintptr_t value);
        void StoreRelease(golang::atomic::Uintptr* u, uintptr_t value);
        bool CompareAndSwap(golang::atomic::Uintptr* u, uintptr_t old, uintptr_t go_new);
        uintptr_t Swap(golang::atomic::Uintptr* u, uintptr_t value);
        uintptr_t Add(golang::atomic::Uintptr* u, uintptr_t delta);
        double Load(golang::atomic::Float64* f);
        void Store(golang::atomic::Float64* f, double value);
        gocpp::unsafe_pointer Load(golang::atomic::UnsafePointer* u);
        void StoreNoWB(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer value);
        void Store(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer value);
        bool CompareAndSwapNoWB(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer old, gocpp::unsafe_pointer go_new);
        bool CompareAndSwap(golang::atomic::UnsafePointer* u, gocpp::unsafe_pointer old, gocpp::unsafe_pointer go_new);
        
        template<typename T>
        T* Load(golang::atomic::Pointer<T>* p);
        
        template<typename T>
        void StoreNoWB(golang::atomic::Pointer<T>* p, T* value);
        
        template<typename T>
        void Store(golang::atomic::Pointer<T>* p, T* value);
        
        template<typename T>
        bool CompareAndSwapNoWB(golang::atomic::Pointer<T>* p, T* old, T* go_new);
        
        template<typename T>
        bool CompareAndSwap(golang::atomic::Pointer<T>* p, T* old, T* go_new);
        void Lock(golang::atomic::noCopy*);
        void Unlock(golang::atomic::noCopy*);
    }
}

