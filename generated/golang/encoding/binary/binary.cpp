// generated by GoCpp from file '$(ImportDir)/encoding/binary/binary.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/encoding/binary/binary.h"
#include "gocpp/support.h"

#include "golang/encoding/binary/native_endian_little.h"
#include "golang/errors/errors.h"
#include "golang/internal/abi/type.h"
#include "golang/io/io.h"
#include "golang/math/unsafe.h"
#include "golang/reflect/type.h"
#include "golang/reflect/value.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"

namespace golang::binary
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Write;
        using reflect::rec::Bool;
        using reflect::rec::CanSet;
        using reflect::rec::Complex;
        using reflect::rec::Elem;
        using reflect::rec::Field;
        using reflect::rec::Float;
        using reflect::rec::Index;
        using reflect::rec::Int;
        using reflect::rec::IsValid;
        using reflect::rec::Kind;
        using reflect::rec::Len;
        using reflect::rec::NumField;
        using reflect::rec::SetBool;
        using reflect::rec::SetComplex;
        using reflect::rec::SetFloat;
        using reflect::rec::SetInt;
        using reflect::rec::SetUint;
        using reflect::rec::Size;
        using reflect::rec::String;
        using reflect::rec::Type;
        using reflect::rec::Uint;
        using sync::rec::Load;
        using sync::rec::Store;
    }

    
    template<typename T>
    ByteOrder::ByteOrder(T& ref)
    {
        value.reset(new ByteOrderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteOrder::ByteOrder(const T& ref)
    {
        value.reset(new ByteOrderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ByteOrder::ByteOrder(T* ptr)
    {
        value.reset(new ByteOrderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ByteOrder::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint16_t ByteOrder::ByteOrderImpl<T, StoreT>::vUint16(gocpp::slice<unsigned char>)
    {
        return rec::Uint16(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uint32_t ByteOrder::ByteOrderImpl<T, StoreT>::vUint32(gocpp::slice<unsigned char>)
    {
        return rec::Uint32(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uint64_t ByteOrder::ByteOrderImpl<T, StoreT>::vUint64(gocpp::slice<unsigned char>)
    {
        return rec::Uint64(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void ByteOrder::ByteOrderImpl<T, StoreT>::vPutUint16(gocpp::slice<unsigned char>, uint16_t)
    {
        return rec::PutUint16(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void ByteOrder::ByteOrderImpl<T, StoreT>::vPutUint32(gocpp::slice<unsigned char>, uint32_t)
    {
        return rec::PutUint32(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void ByteOrder::ByteOrderImpl<T, StoreT>::vPutUint64(gocpp::slice<unsigned char>, uint64_t)
    {
        return rec::PutUint64(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string ByteOrder::ByteOrderImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        uint16_t Uint16(const gocpp::PtrRecv<struct ByteOrder, false>& self, gocpp::slice<unsigned char>)
        {
            return self.ptr->value->vUint16();
        }

        uint16_t Uint16(const gocpp::ObjRecv<struct ByteOrder>& self, gocpp::slice<unsigned char>)
        {
            return self.obj.value->vUint16();
        }

        uint32_t Uint32(const gocpp::PtrRecv<struct ByteOrder, false>& self, gocpp::slice<unsigned char>)
        {
            return self.ptr->value->vUint32();
        }

        uint32_t Uint32(const gocpp::ObjRecv<struct ByteOrder>& self, gocpp::slice<unsigned char>)
        {
            return self.obj.value->vUint32();
        }

        uint64_t Uint64(const gocpp::PtrRecv<struct ByteOrder, false>& self, gocpp::slice<unsigned char>)
        {
            return self.ptr->value->vUint64();
        }

        uint64_t Uint64(const gocpp::ObjRecv<struct ByteOrder>& self, gocpp::slice<unsigned char>)
        {
            return self.obj.value->vUint64();
        }

        void PutUint16(const gocpp::PtrRecv<struct ByteOrder, false>& self, gocpp::slice<unsigned char>, uint16_t)
        {
            return self.ptr->value->vPutUint16();
        }

        void PutUint16(const gocpp::ObjRecv<struct ByteOrder>& self, gocpp::slice<unsigned char>, uint16_t)
        {
            return self.obj.value->vPutUint16();
        }

        void PutUint32(const gocpp::PtrRecv<struct ByteOrder, false>& self, gocpp::slice<unsigned char>, uint32_t)
        {
            return self.ptr->value->vPutUint32();
        }

        void PutUint32(const gocpp::ObjRecv<struct ByteOrder>& self, gocpp::slice<unsigned char>, uint32_t)
        {
            return self.obj.value->vPutUint32();
        }

        void PutUint64(const gocpp::PtrRecv<struct ByteOrder, false>& self, gocpp::slice<unsigned char>, uint64_t)
        {
            return self.ptr->value->vPutUint64();
        }

        void PutUint64(const gocpp::ObjRecv<struct ByteOrder>& self, gocpp::slice<unsigned char>, uint64_t)
        {
            return self.obj.value->vPutUint64();
        }

        std::string String(const gocpp::PtrRecv<struct ByteOrder, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<struct ByteOrder>& self)
        {
            return self.obj.value->vString();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ByteOrder& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    AppendByteOrder::AppendByteOrder(T& ref)
    {
        value.reset(new AppendByteOrderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    AppendByteOrder::AppendByteOrder(const T& ref)
    {
        value.reset(new AppendByteOrderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    AppendByteOrder::AppendByteOrder(T* ptr)
    {
        value.reset(new AppendByteOrderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& AppendByteOrder::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::slice<unsigned char> AppendByteOrder::AppendByteOrderImpl<T, StoreT>::vAppendUint16(gocpp::slice<unsigned char>, uint16_t)
    {
        return rec::AppendUint16(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    gocpp::slice<unsigned char> AppendByteOrder::AppendByteOrderImpl<T, StoreT>::vAppendUint32(gocpp::slice<unsigned char>, uint32_t)
    {
        return rec::AppendUint32(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    gocpp::slice<unsigned char> AppendByteOrder::AppendByteOrderImpl<T, StoreT>::vAppendUint64(gocpp::slice<unsigned char>, uint64_t)
    {
        return rec::AppendUint64(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string AppendByteOrder::AppendByteOrderImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        gocpp::slice<unsigned char> AppendUint16(const gocpp::PtrRecv<struct AppendByteOrder, false>& self, gocpp::slice<unsigned char>, uint16_t)
        {
            return self.ptr->value->vAppendUint16();
        }

        gocpp::slice<unsigned char> AppendUint16(const gocpp::ObjRecv<struct AppendByteOrder>& self, gocpp::slice<unsigned char>, uint16_t)
        {
            return self.obj.value->vAppendUint16();
        }

        gocpp::slice<unsigned char> AppendUint32(const gocpp::PtrRecv<struct AppendByteOrder, false>& self, gocpp::slice<unsigned char>, uint32_t)
        {
            return self.ptr->value->vAppendUint32();
        }

        gocpp::slice<unsigned char> AppendUint32(const gocpp::ObjRecv<struct AppendByteOrder>& self, gocpp::slice<unsigned char>, uint32_t)
        {
            return self.obj.value->vAppendUint32();
        }

        gocpp::slice<unsigned char> AppendUint64(const gocpp::PtrRecv<struct AppendByteOrder, false>& self, gocpp::slice<unsigned char>, uint64_t)
        {
            return self.ptr->value->vAppendUint64();
        }

        gocpp::slice<unsigned char> AppendUint64(const gocpp::ObjRecv<struct AppendByteOrder>& self, gocpp::slice<unsigned char>, uint64_t)
        {
            return self.obj.value->vAppendUint64();
        }

        std::string String(const gocpp::PtrRecv<struct AppendByteOrder, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<struct AppendByteOrder>& self)
        {
            return self.obj.value->vString();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct AppendByteOrder& value)
    {
        return value.PrintTo(os);
    }

    littleEndian LittleEndian;
    bigEndian BigEndian;
    
    template<typename T> requires gocpp::GoStruct<T>
    littleEndian::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool littleEndian::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& littleEndian::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct littleEndian& value)
    {
        return value.PrintTo(os);
    }

    uint16_t rec::Uint16(littleEndian, gocpp::slice<unsigned char> b)
    {
        _ = b[1];
        return uint16_t(b[0]) | (uint16_t(b[1]) << 8);
    }

    void rec::PutUint16(littleEndian, gocpp::slice<unsigned char> b, uint16_t v)
    {
        _ = b[1];
        b[0] = (unsigned char)(v);
        b[1] = (unsigned char)(v >> 8);
    }

    gocpp::slice<unsigned char> rec::AppendUint16(littleEndian, gocpp::slice<unsigned char> b, uint16_t v)
    {
        return append(b, (unsigned char)(v), (unsigned char)(v >> 8));
    }

    uint32_t rec::Uint32(littleEndian, gocpp::slice<unsigned char> b)
    {
        _ = b[3];
        return uint32_t(b[0]) | (uint32_t(b[1]) << 8) | (uint32_t(b[2]) << 16) | (uint32_t(b[3]) << 24);
    }

    void rec::PutUint32(littleEndian, gocpp::slice<unsigned char> b, uint32_t v)
    {
        _ = b[3];
        b[0] = (unsigned char)(v);
        b[1] = (unsigned char)(v >> 8);
        b[2] = (unsigned char)(v >> 16);
        b[3] = (unsigned char)(v >> 24);
    }

    gocpp::slice<unsigned char> rec::AppendUint32(littleEndian, gocpp::slice<unsigned char> b, uint32_t v)
    {
        return append(b, (unsigned char)(v), (unsigned char)(v >> 8), (unsigned char)(v >> 16), (unsigned char)(v >> 24));
    }

    uint64_t rec::Uint64(littleEndian, gocpp::slice<unsigned char> b)
    {
        _ = b[7];
        return uint64_t(b[0]) | (uint64_t(b[1]) << 8) | (uint64_t(b[2]) << 16) | (uint64_t(b[3]) << 24) | (uint64_t(b[4]) << 32) | (uint64_t(b[5]) << 40) | (uint64_t(b[6]) << 48) | (uint64_t(b[7]) << 56);
    }

    void rec::PutUint64(littleEndian, gocpp::slice<unsigned char> b, uint64_t v)
    {
        _ = b[7];
        b[0] = (unsigned char)(v);
        b[1] = (unsigned char)(v >> 8);
        b[2] = (unsigned char)(v >> 16);
        b[3] = (unsigned char)(v >> 24);
        b[4] = (unsigned char)(v >> 32);
        b[5] = (unsigned char)(v >> 40);
        b[6] = (unsigned char)(v >> 48);
        b[7] = (unsigned char)(v >> 56);
    }

    gocpp::slice<unsigned char> rec::AppendUint64(littleEndian, gocpp::slice<unsigned char> b, uint64_t v)
    {
        return append(b, (unsigned char)(v), (unsigned char)(v >> 8), (unsigned char)(v >> 16), (unsigned char)(v >> 24), (unsigned char)(v >> 32), (unsigned char)(v >> 40), (unsigned char)(v >> 48), (unsigned char)(v >> 56));
    }

    std::string rec::String(littleEndian)
    {
        return "LittleEndian";
    }

    std::string rec::GoString(littleEndian)
    {
        return "binary.LittleEndian";
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    bigEndian::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool bigEndian::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& bigEndian::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct bigEndian& value)
    {
        return value.PrintTo(os);
    }

    uint16_t rec::Uint16(bigEndian, gocpp::slice<unsigned char> b)
    {
        _ = b[1];
        return uint16_t(b[1]) | (uint16_t(b[0]) << 8);
    }

    void rec::PutUint16(bigEndian, gocpp::slice<unsigned char> b, uint16_t v)
    {
        _ = b[1];
        b[0] = (unsigned char)(v >> 8);
        b[1] = (unsigned char)(v);
    }

    gocpp::slice<unsigned char> rec::AppendUint16(bigEndian, gocpp::slice<unsigned char> b, uint16_t v)
    {
        return append(b, (unsigned char)(v >> 8), (unsigned char)(v));
    }

    uint32_t rec::Uint32(bigEndian, gocpp::slice<unsigned char> b)
    {
        _ = b[3];
        return uint32_t(b[3]) | (uint32_t(b[2]) << 8) | (uint32_t(b[1]) << 16) | (uint32_t(b[0]) << 24);
    }

    void rec::PutUint32(bigEndian, gocpp::slice<unsigned char> b, uint32_t v)
    {
        _ = b[3];
        b[0] = (unsigned char)(v >> 24);
        b[1] = (unsigned char)(v >> 16);
        b[2] = (unsigned char)(v >> 8);
        b[3] = (unsigned char)(v);
    }

    gocpp::slice<unsigned char> rec::AppendUint32(bigEndian, gocpp::slice<unsigned char> b, uint32_t v)
    {
        return append(b, (unsigned char)(v >> 24), (unsigned char)(v >> 16), (unsigned char)(v >> 8), (unsigned char)(v));
    }

    uint64_t rec::Uint64(bigEndian, gocpp::slice<unsigned char> b)
    {
        _ = b[7];
        return uint64_t(b[7]) | (uint64_t(b[6]) << 8) | (uint64_t(b[5]) << 16) | (uint64_t(b[4]) << 24) | (uint64_t(b[3]) << 32) | (uint64_t(b[2]) << 40) | (uint64_t(b[1]) << 48) | (uint64_t(b[0]) << 56);
    }

    void rec::PutUint64(bigEndian, gocpp::slice<unsigned char> b, uint64_t v)
    {
        _ = b[7];
        b[0] = (unsigned char)(v >> 56);
        b[1] = (unsigned char)(v >> 48);
        b[2] = (unsigned char)(v >> 40);
        b[3] = (unsigned char)(v >> 32);
        b[4] = (unsigned char)(v >> 24);
        b[5] = (unsigned char)(v >> 16);
        b[6] = (unsigned char)(v >> 8);
        b[7] = (unsigned char)(v);
    }

    gocpp::slice<unsigned char> rec::AppendUint64(bigEndian, gocpp::slice<unsigned char> b, uint64_t v)
    {
        return append(b, (unsigned char)(v >> 56), (unsigned char)(v >> 48), (unsigned char)(v >> 40), (unsigned char)(v >> 32), (unsigned char)(v >> 24), (unsigned char)(v >> 16), (unsigned char)(v >> 8), (unsigned char)(v));
    }

    std::string rec::String(bigEndian)
    {
        return "BigEndian";
    }

    std::string rec::GoString(bigEndian)
    {
        return "binary.BigEndian";
    }

    std::string rec::String(nativeEndian)
    {
        return "NativeEndian";
    }

    std::string rec::GoString(nativeEndian)
    {
        return "binary.NativeEndian";
    }

    struct gocpp::error Read(io::Reader r, struct ByteOrder order, go_any data)
    {
        if(auto n = intDataSize(data); n != 0)
        {
            auto bs = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            if(auto [gocpp_id_1, err] = io::ReadFull(r, bs); err != nullptr)
            {
                return err;
            }
            //Go type switch emulation
            {
                const auto& gocpp_id_2 = gocpp::type_info(data);
                int conditionId = -1;
                if(gocpp_id_2 == typeid(bool*)) { conditionId = 0; }
                else if(gocpp_id_2 == typeid(int8_t*)) { conditionId = 1; }
                else if(gocpp_id_2 == typeid(uint8_t*)) { conditionId = 2; }
                else if(gocpp_id_2 == typeid(int16_t*)) { conditionId = 3; }
                else if(gocpp_id_2 == typeid(uint16_t*)) { conditionId = 4; }
                else if(gocpp_id_2 == typeid(int32_t*)) { conditionId = 5; }
                else if(gocpp_id_2 == typeid(uint32_t*)) { conditionId = 6; }
                else if(gocpp_id_2 == typeid(int64_t*)) { conditionId = 7; }
                else if(gocpp_id_2 == typeid(uint64_t*)) { conditionId = 8; }
                else if(gocpp_id_2 == typeid(float*)) { conditionId = 9; }
                else if(gocpp_id_2 == typeid(double*)) { conditionId = 10; }
                else if(gocpp_id_2 == typeid(gocpp::slice<bool>)) { conditionId = 11; }
                else if(gocpp_id_2 == typeid(gocpp::slice<int8_t>)) { conditionId = 12; }
                else if(gocpp_id_2 == typeid(gocpp::slice<uint8_t>)) { conditionId = 13; }
                else if(gocpp_id_2 == typeid(gocpp::slice<int16_t>)) { conditionId = 14; }
                else if(gocpp_id_2 == typeid(gocpp::slice<uint16_t>)) { conditionId = 15; }
                else if(gocpp_id_2 == typeid(gocpp::slice<int32_t>)) { conditionId = 16; }
                else if(gocpp_id_2 == typeid(gocpp::slice<uint32_t>)) { conditionId = 17; }
                else if(gocpp_id_2 == typeid(gocpp::slice<int64_t>)) { conditionId = 18; }
                else if(gocpp_id_2 == typeid(gocpp::slice<uint64_t>)) { conditionId = 19; }
                else if(gocpp_id_2 == typeid(gocpp::slice<float>)) { conditionId = 20; }
                else if(gocpp_id_2 == typeid(gocpp::slice<double>)) { conditionId = 21; }
                switch(conditionId)
                {
                    case 0:
                    {
                        bool* data = gocpp::any_cast<bool*>(data);
                        *data = bs[0] != 0;
                        break;
                    }
                    case 1:
                    {
                        int8_t* data = gocpp::any_cast<int8_t*>(data);
                        *data = int8_t(bs[0]);
                        break;
                    }
                    case 2:
                    {
                        uint8_t* data = gocpp::any_cast<uint8_t*>(data);
                        *data = bs[0];
                        break;
                    }
                    case 3:
                    {
                        int16_t* data = gocpp::any_cast<int16_t*>(data);
                        *data = int16_t(rec::Uint16(gocpp::recv(order), bs));
                        break;
                    }
                    case 4:
                    {
                        uint16_t* data = gocpp::any_cast<uint16_t*>(data);
                        *data = rec::Uint16(gocpp::recv(order), bs);
                        break;
                    }
                    case 5:
                    {
                        int32_t* data = gocpp::any_cast<int32_t*>(data);
                        *data = int32_t(rec::Uint32(gocpp::recv(order), bs));
                        break;
                    }
                    case 6:
                    {
                        uint32_t* data = gocpp::any_cast<uint32_t*>(data);
                        *data = rec::Uint32(gocpp::recv(order), bs);
                        break;
                    }
                    case 7:
                    {
                        int64_t* data = gocpp::any_cast<int64_t*>(data);
                        *data = int64_t(rec::Uint64(gocpp::recv(order), bs));
                        break;
                    }
                    case 8:
                    {
                        uint64_t* data = gocpp::any_cast<uint64_t*>(data);
                        *data = rec::Uint64(gocpp::recv(order), bs);
                        break;
                    }
                    case 9:
                    {
                        float* data = gocpp::any_cast<float*>(data);
                        *data = math::Float32frombits(rec::Uint32(gocpp::recv(order), bs));
                        break;
                    }
                    case 10:
                    {
                        double* data = gocpp::any_cast<double*>(data);
                        *data = math::Float64frombits(rec::Uint64(gocpp::recv(order), bs));
                        break;
                    }
                    case 11:
                    {
                        gocpp::slice<bool> data = gocpp::any_cast<gocpp::slice<bool>>(data);
                        for(auto [i, x] : bs)
                        {
                            data[i] = x != 0;
                        }
                        break;
                    }
                    case 12:
                    {
                        gocpp::slice<int8_t> data = gocpp::any_cast<gocpp::slice<int8_t>>(data);
                        for(auto [i, x] : bs)
                        {
                            data[i] = int8_t(x);
                        }
                        break;
                    }
                    case 13:
                    {
                        gocpp::slice<uint8_t> data = gocpp::any_cast<gocpp::slice<uint8_t>>(data);
                        copy(data, bs);
                        break;
                    }
                    case 14:
                    {
                        gocpp::slice<int16_t> data = gocpp::any_cast<gocpp::slice<int16_t>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = int16_t(rec::Uint16(gocpp::recv(order), bs.make_slice(2 * i)));
                        }
                        break;
                    }
                    case 15:
                    {
                        gocpp::slice<uint16_t> data = gocpp::any_cast<gocpp::slice<uint16_t>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = rec::Uint16(gocpp::recv(order), bs.make_slice(2 * i));
                        }
                        break;
                    }
                    case 16:
                    {
                        gocpp::slice<int32_t> data = gocpp::any_cast<gocpp::slice<int32_t>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = int32_t(rec::Uint32(gocpp::recv(order), bs.make_slice(4 * i)));
                        }
                        break;
                    }
                    case 17:
                    {
                        gocpp::slice<uint32_t> data = gocpp::any_cast<gocpp::slice<uint32_t>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = rec::Uint32(gocpp::recv(order), bs.make_slice(4 * i));
                        }
                        break;
                    }
                    case 18:
                    {
                        gocpp::slice<int64_t> data = gocpp::any_cast<gocpp::slice<int64_t>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = int64_t(rec::Uint64(gocpp::recv(order), bs.make_slice(8 * i)));
                        }
                        break;
                    }
                    case 19:
                    {
                        gocpp::slice<uint64_t> data = gocpp::any_cast<gocpp::slice<uint64_t>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = rec::Uint64(gocpp::recv(order), bs.make_slice(8 * i));
                        }
                        break;
                    }
                    case 20:
                    {
                        gocpp::slice<float> data = gocpp::any_cast<gocpp::slice<float>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = math::Float32frombits(rec::Uint32(gocpp::recv(order), bs.make_slice(4 * i)));
                        }
                        break;
                    }
                    case 21:
                    {
                        gocpp::slice<double> data = gocpp::any_cast<gocpp::slice<double>>(data);
                        for(auto [i, gocpp_ignored] : data)
                        {
                            data[i] = math::Float64frombits(rec::Uint64(gocpp::recv(order), bs.make_slice(8 * i)));
                        }
                        break;
                    }
                    default:
                    {
                        auto data = data;
                        n = 0;
                        break;
                    }
                }
            }
            if(n != 0)
            {
                return nullptr;
            }
        }
        auto v = reflect::ValueOf(data);
        auto size = - 1;
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == reflect::Pointer) { conditionId = 0; }
            else if(condition == reflect::Slice) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    v = rec::Elem(gocpp::recv(v));
                    size = dataSize(v);
                    break;
                case 1:
                    size = dataSize(v);
                    break;
            }
        }
        if(size < 0)
        {
            return errors::New("binary.Read: invalid type " + rec::String(gocpp::recv(reflect::TypeOf(data))));
        }
        auto d = gocpp::InitPtr<decoder>([=](auto& x) {
            x.order = order;
            x.buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        });
        if(auto [gocpp_id_4, err] = io::ReadFull(r, d->buf); err != nullptr)
        {
            return err;
        }
        rec::value(gocpp::recv(d), v);
        return nullptr;
    }

    struct gocpp::error Write(io::Writer w, struct ByteOrder order, go_any data)
    {
        if(auto n = intDataSize(data); n != 0)
        {
            auto bs = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            //Go type switch emulation
            {
                const auto& gocpp_id_5 = gocpp::type_info(data);
                int conditionId = -1;
                if(gocpp_id_5 == typeid(bool*)) { conditionId = 0; }
                else if(gocpp_id_5 == typeid(bool)) { conditionId = 1; }
                else if(gocpp_id_5 == typeid(gocpp::slice<bool>)) { conditionId = 2; }
                else if(gocpp_id_5 == typeid(int8_t*)) { conditionId = 3; }
                else if(gocpp_id_5 == typeid(int8_t)) { conditionId = 4; }
                else if(gocpp_id_5 == typeid(gocpp::slice<int8_t>)) { conditionId = 5; }
                else if(gocpp_id_5 == typeid(uint8_t*)) { conditionId = 6; }
                else if(gocpp_id_5 == typeid(uint8_t)) { conditionId = 7; }
                else if(gocpp_id_5 == typeid(gocpp::slice<uint8_t>)) { conditionId = 8; }
                else if(gocpp_id_5 == typeid(int16_t*)) { conditionId = 9; }
                else if(gocpp_id_5 == typeid(int16_t)) { conditionId = 10; }
                else if(gocpp_id_5 == typeid(gocpp::slice<int16_t>)) { conditionId = 11; }
                else if(gocpp_id_5 == typeid(uint16_t*)) { conditionId = 12; }
                else if(gocpp_id_5 == typeid(uint16_t)) { conditionId = 13; }
                else if(gocpp_id_5 == typeid(gocpp::slice<uint16_t>)) { conditionId = 14; }
                else if(gocpp_id_5 == typeid(int32_t*)) { conditionId = 15; }
                else if(gocpp_id_5 == typeid(int32_t)) { conditionId = 16; }
                else if(gocpp_id_5 == typeid(gocpp::slice<int32_t>)) { conditionId = 17; }
                else if(gocpp_id_5 == typeid(uint32_t*)) { conditionId = 18; }
                else if(gocpp_id_5 == typeid(uint32_t)) { conditionId = 19; }
                else if(gocpp_id_5 == typeid(gocpp::slice<uint32_t>)) { conditionId = 20; }
                else if(gocpp_id_5 == typeid(int64_t*)) { conditionId = 21; }
                else if(gocpp_id_5 == typeid(int64_t)) { conditionId = 22; }
                else if(gocpp_id_5 == typeid(gocpp::slice<int64_t>)) { conditionId = 23; }
                else if(gocpp_id_5 == typeid(uint64_t*)) { conditionId = 24; }
                else if(gocpp_id_5 == typeid(uint64_t)) { conditionId = 25; }
                else if(gocpp_id_5 == typeid(gocpp::slice<uint64_t>)) { conditionId = 26; }
                else if(gocpp_id_5 == typeid(float*)) { conditionId = 27; }
                else if(gocpp_id_5 == typeid(float)) { conditionId = 28; }
                else if(gocpp_id_5 == typeid(gocpp::slice<float>)) { conditionId = 29; }
                else if(gocpp_id_5 == typeid(double*)) { conditionId = 30; }
                else if(gocpp_id_5 == typeid(double)) { conditionId = 31; }
                else if(gocpp_id_5 == typeid(gocpp::slice<double>)) { conditionId = 32; }
                switch(conditionId)
                {
                    case 0:
                    {
                        bool* v = gocpp::any_cast<bool*>(data);
                        if(*v)
                        {
                            bs[0] = 1;
                        }
                        else
                        {
                            bs[0] = 0;
                        }
                        break;
                    }
                    case 1:
                    {
                        bool v = gocpp::any_cast<bool>(data);
                        if(v)
                        {
                            bs[0] = 1;
                        }
                        else
                        {
                            bs[0] = 0;
                        }
                        break;
                    }
                    case 2:
                    {
                        gocpp::slice<bool> v = gocpp::any_cast<gocpp::slice<bool>>(data);
                        for(auto [i, x] : v)
                        {
                            if(x)
                            {
                                bs[i] = 1;
                            }
                            else
                            {
                                bs[i] = 0;
                            }
                        }
                        break;
                    }
                    case 3:
                    {
                        int8_t* v = gocpp::any_cast<int8_t*>(data);
                        bs[0] = (unsigned char)(*v);
                        break;
                    }
                    case 4:
                    {
                        int8_t v = gocpp::any_cast<int8_t>(data);
                        bs[0] = (unsigned char)(v);
                        break;
                    }
                    case 5:
                    {
                        gocpp::slice<int8_t> v = gocpp::any_cast<gocpp::slice<int8_t>>(data);
                        for(auto [i, x] : v)
                        {
                            bs[i] = (unsigned char)(x);
                        }
                        break;
                    }
                    case 6:
                    {
                        uint8_t* v = gocpp::any_cast<uint8_t*>(data);
                        bs[0] = *v;
                        break;
                    }
                    case 7:
                    {
                        uint8_t v = gocpp::any_cast<uint8_t>(data);
                        bs[0] = v;
                        break;
                    }
                    case 8:
                    {
                        gocpp::slice<uint8_t> v = gocpp::any_cast<gocpp::slice<uint8_t>>(data);
                        bs = v;
                        break;
                    }
                    case 9:
                    {
                        int16_t* v = gocpp::any_cast<int16_t*>(data);
                        rec::PutUint16(gocpp::recv(order), bs, uint16_t(*v));
                        break;
                    }
                    case 10:
                    {
                        int16_t v = gocpp::any_cast<int16_t>(data);
                        rec::PutUint16(gocpp::recv(order), bs, uint16_t(v));
                        break;
                    }
                    case 11:
                    {
                        gocpp::slice<int16_t> v = gocpp::any_cast<gocpp::slice<int16_t>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint16(gocpp::recv(order), bs.make_slice(2 * i), uint16_t(x));
                        }
                        break;
                    }
                    case 12:
                    {
                        uint16_t* v = gocpp::any_cast<uint16_t*>(data);
                        rec::PutUint16(gocpp::recv(order), bs, *v);
                        break;
                    }
                    case 13:
                    {
                        uint16_t v = gocpp::any_cast<uint16_t>(data);
                        rec::PutUint16(gocpp::recv(order), bs, v);
                        break;
                    }
                    case 14:
                    {
                        gocpp::slice<uint16_t> v = gocpp::any_cast<gocpp::slice<uint16_t>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint16(gocpp::recv(order), bs.make_slice(2 * i), x);
                        }
                        break;
                    }
                    case 15:
                    {
                        int32_t* v = gocpp::any_cast<int32_t*>(data);
                        rec::PutUint32(gocpp::recv(order), bs, uint32_t(*v));
                        break;
                    }
                    case 16:
                    {
                        int32_t v = gocpp::any_cast<int32_t>(data);
                        rec::PutUint32(gocpp::recv(order), bs, uint32_t(v));
                        break;
                    }
                    case 17:
                    {
                        gocpp::slice<int32_t> v = gocpp::any_cast<gocpp::slice<int32_t>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint32(gocpp::recv(order), bs.make_slice(4 * i), uint32_t(x));
                        }
                        break;
                    }
                    case 18:
                    {
                        uint32_t* v = gocpp::any_cast<uint32_t*>(data);
                        rec::PutUint32(gocpp::recv(order), bs, *v);
                        break;
                    }
                    case 19:
                    {
                        uint32_t v = gocpp::any_cast<uint32_t>(data);
                        rec::PutUint32(gocpp::recv(order), bs, v);
                        break;
                    }
                    case 20:
                    {
                        gocpp::slice<uint32_t> v = gocpp::any_cast<gocpp::slice<uint32_t>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint32(gocpp::recv(order), bs.make_slice(4 * i), x);
                        }
                        break;
                    }
                    case 21:
                    {
                        int64_t* v = gocpp::any_cast<int64_t*>(data);
                        rec::PutUint64(gocpp::recv(order), bs, uint64_t(*v));
                        break;
                    }
                    case 22:
                    {
                        int64_t v = gocpp::any_cast<int64_t>(data);
                        rec::PutUint64(gocpp::recv(order), bs, uint64_t(v));
                        break;
                    }
                    case 23:
                    {
                        gocpp::slice<int64_t> v = gocpp::any_cast<gocpp::slice<int64_t>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint64(gocpp::recv(order), bs.make_slice(8 * i), uint64_t(x));
                        }
                        break;
                    }
                    case 24:
                    {
                        uint64_t* v = gocpp::any_cast<uint64_t*>(data);
                        rec::PutUint64(gocpp::recv(order), bs, *v);
                        break;
                    }
                    case 25:
                    {
                        uint64_t v = gocpp::any_cast<uint64_t>(data);
                        rec::PutUint64(gocpp::recv(order), bs, v);
                        break;
                    }
                    case 26:
                    {
                        gocpp::slice<uint64_t> v = gocpp::any_cast<gocpp::slice<uint64_t>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint64(gocpp::recv(order), bs.make_slice(8 * i), x);
                        }
                        break;
                    }
                    case 27:
                    {
                        float* v = gocpp::any_cast<float*>(data);
                        rec::PutUint32(gocpp::recv(order), bs, math::Float32bits(*v));
                        break;
                    }
                    case 28:
                    {
                        float v = gocpp::any_cast<float>(data);
                        rec::PutUint32(gocpp::recv(order), bs, math::Float32bits(v));
                        break;
                    }
                    case 29:
                    {
                        gocpp::slice<float> v = gocpp::any_cast<gocpp::slice<float>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint32(gocpp::recv(order), bs.make_slice(4 * i), math::Float32bits(x));
                        }
                        break;
                    }
                    case 30:
                    {
                        double* v = gocpp::any_cast<double*>(data);
                        rec::PutUint64(gocpp::recv(order), bs, math::Float64bits(*v));
                        break;
                    }
                    case 31:
                    {
                        double v = gocpp::any_cast<double>(data);
                        rec::PutUint64(gocpp::recv(order), bs, math::Float64bits(v));
                        break;
                    }
                    case 32:
                    {
                        gocpp::slice<double> v = gocpp::any_cast<gocpp::slice<double>>(data);
                        for(auto [i, x] : v)
                        {
                            rec::PutUint64(gocpp::recv(order), bs.make_slice(8 * i), math::Float64bits(x));
                        }
                        break;
                    }
                }
            }
            auto [gocpp_id_7, err] = rec::Write(gocpp::recv(w), bs);
            return err;
        }
        auto v = reflect::Indirect(reflect::ValueOf(data));
        auto size = dataSize(v);
        if(size < 0)
        {
            return errors::New("binary.Write: some values are not fixed-sized in type " + rec::String(gocpp::recv(reflect::TypeOf(data))));
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        auto e = gocpp::InitPtr<encoder>([=](auto& x) {
            x.order = order;
            x.buf = buf;
        });
        rec::value(gocpp::recv(e), v);
        auto [gocpp_id_9, err] = rec::Write(gocpp::recv(w), buf);
        return err;
    }

    int Size(go_any v)
    {
        return dataSize(reflect::Indirect(reflect::ValueOf(v)));
    }

    sync::Map structSize;
    int dataSize(reflect::Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == reflect::Slice) { conditionId = 0; }
            else if(condition == reflect::Struct) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(auto s = sizeof(rec::Elem(gocpp::recv(rec::Type(gocpp::recv(v))))); s >= 0)
                    {
                        return s * rec::Len(gocpp::recv(v));
                    }
                    break;
                case 1:
                    auto t = rec::Type(gocpp::recv(v));
                    if(auto [size, ok] = rec::Load(gocpp::recv(structSize), t); ok)
                    {
                        return gocpp::getValue<int>(size);
                    }
                    auto size = sizeof(t);
                    rec::Store(gocpp::recv(structSize), t, size);
                    return size;
                    break;
                default:
                    if(rec::IsValid(gocpp::recv(v)))
                    {
                        return sizeof(rec::Type(gocpp::recv(v)));
                    }
                    break;
            }
        }
        return - 1;
    }

    int sizeof(reflect::Type t)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == reflect::Array) { conditionId = 0; }
            else if(condition == reflect::Struct) { conditionId = 1; }
            else if(condition == reflect::Bool) { conditionId = 2; }
            else if(condition == reflect::Uint8) { conditionId = 3; }
            else if(condition == reflect::Uint16) { conditionId = 4; }
            else if(condition == reflect::Uint32) { conditionId = 5; }
            else if(condition == reflect::Uint64) { conditionId = 6; }
            else if(condition == reflect::Int8) { conditionId = 7; }
            else if(condition == reflect::Int16) { conditionId = 8; }
            else if(condition == reflect::Int32) { conditionId = 9; }
            else if(condition == reflect::Int64) { conditionId = 10; }
            else if(condition == reflect::Float32) { conditionId = 11; }
            else if(condition == reflect::Float64) { conditionId = 12; }
            else if(condition == reflect::Complex64) { conditionId = 13; }
            else if(condition == reflect::Complex128) { conditionId = 14; }
            switch(conditionId)
            {
                case 0:
                    if(auto s = sizeof(rec::Elem(gocpp::recv(t))); s >= 0)
                    {
                        return s * rec::Len(gocpp::recv(t));
                    }
                    break;
                case 1:
                    auto sum = 0;
                    for(auto [i, n] = std::tuple{0, rec::NumField(gocpp::recv(t))}; i < n; i++)
                    {
                        auto s = sizeof(rec::Field(gocpp::recv(t), i).Type);
                        if(s < 0)
                        {
                            return - 1;
                        }
                        sum += s;
                    }
                    return sum;
                    break;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    return int(rec::Size(gocpp::recv(t)));
                    break;
            }
        }
        return - 1;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    coder::operator T()
    {
        T result;
        result.order = this->order;
        result.buf = this->buf;
        result.offset = this->offset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool coder::operator==(const T& ref) const
    {
        if (order != ref.order) return false;
        if (buf != ref.buf) return false;
        if (offset != ref.offset) return false;
        return true;
    }

    std::ostream& coder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << order;
        os << " " << buf;
        os << " " << offset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct coder& value)
    {
        return value.PrintTo(os);
    }

    bool rec::bool(golang::binary::decoder* d)
    {
        auto x = d->buf[d->offset];
        d->offset++;
        return x != 0;
    }

    void rec::bool(golang::binary::encoder* e, bool x)
    {
        if(x)
        {
            e->buf[e->offset] = 1;
        }
        else
        {
            e->buf[e->offset] = 0;
        }
        e->offset++;
    }

    uint8_t rec::uint8(golang::binary::decoder* d)
    {
        auto x = d->buf[d->offset];
        d->offset++;
        return x;
    }

    void rec::uint8(golang::binary::encoder* e, uint8_t x)
    {
        e->buf[e->offset] = x;
        e->offset++;
    }

    uint16_t rec::uint16(golang::binary::decoder* d)
    {
        auto x = rec::Uint16(gocpp::recv(d->order), d->buf.make_slice(d->offset, d->offset + 2));
        d->offset += 2;
        return x;
    }

    void rec::uint16(golang::binary::encoder* e, uint16_t x)
    {
        rec::PutUint16(gocpp::recv(e->order), e->buf.make_slice(e->offset, e->offset + 2), x);
        e->offset += 2;
    }

    uint32_t rec::uint32(golang::binary::decoder* d)
    {
        auto x = rec::Uint32(gocpp::recv(d->order), d->buf.make_slice(d->offset, d->offset + 4));
        d->offset += 4;
        return x;
    }

    void rec::uint32(golang::binary::encoder* e, uint32_t x)
    {
        rec::PutUint32(gocpp::recv(e->order), e->buf.make_slice(e->offset, e->offset + 4), x);
        e->offset += 4;
    }

    uint64_t rec::uint64(golang::binary::decoder* d)
    {
        auto x = rec::Uint64(gocpp::recv(d->order), d->buf.make_slice(d->offset, d->offset + 8));
        d->offset += 8;
        return x;
    }

    void rec::uint64(golang::binary::encoder* e, uint64_t x)
    {
        rec::PutUint64(gocpp::recv(e->order), e->buf.make_slice(e->offset, e->offset + 8), x);
        e->offset += 8;
    }

    int8_t rec::int8(golang::binary::decoder* d)
    {
        return int8_t(rec::uint8(gocpp::recv(d)));
    }

    void rec::int8(golang::binary::encoder* e, int8_t x)
    {
        rec::uint8(gocpp::recv(e), uint8_t(x));
    }

    int16_t rec::int16(golang::binary::decoder* d)
    {
        return int16_t(rec::uint16(gocpp::recv(d)));
    }

    void rec::int16(golang::binary::encoder* e, int16_t x)
    {
        rec::uint16(gocpp::recv(e), uint16_t(x));
    }

    int32_t rec::int32(golang::binary::decoder* d)
    {
        return int32_t(rec::uint32(gocpp::recv(d)));
    }

    void rec::int32(golang::binary::encoder* e, int32_t x)
    {
        rec::uint32(gocpp::recv(e), uint32_t(x));
    }

    int64_t rec::int64(golang::binary::decoder* d)
    {
        return int64_t(rec::uint64(gocpp::recv(d)));
    }

    void rec::int64(golang::binary::encoder* e, int64_t x)
    {
        rec::uint64(gocpp::recv(e), uint64_t(x));
    }

    void rec::value(golang::binary::decoder* d, reflect::Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == reflect::Array) { conditionId = 0; }
            else if(condition == reflect::Struct) { conditionId = 1; }
            else if(condition == reflect::Slice) { conditionId = 2; }
            else if(condition == reflect::Bool) { conditionId = 3; }
            else if(condition == reflect::Int8) { conditionId = 4; }
            else if(condition == reflect::Int16) { conditionId = 5; }
            else if(condition == reflect::Int32) { conditionId = 6; }
            else if(condition == reflect::Int64) { conditionId = 7; }
            else if(condition == reflect::Uint8) { conditionId = 8; }
            else if(condition == reflect::Uint16) { conditionId = 9; }
            else if(condition == reflect::Uint32) { conditionId = 10; }
            else if(condition == reflect::Uint64) { conditionId = 11; }
            else if(condition == reflect::Float32) { conditionId = 12; }
            else if(condition == reflect::Float64) { conditionId = 13; }
            else if(condition == reflect::Complex64) { conditionId = 14; }
            else if(condition == reflect::Complex128) { conditionId = 15; }
            switch(conditionId)
            {
                case 0:
                    auto l = rec::Len(gocpp::recv(v));
                    for(auto i = 0; i < l; i++)
                    {
                        rec::value(gocpp::recv(d), rec::Index(gocpp::recv(v), i));
                    }
                    break;
                case 1:
                    auto t = rec::Type(gocpp::recv(v));
                    auto l = rec::NumField(gocpp::recv(v));
                    for(auto i = 0; i < l; i++)
                    {
                        if(auto v = rec::Field(gocpp::recv(v), i); rec::CanSet(gocpp::recv(v)) || rec::Field(gocpp::recv(t), i).Name != "_")
                        {
                            rec::value(gocpp::recv(d), v);
                        }
                        else
                        {
                            rec::skip(gocpp::recv(d), v);
                        }
                    }
                    break;
                case 2:
                    auto l = rec::Len(gocpp::recv(v));
                    for(auto i = 0; i < l; i++)
                    {
                        rec::value(gocpp::recv(d), rec::Index(gocpp::recv(v), i));
                    }
                    break;
                case 3:
                    rec::SetBool(gocpp::recv(v), rec::bool(gocpp::recv(d)));
                    break;
                case 4:
                    rec::SetInt(gocpp::recv(v), int64_t(rec::int8(gocpp::recv(d))));
                    break;
                case 5:
                    rec::SetInt(gocpp::recv(v), int64_t(rec::int16(gocpp::recv(d))));
                    break;
                case 6:
                    rec::SetInt(gocpp::recv(v), int64_t(rec::int32(gocpp::recv(d))));
                    break;
                case 7:
                    rec::SetInt(gocpp::recv(v), rec::int64(gocpp::recv(d)));
                    break;
                case 8:
                    rec::SetUint(gocpp::recv(v), uint64_t(rec::uint8(gocpp::recv(d))));
                    break;
                case 9:
                    rec::SetUint(gocpp::recv(v), uint64_t(rec::uint16(gocpp::recv(d))));
                    break;
                case 10:
                    rec::SetUint(gocpp::recv(v), uint64_t(rec::uint32(gocpp::recv(d))));
                    break;
                case 11:
                    rec::SetUint(gocpp::recv(v), rec::uint64(gocpp::recv(d)));
                    break;
                case 12:
                    rec::SetFloat(gocpp::recv(v), double(math::Float32frombits(rec::uint32(gocpp::recv(d)))));
                    break;
                case 13:
                    rec::SetFloat(gocpp::recv(v), math::Float64frombits(rec::uint64(gocpp::recv(d))));
                    break;
                case 14:
                    rec::SetComplex(gocpp::recv(v), complex(double(math::Float32frombits(rec::uint32(gocpp::recv(d)))), double(math::Float32frombits(rec::uint32(gocpp::recv(d))))));
                    break;
                case 15:
                    rec::SetComplex(gocpp::recv(v), complex(math::Float64frombits(rec::uint64(gocpp::recv(d))), math::Float64frombits(rec::uint64(gocpp::recv(d)))));
                    break;
            }
        }
    }

    void rec::value(golang::binary::encoder* e, reflect::Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == reflect::Array) { conditionId = 0; }
            else if(condition == reflect::Struct) { conditionId = 1; }
            else if(condition == reflect::Slice) { conditionId = 2; }
            else if(condition == reflect::Bool) { conditionId = 3; }
            else if(condition == reflect::Int) { conditionId = 4; }
            else if(condition == reflect::Int8) { conditionId = 5; }
            else if(condition == reflect::Int16) { conditionId = 6; }
            else if(condition == reflect::Int32) { conditionId = 7; }
            else if(condition == reflect::Int64) { conditionId = 8; }
            else if(condition == reflect::Uint) { conditionId = 9; }
            else if(condition == reflect::Uint8) { conditionId = 10; }
            else if(condition == reflect::Uint16) { conditionId = 11; }
            else if(condition == reflect::Uint32) { conditionId = 12; }
            else if(condition == reflect::Uint64) { conditionId = 13; }
            else if(condition == reflect::Uintptr) { conditionId = 14; }
            else if(condition == reflect::Float32) { conditionId = 15; }
            else if(condition == reflect::Float64) { conditionId = 16; }
            else if(condition == reflect::Complex64) { conditionId = 17; }
            else if(condition == reflect::Complex128) { conditionId = 18; }
            switch(conditionId)
            {
                case 0:
                    auto l = rec::Len(gocpp::recv(v));
                    for(auto i = 0; i < l; i++)
                    {
                        rec::value(gocpp::recv(e), rec::Index(gocpp::recv(v), i));
                    }
                    break;
                case 1:
                    auto t = rec::Type(gocpp::recv(v));
                    auto l = rec::NumField(gocpp::recv(v));
                    for(auto i = 0; i < l; i++)
                    {
                        if(auto v = rec::Field(gocpp::recv(v), i); rec::CanSet(gocpp::recv(v)) || rec::Field(gocpp::recv(t), i).Name != "_")
                        {
                            rec::value(gocpp::recv(e), v);
                        }
                        else
                        {
                            rec::skip(gocpp::recv(e), v);
                        }
                    }
                    break;
                case 2:
                    auto l = rec::Len(gocpp::recv(v));
                    for(auto i = 0; i < l; i++)
                    {
                        rec::value(gocpp::recv(e), rec::Index(gocpp::recv(v), i));
                    }
                    break;
                case 3:
                    rec::bool(gocpp::recv(e), rec::Bool(gocpp::recv(v)));
                    break;
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    //Go switch emulation
                    {
                        auto condition = rec::Kind(gocpp::recv(rec::Type(gocpp::recv(v))));
                        int conditionId = -1;
                        if(condition == reflect::Int8) { conditionId = 0; }
                        else if(condition == reflect::Int16) { conditionId = 1; }
                        else if(condition == reflect::Int32) { conditionId = 2; }
                        else if(condition == reflect::Int64) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                rec::int8(gocpp::recv(e), int8_t(rec::Int(gocpp::recv(v))));
                                break;
                            case 1:
                                rec::int16(gocpp::recv(e), int16_t(rec::Int(gocpp::recv(v))));
                                break;
                            case 2:
                                rec::int32(gocpp::recv(e), int32_t(rec::Int(gocpp::recv(v))));
                                break;
                            case 3:
                                rec::int64(gocpp::recv(e), rec::Int(gocpp::recv(v)));
                                break;
                        }
                    }
                    break;
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    //Go switch emulation
                    {
                        auto condition = rec::Kind(gocpp::recv(rec::Type(gocpp::recv(v))));
                        int conditionId = -1;
                        if(condition == reflect::Uint8) { conditionId = 0; }
                        else if(condition == reflect::Uint16) { conditionId = 1; }
                        else if(condition == reflect::Uint32) { conditionId = 2; }
                        else if(condition == reflect::Uint64) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                rec::uint8(gocpp::recv(e), uint8_t(rec::Uint(gocpp::recv(v))));
                                break;
                            case 1:
                                rec::uint16(gocpp::recv(e), uint16_t(rec::Uint(gocpp::recv(v))));
                                break;
                            case 2:
                                rec::uint32(gocpp::recv(e), uint32_t(rec::Uint(gocpp::recv(v))));
                                break;
                            case 3:
                                rec::uint64(gocpp::recv(e), rec::Uint(gocpp::recv(v)));
                                break;
                        }
                    }
                    break;
                case 15:
                case 16:
                    //Go switch emulation
                    {
                        auto condition = rec::Kind(gocpp::recv(rec::Type(gocpp::recv(v))));
                        int conditionId = -1;
                        if(condition == reflect::Float32) { conditionId = 0; }
                        else if(condition == reflect::Float64) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                rec::uint32(gocpp::recv(e), math::Float32bits(float(rec::Float(gocpp::recv(v)))));
                                break;
                            case 1:
                                rec::uint64(gocpp::recv(e), math::Float64bits(rec::Float(gocpp::recv(v))));
                                break;
                        }
                    }
                    break;
                case 17:
                case 18:
                    //Go switch emulation
                    {
                        auto condition = rec::Kind(gocpp::recv(rec::Type(gocpp::recv(v))));
                        int conditionId = -1;
                        if(condition == reflect::Complex64) { conditionId = 0; }
                        else if(condition == reflect::Complex128) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                auto x = rec::Complex(gocpp::recv(v));
                                rec::uint32(gocpp::recv(e), math::Float32bits(float(real(x))));
                                rec::uint32(gocpp::recv(e), math::Float32bits(float(imag(x))));
                                break;
                            case 1:
                                auto x = rec::Complex(gocpp::recv(v));
                                rec::uint64(gocpp::recv(e), math::Float64bits(real(x)));
                                rec::uint64(gocpp::recv(e), math::Float64bits(imag(x)));
                                break;
                        }
                    }
                    break;
            }
        }
    }

    void rec::skip(golang::binary::decoder* d, reflect::Value v)
    {
        d->offset += dataSize(v);
    }

    void rec::skip(golang::binary::encoder* e, reflect::Value v)
    {
        auto n = dataSize(v);
        auto zero = e->buf.make_slice(e->offset, e->offset + n);
        for(auto [i, gocpp_ignored] : zero)
        {
            zero[i] = 0;
        }
        e->offset += n;
    }

    int intDataSize(go_any data)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_10 = gocpp::type_info(data);
            int conditionId = -1;
            if(gocpp_id_10 == typeid(bool)) { conditionId = 0; }
            else if(gocpp_id_10 == typeid(int8_t)) { conditionId = 1; }
            else if(gocpp_id_10 == typeid(uint8_t)) { conditionId = 2; }
            else if(gocpp_id_10 == typeid(bool*)) { conditionId = 3; }
            else if(gocpp_id_10 == typeid(int8_t*)) { conditionId = 4; }
            else if(gocpp_id_10 == typeid(uint8_t*)) { conditionId = 5; }
            else if(gocpp_id_10 == typeid(gocpp::slice<bool>)) { conditionId = 6; }
            else if(gocpp_id_10 == typeid(gocpp::slice<int8_t>)) { conditionId = 7; }
            else if(gocpp_id_10 == typeid(gocpp::slice<uint8_t>)) { conditionId = 8; }
            else if(gocpp_id_10 == typeid(int16_t)) { conditionId = 9; }
            else if(gocpp_id_10 == typeid(uint16_t)) { conditionId = 10; }
            else if(gocpp_id_10 == typeid(int16_t*)) { conditionId = 11; }
            else if(gocpp_id_10 == typeid(uint16_t*)) { conditionId = 12; }
            else if(gocpp_id_10 == typeid(gocpp::slice<int16_t>)) { conditionId = 13; }
            else if(gocpp_id_10 == typeid(gocpp::slice<uint16_t>)) { conditionId = 14; }
            else if(gocpp_id_10 == typeid(int32_t)) { conditionId = 15; }
            else if(gocpp_id_10 == typeid(uint32_t)) { conditionId = 16; }
            else if(gocpp_id_10 == typeid(int32_t*)) { conditionId = 17; }
            else if(gocpp_id_10 == typeid(uint32_t*)) { conditionId = 18; }
            else if(gocpp_id_10 == typeid(gocpp::slice<int32_t>)) { conditionId = 19; }
            else if(gocpp_id_10 == typeid(gocpp::slice<uint32_t>)) { conditionId = 20; }
            else if(gocpp_id_10 == typeid(int64_t)) { conditionId = 21; }
            else if(gocpp_id_10 == typeid(uint64_t)) { conditionId = 22; }
            else if(gocpp_id_10 == typeid(int64_t*)) { conditionId = 23; }
            else if(gocpp_id_10 == typeid(uint64_t*)) { conditionId = 24; }
            else if(gocpp_id_10 == typeid(gocpp::slice<int64_t>)) { conditionId = 25; }
            else if(gocpp_id_10 == typeid(gocpp::slice<uint64_t>)) { conditionId = 26; }
            else if(gocpp_id_10 == typeid(float)) { conditionId = 27; }
            else if(gocpp_id_10 == typeid(float*)) { conditionId = 28; }
            else if(gocpp_id_10 == typeid(double)) { conditionId = 29; }
            else if(gocpp_id_10 == typeid(double*)) { conditionId = 30; }
            else if(gocpp_id_10 == typeid(gocpp::slice<float>)) { conditionId = 31; }
            else if(gocpp_id_10 == typeid(gocpp::slice<double>)) { conditionId = 32; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                {
                    bool data = gocpp::any_cast<bool>(data);
                    return 1;
                    break;
                }
                case 6:
                {
                    gocpp::slice<bool> data = gocpp::any_cast<gocpp::slice<bool>>(data);
                    return len(data);
                    break;
                }
                case 7:
                {
                    gocpp::slice<int8_t> data = gocpp::any_cast<gocpp::slice<int8_t>>(data);
                    return len(data);
                    break;
                }
                case 8:
                {
                    gocpp::slice<uint8_t> data = gocpp::any_cast<gocpp::slice<uint8_t>>(data);
                    return len(data);
                    break;
                }
                case 9:
                case 10:
                case 11:
                case 12:
                {
                    int16_t data = gocpp::any_cast<int16_t>(data);
                    return 2;
                    break;
                }
                case 13:
                {
                    gocpp::slice<int16_t> data = gocpp::any_cast<gocpp::slice<int16_t>>(data);
                    return 2 * len(data);
                    break;
                }
                case 14:
                {
                    gocpp::slice<uint16_t> data = gocpp::any_cast<gocpp::slice<uint16_t>>(data);
                    return 2 * len(data);
                    break;
                }
                case 15:
                case 16:
                case 17:
                case 18:
                {
                    int32_t data = gocpp::any_cast<int32_t>(data);
                    return 4;
                    break;
                }
                case 19:
                {
                    gocpp::slice<int32_t> data = gocpp::any_cast<gocpp::slice<int32_t>>(data);
                    return 4 * len(data);
                    break;
                }
                case 20:
                {
                    gocpp::slice<uint32_t> data = gocpp::any_cast<gocpp::slice<uint32_t>>(data);
                    return 4 * len(data);
                    break;
                }
                case 21:
                case 22:
                case 23:
                case 24:
                {
                    int64_t data = gocpp::any_cast<int64_t>(data);
                    return 8;
                    break;
                }
                case 25:
                {
                    gocpp::slice<int64_t> data = gocpp::any_cast<gocpp::slice<int64_t>>(data);
                    return 8 * len(data);
                    break;
                }
                case 26:
                {
                    gocpp::slice<uint64_t> data = gocpp::any_cast<gocpp::slice<uint64_t>>(data);
                    return 8 * len(data);
                    break;
                }
                case 27:
                case 28:
                {
                    float data = gocpp::any_cast<float>(data);
                    return 4;
                    break;
                }
                case 29:
                case 30:
                {
                    double data = gocpp::any_cast<double>(data);
                    return 8;
                    break;
                }
                case 31:
                {
                    gocpp::slice<float> data = gocpp::any_cast<gocpp::slice<float>>(data);
                    return 4 * len(data);
                    break;
                }
                case 32:
                {
                    gocpp::slice<double> data = gocpp::any_cast<gocpp::slice<double>>(data);
                    return 8 * len(data);
                    break;
                }
            }
        }
        return 0;
    }

}

