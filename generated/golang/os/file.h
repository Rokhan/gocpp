// generated by GoCpp from file '$(ImportDir)/os/file.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/io/io.h"
#include "golang/os/dir_windows.h"
#include "golang/os/file_windows.h"
#include "golang/os/types.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/net.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    extern File* Stdin;
    extern File* Stdout;
    extern File* Stderr;
    struct LinkError
    {
        gocpp::string Op;
        gocpp::string Old;
        gocpp::string New;
        gocpp::error Err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct LinkError& value);
    struct noReadFrom
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct noReadFrom& value);
    std::tuple<int64_t, struct gocpp::error> genericReadFrom(struct File* f, io::Reader r);
    extern gocpp::error errWriteAtInAppendMode;
    struct noWriteTo
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct noWriteTo& value);
    std::tuple<int64_t, struct gocpp::error> genericWriteTo(struct File* f, io::Writer w);
    struct gocpp::error Mkdir(gocpp::string name, golang::os::FileMode perm);
    struct gocpp::error setStickyBit(gocpp::string name);
    struct gocpp::error Chdir(gocpp::string dir);
    std::tuple<struct File*, struct gocpp::error> Open(gocpp::string name);
    std::tuple<struct File*, struct gocpp::error> Create(gocpp::string name);
    std::tuple<struct File*, struct gocpp::error> OpenFile(gocpp::string name, int flag, golang::os::FileMode perm);
    extern fs::FileInfo, gocpp::error> (gocpp::string)> lstat;
    struct gocpp::error Rename(gocpp::string oldpath, gocpp::string newpath);
    std::tuple<gocpp::string, struct gocpp::error> Readlink(gocpp::string name);
    std::tuple<int, struct gocpp::error> fixCount(int n, struct gocpp::error err);
    extern bool checkWrapErr;
    gocpp::string TempDir();
    std::tuple<gocpp::string, struct gocpp::error> UserCacheDir();
    std::tuple<gocpp::string, struct gocpp::error> UserConfigDir();
    std::tuple<gocpp::string, struct gocpp::error> UserHomeDir();
    struct gocpp::error Chmod(gocpp::string name, golang::os::FileMode mode);
    fs::FS DirFS(gocpp::string dir);
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadFile(gocpp::string name);
    struct gocpp::error WriteFile(gocpp::string name, gocpp::slice<unsigned char> data, golang::os::FileMode perm);
    struct fileWithoutReadFrom
    {
        noReadFrom noReadFrom;
        File* File;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct fileWithoutReadFrom& value);
    struct fileWithoutWriteTo
    {
        noWriteTo noWriteTo;
        File* File;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct fileWithoutWriteTo& value);

    namespace rec
    {
        gocpp::string Name(golang::os::File* f);
        gocpp::string Error(golang::os::LinkError* e);
        struct gocpp::error Unwrap(golang::os::LinkError* e);
        std::tuple<int, struct gocpp::error> Read(golang::os::File* f, gocpp::slice<unsigned char> b);
        std::tuple<int, struct gocpp::error> ReadAt(golang::os::File* f, gocpp::slice<unsigned char> b, int64_t off);
        std::tuple<int64_t, struct gocpp::error> ReadFrom(golang::os::File* f, io::Reader r);
        std::tuple<int64_t, struct gocpp::error> ReadFrom(golang::os::noReadFrom, io::Reader);
        std::tuple<int, struct gocpp::error> Write(golang::os::File* f, gocpp::slice<unsigned char> b);
        std::tuple<int, struct gocpp::error> WriteAt(golang::os::File* f, gocpp::slice<unsigned char> b, int64_t off);
        std::tuple<int64_t, struct gocpp::error> WriteTo(golang::os::File* f, io::Writer w);
        std::tuple<int64_t, struct gocpp::error> WriteTo(golang::os::noWriteTo, io::Writer);
        std::tuple<int64_t, struct gocpp::error> Seek(golang::os::File* f, int64_t offset, int whence);
        std::tuple<int, struct gocpp::error> WriteString(golang::os::File* f, gocpp::string s);
        struct gocpp::error wrapErr(golang::os::File* f, gocpp::string op, struct gocpp::error err);
        struct gocpp::error Chmod(golang::os::File* f, golang::os::FileMode mode);
        struct gocpp::error SetDeadline(golang::os::File* f, mocklib::Date t);
        struct gocpp::error SetReadDeadline(golang::os::File* f, mocklib::Date t);
        struct gocpp::error SetWriteDeadline(golang::os::File* f, mocklib::Date t);
        std::tuple<syscall::RawConn, struct gocpp::error> SyscallConn(golang::os::File* f);
        std::tuple<fs::File, struct gocpp::error> Open(golang::os::dirFS dir, gocpp::string name);
        std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadFile(golang::os::dirFS dir, gocpp::string name);
        std::tuple<gocpp::slice<os::DirEntry>, struct gocpp::error> ReadDir(golang::os::dirFS dir, gocpp::string name);
        std::tuple<fs::FileInfo, struct gocpp::error> Stat(golang::os::dirFS dir, gocpp::string name);
        std::tuple<gocpp::string, struct gocpp::error> join(golang::os::dirFS dir, gocpp::string name);
    }
}

