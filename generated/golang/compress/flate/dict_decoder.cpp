// generated by GoCpp from file '$(ImportDir)/compress/flate/dict_decoder.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/dict_decoder.h"
#include "gocpp/support.h"

namespace golang::flate
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dictDecoder::operator T()
    {
        T result;
        result.hist = this->hist;
        result.wrPos = this->wrPos;
        result.rdPos = this->rdPos;
        result.full = this->full;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dictDecoder::operator==(const T& ref) const
    {
        if (hist != ref.hist) return false;
        if (wrPos != ref.wrPos) return false;
        if (rdPos != ref.rdPos) return false;
        if (full != ref.full) return false;
        return true;
    }

    std::ostream& dictDecoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << hist;
        os << " " << wrPos;
        os << " " << rdPos;
        os << " " << full;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dictDecoder& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct dictDecoder* dd, int size, gocpp::slice<unsigned char> dict)
    {
        *dd = gocpp::Init<dictDecoder>([=](auto& x) {
            x.hist = dd->hist;
        });
        if(cap(dd->hist) < size)
        {
            dd->hist = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        }
        dd->hist = dd->hist.make_slice(0, size);
        if(len(dict) > len(dd->hist))
        {
            dict = dict.make_slice(len(dict) - len(dd->hist));
        }
        dd->wrPos = copy(dd->hist, dict);
        if(dd->wrPos == len(dd->hist))
        {
            dd->wrPos = 0;
            dd->full = true;
        }
        dd->rdPos = dd->wrPos;
    }

    int rec::histSize(struct dictDecoder* dd)
    {
        if(dd->full)
        {
            return len(dd->hist);
        }
        return dd->wrPos;
    }

    int rec::availRead(struct dictDecoder* dd)
    {
        return dd->wrPos - dd->rdPos;
    }

    int rec::availWrite(struct dictDecoder* dd)
    {
        return len(dd->hist) - dd->wrPos;
    }

    gocpp::slice<unsigned char> rec::writeSlice(struct dictDecoder* dd)
    {
        return dd->hist.make_slice(dd->wrPos);
    }

    void rec::writeMark(struct dictDecoder* dd, int cnt)
    {
        dd->wrPos += cnt;
    }

    void rec::writeByte(struct dictDecoder* dd, unsigned char c)
    {
        dd->hist[dd->wrPos] = c;
        dd->wrPos++;
    }

    int rec::writeCopy(struct dictDecoder* dd, int dist, int length)
    {
        auto dstBase = dd->wrPos;
        auto dstPos = dstBase;
        auto srcPos = dstPos - dist;
        auto endPos = dstPos + length;
        if(endPos > len(dd->hist))
        {
            endPos = len(dd->hist);
        }
        if(srcPos < 0)
        {
            srcPos += len(dd->hist);
            dstPos += copy(dd->hist.make_slice(dstPos, endPos), dd->hist.make_slice(srcPos));
            srcPos = 0;
        }
        for(; dstPos < endPos; )
        {
            dstPos += copy(dd->hist.make_slice(dstPos, endPos), dd->hist.make_slice(srcPos, dstPos));
        }
        dd->wrPos = dstPos;
        return dstPos - dstBase;
    }

    int rec::tryWriteCopy(struct dictDecoder* dd, int dist, int length)
    {
        auto dstPos = dd->wrPos;
        auto endPos = dstPos + length;
        if(dstPos < dist || endPos > len(dd->hist))
        {
            return 0;
        }
        auto dstBase = dstPos;
        auto srcPos = dstPos - dist;
        for(; dstPos < endPos; )
        {
            dstPos += copy(dd->hist.make_slice(dstPos, endPos), dd->hist.make_slice(srcPos, dstPos));
        }
        dd->wrPos = dstPos;
        return dstPos - dstBase;
    }

    gocpp::slice<unsigned char> rec::readFlush(struct dictDecoder* dd)
    {
        auto toRead = dd->hist.make_slice(dd->rdPos, dd->wrPos);
        dd->rdPos = dd->wrPos;
        if(dd->wrPos == len(dd->hist))
        {
            std::tie(dd->wrPos, dd->rdPos) = std::tuple{0, 0};
            dd->full = true;
        }
        return toRead;
    }

}

