// generated by GoCpp from file '$(ImportDir)/runtime/map.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/map.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/slice.h"

namespace golang::runtime
{
    bool isEmpty(uint8_t x);
    struct hmap
    {
        int count;
        uint8_t flags;
        uint8_t B;
        uint16_t noverflow;
        uint32_t hash0;
        unsafe::Pointer buckets;
        unsafe::Pointer oldbuckets;
        uintptr_t nevacuate;
        mapextra* extra;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hmap& value);
    struct mapextra
    {
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        bmap* nextOverflow;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapextra& value);
    struct bmap
    {
        gocpp::array<uint8_t, bucketCnt> tophash;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bmap& value);
    struct hiter
    {
        unsafe::Pointer key;
        unsafe::Pointer elem;
        golang::runtime::maptype* t;
        hmap* h;
        unsafe::Pointer buckets;
        bmap* bptr;
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        uintptr_t startBucket;
        uint8_t offset;
        bool wrapped;
        uint8_t B;
        uint8_t i;
        uintptr_t bucket;
        uintptr_t checkBucket;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hiter& value);
    uintptr_t bucketShift(uint8_t b);
    uintptr_t bucketMask(uint8_t b);
    uint8_t tophash(uintptr_t hash);
    bool evacuated(struct bmap* b);
    struct hmap* makemap64(golang::runtime::maptype* t, int64_t hint, struct hmap* h);
    struct hmap* makemap_small();
    struct hmap* makemap(golang::runtime::maptype* t, int hint, struct hmap* h);
    std::tuple<unsafe::Pointer, struct bmap*> makeBucketArray(golang::runtime::maptype* t, uint8_t b, unsafe::Pointer dirtyalloc);
    unsafe::Pointer mapaccess1(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    std::tuple<unsafe::Pointer, bool> mapaccess2(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    std::tuple<unsafe::Pointer, unsafe::Pointer> mapaccessK(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    unsafe::Pointer mapaccess1_fat(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key, unsafe::Pointer zero);
    std::tuple<unsafe::Pointer, bool> mapaccess2_fat(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key, unsafe::Pointer zero);
    unsafe::Pointer mapassign(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    void mapdelete(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    void mapiterinit(golang::runtime::maptype* t, struct hmap* h, struct hiter* it);
    void mapiternext(struct hiter* it);
    void mapclear(golang::runtime::maptype* t, struct hmap* h);
    void hashGrow(golang::runtime::maptype* t, struct hmap* h);
    bool overLoadFactor(int count, uint8_t B);
    bool tooManyOverflowBuckets(uint16_t noverflow, uint8_t B);
    void growWork(golang::runtime::maptype* t, struct hmap* h, uintptr_t bucket);
    bool bucketEvacuated(golang::runtime::maptype* t, struct hmap* h, uintptr_t bucket);
    struct evacDst
    {
        bmap* b;
        int i;
        unsafe::Pointer k;
        unsafe::Pointer e;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct evacDst& value);
    void evacuate(golang::runtime::maptype* t, struct hmap* h, uintptr_t oldbucket);
    void advanceEvacuationMark(struct hmap* h, golang::runtime::maptype* t, uintptr_t newbit);
    struct hmap* reflect_makemap(golang::runtime::maptype* t, int cap);
    unsafe::Pointer reflect_mapaccess(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    unsafe::Pointer reflect_mapaccess_faststr(golang::runtime::maptype* t, struct hmap* h, gocpp::string key);
    void reflect_mapassign(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key, unsafe::Pointer elem);
    void reflect_mapassign_faststr(golang::runtime::maptype* t, struct hmap* h, gocpp::string key, unsafe::Pointer elem);
    void reflect_mapdelete(golang::runtime::maptype* t, struct hmap* h, unsafe::Pointer key);
    void reflect_mapdelete_faststr(golang::runtime::maptype* t, struct hmap* h, gocpp::string key);
    void reflect_mapiterinit(golang::runtime::maptype* t, struct hmap* h, struct hiter* it);
    void reflect_mapiternext(struct hiter* it);
    unsafe::Pointer reflect_mapiterkey(struct hiter* it);
    unsafe::Pointer reflect_mapiterelem(struct hiter* it);
    int reflect_maplen(struct hmap* h);
    void reflect_mapclear(golang::runtime::maptype* t, struct hmap* h);
    int reflectlite_maplen(struct hmap* h);
    extern gocpp::array<unsigned char, abi::ZeroValSize> zeroVal;
    void mapinitnoop();
    go_any mapclone(go_any m);
    std::tuple<struct bmap*, int> moveToBmap(golang::runtime::maptype* t, struct hmap* h, struct bmap* dst, int pos, struct bmap* src);
    struct hmap* mapclone2(golang::runtime::maptype* t, struct hmap* src);
    void keys(go_any m, unsafe::Pointer p);
    void copyKeys(golang::runtime::maptype* t, struct hmap* h, struct bmap* b, struct slice* s, uint8_t offset);
    void values(go_any m, unsafe::Pointer p);
    void copyValues(golang::runtime::maptype* t, struct hmap* h, struct bmap* b, struct slice* s, uint8_t offset);

    namespace rec
    {
        struct bmap* overflow(struct bmap* b, golang::runtime::maptype* t);
        void setoverflow(struct bmap* b, golang::runtime::maptype* t, struct bmap* ovf);
        unsafe::Pointer keys(struct bmap* b);
        void incrnoverflow(struct hmap* h);
        struct bmap* newoverflow(struct hmap* h, golang::runtime::maptype* t, struct bmap* b);
        void createOverflow(struct hmap* h);
        bool growing(struct hmap* h);
        bool sameSizeGrow(struct hmap* h);
        uintptr_t noldbuckets(struct hmap* h);
        uintptr_t oldbucketmask(struct hmap* h);
    }
}

