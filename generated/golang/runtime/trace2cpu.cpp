// generated by GoCpp from file '$(ImportDir)/runtime/trace2cpu.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2cpu.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/cpuprof.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    void traceInitReadCPU()
    {
        if(traceEnabled())
        {
            go_throw("traceInitReadCPU called with trace enabled");
        }
        trace.cpuLogRead[0] = newProfBuf(3, profBufWordCount, profBufTagCount);
        trace.cpuLogRead[1] = newProfBuf(3, profBufWordCount, profBufTagCount);
        rec::Store(gocpp::recv(trace.cpuLogWrite[0]), trace.cpuLogRead[0]);
        rec::Store(gocpp::recv(trace.cpuLogWrite[1]), trace.cpuLogRead[1]);
    }

    struct gocpp_id_0
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_1
            {

                using isGoStruct = void;

                template<typename T> requires gocpp::GoStruct<T>
                operator T()
                {
                    T result;
                    return result;
                }

                template<typename T> requires gocpp::GoStruct<T>
                bool operator==(const T& ref) const
                {
                    return true;
                }

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
            {
                return value.PrintTo(os);
            }


    void traceStartReadCPU()
    {
        if(! traceEnabled())
        {
            go_throw("traceStartReadCPU called with trace disabled");
        }
        trace.cpuSleep = newWakeableSleep();
        auto done = gocpp::make(gocpp::Tag<gocpp::channel<gocpp_id_0>>(), 1);
        gocpp::go([&]{ [=]() mutable -> void
        {
            for(; traceEnabled(); )
            {
                rec::sleep(gocpp::recv(trace.cpuSleep), 100000000);
                auto tl = traceAcquire();
                if(! rec::ok(gocpp::recv(tl)))
                {
                    break;
                }
                auto keepGoing = traceReadCPU(tl.gen);
                traceRelease(tl);
                if(! keepGoing)
                {
                    break;
                }
            }
            done.send(gocpp_id_1 {});
        }(); });
        trace.cpuLogDone = done;
    }

    void traceStopReadCPU()
    {
        if(traceEnabled())
        {
            go_throw("traceStopReadCPU called with trace enabled");
        }
        rec::Store(gocpp::recv(trace.cpuLogWrite[0]), nullptr);
        rec::Store(gocpp::recv(trace.cpuLogWrite[1]), nullptr);
        rec::close(gocpp::recv(trace.cpuLogRead[0]));
        rec::close(gocpp::recv(trace.cpuLogRead[1]));
        rec::wake(gocpp::recv(trace.cpuSleep));
        trace.cpuLogDone.recv();
        trace.cpuLogDone = nullptr;
        trace.cpuLogRead[0] = nullptr;
        trace.cpuLogRead[1] = nullptr;
        rec::close(gocpp::recv(trace.cpuSleep));
    }

    bool traceReadCPU(uintptr_t gen)
    {
        gocpp::array<uintptr_t, traceStackSize> pcBuf = {};
        auto [data, tags, eof] = rec::read(gocpp::recv(trace.cpuLogRead[gen % 2]), profBufNonBlocking);
        for(; len(data) > 0; )
        {
            if(len(data) < 4 || data[0] > uint64_t(len(data)))
            {
                break;
            }
            if(data[0] < 4 || tags != nullptr && len(tags) < 1)
            {
                break;
            }
            if(len(tags) < 1)
            {
                break;
            }
            auto recordLen = data[0];
            auto timestamp = data[1];
            auto ppid = data[2] >> 1;
            if(auto hasP = (data[2] & 0b1) != 0; ! hasP)
            {
                ppid = ~ uint64_t(0);
            }
            auto goid = data[3];
            auto mpid = data[4];
            auto stk = data.make_slice(5, recordLen);
            auto isOverflowRecord = len(stk) == 1 && data[2] == 0 && data[3] == 0 && data[4] == 0;
            data = data.make_slice(recordLen);
            tags = tags.make_slice(1);
            if(isOverflowRecord)
            {
                continue;
            }
            auto nstk = 1;
            pcBuf[0] = logicalStackSentinel;
            for(; nstk < len(pcBuf) && nstk - 1 < len(stk); nstk++)
            {
                pcBuf[nstk] = uintptr_t(stk[nstk - 1]);
            }
            auto w = unsafeTraceWriter(gen, trace.cpuBuf[gen % 2]);
            bool flushed = {};
            std::tie(w, flushed) = rec::ensure(gocpp::recv(w), 2 + 5 * traceBytesPerNumber);
            if(flushed)
            {
                rec::byte(gocpp::recv(w), unsigned char(traceEvCPUSamples));
            }
            auto stackID = rec::put(gocpp::recv(trace.stackTab[gen % 2]), pcBuf.make_slice(0, nstk));
            rec::byte(gocpp::recv(w), unsigned char(traceEvCPUSample));
            rec::varint(gocpp::recv(w), timestamp);
            rec::varint(gocpp::recv(w), mpid);
            rec::varint(gocpp::recv(w), ppid);
            rec::varint(gocpp::recv(w), goid);
            rec::varint(gocpp::recv(w), stackID);
            trace.cpuBuf[gen % 2] = w.traceBuf;
        }
        return ! eof;
    }

    void traceCPUFlush(uintptr_t gen)
    {
        if(auto buf = trace.cpuBuf[gen % 2]; buf != nullptr)
        {
            lock(& trace.lock);
            traceBufFlush(buf, gen);
            unlock(& trace.lock);
            trace.cpuBuf[gen % 2] = nullptr;
        }
    }

    void traceCPUSample(struct g* gp, struct m* mp, struct p* pp, gocpp::slice<uintptr_t> stk)
    {
        if(! traceEnabled())
        {
            return;
        }
        if(mp == nullptr)
        {
            return;
        }
        auto locked = false;
        if(rec::Load(gocpp::recv(mp->trace.seqlock)) % 2 == 0)
        {
            rec::Add(gocpp::recv(mp->trace.seqlock), 1);
            locked = true;
        }
        auto gen = rec::Load(gocpp::recv(trace.gen));
        if(gen == 0)
        {
            if(locked)
            {
                rec::Add(gocpp::recv(mp->trace.seqlock), 1);
            }
            return;
        }
        auto now = traceClockNow();
        gocpp::array<uint64_t, 3> hdr = {};
        if(pp != nullptr)
        {
            hdr[0] = (uint64_t(pp->id) << 1) | 0b1;
        }
        else
        {
            hdr[0] = 0b10;
        }
        if(gp != nullptr)
        {
            hdr[1] = gp->goid;
        }
        if(mp != nullptr)
        {
            hdr[2] = uint64_t(mp->procid);
        }
        for(; ! rec::CompareAndSwap(gocpp::recv(trace.signalLock), 0, 1); )
        {
            osyield();
        }
        if(auto log = rec::Load(gocpp::recv(trace.cpuLogWrite[gen % 2])); log != nullptr)
        {
            rec::write(gocpp::recv(log), nullptr, int64_t(now), hdr.make_slice(0), stk);
        }
        rec::Store(gocpp::recv(trace.signalLock), 0);
        if(locked)
        {
            rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        }
    }

}

