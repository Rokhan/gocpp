// generated by GoCpp from file '$(ImportDir)/runtime/metrics.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/metrics.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/godebugs/table.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debug.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/float.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/sema.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
    }

    // metrics is a map of runtime/metrics keys to data used by the runtime
    // to sample each metric's value. metricsInit indicates it has been
    // initialized.
    //
    // These fields are protected by metricsSema which should be
    // locked/unlocked with metricsLock() / metricsUnlock().
    uint32_t metricsSema = 1;
    bool metricsInit = 1;
    gocpp::map<std::string, metricData> metrics = 1;
    gocpp::slice<double> sizeClassBuckets = 1;
    gocpp::slice<double> timeHistBuckets = 1;
    
    template<typename T> requires gocpp::GoStruct<T>
    metricData::operator T()
    {
        T result;
        result.deps = this->deps;
        result.compute = this->compute;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool metricData::operator==(const T& ref) const
    {
        if (deps != ref.deps) return false;
        if (compute != ref.compute) return false;
        return true;
    }

    std::ostream& metricData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << deps;
        os << " " << compute;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricData& value)
    {
        return value.PrintTo(os);
    }

    void metricsLock()
    {
        semacquire1(& metricsSema, true, 0, 0, waitReasonSemacquire);
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& metricsSema));
        }
    }

    void metricsUnlock()
    {
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(& metricsSema));
        }
        semrelease(& metricsSema);
    }

    // initMetrics initializes the metrics map if it hasn't been yet.
    //
    // metricsSema must be held.
    void initMetrics()
    {
        if(metricsInit)
        {
            return;
        }
        sizeClassBuckets = gocpp::make(gocpp::Tag<gocpp::slice<double>>(), _NumSizeClasses, _NumSizeClasses + 1);
        sizeClassBuckets[0] = 1;
        for(auto i = 1; i < _NumSizeClasses; i++)
        {
            sizeClassBuckets[i] = double(class_to_size[i] + 1);
        }
        sizeClassBuckets = append(sizeClassBuckets, float64Inf());
        timeHistBuckets = timeHistogramMetricsBuckets();
        metrics = gocpp::map<std::string, metricData> {{ "/cgo/go-to-c-calls:calls"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(NumCgoCall());
            };
        }) }, { "/cpu/classes/gc/mark/assist:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.gcAssistTime));
            };
        }) }, { "/cpu/classes/gc/mark/dedicated:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.gcDedicatedTime));
            };
        }) }, { "/cpu/classes/gc/mark/idle:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.gcIdleTime));
            };
        }) }, { "/cpu/classes/gc/pause:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.gcPauseTime));
            };
        }) }, { "/cpu/classes/gc/total:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.gcTotalTime));
            };
        }) }, { "/cpu/classes/idle:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.idleTime));
            };
        }) }, { "/cpu/classes/scavenge/assist:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.scavengeAssistTime));
            };
        }) }, { "/cpu/classes/scavenge/background:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.scavengeBgTime));
            };
        }) }, { "/cpu/classes/scavenge/total:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.scavengeTotalTime));
            };
        }) }, { "/cpu/classes/total:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.totalTime));
            };
        }) }, { "/cpu/classes/user:cpu-seconds"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(cpuStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(in->cpuStats.userTime));
            };
        }) }, { "/gc/cycles/automatic:gc-cycles"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.gcCyclesDone - in->sysStats.gcCyclesForced;
            };
        }) }, { "/gc/cycles/forced:gc-cycles"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.gcCyclesForced;
            };
        }) }, { "/gc/cycles/total:gc-cycles"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.gcCyclesDone;
            };
        }) }, { "/gc/scan/globals:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(gcStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->gcStats.globalsScan;
            };
        }) }, { "/gc/scan/heap:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(gcStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->gcStats.heapScan;
            };
        }) }, { "/gc/scan/stack:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(gcStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->gcStats.stackScan;
            };
        }) }, { "/gc/scan/total:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(gcStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->gcStats.totalScan;
            };
        }) }, { "/gc/heap/allocs-by-size:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                auto hist = rec::float64HistOrInit(gocpp::recv(out), sizeClassBuckets);
                hist->counts[len(hist->counts) - 1] = in->heapStats.largeAllocCount;
                for(auto [i, count] : in->heapStats.smallAllocCount.make_slice(1))
                {
                    hist->counts[i] = count;
                }
            };
        }) }, { "/gc/heap/allocs:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.totalAllocated;
            };
        }) }, { "/gc/heap/allocs:objects"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.totalAllocs;
            };
        }) }, { "/gc/heap/frees-by-size:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                auto hist = rec::float64HistOrInit(gocpp::recv(out), sizeClassBuckets);
                hist->counts[len(hist->counts) - 1] = in->heapStats.largeFreeCount;
                for(auto [i, count] : in->heapStats.smallFreeCount.make_slice(1))
                {
                    hist->counts[i] = count;
                }
            };
        }) }, { "/gc/heap/frees:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.totalFreed;
            };
        }) }, { "/gc/heap/frees:objects"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.totalFrees;
            };
        }) }, { "/gc/heap/goal:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.heapGoal;
            };
        }) }, { "/gc/gomemlimit:bytes"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(rec::Load(gocpp::recv(gcController.memoryLimit)));
            };
        }) }, { "/gc/gogc:percent"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(rec::Load(gocpp::recv(gcController.gcPercent)));
            };
        }) }, { "/gc/heap/live:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = gcController.heapMarked;
            };
        }) }, { "/gc/heap/objects:objects"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.numObjects;
            };
        }) }, { "/gc/heap/tiny/allocs:objects"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.tinyAllocCount;
            };
        }) }, { "/gc/limiter/last-enabled:gc-cycle"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(rec::Load(gocpp::recv(gcCPULimiter.lastEnabledCycle)));
            };
        }) }, { "/gc/pauses:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                rec::write(gocpp::recv(sched.stwTotalTimeGC), out);
            };
        }) }, { "/gc/stack/starting-size:bytes"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(startingStackSize);
            };
        }) }, { "/memory/classes/heap/free:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(in->heapStats.committed - in->heapStats.inHeap - in->heapStats.inStacks - in->heapStats.inWorkBufs - in->heapStats.inPtrScalarBits);
            };
        }) }, { "/memory/classes/heap/objects:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->heapStats.inObjects;
            };
        }) }, { "/memory/classes/heap/released:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(in->heapStats.released);
            };
        }) }, { "/memory/classes/heap/stacks:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(in->heapStats.inStacks);
            };
        }) }, { "/memory/classes/heap/unused:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(in->heapStats.inHeap) - in->heapStats.inObjects;
            };
        }) }, { "/memory/classes/metadata/mcache/free:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.mCacheSys - in->sysStats.mCacheInUse;
            };
        }) }, { "/memory/classes/metadata/mcache/inuse:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.mCacheInUse;
            };
        }) }, { "/memory/classes/metadata/mspan/free:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.mSpanSys - in->sysStats.mSpanInUse;
            };
        }) }, { "/memory/classes/metadata/mspan/inuse:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.mSpanInUse;
            };
        }) }, { "/memory/classes/metadata/other:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep, sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(in->heapStats.inWorkBufs + in->heapStats.inPtrScalarBits) + in->sysStats.gcMiscSys;
            };
        }) }, { "/memory/classes/os-stacks:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.stacksSys;
            };
        }) }, { "/memory/classes/other:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.otherSys;
            };
        }) }, { "/memory/classes/profiling/buckets:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = in->sysStats.buckHashSys;
            };
        }) }, { "/memory/classes/total:bytes"s, gocpp::Init<>([=](auto& x) {
            x.deps = makeStatDepSet(heapStatsDep, sysStatsDep);
            x.compute = [=](struct statAggregate* in, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(in->heapStats.committed + in->heapStats.released) + in->sysStats.stacksSys + in->sysStats.mSpanSys + in->sysStats.mCacheSys + in->sysStats.buckHashSys + in->sysStats.gcMiscSys + in->sysStats.otherSys;
            };
        }) }, { "/sched/gomaxprocs:threads"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(gomaxprocs);
            };
        }) }, { "/sched/goroutines:goroutines"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindUint64;
                out->scalar = uint64_t(gcount());
            };
        }) }, { "/sched/latencies:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                rec::write(gocpp::recv(sched.timeToRun), out);
            };
        }) }, { "/sched/pauses/stopping/gc:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                rec::write(gocpp::recv(sched.stwStoppingTimeGC), out);
            };
        }) }, { "/sched/pauses/stopping/other:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                rec::write(gocpp::recv(sched.stwStoppingTimeOther), out);
            };
        }) }, { "/sched/pauses/total/gc:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                rec::write(gocpp::recv(sched.stwTotalTimeGC), out);
            };
        }) }, { "/sched/pauses/total/other:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                rec::write(gocpp::recv(sched.stwTotalTimeOther), out);
            };
        }) }, { "/sync/mutex/wait/total:seconds"s, gocpp::Init<>([=](auto& x) {
            x.compute = [=](struct statAggregate* _1, struct metricValue* out) mutable -> void
            {
                out->kind = metricKindFloat64;
                out->scalar = float64bits(nsToSec(totalMutexWaitTimeNanos()));
            };
        }) }};
        for(auto [gocpp_ignored, info] : godebugs::All)
        {
            if(! info.Opaque)
            {
                metrics["/godebug/non-default-behavior/"s + info.Name + ":events"s] = gocpp::Init<metricData>([=](auto& x) {
                    x.compute = compute0;
                });
            }
        }
        metricsInit = true;
    }

    void compute0(struct statAggregate* _1, struct metricValue* out)
    {
        out->kind = metricKindUint64;
        out->scalar = 0;
    }

    void rec::compute(golang::runtime::metricReader f, struct statAggregate* _1, struct metricValue* out)
    {
        out->kind = metricKindUint64;
        out->scalar = f();
    }

    //go:linkname godebug_registerMetric internal/godebug.registerMetric
    void godebug_registerMetric(std::string name, std::function<uint64_t ()> read)
    {
        metricsLock();
        initMetrics();
        auto [d, ok] = metrics[name];
        if(! ok)
        {
            go_throw("runtime: unexpected metric registration for "s + name);
        }
        d.compute = metricReader(read).compute;
        metrics[name] = d;
        metricsUnlock();
    }

    // statDep is a dependency on a group of statistics
    // that a metric might have.
    // statDepSet represents a set of statDeps.
    //
    // Under the hood, it's a bitmap.
    // makeStatDepSet creates a new statDepSet from a list of statDeps.
    runtime::statDepSet makeStatDepSet(gocpp::slice<golang::runtime::statDep> deps)
    {
        runtime::statDepSet s = {};
        for(auto [gocpp_ignored, d] : deps)
        {
            s[d / 64] |= 1 << (d % 64);
        }
        return s;
    }

    // difference returns set difference of s from b as a new set.
    runtime::statDepSet rec::difference(golang::runtime::statDepSet s, golang::runtime::statDepSet b)
    {
        runtime::statDepSet c = {};
        for(auto [i, gocpp_ignored] : s)
        {
            c[i] = s[i] &^ b[i];
        }
        return c;
    }

    // union returns the union of the two sets as a new set.
    runtime::statDepSet rec::union(golang::runtime::statDepSet s, golang::runtime::statDepSet b)
    {
        runtime::statDepSet c = {};
        for(auto [i, gocpp_ignored] : s)
        {
            c[i] = s[i] | b[i];
        }
        return c;
    }

    // empty returns true if there are no dependencies in the set.
    bool rec::empty(golang::runtime::statDepSet* s)
    {
        for(auto [gocpp_ignored, c] : s)
        {
            if(c != 0)
            {
                return false;
            }
        }
        return true;
    }

    // has returns true if the set contains a given statDep.
    bool rec::has(golang::runtime::statDepSet* s, golang::runtime::statDep d)
    {
        return s[d / 64] & (1 << (d % 64)) != 0;
    }

    // heapStatsAggregate represents memory stats obtained from the
    // runtime. This set of stats is grouped together because they
    // depend on each other in some way to make sense of the runtime's
    // current heap memory use. They're also sharded across Ps, so it
    // makes sense to grab them all at once.
    
    template<typename T> requires gocpp::GoStruct<T>
    heapStatsAggregate::operator T()
    {
        T result;
        result.heapStatsDelta = this->heapStatsDelta;
        result.inObjects = this->inObjects;
        result.numObjects = this->numObjects;
        result.totalAllocated = this->totalAllocated;
        result.totalFreed = this->totalFreed;
        result.totalAllocs = this->totalAllocs;
        result.totalFrees = this->totalFrees;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heapStatsAggregate::operator==(const T& ref) const
    {
        if (heapStatsDelta != ref.heapStatsDelta) return false;
        if (inObjects != ref.inObjects) return false;
        if (numObjects != ref.numObjects) return false;
        if (totalAllocated != ref.totalAllocated) return false;
        if (totalFreed != ref.totalFreed) return false;
        if (totalAllocs != ref.totalAllocs) return false;
        if (totalFrees != ref.totalFrees) return false;
        return true;
    }

    std::ostream& heapStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heapStatsDelta;
        os << " " << inObjects;
        os << " " << numObjects;
        os << " " << totalAllocated;
        os << " " << totalFreed;
        os << " " << totalAllocs;
        os << " " << totalFrees;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    // compute populates the heapStatsAggregate with values from the runtime.
    void rec::compute(struct heapStatsAggregate* a)
    {
        rec::read(gocpp::recv(memstats.heapStats), & a->heapStatsDelta);
        a->totalAllocs = a->largeAllocCount;
        a->totalFrees = a->largeFreeCount;
        a->totalAllocated = a->largeAlloc;
        a->totalFreed = a->largeFree;
        for(auto [i, gocpp_ignored] : a->smallAllocCount)
        {
            auto na = a->smallAllocCount[i];
            auto nf = a->smallFreeCount[i];
            a->totalAllocs += na;
            a->totalFrees += nf;
            a->totalAllocated += na * uint64_t(class_to_size[i]);
            a->totalFreed += nf * uint64_t(class_to_size[i]);
        }
        a->inObjects = a->totalAllocated - a->totalFreed;
        a->numObjects = a->totalAllocs - a->totalFrees;
    }

    // sysStatsAggregate represents system memory stats obtained
    // from the runtime. This set of stats is grouped together because
    // they're all relatively cheap to acquire and generally independent
    // of one another and other runtime memory stats. The fact that they
    // may be acquired at different times, especially with respect to
    // heapStatsAggregate, means there could be some skew, but because of
    // these stats are independent, there's no real consistency issue here.
    
    template<typename T> requires gocpp::GoStruct<T>
    sysStatsAggregate::operator T()
    {
        T result;
        result.stacksSys = this->stacksSys;
        result.mSpanSys = this->mSpanSys;
        result.mSpanInUse = this->mSpanInUse;
        result.mCacheSys = this->mCacheSys;
        result.mCacheInUse = this->mCacheInUse;
        result.buckHashSys = this->buckHashSys;
        result.gcMiscSys = this->gcMiscSys;
        result.otherSys = this->otherSys;
        result.heapGoal = this->heapGoal;
        result.gcCyclesDone = this->gcCyclesDone;
        result.gcCyclesForced = this->gcCyclesForced;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sysStatsAggregate::operator==(const T& ref) const
    {
        if (stacksSys != ref.stacksSys) return false;
        if (mSpanSys != ref.mSpanSys) return false;
        if (mSpanInUse != ref.mSpanInUse) return false;
        if (mCacheSys != ref.mCacheSys) return false;
        if (mCacheInUse != ref.mCacheInUse) return false;
        if (buckHashSys != ref.buckHashSys) return false;
        if (gcMiscSys != ref.gcMiscSys) return false;
        if (otherSys != ref.otherSys) return false;
        if (heapGoal != ref.heapGoal) return false;
        if (gcCyclesDone != ref.gcCyclesDone) return false;
        if (gcCyclesForced != ref.gcCyclesForced) return false;
        return true;
    }

    std::ostream& sysStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stacksSys;
        os << " " << mSpanSys;
        os << " " << mSpanInUse;
        os << " " << mCacheSys;
        os << " " << mCacheInUse;
        os << " " << buckHashSys;
        os << " " << gcMiscSys;
        os << " " << otherSys;
        os << " " << heapGoal;
        os << " " << gcCyclesDone;
        os << " " << gcCyclesForced;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sysStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    // compute populates the sysStatsAggregate with values from the runtime.
    void rec::compute(struct sysStatsAggregate* a)
    {
        a->stacksSys = rec::load(gocpp::recv(memstats.stacks_sys));
        a->buckHashSys = rec::load(gocpp::recv(memstats.buckhash_sys));
        a->gcMiscSys = rec::load(gocpp::recv(memstats.gcMiscSys));
        a->otherSys = rec::load(gocpp::recv(memstats.other_sys));
        a->heapGoal = rec::heapGoal(gocpp::recv(gcController));
        a->gcCyclesDone = uint64_t(memstats.numgc);
        a->gcCyclesForced = uint64_t(memstats.numforcedgc);
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            a->mSpanSys = rec::load(gocpp::recv(memstats.mspan_sys));
            a->mSpanInUse = uint64_t(mheap_.spanalloc.inuse);
            a->mCacheSys = rec::load(gocpp::recv(memstats.mcache_sys));
            a->mCacheInUse = uint64_t(mheap_.cachealloc.inuse);
            unlock(& mheap_.lock);
        });
    }

    // cpuStatsAggregate represents CPU stats obtained from the runtime
    // acquired together to avoid skew and inconsistencies.
    
    template<typename T> requires gocpp::GoStruct<T>
    cpuStatsAggregate::operator T()
    {
        T result;
        result.cpuStats = this->cpuStats;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cpuStatsAggregate::operator==(const T& ref) const
    {
        if (cpuStats != ref.cpuStats) return false;
        return true;
    }

    std::ostream& cpuStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << cpuStats;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    // compute populates the cpuStatsAggregate with values from the runtime.
    void rec::compute(struct cpuStatsAggregate* a)
    {
        a->cpuStats = work.cpuStats;
    }

    // gcStatsAggregate represents various GC stats obtained from the runtime
    // acquired together to avoid skew and inconsistencies.
    
    template<typename T> requires gocpp::GoStruct<T>
    gcStatsAggregate::operator T()
    {
        T result;
        result.heapScan = this->heapScan;
        result.stackScan = this->stackScan;
        result.globalsScan = this->globalsScan;
        result.totalScan = this->totalScan;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcStatsAggregate::operator==(const T& ref) const
    {
        if (heapScan != ref.heapScan) return false;
        if (stackScan != ref.stackScan) return false;
        if (globalsScan != ref.globalsScan) return false;
        if (totalScan != ref.totalScan) return false;
        return true;
    }

    std::ostream& gcStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heapScan;
        os << " " << stackScan;
        os << " " << globalsScan;
        os << " " << totalScan;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    // compute populates the gcStatsAggregate with values from the runtime.
    void rec::compute(struct gcStatsAggregate* a)
    {
        a->heapScan = rec::Load(gocpp::recv(gcController.heapScan));
        a->stackScan = rec::Load(gocpp::recv(gcController.lastStackScan));
        a->globalsScan = rec::Load(gocpp::recv(gcController.globalsScan));
        a->totalScan = a->heapScan + a->stackScan + a->globalsScan;
    }

    // nsToSec takes a duration in nanoseconds and converts it to seconds as
    // a float64.
    double nsToSec(int64_t ns)
    {
        return double(ns) / 1e9;
    }

    // statAggregate is the main driver of the metrics implementation.
    //
    // It contains multiple aggregates of runtime statistics, as well
    // as a set of these aggregates that it has populated. The aggregates
    // are populated lazily by its ensure method.
    
    template<typename T> requires gocpp::GoStruct<T>
    statAggregate::operator T()
    {
        T result;
        result.ensured = this->ensured;
        result.heapStats = this->heapStats;
        result.sysStats = this->sysStats;
        result.cpuStats = this->cpuStats;
        result.gcStats = this->gcStats;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool statAggregate::operator==(const T& ref) const
    {
        if (ensured != ref.ensured) return false;
        if (heapStats != ref.heapStats) return false;
        if (sysStats != ref.sysStats) return false;
        if (cpuStats != ref.cpuStats) return false;
        if (gcStats != ref.gcStats) return false;
        return true;
    }

    std::ostream& statAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ensured;
        os << " " << heapStats;
        os << " " << sysStats;
        os << " " << cpuStats;
        os << " " << gcStats;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct statAggregate& value)
    {
        return value.PrintTo(os);
    }

    // ensure populates statistics aggregates determined by deps if they
    // haven't yet been populated.
    void rec::ensure(struct statAggregate* a, golang::runtime::statDepSet* deps)
    {
        auto missing = rec::difference(gocpp::recv(deps), a->ensured);
        if(rec::empty(gocpp::recv(missing)))
        {
            return;
        }
        for(auto i = statDep(0); i < numStatsDeps; i++)
        {
            if(! rec::has(gocpp::recv(missing), i))
            {
                continue;
            }
            //Go switch emulation
            {
                auto condition = i;
                int conditionId = -1;
                if(condition == heapStatsDep) { conditionId = 0; }
                else if(condition == sysStatsDep) { conditionId = 1; }
                else if(condition == cpuStatsDep) { conditionId = 2; }
                else if(condition == gcStatsDep) { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        rec::compute(gocpp::recv(a->heapStats));
                        break;
                    case 1:
                        rec::compute(gocpp::recv(a->sysStats));
                        break;
                    case 2:
                        rec::compute(gocpp::recv(a->cpuStats));
                        break;
                    case 3:
                        rec::compute(gocpp::recv(a->gcStats));
                        break;
                }
            }
        }
        a->ensured = rec::union(gocpp::recv(a->ensured), missing);
    }

    // metricKind is a runtime copy of runtime/metrics.ValueKind and
    // must be kept structurally identical to that type.
    // These values must be kept identical to their corresponding Kind* values
    // in the runtime/metrics package.
    // metricSample is a runtime copy of runtime/metrics.Sample and
    // must be kept structurally identical to that type.
    
    template<typename T> requires gocpp::GoStruct<T>
    metricSample::operator T()
    {
        T result;
        result.name = this->name;
        result.value = this->value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool metricSample::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (value != ref.value) return false;
        return true;
    }

    std::ostream& metricSample::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricSample& value)
    {
        return value.PrintTo(os);
    }

    // metricValue is a runtime copy of runtime/metrics.Sample and
    // must be kept structurally identical to that type.
    
    template<typename T> requires gocpp::GoStruct<T>
    metricValue::operator T()
    {
        T result;
        result.kind = this->kind;
        result.scalar = this->scalar;
        result.pointer = this->pointer;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool metricValue::operator==(const T& ref) const
    {
        if (kind != ref.kind) return false;
        if (scalar != ref.scalar) return false;
        if (pointer != ref.pointer) return false;
        return true;
    }

    std::ostream& metricValue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << scalar;
        os << " " << pointer;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricValue& value)
    {
        return value.PrintTo(os);
    }

    // float64HistOrInit tries to pull out an existing float64Histogram
    // from the value, but if none exists, then it allocates one with
    // the given buckets.
    struct metricFloat64Histogram* rec::float64HistOrInit(struct metricValue* v, gocpp::slice<double> buckets)
    {
        metricFloat64Histogram* hist = {};
        if(v->kind == metricKindFloat64Histogram && v->pointer != nullptr)
        {
            hist = (metricFloat64Histogram*)(v->pointer);
        }
        else
        {
            v->kind = metricKindFloat64Histogram;
            hist = new(metricFloat64Histogram);
            v->pointer = unsafe::Pointer(hist);
        }
        hist->buckets = buckets;
        if(len(hist->counts) != len(hist->buckets) - 1)
        {
            hist->counts = gocpp::make(gocpp::Tag<gocpp::slice<uint64_t>>(), len(buckets) - 1);
        }
        return hist;
    }

    // metricFloat64Histogram is a runtime copy of runtime/metrics.Float64Histogram
    // and must be kept structurally identical to that type.
    
    template<typename T> requires gocpp::GoStruct<T>
    metricFloat64Histogram::operator T()
    {
        T result;
        result.counts = this->counts;
        result.buckets = this->buckets;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool metricFloat64Histogram::operator==(const T& ref) const
    {
        if (counts != ref.counts) return false;
        if (buckets != ref.buckets) return false;
        return true;
    }

    std::ostream& metricFloat64Histogram::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << counts;
        os << " " << buckets;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricFloat64Histogram& value)
    {
        return value.PrintTo(os);
    }

    // agg is used by readMetrics, and is protected by metricsSema.
    //
    // Managed as a global variable because its pointer will be
    // an argument to a dynamically-defined function, and we'd
    // like to avoid it escaping to the heap.
    statAggregate agg;
    
    template<typename T> requires gocpp::GoStruct<T>
    metricName::operator T()
    {
        T result;
        result.name = this->name;
        result.kind = this->kind;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool metricName::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (kind != ref.kind) return false;
        return true;
    }

    std::ostream& metricName::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricName& value)
    {
        return value.PrintTo(os);
    }

    // readMetricNames is the implementation of runtime/metrics.readMetricNames,
    // used by the runtime/metrics test and otherwise unreferenced.
    //
    //go:linkname readMetricNames runtime/metrics_test.runtime_readMetricNames
    gocpp::slice<std::string> readMetricNames()
    {
        metricsLock();
        initMetrics();
        auto n = len(metrics);
        metricsUnlock();
        auto list = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0, n);
        metricsLock();
        for(auto [name, gocpp_ignored] : metrics)
        {
            list = append(list, name);
        }
        metricsUnlock();
        return list;
    }

    // readMetrics is the implementation of runtime/metrics.Read.
    //
    //go:linkname readMetrics runtime/metrics.runtime_readMetrics
    void readMetrics(unsafe::Pointer samplesp, int len, int cap)
    {
        metricsLock();
        initMetrics();
        readMetricsLocked(samplesp, len, cap);
        metricsUnlock();
    }

    // readMetricsLocked is the internal, locked portion of readMetrics.
    //
    // Broken out for more robust testing. metricsLock must be held and
    // initMetrics must have been called already.
    void readMetricsLocked(unsafe::Pointer samplesp, int len, int cap)
    {
        auto sl = slice {samplesp, len, cap};
        auto samples = *(gocpp::slice<metricSample>*)(unsafe::Pointer(& sl));
        agg = statAggregate {};
        for(auto [i, gocpp_ignored] : samples)
        {
            auto sample = & samples[i];
            auto [data, ok] = metrics[sample->name];
            if(! ok)
            {
                sample->value.kind = metricKindBad;
                continue;
            }
            rec::ensure(gocpp::recv(agg), & data.deps);
            rec::compute(gocpp::recv(data), & agg, & sample->value);
        }
    }

}

