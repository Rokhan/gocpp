// generated by GoCpp from file '$(ImportDir)/unicode/letter.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/unicode/letter.h"
#include "gocpp/support.h"

#include "golang/unicode/graphic.h"

namespace golang::unicode
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace unicode::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RangeTable::operator T()
    {
        T result;
        result.R16 = this->R16;
        result.R32 = this->R32;
        result.LatinOffset = this->LatinOffset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RangeTable::operator==(const T& ref) const
    {
        if (R16 != ref.R16) return false;
        if (R32 != ref.R32) return false;
        if (LatinOffset != ref.LatinOffset) return false;
        return true;
    }

    std::ostream& RangeTable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R16;
        os << " " << R32;
        os << " " << LatinOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RangeTable& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Range16::operator T()
    {
        T result;
        result.Lo = this->Lo;
        result.Hi = this->Hi;
        result.Stride = this->Stride;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Range16::operator==(const T& ref) const
    {
        if (Lo != ref.Lo) return false;
        if (Hi != ref.Hi) return false;
        if (Stride != ref.Stride) return false;
        return true;
    }

    std::ostream& Range16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Lo;
        os << " " << Hi;
        os << " " << Stride;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Range16& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Range32::operator T()
    {
        T result;
        result.Lo = this->Lo;
        result.Hi = this->Hi;
        result.Stride = this->Stride;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Range32::operator==(const T& ref) const
    {
        if (Lo != ref.Lo) return false;
        if (Hi != ref.Hi) return false;
        if (Stride != ref.Stride) return false;
        return true;
    }

    std::ostream& Range32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Lo;
        os << " " << Hi;
        os << " " << Stride;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Range32& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CaseRange::operator T()
    {
        T result;
        result.Lo = this->Lo;
        result.Hi = this->Hi;
        result.Delta = this->Delta;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CaseRange::operator==(const T& ref) const
    {
        if (Lo != ref.Lo) return false;
        if (Hi != ref.Hi) return false;
        if (Delta != ref.Delta) return false;
        return true;
    }

    std::ostream& CaseRange::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Lo;
        os << " " << Hi;
        os << " " << Delta;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CaseRange& value)
    {
        return value.PrintTo(os);
    }

    // // to make the CaseRanges text shorter
    bool is16(gocpp::slice<Range16> ranges, uint16_t r)
    {
        if(len(ranges) <= linearMax || r <= MaxLatin1)
        {
            for(auto [i, gocpp_ignored] : ranges)
            {
                auto range_ = & ranges[i];
                if(r < range_->Lo)
                {
                    return false;
                }
                if(r <= range_->Hi)
                {
                    return range_->Stride == 1 || (r - range_->Lo) % range_->Stride == 0;
                }
            }
            return false;
        }
        auto lo = 0;
        auto hi = len(ranges);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto range_ = & ranges[m];
            if(range_->Lo <= r && r <= range_->Hi)
            {
                return range_->Stride == 1 || (r - range_->Lo) % range_->Stride == 0;
            }
            if(r < range_->Lo)
            {
                hi = m;
            }
            else
            {
                lo = m + 1;
            }
        }
        return false;
    }

    bool is32(gocpp::slice<Range32> ranges, uint32_t r)
    {
        if(len(ranges) <= linearMax)
        {
            for(auto [i, gocpp_ignored] : ranges)
            {
                auto range_ = & ranges[i];
                if(r < range_->Lo)
                {
                    return false;
                }
                if(r <= range_->Hi)
                {
                    return range_->Stride == 1 || (r - range_->Lo) % range_->Stride == 0;
                }
            }
            return false;
        }
        auto lo = 0;
        auto hi = len(ranges);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto range_ = ranges[m];
            if(range_.Lo <= r && r <= range_.Hi)
            {
                return range_.Stride == 1 || (r - range_.Lo) % range_.Stride == 0;
            }
            if(r < range_.Lo)
            {
                hi = m;
            }
            else
            {
                lo = m + 1;
            }
        }
        return false;
    }

    bool Is(struct RangeTable* rangeTab, gocpp::rune r)
    {
        auto r16 = rangeTab->R16;
        if(len(r16) > 0 && uint32_t(r) <= uint32_t(r16[len(r16) - 1].Hi))
        {
            return is16(r16, uint16_t(r));
        }
        auto r32 = rangeTab->R32;
        if(len(r32) > 0 && r >= rune(r32[0].Lo))
        {
            return is32(r32, uint32_t(r));
        }
        return false;
    }

    bool isExcludingLatin(struct RangeTable* rangeTab, gocpp::rune r)
    {
        auto r16 = rangeTab->R16;
        if(auto off = rangeTab->LatinOffset; len(r16) > off && uint32_t(r) <= uint32_t(r16[len(r16) - 1].Hi))
        {
            return is16(r16.make_slice(off), uint16_t(r));
        }
        auto r32 = rangeTab->R32;
        if(len(r32) > 0 && r >= rune(r32[0].Lo))
        {
            return is32(r32, uint32_t(r));
        }
        return false;
    }

    bool IsUpper(gocpp::rune r)
    {
        if(uint32_t(r) <= MaxLatin1)
        {
            return properties[uint8_t(r)] & pLmask == pLu;
        }
        return isExcludingLatin(Upper, r);
    }

    bool IsLower(gocpp::rune r)
    {
        if(uint32_t(r) <= MaxLatin1)
        {
            return properties[uint8_t(r)] & pLmask == pLl;
        }
        return isExcludingLatin(Lower, r);
    }

    bool IsTitle(gocpp::rune r)
    {
        if(r <= MaxLatin1)
        {
            return false;
        }
        return isExcludingLatin(Title, r);
    }

    std::tuple<gocpp::rune, bool> to(int _case, gocpp::rune r, gocpp::slice<CaseRange> caseRange)
    {
        gocpp::rune mappedRune;
        bool foundMapping;
        if(_case < 0 || MaxCase <= _case)
        {
            gocpp::rune mappedRune;
            bool foundMapping;
            return {ReplacementChar, false};
        }
        auto lo = 0;
        auto hi = len(caseRange);
        for(; lo < hi; )
        {
            gocpp::rune mappedRune;
            bool foundMapping;
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto cr = caseRange[m];
            if(rune(cr.Lo) <= r && r <= rune(cr.Hi))
            {
                gocpp::rune mappedRune;
                bool foundMapping;
                auto delta = cr.Delta[_case];
                if(delta > MaxRune)
                {
                    gocpp::rune mappedRune;
                    bool foundMapping;
                    return {rune(cr.Lo) + ((r - rune(cr.Lo)) &^ 1 | rune(_case & 1)), true};
                }
                return {r + delta, true};
            }
            if(r < rune(cr.Lo))
            {
                gocpp::rune mappedRune;
                bool foundMapping;
                hi = m;
            }
            else
            {
                gocpp::rune mappedRune;
                bool foundMapping;
                lo = m + 1;
            }
        }
        return {r, false};
    }

    gocpp::rune To(int _case, gocpp::rune r)
    {
        std::tie(r, gocpp_id_0) = to(_case, r, CaseRanges);
        return r;
    }

    gocpp::rune ToUpper(gocpp::rune r)
    {
        if(r <= MaxASCII)
        {
            if('a' <= r && r <= 'z')
            {
                r -= 'a' - 'A';
            }
            return r;
        }
        return To(UpperCase, r);
    }

    gocpp::rune ToLower(gocpp::rune r)
    {
        if(r <= MaxASCII)
        {
            if('A' <= r && r <= 'Z')
            {
                r += 'a' - 'A';
            }
            return r;
        }
        return To(LowerCase, r);
    }

    gocpp::rune ToTitle(gocpp::rune r)
    {
        if(r <= MaxASCII)
        {
            if('a' <= r && r <= 'z')
            {
                r -= 'a' - 'A';
            }
            return r;
        }
        return To(TitleCase, r);
    }

    gocpp::rune rec::ToUpper(golang::unicode::SpecialCase special, gocpp::rune r)
    {
        auto [r1, hadMapping] = to(UpperCase, r, gocpp::Tag<gocpp::slice<CaseRange>>()(special));
        if(r1 == r && ! hadMapping)
        {
            r1 = ToUpper(r);
        }
        return r1;
    }

    gocpp::rune rec::ToTitle(golang::unicode::SpecialCase special, gocpp::rune r)
    {
        auto [r1, hadMapping] = to(TitleCase, r, gocpp::Tag<gocpp::slice<CaseRange>>()(special));
        if(r1 == r && ! hadMapping)
        {
            r1 = ToTitle(r);
        }
        return r1;
    }

    gocpp::rune rec::ToLower(golang::unicode::SpecialCase special, gocpp::rune r)
    {
        auto [r1, hadMapping] = to(LowerCase, r, gocpp::Tag<gocpp::slice<CaseRange>>()(special));
        if(r1 == r && ! hadMapping)
        {
            r1 = ToLower(r);
        }
        return r1;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    foldPair::operator T()
    {
        T result;
        result.From = this->From;
        result.To = this->To;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool foldPair::operator==(const T& ref) const
    {
        if (From != ref.From) return false;
        if (To != ref.To) return false;
        return true;
    }

    std::ostream& foldPair::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << From;
        os << " " << To;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct foldPair& value)
    {
        return value.PrintTo(os);
    }

    gocpp::rune SimpleFold(gocpp::rune r)
    {
        if(r < 0 || r > MaxRune)
        {
            return r;
        }
        if(int(r) < len(asciiFold))
        {
            return rune(asciiFold[r]);
        }
        auto lo = 0;
        auto hi = len(caseOrbit);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            if(rune(caseOrbit[m].From) < r)
            {
                lo = m + 1;
            }
            else
            {
                hi = m;
            }
        }
        if(lo < len(caseOrbit) && rune(caseOrbit[lo].From) == r)
        {
            return rune(caseOrbit[lo].To);
        }
        if(auto l = ToLower(r); l != r)
        {
            return l;
        }
        return ToUpper(r);
    }

}

