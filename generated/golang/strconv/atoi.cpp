// generated by GoCpp from file '$(ImportDir)/strconv/atoi.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/atoi.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"

namespace golang::strconv
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    unsigned char lower(unsigned char c)
    {
        return c | ('x' - 'X');
    }

    gocpp::error ErrRange = errors::New("value out of range"s);
    gocpp::error ErrSyntax = errors::New("invalid syntax"s);
    
    template<typename T> requires gocpp::GoStruct<T>
    NumError::operator T()
    {
        T result;
        result.Func = this->Func;
        result.Num = this->Num;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NumError::operator==(const T& ref) const
    {
        if (Func != ref.Func) return false;
        if (Num != ref.Num) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& NumError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Func;
        os << " " << Num;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NumError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct NumError* e)
    {
        return "strconv."s + e->Func + ": "s + "parsing "s + Quote(e->Num) + ": "s + rec::Error(gocpp::recv(e->Err));
    }

    struct gocpp::error rec::Unwrap(struct NumError* e)
    {
        return e->Err;
    }

    std::string cloneString(std::string x)
    {
        return std::string(gocpp::slice<unsigned char>(x));
    }

    struct NumError* syntaxError(std::string fn, std::string str)
    {
        return new NumError {fn, cloneString(str), ErrSyntax};
    }

    struct NumError* rangeError(std::string fn, std::string str)
    {
        return new NumError {fn, cloneString(str), ErrRange};
    }

    struct NumError* baseError(std::string fn, std::string str, int base)
    {
        return new NumError {fn, cloneString(str), errors::New("invalid base "s + Itoa(base))};
    }

    struct NumError* bitSizeError(std::string fn, std::string str, int bitSize)
    {
        return new NumError {fn, cloneString(str), errors::New("invalid bit size "s + Itoa(bitSize))};
    }

    std::tuple<uint64_t, struct gocpp::error> ParseUint(std::string s, int base, int bitSize)
    {
        auto fnParseUint = "ParseUint"s;
        if(s == ""s)
        {
            return {0, syntaxError(fnParseUint, s)};
        }
        auto base0 = base == 0;
        auto s0 = s;
        //Go switch emulation
        {
            int conditionId = -1;
            if(2 <= base && base <= 36) { conditionId = 0; }
            else if(base == 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    break;
                case 1:
                    base = 10;
                    if(s[0] == '0')
                    {
                        //Go switch emulation
                        {
                            int conditionId = -1;
                            if(len(s) >= 3 && lower(s[1]) == 'b') { conditionId = 0; }
                            else if(len(s) >= 3 && lower(s[1]) == 'o') { conditionId = 1; }
                            else if(len(s) >= 3 && lower(s[1]) == 'x') { conditionId = 2; }
                            switch(conditionId)
                            {
                                case 0:
                                    base = 2;
                                    s = s.make_slice(2);
                                    break;
                                case 1:
                                    base = 8;
                                    s = s.make_slice(2);
                                    break;
                                case 2:
                                    base = 16;
                                    s = s.make_slice(2);
                                    break;
                                default:
                                    base = 8;
                                    s = s.make_slice(1);
                                    break;
                            }
                        }
                    }
                    break;
                default:
                    return {0, baseError(fnParseUint, s0, base)};
                    break;
            }
        }
        if(bitSize == 0)
        {
            bitSize = IntSize;
        }
        else
        if(bitSize < 0 || bitSize > 64)
        {
            return {0, bitSizeError(fnParseUint, s0, bitSize)};
        }
        uint64_t cutoff = {};
        //Go switch emulation
        {
            auto condition = base;
            int conditionId = -1;
            if(condition == 10) { conditionId = 0; }
            else if(condition == 16) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    cutoff = maxUint64 / 10 + 1;
                    break;
                case 1:
                    cutoff = maxUint64 / 16 + 1;
                    break;
                default:
                    cutoff = maxUint64 / uint64_t(base) + 1;
                    break;
            }
        }
        auto maxVal = (uint64_t(1) << (unsigned int)(bitSize)) - 1;
        auto underscores = false;
        uint64_t n = {};
        for(auto [gocpp_ignored, c] : gocpp::slice<unsigned char>(s))
        {
            unsigned char d = {};
            //Go switch emulation
            {
                int conditionId = -1;
                if(c == '_' && base0) { conditionId = 0; }
                else if('0' <= c && c <= '9') { conditionId = 1; }
                else if('a' <= lower(c) && lower(c) <= 'z') { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        underscores = true;
                        continue;
                        break;
                    case 1:
                        d = c - '0';
                        break;
                    case 2:
                        d = lower(c) - 'a' + 10;
                        break;
                    default:
                        return {0, syntaxError(fnParseUint, s0)};
                        break;
                }
            }
            if(d >= (unsigned char)(base))
            {
                return {0, syntaxError(fnParseUint, s0)};
            }
            if(n >= cutoff)
            {
                return {maxVal, rangeError(fnParseUint, s0)};
            }
            n *= uint64_t(base);
            auto n1 = n + uint64_t(d);
            if(n1 < n || n1 > maxVal)
            {
                return {maxVal, rangeError(fnParseUint, s0)};
            }
            n = n1;
        }
        if(underscores && ! underscoreOK(s0))
        {
            return {0, syntaxError(fnParseUint, s0)};
        }
        return {n, nullptr};
    }

    std::tuple<int64_t, struct gocpp::error> ParseInt(std::string s, int base, int bitSize)
    {
        int64_t i;
        struct gocpp::error err;
        auto fnParseInt = "ParseInt"s;
        if(s == ""s)
        {
            return {0, syntaxError(fnParseInt, s)};
        }
        auto s0 = s;
        auto neg = false;
        if(s[0] == '+')
        {
            s = s.make_slice(1);
        }
        else
        if(s[0] == '-')
        {
            neg = true;
            s = s.make_slice(1);
        }
        uint64_t un = {};
        std::tie(un, err) = ParseUint(s, base, bitSize);
        if(err != nullptr && gocpp::getValue<NumError*>(err)->Err != ErrRange)
        {
            gocpp::getValue<NumError*>(err)->Func = fnParseInt;
            gocpp::getValue<NumError*>(err)->Num = cloneString(s0);
            return {0, err};
        }
        if(bitSize == 0)
        {
            bitSize = IntSize;
        }
        auto cutoff = uint64_t(1 << (unsigned int)(bitSize - 1));
        if(! neg && un >= cutoff)
        {
            return {int64_t(cutoff - 1), rangeError(fnParseInt, s0)};
        }
        if(neg && un > cutoff)
        {
            return {- int64_t(cutoff), rangeError(fnParseInt, s0)};
        }
        auto n = int64_t(un);
        if(neg)
        {
            n = - n;
        }
        return {n, nullptr};
    }

    std::tuple<int, struct gocpp::error> Atoi(std::string s)
    {
        auto fnAtoi = "Atoi"s;
        auto sLen = len(s);
        if(intSize == 32 && (0 < sLen && sLen < 10) || intSize == 64 && (0 < sLen && sLen < 19))
        {
            auto s0 = s;
            if(s[0] == '-' || s[0] == '+')
            {
                s = s.make_slice(1);
                if(len(s) < 1)
                {
                    return {0, syntaxError(fnAtoi, s0)};
                }
            }
            auto n = 0;
            for(auto [gocpp_ignored, ch] : gocpp::slice<unsigned char>(s))
            {
                ch -= '0';
                if(ch > 9)
                {
                    return {0, syntaxError(fnAtoi, s0)};
                }
                n = n * 10 + int(ch);
            }
            if(s0[0] == '-')
            {
                n = - n;
            }
            return {n, nullptr};
        }
        auto [i64, err] = ParseInt(s, 10, 0);
        if(auto [nerr, ok] = gocpp::getValue<NumError*>(err); ok)
        {
            nerr->Func = fnAtoi;
        }
        return {int(i64), err};
    }

    bool underscoreOK(std::string s)
    {
        auto saw = '^';
        auto i = 0;
        if(len(s) >= 1 && (s[0] == '-' || s[0] == '+'))
        {
            s = s.make_slice(1);
        }
        auto hex = false;
        if(len(s) >= 2 && s[0] == '0' && (lower(s[1]) == 'b' || lower(s[1]) == 'o' || lower(s[1]) == 'x'))
        {
            i = 2;
            saw = '0';
            hex = lower(s[1]) == 'x';
        }
        for(; i < len(s); i++)
        {
            if('0' <= s[i] && s[i] <= '9' || hex && 'a' <= lower(s[i]) && lower(s[i]) <= 'f')
            {
                saw = '0';
                continue;
            }
            if(s[i] == '_')
            {
                if(saw != '0')
                {
                    return false;
                }
                saw = '_';
                continue;
            }
            if(saw == '_')
            {
                return false;
            }
            saw = '!';
        }
        return saw != '_';
    }

}

