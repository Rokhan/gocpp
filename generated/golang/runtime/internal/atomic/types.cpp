// generated by GoCpp from file '$(ImportDir)/runtime/internal/atomic/types.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/internal/atomic/types.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::atomic
{
    
    std::ostream& Int32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Int32& value)
    {
        return value.PrintTo(os);
    }

    int32_t Load(struct Int32* i)
    {
        return Loadint32(& i->value);
    }

    void Store(struct Int32* i, int32_t value)
    {
        Storeint32(& i->value, value);
    }

    bool CompareAndSwap(struct Int32* i, int32_t old, int32_t go_new)
    {
        return Casint32(& i->value, old, go_new);
    }

    int32_t Swap(struct Int32* i, int32_t go_new)
    {
        return Xchgint32(& i->value, go_new);
    }

    int32_t Add(struct Int32* i, int32_t delta)
    {
        return Xaddint32(& i->value, delta);
    }

    
    std::ostream& Int64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << _;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Int64& value)
    {
        return value.PrintTo(os);
    }

    int64_t Load(struct Int64* i)
    {
        return Loadint64(& i->value);
    }

    void Store(struct Int64* i, int64_t value)
    {
        Storeint64(& i->value, value);
    }

    bool CompareAndSwap(struct Int64* i, int64_t old, int64_t go_new)
    {
        return Casint64(& i->value, old, go_new);
    }

    int64_t Swap(struct Int64* i, int64_t go_new)
    {
        return Xchgint64(& i->value, go_new);
    }

    int64_t Add(struct Int64* i, int64_t delta)
    {
        return Xaddint64(& i->value, delta);
    }

    
    std::ostream& Uint8::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint8& value)
    {
        return value.PrintTo(os);
    }

    uint8_t Load(struct Uint8* u)
    {
        return Load8(& u->value);
    }

    void Store(struct Uint8* u, uint8_t value)
    {
        Store8(& u->value, value);
    }

    void And(struct Uint8* u, uint8_t value)
    {
        And8(& u->value, value);
    }

    void Or(struct Uint8* u, uint8_t value)
    {
        Or8(& u->value, value);
    }

    
    std::ostream& Bool::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Bool& value)
    {
        return value.PrintTo(os);
    }

    bool Load(struct Bool* b)
    {
        return Load(gocpp::recv(b->u)) != 0;
    }

    void Store(struct Bool* b, bool value)
    {
        auto s = uint8_t(0);
        if(value)
        {
            s = 1;
        }
        Store(gocpp::recv(b->u), s);
    }

    
    std::ostream& Uint32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint32& value)
    {
        return value.PrintTo(os);
    }

    uint32_t Load(struct Uint32* u)
    {
        return Load(& u->value);
    }

    uint32_t LoadAcquire(struct Uint32* u)
    {
        return LoadAcq(& u->value);
    }

    void Store(struct Uint32* u, uint32_t value)
    {
        Store(& u->value, value);
    }

    void StoreRelease(struct Uint32* u, uint32_t value)
    {
        StoreRel(& u->value, value);
    }

    bool CompareAndSwap(struct Uint32* u, uint32_t old, uint32_t go_new)
    {
        return Cas(& u->value, old, go_new);
    }

    bool CompareAndSwapRelease(struct Uint32* u, uint32_t old, uint32_t go_new)
    {
        return CasRel(& u->value, old, go_new);
    }

    uint32_t Swap(struct Uint32* u, uint32_t value)
    {
        return Xchg(& u->value, value);
    }

    void And(struct Uint32* u, uint32_t value)
    {
        And(& u->value, value);
    }

    void Or(struct Uint32* u, uint32_t value)
    {
        Or(& u->value, value);
    }

    uint32_t Add(struct Uint32* u, int32_t delta)
    {
        return Xadd(& u->value, delta);
    }

    
    std::ostream& Uint64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << _;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uint64& value)
    {
        return value.PrintTo(os);
    }

    uint64_t Load(struct Uint64* u)
    {
        return Load64(& u->value);
    }

    void Store(struct Uint64* u, uint64_t value)
    {
        Store64(& u->value, value);
    }

    bool CompareAndSwap(struct Uint64* u, uint64_t old, uint64_t go_new)
    {
        return Cas64(& u->value, old, go_new);
    }

    uint64_t Swap(struct Uint64* u, uint64_t value)
    {
        return Xchg64(& u->value, value);
    }

    uint64_t Add(struct Uint64* u, int64_t delta)
    {
        return Xadd64(& u->value, delta);
    }

    
    std::ostream& Uintptr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Uintptr& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t Load(struct Uintptr* u)
    {
        return Loaduintptr(& u->value);
    }

    uintptr_t LoadAcquire(struct Uintptr* u)
    {
        return LoadAcquintptr(& u->value);
    }

    void Store(struct Uintptr* u, uintptr_t value)
    {
        Storeuintptr(& u->value, value);
    }

    void StoreRelease(struct Uintptr* u, uintptr_t value)
    {
        StoreReluintptr(& u->value, value);
    }

    bool CompareAndSwap(struct Uintptr* u, uintptr_t old, uintptr_t go_new)
    {
        return Casuintptr(& u->value, old, go_new);
    }

    uintptr_t Swap(struct Uintptr* u, uintptr_t value)
    {
        return Xchguintptr(& u->value, value);
    }

    uintptr_t Add(struct Uintptr* u, uintptr_t delta)
    {
        return Xadduintptr(& u->value, delta);
    }

    
    std::ostream& Float64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Float64& value)
    {
        return value.PrintTo(os);
    }

    double Load(struct Float64* f)
    {
        auto r = Load(gocpp::recv(f->u));
        return *(double*)(unsafe::Pointer(& r));
    }

    void Store(struct Float64* f, double value)
    {
        Store(gocpp::recv(f->u), *(uint64_t*)(unsafe::Pointer(& value)));
    }

    
    std::ostream& UnsafePointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct UnsafePointer& value)
    {
        return value.PrintTo(os);
    }

    unsafe::Pointer Load(struct UnsafePointer* u)
    {
        return Loadp(unsafe::Pointer(& u->value));
    }

    void StoreNoWB(struct UnsafePointer* u, unsafe::Pointer value)
    {
        StorepNoWB(unsafe::Pointer(& u->value), value);
    }

    void Store(struct UnsafePointer* u, unsafe::Pointer value)
    {
        storePointer(& u->value, value);
    }

    void storePointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    /* convertBlockStmt, nil block */;

    bool CompareAndSwapNoWB(struct UnsafePointer* u, unsafe::Pointer old, unsafe::Pointer go_new)
    {
        return Casp1(& u->value, old, go_new);
    }

    bool CompareAndSwap(struct UnsafePointer* u, unsafe::Pointer old, unsafe::Pointer go_new)
    {
        return casPointer(& u->value, old, go_new);
    }

    bool casPointer(unsafe::Pointer* ptr, unsafe::Pointer old, unsafe::Pointer go_new)
    /* convertBlockStmt, nil block */;

    
    template<typename T>
    std::ostream& Pointer<T>::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const struct Pointer<T>& value)
    {
        return value.PrintTo(os);
    }


    template<typename T>
    T* Load(struct Pointer<T>* p)
    {
        return (T*)(Load(gocpp::recv(p->u)));
    }


    template<typename T>
    void StoreNoWB(struct Pointer<T>* p, T* value)
    {
        StoreNoWB(gocpp::recv(p->u), unsafe::Pointer(value));
    }


    template<typename T>
    void Store(struct Pointer<T>* p, T* value)
    {
        Store(gocpp::recv(p->u), unsafe::Pointer(value));
    }


    template<typename T>
    bool CompareAndSwapNoWB(struct Pointer<T>* p, T* old, T* go_new)
    {
        return CompareAndSwapNoWB(gocpp::recv(p->u), unsafe::Pointer(old), unsafe::Pointer(go_new));
    }


    template<typename T>
    bool CompareAndSwap(struct Pointer<T>* p, T* old, T* go_new)
    {
        return CompareAndSwap(gocpp::recv(p->u), unsafe::Pointer(old), unsafe::Pointer(go_new));
    }

    
    std::ostream& noCopy::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value)
    {
        return value.PrintTo(os);
    }

    void Lock(noCopy*)
    {
    }

    void Unlock(noCopy*)
    {
    }

    
    std::ostream& align64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct align64& value)
    {
        return value.PrintTo(os);
    }

}

