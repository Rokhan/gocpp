// generated by GoCpp from file '$(ImportDir)/slices/slices.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/slices/slices.h"
#include "gocpp/support.h"

#include "golang/cmp/cmp.h"
#include "golang/unsafe/unsafe.h"

// Package slices defines various functions useful with slices of any type.
namespace golang::slices
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Equal reports whether two slices are equal: the same length and all
    // elements equal. If the lengths are different, Equal returns false.
    // Otherwise, the elements are compared in increasing index order, and the
    // comparison stops at the first unequal pair.
    // Floating point NaNs are not considered equal.

    template<typename S, typename E>
    bool Equal(S s1, S s2)
    {
        if(len(s1) != len(s2))
        {
            return false;
        }
        for(auto [i, gocpp_ignored] : s1)
        {
            if(s1[i] != s2[i])
            {
                return false;
            }
        }
        return true;
    }

    // EqualFunc reports whether two slices are equal using an equality
    // function on each pair of elements. If the lengths are different,
    // EqualFunc returns false. Otherwise, the elements are compared in
    // increasing index order, and the comparison stops at the first index
    // for which eq returns false.

    template<typename S1, typename S2, typename E1, typename E2>
    bool EqualFunc(S1 s1, S2 s2, std::function<bool (E1 _1, E2 _2)> eq)
    {
        if(len(s1) != len(s2))
        {
            return false;
        }
        for(auto [i, v1] : s1)
        {
            auto v2 = s2[i];
            if(! eq(v1, v2))
            {
                return false;
            }
        }
        return true;
    }

    // Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
    // of elements. The elements are compared sequentially, starting at index 0,
    // until one element is not equal to the other.
    // The result of comparing the first non-matching elements is returned.
    // If both slices are equal until one of them ends, the shorter slice is
    // considered less than the longer one.
    // The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.

    template<typename S, typename E>
    int Compare(S s1, S s2)
    {
        for(auto [i, v1] : s1)
        {
            if(i >= len(s2))
            {
                return + 1;
            }
            auto v2 = s2[i];
            if(auto c = cmp::Compare(v1, v2); c != 0)
            {
                return c;
            }
        }
        if(len(s1) < len(s2))
        {
            return - 1;
        }
        return 0;
    }

    // CompareFunc is like [Compare] but uses a custom comparison function on each
    // pair of elements.
    // The result is the first non-zero result of cmp; if cmp always
    // returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
    // and +1 if len(s1) > len(s2).

    template<typename S1, typename S2, typename E1, typename E2>
    int CompareFunc(S1 s1, S2 s2, std::function<int (E1 _1, E2 _2)> cmp)
    {
        for(auto [i, v1] : s1)
        {
            if(i >= len(s2))
            {
                return + 1;
            }
            auto v2 = s2[i];
            if(auto c = cmp(v1, v2); c != 0)
            {
                return c;
            }
        }
        if(len(s1) < len(s2))
        {
            return - 1;
        }
        return 0;
    }

    // Index returns the index of the first occurrence of v in s,
    // or -1 if not present.

    template<typename S, typename E>
    int Index(S s, E v)
    {
        for(auto [i, gocpp_ignored] : s)
        {
            if(v == s[i])
            {
                return i;
            }
        }
        return - 1;
    }

    // IndexFunc returns the first index i satisfying f(s[i]),
    // or -1 if none do.

    template<typename S, typename E>
    int IndexFunc(S s, std::function<bool (E _1)> f)
    {
        for(auto [i, gocpp_ignored] : s)
        {
            if(f(s[i]))
            {
                return i;
            }
        }
        return - 1;
    }

    // Contains reports whether v is present in s.

    template<typename S, typename E>
    bool Contains(S s, E v)
    {
        return Index(s, v) >= 0;
    }

    // ContainsFunc reports whether at least one
    // element e of s satisfies f(e).

    template<typename S, typename E>
    bool ContainsFunc(S s, std::function<bool (E _1)> f)
    {
        return IndexFunc(s, f) >= 0;
    }

    // Insert inserts the values v... into s at index i,
    // returning the modified slice.
    // The elements at s[i:] are shifted up to make room.
    // In the returned slice r, r[i] == v[0],
    // and r[i+len(v)] == value originally at r[i].
    // Insert panics if i is out of range.
    // This function is O(len(s) + len(v)).

    template<typename S, typename E>
    S Insert(S s, int i, gocpp::slice<E> v)
    {
        _ = s.make_slice(i);
        auto m = len(v);
        if(m == 0)
        {
            return s;
        }
        auto n = len(s);
        if(i == n)
        {
            return append(s, v);
        }
        if(n + m > cap(s))
        {
            auto s2 = append(s.make_slice(0, i), gocpp::make(S, n + m - i));
            copy(s2.make_slice(i), v);
            copy(s2.make_slice(i + m), s.make_slice(i));
            return s2;
        }
        s = s.make_slice(0, n + m);
        if(! overlaps(v, s.make_slice(i + m)))
        {
            copy(s.make_slice(i + m), s.make_slice(i));
            copy(s.make_slice(i), v);
            return s;
        }
        copy(s.make_slice(n), v);
        rotateRight(s.make_slice(i), m);
        return s;
    }

    // Delete removes the elements s[i:j] from s, returning the modified slice.
    // Delete panics if j > len(s) or s[i:j] is not a valid slice of s.
    // Delete is O(len(s)-i), so if many items must be deleted, it is better to
    // make a single call deleting them all together than to delete one at a time.
    // Delete zeroes the elements s[len(s)-(j-i):len(s)].

    template<typename S, typename E>
    S Delete(S s, int i, int j)
    {
        _ = s.make_slice(i, j, len(s));
        if(i == j)
        {
            return s;
        }
        auto oldlen = len(s);
        s = append(s.make_slice(0, i), s.make_slice(j));
        clear(s.make_slice(len(s), oldlen));
        return s;
    }

    // DeleteFunc removes any elements from s for which del returns true,
    // returning the modified slice.
    // DeleteFunc zeroes the elements between the new length and the original length.

    template<typename S, typename E>
    S DeleteFunc(S s, std::function<bool (E _1)> del)
    {
        auto i = IndexFunc(s, del);
        if(i == - 1)
        {
            return s;
        }
        for(auto j = i + 1; j < len(s); j++)
        {
            if(auto v = s[j]; ! del(v))
            {
                s[i] = v;
                i++;
            }
        }
        clear(s.make_slice(i));
        return s.make_slice(0, i);
    }

    // Replace replaces the elements s[i:j] by the given v, and returns the
    // modified slice.
    // Replace panics if j > len(s) or s[i:j] is not a valid slice of s.
    // When len(v) < (j-i), Replace zeroes the elements between the new length and the original length.

    template<typename S, typename E>
    S Replace(S s, int i, int j, gocpp::slice<E> v)
    {
        _ = s.make_slice(i, j);
        if(i == j)
        {
            return Insert(s, i, v);
        }
        if(j == len(s))
        {
            return append(s.make_slice(0, i), v);
        }
        auto tot = len(s.make_slice(0, i)) + len(v) + len(s.make_slice(j));
        if(tot > cap(s))
        {
            auto s2 = append(s.make_slice(0, i), gocpp::make(S, tot - i));
            copy(s2.make_slice(i), v);
            copy(s2.make_slice(i + len(v)), s.make_slice(j));
            return s2;
        }
        auto r = s.make_slice(0, tot);
        if(i + len(v) <= j)
        {
            copy(r.make_slice(i), v);
            copy(r.make_slice(i + len(v)), s.make_slice(j));
            clear(s.make_slice(tot));
            return r;
        }
        if(! overlaps(r.make_slice(i + len(v)), v))
        {
            copy(r.make_slice(i + len(v)), s.make_slice(j));
            copy(r.make_slice(i), v);
            return r;
        }
        auto y = len(v) - (j - i);
        if(! overlaps(r.make_slice(i, j), v))
        {
            copy(r.make_slice(i, j), v.make_slice(y));
            copy(r.make_slice(len(s)), v.make_slice(0, y));
            rotateRight(r.make_slice(i), y);
            return r;
        }
        if(! overlaps(r.make_slice(len(s)), v))
        {
            copy(r.make_slice(len(s)), v.make_slice(0, y));
            copy(r.make_slice(i, j), v.make_slice(y));
            rotateRight(r.make_slice(i), y);
            return r;
        }
        auto k = startIdx(v, s.make_slice(j));
        copy(r.make_slice(i), v);
        copy(r.make_slice(i + len(v)), r.make_slice(i + k));
        return r;
    }

    // Clone returns a copy of the slice.
    // The elements are copied using assignment, so this is a shallow clone.

    template<typename S, typename E>
    S Clone(S s)
    {
        return append(s.make_slice(, 0, 0), s);
    }

    // Compact replaces consecutive runs of equal elements with a single copy.
    // This is like the uniq command found on Unix.
    // Compact modifies the contents of the slice s and returns the modified slice,
    // which may have a smaller length.
    // Compact zeroes the elements between the new length and the original length.

    template<typename S, typename E>
    S Compact(S s)
    {
        if(len(s) < 2)
        {
            return s;
        }
        auto i = 1;
        for(auto k = 1; k < len(s); k++)
        {
            if(s[k] != s[k - 1])
            {
                if(i != k)
                {
                    s[i] = s[k];
                }
                i++;
            }
        }
        clear(s.make_slice(i));
        return s.make_slice(0, i);
    }

    // CompactFunc is like [Compact] but uses an equality function to compare elements.
    // For runs of elements that compare equal, CompactFunc keeps the first one.
    // CompactFunc zeroes the elements between the new length and the original length.

    template<typename S, typename E>
    S CompactFunc(S s, std::function<bool (E _1, E _2)> eq)
    {
        if(len(s) < 2)
        {
            return s;
        }
        auto i = 1;
        for(auto k = 1; k < len(s); k++)
        {
            if(! eq(s[k], s[k - 1]))
            {
                if(i != k)
                {
                    s[i] = s[k];
                }
                i++;
            }
        }
        clear(s.make_slice(i));
        return s.make_slice(0, i);
    }

    // Grow increases the slice's capacity, if necessary, to guarantee space for
    // another n elements. After Grow(n), at least n elements can be appended
    // to the slice without another allocation. If n is negative or too large to
    // allocate the memory, Grow panics.

    template<typename S, typename E>
    S Grow(S s, int n)
    {
        if(n < 0)
        {
            gocpp::panic("cannot be negative"s);
        }
        if(n -= cap(s) - len(s); n > 0)
        {
            s = append(s.make_slice(0, cap(s)), gocpp::make(gocpp::Tag<gocpp::slice<E>>(), n)).make_slice(0, len(s));
        }
        return s;
    }

    // Clip removes unused capacity from the slice, returning s[:len(s):len(s)].

    template<typename S, typename E>
    S Clip(S s)
    {
        return s.make_slice(, len(s), len(s));
    }

    // rotateLeft rotates b left by n spaces.
    // s_final[i] = s_orig[i+r], wrapping around.

    template<typename E>
    void rotateLeft(gocpp::slice<E> s, int r)
    {
        for(; r != 0 && r != len(s); )
        {
            if(r * 2 <= len(s))
            {
                swap(s.make_slice(0, r), s.make_slice(len(s) - r));
                s = s.make_slice(0, len(s) - r);
            }
            else
            {
                swap(s.make_slice(0, len(s) - r), s.make_slice(r));
                std::tie(s, r) = std::tuple{s.make_slice(len(s) - r), r * 2 - len(s)};
            }
        }
    }


    template<typename E>
    void rotateRight(gocpp::slice<E> s, int r)
    {
        rotateLeft(s, len(s) - r);
    }

    // swap swaps the contents of x and y. x and y must be equal length and disjoint.

    template<typename E>
    void swap(gocpp::slice<E> x, gocpp::slice<E> y)
    {
        for(auto i = 0; i < len(x); i++)
        {
            std::tie(x[i], y[i]) = std::tuple{y[i], x[i]};
        }
    }

    // overlaps reports whether the memory ranges a[0:len(a)] and b[0:len(b)] overlap.

    template<typename E>
    bool overlaps(gocpp::slice<E> a, gocpp::slice<E> b)
    {
        if(len(a) == 0 || len(b) == 0)
        {
            return false;
        }
        auto elemSize = gocpp::Sizeof<E>();
        if(elemSize == 0)
        {
            return false;
        }
        return uintptr_t(unsafe::Pointer(& a[0])) <= uintptr_t(unsafe::Pointer(& b[len(b) - 1])) + (elemSize - 1) && uintptr_t(unsafe::Pointer(& b[0])) <= uintptr_t(unsafe::Pointer(& a[len(a) - 1])) + (elemSize - 1);
    }

    // startIdx returns the index in haystack where the needle starts.
    // prerequisite: the needle must be aliased entirely inside the haystack.

    template<typename E>
    int startIdx(gocpp::slice<E> haystack, gocpp::slice<E> needle)
    {
        auto p = & needle[0];
        for(auto [i, gocpp_ignored] : haystack)
        {
            if(p == & haystack[i])
            {
                return i;
            }
        }
        gocpp::panic("needle not found"s);
    }

    // Reverse reverses the elements of the slice in place.

    template<typename S, typename E>
    void Reverse(S s)
    {
        for(auto [i, j] = std::tuple{0, len(s) - 1}; i < j; std::tie(i, j) = std::tuple{i + 1, j - 1})
        {
            std::tie(s[i], s[j]) = std::tuple{s[j], s[i]};
        }
    }

    // Concat returns a new slice concatenating the passed in slices.

    template<typename S, typename E>
    S Concat(gocpp::slice<S> slices)
    {
        auto size = 0;
        for(auto [gocpp_ignored, s] : slices)
        {
            size += len(s);
            if(size < 0)
            {
                gocpp::panic("len out of range"s);
            }
        }
        auto newslice = Grow<S>(nullptr, size);
        for(auto [gocpp_ignored, s] : slices)
        {
            newslice = append(newslice, s);
        }
        return newslice;
    }

}

