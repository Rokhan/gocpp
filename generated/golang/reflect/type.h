// generated by GoCpp from file '$(ImportDir)/reflect/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/type.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/value.h"
#include "golang/sync/atomic/type.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"

namespace golang::reflect
{
    struct Type : gocpp::Interface
    {
        Type(){}
        Type(Type& i) = default;
        Type(const Type& i) = default;
        Type& operator=(Type& i) = default;
        Type& operator=(const Type& i) = default;

        template<typename T>
        Type(T& ref);

        template<typename T>
        Type(const T& ref);

        template<typename T>
        Type(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IType
        {
            virtual int vAlign() = 0;
            virtual int vFieldAlign() = 0;
            virtual struct Method vMethod(int) = 0;
            virtual std::tuple<struct Method, bool> vMethodByName(std::string) = 0;
            virtual int vNumMethod() = 0;
            virtual std::string vName() = 0;
            virtual std::string vPkgPath() = 0;
            virtual uintptr_t vSize() = 0;
            virtual std::string vString() = 0;
            virtual reflect::Kind vKind() = 0;
            virtual bool vImplements(struct Type u) = 0;
            virtual bool vAssignableTo(struct Type u) = 0;
            virtual bool vConvertibleTo(struct Type u) = 0;
            virtual bool vComparable() = 0;
            virtual int vBits() = 0;
            virtual reflect::ChanDir vChanDir() = 0;
            virtual bool vIsVariadic() = 0;
            virtual struct Type vElem() = 0;
            virtual struct StructField vField(int i) = 0;
            virtual struct StructField vFieldByIndex(gocpp::slice<int> index) = 0;
            virtual std::tuple<struct StructField, bool> vFieldByName(std::string name) = 0;
            virtual std::tuple<struct StructField, bool> vFieldByNameFunc(std::function<bool (std::string)> match) = 0;
            virtual struct Type vIn(int i) = 0;
            virtual struct Type vKey() = 0;
            virtual int vLen() = 0;
            virtual int vNumField() = 0;
            virtual int vNumIn() = 0;
            virtual int vNumOut() = 0;
            virtual struct Type vOut(int i) = 0;
            virtual abi::Type* vcommon() = 0;
            virtual reflect::uncommonType* vuncommon() = 0;
        };

        template<typename T, typename StoreT>
        struct TypeImpl : IType
        {
            explicit TypeImpl(T* ptr)
            {
                value.reset(ptr);
            }

            int vAlign() override;

            int vFieldAlign() override;

            struct Method vMethod(int) override;

            std::tuple<struct Method, bool> vMethodByName(std::string) override;

            int vNumMethod() override;

            std::string vName() override;

            std::string vPkgPath() override;

            uintptr_t vSize() override;

            std::string vString() override;

            reflect::Kind vKind() override;

            bool vImplements(struct Type u) override;

            bool vAssignableTo(struct Type u) override;

            bool vConvertibleTo(struct Type u) override;

            bool vComparable() override;

            int vBits() override;

            reflect::ChanDir vChanDir() override;

            bool vIsVariadic() override;

            struct Type vElem() override;

            struct StructField vField(int i) override;

            struct StructField vFieldByIndex(gocpp::slice<int> index) override;

            std::tuple<struct StructField, bool> vFieldByName(std::string name) override;

            std::tuple<struct StructField, bool> vFieldByNameFunc(std::function<bool (std::string)> match) override;

            struct Type vIn(int i) override;

            struct Type vKey() override;

            int vLen() override;

            int vNumField() override;

            int vNumIn() override;

            int vNumOut() override;

            struct Type vOut(int i) override;

            abi::Type* vcommon() override;

            reflect::uncommonType* vuncommon() override;

            StoreT value;
        };

        std::shared_ptr<IType> value;
    };

    namespace rec
    {
        int Align(const gocpp::PtrRecv<struct Type, false>& self);
        int Align(const gocpp::ObjRecv<struct Type>& self);

        int FieldAlign(const gocpp::PtrRecv<struct Type, false>& self);
        int FieldAlign(const gocpp::ObjRecv<struct Type>& self);

        struct Method Method(const gocpp::PtrRecv<struct Type, false>& self, int);
        struct Method Method(const gocpp::ObjRecv<struct Type>& self, int);

        std::tuple<struct Method, bool> MethodByName(const gocpp::PtrRecv<struct Type, false>& self, std::string);
        std::tuple<struct Method, bool> MethodByName(const gocpp::ObjRecv<struct Type>& self, std::string);

        int NumMethod(const gocpp::PtrRecv<struct Type, false>& self);
        int NumMethod(const gocpp::ObjRecv<struct Type>& self);

        std::string Name(const gocpp::PtrRecv<struct Type, false>& self);
        std::string Name(const gocpp::ObjRecv<struct Type>& self);

        std::string PkgPath(const gocpp::PtrRecv<struct Type, false>& self);
        std::string PkgPath(const gocpp::ObjRecv<struct Type>& self);

        uintptr_t Size(const gocpp::PtrRecv<struct Type, false>& self);
        uintptr_t Size(const gocpp::ObjRecv<struct Type>& self);

        std::string String(const gocpp::PtrRecv<struct Type, false>& self);
        std::string String(const gocpp::ObjRecv<struct Type>& self);

        reflect::Kind Kind(const gocpp::PtrRecv<struct Type, false>& self);
        reflect::Kind Kind(const gocpp::ObjRecv<struct Type>& self);

        bool Implements(const gocpp::PtrRecv<struct Type, false>& self, struct Type u);
        bool Implements(const gocpp::ObjRecv<struct Type>& self, struct Type u);

        bool AssignableTo(const gocpp::PtrRecv<struct Type, false>& self, struct Type u);
        bool AssignableTo(const gocpp::ObjRecv<struct Type>& self, struct Type u);

        bool ConvertibleTo(const gocpp::PtrRecv<struct Type, false>& self, struct Type u);
        bool ConvertibleTo(const gocpp::ObjRecv<struct Type>& self, struct Type u);

        bool Comparable(const gocpp::PtrRecv<struct Type, false>& self);
        bool Comparable(const gocpp::ObjRecv<struct Type>& self);

        int Bits(const gocpp::PtrRecv<struct Type, false>& self);
        int Bits(const gocpp::ObjRecv<struct Type>& self);

        reflect::ChanDir ChanDir(const gocpp::PtrRecv<struct Type, false>& self);
        reflect::ChanDir ChanDir(const gocpp::ObjRecv<struct Type>& self);

        bool IsVariadic(const gocpp::PtrRecv<struct Type, false>& self);
        bool IsVariadic(const gocpp::ObjRecv<struct Type>& self);

        struct Type Elem(const gocpp::PtrRecv<struct Type, false>& self);
        struct Type Elem(const gocpp::ObjRecv<struct Type>& self);

        struct StructField Field(const gocpp::PtrRecv<struct Type, false>& self, int i);
        struct StructField Field(const gocpp::ObjRecv<struct Type>& self, int i);

        struct StructField FieldByIndex(const gocpp::PtrRecv<struct Type, false>& self, gocpp::slice<int> index);
        struct StructField FieldByIndex(const gocpp::ObjRecv<struct Type>& self, gocpp::slice<int> index);

        std::tuple<struct StructField, bool> FieldByName(const gocpp::PtrRecv<struct Type, false>& self, std::string name);
        std::tuple<struct StructField, bool> FieldByName(const gocpp::ObjRecv<struct Type>& self, std::string name);

        std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::PtrRecv<struct Type, false>& self, std::function<bool (std::string)> match);
        std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::ObjRecv<struct Type>& self, std::function<bool (std::string)> match);

        struct Type In(const gocpp::PtrRecv<struct Type, false>& self, int i);
        struct Type In(const gocpp::ObjRecv<struct Type>& self, int i);

        struct Type Key(const gocpp::PtrRecv<struct Type, false>& self);
        struct Type Key(const gocpp::ObjRecv<struct Type>& self);

        int Len(const gocpp::PtrRecv<struct Type, false>& self);
        int Len(const gocpp::ObjRecv<struct Type>& self);

        int NumField(const gocpp::PtrRecv<struct Type, false>& self);
        int NumField(const gocpp::ObjRecv<struct Type>& self);

        int NumIn(const gocpp::PtrRecv<struct Type, false>& self);
        int NumIn(const gocpp::ObjRecv<struct Type>& self);

        int NumOut(const gocpp::PtrRecv<struct Type, false>& self);
        int NumOut(const gocpp::ObjRecv<struct Type>& self);

        struct Type Out(const gocpp::PtrRecv<struct Type, false>& self, int i);
        struct Type Out(const gocpp::ObjRecv<struct Type>& self, int i);

        abi::Type* common(const gocpp::PtrRecv<struct Type, false>& self);
        abi::Type* common(const gocpp::ObjRecv<struct Type>& self);

        reflect::uncommonType* uncommon(const gocpp::PtrRecv<struct Type, false>& self);
        reflect::uncommonType* uncommon(const gocpp::ObjRecv<struct Type>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    struct common
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct common& value);
    struct rtype
    {
        abi::Type t;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct rtype& value);
    struct interfaceType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct interfaceType& value);
    abi::Name nameOffFor(abi::Type* t, golang::reflect::aNameOff off);
    abi::Type* typeOffFor(abi::Type* t, golang::reflect::aTypeOff off);
    struct mapType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapType& value);
    struct ptrType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ptrType& value);
    struct sliceType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sliceType& value);
    struct structType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structType& value);
    std::string pkgPath(abi::Name n);
    abi::Name newName(std::string n, std::string tag, bool exported, bool embedded);
    struct Method
    {
        std::string Name;
        std::string PkgPath;
        Type Type;
        /* Value Func; [Known incomplete type] */
        int Index;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Method& value);
    extern gocpp::slice<std::string> kindNames;
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off);
    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off);
    unsafe::Pointer resolveTextOff(unsafe::Pointer rtype, int32_t off);
    int32_t addReflectOff(unsafe::Pointer ptr);
    reflect::aNameOff resolveReflectName(abi::Name n);
    reflect::aTypeOff resolveReflectType(abi::Type* t);
    reflect::aTextOff resolveReflectText(unsafe::Pointer ptr);
    unsafe::Pointer textOffFor(abi::Type* t, golang::reflect::aTextOff off);
    std::string pkgPathFor(abi::Type* t);
    std::string nameFor(abi::Type* t);
    struct rtype* toRType(abi::Type* t);
    abi::Type* elem(abi::Type* t);
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    struct StructField
    {
        std::string Name;
        std::string PkgPath;
        Type Type;
        golang::reflect::StructTag Tag;
        uintptr_t Offset;
        gocpp::slice<int> Index;
        bool Anonymous;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructField& value);
    struct fieldScan
    {
        structType* typ;
        gocpp::slice<int> index;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct fieldScan& value);
    struct Type TypeOf(go_any i);
    abi::Type* rtypeOf(go_any i);
    struct Type PtrTo(struct Type t);
    struct Type PointerTo(struct Type t);
    abi::Type* ptrTo(abi::Type* t);
    uint32_t fnv1(uint32_t x, gocpp::slice<unsigned char> list);
    
    template<typename... Args>
    uint32_t fnv1(uint32_t x, Args... list)
    {
        return fnv1(x, gocpp::ToSlice<unsigned char>(list...));
    }
    
    template<typename... Args>
    uint32_t fnv1(uint32_t x, unsigned char value, Args... list)
    {
        return fnv1(x, gocpp::ToSlice<unsigned char>(value, list...));
    }
    bool implements(abi::Type* T, abi::Type* V);
    bool specialChannelAssignability(abi::Type* T, abi::Type* V);
    bool directlyAssignable(abi::Type* T, abi::Type* V);
    bool haveIdenticalType(abi::Type* T, abi::Type* V, bool cmpTags);
    bool haveIdenticalUnderlyingType(abi::Type* T, abi::Type* V, bool cmpTags);
    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> typelinks();
    abi::Type* rtypeOff(unsafe::Pointer section, int32_t off);
    gocpp::slice<abi::Type*> typesByString(std::string s);
    struct cacheKey
    {
        golang::reflect::Kind kind;
        abi::Type* t1;
        abi::Type* t2;
        uintptr_t extra;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cacheKey& value);
    struct Type ChanOf(golang::reflect::ChanDir dir, struct Type t);
    struct Type MapOf(struct Type key, struct Type elem);
    struct Type initFuncTypes(int n);
    struct Type FuncOf(gocpp::slice<Type> in, gocpp::slice<Type> out, bool variadic);
    std::string stringFor(abi::Type* t);
    std::string funcStr(golang::reflect::funcType* ft);
    bool isReflexive(abi::Type* t);
    bool needKeyUpdate(abi::Type* t);
    bool hashMightPanic(abi::Type* t);
    abi::Type* bucketOf(abi::Type* ktyp, abi::Type* etyp);
    void emitGCMask(gocpp::slice<unsigned char> out, uintptr_t base, abi::Type* typ, uintptr_t n);
    gocpp::slice<unsigned char> appendGCProg(gocpp::slice<unsigned char> dst, abi::Type* typ);
    struct Type SliceOf(struct Type t);
    struct structTypeUncommon
    {
        golang::reflect::uncommonType u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value);
    bool isLetter(gocpp::rune ch);
    bool isValidFieldName(std::string fieldName);
    struct Type StructOf(gocpp::slice<StructField> fields);
    void embeddedIfaceMethStub();
    std::tuple<reflect::structField, std::string> runtimeStructField(struct StructField field);
    uintptr_t typeptrdata(abi::Type* t);
    struct Type ArrayOf(int length, struct Type elem);
    gocpp::slice<unsigned char> appendVarint(gocpp::slice<unsigned char> x, uintptr_t v);
    struct Type toType(abi::Type* t);
    struct layoutKey
    {
        golang::reflect::funcType* ftyp;
        abi::Type* rcvr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct layoutKey& value);
    struct layoutType
    {
        abi::Type* t;
        sync::Pool* framePool;
        abiDesc abid;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct layoutType& value);
    std::tuple<abi::Type*, sync::Pool*, struct abiDesc> funcLayout(golang::reflect::funcType* t, abi::Type* rcvr);
    bool ifaceIndir(abi::Type* t);
    struct bitVector
    {
        uint32_t n;
        gocpp::slice<unsigned char> data;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bitVector& value);
    void addTypeBits(struct bitVector* bv, uintptr_t offset, abi::Type* t);
    
    template<typename T>
    struct Type TypeFor();

    namespace rec
    {
        abi::Type* common(struct rtype* t);
        abi::UncommonType* uncommon(struct rtype* t);
        abi::Name nameOff(struct interfaceType* t, golang::reflect::aNameOff off);
        abi::Type* typeOff(struct interfaceType* t, golang::reflect::aTypeOff off);
        abi::Type* common(struct interfaceType* t);
        abi::UncommonType* uncommon(struct interfaceType* t);
        bool IsExported(struct Method m);
        std::string String(golang::reflect::Kind k);
        abi::Name nameOff(struct rtype* t, golang::reflect::aNameOff off);
        abi::Type* typeOff(struct rtype* t, golang::reflect::aTypeOff off);
        unsafe::Pointer textOff(struct rtype* t, golang::reflect::aTextOff off);
        std::string String(struct rtype* t);
        uintptr_t Size(struct rtype* t);
        int Bits(struct rtype* t);
        int Align(struct rtype* t);
        int FieldAlign(struct rtype* t);
        reflect::Kind Kind(struct rtype* t);
        gocpp::slice<abi::Method> exportedMethods(struct rtype* t);
        int NumMethod(struct rtype* t);
        struct Method Method(struct rtype* t, int i);
        std::tuple<struct Method, bool> MethodByName(struct rtype* t, std::string name);
        std::string PkgPath(struct rtype* t);
        std::string Name(struct rtype* t);
        reflect::ChanDir ChanDir(struct rtype* t);
        struct Type Elem(struct rtype* t);
        struct StructField Field(struct rtype* t, int i);
        struct StructField FieldByIndex(struct rtype* t, gocpp::slice<int> index);
        std::tuple<struct StructField, bool> FieldByName(struct rtype* t, std::string name);
        std::tuple<struct StructField, bool> FieldByNameFunc(struct rtype* t, std::function<bool (std::string)> match);
        struct Type Key(struct rtype* t);
        int Len(struct rtype* t);
        int NumField(struct rtype* t);
        struct Type In(struct rtype* t, int i);
        int NumIn(struct rtype* t);
        int NumOut(struct rtype* t);
        struct Type Out(struct rtype* t, int i);
        bool IsVariadic(struct rtype* t);
        std::string String(golang::reflect::ChanDir d);
        struct Method Method(struct interfaceType* t, int i);
        int NumMethod(struct interfaceType* t);
        std::tuple<struct Method, bool> MethodByName(struct interfaceType* t, std::string name);
        bool IsExported(struct StructField f);
        std::string Get(golang::reflect::StructTag tag, std::string key);
        std::tuple<std::string, bool> Lookup(golang::reflect::StructTag tag, std::string key);
        struct StructField Field(struct structType* t, int i);
        struct StructField FieldByIndex(struct structType* t, gocpp::slice<int> index);
        std::tuple<struct StructField, bool> FieldByNameFunc(struct structType* t, std::function<bool (std::string)> match);
        std::tuple<struct StructField, bool> FieldByName(struct structType* t, std::string name);
        abi::Type* ptrTo(struct rtype* t);
        bool Implements(struct rtype* t, struct Type u);
        bool AssignableTo(struct rtype* t, struct Type u);
        bool ConvertibleTo(struct rtype* t, struct Type u);
        bool Comparable(struct rtype* t);
        gocpp::slice<unsigned char> gcSlice(struct rtype* t, uintptr_t begin, uintptr_t end);
        void append(struct bitVector* bv, uint8_t bit);
    }
}

