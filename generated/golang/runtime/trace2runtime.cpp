// generated by GoCpp from file '$(ImportDir)/runtime/trace2runtime.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2runtime.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    
    std::ostream& gTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gTraceState& value)
    {
        return value.PrintTo(os);
    }

    void reset(struct gTraceState* s)
    {
        s->seq = gocpp::array<uint64_t, 2> {};
    }

    
    std::ostream& mTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << seqlock;
        os << " " << buf;
        os << " " << link;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mTraceState& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& pTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mSyscallID;
        os << " " << maySweep;
        os << " " << inSweep;
        os << " " << swept;
        os << " " << reclaimed;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pTraceState& value)
    {
        return value.PrintTo(os);
    }

    void traceLockInit()
    {
        lockInit(& trace.stringTab[0].lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[0].tab.lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[1].lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[1].tab.lock, lockRankTraceStrings);
        lockInit(& trace.stackTab[0].tab.lock, lockRankTraceStackTab);
        lockInit(& trace.stackTab[1].tab.lock, lockRankTraceStackTab);
        lockInit(& trace.lock, lockRankTrace);
    }

    void lockRankMayTraceFlush()
    {
        lockWithRankMayAcquire(& trace.lock, getLockRank(& trace.lock));
    }

    gocpp::array_base<std::string> traceBlockReasonStrings = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.traceBlockGeneric = "unspecified"; x.traceBlockForever = "forever"; x.traceBlockNet = "network"; x.traceBlockSelect = "select"; x.traceBlockCondWait = "sync.(*Cond).Wait"; x.traceBlockSync = "sync"; x.traceBlockChanSend = "chan send"; x.traceBlockChanRecv = "chan receive"; x.traceBlockGCMarkAssist = "GC mark assist wait for work"; x.traceBlockGCSweep = "GC background sweeper wait"; x.traceBlockSystemGoroutine = "system goroutine wait"; x.traceBlockPreempted = "preempted"; x.traceBlockDebugCall = "wait for debug call"; x.traceBlockUntilGCEnds = "wait until GC ends"; x.traceBlockSleep = "sleep"; });
    gocpp::array_base<std::string> traceGoStopReasonStrings = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.traceGoStopGeneric = "unspecified"; x.traceGoStopGoSched = "runtime.Gosched"; x.traceGoStopPreempted = "preempted"; });
    bool traceEnabled()
    {
        return Load(gocpp::recv(trace.gen)) != 0;
    }

    bool traceShuttingDown()
    {
        return Load(gocpp::recv(trace.shutdown));
    }

    
    std::ostream& traceLocker::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mp;
        os << " " << gen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceLocker& value)
    {
        return value.PrintTo(os);
    }

    traceLocker traceAcquire()
    {
        if(! traceEnabled())
        {
            return traceLocker {};
        }
        return traceAcquireEnabled();
    }

    traceLocker traceAcquireEnabled()
    {
        lockRankMayTraceFlush();
        auto mp = acquirem();
        auto seq = Add(gocpp::recv(mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 1)
        {
            go_throw("bad use of trace.seqlock or tracer is reentrant");
        }
        auto gen = Load(gocpp::recv(trace.gen));
        if(gen == 0)
        {
            Add(gocpp::recv(mp->trace.seqlock), 1);
            releasem(mp);
            return traceLocker {};
        }
        return traceLocker {mp, gen};
    }

    bool ok(struct traceLocker tl)
    {
        return tl.gen != 0;
    }

    void traceRelease(traceLocker tl)
    {
        auto seq = Add(gocpp::recv(tl.mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 0)
        {
            print("runtime: seq=", seq, "\n");
            go_throw("bad use of trace.seqlock");
        }
        releasem(tl.mp);
    }

    void traceExitingSyscall()
    {
        Add(gocpp::recv(trace.exitingSyscall), 1);
    }

    void traceExitedSyscall()
    {
        Add(gocpp::recv(trace.exitingSyscall), - 1);
    }

    void Gomaxprocs(struct traceLocker tl, int32_t procs)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvProcsChange, traceArg(procs), stack(gocpp::recv(tl), 1));
    }

    void ProcStart(struct traceLocker tl)
    {
        auto pp = ptr(gocpp::recv(tl.mp->p));
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcIdle)), traceEvProcStart, traceArg(pp->id), nextSeq(gocpp::recv(pp->trace), tl.gen));
    }

    void ProcStop(struct traceLocker tl, p* pp)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcRunning)), traceEvProcStop);
    }

    void GCActive(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCActive, traceArg(trace.seqGC));
        trace.seqGC++;
    }

    void GCStart(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCBegin, traceArg(trace.seqGC), stack(gocpp::recv(tl), 3));
        trace.seqGC++;
    }

    void GCDone(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCEnd, traceArg(trace.seqGC));
        trace.seqGC++;
    }

    void STWStart(struct traceLocker tl, stwReason reason)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvSTWBegin, string(gocpp::recv(tl), String(gocpp::recv(reason))), stack(gocpp::recv(tl), 2));
    }

    void STWDone(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvSTWEnd);
    }

    void GCSweepStart(struct traceLocker tl)
    {
        auto pp = ptr(gocpp::recv(tl.mp->p));
        if(pp->trace.maySweep)
        {
            go_throw("double traceGCSweepStart");
        }
        std::tie(pp->trace.maySweep, pp->trace.swept, pp->trace.reclaimed) = std::tuple{true, 0, 0};
    }

    void GCSweepSpan(struct traceLocker tl, uintptr_t bytesSwept)
    {
        auto pp = ptr(gocpp::recv(tl.mp->p));
        if(pp->trace.maySweep)
        {
            if(pp->trace.swept == 0)
            {
                commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCSweepBegin, stack(gocpp::recv(tl), 1));
                pp->trace.inSweep = true;
            }
            pp->trace.swept += bytesSwept;
        }
    }

    void GCSweepDone(struct traceLocker tl)
    {
        auto pp = ptr(gocpp::recv(tl.mp->p));
        if(! pp->trace.maySweep)
        {
            go_throw("missing traceGCSweepStart");
        }
        if(pp->trace.inSweep)
        {
            commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCSweepEnd, traceArg(pp->trace.swept), traceArg(pp->trace.reclaimed));
            pp->trace.inSweep = false;
        }
        pp->trace.maySweep = false;
    }

    void GCMarkAssistStart(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCMarkAssistBegin, stack(gocpp::recv(tl), 1));
    }

    void GCMarkAssistDone(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCMarkAssistEnd);
    }

    void GoCreate(struct traceLocker tl, g* newg, uintptr_t pc)
    {
        setStatusTraced(gocpp::recv(newg->trace), tl.gen);
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoCreate, traceArg(newg->goid), startPC(gocpp::recv(tl), pc), stack(gocpp::recv(tl), 2));
    }

    void GoStart(struct traceLocker tl)
    {
        auto gp = getg()->m->curg;
        auto pp = gp->m->p;
        auto w = eventWriter(gocpp::recv(tl), traceGoRunnable, traceProcRunning);
        w = write(gocpp::recv(w), traceEvGoStart, traceArg(gp->goid), nextSeq(gocpp::recv(gp->trace), tl.gen));
        if(ptr(gocpp::recv(pp))->gcMarkWorkerMode != gcMarkWorkerNotWorker)
        {
            w = write(gocpp::recv(w), traceEvGoLabel, trace.markWorkerLabels[tl.gen % 2][ptr(gocpp::recv(pp))->gcMarkWorkerMode]);
        }
        end(gocpp::recv(w));
    }

    void GoEnd(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoDestroy);
    }

    void GoSched(struct traceLocker tl)
    {
        GoStop(gocpp::recv(tl), traceGoStopGoSched);
    }

    void GoPreempt(struct traceLocker tl)
    {
        GoStop(gocpp::recv(tl), traceGoStopPreempted);
    }

    void GoStop(struct traceLocker tl, traceGoStopReason reason)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoStop, traceArg(trace.goStopReasons[tl.gen % 2][reason]), stack(gocpp::recv(tl), 1));
    }

    void GoPark(struct traceLocker tl, traceBlockReason reason, int skip)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoBlock, traceArg(trace.goBlockReasons[tl.gen % 2][reason]), stack(gocpp::recv(tl), skip));
    }

    void GoUnpark(struct traceLocker tl, g* gp, int skip)
    {
        auto w = eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning);
        if(! statusWasTraced(gocpp::recv(gp->trace), tl.gen) && acquireStatus(gocpp::recv(gp->trace), tl.gen))
        {
            w.w = writeGoStatus(gocpp::recv(w.w), gp->goid, - 1, traceGoWaiting, gp->inMarkAssist);
        }
        commit(gocpp::recv(w), traceEvGoUnblock, traceArg(gp->goid), nextSeq(gocpp::recv(gp->trace), tl.gen), stack(gocpp::recv(tl), skip));
    }

    void GoSysCall(struct traceLocker tl)
    {
        int skip = {};
        //Go switch emulation
        {
            int conditionId = -1;
            if(tracefpunwindoff()) { conditionId = 0; }
            else if(GOOS == "solaris" || GOOS == "illumos") { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    skip = 1;
                    break;
                case 1:
                    skip = 3;
                    break;
                default:
                    skip = 4;
                    break;
            }
        }
        auto pp = ptr(gocpp::recv(tl.mp->p));
        pp->trace.mSyscallID = int64_t(tl.mp->procid);
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoSyscallBegin, nextSeq(gocpp::recv(pp->trace), tl.gen), stack(gocpp::recv(tl), skip));
    }

    void GoSysExit(struct traceLocker tl, bool lostP)
    {
        auto ev = traceEvGoSyscallEnd;
        auto procStatus = traceProcSyscall;
        if(lostP)
        {
            ev = traceEvGoSyscallEndBlocked;
            procStatus = traceProcRunning;
        }
        else
        {
            ptr(gocpp::recv(tl.mp->p))->trace.mSyscallID = - 1;
        }
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoSyscall, procStatus)), ev);
    }

    void ProcSteal(struct traceLocker tl, p* pp, bool inSyscall)
    {
        auto mStolenFrom = pp->trace.mSyscallID;
        pp->trace.mSyscallID = - 1;
        auto goStatus = traceGoRunning;
        auto procStatus = traceProcRunning;
        if(inSyscall)
        {
            goStatus = traceGoSyscall;
            procStatus = traceProcSyscallAbandoned;
        }
        auto w = eventWriter(gocpp::recv(tl), goStatus, procStatus);
        if(! statusWasTraced(gocpp::recv(pp->trace), tl.gen) && acquireStatus(gocpp::recv(pp->trace), tl.gen))
        {
            w.w = writeProcStatus(gocpp::recv(w.w), uint64_t(pp->id), traceProcSyscallAbandoned, pp->trace.inSweep);
        }
        commit(gocpp::recv(w), traceEvProcSteal, traceArg(pp->id), nextSeq(gocpp::recv(pp->trace), tl.gen), traceArg(mStolenFrom));
    }

    void GoSysBlock(struct traceLocker tl, p* pp)
    {
    }

    void HeapAlloc(struct traceLocker tl, uint64_t live)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvHeapAlloc, traceArg(live));
    }

    void HeapGoal(struct traceLocker tl)
    {
        auto heapGoal = heapGoal(gocpp::recv(gcController));
        if(heapGoal == ~ uint64_t(0))
        {
            heapGoal = 0;
        }
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvHeapGoal, traceArg(heapGoal));
    }

    void OneNewExtraM(struct traceLocker tl, g* _)
    {
    }

    void GoCreateSyscall(struct traceLocker tl, g* gp)
    {
        setStatusTraced(gocpp::recv(gp->trace), tl.gen);
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoBad, traceProcBad)), traceEvGoCreateSyscall, traceArg(gp->goid));
    }

    void GoDestroySyscall(struct traceLocker tl)
    {
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcBad)), traceEvGoDestroySyscall);
    }

    void trace_userTaskCreate(uint64_t id, uint64_t parentID, std::string taskType)
    {
        auto tl = traceAcquire();
        if(! ok(gocpp::recv(tl)))
        {
            return;
        }
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserTaskBegin, traceArg(id), traceArg(parentID), string(gocpp::recv(tl), taskType), stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    void trace_userTaskEnd(uint64_t id)
    {
        auto tl = traceAcquire();
        if(! ok(gocpp::recv(tl)))
        {
            return;
        }
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserTaskEnd, traceArg(id), stack(gocpp::recv(tl), 2));
        traceRelease(tl);
    }

    void trace_userRegion(uint64_t id, uint64_t mode, std::string name)
    {
        auto tl = traceAcquire();
        if(! ok(gocpp::recv(tl)))
        {
            return;
        }
        traceEv ev = {};
        //Go switch emulation
        {
            auto condition = mode;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    ev = traceEvUserRegionBegin;
                    break;
                case 1:
                    ev = traceEvUserRegionEnd;
                    break;
                default:
                    return;
                    break;
            }
        }
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), ev, traceArg(id), string(gocpp::recv(tl), name), stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    void trace_userLog(uint64_t id, std::string category, std::string message)
    {
        auto tl = traceAcquire();
        if(! ok(gocpp::recv(tl)))
        {
            return;
        }
        commit(gocpp::recv(eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserLog, traceArg(id), string(gocpp::recv(tl), category), uniqueString(gocpp::recv(tl), message), stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    void traceProcFree(p* _)
    {
    }

    void traceThreadDestroy(m* mp)
    {
        assertLockHeld(& sched.lock);
        auto seq = Add(gocpp::recv(mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 1)
        {
            go_throw("bad use of trace.seqlock or tracer is reentrant");
        }
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            for(auto [i, gocpp_ignored] : mp->trace.buf)
            {
                if(mp->trace.buf[i] != nullptr)
                {
                    traceBufFlush(mp->trace.buf[i], uintptr_t(i));
                    mp->trace.buf[i] = nullptr;
                }
            }
            unlock(& trace.lock);
        });
        auto seq1 = Add(gocpp::recv(mp->trace.seqlock), 1);
        if(seq1 != seq + 1)
        {
            print("runtime: seq1=", seq1, "\n");
            go_throw("bad use of trace.seqlock");
        }
    }

    void RecordSyscallExitedTime(struct traceLocker _, g* _, p* _)
    {
    }

}

