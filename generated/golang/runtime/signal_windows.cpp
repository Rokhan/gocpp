// generated by GoCpp from file '$(ImportDir)/runtime/signal_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/signal_windows.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/arena.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/defs_windows.h"
#include "golang/runtime/defs_windows_amd64.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/preempt.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    void preventErrorDialogs()
    {
        auto errormode = stdcall0(_GetErrorMode);
        stdcall1(_SetErrorMode, errormode | _SEM_FAILCRITICALERRORS | _SEM_NOGPFAULTERRORBOX | _SEM_NOOPENFILEERRORBOX);
        uintptr_t werflags = {};
        stdcall2(_WerGetFlags, currentProcess, uintptr_t(unsafe::Pointer(& werflags)));
        stdcall1(_WerSetFlags, werflags | _WER_FAULT_REPORTING_NO_UI);
    }

    void enableWER()
    {
        auto errormode = stdcall0(_GetErrorMode);
        if(errormode & _SEM_NOGPFAULTERRORBOX != 0)
        {
            stdcall1(_SetErrorMode, errormode ^ _SEM_NOGPFAULTERRORBOX);
        }
    }

    void exceptiontramp()
    /* convertBlockStmt, nil block */;

    void firstcontinuetramp()
    /* convertBlockStmt, nil block */;

    void lastcontinuetramp()
    /* convertBlockStmt, nil block */;

    void sehtramp()
    /* convertBlockStmt, nil block */;

    void sigresume()
    /* convertBlockStmt, nil block */;

    void initExceptionHandler()
    {
        stdcall2(_AddVectoredExceptionHandler, 1, abi::FuncPCABI0(exceptiontramp));
        if(GOARCH == "386"s)
        {
            stdcall1(_SetUnhandledExceptionFilter, abi::FuncPCABI0(lastcontinuetramp));
        }
        else
        {
            stdcall2(_AddVectoredContinueHandler, 1, abi::FuncPCABI0(firstcontinuetramp));
            stdcall2(_AddVectoredContinueHandler, 0, abi::FuncPCABI0(lastcontinuetramp));
        }
    }

    bool isAbort(struct context* r)
    {
        auto pc = rec::ip(gocpp::recv(r));
        if(GOARCH == "386"s || GOARCH == "amd64"s || GOARCH == "arm"s)
        {
            pc--;
        }
        return isAbortPC(pc);
    }

    bool isgoexception(struct exceptionrecord* info, struct context* r)
    {
        if(rec::ip(gocpp::recv(r)) < firstmoduledata.text || firstmoduledata.etext < rec::ip(gocpp::recv(r)))
        {
            return false;
        }
        //Go switch emulation
        {
            auto condition = info->exceptioncode;
            int conditionId = -1;
            if(condition == _EXCEPTION_ACCESS_VIOLATION) { conditionId = 0; }
            else if(condition == _EXCEPTION_IN_PAGE_ERROR) { conditionId = 1; }
            else if(condition == _EXCEPTION_INT_DIVIDE_BY_ZERO) { conditionId = 2; }
            else if(condition == _EXCEPTION_INT_OVERFLOW) { conditionId = 3; }
            else if(condition == _EXCEPTION_FLT_DENORMAL_OPERAND) { conditionId = 4; }
            else if(condition == _EXCEPTION_FLT_DIVIDE_BY_ZERO) { conditionId = 5; }
            else if(condition == _EXCEPTION_FLT_INEXACT_RESULT) { conditionId = 6; }
            else if(condition == _EXCEPTION_FLT_OVERFLOW) { conditionId = 7; }
            else if(condition == _EXCEPTION_FLT_UNDERFLOW) { conditionId = 8; }
            else if(condition == _EXCEPTION_BREAKPOINT) { conditionId = 9; }
            else if(condition == _EXCEPTION_ILLEGAL_INSTRUCTION) { conditionId = 10; }
            switch(conditionId)
            {
                default:
                    return false;
                    break;
                case 0:
                    break;
                case 1:
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    break;
                case 9:
                    break;
                case 10:
                    break;
            }
        }
        return true;
    }

    struct g* sigFetchGSafe()
    /* convertBlockStmt, nil block */;

    struct g* sigFetchG()
    {
        if(GOARCH == "386"s)
        {
            return sigFetchGSafe();
        }
        return getg();
    }

    int32_t sigtrampgo(struct exceptionpointers* ep, int kind)
    {
        auto gp = sigFetchG();
        if(gp == nullptr)
        {
            return _EXCEPTION_CONTINUE_SEARCH;
        }
        std::function<int32_t (struct exceptionrecord* info, struct context* r, struct g* gp)> fn = {};
        //Go switch emulation
        {
            auto condition = kind;
            int conditionId = -1;
            if(condition == callbackVEH) { conditionId = 0; }
            else if(condition == callbackFirstVCH) { conditionId = 1; }
            else if(condition == callbackLastVCH) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    fn = exceptionhandler;
                    break;
                case 1:
                    fn = firstcontinuehandler;
                    break;
                case 2:
                    fn = lastcontinuehandler;
                    break;
                default:
                    go_throw("unknown sigtramp callback"s);
                    break;
            }
        }
        int32_t ret = {};
        if(gp != gp->m->g0)
        {
            systemstack([=]() mutable -> void
            {
                ret = fn(ep->record, ep->context, gp);
            });
        }
        else
        {
            ret = fn(ep->record, ep->context, gp);
        }
        if(ret == _EXCEPTION_CONTINUE_SEARCH)
        {
            return ret;
        }
        if(rec::ip(gocpp::recv(ep->context)) == abi::FuncPCABI0(sigresume))
        {
            return ret;
        }
        prepareContextForSigResume(ep->context);
        rec::set_sp(gocpp::recv(ep->context), gp->m->g0->sched.sp);
        rec::set_ip(gocpp::recv(ep->context), abi::FuncPCABI0(sigresume));
        return ret;
    }

    int32_t exceptionhandler(struct exceptionrecord* info, struct context* r, struct g* gp)
    {
        if(! isgoexception(info, r))
        {
            return _EXCEPTION_CONTINUE_SEARCH;
        }
        if(gp->throwsplit || isAbort(r))
        {
            winthrow(info, r, gp);
        }
        gp->sig = info->exceptioncode;
        gp->sigcode0 = info->exceptioninformation[0];
        gp->sigcode1 = info->exceptioninformation[1];
        gp->sigpc = rec::ip(gocpp::recv(r));
        if(rec::ip(gocpp::recv(r)) != 0 && rec::ip(gocpp::recv(r)) != abi::FuncPCABI0(asyncPreempt))
        {
            auto sp = unsafe::Pointer(rec::sp(gocpp::recv(r)));
            auto delta = uintptr_t(sys::StackAlign);
            sp = add(sp, - delta);
            rec::set_sp(gocpp::recv(r), uintptr_t(sp));
            if(usesLR)
            {
                *((uintptr_t*)(sp)) = rec::lr(gocpp::recv(r));
                rec::set_lr(gocpp::recv(r), rec::ip(gocpp::recv(r)));
            }
            else
            {
                *((uintptr_t*)(sp)) = rec::ip(gocpp::recv(r));
            }
        }
        rec::set_ip(gocpp::recv(r), abi::FuncPCABI0(sigpanic0));
        return _EXCEPTION_CONTINUE_EXECUTION;
    }

    int32_t sehhandler(struct exceptionrecord* _1, uint64_t _2, struct context* _3, struct _DISPATCHER_CONTEXT* dctxt)
    {
        auto g0 = getg();
        if(g0 == nullptr || g0->m->curg == nullptr)
        {
            return _EXCEPTION_CONTINUE_SEARCH_SEH;
        }
        auto gp = g0->m->curg;
        auto ctxt = rec::ctx(gocpp::recv(dctxt));
        uintptr_t base = {};
        uintptr_t sp = {};
        for(; ; )
        {
            auto entry = stdcall3(_RtlLookupFunctionEntry, rec::ip(gocpp::recv(ctxt)), uintptr_t(unsafe::Pointer(& base)), 0);
            if(entry == 0)
            {
                break;
            }
            stdcall8(_RtlVirtualUnwind, 0, base, rec::ip(gocpp::recv(ctxt)), entry, uintptr_t(unsafe::Pointer(ctxt)), 0, uintptr_t(unsafe::Pointer(& sp)), 0);
            if(sp < gp->stack.lo || gp->stack.hi <= sp)
            {
                break;
            }
        }
        return _EXCEPTION_CONTINUE_SEARCH_SEH;
    }

    int32_t firstcontinuehandler(struct exceptionrecord* info, struct context* r, struct g* gp)
    {
        if(! isgoexception(info, r))
        {
            return _EXCEPTION_CONTINUE_SEARCH;
        }
        return _EXCEPTION_CONTINUE_EXECUTION;
    }

    int32_t lastcontinuehandler(struct exceptionrecord* info, struct context* r, struct g* gp)
    {
        if(islibrary || isarchive)
        {
            return _EXCEPTION_CONTINUE_SEARCH;
        }
        if(GOARCH == "arm64"s && info->exceptioncode == _EXCEPTION_ILLEGAL_INSTRUCTION && (rec::ip(gocpp::recv(r)) < firstmoduledata.text || firstmoduledata.etext < rec::ip(gocpp::recv(r))))
        {
            return _EXCEPTION_CONTINUE_SEARCH;
        }
        winthrow(info, r, gp);
        return 0;
    }

    void winthrow(struct exceptionrecord* info, struct context* r, struct g* gp)
    {
        auto g0 = getg();
        if(rec::Load(gocpp::recv(panicking)) != 0)
        {
            exit(2);
        }
        rec::Store(gocpp::recv(panicking), 1);
        g0->stack.lo = 0;
        g0->stackguard0 = g0->stack.lo + stackGuard;
        g0->stackguard1 = g0->stackguard0;
        print("Exception "s, hex(info->exceptioncode), " "s, hex(info->exceptioninformation[0]), " "s, hex(info->exceptioninformation[1]), " "s, hex(rec::ip(gocpp::recv(r))), "\n"s);
        print("PC="s, hex(rec::ip(gocpp::recv(r))), "\n"s);
        if(g0->m->incgo && gp == g0->m->g0 && g0->m->curg != nullptr)
        {
            if(iscgo)
            {
                print("signal arrived during external code execution\n"s);
            }
            gp = g0->m->curg;
        }
        print("\n"s);
        g0->m->throwing = throwTypeRuntime;
        rec::set(gocpp::recv(g0->m->caughtsig), gp);
        auto [level, gocpp_id_1, docrash] = gotraceback();
        if(level > 0)
        {
            tracebacktrap(rec::ip(gocpp::recv(r)), rec::sp(gocpp::recv(r)), rec::lr(gocpp::recv(r)), gp);
            tracebackothers(gp);
            dumpregs(r);
        }
        if(docrash)
        {
            dieFromException(info, r);
        }
        exit(2);
    }

    void sigpanic()
    {
        auto gp = getg();
        if(! canpanic())
        {
            go_throw("unexpected signal during runtime execution"s);
        }
        //Go switch emulation
        {
            auto condition = gp->sig;
            int conditionId = -1;
            if(condition == _EXCEPTION_ACCESS_VIOLATION) { conditionId = 0; }
            else if(condition == _EXCEPTION_IN_PAGE_ERROR) { conditionId = 1; }
            else if(condition == _EXCEPTION_INT_DIVIDE_BY_ZERO) { conditionId = 2; }
            else if(condition == _EXCEPTION_INT_OVERFLOW) { conditionId = 3; }
            else if(condition == _EXCEPTION_FLT_DENORMAL_OPERAND) { conditionId = 4; }
            else if(condition == _EXCEPTION_FLT_DIVIDE_BY_ZERO) { conditionId = 5; }
            else if(condition == _EXCEPTION_FLT_INEXACT_RESULT) { conditionId = 6; }
            else if(condition == _EXCEPTION_FLT_OVERFLOW) { conditionId = 7; }
            else if(condition == _EXCEPTION_FLT_UNDERFLOW) { conditionId = 8; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    if(gp->sigcode1 < 0x1000)
                    {
                        panicmem();
                    }
                    if(gp->paniconfault)
                    {
                        panicmemAddr(gp->sigcode1);
                    }
                    if(inUserArenaChunk(gp->sigcode1))
                    {
                        print("accessed data from freed user arena "s, hex(gp->sigcode1), "\n"s);
                    }
                    else
                    {
                        print("unexpected fault address "s, hex(gp->sigcode1), "\n"s);
                    }
                    go_throw("fault"s);
                    break;
                case 2:
                    panicdivide();
                    break;
                case 3:
                    panicoverflow();
                    break;
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    panicfloat();
                    break;
            }
        }
        go_throw("fault"s);
    }

    void initsig(bool preinit)
    {
    }

    void sigenable(uint32_t sig)
    {
    }

    void sigdisable(uint32_t sig)
    {
    }

    void sigignore(uint32_t sig)
    {
    }

    std::string signame(uint32_t sig)
    {
        return ""s;
    }

    void crash()
    {
        dieFromException(nullptr, nullptr);
    }

    void dieFromException(struct exceptionrecord* info, struct context* r)
    {
        if(info == nullptr)
        {
            auto gp = getg();
            if(gp->sig != 0)
            {
                info = gocpp::InitPtr<exceptionrecord>([=](auto& x) {
                    x.exceptionaddress = gp->sigpc;
                    x.exceptioncode = gp->sig;
                    x.numberparameters = 2;
                });
                info->exceptioninformation[0] = gp->sigcode0;
                info->exceptioninformation[1] = gp->sigcode1;
            }
            else
            {
                info = gocpp::InitPtr<exceptionrecord>([=](auto& x) {
                    x.exceptioncode = 2;
                });
            }
        }
        auto FAIL_FAST_GENERATE_EXCEPTION_ADDRESS = 0x1;
        stdcall3(_RaiseFailFastException, uintptr_t(unsafe::Pointer(info)), uintptr_t(unsafe::Pointer(r)), FAIL_FAST_GENERATE_EXCEPTION_ADDRESS);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gsignalStack::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gsignalStack::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gsignalStack::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gsignalStack& value)
    {
        return value.PrintTo(os);
    }

}

