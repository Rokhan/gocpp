// generated by GoCpp from file '$(ImportDir)/syscall/zsyscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/zsyscall_windows.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/sysdll/sysdll.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    unsafe::Pointer _;
    gocpp::error errERROR_IO_PENDING = Errno(errnoERROR_IO_PENDING);
    gocpp::error errERROR_EINVAL = EINVAL;
    struct gocpp::error errnoErr(Errno e)
    {
        //Go switch emulation
        {
            auto condition = e;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == errnoERROR_IO_PENDING) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return errERROR_EINVAL;
                    break;
                case 1:
                    return errERROR_IO_PENDING;
                    break;
            }
        }
        return e;
    }

    LazyDLL* modadvapi32 = NewLazyDLL(sysdll::Add("advapi32.dll"));
    LazyDLL* modcrypt32 = NewLazyDLL(sysdll::Add("crypt32.dll"));
    LazyDLL* moddnsapi = NewLazyDLL(sysdll::Add("dnsapi.dll"));
    LazyDLL* modiphlpapi = NewLazyDLL(sysdll::Add("iphlpapi.dll"));
    LazyDLL* modkernel32 = NewLazyDLL(sysdll::Add("kernel32.dll"));
    LazyDLL* modmswsock = NewLazyDLL(sysdll::Add("mswsock.dll"));
    LazyDLL* modnetapi32 = NewLazyDLL(sysdll::Add("netapi32.dll"));
    LazyDLL* modntdll = NewLazyDLL(sysdll::Add("ntdll.dll"));
    LazyDLL* modsecur32 = NewLazyDLL(sysdll::Add("secur32.dll"));
    LazyDLL* modshell32 = NewLazyDLL(sysdll::Add("shell32.dll"));
    LazyDLL* moduserenv = NewLazyDLL(sysdll::Add("userenv.dll"));
    LazyDLL* modws2_32 = NewLazyDLL(sysdll::Add("ws2_32.dll"));
    LazyProc* procConvertSidToStringSidW = NewProc(gocpp::recv(modadvapi32), "ConvertSidToStringSidW");
    LazyProc* procConvertStringSidToSidW = NewProc(gocpp::recv(modadvapi32), "ConvertStringSidToSidW");
    LazyProc* procCopySid = NewProc(gocpp::recv(modadvapi32), "CopySid");
    LazyProc* procCreateProcessAsUserW = NewProc(gocpp::recv(modadvapi32), "CreateProcessAsUserW");
    LazyProc* procCryptAcquireContextW = NewProc(gocpp::recv(modadvapi32), "CryptAcquireContextW");
    LazyProc* procCryptGenRandom = NewProc(gocpp::recv(modadvapi32), "CryptGenRandom");
    LazyProc* procCryptReleaseContext = NewProc(gocpp::recv(modadvapi32), "CryptReleaseContext");
    LazyProc* procGetLengthSid = NewProc(gocpp::recv(modadvapi32), "GetLengthSid");
    LazyProc* procGetTokenInformation = NewProc(gocpp::recv(modadvapi32), "GetTokenInformation");
    LazyProc* procLookupAccountNameW = NewProc(gocpp::recv(modadvapi32), "LookupAccountNameW");
    LazyProc* procLookupAccountSidW = NewProc(gocpp::recv(modadvapi32), "LookupAccountSidW");
    LazyProc* procOpenProcessToken = NewProc(gocpp::recv(modadvapi32), "OpenProcessToken");
    LazyProc* procRegCloseKey = NewProc(gocpp::recv(modadvapi32), "RegCloseKey");
    LazyProc* procRegEnumKeyExW = NewProc(gocpp::recv(modadvapi32), "RegEnumKeyExW");
    LazyProc* procRegOpenKeyExW = NewProc(gocpp::recv(modadvapi32), "RegOpenKeyExW");
    LazyProc* procRegQueryInfoKeyW = NewProc(gocpp::recv(modadvapi32), "RegQueryInfoKeyW");
    LazyProc* procRegQueryValueExW = NewProc(gocpp::recv(modadvapi32), "RegQueryValueExW");
    LazyProc* procCertAddCertificateContextToStore = NewProc(gocpp::recv(modcrypt32), "CertAddCertificateContextToStore");
    LazyProc* procCertCloseStore = NewProc(gocpp::recv(modcrypt32), "CertCloseStore");
    LazyProc* procCertCreateCertificateContext = NewProc(gocpp::recv(modcrypt32), "CertCreateCertificateContext");
    LazyProc* procCertEnumCertificatesInStore = NewProc(gocpp::recv(modcrypt32), "CertEnumCertificatesInStore");
    LazyProc* procCertFreeCertificateChain = NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateChain");
    LazyProc* procCertFreeCertificateContext = NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateContext");
    LazyProc* procCertGetCertificateChain = NewProc(gocpp::recv(modcrypt32), "CertGetCertificateChain");
    LazyProc* procCertOpenStore = NewProc(gocpp::recv(modcrypt32), "CertOpenStore");
    LazyProc* procCertOpenSystemStoreW = NewProc(gocpp::recv(modcrypt32), "CertOpenSystemStoreW");
    LazyProc* procCertVerifyCertificateChainPolicy = NewProc(gocpp::recv(modcrypt32), "CertVerifyCertificateChainPolicy");
    LazyProc* procDnsNameCompare_W = NewProc(gocpp::recv(moddnsapi), "DnsNameCompare_W");
    LazyProc* procDnsQuery_W = NewProc(gocpp::recv(moddnsapi), "DnsQuery_W");
    LazyProc* procDnsRecordListFree = NewProc(gocpp::recv(moddnsapi), "DnsRecordListFree");
    LazyProc* procGetAdaptersInfo = NewProc(gocpp::recv(modiphlpapi), "GetAdaptersInfo");
    LazyProc* procGetIfEntry = NewProc(gocpp::recv(modiphlpapi), "GetIfEntry");
    LazyProc* procCancelIo = NewProc(gocpp::recv(modkernel32), "CancelIo");
    LazyProc* procCancelIoEx = NewProc(gocpp::recv(modkernel32), "CancelIoEx");
    LazyProc* procCloseHandle = NewProc(gocpp::recv(modkernel32), "CloseHandle");
    LazyProc* procCreateDirectoryW = NewProc(gocpp::recv(modkernel32), "CreateDirectoryW");
    LazyProc* procCreateFileMappingW = NewProc(gocpp::recv(modkernel32), "CreateFileMappingW");
    LazyProc* procCreateFileW = NewProc(gocpp::recv(modkernel32), "CreateFileW");
    LazyProc* procCreateHardLinkW = NewProc(gocpp::recv(modkernel32), "CreateHardLinkW");
    LazyProc* procCreateIoCompletionPort = NewProc(gocpp::recv(modkernel32), "CreateIoCompletionPort");
    LazyProc* procCreatePipe = NewProc(gocpp::recv(modkernel32), "CreatePipe");
    LazyProc* procCreateProcessW = NewProc(gocpp::recv(modkernel32), "CreateProcessW");
    LazyProc* procCreateSymbolicLinkW = NewProc(gocpp::recv(modkernel32), "CreateSymbolicLinkW");
    LazyProc* procCreateToolhelp32Snapshot = NewProc(gocpp::recv(modkernel32), "CreateToolhelp32Snapshot");
    LazyProc* procDeleteFileW = NewProc(gocpp::recv(modkernel32), "DeleteFileW");
    LazyProc* procDeleteProcThreadAttributeList = NewProc(gocpp::recv(modkernel32), "DeleteProcThreadAttributeList");
    LazyProc* procDeviceIoControl = NewProc(gocpp::recv(modkernel32), "DeviceIoControl");
    LazyProc* procDuplicateHandle = NewProc(gocpp::recv(modkernel32), "DuplicateHandle");
    LazyProc* procExitProcess = NewProc(gocpp::recv(modkernel32), "ExitProcess");
    LazyProc* procFindClose = NewProc(gocpp::recv(modkernel32), "FindClose");
    LazyProc* procFindFirstFileW = NewProc(gocpp::recv(modkernel32), "FindFirstFileW");
    LazyProc* procFindNextFileW = NewProc(gocpp::recv(modkernel32), "FindNextFileW");
    LazyProc* procFlushFileBuffers = NewProc(gocpp::recv(modkernel32), "FlushFileBuffers");
    LazyProc* procFlushViewOfFile = NewProc(gocpp::recv(modkernel32), "FlushViewOfFile");
    LazyProc* procFormatMessageW = NewProc(gocpp::recv(modkernel32), "FormatMessageW");
    LazyProc* procFreeEnvironmentStringsW = NewProc(gocpp::recv(modkernel32), "FreeEnvironmentStringsW");
    LazyProc* procFreeLibrary = NewProc(gocpp::recv(modkernel32), "FreeLibrary");
    LazyProc* procGetCommandLineW = NewProc(gocpp::recv(modkernel32), "GetCommandLineW");
    LazyProc* procGetComputerNameW = NewProc(gocpp::recv(modkernel32), "GetComputerNameW");
    LazyProc* procGetConsoleMode = NewProc(gocpp::recv(modkernel32), "GetConsoleMode");
    LazyProc* procGetCurrentDirectoryW = NewProc(gocpp::recv(modkernel32), "GetCurrentDirectoryW");
    LazyProc* procGetCurrentProcess = NewProc(gocpp::recv(modkernel32), "GetCurrentProcess");
    LazyProc* procGetCurrentProcessId = NewProc(gocpp::recv(modkernel32), "GetCurrentProcessId");
    LazyProc* procGetEnvironmentStringsW = NewProc(gocpp::recv(modkernel32), "GetEnvironmentStringsW");
    LazyProc* procGetEnvironmentVariableW = NewProc(gocpp::recv(modkernel32), "GetEnvironmentVariableW");
    LazyProc* procGetExitCodeProcess = NewProc(gocpp::recv(modkernel32), "GetExitCodeProcess");
    LazyProc* procGetFileAttributesExW = NewProc(gocpp::recv(modkernel32), "GetFileAttributesExW");
    LazyProc* procGetFileAttributesW = NewProc(gocpp::recv(modkernel32), "GetFileAttributesW");
    LazyProc* procGetFileInformationByHandle = NewProc(gocpp::recv(modkernel32), "GetFileInformationByHandle");
    LazyProc* procGetFileType = NewProc(gocpp::recv(modkernel32), "GetFileType");
    LazyProc* procGetFinalPathNameByHandleW = NewProc(gocpp::recv(modkernel32), "GetFinalPathNameByHandleW");
    LazyProc* procGetFullPathNameW = NewProc(gocpp::recv(modkernel32), "GetFullPathNameW");
    LazyProc* procGetLastError = NewProc(gocpp::recv(modkernel32), "GetLastError");
    LazyProc* procGetLongPathNameW = NewProc(gocpp::recv(modkernel32), "GetLongPathNameW");
    LazyProc* procGetProcAddress = NewProc(gocpp::recv(modkernel32), "GetProcAddress");
    LazyProc* procGetProcessTimes = NewProc(gocpp::recv(modkernel32), "GetProcessTimes");
    LazyProc* procGetQueuedCompletionStatus = NewProc(gocpp::recv(modkernel32), "GetQueuedCompletionStatus");
    LazyProc* procGetShortPathNameW = NewProc(gocpp::recv(modkernel32), "GetShortPathNameW");
    LazyProc* procGetStartupInfoW = NewProc(gocpp::recv(modkernel32), "GetStartupInfoW");
    LazyProc* procGetStdHandle = NewProc(gocpp::recv(modkernel32), "GetStdHandle");
    LazyProc* procGetSystemTimeAsFileTime = NewProc(gocpp::recv(modkernel32), "GetSystemTimeAsFileTime");
    LazyProc* procGetTempPathW = NewProc(gocpp::recv(modkernel32), "GetTempPathW");
    LazyProc* procGetTimeZoneInformation = NewProc(gocpp::recv(modkernel32), "GetTimeZoneInformation");
    LazyProc* procGetVersion = NewProc(gocpp::recv(modkernel32), "GetVersion");
    LazyProc* procInitializeProcThreadAttributeList = NewProc(gocpp::recv(modkernel32), "InitializeProcThreadAttributeList");
    LazyProc* procLoadLibraryW = NewProc(gocpp::recv(modkernel32), "LoadLibraryW");
    LazyProc* procLocalFree = NewProc(gocpp::recv(modkernel32), "LocalFree");
    LazyProc* procMapViewOfFile = NewProc(gocpp::recv(modkernel32), "MapViewOfFile");
    LazyProc* procMoveFileW = NewProc(gocpp::recv(modkernel32), "MoveFileW");
    LazyProc* procOpenProcess = NewProc(gocpp::recv(modkernel32), "OpenProcess");
    LazyProc* procPostQueuedCompletionStatus = NewProc(gocpp::recv(modkernel32), "PostQueuedCompletionStatus");
    LazyProc* procProcess32FirstW = NewProc(gocpp::recv(modkernel32), "Process32FirstW");
    LazyProc* procProcess32NextW = NewProc(gocpp::recv(modkernel32), "Process32NextW");
    LazyProc* procReadConsoleW = NewProc(gocpp::recv(modkernel32), "ReadConsoleW");
    LazyProc* procReadDirectoryChangesW = NewProc(gocpp::recv(modkernel32), "ReadDirectoryChangesW");
    LazyProc* procReadFile = NewProc(gocpp::recv(modkernel32), "ReadFile");
    LazyProc* procRemoveDirectoryW = NewProc(gocpp::recv(modkernel32), "RemoveDirectoryW");
    LazyProc* procSetCurrentDirectoryW = NewProc(gocpp::recv(modkernel32), "SetCurrentDirectoryW");
    LazyProc* procSetEndOfFile = NewProc(gocpp::recv(modkernel32), "SetEndOfFile");
    LazyProc* procSetEnvironmentVariableW = NewProc(gocpp::recv(modkernel32), "SetEnvironmentVariableW");
    LazyProc* procSetFileAttributesW = NewProc(gocpp::recv(modkernel32), "SetFileAttributesW");
    LazyProc* procSetFileCompletionNotificationModes = NewProc(gocpp::recv(modkernel32), "SetFileCompletionNotificationModes");
    LazyProc* procSetFilePointer = NewProc(gocpp::recv(modkernel32), "SetFilePointer");
    LazyProc* procSetFileTime = NewProc(gocpp::recv(modkernel32), "SetFileTime");
    LazyProc* procSetHandleInformation = NewProc(gocpp::recv(modkernel32), "SetHandleInformation");
    LazyProc* procTerminateProcess = NewProc(gocpp::recv(modkernel32), "TerminateProcess");
    LazyProc* procUnmapViewOfFile = NewProc(gocpp::recv(modkernel32), "UnmapViewOfFile");
    LazyProc* procUpdateProcThreadAttribute = NewProc(gocpp::recv(modkernel32), "UpdateProcThreadAttribute");
    LazyProc* procVirtualLock = NewProc(gocpp::recv(modkernel32), "VirtualLock");
    LazyProc* procVirtualUnlock = NewProc(gocpp::recv(modkernel32), "VirtualUnlock");
    LazyProc* procWaitForSingleObject = NewProc(gocpp::recv(modkernel32), "WaitForSingleObject");
    LazyProc* procWriteConsoleW = NewProc(gocpp::recv(modkernel32), "WriteConsoleW");
    LazyProc* procWriteFile = NewProc(gocpp::recv(modkernel32), "WriteFile");
    LazyProc* procAcceptEx = NewProc(gocpp::recv(modmswsock), "AcceptEx");
    LazyProc* procGetAcceptExSockaddrs = NewProc(gocpp::recv(modmswsock), "GetAcceptExSockaddrs");
    LazyProc* procTransmitFile = NewProc(gocpp::recv(modmswsock), "TransmitFile");
    LazyProc* procNetApiBufferFree = NewProc(gocpp::recv(modnetapi32), "NetApiBufferFree");
    LazyProc* procNetGetJoinInformation = NewProc(gocpp::recv(modnetapi32), "NetGetJoinInformation");
    LazyProc* procNetUserGetInfo = NewProc(gocpp::recv(modnetapi32), "NetUserGetInfo");
    LazyProc* procRtlGetNtVersionNumbers = NewProc(gocpp::recv(modntdll), "RtlGetNtVersionNumbers");
    LazyProc* procGetUserNameExW = NewProc(gocpp::recv(modsecur32), "GetUserNameExW");
    LazyProc* procTranslateNameW = NewProc(gocpp::recv(modsecur32), "TranslateNameW");
    LazyProc* procCommandLineToArgvW = NewProc(gocpp::recv(modshell32), "CommandLineToArgvW");
    LazyProc* procGetUserProfileDirectoryW = NewProc(gocpp::recv(moduserenv), "GetUserProfileDirectoryW");
    LazyProc* procFreeAddrInfoW = NewProc(gocpp::recv(modws2_32), "FreeAddrInfoW");
    LazyProc* procGetAddrInfoW = NewProc(gocpp::recv(modws2_32), "GetAddrInfoW");
    LazyProc* procWSACleanup = NewProc(gocpp::recv(modws2_32), "WSACleanup");
    LazyProc* procWSAEnumProtocolsW = NewProc(gocpp::recv(modws2_32), "WSAEnumProtocolsW");
    LazyProc* procWSAIoctl = NewProc(gocpp::recv(modws2_32), "WSAIoctl");
    LazyProc* procWSARecv = NewProc(gocpp::recv(modws2_32), "WSARecv");
    LazyProc* procWSARecvFrom = NewProc(gocpp::recv(modws2_32), "WSARecvFrom");
    LazyProc* procWSASend = NewProc(gocpp::recv(modws2_32), "WSASend");
    LazyProc* procWSASendTo = NewProc(gocpp::recv(modws2_32), "WSASendTo");
    LazyProc* procWSAStartup = NewProc(gocpp::recv(modws2_32), "WSAStartup");
    LazyProc* procbind = NewProc(gocpp::recv(modws2_32), "bind");
    LazyProc* procclosesocket = NewProc(gocpp::recv(modws2_32), "closesocket");
    LazyProc* procconnect = NewProc(gocpp::recv(modws2_32), "connect");
    LazyProc* procgethostbyname = NewProc(gocpp::recv(modws2_32), "gethostbyname");
    LazyProc* procgetpeername = NewProc(gocpp::recv(modws2_32), "getpeername");
    LazyProc* procgetprotobyname = NewProc(gocpp::recv(modws2_32), "getprotobyname");
    LazyProc* procgetservbyname = NewProc(gocpp::recv(modws2_32), "getservbyname");
    LazyProc* procgetsockname = NewProc(gocpp::recv(modws2_32), "getsockname");
    LazyProc* procgetsockopt = NewProc(gocpp::recv(modws2_32), "getsockopt");
    LazyProc* proclisten = NewProc(gocpp::recv(modws2_32), "listen");
    LazyProc* procntohs = NewProc(gocpp::recv(modws2_32), "ntohs");
    LazyProc* procsetsockopt = NewProc(gocpp::recv(modws2_32), "setsockopt");
    LazyProc* procshutdown = NewProc(gocpp::recv(modws2_32), "shutdown");
    LazyProc* procsocket = NewProc(gocpp::recv(modws2_32), "socket");
    struct gocpp::error ConvertSidToStringSid(struct SID* sid, uint16_t** stringSid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_1, e1] = Syscall(Addr(gocpp::recv(procConvertSidToStringSidW)), 2, uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(stringSid)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ConvertStringSidToSid(uint16_t* stringSid, struct SID** sid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_3, e1] = Syscall(Addr(gocpp::recv(procConvertStringSidToSidW)), 2, uintptr_t(unsafe::Pointer(stringSid)), uintptr_t(unsafe::Pointer(sid)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CopySid(uint32_t destSidLen, struct SID* destSid, struct SID* srcSid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_5, e1] = Syscall(Addr(gocpp::recv(procCopySid)), 3, uintptr_t(destSidLen), uintptr_t(unsafe::Pointer(destSid)), uintptr_t(unsafe::Pointer(srcSid)));
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateProcessAsUser(Token token, uint16_t* appName, uint16_t* commandLine, struct SecurityAttributes* procSecurity, struct SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, struct StartupInfo* startupInfo, struct ProcessInformation* outProcInfo)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            struct gocpp::error err;
            _p0 = 1;
        }
        auto [r1, gocpp_id_7, e1] = Syscall12(Addr(gocpp::recv(procCreateProcessAsUserW)), 11, uintptr_t(token), uintptr_t(unsafe::Pointer(appName)), uintptr_t(unsafe::Pointer(commandLine)), uintptr_t(unsafe::Pointer(procSecurity)), uintptr_t(unsafe::Pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(unsafe::Pointer(env)), uintptr_t(unsafe::Pointer(currentDir)), uintptr_t(unsafe::Pointer(startupInfo)), uintptr_t(unsafe::Pointer(outProcInfo)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptAcquireContext(Handle* provhandle, uint16_t* container, uint16_t* provider, uint32_t provtype, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_9, e1] = Syscall6(Addr(gocpp::recv(procCryptAcquireContextW)), 5, uintptr_t(unsafe::Pointer(provhandle)), uintptr_t(unsafe::Pointer(container)), uintptr_t(unsafe::Pointer(provider)), uintptr_t(provtype), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptGenRandom(Handle provhandle, uint32_t buflen, unsigned char* buf)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_11, e1] = Syscall(Addr(gocpp::recv(procCryptGenRandom)), 3, uintptr_t(provhandle), uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)));
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptReleaseContext(Handle provhandle, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_13, e1] = Syscall(Addr(gocpp::recv(procCryptReleaseContext)), 2, uintptr_t(provhandle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    uint32_t GetLengthSid(struct SID* sid)
    {
        uint32_t len;
        auto [r0, gocpp_id_16, gocpp_id_17] = Syscall(Addr(gocpp::recv(procGetLengthSid)), 1, uintptr_t(unsafe::Pointer(sid)), 0, 0);
        len = uint32_t(r0);
        return len;
    }

    struct gocpp::error GetTokenInformation(Token t, uint32_t infoClass, unsigned char* info, uint32_t infoLen, uint32_t* returnedLen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_19, e1] = Syscall6(Addr(gocpp::recv(procGetTokenInformation)), 5, uintptr_t(t), uintptr_t(infoClass), uintptr_t(unsafe::Pointer(info)), uintptr_t(infoLen), uintptr_t(unsafe::Pointer(returnedLen)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error LookupAccountName(uint16_t* systemName, uint16_t* accountName, struct SID* sid, uint32_t* sidLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_21, e1] = Syscall9(Addr(gocpp::recv(procLookupAccountNameW)), 7, uintptr_t(unsafe::Pointer(systemName)), uintptr_t(unsafe::Pointer(accountName)), uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(sidLen)), uintptr_t(unsafe::Pointer(refdDomainName)), uintptr_t(unsafe::Pointer(refdDomainNameLen)), uintptr_t(unsafe::Pointer(use)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error LookupAccountSid(uint16_t* systemName, struct SID* sid, uint16_t* name, uint32_t* nameLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_23, e1] = Syscall9(Addr(gocpp::recv(procLookupAccountSidW)), 7, uintptr_t(unsafe::Pointer(systemName)), uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(nameLen)), uintptr_t(unsafe::Pointer(refdDomainName)), uintptr_t(unsafe::Pointer(refdDomainNameLen)), uintptr_t(unsafe::Pointer(use)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error OpenProcessToken(Handle h, uint32_t access, Token* token)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_25, e1] = Syscall(Addr(gocpp::recv(procOpenProcessToken)), 3, uintptr_t(h), uintptr_t(access), uintptr_t(unsafe::Pointer(token)));
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error RegCloseKey(Handle key)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_28, gocpp_id_29] = Syscall(Addr(gocpp::recv(procRegCloseKey)), 1, uintptr_t(key), 0, 0);
        if(r0 != 0)
        {
            struct gocpp::error regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error regEnumKeyEx(Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_32, gocpp_id_33] = Syscall9(Addr(gocpp::recv(procRegEnumKeyExW)), 8, uintptr_t(key), uintptr_t(index), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(nameLen)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(go_class)), uintptr_t(unsafe::Pointer(classLen)), uintptr_t(unsafe::Pointer(lastWriteTime)), 0);
        if(r0 != 0)
        {
            struct gocpp::error regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegOpenKeyEx(Handle key, uint16_t* subkey, uint32_t options, uint32_t desiredAccess, Handle* result)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_36, gocpp_id_37] = Syscall6(Addr(gocpp::recv(procRegOpenKeyExW)), 5, uintptr_t(key), uintptr_t(unsafe::Pointer(subkey)), uintptr_t(options), uintptr_t(desiredAccess), uintptr_t(unsafe::Pointer(result)), 0);
        if(r0 != 0)
        {
            struct gocpp::error regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegQueryInfoKey(Handle key, uint16_t* go_class, uint32_t* classLen, uint32_t* reserved, uint32_t* subkeysLen, uint32_t* maxSubkeyLen, uint32_t* maxClassLen, uint32_t* valuesLen, uint32_t* maxValueNameLen, uint32_t* maxValueLen, uint32_t* saLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_40, gocpp_id_41] = Syscall12(Addr(gocpp::recv(procRegQueryInfoKeyW)), 12, uintptr_t(key), uintptr_t(unsafe::Pointer(go_class)), uintptr_t(unsafe::Pointer(classLen)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(subkeysLen)), uintptr_t(unsafe::Pointer(maxSubkeyLen)), uintptr_t(unsafe::Pointer(maxClassLen)), uintptr_t(unsafe::Pointer(valuesLen)), uintptr_t(unsafe::Pointer(maxValueNameLen)), uintptr_t(unsafe::Pointer(maxValueLen)), uintptr_t(unsafe::Pointer(saLen)), uintptr_t(unsafe::Pointer(lastWriteTime)));
        if(r0 != 0)
        {
            struct gocpp::error regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegQueryValueEx(Handle key, uint16_t* name, uint32_t* reserved, uint32_t* valtype, unsigned char* buf, uint32_t* buflen)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_44, gocpp_id_45] = Syscall6(Addr(gocpp::recv(procRegQueryValueExW)), 6, uintptr_t(key), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(valtype)), uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(buflen)));
        if(r0 != 0)
        {
            struct gocpp::error regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error CertAddCertificateContextToStore(Handle store, struct CertContext* certContext, uint32_t addDisposition, struct CertContext** storeContext)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_47, e1] = Syscall6(Addr(gocpp::recv(procCertAddCertificateContextToStore)), 4, uintptr_t(store), uintptr_t(unsafe::Pointer(certContext)), uintptr_t(addDisposition), uintptr_t(unsafe::Pointer(storeContext)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CertCloseStore(Handle store, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_49, e1] = Syscall(Addr(gocpp::recv(procCertCloseStore)), 2, uintptr_t(store), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct CertContext*, struct gocpp::error> CertCreateCertificateContext(uint32_t certEncodingType, unsigned char* certEncoded, uint32_t encodedLen)
    {
        struct CertContext* context;
        struct gocpp::error err;
        auto [r0, gocpp_id_51, e1] = Syscall(Addr(gocpp::recv(procCertCreateCertificateContext)), 3, uintptr_t(certEncodingType), uintptr_t(unsafe::Pointer(certEncoded)), uintptr_t(encodedLen));
        context = (CertContext*)(unsafe::Pointer(r0));
        if(context == nullptr)
        {
            struct CertContext* context;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {context, err};
    }

    std::tuple<struct CertContext*, struct gocpp::error> CertEnumCertificatesInStore(Handle store, struct CertContext* prevContext)
    {
        struct CertContext* context;
        struct gocpp::error err;
        auto [r0, gocpp_id_53, e1] = Syscall(Addr(gocpp::recv(procCertEnumCertificatesInStore)), 2, uintptr_t(store), uintptr_t(unsafe::Pointer(prevContext)), 0);
        context = (CertContext*)(unsafe::Pointer(r0));
        if(context == nullptr)
        {
            struct CertContext* context;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {context, err};
    }

    void CertFreeCertificateChain(struct CertChainContext* ctx)
    {
        Syscall(Addr(gocpp::recv(procCertFreeCertificateChain)), 1, uintptr_t(unsafe::Pointer(ctx)), 0, 0);
        return;
    }

    struct gocpp::error CertFreeCertificateContext(struct CertContext* ctx)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_55, e1] = Syscall(Addr(gocpp::recv(procCertFreeCertificateContext)), 1, uintptr_t(unsafe::Pointer(ctx)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CertGetCertificateChain(Handle engine, struct CertContext* leaf, struct Filetime* time, Handle additionalStore, struct CertChainPara* para, uint32_t flags, uintptr_t reserved, struct CertChainContext** chainCtx)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_57, e1] = Syscall9(Addr(gocpp::recv(procCertGetCertificateChain)), 8, uintptr_t(engine), uintptr_t(unsafe::Pointer(leaf)), uintptr_t(unsafe::Pointer(time)), uintptr_t(additionalStore), uintptr_t(unsafe::Pointer(para)), uintptr_t(flags), uintptr_t(reserved), uintptr_t(unsafe::Pointer(chainCtx)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> CertOpenStore(uintptr_t storeProvider, uint32_t msgAndCertEncodingType, uintptr_t cryptProv, uint32_t flags, uintptr_t para)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_59, e1] = Syscall6(Addr(gocpp::recv(procCertOpenStore)), 5, uintptr_t(storeProvider), uintptr_t(msgAndCertEncodingType), uintptr_t(cryptProv), uintptr_t(flags), uintptr_t(para), 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<Handle, struct gocpp::error> CertOpenSystemStore(Handle hprov, uint16_t* name)
    {
        Handle store;
        struct gocpp::error err;
        auto [r0, gocpp_id_61, e1] = Syscall(Addr(gocpp::recv(procCertOpenSystemStoreW)), 2, uintptr_t(hprov), uintptr_t(unsafe::Pointer(name)), 0);
        store = Handle(r0);
        if(store == 0)
        {
            Handle store;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {store, err};
    }

    struct gocpp::error CertVerifyCertificateChainPolicy(uintptr_t policyOID, struct CertChainContext* chain, struct CertChainPolicyPara* para, struct CertChainPolicyStatus* status)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_63, e1] = Syscall6(Addr(gocpp::recv(procCertVerifyCertificateChainPolicy)), 4, uintptr_t(policyOID), uintptr_t(unsafe::Pointer(chain)), uintptr_t(unsafe::Pointer(para)), uintptr_t(unsafe::Pointer(status)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    bool DnsNameCompare(uint16_t* name1, uint16_t* name2)
    {
        bool same;
        auto [r0, gocpp_id_66, gocpp_id_67] = Syscall(Addr(gocpp::recv(procDnsNameCompare_W)), 2, uintptr_t(unsafe::Pointer(name1)), uintptr_t(unsafe::Pointer(name2)), 0);
        same = r0 != 0;
        return same;
    }

    struct gocpp::error DnsQuery(std::string name, uint16_t qtype, uint32_t options, unsigned char* extra, struct DNSRecord** qrs, unsigned char* pr)
    {
        struct gocpp::error status;
        uint16_t* _p0 = {};
        std::tie(_p0, status) = UTF16PtrFromString(name);
        if(status != nullptr)
        {
            struct gocpp::error status;
            return status;
        }
        return _DnsQuery(_p0, qtype, options, extra, qrs, pr);
    }

    struct gocpp::error _DnsQuery(uint16_t* name, uint16_t qtype, uint32_t options, unsigned char* extra, struct DNSRecord** qrs, unsigned char* pr)
    {
        struct gocpp::error status;
        auto [r0, gocpp_id_70, gocpp_id_71] = Syscall6(Addr(gocpp::recv(procDnsQuery_W)), 6, uintptr_t(unsafe::Pointer(name)), uintptr_t(qtype), uintptr_t(options), uintptr_t(unsafe::Pointer(extra)), uintptr_t(unsafe::Pointer(qrs)), uintptr_t(unsafe::Pointer(pr)));
        if(r0 != 0)
        {
            struct gocpp::error status;
            status = Errno(r0);
        }
        return status;
    }

    void DnsRecordListFree(struct DNSRecord* rl, uint32_t freetype)
    {
        Syscall(Addr(gocpp::recv(procDnsRecordListFree)), 2, uintptr_t(unsafe::Pointer(rl)), uintptr_t(freetype), 0);
        return;
    }

    struct gocpp::error GetAdaptersInfo(struct IpAdapterInfo* ai, uint32_t* ol)
    {
        struct gocpp::error errcode;
        auto [r0, gocpp_id_74, gocpp_id_75] = Syscall(Addr(gocpp::recv(procGetAdaptersInfo)), 2, uintptr_t(unsafe::Pointer(ai)), uintptr_t(unsafe::Pointer(ol)), 0);
        if(r0 != 0)
        {
            struct gocpp::error errcode;
            errcode = Errno(r0);
        }
        return errcode;
    }

    struct gocpp::error GetIfEntry(struct MibIfRow* pIfRow)
    {
        struct gocpp::error errcode;
        auto [r0, gocpp_id_78, gocpp_id_79] = Syscall(Addr(gocpp::recv(procGetIfEntry)), 1, uintptr_t(unsafe::Pointer(pIfRow)), 0, 0);
        if(r0 != 0)
        {
            struct gocpp::error errcode;
            errcode = Errno(r0);
        }
        return errcode;
    }

    struct gocpp::error CancelIo(Handle s)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_81, e1] = Syscall(Addr(gocpp::recv(procCancelIo)), 1, uintptr_t(s), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CancelIoEx(Handle s, struct Overlapped* o)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_83, e1] = Syscall(Addr(gocpp::recv(procCancelIoEx)), 2, uintptr_t(s), uintptr_t(unsafe::Pointer(o)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CloseHandle(Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_85, e1] = Syscall(Addr(gocpp::recv(procCloseHandle)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateDirectory(uint16_t* path, struct SecurityAttributes* sa)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_87, e1] = Syscall(Addr(gocpp::recv(procCreateDirectoryW)), 2, uintptr_t(unsafe::Pointer(path)), uintptr_t(unsafe::Pointer(sa)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> CreateFileMapping(Handle fhandle, struct SecurityAttributes* sa, uint32_t prot, uint32_t maxSizeHigh, uint32_t maxSizeLow, uint16_t* name)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_89, e1] = Syscall6(Addr(gocpp::recv(procCreateFileMappingW)), 6, uintptr_t(fhandle), uintptr_t(unsafe::Pointer(sa)), uintptr_t(prot), uintptr_t(maxSizeHigh), uintptr_t(maxSizeLow), uintptr_t(unsafe::Pointer(name)));
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<Handle, struct gocpp::error> CreateFile(uint16_t* name, uint32_t access, uint32_t mode, struct SecurityAttributes* sa, uint32_t createmode, uint32_t attrs, int32_t templatefile)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_91, e1] = Syscall9(Addr(gocpp::recv(procCreateFileW)), 7, uintptr_t(unsafe::Pointer(name)), uintptr_t(access), uintptr_t(mode), uintptr_t(unsafe::Pointer(sa)), uintptr_t(createmode), uintptr_t(attrs), uintptr_t(templatefile), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error CreateHardLink(uint16_t* filename, uint16_t* existingfilename, uintptr_t reserved)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_93, e1] = Syscall(Addr(gocpp::recv(procCreateHardLinkW)), 3, uintptr_t(unsafe::Pointer(filename)), uintptr_t(unsafe::Pointer(existingfilename)), uintptr_t(reserved));
        if(r1 & 0xff == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> createIoCompletionPort(Handle filehandle, Handle cphandle, uintptr_t key, uint32_t threadcnt)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_95, e1] = Syscall6(Addr(gocpp::recv(procCreateIoCompletionPort)), 4, uintptr_t(filehandle), uintptr_t(cphandle), uintptr_t(key), uintptr_t(threadcnt), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error CreatePipe(Handle* readhandle, Handle* writehandle, struct SecurityAttributes* sa, uint32_t size)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_97, e1] = Syscall6(Addr(gocpp::recv(procCreatePipe)), 4, uintptr_t(unsafe::Pointer(readhandle)), uintptr_t(unsafe::Pointer(writehandle)), uintptr_t(unsafe::Pointer(sa)), uintptr_t(size), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateProcess(uint16_t* appName, uint16_t* commandLine, struct SecurityAttributes* procSecurity, struct SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, struct StartupInfo* startupInfo, struct ProcessInformation* outProcInfo)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            struct gocpp::error err;
            _p0 = 1;
        }
        auto [r1, gocpp_id_99, e1] = Syscall12(Addr(gocpp::recv(procCreateProcessW)), 10, uintptr_t(unsafe::Pointer(appName)), uintptr_t(unsafe::Pointer(commandLine)), uintptr_t(unsafe::Pointer(procSecurity)), uintptr_t(unsafe::Pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(unsafe::Pointer(env)), uintptr_t(unsafe::Pointer(currentDir)), uintptr_t(unsafe::Pointer(startupInfo)), uintptr_t(unsafe::Pointer(outProcInfo)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateSymbolicLink(uint16_t* symlinkfilename, uint16_t* targetfilename, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_101, e1] = Syscall(Addr(gocpp::recv(procCreateSymbolicLinkW)), 3, uintptr_t(unsafe::Pointer(symlinkfilename)), uintptr_t(unsafe::Pointer(targetfilename)), uintptr_t(flags));
        if(r1 & 0xff == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> CreateToolhelp32Snapshot(uint32_t flags, uint32_t processId)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_103, e1] = Syscall(Addr(gocpp::recv(procCreateToolhelp32Snapshot)), 2, uintptr_t(flags), uintptr_t(processId), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error DeleteFile(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_105, e1] = Syscall(Addr(gocpp::recv(procDeleteFileW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    void deleteProcThreadAttributeList(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist)
    {
        Syscall(Addr(gocpp::recv(procDeleteProcThreadAttributeList)), 1, uintptr_t(unsafe::Pointer(attrlist)), 0, 0);
        return;
    }

    struct gocpp::error DeviceIoControl(Handle handle, uint32_t ioControlCode, unsigned char* inBuffer, uint32_t inBufferSize, unsigned char* outBuffer, uint32_t outBufferSize, uint32_t* bytesReturned, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_107, e1] = Syscall9(Addr(gocpp::recv(procDeviceIoControl)), 8, uintptr_t(handle), uintptr_t(ioControlCode), uintptr_t(unsafe::Pointer(inBuffer)), uintptr_t(inBufferSize), uintptr_t(unsafe::Pointer(outBuffer)), uintptr_t(outBufferSize), uintptr_t(unsafe::Pointer(bytesReturned)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error DuplicateHandle(Handle hSourceProcessHandle, Handle hSourceHandle, Handle hTargetProcessHandle, Handle* lpTargetHandle, uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwOptions)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(bInheritHandle)
        {
            struct gocpp::error err;
            _p0 = 1;
        }
        auto [r1, gocpp_id_109, e1] = Syscall9(Addr(gocpp::recv(procDuplicateHandle)), 7, uintptr_t(hSourceProcessHandle), uintptr_t(hSourceHandle), uintptr_t(hTargetProcessHandle), uintptr_t(unsafe::Pointer(lpTargetHandle)), uintptr_t(dwDesiredAccess), uintptr_t(_p0), uintptr_t(dwOptions), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    void ExitProcess(uint32_t exitcode)
    {
        Syscall(Addr(gocpp::recv(procExitProcess)), 1, uintptr_t(exitcode), 0, 0);
        return;
    }

    struct gocpp::error FindClose(Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_111, e1] = Syscall(Addr(gocpp::recv(procFindClose)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> findFirstFile1(uint16_t* name, struct win32finddata1* data)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_113, e1] = Syscall(Addr(gocpp::recv(procFindFirstFileW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(data)), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error findNextFile1(Handle handle, struct win32finddata1* data)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_115, e1] = Syscall(Addr(gocpp::recv(procFindNextFileW)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(data)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FlushFileBuffers(Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_117, e1] = Syscall(Addr(gocpp::recv(procFlushFileBuffers)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FlushViewOfFile(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_119, e1] = Syscall(Addr(gocpp::recv(procFlushViewOfFile)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> formatMessage(uint32_t flags, uintptr_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args)
    {
        uint32_t n;
        struct gocpp::error err;
        uint16_t* _p0 = {};
        if(len(buf) > 0)
        {
            uint32_t n;
            struct gocpp::error err;
            _p0 = & buf[0];
        }
        auto [r0, gocpp_id_121, e1] = Syscall9(Addr(gocpp::recv(procFormatMessageW)), 7, uintptr_t(flags), uintptr_t(msgsrc), uintptr_t(msgid), uintptr_t(langid), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(args)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error FreeEnvironmentStrings(uint16_t* envs)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_123, e1] = Syscall(Addr(gocpp::recv(procFreeEnvironmentStringsW)), 1, uintptr_t(unsafe::Pointer(envs)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FreeLibrary(Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_125, e1] = Syscall(Addr(gocpp::recv(procFreeLibrary)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t* GetCommandLine()
    {
        uint16_t* cmd;
        auto [r0, gocpp_id_128, gocpp_id_129] = Syscall(Addr(gocpp::recv(procGetCommandLineW)), 0, 0, 0, 0);
        cmd = (uint16_t*)(unsafe::Pointer(r0));
        return cmd;
    }

    struct gocpp::error GetComputerName(uint16_t* buf, uint32_t* n)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_131, e1] = Syscall(Addr(gocpp::recv(procGetComputerNameW)), 2, uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(n)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error GetConsoleMode(Handle console, uint32_t* mode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_133, e1] = Syscall(Addr(gocpp::recv(procGetConsoleMode)), 2, uintptr_t(console), uintptr_t(unsafe::Pointer(mode)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetCurrentDirectory(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_135, e1] = Syscall(Addr(gocpp::recv(procGetCurrentDirectoryW)), 2, uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<Handle, struct gocpp::error> GetCurrentProcess()
    {
        Handle pseudoHandle;
        struct gocpp::error err;
        auto [r0, gocpp_id_137, e1] = Syscall(Addr(gocpp::recv(procGetCurrentProcess)), 0, 0, 0, 0);
        pseudoHandle = Handle(r0);
        if(pseudoHandle == 0)
        {
            Handle pseudoHandle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {pseudoHandle, err};
    }

    uint32_t getCurrentProcessId()
    {
        uint32_t pid;
        auto [r0, gocpp_id_140, gocpp_id_141] = Syscall(Addr(gocpp::recv(procGetCurrentProcessId)), 0, 0, 0, 0);
        pid = uint32_t(r0);
        return pid;
    }

    std::tuple<uint16_t*, struct gocpp::error> GetEnvironmentStrings()
    {
        uint16_t* envs;
        struct gocpp::error err;
        auto [r0, gocpp_id_143, e1] = Syscall(Addr(gocpp::recv(procGetEnvironmentStringsW)), 0, 0, 0, 0);
        envs = (uint16_t*)(unsafe::Pointer(r0));
        if(envs == nullptr)
        {
            uint16_t* envs;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {envs, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetEnvironmentVariable(uint16_t* name, uint16_t* buffer, uint32_t size)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_145, e1] = Syscall(Addr(gocpp::recv(procGetEnvironmentVariableW)), 3, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(buffer)), uintptr_t(size));
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error GetExitCodeProcess(Handle handle, uint32_t* exitcode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_147, e1] = Syscall(Addr(gocpp::recv(procGetExitCodeProcess)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(exitcode)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error GetFileAttributesEx(uint16_t* name, uint32_t level, unsigned char* info)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_149, e1] = Syscall(Addr(gocpp::recv(procGetFileAttributesExW)), 3, uintptr_t(unsafe::Pointer(name)), uintptr_t(level), uintptr_t(unsafe::Pointer(info)));
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileAttributes(uint16_t* name)
    {
        uint32_t attrs;
        struct gocpp::error err;
        auto [r0, gocpp_id_151, e1] = Syscall(Addr(gocpp::recv(procGetFileAttributesW)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        attrs = uint32_t(r0);
        if(attrs == INVALID_FILE_ATTRIBUTES)
        {
            uint32_t attrs;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {attrs, err};
    }

    struct gocpp::error GetFileInformationByHandle(Handle handle, struct ByHandleFileInformation* data)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_153, e1] = Syscall(Addr(gocpp::recv(procGetFileInformationByHandle)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(data)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileType(Handle filehandle)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_155, e1] = Syscall(Addr(gocpp::recv(procGetFileType)), 1, uintptr_t(filehandle), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> getFinalPathNameByHandle(Handle file, uint16_t* filePath, uint32_t filePathSize, uint32_t flags)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_157, e1] = Syscall6(Addr(gocpp::recv(procGetFinalPathNameByHandleW)), 4, uintptr_t(file), uintptr_t(unsafe::Pointer(filePath)), uintptr_t(filePathSize), uintptr_t(flags), 0, 0);
        n = uint32_t(r0);
        if(n == 0 || n >= filePathSize)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetFullPathName(uint16_t* path, uint32_t buflen, uint16_t* buf, uint16_t** fname)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_159, e1] = Syscall6(Addr(gocpp::recv(procGetFullPathNameW)), 4, uintptr_t(unsafe::Pointer(path)), uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(fname)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error GetLastError()
    {
        struct gocpp::error lasterr;
        auto [r0, gocpp_id_162, gocpp_id_163] = Syscall(Addr(gocpp::recv(procGetLastError)), 0, 0, 0, 0);
        if(r0 != 0)
        {
            struct gocpp::error lasterr;
            lasterr = Errno(r0);
        }
        return lasterr;
    }

    std::tuple<uint32_t, struct gocpp::error> GetLongPathName(uint16_t* path, uint16_t* buf, uint32_t buflen)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_165, e1] = Syscall(Addr(gocpp::recv(procGetLongPathNameW)), 3, uintptr_t(unsafe::Pointer(path)), uintptr_t(unsafe::Pointer(buf)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uintptr_t, struct gocpp::error> GetProcAddress(Handle module, std::string procname)
    {
        uintptr_t proc;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(procname);
        if(err != nullptr)
        {
            uintptr_t proc;
            struct gocpp::error err;
            return {proc, err};
        }
        return _GetProcAddress(module, _p0);
    }

    std::tuple<uintptr_t, struct gocpp::error> _GetProcAddress(Handle module, unsigned char* procname)
    {
        uintptr_t proc;
        struct gocpp::error err;
        auto [r0, gocpp_id_167, e1] = Syscall(Addr(gocpp::recv(procGetProcAddress)), 2, uintptr_t(module), uintptr_t(unsafe::Pointer(procname)), 0);
        proc = uintptr_t(r0);
        if(proc == 0)
        {
            uintptr_t proc;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {proc, err};
    }

    struct gocpp::error GetProcessTimes(Handle handle, struct Filetime* creationTime, struct Filetime* exitTime, struct Filetime* kernelTime, struct Filetime* userTime)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_169, e1] = Syscall6(Addr(gocpp::recv(procGetProcessTimes)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(creationTime)), uintptr_t(unsafe::Pointer(exitTime)), uintptr_t(unsafe::Pointer(kernelTime)), uintptr_t(unsafe::Pointer(userTime)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error getQueuedCompletionStatus(Handle cphandle, uint32_t* qty, uintptr_t* key, struct Overlapped** overlapped, uint32_t timeout)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_171, e1] = Syscall6(Addr(gocpp::recv(procGetQueuedCompletionStatus)), 5, uintptr_t(cphandle), uintptr_t(unsafe::Pointer(qty)), uintptr_t(unsafe::Pointer(key)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(timeout), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetShortPathName(uint16_t* longpath, uint16_t* shortpath, uint32_t buflen)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_173, e1] = Syscall(Addr(gocpp::recv(procGetShortPathNameW)), 3, uintptr_t(unsafe::Pointer(longpath)), uintptr_t(unsafe::Pointer(shortpath)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    void getStartupInfo(struct StartupInfo* startupInfo)
    {
        Syscall(Addr(gocpp::recv(procGetStartupInfoW)), 1, uintptr_t(unsafe::Pointer(startupInfo)), 0, 0);
        return;
    }

    std::tuple<Handle, struct gocpp::error> GetStdHandle(int stdhandle)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_175, e1] = Syscall(Addr(gocpp::recv(procGetStdHandle)), 1, uintptr_t(stdhandle), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    void GetSystemTimeAsFileTime(struct Filetime* time)
    {
        Syscall(Addr(gocpp::recv(procGetSystemTimeAsFileTime)), 1, uintptr_t(unsafe::Pointer(time)), 0, 0);
        return;
    }

    std::tuple<uint32_t, struct gocpp::error> GetTempPath(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_177, e1] = Syscall(Addr(gocpp::recv(procGetTempPathW)), 2, uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetTimeZoneInformation(struct Timezoneinformation* tzi)
    {
        uint32_t rc;
        struct gocpp::error err;
        auto [r0, gocpp_id_179, e1] = Syscall(Addr(gocpp::recv(procGetTimeZoneInformation)), 1, uintptr_t(unsafe::Pointer(tzi)), 0, 0);
        rc = uint32_t(r0);
        if(rc == 0xffffffff)
        {
            uint32_t rc;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {rc, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetVersion()
    {
        uint32_t ver;
        struct gocpp::error err;
        auto [r0, gocpp_id_181, e1] = Syscall(Addr(gocpp::recv(procGetVersion)), 0, 0, 0, 0);
        ver = uint32_t(r0);
        if(ver == 0)
        {
            uint32_t ver;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {ver, err};
    }

    struct gocpp::error initializeProcThreadAttributeList(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t attrcount, uint32_t flags, uintptr_t* size)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_183, e1] = Syscall6(Addr(gocpp::recv(procInitializeProcThreadAttributeList)), 4, uintptr_t(unsafe::Pointer(attrlist)), uintptr_t(attrcount), uintptr_t(flags), uintptr_t(unsafe::Pointer(size)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> LoadLibrary(std::string libname)
    {
        Handle handle;
        struct gocpp::error err;
        uint16_t* _p0 = {};
        std::tie(_p0, err) = UTF16PtrFromString(libname);
        if(err != nullptr)
        {
            Handle handle;
            struct gocpp::error err;
            return {handle, err};
        }
        return _LoadLibrary(_p0);
    }

    std::tuple<Handle, struct gocpp::error> _LoadLibrary(uint16_t* libname)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_185, e1] = Syscall(Addr(gocpp::recv(procLoadLibraryW)), 1, uintptr_t(unsafe::Pointer(libname)), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<Handle, struct gocpp::error> LocalFree(Handle hmem)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_187, e1] = Syscall(Addr(gocpp::recv(procLocalFree)), 1, uintptr_t(hmem), 0, 0);
        handle = Handle(r0);
        if(handle != 0)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<uintptr_t, struct gocpp::error> MapViewOfFile(Handle handle, uint32_t access, uint32_t offsetHigh, uint32_t offsetLow, uintptr_t length)
    {
        uintptr_t addr;
        struct gocpp::error err;
        auto [r0, gocpp_id_189, e1] = Syscall6(Addr(gocpp::recv(procMapViewOfFile)), 5, uintptr_t(handle), uintptr_t(access), uintptr_t(offsetHigh), uintptr_t(offsetLow), uintptr_t(length), 0);
        addr = uintptr_t(r0);
        if(addr == 0)
        {
            uintptr_t addr;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {addr, err};
    }

    struct gocpp::error MoveFile(uint16_t* from, uint16_t* to)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_191, e1] = Syscall(Addr(gocpp::recv(procMoveFileW)), 2, uintptr_t(unsafe::Pointer(from)), uintptr_t(unsafe::Pointer(to)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> OpenProcess(uint32_t da, bool inheritHandle, uint32_t pid)
    {
        Handle handle;
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandle)
        {
            Handle handle;
            struct gocpp::error err;
            _p0 = 1;
        }
        auto [r0, gocpp_id_193, e1] = Syscall(Addr(gocpp::recv(procOpenProcess)), 3, uintptr_t(da), uintptr_t(_p0), uintptr_t(pid));
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error postQueuedCompletionStatus(Handle cphandle, uint32_t qty, uintptr_t key, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_195, e1] = Syscall6(Addr(gocpp::recv(procPostQueuedCompletionStatus)), 4, uintptr_t(cphandle), uintptr_t(qty), uintptr_t(key), uintptr_t(unsafe::Pointer(overlapped)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Process32First(Handle snapshot, struct ProcessEntry32* procEntry)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_197, e1] = Syscall(Addr(gocpp::recv(procProcess32FirstW)), 2, uintptr_t(snapshot), uintptr_t(unsafe::Pointer(procEntry)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Process32Next(Handle snapshot, struct ProcessEntry32* procEntry)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_199, e1] = Syscall(Addr(gocpp::recv(procProcess32NextW)), 2, uintptr_t(snapshot), uintptr_t(unsafe::Pointer(procEntry)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ReadConsole(Handle console, uint16_t* buf, uint32_t toread, uint32_t* read, unsigned char* inputControl)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_201, e1] = Syscall6(Addr(gocpp::recv(procReadConsoleW)), 5, uintptr_t(console), uintptr_t(unsafe::Pointer(buf)), uintptr_t(toread), uintptr_t(unsafe::Pointer(read)), uintptr_t(unsafe::Pointer(inputControl)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ReadDirectoryChanges(Handle handle, unsigned char* buf, uint32_t buflen, bool watchSubTree, uint32_t mask, uint32_t* retlen, struct Overlapped* overlapped, uintptr_t completionRoutine)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(watchSubTree)
        {
            struct gocpp::error err;
            _p0 = 1;
        }
        auto [r1, gocpp_id_203, e1] = Syscall9(Addr(gocpp::recv(procReadDirectoryChangesW)), 8, uintptr_t(handle), uintptr_t(unsafe::Pointer(buf)), uintptr_t(buflen), uintptr_t(_p0), uintptr_t(mask), uintptr_t(unsafe::Pointer(retlen)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(completionRoutine), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error readFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            struct gocpp::error err;
            _p0 = & buf[0];
        }
        auto [r1, gocpp_id_205, e1] = Syscall6(Addr(gocpp::recv(procReadFile)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(done)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error RemoveDirectory(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_207, e1] = Syscall(Addr(gocpp::recv(procRemoveDirectoryW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetCurrentDirectory(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_209, e1] = Syscall(Addr(gocpp::recv(procSetCurrentDirectoryW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetEndOfFile(Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_211, e1] = Syscall(Addr(gocpp::recv(procSetEndOfFile)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetEnvironmentVariable(uint16_t* name, uint16_t* value)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_213, e1] = Syscall(Addr(gocpp::recv(procSetEnvironmentVariableW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(value)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetFileAttributes(uint16_t* name, uint32_t attrs)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_215, e1] = Syscall(Addr(gocpp::recv(procSetFileAttributesW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(attrs), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetFileCompletionNotificationModes(Handle handle, uint8_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_217, e1] = Syscall(Addr(gocpp::recv(procSetFileCompletionNotificationModes)), 2, uintptr_t(handle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> SetFilePointer(Handle handle, int32_t lowoffset, int32_t* highoffsetptr, uint32_t whence)
    {
        uint32_t newlowoffset;
        struct gocpp::error err;
        auto [r0, gocpp_id_219, e1] = Syscall6(Addr(gocpp::recv(procSetFilePointer)), 4, uintptr_t(handle), uintptr_t(lowoffset), uintptr_t(unsafe::Pointer(highoffsetptr)), uintptr_t(whence), 0, 0);
        newlowoffset = uint32_t(r0);
        if(newlowoffset == 0xffffffff)
        {
            uint32_t newlowoffset;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {newlowoffset, err};
    }

    struct gocpp::error SetFileTime(Handle handle, struct Filetime* ctime, struct Filetime* atime, struct Filetime* wtime)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_221, e1] = Syscall6(Addr(gocpp::recv(procSetFileTime)), 4, uintptr_t(handle), uintptr_t(unsafe::Pointer(ctime)), uintptr_t(unsafe::Pointer(atime)), uintptr_t(unsafe::Pointer(wtime)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetHandleInformation(Handle handle, uint32_t mask, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_223, e1] = Syscall(Addr(gocpp::recv(procSetHandleInformation)), 3, uintptr_t(handle), uintptr_t(mask), uintptr_t(flags));
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error TerminateProcess(Handle handle, uint32_t exitcode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_225, e1] = Syscall(Addr(gocpp::recv(procTerminateProcess)), 2, uintptr_t(handle), uintptr_t(exitcode), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error UnmapViewOfFile(uintptr_t addr)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_227, e1] = Syscall(Addr(gocpp::recv(procUnmapViewOfFile)), 1, uintptr_t(addr), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error updateProcThreadAttribute(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t flags, uintptr_t attr, unsafe::Pointer value, uintptr_t size, unsafe::Pointer prevvalue, uintptr_t* returnedsize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_229, e1] = Syscall9(Addr(gocpp::recv(procUpdateProcThreadAttribute)), 7, uintptr_t(unsafe::Pointer(attrlist)), uintptr_t(flags), uintptr_t(attr), uintptr_t(value), uintptr_t(size), uintptr_t(prevvalue), uintptr_t(unsafe::Pointer(returnedsize)), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error VirtualLock(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_231, e1] = Syscall(Addr(gocpp::recv(procVirtualLock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error VirtualUnlock(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_233, e1] = Syscall(Addr(gocpp::recv(procVirtualUnlock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> WaitForSingleObject(Handle handle, uint32_t waitMilliseconds)
    {
        uint32_t event;
        struct gocpp::error err;
        auto [r0, gocpp_id_235, e1] = Syscall(Addr(gocpp::recv(procWaitForSingleObject)), 2, uintptr_t(handle), uintptr_t(waitMilliseconds), 0);
        event = uint32_t(r0);
        if(event == 0xffffffff)
        {
            uint32_t event;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {event, err};
    }

    struct gocpp::error WriteConsole(Handle console, uint16_t* buf, uint32_t towrite, uint32_t* written, unsigned char* reserved)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_237, e1] = Syscall6(Addr(gocpp::recv(procWriteConsoleW)), 5, uintptr_t(console), uintptr_t(unsafe::Pointer(buf)), uintptr_t(towrite), uintptr_t(unsafe::Pointer(written)), uintptr_t(unsafe::Pointer(reserved)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error writeFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            struct gocpp::error err;
            _p0 = & buf[0];
        }
        auto [r1, gocpp_id_239, e1] = Syscall6(Addr(gocpp::recv(procWriteFile)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(done)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error AcceptEx(Handle ls, Handle as, unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, uint32_t* recvd, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_241, e1] = Syscall9(Addr(gocpp::recv(procAcceptEx)), 8, uintptr_t(ls), uintptr_t(as), uintptr_t(unsafe::Pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    void GetAcceptExSockaddrs(unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, struct RawSockaddrAny** lrsa, int32_t* lrsalen, struct RawSockaddrAny** rrsa, int32_t* rrsalen)
    {
        Syscall9(Addr(gocpp::recv(procGetAcceptExSockaddrs)), 8, uintptr_t(unsafe::Pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(unsafe::Pointer(lrsa)), uintptr_t(unsafe::Pointer(lrsalen)), uintptr_t(unsafe::Pointer(rrsa)), uintptr_t(unsafe::Pointer(rrsalen)), 0);
        return;
    }

    struct gocpp::error TransmitFile(Handle s, Handle handle, uint32_t bytesToWrite, uint32_t bytsPerSend, struct Overlapped* overlapped, struct TransmitFileBuffers* transmitFileBuf, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_243, e1] = Syscall9(Addr(gocpp::recv(procTransmitFile)), 7, uintptr_t(s), uintptr_t(handle), uintptr_t(bytesToWrite), uintptr_t(bytsPerSend), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(transmitFileBuf)), uintptr_t(flags), 0, 0);
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error NetApiBufferFree(unsigned char* buf)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_246, gocpp_id_247] = Syscall(Addr(gocpp::recv(procNetApiBufferFree)), 1, uintptr_t(unsafe::Pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            struct gocpp::error neterr;
            neterr = Errno(r0);
        }
        return neterr;
    }

    struct gocpp::error NetGetJoinInformation(uint16_t* server, uint16_t** name, uint32_t* bufType)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_250, gocpp_id_251] = Syscall(Addr(gocpp::recv(procNetGetJoinInformation)), 3, uintptr_t(unsafe::Pointer(server)), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(bufType)));
        if(r0 != 0)
        {
            struct gocpp::error neterr;
            neterr = Errno(r0);
        }
        return neterr;
    }

    struct gocpp::error NetUserGetInfo(uint16_t* serverName, uint16_t* userName, uint32_t level, unsigned char** buf)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_254, gocpp_id_255] = Syscall6(Addr(gocpp::recv(procNetUserGetInfo)), 4, uintptr_t(unsafe::Pointer(serverName)), uintptr_t(unsafe::Pointer(userName)), uintptr_t(level), uintptr_t(unsafe::Pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            struct gocpp::error neterr;
            neterr = Errno(r0);
        }
        return neterr;
    }

    void rtlGetNtVersionNumbers(uint32_t* majorVersion, uint32_t* minorVersion, uint32_t* buildNumber)
    {
        Syscall(Addr(gocpp::recv(procRtlGetNtVersionNumbers)), 3, uintptr_t(unsafe::Pointer(majorVersion)), uintptr_t(unsafe::Pointer(minorVersion)), uintptr_t(unsafe::Pointer(buildNumber)));
        return;
    }

    struct gocpp::error GetUserNameEx(uint32_t nameFormat, uint16_t* nameBuffre, uint32_t* nSize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_257, e1] = Syscall(Addr(gocpp::recv(procGetUserNameExW)), 3, uintptr_t(nameFormat), uintptr_t(unsafe::Pointer(nameBuffre)), uintptr_t(unsafe::Pointer(nSize)));
        if(r1 & 0xff == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error TranslateName(uint16_t* accName, uint32_t accNameFormat, uint32_t desiredNameFormat, uint16_t* translatedName, uint32_t* nSize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_259, e1] = Syscall6(Addr(gocpp::recv(procTranslateNameW)), 5, uintptr_t(unsafe::Pointer(accName)), uintptr_t(accNameFormat), uintptr_t(desiredNameFormat), uintptr_t(unsafe::Pointer(translatedName)), uintptr_t(unsafe::Pointer(nSize)), 0);
        if(r1 & 0xff == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*, struct gocpp::error> CommandLineToArgv(uint16_t* cmd, int32_t* argc)
    {
        gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>* argv;
        struct gocpp::error err;
        auto [r0, gocpp_id_261, e1] = Syscall(Addr(gocpp::recv(procCommandLineToArgvW)), 2, uintptr_t(unsafe::Pointer(cmd)), uintptr_t(unsafe::Pointer(argc)), 0);
        argv = (gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*)(unsafe::Pointer(r0));
        if(argv == nullptr)
        {
            gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>* argv;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {argv, err};
    }

    struct gocpp::error GetUserProfileDirectory(Token t, uint16_t* dir, uint32_t* dirLen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_263, e1] = Syscall(Addr(gocpp::recv(procGetUserProfileDirectoryW)), 3, uintptr_t(t), uintptr_t(unsafe::Pointer(dir)), uintptr_t(unsafe::Pointer(dirLen)));
        if(r1 == 0)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    void FreeAddrInfoW(struct AddrinfoW* addrinfo)
    {
        Syscall(Addr(gocpp::recv(procFreeAddrInfoW)), 1, uintptr_t(unsafe::Pointer(addrinfo)), 0, 0);
        return;
    }

    struct gocpp::error GetAddrInfoW(uint16_t* nodename, uint16_t* servicename, struct AddrinfoW* hints, struct AddrinfoW** result)
    {
        struct gocpp::error sockerr;
        auto [r0, gocpp_id_266, gocpp_id_267] = Syscall6(Addr(gocpp::recv(procGetAddrInfoW)), 4, uintptr_t(unsafe::Pointer(nodename)), uintptr_t(unsafe::Pointer(servicename)), uintptr_t(unsafe::Pointer(hints)), uintptr_t(unsafe::Pointer(result)), 0, 0);
        if(r0 != 0)
        {
            struct gocpp::error sockerr;
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    struct gocpp::error WSACleanup()
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_269, e1] = Syscall(Addr(gocpp::recv(procWSACleanup)), 0, 0, 0, 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<int32_t, struct gocpp::error> WSAEnumProtocols(int32_t* protocols, struct WSAProtocolInfo* protocolBuffer, uint32_t* bufferLength)
    {
        int32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_271, e1] = Syscall(Addr(gocpp::recv(procWSAEnumProtocolsW)), 3, uintptr_t(unsafe::Pointer(protocols)), uintptr_t(unsafe::Pointer(protocolBuffer)), uintptr_t(unsafe::Pointer(bufferLength)));
        n = int32_t(r0);
        if(n == - 1)
        {
            int32_t n;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error WSAIoctl(Handle s, uint32_t iocc, unsigned char* inbuf, uint32_t cbif, unsigned char* outbuf, uint32_t cbob, uint32_t* cbbr, struct Overlapped* overlapped, uintptr_t completionRoutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_273, e1] = Syscall9(Addr(gocpp::recv(procWSAIoctl)), 9, uintptr_t(s), uintptr_t(iocc), uintptr_t(unsafe::Pointer(inbuf)), uintptr_t(cbif), uintptr_t(unsafe::Pointer(outbuf)), uintptr_t(cbob), uintptr_t(unsafe::Pointer(cbbr)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(completionRoutine));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSARecv(Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_275, e1] = Syscall9(Addr(gocpp::recv(procWSARecv)), 7, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(flags)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSARecvFrom(Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, struct RawSockaddrAny* from, int32_t* fromlen, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_277, e1] = Syscall9(Addr(gocpp::recv(procWSARecvFrom)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(flags)), uintptr_t(unsafe::Pointer(from)), uintptr_t(unsafe::Pointer(fromlen)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSASend(Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_279, e1] = Syscall9(Addr(gocpp::recv(procWSASend)), 7, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSASendTo(Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct RawSockaddrAny* to, int32_t tolen, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_281, e1] = Syscall9(Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(to)), uintptr_t(tolen), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSAStartup(uint32_t verreq, struct WSAData* data)
    {
        struct gocpp::error sockerr;
        auto [r0, gocpp_id_284, gocpp_id_285] = Syscall(Addr(gocpp::recv(procWSAStartup)), 2, uintptr_t(verreq), uintptr_t(unsafe::Pointer(data)), 0);
        if(r0 != 0)
        {
            struct gocpp::error sockerr;
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    struct gocpp::error bind(Handle s, unsafe::Pointer name, int32_t namelen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_287, e1] = Syscall(Addr(gocpp::recv(procbind)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Closesocket(Handle s)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_289, e1] = Syscall(Addr(gocpp::recv(procclosesocket)), 1, uintptr_t(s), 0, 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error connect(Handle s, unsafe::Pointer name, int32_t namelen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_291, e1] = Syscall(Addr(gocpp::recv(procconnect)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct Hostent*, struct gocpp::error> GetHostByName(std::string name)
    {
        struct Hostent* h;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            struct Hostent* h;
            struct gocpp::error err;
            return {h, err};
        }
        return _GetHostByName(_p0);
    }

    std::tuple<struct Hostent*, struct gocpp::error> _GetHostByName(unsigned char* name)
    {
        struct Hostent* h;
        struct gocpp::error err;
        auto [r0, gocpp_id_293, e1] = Syscall(Addr(gocpp::recv(procgethostbyname)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        h = (Hostent*)(unsafe::Pointer(r0));
        if(h == nullptr)
        {
            struct Hostent* h;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {h, err};
    }

    struct gocpp::error getpeername(Handle s, struct RawSockaddrAny* rsa, int32_t* addrlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_295, e1] = Syscall(Addr(gocpp::recv(procgetpeername)), 3, uintptr_t(s), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(unsafe::Pointer(addrlen)));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct Protoent*, struct gocpp::error> GetProtoByName(std::string name)
    {
        struct Protoent* p;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            struct Protoent* p;
            struct gocpp::error err;
            return {p, err};
        }
        return _GetProtoByName(_p0);
    }

    std::tuple<struct Protoent*, struct gocpp::error> _GetProtoByName(unsigned char* name)
    {
        struct Protoent* p;
        struct gocpp::error err;
        auto [r0, gocpp_id_297, e1] = Syscall(Addr(gocpp::recv(procgetprotobyname)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        p = (Protoent*)(unsafe::Pointer(r0));
        if(p == nullptr)
        {
            struct Protoent* p;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {p, err};
    }

    std::tuple<struct Servent*, struct gocpp::error> GetServByName(std::string name, std::string proto)
    {
        struct Servent* s;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            struct Servent* s;
            struct gocpp::error err;
            return {s, err};
        }
        unsigned char* _p1 = {};
        std::tie(_p1, err) = BytePtrFromString(proto);
        if(err != nullptr)
        {
            struct Servent* s;
            struct gocpp::error err;
            return {s, err};
        }
        return _GetServByName(_p0, _p1);
    }

    std::tuple<struct Servent*, struct gocpp::error> _GetServByName(unsigned char* name, unsigned char* proto)
    {
        struct Servent* s;
        struct gocpp::error err;
        auto [r0, gocpp_id_299, e1] = Syscall(Addr(gocpp::recv(procgetservbyname)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(proto)), 0);
        s = (Servent*)(unsafe::Pointer(r0));
        if(s == nullptr)
        {
            struct Servent* s;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {s, err};
    }

    struct gocpp::error getsockname(Handle s, struct RawSockaddrAny* rsa, int32_t* addrlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_301, e1] = Syscall(Addr(gocpp::recv(procgetsockname)), 3, uintptr_t(s), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(unsafe::Pointer(addrlen)));
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Getsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t* optlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_303, e1] = Syscall6(Addr(gocpp::recv(procgetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(unsafe::Pointer(optval)), uintptr_t(unsafe::Pointer(optlen)), 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error listen(Handle s, int32_t backlog)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_305, e1] = Syscall(Addr(gocpp::recv(proclisten)), 2, uintptr_t(s), uintptr_t(backlog), 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t Ntohs(uint16_t netshort)
    {
        uint16_t u;
        auto [r0, gocpp_id_308, gocpp_id_309] = Syscall(Addr(gocpp::recv(procntohs)), 1, uintptr_t(netshort), 0, 0);
        u = uint16_t(r0);
        return u;
    }

    struct gocpp::error Setsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t optlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_311, e1] = Syscall6(Addr(gocpp::recv(procsetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(unsafe::Pointer(optval)), uintptr_t(optlen), 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error shutdown(Handle s, int32_t how)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_313, e1] = Syscall(Addr(gocpp::recv(procshutdown)), 2, uintptr_t(s), uintptr_t(how), 0);
        if(r1 == socket_error)
        {
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, struct gocpp::error> socket(int32_t af, int32_t typ, int32_t protocol)
    {
        Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_315, e1] = Syscall(Addr(gocpp::recv(procsocket)), 3, uintptr_t(af), uintptr_t(typ), uintptr_t(protocol));
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            struct gocpp::error err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

}

