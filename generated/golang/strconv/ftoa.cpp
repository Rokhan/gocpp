// generated by GoCpp from file '$(ImportDir)/strconv/ftoa.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/ftoa.h"
#include "gocpp/support.h"

#include "golang/math/unsafe.h"
#include "golang/strconv/atoi.h"
#include "golang/strconv/decimal.h"
#include "golang/strconv/ftoaryu.h"
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"

namespace golang::strconv
{
    
    template<typename T> requires gocpp::GoStruct<T>
    floatInfo::operator T()
    {
        T result;
        result.mantbits = this->mantbits;
        result.expbits = this->expbits;
        result.bias = this->bias;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool floatInfo::operator==(const T& ref) const
    {
        if (mantbits != ref.mantbits) return false;
        if (expbits != ref.expbits) return false;
        if (bias != ref.bias) return false;
        return true;
    }

    std::ostream& floatInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mantbits;
        os << " " << expbits;
        os << " " << bias;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct floatInfo& value)
    {
        return value.PrintTo(os);
    }

    floatInfo float32info = floatInfo {23, 8, - 127};
    floatInfo float64info = floatInfo {52, 11, - 1023};
    std::string FormatFloat(double f, unsigned char fmt, int prec, int bitSize)
    {
        return string(genericFtoa(gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, max(prec + 4, 24)), f, fmt, prec, bitSize));
    }

    gocpp::slice<unsigned char> AppendFloat(gocpp::slice<unsigned char> dst, double f, unsigned char fmt, int prec, int bitSize)
    {
        return genericFtoa(dst, f, fmt, prec, bitSize);
    }

    gocpp::slice<unsigned char> genericFtoa(gocpp::slice<unsigned char> dst, double val, unsigned char fmt, int prec, int bitSize)
    {
        uint64_t bits = {};
        floatInfo* flt = {};
        //Go switch emulation
        {
            auto condition = bitSize;
            int conditionId = -1;
            if(condition == 32) { conditionId = 0; }
            else if(condition == 64) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    bits = uint64_t(math::Float32bits(float(val)));
                    flt = & float32info;
                    break;
                case 1:
                    bits = math::Float64bits(val);
                    flt = & float64info;
                    break;
                default:
                    gocpp::panic("strconv: illegal AppendFloat/FormatFloat bitSize");
                    break;
            }
        }
        auto neg = (bits >> (flt->expbits + flt->mantbits)) != 0;
        auto exp = int(bits >> flt->mantbits) & ((1 << flt->expbits) - 1);
        auto mant = bits & ((uint64_t(1) << flt->mantbits) - 1);
        //Go switch emulation
        {
            auto condition = exp;
            int conditionId = -1;
            if(condition == (1 << flt->expbits) - 1) { conditionId = 0; }
            else if(condition == 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    std::string s = {};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(mant != 0) { conditionId = 0; }
                        else if(neg) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                s = "NaN";
                                break;
                            case 1:
                                s = "-Inf";
                                break;
                            default:
                                s = "+Inf";
                                break;
                        }
                    }
                    return append(dst, s);
                    break;
                case 1:
                    exp++;
                    break;
                default:
                    mant |= uint64_t(1) << flt->mantbits;
                    break;
            }
        }
        exp += flt->bias;
        if(fmt == 'b')
        {
            return fmtB(dst, neg, mant, exp, flt);
        }
        if(fmt == 'x' || fmt == 'X')
        {
            return fmtX(dst, prec, fmt, neg, mant, exp, flt);
        }
        if(! optimize)
        {
            return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
        }
        decimalSlice digs = {};
        auto ok = false;
        auto shortest = prec < 0;
        if(shortest)
        {
            gocpp::array<unsigned char, 32> buf = {};
            digs.d = buf.make_slice(0, );
            ryuFtoaShortest(& digs, mant, exp - int(flt->mantbits), flt);
            ok = true;
            //Go switch emulation
            {
                auto condition = fmt;
                int conditionId = -1;
                if(condition == 'e') { conditionId = 0; }
                if(condition == 'E') { conditionId = 1; }
                else if(condition == 'f') { conditionId = 2; }
                else if(condition == 'g') { conditionId = 3; }
                else if(condition == 'G') { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        prec = max(digs.nd - 1, 0);
                        break;
                    case 2:
                        prec = max(digs.nd - digs.dp, 0);
                        break;
                    case 3:
                    case 4:
                        prec = digs.nd;
                        break;
                }
            }
        }
        else
        if(fmt != 'f')
        {
            auto digits = prec;
            //Go switch emulation
            {
                auto condition = fmt;
                int conditionId = -1;
                if(condition == 'e') { conditionId = 0; }
                if(condition == 'E') { conditionId = 1; }
                else if(condition == 'g') { conditionId = 2; }
                else if(condition == 'G') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        digits++;
                        break;
                    case 2:
                    case 3:
                        if(prec == 0)
                        {
                            prec = 1;
                        }
                        digits = prec;
                        break;
                    default:
                        digits = 1;
                        break;
                }
            }
            gocpp::array<unsigned char, 24> buf = {};
            if(bitSize == 32 && digits <= 9)
            {
                digs.d = buf.make_slice(0, );
                ryuFtoaFixed32(& digs, uint32_t(mant), exp - int(flt->mantbits), digits);
                ok = true;
            }
            else
            if(digits <= 18)
            {
                digs.d = buf.make_slice(0, );
                ryuFtoaFixed64(& digs, mant, exp - int(flt->mantbits), digits);
                ok = true;
            }
        }
        if(! ok)
        {
            return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
        }
        return formatDigits(dst, shortest, neg, digs, prec, fmt);
    }

    gocpp::slice<unsigned char> bigFtoa(gocpp::slice<unsigned char> dst, int prec, unsigned char fmt, bool neg, uint64_t mant, int exp, floatInfo* flt)
    {
        auto d = go_new(decimal);
        Assign(gocpp::recv(d), mant);
        Shift(gocpp::recv(d), exp - int(flt->mantbits));
        decimalSlice digs = {};
        auto shortest = prec < 0;
        if(shortest)
        {
            roundShortest(d, mant, exp, flt);
            digs = gocpp::Init<decimalSlice>([](decimalSlice& x) { x.d = d->d.make_slice(0, ); x.nd = d->nd; x.dp = d->dp; });
            //Go switch emulation
            {
                auto condition = fmt;
                int conditionId = -1;
                if(condition == 'e') { conditionId = 0; }
                if(condition == 'E') { conditionId = 1; }
                else if(condition == 'f') { conditionId = 2; }
                else if(condition == 'g') { conditionId = 3; }
                else if(condition == 'G') { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        prec = digs.nd - 1;
                        break;
                    case 2:
                        prec = max(digs.nd - digs.dp, 0);
                        break;
                    case 3:
                    case 4:
                        prec = digs.nd;
                        break;
                }
            }
        }
        else
        {
            //Go switch emulation
            {
                auto condition = fmt;
                int conditionId = -1;
                if(condition == 'e') { conditionId = 0; }
                if(condition == 'E') { conditionId = 1; }
                else if(condition == 'f') { conditionId = 2; }
                else if(condition == 'g') { conditionId = 3; }
                else if(condition == 'G') { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        Round(gocpp::recv(d), prec + 1);
                        break;
                    case 2:
                        Round(gocpp::recv(d), d->dp + prec);
                        break;
                    case 3:
                    case 4:
                        if(prec == 0)
                        {
                            prec = 1;
                        }
                        Round(gocpp::recv(d), prec);
                        break;
                }
            }
            digs = gocpp::Init<decimalSlice>([](decimalSlice& x) { x.d = d->d.make_slice(0, ); x.nd = d->nd; x.dp = d->dp; });
        }
        return formatDigits(dst, shortest, neg, digs, prec, fmt);
    }

    gocpp::slice<unsigned char> formatDigits(gocpp::slice<unsigned char> dst, bool shortest, bool neg, decimalSlice digs, int prec, unsigned char fmt)
    {
        //Go switch emulation
        {
            auto condition = fmt;
            int conditionId = -1;
            if(condition == 'e') { conditionId = 0; }
            if(condition == 'E') { conditionId = 1; }
            else if(condition == 'f') { conditionId = 2; }
            else if(condition == 'g') { conditionId = 3; }
            else if(condition == 'G') { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    return fmtE(dst, neg, digs, prec, fmt);
                    break;
                case 2:
                    return fmtF(dst, neg, digs, prec);
                    break;
                case 3:
                case 4:
                    auto eprec = prec;
                    if(eprec > digs.nd && digs.nd >= digs.dp)
                    {
                        eprec = digs.nd;
                    }
                    if(shortest)
                    {
                        eprec = 6;
                    }
                    auto exp = digs.dp - 1;
                    if(exp < - 4 || exp >= eprec)
                    {
                        if(prec > digs.nd)
                        {
                            prec = digs.nd;
                        }
                        return fmtE(dst, neg, digs, prec - 1, fmt + 'e' - 'g');
                    }
                    if(prec > digs.dp)
                    {
                        prec = digs.nd;
                    }
                    return fmtF(dst, neg, digs, max(prec - digs.dp, 0));
                    break;
            }
        }
        return append(dst, '%', fmt);
    }

    void roundShortest(decimal* d, uint64_t mant, int exp, floatInfo* flt)
    {
        if(mant == 0)
        {
            d->nd = 0;
            return;
        }
        auto minexp = flt->bias + 1;
        if(exp > minexp && 332 * (d->dp - d->nd) >= 100 * (exp - int(flt->mantbits)))
        {
            return;
        }
        auto upper = go_new(decimal);
        Assign(gocpp::recv(upper), mant * 2 + 1);
        Shift(gocpp::recv(upper), exp - int(flt->mantbits) - 1);
        uint64_t mantlo = {};
        int explo = {};
        if(mant > (1 << flt->mantbits) || exp == minexp)
        {
            mantlo = mant - 1;
            explo = exp;
        }
        else
        {
            mantlo = mant * 2 - 1;
            explo = exp - 1;
        }
        auto lower = go_new(decimal);
        Assign(gocpp::recv(lower), mantlo * 2 + 1);
        Shift(gocpp::recv(lower), explo - int(flt->mantbits) - 1);
        auto inclusive = mant % 2 == 0;
        uint8_t upperdelta = {};
        for(auto ui = 0; ; ui++)
        {
            auto mi = ui - upper->dp + d->dp;
            if(mi >= d->nd)
            {
                break;
            }
            auto li = ui - upper->dp + lower->dp;
            auto l = unsigned char('0');
            if(li >= 0 && li < lower->nd)
            {
                l = lower->d[li];
            }
            auto m = unsigned char('0');
            if(mi >= 0)
            {
                m = d->d[mi];
            }
            auto u = unsigned char('0');
            if(ui < upper->nd)
            {
                u = upper->d[ui];
            }
            auto okdown = l != m || inclusive && li + 1 == lower->nd;
            //Go switch emulation
            {
                int conditionId = -1;
                if(upperdelta == 0 && m + 1 < u) { conditionId = 0; }
                else if(upperdelta == 0 && m != u) { conditionId = 1; }
                else if(upperdelta == 1 && (m != '9' || u != '0')) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        upperdelta = 2;
                        break;
                    case 1:
                        upperdelta = 1;
                        break;
                    case 2:
                        upperdelta = 2;
                        break;
                }
            }
            auto okup = upperdelta > 0 && (inclusive || upperdelta > 1 || ui + 1 < upper->nd);
            //Go switch emulation
            {
                int conditionId = -1;
                if(okdown && okup) { conditionId = 0; }
                else if(okdown) { conditionId = 1; }
                else if(okup) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        Round(gocpp::recv(d), mi + 1);
                        return;
                        break;
                    case 1:
                        RoundDown(gocpp::recv(d), mi + 1);
                        return;
                        break;
                    case 2:
                        RoundUp(gocpp::recv(d), mi + 1);
                        return;
                        break;
                }
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    decimalSlice::operator T()
    {
        T result;
        result.d = this->d;
        result.nd = this->nd;
        result.dp = this->dp;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decimalSlice::operator==(const T& ref) const
    {
        if (d != ref.d) return false;
        if (nd != ref.nd) return false;
        if (dp != ref.dp) return false;
        return true;
    }

    std::ostream& decimalSlice::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << d;
        os << " " << nd;
        os << " " << dp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decimalSlice& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<unsigned char> fmtE(gocpp::slice<unsigned char> dst, bool neg, decimalSlice d, int prec, unsigned char fmt)
    {
        if(neg)
        {
            dst = append(dst, '-');
        }
        auto ch = unsigned char('0');
        if(d.nd != 0)
        {
            ch = d.d[0];
        }
        dst = append(dst, ch);
        if(prec > 0)
        {
            dst = append(dst, '.');
            auto i = 1;
            auto m = min(d.nd, prec + 1);
            if(i < m)
            {
                dst = append(dst, d.d.make_slice(i, m));
                i = m;
            }
            for(; i <= prec; i++)
            {
                dst = append(dst, '0');
            }
        }
        dst = append(dst, fmt);
        auto exp = d.dp - 1;
        if(d.nd == 0)
        {
            exp = 0;
        }
        if(exp < 0)
        {
            ch = '-';
            exp = - exp;
        }
        else
        {
            ch = '+';
        }
        dst = append(dst, ch);
        //Go switch emulation
        {
            int conditionId = -1;
            if(exp < 10) { conditionId = 0; }
            else if(exp < 100) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    dst = append(dst, '0', unsigned char(exp) + '0');
                    break;
                case 1:
                    dst = append(dst, unsigned char(exp / 10) + '0', unsigned char(exp % 10) + '0');
                    break;
                default:
                    dst = append(dst, unsigned char(exp / 100) + '0', unsigned char(exp / 10) % 10 + '0', unsigned char(exp % 10) + '0');
                    break;
            }
        }
        return dst;
    }

    gocpp::slice<unsigned char> fmtF(gocpp::slice<unsigned char> dst, bool neg, decimalSlice d, int prec)
    {
        if(neg)
        {
            dst = append(dst, '-');
        }
        if(d.dp > 0)
        {
            auto m = min(d.nd, d.dp);
            dst = append(dst, d.d.make_slice(0, m));
            for(; m < d.dp; m++)
            {
                dst = append(dst, '0');
            }
        }
        else
        {
            dst = append(dst, '0');
        }
        if(prec > 0)
        {
            dst = append(dst, '.');
            for(auto i = 0; i < prec; i++)
            {
                auto ch = unsigned char('0');
                if(auto j = d.dp + i; 0 <= j && j < d.nd)
                {
                    ch = d.d[j];
                }
                dst = append(dst, ch);
            }
        }
        return dst;
    }

    gocpp::slice<unsigned char> fmtB(gocpp::slice<unsigned char> dst, bool neg, uint64_t mant, int exp, floatInfo* flt)
    {
        if(neg)
        {
            dst = append(dst, '-');
        }
        std::tie(dst, gocpp_id_0) = formatBits(dst, mant, 10, false, true);
        dst = append(dst, 'p');
        exp -= int(flt->mantbits);
        if(exp >= 0)
        {
            dst = append(dst, '+');
        }
        std::tie(dst, gocpp_id_1) = formatBits(dst, uint64_t(exp), 10, exp < 0, true);
        return dst;
    }

    gocpp::slice<unsigned char> fmtX(gocpp::slice<unsigned char> dst, int prec, unsigned char fmt, bool neg, uint64_t mant, int exp, floatInfo* flt)
    {
        if(mant == 0)
        {
            exp = 0;
        }
        mant <<= 60 - flt->mantbits;
        for(; mant != 0 && mant & (1 << 60) == 0; )
        {
            mant <<= 1;
            exp--;
        }
        if(prec >= 0 && prec < 15)
        {
            auto shift = (unsigned int)(prec * 4);
            auto extra = (mant << shift) & ((1 << 60) - 1);
            mant >>= 60 - shift;
            if(extra | (mant & 1) > (1 << 59))
            {
                mant++;
            }
            mant <<= 60 - shift;
            if(mant & (1 << 61) != 0)
            {
                mant >>= 1;
                exp++;
            }
        }
        auto hex = lowerhex;
        if(fmt == 'X')
        {
            hex = upperhex;
        }
        if(neg)
        {
            dst = append(dst, '-');
        }
        dst = append(dst, '0', fmt, '0' + unsigned char((mant >> 60) & 1));
        mant <<= 4;
        if(prec < 0 && mant != 0)
        {
            dst = append(dst, '.');
            for(; mant != 0; )
            {
                dst = append(dst, hex[(mant >> 60) & 15]);
                mant <<= 4;
            }
        }
        else
        if(prec > 0)
        {
            dst = append(dst, '.');
            for(auto i = 0; i < prec; i++)
            {
                dst = append(dst, hex[(mant >> 60) & 15]);
                mant <<= 4;
            }
        }
        auto ch = unsigned char('P');
        if(fmt == lower(fmt))
        {
            ch = 'p';
        }
        dst = append(dst, ch);
        if(exp < 0)
        {
            ch = '-';
            exp = - exp;
        }
        else
        {
            ch = '+';
        }
        dst = append(dst, ch);
        //Go switch emulation
        {
            int conditionId = -1;
            if(exp < 100) { conditionId = 0; }
            else if(exp < 1000) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    dst = append(dst, unsigned char(exp / 10) + '0', unsigned char(exp % 10) + '0');
                    break;
                case 1:
                    dst = append(dst, unsigned char(exp / 100) + '0', unsigned char((exp / 10) % 10) + '0', unsigned char(exp % 10) + '0');
                    break;
                default:
                    dst = append(dst, unsigned char(exp / 1000) + '0', unsigned char(exp / 100) % 10 + '0', unsigned char((exp / 10) % 10) + '0', unsigned char(exp % 10) + '0');
                    break;
            }
        }
        return dst;
    }

}

