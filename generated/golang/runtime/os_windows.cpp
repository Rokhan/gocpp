// generated by GoCpp from file '$(ImportDir)/runtime/os_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/os_windows.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/defs_windows.h"
#include "golang/runtime/defs_windows_amd64.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/netpoll_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/preempt.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/select.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sigqueue.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/stubs_amd64.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/syscall_windows.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
    }

    // TODO(brainman): should not need those
    // Following syscalls are available on every Windows PC.
    // All these variables are set by the Windows executable
    // loader before the Go program starts.
    // Use ProcessPrng to generate cryptographically random data.
    // Load ntdll.dll manually during startup, otherwise Mingw
    // links wrong printf function to cgo executable (see issue
    // 12030 for details).
    // These are from non-kernel32.dll, so we prefer to LoadLibraryEx them.
    runtime::stdFunction _AddVectoredContinueHandler;
    runtime::stdFunction _AddVectoredExceptionHandler;
    runtime::stdFunction _CloseHandle;
    runtime::stdFunction _CreateEventA;
    runtime::stdFunction _CreateFileA;
    runtime::stdFunction _CreateIoCompletionPort;
    runtime::stdFunction _CreateThread;
    runtime::stdFunction _CreateWaitableTimerA;
    runtime::stdFunction _CreateWaitableTimerExW;
    runtime::stdFunction _DuplicateHandle;
    runtime::stdFunction _ExitProcess;
    runtime::stdFunction _FreeEnvironmentStringsW;
    runtime::stdFunction _GetConsoleMode;
    runtime::stdFunction _GetCurrentThreadId;
    runtime::stdFunction _GetEnvironmentStringsW;
    runtime::stdFunction _GetErrorMode;
    runtime::stdFunction _GetProcAddress;
    runtime::stdFunction _GetProcessAffinityMask;
    runtime::stdFunction _GetQueuedCompletionStatusEx;
    runtime::stdFunction _GetStdHandle;
    runtime::stdFunction _GetSystemDirectoryA;
    runtime::stdFunction _GetSystemInfo;
    runtime::stdFunction _GetThreadContext;
    runtime::stdFunction _SetThreadContext;
    runtime::stdFunction _LoadLibraryExW;
    runtime::stdFunction _LoadLibraryW;
    runtime::stdFunction _PostQueuedCompletionStatus;
    runtime::stdFunction _QueryPerformanceCounter;
    runtime::stdFunction _RaiseFailFastException;
    runtime::stdFunction _ResumeThread;
    runtime::stdFunction _RtlLookupFunctionEntry;
    runtime::stdFunction _RtlVirtualUnwind;
    runtime::stdFunction _SetConsoleCtrlHandler;
    runtime::stdFunction _SetErrorMode;
    runtime::stdFunction _SetEvent;
    runtime::stdFunction _SetProcessPriorityBoost;
    runtime::stdFunction _SetThreadPriority;
    runtime::stdFunction _SetUnhandledExceptionFilter;
    runtime::stdFunction _SetWaitableTimer;
    runtime::stdFunction _SuspendThread;
    runtime::stdFunction _SwitchToThread;
    runtime::stdFunction _TlsAlloc;
    runtime::stdFunction _VirtualAlloc;
    runtime::stdFunction _VirtualFree;
    runtime::stdFunction _VirtualQuery;
    runtime::stdFunction _WaitForSingleObject;
    runtime::stdFunction _WaitForMultipleObjects;
    runtime::stdFunction _WerGetFlags;
    runtime::stdFunction _WerSetFlags;
    runtime::stdFunction _WriteConsoleW;
    runtime::stdFunction _WriteFile;
    runtime::stdFunction _;
    runtime::stdFunction _ProcessPrng;
    runtime::stdFunction _RtlGetCurrentPeb;
    runtime::stdFunction _RtlGetNtVersionNumbers;
    runtime::stdFunction _timeBeginPeriod;
    runtime::stdFunction _timeEndPeriod;
    runtime::stdFunction _WSAGetOverlappedResult;
    runtime::stdFunction _;
    gocpp::array<uint16_t, 21> bcryptprimitivesdll = gocpp::array<uint16_t, 21> {'b', 'c', 'r', 'y', 'p', 't', 'p', 'r', 'i', 'm', 'i', 't', 'i', 'v', 'e', 's', '.', 'd', 'l', 'l', 0};
    gocpp::array<uint16_t, 10> ntdlldll = gocpp::array<uint16_t, 10> {'n', 't', 'd', 'l', 'l', '.', 'd', 'l', 'l', 0};
    gocpp::array<uint16_t, 13> powrprofdll = gocpp::array<uint16_t, 13> {'p', 'o', 'w', 'r', 'p', 'r', 'o', 'f', '.', 'd', 'l', 'l', 0};
    gocpp::array<uint16_t, 10> winmmdll = gocpp::array<uint16_t, 10> {'w', 'i', 'n', 'm', 'm', '.', 'd', 'l', 'l', 0};
    gocpp::array<uint16_t, 11> ws2_32dll = gocpp::array<uint16_t, 11> {'w', 's', '2', '_', '3', '2', '.', 'd', 'l', 'l', 0};
    // Function to be called by windows CreateThread
    // to start new os thread.
    void tstart_stdcall(struct m* newm)
    /* convertBlockStmt, nil block */;

    // Init-time helper
    void wintls()
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    mOS::operator T()
    {
        T result;
        result.threadLock = this->threadLock;
        result.thread = this->thread;
        result.waitsema = this->waitsema;
        result.resumesema = this->resumesema;
        result.highResTimer = this->highResTimer;
        result.preemptExtLock = this->preemptExtLock;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mOS::operator==(const T& ref) const
    {
        if (threadLock != ref.threadLock) return false;
        if (thread != ref.thread) return false;
        if (waitsema != ref.waitsema) return false;
        if (resumesema != ref.resumesema) return false;
        if (highResTimer != ref.highResTimer) return false;
        if (preemptExtLock != ref.preemptExtLock) return false;
        return true;
    }

    std::ostream& mOS::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << threadLock;
        os << " " << thread;
        os << " " << waitsema;
        os << " " << resumesema;
        os << " " << highResTimer;
        os << " " << preemptExtLock;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mOS& value)
    {
        return value.PrintTo(os);
    }

    // Stubs so tests can link correctly. These should never be called.
    int32_t open(unsigned char* name, int32_t mode, int32_t perm)
    {
        go_throw("unimplemented"_s);
        return - 1;
    }

    int32_t closefd(int32_t fd)
    {
        go_throw("unimplemented"_s);
        return - 1;
    }

    int32_t read(int32_t fd, gocpp::unsafe_pointer p, int32_t n)
    {
        go_throw("unimplemented"_s);
        return - 1;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    sigset::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sigset::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& sigset::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sigset& value)
    {
        return value.PrintTo(os);
    }

    // Call a Windows function with stdcall conventions,
    // and switch to os stack during the call.
    void asmstdcall(gocpp::unsafe_pointer fn)
    /* convertBlockStmt, nil block */;

    gocpp::unsafe_pointer asmstdcallAddr;
    runtime::stdFunction windowsFindfunc(uintptr_t lib, gocpp::slice<unsigned char> name)
    {
        if(name[len(name) - 1] != 0)
        {
            go_throw("usage"_s);
        }
        auto f = stdcall2(_GetProcAddress, lib, uintptr_t(gocpp::unsafe_pointer(& name[0])));
        return stdFunction(gocpp::unsafe_pointer(f));
    }

    gocpp::array<unsigned char, _MAX_PATH + 1> sysDirectory;
    uintptr_t sysDirectoryLen;
    void initSysDirectory()
    {
        auto l = stdcall2(_GetSystemDirectoryA, uintptr_t(gocpp::unsafe_pointer(& sysDirectory[0])), uintptr_t(len(sysDirectory) - 1));
        if(l == 0 || l > uintptr_t(len(sysDirectory) - 1))
        {
            go_throw("Unable to determine system directory"_s);
        }
        sysDirectory[l] = '\\';
        sysDirectoryLen = l + 1;
    }

    //go:linkname windows_GetSystemDirectory internal/syscall/windows.GetSystemDirectory
    gocpp::string windows_GetSystemDirectory()
    {
        return unsafe::String(& sysDirectory[0], sysDirectoryLen);
    }

    uintptr_t windowsLoadSystemLib(gocpp::slice<uint16_t> name)
    {
        return stdcall3(_LoadLibraryExW, uintptr_t(gocpp::unsafe_pointer(& name[0])), 0, _LOAD_LIBRARY_SEARCH_SYSTEM32);
    }

    void loadOptionalSyscalls()
    {
        auto bcryptPrimitives = windowsLoadSystemLib(bcryptprimitivesdll.make_slice(0));
        if(bcryptPrimitives == 0)
        {
            go_throw("bcryptprimitives.dll not found"_s);
        }
        _ProcessPrng = windowsFindfunc(bcryptPrimitives, gocpp::slice<unsigned char>("ProcessPrng\000"_s));
        auto n32 = windowsLoadSystemLib(ntdlldll.make_slice(0));
        if(n32 == 0)
        {
            go_throw("ntdll.dll not found"_s);
        }
        _RtlGetCurrentPeb = windowsFindfunc(n32, gocpp::slice<unsigned char>("RtlGetCurrentPeb\000"_s));
        _RtlGetNtVersionNumbers = windowsFindfunc(n32, gocpp::slice<unsigned char>("RtlGetNtVersionNumbers\000"_s));
        auto m32 = windowsLoadSystemLib(winmmdll.make_slice(0));
        if(m32 == 0)
        {
            go_throw("winmm.dll not found"_s);
        }
        _timeBeginPeriod = windowsFindfunc(m32, gocpp::slice<unsigned char>("timeBeginPeriod\000"_s));
        _timeEndPeriod = windowsFindfunc(m32, gocpp::slice<unsigned char>("timeEndPeriod\000"_s));
        if(_timeBeginPeriod == nullptr || _timeEndPeriod == nullptr)
        {
            go_throw("timeBegin/EndPeriod not found"_s);
        }
        auto ws232 = windowsLoadSystemLib(ws2_32dll.make_slice(0));
        if(ws232 == 0)
        {
            go_throw("ws2_32.dll not found"_s);
        }
        _WSAGetOverlappedResult = windowsFindfunc(ws232, gocpp::slice<unsigned char>("WSAGetOverlappedResult\000"_s));
        if(_WSAGetOverlappedResult == nullptr)
        {
            go_throw("WSAGetOverlappedResult not found"_s);
        }
    }

    void monitorSuspendResume()
    {
        auto _DEVICE_NOTIFY_CALLBACK = 2;
        struct _DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS
        {
            uintptr_t callback;
            uintptr_t context;

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << callback;
                os << " " << context;
                os << '}';
                return os;
            }
        };
        auto powrprof = windowsLoadSystemLib(powrprofdll.make_slice(0));
        if(powrprof == 0)
        {
            return;
        }
        auto powerRegisterSuspendResumeNotification = windowsFindfunc(powrprof, gocpp::slice<unsigned char>("PowerRegisterSuspendResumeNotification\000"_s));
        if(powerRegisterSuspendResumeNotification == nullptr)
        {
            return;
        }
        go_any fn = [=](uintptr_t context, uint32_t changeType, uintptr_t setting) mutable -> uintptr_t
        {
            for(auto mp = (m*)(atomic::Loadp(gocpp::unsafe_pointer(& allm))); mp != nullptr; mp = mp->alllink)
            {
                if(mp->resumesema != 0)
                {
                    stdcall1(_SetEvent, mp->resumesema);
                }
            }
            return 0;
        };
        auto params = gocpp::Init<_DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS>([=](auto& x) {
            x.callback = compileCallback(*efaceOf(& fn), true);
        });
        auto handle = uintptr_t(0);
        stdcall3(powerRegisterSuspendResumeNotification, _DEVICE_NOTIFY_CALLBACK, uintptr_t(gocpp::unsafe_pointer(& params)), uintptr_t(gocpp::unsafe_pointer(& handle)));
    }

    //go:nosplit
    uintptr_t getLoadLibrary()
    {
        return uintptr_t(gocpp::unsafe_pointer(_LoadLibraryW));
    }

    //go:nosplit
    uintptr_t getLoadLibraryEx()
    {
        return uintptr_t(gocpp::unsafe_pointer(_LoadLibraryExW));
    }

    //go:nosplit
    uintptr_t getGetProcAddress()
    {
        return uintptr_t(gocpp::unsafe_pointer(_GetProcAddress));
    }

    int32_t getproccount()
    {
        uintptr_t mask = {};
        uintptr_t sysmask = {};
        auto ret = stdcall3(_GetProcessAffinityMask, currentProcess, uintptr_t(gocpp::unsafe_pointer(& mask)), uintptr_t(gocpp::unsafe_pointer(& sysmask)));
        if(ret != 0)
        {
            auto n = 0;
            auto maskbits = int(gocpp::Sizeof<uintptr_t>() * 8);
            for(auto i = 0; i < maskbits; i++)
            {
                if(mask & (1 << (unsigned int)(i)) != 0)
                {
                    n++;
                }
            }
            if(n != 0)
            {
                return int32_t(n);
            }
        }
        // use GetSystemInfo if GetProcessAffinityMask fails
        systeminfo info = {};
        stdcall1(_GetSystemInfo, uintptr_t(gocpp::unsafe_pointer(& info)));
        return int32_t(info.dwnumberofprocessors);
    }

    uintptr_t getPageSize()
    {
        systeminfo info = {};
        stdcall1(_GetSystemInfo, uintptr_t(gocpp::unsafe_pointer(& info)));
        return uintptr_t(info.dwpagesize);
    }

    // in sys_windows_386.s and sys_windows_amd64.s:
    uint32_t getlasterror()
    /* convertBlockStmt, nil block */;

    uint32_t timeBeginPeriodRetValue;
    // osRelaxMinNS indicates that sysmon shouldn't osRelax if the next
    // timer is less than 60 ms from now. Since osRelaxing may reduce
    // timer resolution to 15.6 ms, this keeps timer error under roughly 1
    // part in 4.
    // osRelax is called by the scheduler when transitioning to and from
    // all Ps being idle.
    //
    // Some versions of Windows have high resolution timer. For those
    // versions osRelax is noop.
    // For Windows versions without high resolution timer, osRelax
    // adjusts the system-wide timer resolution. Go needs a
    // high resolution timer while running and there's little extra cost
    // if we're already using the CPU, but if all Ps are idle there's no
    // need to consume extra power to drive the high-res timer.
    uint32_t osRelax(bool relax)
    {
        if(haveHighResTimer)
        {
            return 0;
        }
        if(relax)
        {
            return uint32_t(stdcall1(_timeEndPeriod, 1));
        }
        else
        {
            return uint32_t(stdcall1(_timeBeginPeriod, 1));
        }
    }

    // haveHighResTimer indicates that the CreateWaitableTimerEx
    // CREATE_WAITABLE_TIMER_HIGH_RESOLUTION flag is available.
    bool haveHighResTimer = false;
    // createHighResTimer calls CreateWaitableTimerEx with
    // CREATE_WAITABLE_TIMER_HIGH_RESOLUTION flag to create high
    // resolution timer. createHighResTimer returns new timer
    // handle or 0, if CreateWaitableTimerEx failed.
    uintptr_t createHighResTimer()
    {
        // As per @jstarks, see
        // https://github.com/golang/go/issues/8687#issuecomment-656259353
        auto _CREATE_WAITABLE_TIMER_HIGH_RESOLUTION = 0x00000002;
        auto _SYNCHRONIZE = 0x00100000;
        auto _TIMER_QUERY_STATE = 0x0001;
        auto _TIMER_MODIFY_STATE = 0x0002;
        return stdcall4(_CreateWaitableTimerExW, 0, 0, _CREATE_WAITABLE_TIMER_HIGH_RESOLUTION, _SYNCHRONIZE | _TIMER_QUERY_STATE | _TIMER_MODIFY_STATE);
    }

    void initHighResTimer()
    {
        auto h = createHighResTimer();
        if(h != 0)
        {
            haveHighResTimer = true;
            stdcall1(_CloseHandle, h);
        }
    }

    //go:linkname canUseLongPaths os.canUseLongPaths
    bool canUseLongPaths;
    // We want this to be large enough to hold the contents of sysDirectory, *plus*
    // a slash and another component that itself is greater than MAX_PATH.
    gocpp::array<unsigned char, (_MAX_PATH + 1) * 2 + 1> longFileName;
    // initLongPathSupport initializes the canUseLongPaths variable, which is
    // linked into os.canUseLongPaths for determining whether or not long paths
    // need to be fixed up. In the best case, this function is running on newer
    // Windows 10 builds, which have a bit field member of the PEB called
    // "IsLongPathAwareProcess." When this is set, we don't need to go through the
    // error-prone fixup function in order to access long paths. So this init
    // function first checks the Windows build number, sets the flag, and then
    // tests to see if it's actually working. If everything checks out, then
    // canUseLongPaths is set to true, and later when called, os.fixLongPath
    // returns early without doing work.
    void initLongPathSupport()
    {
        auto IsLongPathAwareProcess = 0x80;
        auto PebBitFieldOffset = 3;
        auto OPEN_EXISTING = 3;
        auto ERROR_PATH_NOT_FOUND = 3;
        // Check that we're â‰¥ 10.0.15063.
        uint32_t maj = {};
        uint32_t min = {};
        uint32_t build = {};
        stdcall3(_RtlGetNtVersionNumbers, uintptr_t(gocpp::unsafe_pointer(& maj)), uintptr_t(gocpp::unsafe_pointer(& min)), uintptr_t(gocpp::unsafe_pointer(& build)));
        if(maj < 10 || (maj == 10 && min == 0 && build & 0xffff < 15063))
        {
            return;
        }
        auto bitField = (unsigned char*)(gocpp::unsafe_pointer(stdcall0(_RtlGetCurrentPeb) + PebBitFieldOffset));
        auto originalBitField = *bitField;
        *bitField |= IsLongPathAwareProcess;
        auto targ = longFileName.make_slice(len(longFileName) - 33, len(longFileName) - 1);
        if(readRandom(targ) != len(targ))
        {
            readTimeRandom(targ);
        }
        auto start = copy(longFileName.make_slice(0), sysDirectory.make_slice(0, sysDirectoryLen));
        auto dig = "0123456789abcdef"_s;
        for(auto i = 0; i < 32; i++)
        {
            longFileName[start + i * 2] = dig[longFileName[len(longFileName) - 33 + i] >> 4];
            longFileName[start + i * 2 + 1] = dig[longFileName[len(longFileName) - 33 + i] & 0xf];
        }
        start += 64;
        for(auto i = start; i < len(longFileName) - 1; i++)
        {
            longFileName[i] = 'A';
        }
        stdcall7(_CreateFileA, uintptr_t(gocpp::unsafe_pointer(& longFileName[0])), 0, 0, 0, OPEN_EXISTING, 0, 0);
        if(getlasterror() == ERROR_PATH_NOT_FOUND)
        {
            *bitField = originalBitField;
            println("runtime: warning: IsLongPathAwareProcess failed to enable long paths; proceeding in fixup mode"_s);
            return;
        }
        canUseLongPaths = true;
    }

    void osinit()
    {
        asmstdcallAddr = gocpp::unsafe_pointer(abi::FuncPCABI0(asmstdcall));
        loadOptionalSyscalls();
        preventErrorDialogs();
        initExceptionHandler();
        initHighResTimer();
        timeBeginPeriodRetValue = osRelax(false);
        initSysDirectory();
        initLongPathSupport();
        ncpu = getproccount();
        physPageSize = getPageSize();
        stdcall2(_SetProcessPriorityBoost, currentProcess, 1);
    }

    //go:nosplit
    int readRandom(gocpp::slice<unsigned char> r)
    {
        auto n = 0;
        if(stdcall2(_ProcessPrng, uintptr_t(gocpp::unsafe_pointer(& r[0])), uintptr_t(len(r))) & 0xff != 0)
        {
            n = len(r);
        }
        return n;
    }

    void goenvs()
    {
        auto strings = gocpp::unsafe_pointer(stdcall0(_GetEnvironmentStringsW));
        auto p = (gocpp::array_ptr<gocpp::array<uint16_t, 1 << 24>>)(strings).make_slice(0);
        auto n = 0;
        for(auto [from, i] = std::tuple{0, 0}; true; i++)
        {
            if(p[i] == 0)
            {
                if(i == from)
                {
                    break;
                }
                from = i + 1;
                n++;
            }
        }
        envs = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::string>>(), n);
        for(auto [i, gocpp_ignored] : envs)
        {
            envs[i] = gostringw(& p[0]);
            for(; p[0] != 0; )
            {
                p = p.make_slice(1);
            }
            p = p.make_slice(1);
        }
        stdcall1(_FreeEnvironmentStringsW, uintptr_t(strings));
        // We call these all the way here, late in init, so that malloc works
        // for the callback functions these generate.
        go_any fn = ctrlHandler;
        auto ctrlHandlerPC = compileCallback(*efaceOf(& fn), true);
        stdcall2(_SetConsoleCtrlHandler, ctrlHandlerPC, 1);
        monitorSuspendResume();
    }

    // exiting is set to non-zero when the process is exiting.
    uint32_t exiting;
    //go:nosplit
    void exit(int32_t code)
    {
        lock(& suspendLock);
        atomic::Store(& exiting, 1);
        stdcall1(_ExitProcess, uintptr_t(code));
    }

    // write1 must be nosplit because it's used as a last resort in
    // functions like badmorestackg0. In such cases, we'll always take the
    // ASCII path.
    //
    //go:nosplit
    int32_t write1(uintptr_t fd, gocpp::unsafe_pointer buf, int32_t n)
    {
        auto _STD_OUTPUT_HANDLE = ~ uintptr_t(10);
        auto _STD_ERROR_HANDLE = ~ uintptr_t(11);
        uintptr_t handle = {};
        //Go switch emulation
        {
            auto condition = fd;
            int conditionId = -1;
            if(condition == 1) { conditionId = 0; }
            else if(condition == 2) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    handle = stdcall1(_GetStdHandle, _STD_OUTPUT_HANDLE);
                    break;
                case 1:
                    handle = stdcall1(_GetStdHandle, _STD_ERROR_HANDLE);
                    break;
                default:
                    handle = fd;
                    break;
            }
        }
        auto isASCII = true;
        auto b = (gocpp::array_ptr<gocpp::array<unsigned char, 1 << 30>>)(buf).make_slice(0, n);
        for(auto [gocpp_ignored, x] : b)
        {
            if(x >= 0x80)
            {
                isASCII = false;
                break;
            }
        }
        if(! isASCII)
        {
            uint32_t m = {};
            auto isConsole = stdcall2(_GetConsoleMode, handle, uintptr_t(gocpp::unsafe_pointer(& m))) != 0;
            if(isConsole)
            {
                return int32_t(writeConsole(handle, buf, n));
            }
        }
        uint32_t written = {};
        stdcall5(_WriteFile, handle, uintptr_t(buf), uintptr_t(n), uintptr_t(gocpp::unsafe_pointer(& written)), 0);
        return int32_t(written);
    }

    gocpp::array<uint16_t, 1000> utf16ConsoleBack;
    mutex utf16ConsoleBackLock;
    // writeConsole writes bufLen bytes from buf to the console File.
    // It returns the number of bytes written.
    int writeConsole(uintptr_t handle, gocpp::unsafe_pointer buf, int32_t bufLen)
    {
        auto surr2 = (surrogateMin + surrogateMax + 1) / 2;
        lock(& utf16ConsoleBackLock);
        auto b = (gocpp::array_ptr<gocpp::array<unsigned char, 1 << 30>>)(buf).make_slice(0, bufLen);
        auto s = *(gocpp::string*)(gocpp::unsafe_pointer(& b));
        auto utf16tmp = utf16ConsoleBack.make_slice(0);
        auto total = len(s);
        auto w = 0;
        for(auto [gocpp_ignored, r] : s)
        {
            if(w >= len(utf16tmp) - 2)
            {
                writeConsoleUTF16(handle, utf16tmp.make_slice(0, w));
                w = 0;
            }
            if(r < 0x10000)
            {
                utf16tmp[w] = uint16_t(r);
                w++;
            }
            else
            {
                r -= 0x10000;
                utf16tmp[w] = surrogateMin + uint16_t(r >> 10) & 0x3ff;
                utf16tmp[w + 1] = surr2 + uint16_t(r) & 0x3ff;
                w += 2;
            }
        }
        writeConsoleUTF16(handle, utf16tmp.make_slice(0, w));
        unlock(& utf16ConsoleBackLock);
        return total;
    }

    // writeConsoleUTF16 is the dedicated windows calls that correctly prints
    // to the console regardless of the current code page. Input is utf-16 code points.
    // The handle must be a console handle.
    void writeConsoleUTF16(uintptr_t handle, gocpp::slice<uint16_t> b)
    {
        auto l = uint32_t(len(b));
        if(l == 0)
        {
            return;
        }
        uint32_t written = {};
        stdcall5(_WriteConsoleW, handle, uintptr_t(gocpp::unsafe_pointer(& b[0])), uintptr_t(l), uintptr_t(gocpp::unsafe_pointer(& written)), 0);
        return;
    }

    //go:nosplit
    int32_t semasleep(int64_t ns)
    {
        auto _WAIT_ABANDONED = 0x00000080;
        auto _WAIT_OBJECT_0 = 0x00000000;
        auto _WAIT_TIMEOUT = 0x00000102;
        auto _WAIT_FAILED = 0xFFFFFFFF;
        uintptr_t result = {};
        if(ns < 0)
        {
            result = stdcall2(_WaitForSingleObject, getg()->m->waitsema, uintptr_t(_INFINITE));
        }
        else
        {
            auto start = nanotime();
            auto elapsed = int64_t(0);
            for(; ; )
            {
                auto ms = int64_t(timediv(ns - elapsed, 1000000, nullptr));
                if(ms == 0)
                {
                    ms = 1;
                }
                result = stdcall4(_WaitForMultipleObjects, 2, uintptr_t(gocpp::unsafe_pointer(new gocpp::array<uintptr_t, 2> {getg()->m->waitsema, getg()->m->resumesema})), 0, uintptr_t(ms));
                if(result != _WAIT_OBJECT_0 + 1)
                {
                    break;
                }
                elapsed = nanotime() - start;
                if(elapsed >= ns)
                {
                    return - 1;
                }
            }
        }
        //Go switch emulation
        {
            auto condition = result;
            int conditionId = -1;
            if(condition == _WAIT_OBJECT_0) { conditionId = 0; }
            else if(condition == _WAIT_TIMEOUT) { conditionId = 1; }
            else if(condition == _WAIT_ABANDONED) { conditionId = 2; }
            else if(condition == _WAIT_FAILED) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return 0;
                    break;
                case 1:
                    return - 1;
                    break;
                case 2:
                    systemstack([=]() mutable -> void
                    {
                        go_throw("runtime.semasleep wait_abandoned"_s);
                    });
                    break;
                case 3:
                    systemstack([=]() mutable -> void
                    {
                        print("runtime: waitforsingleobject wait_failed; errno="_s, getlasterror(), "\n"_s);
                        go_throw("runtime.semasleep wait_failed"_s);
                    });
                    break;
                default:
                    systemstack([=]() mutable -> void
                    {
                        print("runtime: waitforsingleobject unexpected; result="_s, result, "\n"_s);
                        go_throw("runtime.semasleep unexpected"_s);
                    });
                    break;
            }
        }
        return - 1;
    }

    //go:nosplit
    void semawakeup(struct m* mp)
    {
        if(stdcall1(_SetEvent, mp->waitsema) == 0)
        {
            systemstack([=]() mutable -> void
            {
                print("runtime: setevent failed; errno="_s, getlasterror(), "\n"_s);
                go_throw("runtime.semawakeup"_s);
            });
        }
    }

    //go:nosplit
    void semacreate(struct m* mp)
    {
        if(mp->waitsema != 0)
        {
            return;
        }
        mp->waitsema = stdcall4(_CreateEventA, 0, 0, 0, 0);
        if(mp->waitsema == 0)
        {
            systemstack([=]() mutable -> void
            {
                print("runtime: createevent failed; errno="_s, getlasterror(), "\n"_s);
                go_throw("runtime.semacreate"_s);
            });
        }
        mp->resumesema = stdcall4(_CreateEventA, 0, 0, 0, 0);
        if(mp->resumesema == 0)
        {
            systemstack([=]() mutable -> void
            {
                print("runtime: createevent failed; errno="_s, getlasterror(), "\n"_s);
                go_throw("runtime.semacreate"_s);
            });
            stdcall1(_CloseHandle, mp->waitsema);
            mp->waitsema = 0;
        }
    }

    // May run with m.p==nil, so write barriers are not allowed. This
    // function is called by newosproc0, so it is also required to
    // operate without stack guards.
    //
    //go:nowritebarrierrec
    //go:nosplit
    void newosproc(struct m* mp)
    {
        auto thandle = stdcall6(_CreateThread, 0, 0, abi::FuncPCABI0(tstart_stdcall), uintptr_t(gocpp::unsafe_pointer(mp)), 0, 0);
        if(thandle == 0)
        {
            if(atomic::Load(& exiting) != 0)
            {
                lock(& deadlock);
                lock(& deadlock);
            }
            print("runtime: failed to create new OS thread (have "_s, mcount(), " already; errno="_s, getlasterror(), ")\n"_s);
            go_throw("runtime.newosproc"_s);
        }
        stdcall1(_CloseHandle, thandle);
    }

    // Used by the C library build mode. On Linux this function would allocate a
    // stack, but that's not necessary for Windows. No stack guards are present
    // and the GC has not been initialized, so write barriers will fail.
    //
    //go:nowritebarrierrec
    //go:nosplit
    void newosproc0(struct m* mp, gocpp::unsafe_pointer stk)
    {
        go_throw("bad newosproc0"_s);
    }

    void exitThread(atomic::Uint32* wait)
    {
        go_throw("exitThread"_s);
    }

    // Called to initialize a new m (including the bootstrap m).
    // Called on the parent thread (main thread in case of bootstrap), can allocate memory.
    void mpreinit(struct m* mp)
    {
    }

    //go:nosplit
    void sigsave(struct sigset* p)
    {
    }

    //go:nosplit
    void msigrestore(struct sigset sigmask)
    {
    }

    //go:nosplit
    //go:nowritebarrierrec
    void clearSignalHandlers()
    {
    }

    //go:nosplit
    void sigblock(bool exiting)
    {
    }

    // Called to initialize a new m (including the bootstrap m).
    // Called on the new thread, cannot allocate memory.
    void minit()
    {
        uintptr_t thandle = {};
        if(stdcall7(_DuplicateHandle, currentProcess, currentThread, currentProcess, uintptr_t(gocpp::unsafe_pointer(& thandle)), 0, 0, _DUPLICATE_SAME_ACCESS) == 0)
        {
            print("runtime.minit: duplicatehandle failed; errno="_s, getlasterror(), "\n"_s);
            go_throw("runtime.minit: duplicatehandle failed"_s);
        }
        auto mp = getg()->m;
        lock(& mp->threadLock);
        mp->thread = thandle;
        mp->procid = uint64_t(stdcall0(_GetCurrentThreadId));
        if(mp->highResTimer == 0 && haveHighResTimer)
        {
            mp->highResTimer = createHighResTimer();
            if(mp->highResTimer == 0)
            {
                print("runtime: CreateWaitableTimerEx failed; errno="_s, getlasterror(), "\n"_s);
                go_throw("CreateWaitableTimerEx when creating timer failed"_s);
            }
        }
        unlock(& mp->threadLock);
        // Query the true stack base from the OS. Currently we're
        // running on a small assumed stack.
        memoryBasicInformation mbi = {};
        auto res = stdcall3(_VirtualQuery, uintptr_t(gocpp::unsafe_pointer(& mbi)), uintptr_t(gocpp::unsafe_pointer(& mbi)), gocpp::Sizeof<memoryBasicInformation>());
        if(res == 0)
        {
            print("runtime: VirtualQuery failed; errno="_s, getlasterror(), "\n"_s);
            go_throw("VirtualQuery for stack base failed"_s);
        }
        auto base = mbi.allocationBase + (16 << 10);
        auto g0 = getg();
        if(base > g0->stack.hi || g0->stack.hi - base > (64 << 20))
        {
            print("runtime: g0 stack ["_s, hex(base), ","_s, hex(g0->stack.hi), ")\n"_s);
            go_throw("bad g0 stack"_s);
        }
        g0->stack.lo = base;
        g0->stackguard0 = g0->stack.lo + stackGuard;
        g0->stackguard1 = g0->stackguard0;
        stackcheck();
    }

    // Called from dropm to undo the effect of an minit.
    //
    //go:nosplit
    void unminit()
    {
        auto mp = getg()->m;
        lock(& mp->threadLock);
        if(mp->thread != 0)
        {
            stdcall1(_CloseHandle, mp->thread);
            mp->thread = 0;
        }
        unlock(& mp->threadLock);
        mp->procid = 0;
    }

    // Called from exitm, but not from drop, to undo the effect of thread-owned
    // resources in minit, semacreate, or elsewhere. Do not take locks after calling this.
    //
    //go:nosplit
    void mdestroy(struct m* mp)
    {
        if(mp->highResTimer != 0)
        {
            stdcall1(_CloseHandle, mp->highResTimer);
            mp->highResTimer = 0;
        }
        if(mp->waitsema != 0)
        {
            stdcall1(_CloseHandle, mp->waitsema);
            mp->waitsema = 0;
        }
        if(mp->resumesema != 0)
        {
            stdcall1(_CloseHandle, mp->resumesema);
            mp->resumesema = 0;
        }
    }

    // asmstdcall_trampoline calls asmstdcall converting from Go to C calling convention.
    void asmstdcall_trampoline(gocpp::unsafe_pointer args)
    /* convertBlockStmt, nil block */;

    // stdcall_no_g calls asmstdcall on os stack without using g.
    //
    //go:nosplit
    uintptr_t stdcall_no_g(golang::runtime::stdFunction fn, int n, uintptr_t args)
    {
        auto libcall_tmp = gocpp::Init<libcall>([=](auto& x) {
            x.fn = uintptr_t(gocpp::unsafe_pointer(fn));
            x.n = uintptr_t(n);
            x.args = args;
        });
        auto& libcall = libcall_tmp;
        asmstdcall_trampoline(noescape(gocpp::unsafe_pointer(& libcall)));
        return libcall.r1;
    }

    // Calling stdcall on os stack.
    // May run during STW, so write barriers are not allowed.
    //
    //go:nowritebarrier
    //go:nosplit
    uintptr_t stdcall(golang::runtime::stdFunction fn)
    {
        auto gp = getg();
        auto mp = gp->m;
        mp->libcall.fn = uintptr_t(gocpp::unsafe_pointer(fn));
        auto resetLibcall = false;
        if(mp->profilehz != 0 && mp->libcallsp == 0)
        {
            rec::set(gocpp::recv(mp->libcallg), gp);
            mp->libcallpc = getcallerpc();
            mp->libcallsp = getcallersp();
            resetLibcall = true;
        }
        asmcgocall(asmstdcallAddr, gocpp::unsafe_pointer(& mp->libcall));
        if(resetLibcall)
        {
            mp->libcallsp = 0;
        }
        return mp->libcall.r1;
    }

    //go:nosplit
    uintptr_t stdcall0(golang::runtime::stdFunction fn)
    {
        auto mp = getg()->m;
        mp->libcall.n = 0;
        mp->libcall.args = 0;
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall1(golang::runtime::stdFunction fn, uintptr_t a0)
    {
        auto mp = getg()->m;
        mp->libcall.n = 1;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall2(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1)
    {
        auto mp = getg()->m;
        mp->libcall.n = 2;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall3(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1, uintptr_t a2)
    {
        auto mp = getg()->m;
        mp->libcall.n = 3;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall4(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1, uintptr_t a2, uintptr_t a3)
    {
        auto mp = getg()->m;
        mp->libcall.n = 4;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall5(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4)
    {
        auto mp = getg()->m;
        mp->libcall.n = 5;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall6(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5)
    {
        auto mp = getg()->m;
        mp->libcall.n = 6;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall7(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
    {
        auto mp = getg()->m;
        mp->libcall.n = 7;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    //go:cgo_unsafe_args
    uintptr_t stdcall8(golang::runtime::stdFunction fn, uintptr_t a0, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7)
    {
        auto mp = getg()->m;
        mp->libcall.n = 8;
        mp->libcall.args = uintptr_t(noescape(gocpp::unsafe_pointer(& a0)));
        return stdcall(fn);
    }

    //go:nosplit
    void osyield_no_g()
    {
        stdcall_no_g(_SwitchToThread, 0, 0);
    }

    //go:nosplit
    void osyield()
    {
        systemstack([=]() mutable -> void
        {
            stdcall0(_SwitchToThread);
        });
    }

    //go:nosplit
    void usleep_no_g(uint32_t us)
    {
        auto timeout = uintptr_t(us) / 1000;
        auto args = gocpp::array<uintptr_t, 2> {_INVALID_HANDLE_VALUE, timeout};
        stdcall_no_g(_WaitForSingleObject, len(args), uintptr_t(noescape(gocpp::unsafe_pointer(& args[0]))));
    }

    //go:nosplit
    void usleep(uint32_t us)
    {
        systemstack([=]() mutable -> void
        {
            uintptr_t h = {};
            uintptr_t timeout = {};
            if(haveHighResTimer && getg()->m->highResTimer != 0)
            {
                h = getg()->m->highResTimer;
                auto dt = - 10 * int64_t(us);
                stdcall6(_SetWaitableTimer, h, uintptr_t(gocpp::unsafe_pointer(& dt)), 0, 0, 0, 0);
                timeout = _INFINITE;
            }
            else
            {
                h = _INVALID_HANDLE_VALUE;
                timeout = uintptr_t(us) / 1000;
            }
            stdcall2(_WaitForSingleObject, h, timeout);
        });
    }

    uintptr_t ctrlHandler(uint32_t _type)
    {
        uint32_t s = {};
        //Go switch emulation
        {
            auto condition = _type;
            int conditionId = -1;
            if(condition == _CTRL_C_EVENT) { conditionId = 0; }
            else if(condition == _CTRL_BREAK_EVENT) { conditionId = 1; }
            else if(condition == _CTRL_CLOSE_EVENT) { conditionId = 2; }
            else if(condition == _CTRL_LOGOFF_EVENT) { conditionId = 3; }
            else if(condition == _CTRL_SHUTDOWN_EVENT) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    s = _SIGINT;
                    break;
                case 2:
                case 3:
                case 4:
                    s = _SIGTERM;
                    break;
                default:
                    return 0;
                    break;
            }
        }
        if(sigsend(s))
        {
            if(s == _SIGTERM)
            {
                block();
            }
            return 1;
        }
        return 0;
    }

    // called from zcallback_windows_*.s to sys_windows_*.s
    void callbackasm1()
    /* convertBlockStmt, nil block */;

    uintptr_t profiletimer;
    void profilem(struct m* mp, uintptr_t thread)
    {
        // Align Context to 16 bytes.
        context* c = {};
        gocpp::array<unsigned char, gocpp::Sizeof<context>() + 15> cbuf = {};
        c = (context*)(gocpp::unsafe_pointer((uintptr_t(gocpp::unsafe_pointer(& cbuf[15]))) &^ 15));
        c->contextflags = _CONTEXT_CONTROL;
        stdcall2(_GetThreadContext, thread, uintptr_t(gocpp::unsafe_pointer(c)));
        auto gp = gFromSP(mp, rec::sp(gocpp::recv(c)));
        sigprof(rec::ip(gocpp::recv(c)), rec::sp(gocpp::recv(c)), rec::lr(gocpp::recv(c)), gp, mp);
    }

    struct g* gFromSP(struct m* mp, uintptr_t sp)
    {
        if(auto gp = mp->g0; gp != nullptr && gp->stack.lo < sp && sp < gp->stack.hi)
        {
            return gp;
        }
        if(auto gp = mp->gsignal; gp != nullptr && gp->stack.lo < sp && sp < gp->stack.hi)
        {
            return gp;
        }
        if(auto gp = mp->curg; gp != nullptr && gp->stack.lo < sp && sp < gp->stack.hi)
        {
            return gp;
        }
        return nullptr;
    }

    void profileLoop()
    {
        stdcall2(_SetThreadPriority, currentThread, _THREAD_PRIORITY_HIGHEST);
        for(; ; )
        {
            stdcall2(_WaitForSingleObject, profiletimer, _INFINITE);
            auto first = (m*)(atomic::Loadp(gocpp::unsafe_pointer(& allm)));
            for(auto mp = first; mp != nullptr; mp = mp->alllink)
            {
                if(mp == getg()->m)
                {
                    continue;
                }
                lock(& mp->threadLock);
                if(mp->thread == 0 || mp->profilehz == 0 || mp->blocked)
                {
                    unlock(& mp->threadLock);
                    continue;
                }
                // Acquire our own handle to the thread.
                uintptr_t thread = {};
                if(stdcall7(_DuplicateHandle, currentProcess, mp->thread, currentProcess, uintptr_t(gocpp::unsafe_pointer(& thread)), 0, 0, _DUPLICATE_SAME_ACCESS) == 0)
                {
                    print("runtime: duplicatehandle failed; errno="_s, getlasterror(), "\n"_s);
                    go_throw("duplicatehandle failed"_s);
                }
                unlock(& mp->threadLock);
                if(int32_t(stdcall1(_SuspendThread, thread)) == - 1)
                {
                    stdcall1(_CloseHandle, thread);
                    continue;
                }
                if(mp->profilehz != 0 && ! mp->blocked)
                {
                    profilem(mp, thread);
                }
                stdcall1(_ResumeThread, thread);
                stdcall1(_CloseHandle, thread);
            }
        }
    }

    void setProcessCPUProfiler(int32_t hz)
    {
        if(profiletimer == 0)
        {
            uintptr_t timer = {};
            if(haveHighResTimer)
            {
                timer = createHighResTimer();
            }
            else
            {
                timer = stdcall3(_CreateWaitableTimerA, 0, 0, 0);
            }
            atomic::Storeuintptr(& profiletimer, timer);
            newm(profileLoop, nullptr, - 1);
        }
    }

    void setThreadCPUProfiler(int32_t hz)
    {
        auto ms = int32_t(0);
        auto due = ~ int64_t(~ uint64_t(1 << 63));
        if(hz > 0)
        {
            ms = 1000 / hz;
            if(ms == 0)
            {
                ms = 1;
            }
            due = int64_t(ms) * - 10000;
        }
        stdcall6(_SetWaitableTimer, profiletimer, uintptr_t(gocpp::unsafe_pointer(& due)), uintptr_t(ms), 0, 0, 0);
        atomic::Store((uint32_t*)(gocpp::unsafe_pointer(& getg()->m->profilehz)), uint32_t(hz));
    }

    // suspendLock protects simultaneous SuspendThread operations from
    // suspending each other.
    mutex suspendLock;
    void preemptM(struct m* mp)
    {
        if(mp == getg()->m)
        {
            go_throw("self-preempt"_s);
        }
        if(! atomic::Cas(& mp->preemptExtLock, 0, 1))
        {
            rec::Add(gocpp::recv(mp->preemptGen), 1);
            return;
        }
        lock(& mp->threadLock);
        if(mp->thread == 0)
        {
            unlock(& mp->threadLock);
            atomic::Store(& mp->preemptExtLock, 0);
            rec::Add(gocpp::recv(mp->preemptGen), 1);
            return;
        }
        uintptr_t thread = {};
        if(stdcall7(_DuplicateHandle, currentProcess, mp->thread, currentProcess, uintptr_t(gocpp::unsafe_pointer(& thread)), 0, 0, _DUPLICATE_SAME_ACCESS) == 0)
        {
            print("runtime.preemptM: duplicatehandle failed; errno="_s, getlasterror(), "\n"_s);
            go_throw("runtime.preemptM: duplicatehandle failed"_s);
        }
        unlock(& mp->threadLock);
        // Prepare thread context buffer. This must be aligned to 16 bytes.
        context* c = {};
        gocpp::array<unsigned char, gocpp::Sizeof<context>() + 15> cbuf = {};
        c = (context*)(gocpp::unsafe_pointer((uintptr_t(gocpp::unsafe_pointer(& cbuf[15]))) &^ 15));
        c->contextflags = _CONTEXT_CONTROL;
        lock(& suspendLock);
        if(int32_t(stdcall1(_SuspendThread, thread)) == - 1)
        {
            unlock(& suspendLock);
            stdcall1(_CloseHandle, thread);
            atomic::Store(& mp->preemptExtLock, 0);
            rec::Add(gocpp::recv(mp->preemptGen), 1);
            return;
        }
        stdcall2(_GetThreadContext, thread, uintptr_t(gocpp::unsafe_pointer(c)));
        unlock(& suspendLock);
        auto gp = gFromSP(mp, rec::sp(gocpp::recv(c)));
        if(gp != nullptr && wantAsyncPreempt(gp))
        {
            if(auto [ok, newpc] = isAsyncSafePoint(gp, rec::ip(gocpp::recv(c)), rec::sp(gocpp::recv(c)), rec::lr(gocpp::recv(c))); ok)
            {
                auto targetPC = abi::FuncPCABI0(asyncPreempt);
                //Go switch emulation
                {
                    auto condition = GOARCH;
                    int conditionId = -1;
                    if(condition == "386"_s) { conditionId = 0; }
                    else if(condition == "amd64"_s) { conditionId = 1; }
                    else if(condition == "arm"_s) { conditionId = 2; }
                    else if(condition == "arm64"_s) { conditionId = 3; }
                    switch(conditionId)
                    {
                        default:
                            go_throw("unsupported architecture"_s);
                            break;
                        case 0:
                        case 1:
                            auto sp = rec::sp(gocpp::recv(c));
                            sp -= goarch::PtrSize;
                            *(uintptr_t*)(gocpp::unsafe_pointer(sp)) = newpc;
                            rec::set_sp(gocpp::recv(c), sp);
                            rec::set_ip(gocpp::recv(c), targetPC);
                            break;
                        case 2:
                            auto sp = rec::sp(gocpp::recv(c));
                            sp -= goarch::PtrSize;
                            rec::set_sp(gocpp::recv(c), sp);
                            *(uint32_t*)(gocpp::unsafe_pointer(sp)) = uint32_t(rec::lr(gocpp::recv(c)));
                            rec::set_lr(gocpp::recv(c), newpc - 1);
                            rec::set_ip(gocpp::recv(c), targetPC);
                            break;
                        case 3:
                            auto sp = rec::sp(gocpp::recv(c)) - 16;
                            rec::set_sp(gocpp::recv(c), sp);
                            *(uint64_t*)(gocpp::unsafe_pointer(sp)) = uint64_t(rec::lr(gocpp::recv(c)));
                            rec::set_lr(gocpp::recv(c), newpc);
                            rec::set_ip(gocpp::recv(c), targetPC);
                            break;
                    }
                }
                stdcall2(_SetThreadContext, thread, uintptr_t(gocpp::unsafe_pointer(c)));
            }
        }
        atomic::Store(& mp->preemptExtLock, 0);
        rec::Add(gocpp::recv(mp->preemptGen), 1);
        stdcall1(_ResumeThread, thread);
        stdcall1(_CloseHandle, thread);
    }

    // osPreemptExtEnter is called before entering external code that may
    // call ExitProcess.
    //
    // This must be nosplit because it may be called from a syscall with
    // untyped stack slots, so the stack must not be grown or scanned.
    //
    //go:nosplit
    void osPreemptExtEnter(struct m* mp)
    {
        for(; ! atomic::Cas(& mp->preemptExtLock, 0, 1); )
        {
            osyield();
        }
    }

    // osPreemptExtExit is called after returning from external code that
    // may call ExitProcess.
    //
    // See osPreemptExtEnter for why this is nosplit.
    //
    //go:nosplit
    void osPreemptExtExit(struct m* mp)
    {
        atomic::Store(& mp->preemptExtLock, 0);
    }

}

