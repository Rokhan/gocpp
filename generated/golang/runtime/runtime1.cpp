// generated by GoCpp from file '$(ImportDir)/runtime/runtime1.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime1.h"
#include "gocpp/support.h"

#include "golang/internal/bytealg/indexbyte_native.h"
// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/auxv_none.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/trace2.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    int tracebackCrash = 1 << 0;
    int tracebackAll = 1 << 1;
    int tracebackShift = 2;
    uint32_t traceback_cache = 2 << tracebackShift;
    uint32_t traceback_env;
    std::tuple<int32_t, bool, bool> gotraceback()
    {
        int32_t level;
        bool all;
        bool crash;
        auto gp = getg();
        auto t = Load(gocpp::recv(atomic), & traceback_cache);
        crash = t & tracebackCrash != 0;
        all = gp->m->throwing >= throwTypeUser || t & tracebackAll != 0;
        if(gp->m->traceback != 0)
        {
            int32_t level;
            bool all;
            bool crash;
            level = int32(gp->m->traceback);
        }
        else
        if(gp->m->throwing >= throwTypeRuntime)
        {
            int32_t level;
            bool all;
            bool crash;
            level = 2;
        }
        else
        {
            int32_t level;
            bool all;
            bool crash;
            level = int32(t >> tracebackShift);
        }
        return {level, all, crash};
    }

    int32_t argc;
    unsigned char** argv;
    unsigned char* argv_index(unsigned char** argv, int32_t i)
    {
        return *(**byte)(add(Pointer(gocpp::recv(unsafe), argv), uintptr(i) * goarch.PtrSize));
    }

    void args(int32_t c, unsigned char** v)
    {
        argc = c;
        argv = v;
        sysargs(c, v);
    }

    void goargs()
    {
        if(GOOS == "windows")
        {
            return;
        }
        argslice = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), argc);
        for(auto i = int32(0); i < argc; i++)
        {
            argslice[i] = gostringnocopy(argv_index(argv, i));
        }
    }

    void goenvs_unix()
    {
        auto n = int32(0);
        for(; argv_index(argv, argc + 1 + n) != nullptr; )
        {
            n++;
        }
        envs = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        for(auto i = int32(0); i < n; i++)
        {
            envs[i] = gostring(argv_index(argv, argc + 1 + i));
        }
    }

    gocpp::slice<std::string> environ()
    {
        return envs;
    }

    uint64_t test_z64;
    uint64_t test_x64;
    void testAtomic64()
    {
        test_z64 = 42;
        test_x64 = 0;
        if(Cas64(gocpp::recv(atomic), & test_z64, test_x64, 1))
        {
            go_throw("cas64 failed");
        }
        if(test_x64 != 0)
        {
            go_throw("cas64 failed");
        }
        test_x64 = 42;
        if(! Cas64(gocpp::recv(atomic), & test_z64, test_x64, 1))
        {
            go_throw("cas64 failed");
        }
        if(test_x64 != 42 || test_z64 != 1)
        {
            go_throw("cas64 failed");
        }
        if(Load64(gocpp::recv(atomic), & test_z64) != 1)
        {
            go_throw("load64 failed");
        }
        Store64(gocpp::recv(atomic), & test_z64, (1 << 40) + 1);
        if(Load64(gocpp::recv(atomic), & test_z64) != (1 << 40) + 1)
        {
            go_throw("store64 failed");
        }
        if(Xadd64(gocpp::recv(atomic), & test_z64, (1 << 40) + 1) != (2 << 40) + 2)
        {
            go_throw("xadd64 failed");
        }
        if(Load64(gocpp::recv(atomic), & test_z64) != (2 << 40) + 2)
        {
            go_throw("xadd64 failed");
        }
        if(Xchg64(gocpp::recv(atomic), & test_z64, (3 << 40) + 3) != (2 << 40) + 2)
        {
            go_throw("xchg64 failed");
        }
        if(Load64(gocpp::recv(atomic), & test_z64) != (3 << 40) + 3)
        {
            go_throw("xchg64 failed");
        }
    }

    void check()
    {
        int8_t a = {};
        uint8_t b = {};
        int16_t c = {};
        uint16_t d = {};
        int32_t e = {};
        uint32_t f = {};
        int64_t g = {};
        uint64_t h = {};
        float i = {};
        float i1 = {};
        double j = {};
        double j1 = {};
        unsafe::Pointer k = {};
        uint16_t* l = {};
        gocpp::array<unsigned char, 4> m = {};
        
        std::ostream& x1t::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << x;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const x1t& value)
        {
            return value.PrintTo(os);
        }

        
        std::ostream& y1t::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << x1;
            os << " " << y;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const y1t& value)
        {
            return value.PrintTo(os);
        }

        x1t x1 = {};
        y1t y1 = {};
        if(Sizeof(gocpp::recv(unsafe), a) != 1)
        {
            go_throw("bad a");
        }
        if(Sizeof(gocpp::recv(unsafe), b) != 1)
        {
            go_throw("bad b");
        }
        if(Sizeof(gocpp::recv(unsafe), c) != 2)
        {
            go_throw("bad c");
        }
        if(Sizeof(gocpp::recv(unsafe), d) != 2)
        {
            go_throw("bad d");
        }
        if(Sizeof(gocpp::recv(unsafe), e) != 4)
        {
            go_throw("bad e");
        }
        if(Sizeof(gocpp::recv(unsafe), f) != 4)
        {
            go_throw("bad f");
        }
        if(Sizeof(gocpp::recv(unsafe), g) != 8)
        {
            go_throw("bad g");
        }
        if(Sizeof(gocpp::recv(unsafe), h) != 8)
        {
            go_throw("bad h");
        }
        if(Sizeof(gocpp::recv(unsafe), i) != 4)
        {
            go_throw("bad i");
        }
        if(Sizeof(gocpp::recv(unsafe), j) != 8)
        {
            go_throw("bad j");
        }
        if(Sizeof(gocpp::recv(unsafe), k) != goarch.PtrSize)
        {
            go_throw("bad k");
        }
        if(Sizeof(gocpp::recv(unsafe), l) != goarch.PtrSize)
        {
            go_throw("bad l");
        }
        if(Sizeof(gocpp::recv(unsafe), x1) != 1)
        {
            go_throw("bad unsafe.Sizeof x1");
        }
        if(Offsetof(gocpp::recv(unsafe), y1.y) != 1)
        {
            go_throw("bad offsetof y1.y");
        }
        if(Sizeof(gocpp::recv(unsafe), y1) != 2)
        {
            go_throw("bad unsafe.Sizeof y1");
        }
        if(timediv(12345 * 1000000000 + 54321, 1000000000, & e) != 12345 || e != 54321)
        {
            go_throw("bad timediv");
        }
        uint32_t z = {};
        z = 1;
        if(! Cas(gocpp::recv(atomic), & z, 1, 2))
        {
            go_throw("cas1");
        }
        if(z != 2)
        {
            go_throw("cas2");
        }
        z = 4;
        if(Cas(gocpp::recv(atomic), & z, 5, 6))
        {
            go_throw("cas3");
        }
        if(z != 4)
        {
            go_throw("cas4");
        }
        z = 0xffffffff;
        if(! Cas(gocpp::recv(atomic), & z, 0xffffffff, 0xfffffffe))
        {
            go_throw("cas5");
        }
        if(z != 0xfffffffe)
        {
            go_throw("cas6");
        }
        m = gocpp::array<unsigned char, 4> {1, 1, 1, 1};
        Or8(gocpp::recv(atomic), & m[1], 0xf0);
        if(m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1)
        {
            go_throw("atomicor8");
        }
        m = gocpp::array<unsigned char, 4> {0xff, 0xff, 0xff, 0xff};
        And8(gocpp::recv(atomic), & m[1], 0x1);
        if(m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff)
        {
            go_throw("atomicand8");
        }
        *(*uint64_t)(Pointer(gocpp::recv(unsafe), & j)) = ^ uint64_t(0);
        if(j == j)
        {
            go_throw("float64nan");
        }
        if(! (j != j))
        {
            go_throw("float64nan1");
        }
        *(*uint64_t)(Pointer(gocpp::recv(unsafe), & j1)) = ^ uint64_t(1);
        if(j == j1)
        {
            go_throw("float64nan2");
        }
        if(! (j != j1))
        {
            go_throw("float64nan3");
        }
        *(*uint32_t)(Pointer(gocpp::recv(unsafe), & i)) = ^ uint32_t(0);
        if(i == i)
        {
            go_throw("float32nan");
        }
        if(i == i)
        {
            go_throw("float32nan1");
        }
        *(*uint32_t)(Pointer(gocpp::recv(unsafe), & i1)) = ^ uint32_t(1);
        if(i == i1)
        {
            go_throw("float32nan2");
        }
        if(i == i1)
        {
            go_throw("float32nan3");
        }
        testAtomic64();
        if(fixedStack != round2(fixedStack))
        {
            go_throw("FixedStack is not power-of-2");
        }
        if(! checkASM())
        {
            go_throw("assembly checks failed");
        }
    }

    
    std::ostream& dbgVar::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << value;
        os << " " << atomic;
        os << " " << def;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const dbgVar& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {
        int32_t cgocheck;
        int32_t clobberfree;
        int32_t disablethp;
        int32_t dontfreezetheworld;
        int32_t efence;
        int32_t gccheckmark;
        int32_t gcpacertrace;
        int32_t gcshrinkstackoff;
        int32_t gcstoptheworld;
        int32_t gctrace;
        int32_t invalidptr;
        int32_t madvdontneed;
        atomic::Int32 runtimeContentionStacks;
        int32_t scavtrace;
        int32_t scheddetail;
        int32_t schedtrace;
        int32_t tracebackancestors;
        int32_t asyncpreemptoff;
        int32_t harddecommit;
        int32_t adaptivestackstart;
        int32_t tracefpunwindoff;
        int32_t traceadvanceperiod;
        bool malloc;
        int32_t allocfreetrace;
        int32_t inittrace;
        int32_t sbrk;
        atomic::Int32 panicnil;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << cgocheck;
            os << " " << clobberfree;
            os << " " << disablethp;
            os << " " << dontfreezetheworld;
            os << " " << efence;
            os << " " << gccheckmark;
            os << " " << gcpacertrace;
            os << " " << gcshrinkstackoff;
            os << " " << gcstoptheworld;
            os << " " << gctrace;
            os << " " << invalidptr;
            os << " " << madvdontneed;
            os << " " << runtimeContentionStacks;
            os << " " << scavtrace;
            os << " " << scheddetail;
            os << " " << schedtrace;
            os << " " << tracebackancestors;
            os << " " << asyncpreemptoff;
            os << " " << harddecommit;
            os << " " << adaptivestackstart;
            os << " " << tracefpunwindoff;
            os << " " << traceadvanceperiod;
            os << " " << malloc;
            os << " " << allocfreetrace;
            os << " " << inittrace;
            os << " " << sbrk;
            os << " " << panicnil;
            os << '}';
            return os;
        }
    };
    gocpp_id_0 debug;
    gocpp::slice<dbgVar*> dbgvars = gocpp::slice<dbgVar*> {gocpp::Init<>([](& x) { x.name = "allocfreetrace"; x.value = & debug.allocfreetrace; }), gocpp::Init<>([](& x) { x.name = "clobberfree"; x.value = & debug.clobberfree; }), gocpp::Init<>([](& x) { x.name = "cgocheck"; x.value = & debug.cgocheck; }), gocpp::Init<>([](& x) { x.name = "disablethp"; x.value = & debug.disablethp; }), gocpp::Init<>([](& x) { x.name = "dontfreezetheworld"; x.value = & debug.dontfreezetheworld; }), gocpp::Init<>([](& x) { x.name = "efence"; x.value = & debug.efence; }), gocpp::Init<>([](& x) { x.name = "gccheckmark"; x.value = & debug.gccheckmark; }), gocpp::Init<>([](& x) { x.name = "gcpacertrace"; x.value = & debug.gcpacertrace; }), gocpp::Init<>([](& x) { x.name = "gcshrinkstackoff"; x.value = & debug.gcshrinkstackoff; }), gocpp::Init<>([](& x) { x.name = "gcstoptheworld"; x.value = & debug.gcstoptheworld; }), gocpp::Init<>([](& x) { x.name = "gctrace"; x.value = & debug.gctrace; }), gocpp::Init<>([](& x) { x.name = "invalidptr"; x.value = & debug.invalidptr; }), gocpp::Init<>([](& x) { x.name = "madvdontneed"; x.value = & debug.madvdontneed; }), gocpp::Init<>([](& x) { x.name = "runtimecontentionstacks"; x.atomic = & debug.runtimeContentionStacks; }), gocpp::Init<>([](& x) { x.name = "sbrk"; x.value = & debug.sbrk; }), gocpp::Init<>([](& x) { x.name = "scavtrace"; x.value = & debug.scavtrace; }), gocpp::Init<>([](& x) { x.name = "scheddetail"; x.value = & debug.scheddetail; }), gocpp::Init<>([](& x) { x.name = "schedtrace"; x.value = & debug.schedtrace; }), gocpp::Init<>([](& x) { x.name = "tracebackancestors"; x.value = & debug.tracebackancestors; }), gocpp::Init<>([](& x) { x.name = "asyncpreemptoff"; x.value = & debug.asyncpreemptoff; }), gocpp::Init<>([](& x) { x.name = "inittrace"; x.value = & debug.inittrace; }), gocpp::Init<>([](& x) { x.name = "harddecommit"; x.value = & debug.harddecommit; }), gocpp::Init<>([](& x) { x.name = "adaptivestackstart"; x.value = & debug.adaptivestackstart; }), gocpp::Init<>([](& x) { x.name = "tracefpunwindoff"; x.value = & debug.tracefpunwindoff; }), gocpp::Init<>([](& x) { x.name = "panicnil"; x.atomic = & debug.panicnil; }), gocpp::Init<>([](& x) { x.name = "traceadvanceperiod"; x.value = & debug.traceadvanceperiod; })};
    void parsedebugvars()
    {
        debug.cgocheck = 1;
        debug.invalidptr = 1;
        debug.adaptivestackstart = 1;
        if(GOOS == "linux")
        {
            debug.madvdontneed = 1;
        }
        debug.traceadvanceperiod = defaultTraceAdvancePeriod;
        auto godebug = gogetenv("GODEBUG");
        auto p = go_new(string);
        *p = godebug;
        Store(gocpp::recv(godebugEnv), p);
        for(auto [_, v] : dbgvars)
        {
            if(v->def != 0)
            {
                if(v->value != nullptr)
                {
                    *v->value = v->def;
                }
                else
                if(v->atomic != nullptr)
                {
                    Store(gocpp::recv(v->atomic), v->def);
                }
            }
        }
        parsegodebug(godebugDefault, nullptr);
        parsegodebug(godebug, nullptr);
        debug.malloc = (debug.allocfreetrace | debug.inittrace | debug.sbrk) != 0;
        setTraceback(gogetenv("GOTRACEBACK"));
        traceback_env = traceback_cache;
    }

    void reparsedebugvars(std::string env)
    {
        auto seen = gocpp::make(gocpp::Tag<gocpp::map<std::string, bool>>());
        parsegodebug(env, seen);
        parsegodebug(godebugDefault, seen);
        for(auto [_, v] : dbgvars)
        {
            if(v->atomic != nullptr && ! seen[v->name])
            {
                Store(gocpp::recv(v->atomic), 0);
            }
        }
    }

    void parsegodebug(std::string godebug, gocpp::map<std::string, bool> seen)
    {
        for(auto p = godebug; p != ""; )
        {
            std::string field = {};
            if(seen == nullptr)
            {
                auto i = IndexByteString(gocpp::recv(bytealg), p, ',');
                if(i < 0)
                {
                    std::tie(field, p) = std::tuple{p, ""};
                }
                else
                {
                    std::tie(field, p) = std::tuple{p.make_slice(0, i), p.make_slice(i + 1)};
                }
            }
            else
            {
                auto i = len(p) - 1;
                for(; i >= 0 && p[i] != ','; )
                {
                    i--;
                }
                if(i < 0)
                {
                    std::tie(p, field) = std::tuple{"", p};
                }
                else
                {
                    std::tie(p, field) = std::tuple{p.make_slice(0, i), p.make_slice(i + 1)};
                }
            }
            auto i = IndexByteString(gocpp::recv(bytealg), field, '=');
            if(i < 0)
            {
                continue;
            }
            auto [key, value] = std::tuple{field.make_slice(0, i), field.make_slice(i + 1)};
            if(seen[key])
            {
                continue;
            }
            if(seen != nullptr)
            {
                seen[key] = true;
            }
            if(seen == nullptr && key == "memprofilerate")
            {
                if(auto [n, ok] = atoi(value); ok)
                {
                    MemProfileRate = n;
                }
            }
            else
            {
                for(auto [_, v] : dbgvars)
                {
                    if(v->name == key)
                    {
                        if(auto [n, ok] = atoi32(value); ok)
                        {
                            if(seen == nullptr && v->value != nullptr)
                            {
                                *v->value = n;
                            }
                            else
                            if(v->atomic != nullptr)
                            {
                                Store(gocpp::recv(v->atomic), n);
                            }
                        }
                    }
                }
            }
        }
        if(debug.cgocheck > 1)
        {
            go_throw("cgocheck > 1 mode is no longer supported at runtime. Use GOEXPERIMENT=cgocheck2 at build time instead.");
        }
    }

    void setTraceback(std::string level)
    {
        uint32_t t = {};
        //Go switch emulation
        {
            auto condition = level;
            int conditionId = -1;
            if(condition == "none") { conditionId = 0; }
            else if(condition == "single") { conditionId = 1; }
            else if(condition == "") { conditionId = 2; }
            else if(condition == "all") { conditionId = 3; }
            else if(condition == "system") { conditionId = 4; }
            else if(condition == "crash") { conditionId = 5; }
            else if(condition == "wer") { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    t = 0;
                    break;
                case 1:
                case 2:
                    t = 1 << tracebackShift;
                    break;
                case 3:
                    t = (1 << tracebackShift) | tracebackAll;
                    break;
                case 4:
                    t = (2 << tracebackShift) | tracebackAll;
                    break;
                case 5:
                    t = (2 << tracebackShift) | tracebackAll | tracebackCrash;
                    break;
                case 6:
                    if(GOOS == "windows")
                    {
                        t = (2 << tracebackShift) | tracebackAll | tracebackCrash;
                        enableWER();
                        break;
                    }
                default:
                    t = tracebackAll;
                    if(auto [n, ok] = atoi(level); ok && n == int(uint32_t(n)))
                    {
                        t |= uint32_t(n) << tracebackShift;
                    }
                    break;
            }
        }
        if(islibrary || isarchive)
        {
            t |= tracebackCrash;
        }
        t |= traceback_env;
        Store(gocpp::recv(atomic), & traceback_cache, t);
    }

    int32_t timediv(int64_t v, int32_t div, int32_t* rem)
    {
        auto res = int32(0);
        for(auto bit = 30; bit >= 0; bit--)
        {
            if(v >= (int64(div) << (unsigned int)(bit)))
            {
                v = v - (int64(div) << (unsigned int)(bit));
                res |= 1 << (unsigned int)(bit);
            }
        }
        if(v >= int64(div))
        {
            if(rem != nullptr)
            {
                *rem = 0;
            }
            return 0x7fffffff;
        }
        if(rem != nullptr)
        {
            *rem = int32(v);
        }
        return res;
    }

    m* acquirem()
    {
        auto gp = getg();
        gp->m->locks++;
        return gp->m;
    }

    void releasem(m* mp)
    {
        auto gp = getg();
        mp->locks--;
        if(mp->locks == 0 && gp->preempt)
        {
            gp->stackguard0 = stackPreempt;
        }
    }

    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> reflect_typelinks()
    {
        auto modules = activeModules();
        auto sections = gocpp::slice<unsafe::Pointer> {Pointer(gocpp::recv(unsafe), modules[0]->types)};
        auto ret = gocpp::slice<gocpp::slice<int32_t>> {modules[0]->typelinks};
        for(auto [_, md] : modules.make_slice(1))
        {
            sections = append(sections, Pointer(gocpp::recv(unsafe), md->types));
            ret = append(ret, md->typelinks);
        }
        return {sections, ret};
    }

    unsafe::Pointer reflect_resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    {
        return Pointer(gocpp::recv(unsafe), resolveNameOff(ptrInModule, nameOff(off)).Bytes);
    }

    unsafe::Pointer reflect_resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    {
        return Pointer(gocpp::recv(unsafe), typeOff(gocpp::recv(toRType((*_type)(rtype))), typeOff(off)));
    }

    unsafe::Pointer reflect_resolveTextOff(unsafe::Pointer rtype, int32_t off)
    {
        return textOff(gocpp::recv(toRType((*_type)(rtype))), textOff(off));
    }

    unsafe::Pointer reflectlite_resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    {
        return Pointer(gocpp::recv(unsafe), resolveNameOff(ptrInModule, nameOff(off)).Bytes);
    }

    unsafe::Pointer reflectlite_resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    {
        return Pointer(gocpp::recv(unsafe), typeOff(gocpp::recv(toRType((*_type)(rtype))), typeOff(off)));
    }

    int32_t reflect_addReflectOff(unsafe::Pointer ptr)
    {
        reflectOffsLock();
        if(reflectOffs.m == nullptr)
        {
            reflectOffs.m = gocpp::make(gocpp::Tag<gocpp::map<int32_t, unsafe::Pointer>>());
            reflectOffs.minv = gocpp::make(gocpp::Tag<gocpp::map<unsafe::Pointer, int32_t>>());
            reflectOffs.next = - 1;
        }
        auto [id, found] = reflectOffs.minv[ptr];
        if(! found)
        {
            id = reflectOffs.next;
            reflectOffs.next--;
            reflectOffs.m[id] = ptr;
            reflectOffs.minv[ptr] = id;
        }
        reflectOffsUnlock();
        return id;
    }

}

