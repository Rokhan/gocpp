// generated by GoCpp from file '$(ImportDir)/runtime/sigqueue.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/sigqueue.h"
#include "gocpp/support.h"

#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/sigqueue_note.h"  [Ignored, known errors]

namespace golang::runtime
{
    struct gocpp_id_0
    {
        note note;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> mask;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> wanted;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> ignored;
        gocpp::array<uint32_t, (_NSIG + 31) / 32> recv;
        atomic::Uint32 state;
        atomic::Uint32 delivering;
        bool inuse;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.note = this->note;
            result.mask = this->mask;
            result.wanted = this->wanted;
            result.ignored = this->ignored;
            result.recv = this->recv;
            result.state = this->state;
            result.delivering = this->delivering;
            result.inuse = this->inuse;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (note != ref.note) return false;
            if (mask != ref.mask) return false;
            if (wanted != ref.wanted) return false;
            if (ignored != ref.ignored) return false;
            if (recv != ref.recv) return false;
            if (state != ref.state) return false;
            if (delivering != ref.delivering) return false;
            if (inuse != ref.inuse) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << note;
            os << " " << mask;
            os << " " << wanted;
            os << " " << ignored;
            os << " " << recv;
            os << " " << state;
            os << " " << delivering;
            os << " " << inuse;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 sig;
    bool sigsend(uint32_t s)
    {
        auto bit = uint32_t(1) << (unsigned int)(s & 31);
        if(s >= uint32_t(32 * len(sig.wanted)))
        {
            return false;
        }
        Add(gocpp::recv(sig.delivering), 1);
        if(auto w = atomic::Load(& sig.wanted[s / 32]); w & bit == 0)
        {
            Add(gocpp::recv(sig.delivering), - 1);
            return false;
        }
        for(; ; )
        {
            auto mask = sig.mask[s / 32];
            if(mask & bit != 0)
            {
                Add(gocpp::recv(sig.delivering), - 1);
                return true;
            }
            if(atomic::Cas(& sig.mask[s / 32], mask, mask | bit))
            {
                break;
            }
        }
        Send:
        for(; ; )
        {
            //Go switch emulation
            {
                auto condition = Load(gocpp::recv(sig.state));
                int conditionId = -1;
                else if(condition == sigIdle) { conditionId = 0; }
                else if(condition == sigSending) { conditionId = 1; }
                else if(condition == sigReceiving) { conditionId = 2; }
                switch(conditionId)
                {
                    default:
                        go_throw("sigsend: inconsistent state");
                        break;
                    case 0:
                        if(CompareAndSwap(gocpp::recv(sig.state), sigIdle, sigSending))
                        {
                            goto Send_break;
                        }
                        break;
                    case 1:
                        goto Send_break;
                        break;
                    case 2:
                        if(CompareAndSwap(gocpp::recv(sig.state), sigReceiving, sigIdle))
                        {
                            if(GOOS == "darwin" || GOOS == "ios")
                            {
                                sigNoteWakeup(& sig.note);
                                goto Send_break;
                            }
                            notewakeup(& sig.note);
                            goto Send_break;
                        }
                        break;
                }
            }
            if(false) {
            Send_continue:
                continue;
            Send_break:
                break;
            }
        }
        Add(gocpp::recv(sig.delivering), - 1);
        return true;
    }

    uint32_t signal_recv()
    {
        for(; ; )
        {
            for(auto i = uint32_t(0); i < _NSIG; i++)
            {
                if(sig.recv[i / 32] & (1 << (i & 31)) != 0)
                {
                    sig.recv[i / 32] &^= 1 << (i & 31);
                    return i;
                }
            }
            Receive:
            for(; ; )
            {
                //Go switch emulation
                {
                    auto condition = Load(gocpp::recv(sig.state));
                    int conditionId = -1;
                    else if(condition == sigIdle) { conditionId = 0; }
                    else if(condition == sigSending) { conditionId = 1; }
                    switch(conditionId)
                    {
                        default:
                            go_throw("signal_recv: inconsistent state");
                            break;
                        case 0:
                            if(CompareAndSwap(gocpp::recv(sig.state), sigIdle, sigReceiving))
                            {
                                if(GOOS == "darwin" || GOOS == "ios")
                                {
                                    sigNoteSleep(& sig.note);
                                    goto Receive_break;
                                }
                                notetsleepg(& sig.note, - 1);
                                noteclear(& sig.note);
                                goto Receive_break;
                            }
                            break;
                        case 1:
                            if(CompareAndSwap(gocpp::recv(sig.state), sigSending, sigIdle))
                            {
                                goto Receive_break;
                            }
                            break;
                    }
                }
                if(false) {
                Receive_continue:
                    continue;
                Receive_break:
                    break;
                }
            }
            for(auto [i, gocpp_ignored] : sig.mask)
            {
                sig.recv[i] = atomic::Xchg(& sig.mask[i], 0);
            }
        }
    }

    void signalWaitUntilIdle()
    {
        for(; Load(gocpp::recv(sig.delivering)) != 0; )
        {
            Gosched();
        }
        for(; Load(gocpp::recv(sig.state)) != sigReceiving; )
        {
            Gosched();
        }
    }

    void signal_enable(uint32_t s)
    {
        if(! sig.inuse)
        {
            sig.inuse = true;
            if(GOOS == "darwin" || GOOS == "ios")
            {
                sigNoteSetup(& sig.note);
            }
            else
            {
                noteclear(& sig.note);
            }
        }
        if(s >= uint32_t(len(sig.wanted) * 32))
        {
            return;
        }
        auto w = sig.wanted[s / 32];
        w |= 1 << (s & 31);
        atomic::Store(& sig.wanted[s / 32], w);
        auto i = sig.ignored[s / 32];
        i &^= 1 << (s & 31);
        atomic::Store(& sig.ignored[s / 32], i);
        sigenable(s);
    }

    void signal_disable(uint32_t s)
    {
        if(s >= uint32_t(len(sig.wanted) * 32))
        {
            return;
        }
        sigdisable(s);
        auto w = sig.wanted[s / 32];
        w &^= 1 << (s & 31);
        atomic::Store(& sig.wanted[s / 32], w);
    }

    void signal_ignore(uint32_t s)
    {
        if(s >= uint32_t(len(sig.wanted) * 32))
        {
            return;
        }
        sigignore(s);
        auto w = sig.wanted[s / 32];
        w &^= 1 << (s & 31);
        atomic::Store(& sig.wanted[s / 32], w);
        auto i = sig.ignored[s / 32];
        i |= 1 << (s & 31);
        atomic::Store(& sig.ignored[s / 32], i);
    }

    void sigInitIgnored(uint32_t s)
    {
        auto i = sig.ignored[s / 32];
        i |= 1 << (s & 31);
        atomic::Store(& sig.ignored[s / 32], i);
    }

    bool signal_ignored(uint32_t s)
    {
        auto i = atomic::Load(& sig.ignored[s / 32]);
        return i & (1 << (s & 31)) != 0;
    }

}

