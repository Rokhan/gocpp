// generated by GoCpp from file '$(ImportDir)/syscall/syscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/syscall_windows.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/itoa/itoa.h"
// #include "golang/internal/race/norace.h"  [Ignored, known errors]
#include "golang/runtime/extern.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/syscall/asan0.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/msan0.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/wtf8_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    gocpp::slice<uint16_t> StringToUTF16(std::string s)
    {
        auto [a, err] = UTF16FromString(s);
        if(err != nullptr)
        {
            gocpp::panic("syscall: string with NUL passed to StringToUTF16");
        }
        return a;
    }

    std::tuple<gocpp::slice<uint16_t>, std::string> UTF16FromString(std::string s)
    {
        if(bytealg::IndexByteString(s, 0) != - 1)
        {
            return {nullptr, EINVAL};
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 0, len(s) + 1);
        buf = encodeWTF16(s, buf);
        return {append(buf, 0), nullptr};
    }

    std::string UTF16ToString(gocpp::slice<uint16_t> s)
    {
        auto maxLen = 0;
        for(auto [i, v] : s)
        {
            if(v == 0)
            {
                s = s.make_slice(0, i);
                break;
            }
            //Go switch emulation
            {
                int conditionId = -1;
                if(v <= rune1Max) { conditionId = 0; }
                else if(v <= rune2Max) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        maxLen += 1;
                        break;
                    case 1:
                        maxLen += 2;
                        break;
                    default:
                        maxLen += 3;
                        break;
                }
            }
        }
        auto buf = decodeWTF16(s, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, maxLen));
        return unsafe::String(unsafe::SliceData(buf), len(buf));
    }

    std::string utf16PtrToString(uint16_t* p)
    {
        if(p == nullptr)
        {
            return "";
        }
        auto end = unsafe::Pointer(p);
        auto n = 0;
        for(; *(uint16_t*)(end) != 0; )
        {
            end = unsafe::Pointer(uintptr_t(end) + gocpp::Sizeof<uint16_t>());
            n++;
        }
        return UTF16ToString(unsafe::Slice(p, n));
    }

    uint16_t* StringToUTF16Ptr(std::string s)
    {
        return & StringToUTF16(s)[0];
    }

    std::tuple<uint16_t*, std::string> UTF16PtrFromString(std::string s)
    {
        auto [a, err] = UTF16FromString(s);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {& a[0], nullptr};
    }

    uint32_t langid(uint16_t pri, uint16_t sub)
    {
        return (uint32_t(sub) << 10) | uint32_t(pri);
    }

    std::tuple<uint32_t, std::string> FormatMessage(uint32_t flags, uint32_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args)
    {
        uint32_t n;
        std::string err;
        return formatMessage(flags, uintptr_t(msgsrc), msgid, langid, buf, args);
    }

    std::string Error(Errno e)
    {
        auto idx = int(e - APPLICATION_ERROR);
        if(0 <= idx && idx < len(errors))
        {
            return errors[idx];
        }
        uint32_t flags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_IGNORE_INSERTS;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 300);
        auto [n, err] = formatMessage(flags, 0, uint32_t(e), langid(LANG_ENGLISH, SUBLANG_ENGLISH_US), b, nullptr);
        if(err != nullptr)
        {
            std::tie(n, err) = formatMessage(flags, 0, uint32_t(e), 0, b, nullptr);
            if(err != nullptr)
            {
                return "winapi error #" + itoa::Itoa(int(e));
            }
        }
        for(; n > 0 && (b[n - 1] == '\n' || b[n - 1] == '\r'); n--)
        {
        }
        return UTF16ToString(b.make_slice(0, n));
    }

    bool Is(Errno e, std::string target)
    {
        //Go switch emulation
        {
            auto condition = target;
            int conditionId = -1;
            if(condition == oserror::ErrPermission) { conditionId = 0; }
            else if(condition == oserror::ErrExist) { conditionId = 1; }
            else if(condition == oserror::ErrNotExist) { conditionId = 2; }
            else if(condition == errorspkg::ErrUnsupported) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return e == ERROR_ACCESS_DENIED || e == EACCES || e == EPERM;
                    break;
                case 1:
                    return e == ERROR_ALREADY_EXISTS || e == ERROR_DIR_NOT_EMPTY || e == ERROR_FILE_EXISTS || e == EEXIST || e == ENOTEMPTY;
                    break;
                case 2:
                    return e == ERROR_FILE_NOT_FOUND || e == _ERROR_BAD_NETPATH || e == ERROR_PATH_NOT_FOUND || e == ENOENT;
                    break;
                case 3:
                    return e == _ERROR_NOT_SUPPORTED || e == _ERROR_CALL_NOT_IMPLEMENTED || e == ENOSYS || e == ENOTSUP || e == EOPNOTSUPP || e == EWINDOWS;
                    break;
            }
        }
        return false;
    }

    bool Temporary(Errno e)
    {
        return e == EINTR || e == EMFILE || Timeout(gocpp::recv(e));
    }

    bool Timeout(Errno e)
    {
        return e == EAGAIN || e == EWOULDBLOCK || e == ETIMEDOUT;
    }

    uintptr_t compileCallback(go_any fn, bool cleanstack)
    /* convertBlockStmt, nil block */;

    uintptr_t NewCallback(go_any fn)
    {
        return compileCallback(fn, true);
    }

    uintptr_t NewCallbackCDecl(go_any fn)
    {
        return compileCallback(fn, false);
    }

    SecurityAttributes* makeInheritSa()
    {
        SecurityAttributes sa = {};
        sa.Length = uint32_t(gocpp::Sizeof<SecurityAttributes>());
        sa.InheritHandle = 1;
        return & sa;
    }

    std::tuple<Handle, std::string> Open(std::string path, int mode, uint32_t perm)
    {
        Handle fd;
        std::string err;
        if(len(path) == 0)
        {
            Handle fd;
            std::string err;
            return {InvalidHandle, ERROR_FILE_NOT_FOUND};
        }
        auto [pathp, err] = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            Handle fd;
            std::string err;
            return {InvalidHandle, err};
        }
        uint32_t access = {};
        //Go switch emulation
        {
            auto condition = mode & (O_RDONLY | O_WRONLY | O_RDWR);
            int conditionId = -1;
            if(condition == O_RDONLY) { conditionId = 0; }
            else if(condition == O_WRONLY) { conditionId = 1; }
            else if(condition == O_RDWR) { conditionId = 2; }
            switch(conditionId)
            {
                Handle fd;
                std::string err;
                case 0:
                    access = GENERIC_READ;
                    break;
                case 1:
                    access = GENERIC_WRITE;
                    break;
                case 2:
                    access = GENERIC_READ | GENERIC_WRITE;
                    break;
            }
        }
        if(mode & O_CREAT != 0)
        {
            Handle fd;
            std::string err;
            access |= GENERIC_WRITE;
        }
        if(mode & O_APPEND != 0)
        {
            Handle fd;
            std::string err;
            access &^= GENERIC_WRITE;
            access |= FILE_APPEND_DATA;
        }
        auto sharemode = uint32_t(FILE_SHARE_READ | FILE_SHARE_WRITE);
        SecurityAttributes* sa = {};
        if(mode & O_CLOEXEC == 0)
        {
            Handle fd;
            std::string err;
            sa = makeInheritSa();
        }
        uint32_t createmode = {};
        //Go switch emulation
        {
            int conditionId = -1;
            if(mode & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL)) { conditionId = 0; }
            else if(mode & (O_CREAT | O_TRUNC) == (O_CREAT | O_TRUNC)) { conditionId = 1; }
            else if(mode & O_CREAT == O_CREAT) { conditionId = 2; }
            else if(mode & O_TRUNC == O_TRUNC) { conditionId = 3; }
            switch(conditionId)
            {
                Handle fd;
                std::string err;
                case 0:
                    createmode = CREATE_NEW;
                    break;
                case 1:
                    createmode = CREATE_ALWAYS;
                    break;
                case 2:
                    createmode = OPEN_ALWAYS;
                    break;
                case 3:
                    createmode = TRUNCATE_EXISTING;
                    break;
                default:
                    createmode = OPEN_EXISTING;
                    break;
            }
        }
        uint32_t attrs = FILE_ATTRIBUTE_NORMAL;
        if(perm & S_IWRITE == 0)
        {
            Handle fd;
            std::string err;
            attrs = FILE_ATTRIBUTE_READONLY;
            if(createmode == CREATE_ALWAYS)
            {
                Handle fd;
                std::string err;
                auto [h, e] = CreateFile(pathp, access, sharemode, sa, TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                //Go switch emulation
                {
                    auto condition = e;
                    int conditionId = -1;
                    if(condition == ERROR_FILE_NOT_FOUND) { conditionId = 0; }
                    if(condition == _ERROR_BAD_NETPATH) { conditionId = 1; }
                    if(condition == ERROR_PATH_NOT_FOUND) { conditionId = 2; }
                    switch(conditionId)
                    {
                        Handle fd;
                        std::string err;
                        case 0:
                        case 1:
                        case 2:
                            break;
                        default:
                            return {h, e};
                            break;
                    }
                }
            }
        }
        if(createmode == OPEN_EXISTING && access == GENERIC_READ)
        {
            Handle fd;
            std::string err;
            attrs |= FILE_FLAG_BACKUP_SEMANTICS;
        }
        if(mode & O_SYNC != 0)
        {
            Handle fd;
            std::string err;
            auto _FILE_FLAG_WRITE_THROUGH = 0x80000000;
            attrs |= _FILE_FLAG_WRITE_THROUGH;
        }
        return CreateFile(pathp, access, sharemode, sa, createmode, attrs, 0);
    }

    std::tuple<int, std::string> Read(Handle fd, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        uint32_t done = {};
        auto e = ReadFile(fd, p, & done, nullptr);
        if(e != nullptr)
        {
            int n;
            std::string err;
            if(e == ERROR_BROKEN_PIPE)
            {
                int n;
                std::string err;
                return {0, nullptr};
            }
            return {0, e};
        }
        return {int(done), nullptr};
    }

    std::tuple<int, std::string> Write(Handle fd, gocpp::slice<unsigned char> p)
    {
        int n;
        std::string err;
        uint32_t done = {};
        auto e = WriteFile(fd, p, & done, nullptr);
        if(e != nullptr)
        {
            int n;
            std::string err;
            return {0, e};
        }
        return {int(done), nullptr};
    }

    std::string ReadFile(Handle fd, gocpp::slice<unsigned char> p, uint32_t* done, Overlapped* overlapped)
    {
        auto err = readFile(fd, p, done, overlapped);
        if(race::Enabled)
        {
            if(*done > 0)
            {
                race::WriteRange(unsafe::Pointer(& p[0]), int(*done));
            }
            race::Acquire(unsafe::Pointer(& ioSync));
        }
        if(msanenabled && *done > 0)
        {
            msanWrite(unsafe::Pointer(& p[0]), int(*done));
        }
        if(asanenabled && *done > 0)
        {
            asanWrite(unsafe::Pointer(& p[0]), int(*done));
        }
        return err;
    }

    std::string WriteFile(Handle fd, gocpp::slice<unsigned char> p, uint32_t* done, Overlapped* overlapped)
    {
        if(race::Enabled)
        {
            race::ReleaseMerge(unsafe::Pointer(& ioSync));
        }
        auto err = writeFile(fd, p, done, overlapped);
        if(race::Enabled && *done > 0)
        {
            race::ReadRange(unsafe::Pointer(& p[0]), int(*done));
        }
        if(msanenabled && *done > 0)
        {
            msanRead(unsafe::Pointer(& p[0]), int(*done));
        }
        if(asanenabled && *done > 0)
        {
            asanRead(unsafe::Pointer(& p[0]), int(*done));
        }
        return err;
    }

    int64_t ioSync;
    LazyProc* procSetFilePointerEx = NewProc(gocpp::recv(modkernel32), "SetFilePointerEx");
    std::string setFilePointerEx(Handle handle, int64_t distToMove, int64_t* newFilePointer, uint32_t whence)
    {
        Errno e1 = {};
        if(gocpp::Sizeof<uintptr_t>() == 8)
        {
            std::tie(gocpp_id_0, gocpp_id_1, e1) = Syscall6(Addr(gocpp::recv(procSetFilePointerEx)), 4, uintptr_t(handle), uintptr_t(distToMove), uintptr_t(unsafe::Pointer(newFilePointer)), uintptr_t(whence), 0, 0);
        }
        else
        {
            //Go switch emulation
            {
                auto condition = runtime::GOARCH;
                int conditionId = -1;
                else if(condition == "386") { conditionId = 0; }
                else if(condition == "arm") { conditionId = 1; }
                switch(conditionId)
                {
                    default:
                        gocpp::panic("unsupported 32-bit architecture");
                        break;
                    case 0:
                        std::tie(gocpp_id_2, gocpp_id_3, e1) = Syscall6(Addr(gocpp::recv(procSetFilePointerEx)), 5, uintptr_t(handle), uintptr_t(distToMove), uintptr_t(distToMove >> 32), uintptr_t(unsafe::Pointer(newFilePointer)), uintptr_t(whence), 0);
                        break;
                    case 1:
                        std::tie(gocpp_id_4, gocpp_id_5, e1) = Syscall6(Addr(gocpp::recv(procSetFilePointerEx)), 6, uintptr_t(handle), 0, uintptr_t(distToMove), uintptr_t(distToMove >> 32), uintptr_t(unsafe::Pointer(newFilePointer)), uintptr_t(whence));
                        break;
                }
            }
        }
        if(e1 != 0)
        {
            return errnoErr(e1);
        }
        return nullptr;
    }

    std::tuple<int64_t, std::string> Seek(Handle fd, int64_t offset, int whence)
    {
        int64_t newoffset;
        std::string err;
        uint32_t w = {};
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                int64_t newoffset;
                std::string err;
                case 0:
                    w = FILE_BEGIN;
                    break;
                case 1:
                    w = FILE_CURRENT;
                    break;
                case 2:
                    w = FILE_END;
                    break;
            }
        }
        err = setFilePointerEx(fd, offset, & newoffset, w);
        return {newoffset, err};
    }

    std::string Close(Handle fd)
    {
        std::string err;
        return CloseHandle(fd);
    }

    Handle Stdin = getStdHandle(STD_INPUT_HANDLE);
    Handle Stdout = getStdHandle(STD_OUTPUT_HANDLE);
    Handle Stderr = getStdHandle(STD_ERROR_HANDLE);
    Handle getStdHandle(int h)
    {
        Handle fd;
        auto [r, gocpp_id_7] = GetStdHandle(h);
        return r;
    }

    std::tuple<std::string, std::string> Getwd()
    {
        std::string wd;
        std::string err;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 300);
        for(; ; )
        {
            std::string wd;
            std::string err;
            auto [n, e] = GetCurrentDirectory(uint32_t(len(b)), & b[0]);
            if(e != nullptr)
            {
                std::string wd;
                std::string err;
                return {"", e};
            }
            if(int(n) <= len(b))
            {
                std::string wd;
                std::string err;
                return {UTF16ToString(b.make_slice(0, n)), nullptr};
            }
            b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
        }
    }

    std::string Chdir(std::string path)
    {
        std::string err;
        auto [pathp, err] = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return SetCurrentDirectory(pathp);
    }

    std::string Mkdir(std::string path, uint32_t mode)
    {
        std::string err;
        auto [pathp, err] = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return CreateDirectory(pathp, nullptr);
    }

    std::string Rmdir(std::string path)
    {
        std::string err;
        auto [pathp, err] = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return RemoveDirectory(pathp);
    }

    std::string Unlink(std::string path)
    {
        std::string err;
        auto [pathp, err] = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return DeleteFile(pathp);
    }

    std::string Rename(std::string oldpath, std::string newpath)
    {
        std::string err;
        auto [from, err] = UTF16PtrFromString(oldpath);
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        uint16_t* to;
        std::tie(to, err) = UTF16PtrFromString(newpath);
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return MoveFile(from, to);
    }

    std::tuple<std::string, std::string> ComputerName()
    {
        std::string name;
        std::string err;
        uint32_t n = MAX_COMPUTERNAME_LENGTH + 1;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
        auto e = GetComputerName(& b[0], & n);
        if(e != nullptr)
        {
            std::string name;
            std::string err;
            return {"", e};
        }
        return {UTF16ToString(b.make_slice(0, n)), nullptr};
    }

    std::string Ftruncate(Handle fd, int64_t length)
    {
        gocpp::Defer defer;
        try
        {
            std::string err;
            auto [curoffset, e] = Seek(fd, 0, 1);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            defer.push_back([=]{ Seek(fd, curoffset, 0); });
            std::tie(gocpp_id_8, e) = Seek(fd, length, 0);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            e = SetEndOfFile(fd);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::string Gettimeofday(Timeval* tv)
    {
        std::string err;
        Filetime ft = {};
        GetSystemTimeAsFileTime(& ft);
        *tv = NsecToTimeval(Nanoseconds(gocpp::recv(ft)));
        return nullptr;
    }

    std::string Pipe(gocpp::slice<Handle> p)
    {
        std::string err;
        if(len(p) != 2)
        {
            std::string err;
            return EINVAL;
        }
        Handle r = {};
        Handle w = {};
        auto e = CreatePipe(& r, & w, makeInheritSa(), 0);
        if(e != nullptr)
        {
            std::string err;
            return e;
        }
        p[0] = r;
        p[1] = w;
        return nullptr;
    }

    std::string Utimes(std::string path, gocpp::slice<Timeval> tv)
    {
        gocpp::Defer defer;
        try
        {
            std::string err;
            if(len(tv) != 2)
            {
                std::string err;
                return EINVAL;
            }
            auto [pathp, e] = UTF16PtrFromString(path);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            Handle h;
            std::tie(h, e) = CreateFile(pathp, FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            defer.push_back([=]{ Close(h); });
            auto a = Filetime {};
            auto w = Filetime {};
            if(Nanoseconds(gocpp::recv(tv[0])) != 0)
            {
                std::string err;
                a = NsecToFiletime(Nanoseconds(gocpp::recv(tv[0])));
            }
            if(Nanoseconds(gocpp::recv(tv[0])) != 0)
            {
                std::string err;
                w = NsecToFiletime(Nanoseconds(gocpp::recv(tv[1])));
            }
            return SetFileTime(h, nullptr, & a, & w);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::string UtimesNano(std::string path, gocpp::slice<Timespec> ts)
    {
        gocpp::Defer defer;
        try
        {
            std::string err;
            if(len(ts) != 2)
            {
                std::string err;
                return EINVAL;
            }
            auto [pathp, e] = UTF16PtrFromString(path);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            Handle h;
            std::tie(h, e) = CreateFile(pathp, FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
            if(e != nullptr)
            {
                std::string err;
                return e;
            }
            defer.push_back([=]{ Close(h); });
            auto a = Filetime {};
            auto w = Filetime {};
            if(ts[0].Nsec != _UTIME_OMIT)
            {
                std::string err;
                a = NsecToFiletime(TimespecToNsec(ts[0]));
            }
            if(ts[1].Nsec != _UTIME_OMIT)
            {
                std::string err;
                w = NsecToFiletime(TimespecToNsec(ts[1]));
            }
            return SetFileTime(h, nullptr, & a, & w);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::string Fsync(Handle fd)
    {
        std::string err;
        return FlushFileBuffers(fd);
    }

    std::string Chmod(std::string path, uint32_t mode)
    {
        std::string err;
        auto [p, e] = UTF16PtrFromString(path);
        if(e != nullptr)
        {
            std::string err;
            return e;
        }
        uint32_t attrs;
        std::tie(attrs, e) = GetFileAttributes(p);
        if(e != nullptr)
        {
            std::string err;
            return e;
        }
        if(mode & S_IWRITE != 0)
        {
            std::string err;
            attrs &^= FILE_ATTRIBUTE_READONLY;
        }
        else
        {
            std::string err;
            attrs |= FILE_ATTRIBUTE_READONLY;
        }
        return SetFileAttributes(p, attrs);
    }

    std::string LoadCancelIoEx()
    {
        return Find(gocpp::recv(procCancelIoEx));
    }

    std::string LoadSetFileCompletionNotificationModes()
    {
        return Find(gocpp::recv(procSetFileCompletionNotificationModes));
    }

    bool SocketDisableIPv6;
    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrInet4::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Port = this->Port;
        result.Addr = this->Addr;
        result.Zero = this->Zero;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrInet4::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Port != ref.Port) return false;
        if (Addr != ref.Addr) return false;
        if (Zero != ref.Zero) return false;
        return true;
    }

    std::ostream& RawSockaddrInet4::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Port;
        os << " " << Addr;
        os << " " << Zero;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrInet4& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrInet6::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Port = this->Port;
        result.Flowinfo = this->Flowinfo;
        result.Addr = this->Addr;
        result.Scope_id = this->Scope_id;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrInet6::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Port != ref.Port) return false;
        if (Flowinfo != ref.Flowinfo) return false;
        if (Addr != ref.Addr) return false;
        if (Scope_id != ref.Scope_id) return false;
        return true;
    }

    std::ostream& RawSockaddrInet6::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Port;
        os << " " << Flowinfo;
        os << " " << Addr;
        os << " " << Scope_id;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrInet6& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddr::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Data = this->Data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddr::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Data != ref.Data) return false;
        return true;
    }

    std::ostream& RawSockaddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddr& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrAny::operator T()
    {
        T result;
        result.Addr = this->Addr;
        result.Pad = this->Pad;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrAny::operator==(const T& ref) const
    {
        if (Addr != ref.Addr) return false;
        if (Pad != ref.Pad) return false;
        return true;
    }

    std::ostream& RawSockaddrAny::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Addr;
        os << " " << Pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrAny& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Sockaddr::Sockaddr(T& ref)
    {
        value.reset(new SockaddrImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Sockaddr::Sockaddr(const T& ref)
    {
        value.reset(new SockaddrImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Sockaddr::Sockaddr(T* ptr)
    {
        value.reset(new SockaddrImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Sockaddr::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<unsafe::Pointer, int32_t, std::string> Sockaddr::SockaddrImpl<T, StoreT>::vsockaddr()
    {
        return sockaddr(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<unsafe::Pointer, int32_t, std::string> sockaddr(const gocpp::PtrRecv<Sockaddr, false>& self)
    {
        return self.ptr->value->vsockaddr();
    }

    std::tuple<unsafe::Pointer, int32_t, std::string> sockaddr(const gocpp::ObjRecv<Sockaddr>& self)
    {
        return self.obj.value->vsockaddr();
    }

    std::ostream& operator<<(std::ostream& os, const struct Sockaddr& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SockaddrInet4::operator T()
    {
        T result;
        result.Port = this->Port;
        result.Addr = this->Addr;
        result.raw = this->raw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SockaddrInet4::operator==(const T& ref) const
    {
        if (Port != ref.Port) return false;
        if (Addr != ref.Addr) return false;
        if (raw != ref.raw) return false;
        return true;
    }

    std::ostream& SockaddrInet4::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Port;
        os << " " << Addr;
        os << " " << raw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SockaddrInet4& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<unsafe::Pointer, int32_t, std::string> sockaddr(struct SockaddrInet4* sa)
    {
        if(sa->Port < 0 || sa->Port > 0xFFFF)
        {
            return {nullptr, 0, EINVAL};
        }
        sa->raw.Family = AF_INET;
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& sa->raw.Port));
        p[0] = unsigned char(sa->Port >> 8);
        p[1] = unsigned char(sa->Port);
        sa->raw.Addr = sa->Addr;
        return {unsafe::Pointer(& sa->raw), int32_t(gocpp::Sizeof<RawSockaddrInet4>()), nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SockaddrInet6::operator T()
    {
        T result;
        result.Port = this->Port;
        result.ZoneId = this->ZoneId;
        result.Addr = this->Addr;
        result.raw = this->raw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SockaddrInet6::operator==(const T& ref) const
    {
        if (Port != ref.Port) return false;
        if (ZoneId != ref.ZoneId) return false;
        if (Addr != ref.Addr) return false;
        if (raw != ref.raw) return false;
        return true;
    }

    std::ostream& SockaddrInet6::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Port;
        os << " " << ZoneId;
        os << " " << Addr;
        os << " " << raw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SockaddrInet6& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<unsafe::Pointer, int32_t, std::string> sockaddr(struct SockaddrInet6* sa)
    {
        if(sa->Port < 0 || sa->Port > 0xFFFF)
        {
            return {nullptr, 0, EINVAL};
        }
        sa->raw.Family = AF_INET6;
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& sa->raw.Port));
        p[0] = unsigned char(sa->Port >> 8);
        p[1] = unsigned char(sa->Port);
        sa->raw.Scope_id = sa->ZoneId;
        sa->raw.Addr = sa->Addr;
        return {unsafe::Pointer(& sa->raw), int32_t(gocpp::Sizeof<RawSockaddrInet6>()), nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrUnix::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Path = this->Path;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrUnix::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Path != ref.Path) return false;
        return true;
    }

    std::ostream& RawSockaddrUnix::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Path;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrUnix& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SockaddrUnix::operator T()
    {
        T result;
        result.Name = this->Name;
        result.raw = this->raw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SockaddrUnix::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (raw != ref.raw) return false;
        return true;
    }

    std::ostream& SockaddrUnix::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << raw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SockaddrUnix& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<unsafe::Pointer, int32_t, std::string> sockaddr(struct SockaddrUnix* sa)
    {
        auto name = sa->Name;
        auto n = len(name);
        if(n > len(sa->raw.Path))
        {
            return {nullptr, 0, EINVAL};
        }
        if(n == len(sa->raw.Path) && name[0] != '@')
        {
            return {nullptr, 0, EINVAL};
        }
        sa->raw.Family = AF_UNIX;
        for(auto i = 0; i < n; i++)
        {
            sa->raw.Path[i] = int8_t(name[i]);
        }
        auto sl = int32_t(2);
        if(n > 0)
        {
            sl += int32_t(n) + 1;
        }
        if(sa->raw.Path[0] == '@' || (sa->raw.Path[0] == 0 && sl > 3))
        {
            sa->raw.Path[0] = 0;
            sl--;
        }
        return {unsafe::Pointer(& sa->raw), sl, nullptr};
    }

    std::tuple<Sockaddr, std::string> Sockaddr(struct RawSockaddrAny* rsa)
    {
        //Go switch emulation
        {
            auto condition = rsa->Addr.Family;
            int conditionId = -1;
            if(condition == AF_UNIX) { conditionId = 0; }
            else if(condition == AF_INET) { conditionId = 1; }
            else if(condition == AF_INET6) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    auto pp = (RawSockaddrUnix*)(unsafe::Pointer(rsa));
                    auto sa = go_new(SockaddrUnix);
                    if(pp->Path[0] == 0)
                    {
                        pp->Path[0] = '@';
                    }
                    auto n = 0;
                    for(; n < len(pp->Path) && pp->Path[n] != 0; )
                    {
                        n++;
                    }
                    sa->Name = string(unsafe::Slice((unsigned char*)(unsafe::Pointer(& pp->Path[0])), n));
                    return {sa, nullptr};
                    break;
                case 1:
                    auto pp = (RawSockaddrInet4*)(unsafe::Pointer(rsa));
                    auto sa = go_new(SockaddrInet4);
                    auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& pp->Port));
                    sa->Port = (int(p[0]) << 8) + int(p[1]);
                    sa->Addr = pp->Addr;
                    return {sa, nullptr};
                    break;
                case 2:
                    auto pp = (RawSockaddrInet6*)(unsafe::Pointer(rsa));
                    auto sa = go_new(SockaddrInet6);
                    auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& pp->Port));
                    sa->Port = (int(p[0]) << 8) + int(p[1]);
                    sa->ZoneId = pp->Scope_id;
                    sa->Addr = pp->Addr;
                    return {sa, nullptr};
                    break;
            }
        }
        return {nullptr, EAFNOSUPPORT};
    }

    std::tuple<Handle, std::string> Socket(int domain, int typ, int proto)
    {
        Handle fd;
        std::string err;
        if(domain == AF_INET6 && SocketDisableIPv6)
        {
            Handle fd;
            std::string err;
            return {InvalidHandle, EAFNOSUPPORT};
        }
        return socket(int32_t(domain), int32_t(typ), int32_t(proto));
    }

    std::string SetsockoptInt(Handle fd, int level, int opt, int value)
    {
        std::string err;
        auto v = int32_t(value);
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(& v)), int32_t(gocpp::Sizeof<int32_t>()));
    }

    std::string Bind(Handle fd, Sockaddr sa)
    {
        std::string err;
        auto [ptr, n, err] = sockaddr(gocpp::recv(sa));
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return bind(fd, ptr, n);
    }

    std::string Connect(Handle fd, Sockaddr sa)
    {
        std::string err;
        auto [ptr, n, err] = sockaddr(gocpp::recv(sa));
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return connect(fd, ptr, n);
    }

    std::tuple<Sockaddr, std::string> Getsockname(Handle fd)
    {
        Sockaddr sa;
        std::string err;
        RawSockaddrAny rsa = {};
        auto l = int32_t(gocpp::Sizeof<RawSockaddrAny>());
        if(err = getsockname(fd, & rsa, & l); err != nullptr)
        {
            Sockaddr sa;
            std::string err;
            return {sa, err};
        }
        return Sockaddr(gocpp::recv(rsa));
    }

    std::tuple<Sockaddr, std::string> Getpeername(Handle fd)
    {
        Sockaddr sa;
        std::string err;
        RawSockaddrAny rsa = {};
        auto l = int32_t(gocpp::Sizeof<RawSockaddrAny>());
        if(err = getpeername(fd, & rsa, & l); err != nullptr)
        {
            Sockaddr sa;
            std::string err;
            return {sa, err};
        }
        return Sockaddr(gocpp::recv(rsa));
    }

    std::string Listen(Handle s, int n)
    {
        std::string err;
        return listen(s, int32_t(n));
    }

    std::string Shutdown(Handle fd, int how)
    {
        std::string err;
        return shutdown(fd, int32_t(how));
    }

    std::string WSASendto(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, Sockaddr to, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        unsafe::Pointer rsa = {};
        int32_t len = {};
        if(to != nullptr)
        {
            std::string err;
            std::tie(rsa, len, err) = sockaddr(gocpp::recv(to));
            if(err != nullptr)
            {
                std::string err;
                return err;
            }
        }
        auto [r1, gocpp_id_10, e1] = Syscall9(Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(len), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            std::string err;
            if(e1 != 0)
            {
                std::string err;
                err = errnoErr(e1);
            }
            else
            {
                std::string err;
                err = EINVAL;
            }
        }
        return err;
    }

    std::string wsaSendtoInet4(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, SockaddrInet4* to, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        auto [rsa, len, err] = sockaddr(gocpp::recv(to));
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        auto [r1, gocpp_id_12, e1] = Syscall9(Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(len), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            std::string err;
            if(e1 != 0)
            {
                std::string err;
                err = errnoErr(e1);
            }
            else
            {
                std::string err;
                err = EINVAL;
            }
        }
        return err;
    }

    std::string wsaSendtoInet6(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, SockaddrInet6* to, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        auto [rsa, len, err] = sockaddr(gocpp::recv(to));
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        auto [r1, gocpp_id_14, e1] = Syscall9(Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(len), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            std::string err;
            if(e1 != 0)
            {
                std::string err;
                err = errnoErr(e1);
            }
            else
            {
                std::string err;
                err = EINVAL;
            }
        }
        return err;
    }

    std::string LoadGetAddrInfo()
    {
        return Find(gocpp::recv(procGetAddrInfoW));
    }

    struct gocpp_id_15
    {
        sync::Once once;
        uintptr_t addr;
        std::string err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.once = this->once;
            result.addr = this->addr;
            result.err = this->err;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (once != ref.once) return false;
            if (addr != ref.addr) return false;
            if (err != ref.err) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << once;
            os << " " << addr;
            os << " " << err;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_15& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_15 connectExFunc;
    std::string LoadConnectEx()
    {
        Do(gocpp::recv(connectExFunc.once), [=]() mutable -> void
        {
            gocpp::Defer defer;
            try
            {
                Handle s = {};
                std::tie(s, connectExFunc.err) = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if(connectExFunc.err != nullptr)
                {
                    return;
                }
                defer.push_back([=]{ CloseHandle(s); });
                uint32_t n = {};
                connectExFunc.err = WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, (unsigned char*)(unsafe::Pointer(& WSAID_CONNECTEX)), uint32_t(gocpp::Sizeof<GUID>()), (unsigned char*)(unsafe::Pointer(& connectExFunc.addr)), uint32_t(gocpp::Sizeof<uintptr_t>()), & n, nullptr, 0);
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        });
        return connectExFunc.err;
    }

    std::string connectEx(Handle s, unsafe::Pointer name, int32_t namelen, unsigned char* sendBuf, uint32_t sendDataLen, uint32_t* bytesSent, Overlapped* overlapped)
    {
        std::string err;
        auto [r1, gocpp_id_17, e1] = Syscall9(connectExFunc.addr, 7, uintptr_t(s), uintptr_t(name), uintptr_t(namelen), uintptr_t(unsafe::Pointer(sendBuf)), uintptr_t(sendDataLen), uintptr_t(unsafe::Pointer(bytesSent)), uintptr_t(unsafe::Pointer(overlapped)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            if(e1 != 0)
            {
                std::string err;
                err = error(e1);
            }
            else
            {
                std::string err;
                err = EINVAL;
            }
        }
        return err;
    }

    std::string ConnectEx(Handle fd, Sockaddr sa, unsigned char* sendBuf, uint32_t sendDataLen, uint32_t* bytesSent, Overlapped* overlapped)
    {
        auto err = LoadConnectEx();
        if(err != nullptr)
        {
            return errorspkg::New("failed to find ConnectEx: " + Error(gocpp::recv(err)));
        }
        unsafe::Pointer ptr;
        int32_t n;
        std::tie(ptr, n, err) = sockaddr(gocpp::recv(sa));
        if(err != nullptr)
        {
            return err;
        }
        return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Rusage::operator T()
    {
        T result;
        result.CreationTime = this->CreationTime;
        result.ExitTime = this->ExitTime;
        result.KernelTime = this->KernelTime;
        result.UserTime = this->UserTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rusage::operator==(const T& ref) const
    {
        if (CreationTime != ref.CreationTime) return false;
        if (ExitTime != ref.ExitTime) return false;
        if (KernelTime != ref.KernelTime) return false;
        if (UserTime != ref.UserTime) return false;
        return true;
    }

    std::ostream& Rusage::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << CreationTime;
        os << " " << ExitTime;
        os << " " << KernelTime;
        os << " " << UserTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rusage& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    WaitStatus::operator T()
    {
        T result;
        result.ExitCode = this->ExitCode;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WaitStatus::operator==(const T& ref) const
    {
        if (ExitCode != ref.ExitCode) return false;
        return true;
    }

    std::ostream& WaitStatus::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ExitCode;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WaitStatus& value)
    {
        return value.PrintTo(os);
    }

    bool Exited(struct WaitStatus w)
    {
        return true;
    }

    int ExitStatus(struct WaitStatus w)
    {
        return int(w.ExitCode);
    }

    Signal Signal(struct WaitStatus w)
    {
        return - 1;
    }

    bool CoreDump(struct WaitStatus w)
    {
        return false;
    }

    bool Stopped(struct WaitStatus w)
    {
        return false;
    }

    bool Continued(struct WaitStatus w)
    {
        return false;
    }

    Signal StopSignal(struct WaitStatus w)
    {
        return - 1;
    }

    bool Signaled(struct WaitStatus w)
    {
        return false;
    }

    int TrapCause(struct WaitStatus w)
    {
        return - 1;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Timespec::operator T()
    {
        T result;
        result.Sec = this->Sec;
        result.Nsec = this->Nsec;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Timespec::operator==(const T& ref) const
    {
        if (Sec != ref.Sec) return false;
        if (Nsec != ref.Nsec) return false;
        return true;
    }

    std::ostream& Timespec::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Sec;
        os << " " << Nsec;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Timespec& value)
    {
        return value.PrintTo(os);
    }

    int64_t TimespecToNsec(Timespec ts)
    {
        return int64_t(ts.Sec) * 1e9 + int64_t(ts.Nsec);
    }

    Timespec NsecToTimespec(int64_t nsec)
    {
        Timespec ts;
        ts.Sec = nsec / 1e9;
        ts.Nsec = nsec % 1e9;
        return ts;
    }

    std::tuple<Handle, Sockaddr, std::string> Accept(Handle fd)
    {
        Handle nfd;
        Sockaddr sa;
        std::string err;
        return {0, nullptr, EWINDOWS};
    }

    std::tuple<int, Sockaddr, std::string> Recvfrom(Handle fd, gocpp::slice<unsigned char> p, int flags)
    {
        int n;
        Sockaddr from;
        std::string err;
        return {0, nullptr, EWINDOWS};
    }

    std::string Sendto(Handle fd, gocpp::slice<unsigned char> p, int flags, Sockaddr to)
    {
        std::string err;
        return EWINDOWS;
    }

    std::string SetsockoptTimeval(Handle fd, int level, int opt, Timeval* tv)
    {
        std::string err;
        return EWINDOWS;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Linger::operator T()
    {
        T result;
        result.Onoff = this->Onoff;
        result.Linger = this->Linger;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Linger::operator==(const T& ref) const
    {
        if (Onoff != ref.Onoff) return false;
        if (Linger != ref.Linger) return false;
        return true;
    }

    std::ostream& Linger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Onoff;
        os << " " << Linger;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Linger& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    sysLinger::operator T()
    {
        T result;
        result.Onoff = this->Onoff;
        result.Linger = this->Linger;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sysLinger::operator==(const T& ref) const
    {
        if (Onoff != ref.Onoff) return false;
        if (Linger != ref.Linger) return false;
        return true;
    }

    std::ostream& sysLinger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Onoff;
        os << " " << Linger;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sysLinger& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IPMreq::operator T()
    {
        T result;
        result.Multiaddr = this->Multiaddr;
        result.Interface = this->Interface;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IPMreq::operator==(const T& ref) const
    {
        if (Multiaddr != ref.Multiaddr) return false;
        if (Interface != ref.Interface) return false;
        return true;
    }

    std::ostream& IPMreq::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Multiaddr;
        os << " " << Interface;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IPMreq& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IPv6Mreq::operator T()
    {
        T result;
        result.Multiaddr = this->Multiaddr;
        result.Interface = this->Interface;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IPv6Mreq::operator==(const T& ref) const
    {
        if (Multiaddr != ref.Multiaddr) return false;
        if (Interface != ref.Interface) return false;
        return true;
    }

    std::ostream& IPv6Mreq::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Multiaddr;
        os << " " << Interface;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IPv6Mreq& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, std::string> GetsockoptInt(Handle fd, int level, int opt)
    {
        return {- 1, EWINDOWS};
    }

    std::string SetsockoptLinger(Handle fd, int level, int opt, Linger* l)
    {
        std::string err;
        auto sys = gocpp::Init<sysLinger>([](sysLinger& x) { x.Onoff = uint16_t(l->Onoff); x.Linger = uint16_t(l->Linger); });
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(& sys)), int32_t(gocpp::Sizeof<sysLinger>()));
    }

    std::string SetsockoptInet4Addr(Handle fd, int level, int opt, gocpp::array<unsigned char, 4> value)
    {
        std::string err;
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(& value[0])), 4);
    }

    std::string SetsockoptIPMreq(Handle fd, int level, int opt, IPMreq* mreq)
    {
        std::string err;
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(mreq)), int32_t(gocpp::Sizeof<IPMreq>()));
    }

    std::string SetsockoptIPv6Mreq(Handle fd, int level, int opt, IPv6Mreq* mreq)
    {
        std::string err;
        return EWINDOWS;
    }

    int Getpid()
    {
        int pid;
        return int(getCurrentProcessId());
    }

    std::tuple<Handle, std::string> FindFirstFile(uint16_t* name, Win32finddata* data)
    {
        Handle handle;
        std::string err;
        win32finddata1 data1 = {};
        std::tie(handle, err) = findFirstFile1(name, & data1);
        if(err == nullptr)
        {
            Handle handle;
            std::string err;
            copyFindData(data, & data1);
        }
        return {handle, err};
    }

    std::string FindNextFile(Handle handle, Win32finddata* data)
    {
        std::string err;
        win32finddata1 data1 = {};
        err = findNextFile1(handle, & data1);
        if(err == nullptr)
        {
            std::string err;
            copyFindData(data, & data1);
        }
        return err;
    }

    std::tuple<ProcessEntry32*, std::string> getProcessEntry(int pid)
    {
        gocpp::Defer defer;
        try
        {
            auto [snapshot, err] = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ CloseHandle(snapshot); });
            ProcessEntry32 procEntry = {};
            procEntry.Size = uint32_t(gocpp::Sizeof<ProcessEntry32>());
            if(err = Process32First(snapshot, & procEntry); err != nullptr)
            {
                return {nullptr, err};
            }
            for(; ; )
            {
                if(procEntry.ProcessID == uint32_t(pid))
                {
                    return {& procEntry, nullptr};
                }
                err = Process32Next(snapshot, & procEntry);
                if(err != nullptr)
                {
                    return {nullptr, err};
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    int Getppid()
    {
        int ppid;
        auto [pe, err] = getProcessEntry(Getpid());
        if(err != nullptr)
        {
            int ppid;
            return - 1;
        }
        return int(pe->ParentProcessID);
    }

    std::tuple<gocpp::slice<uint16_t>, std::string> fdpath(Handle fd, gocpp::slice<uint16_t> buf)
    {
        auto FILE_NAME_NORMALIZED = 0;
        auto VOLUME_NAME_DOS = 0;
        for(; ; )
        {
            auto [n, err] = getFinalPathNameByHandle(fd, & buf[0], uint32_t(len(buf)), FILE_NAME_NORMALIZED | VOLUME_NAME_DOS);
            if(err == nullptr)
            {
                buf = buf.make_slice(0, n);
                break;
            }
            if(err != _ERROR_NOT_ENOUGH_MEMORY)
            {
                return {nullptr, err};
            }
            buf = append(buf, gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n - uint32_t(len(buf))));
        }
        return {buf, nullptr};
    }

    std::string Fchdir(Handle fd)
    {
        std::string err;
        gocpp::array<uint16_t, MAX_PATH + 1> buf = {};
        auto [path, err] = fdpath(fd, buf.make_slice(0, ));
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        if(len(path) >= 4 && path[0] == '\\' && path[1] == '\\' && path[2] == '?' && path[3] == '\\')
        {
            std::string err;
            path = path.make_slice(4);
        }
        return SetCurrentDirectory(& path[0]);
    }

    std::string Link(std::string oldpath, std::string newpath)
    {
        std::string err;
        return EWINDOWS;
    }

    std::string Symlink(std::string path, std::string link)
    {
        std::string err;
        return EWINDOWS;
    }

    std::string Fchmod(Handle fd, uint32_t mode)
    {
        std::string err;
        return EWINDOWS;
    }

    std::string Chown(std::string path, int uid, int gid)
    {
        std::string err;
        return EWINDOWS;
    }

    std::string Lchown(std::string path, int uid, int gid)
    {
        std::string err;
        return EWINDOWS;
    }

    std::string Fchown(Handle fd, int uid, int gid)
    {
        std::string err;
        return EWINDOWS;
    }

    int Getuid()
    {
        int uid;
        return - 1;
    }

    int Geteuid()
    {
        int euid;
        return - 1;
    }

    int Getgid()
    {
        int gid;
        return - 1;
    }

    int Getegid()
    {
        int egid;
        return - 1;
    }

    std::tuple<gocpp::slice<int>, std::string> Getgroups()
    {
        gocpp::slice<int> gids;
        std::string err;
        return {nullptr, EWINDOWS};
    }

    void Signal(Signal s)
    {
    }

    std::string String(Signal s)
    {
        if(0 <= s && int(s) < len(signals))
        {
            auto str = signals[s];
            if(str != "")
            {
                return str;
            }
        }
        return "signal " + itoa::Itoa(int(s));
    }

    std::string LoadCreateSymbolicLink()
    {
        return Find(gocpp::recv(procCreateSymbolicLinkW));
    }

    std::tuple<int, std::string> Readlink(std::string path, gocpp::slice<unsigned char> buf)
    {
        gocpp::Defer defer;
        try
        {
            int n;
            std::string err;
            auto [fd, err] = CreateFile(StringToUTF16Ptr(path), GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, 0);
            if(err != nullptr)
            {
                int n;
                std::string err;
                return {- 1, err};
            }
            defer.push_back([=]{ CloseHandle(fd); });
            auto rdbbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
            uint32_t bytesReturned = {};
            err = DeviceIoControl(fd, FSCTL_GET_REPARSE_POINT, nullptr, 0, & rdbbuf[0], uint32_t(len(rdbbuf)), & bytesReturned, nullptr);
            if(err != nullptr)
            {
                int n;
                std::string err;
                return {- 1, err};
            }
            auto rdb = (reparseDataBuffer*)(unsafe::Pointer(& rdbbuf[0]));
            std::string s = {};
            //Go switch emulation
            {
                auto condition = rdb->ReparseTag;
                int conditionId = -1;
                if(condition == IO_REPARSE_TAG_SYMLINK) { conditionId = 0; }
                else if(condition == _IO_REPARSE_TAG_MOUNT_POINT) { conditionId = 1; }
                switch(conditionId)
                {
                    int n;
                    std::string err;
                    case 0:
                        auto data = (symbolicLinkReparseBuffer*)(unsafe::Pointer(& rdb->reparseBuffer));
                        auto p = (gocpp::array<uint16_t, 0xffff>*)(unsafe::Pointer(& data->PathBuffer[0]));
                        s = UTF16ToString(p.make_slice(data->SubstituteNameOffset / 2, (data->SubstituteNameOffset + data->SubstituteNameLength) / 2));
                        if(data->Flags & _SYMLINK_FLAG_RELATIVE == 0)
                        {
                            int n;
                            std::string err;
                            if(len(s) >= 4 && s.make_slice(0, 4) == "\\??\\")
                            {
                                int n;
                                std::string err;
                                s = s.make_slice(4);
                                //Go switch emulation
                                {
                                    int conditionId = -1;
                                    if(len(s) >= 2 && s[1] == ':') { conditionId = 0; }
                                    else if(len(s) >= 4 && s.make_slice(0, 4) == "UNC\\") { conditionId = 1; }
                                    switch(conditionId)
                                    {
                                        int n;
                                        std::string err;
                                        case 0:
                                            break;
                                        case 1:
                                            s = "\\\\" + s.make_slice(4);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                            else
                            {
                                int n;
                                std::string err;
                            }
                        }
                        break;
                    case 1:
                        auto data = (mountPointReparseBuffer*)(unsafe::Pointer(& rdb->reparseBuffer));
                        auto p = (gocpp::array<uint16_t, 0xffff>*)(unsafe::Pointer(& data->PathBuffer[0]));
                        s = UTF16ToString(p.make_slice(data->SubstituteNameOffset / 2, (data->SubstituteNameOffset + data->SubstituteNameLength) / 2));
                        if(len(s) >= 4 && s.make_slice(0, 4) == "\\??\\")
                        {
                            int n;
                            std::string err;
                            s = s.make_slice(4);
                        }
                        else
                        {
                            int n;
                            std::string err;
                        }
                        break;
                    default:
                        return {- 1, ENOENT};
                        break;
                }
            }
            n = copy(buf, gocpp::Tag<gocpp::slice<unsigned char>>()(s));
            return {n, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<Handle, std::string> CreateIoCompletionPort(Handle filehandle, Handle cphandle, uint32_t key, uint32_t threadcnt)
    {
        return createIoCompletionPort(filehandle, cphandle, uintptr_t(key), threadcnt);
    }

    std::string GetQueuedCompletionStatus(Handle cphandle, uint32_t* qty, uint32_t* key, Overlapped** overlapped, uint32_t timeout)
    {
        uintptr_t ukey = {};
        uintptr_t* pukey = {};
        if(key != nullptr)
        {
            ukey = uintptr_t(*key);
            pukey = & ukey;
        }
        auto err = getQueuedCompletionStatus(cphandle, qty, pukey, overlapped, timeout);
        if(key != nullptr)
        {
            *key = uint32_t(ukey);
            if(uintptr_t(*key) != ukey && err == nullptr)
            {
                err = errorspkg::New("GetQueuedCompletionStatus returned key overflow");
            }
        }
        return err;
    }

    std::string PostQueuedCompletionStatus(Handle cphandle, uint32_t qty, uint32_t key, Overlapped* overlapped)
    {
        return postQueuedCompletionStatus(cphandle, qty, uintptr_t(key), overlapped);
    }

    std::tuple<_PROC_THREAD_ATTRIBUTE_LIST*, std::string> newProcThreadAttributeList(uint32_t maxAttrCount)
    {
        uintptr_t size = {};
        auto err = initializeProcThreadAttributeList(nullptr, maxAttrCount, 0, & size);
        if(err != ERROR_INSUFFICIENT_BUFFER)
        {
            if(err == nullptr)
            {
                return {nullptr, errorspkg::New("unable to query buffer size from InitializeProcThreadAttributeList")};
            }
            return {nullptr, err};
        }
        auto al = (_PROC_THREAD_ATTRIBUTE_LIST*)(unsafe::Pointer(& gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size)[0]));
        err = initializeProcThreadAttributeList(al, maxAttrCount, 0, & size);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {al, nullptr};
    }

    std::string RegEnumKeyEx(Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, Filetime* lastWriteTime)
    {
        std::string regerrno;
        return regEnumKeyEx(key, index, name, nameLen, reserved, go_class, classLen, lastWriteTime);
    }

    std::string GetStartupInfo(StartupInfo* startupInfo)
    {
        getStartupInfo(startupInfo);
        return nullptr;
    }

}

