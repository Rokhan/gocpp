// generated by GoCpp from file '$(ImportDir)/slices/slices.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/slices/slices.h"
#include "gocpp/support.h"

#include "golang/cmp/cmp.h"
#include "golang/unsafe/unsafe.h"

namespace golang::slices
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace cmp::rec;
        using namespace unsafe::rec;
    }


    template<typename S, typename E>
    bool Equal(S s1, S s2)
    {
        if(len(s1) != len(s2))
        {
            return false;
        }
        for(auto [i, gocpp_ignored] : s1)
        {
            if(s1[i] != s2[i])
            {
                return false;
            }
        }
        return true;
    }


    template<typename S1, typename S2, typename E1, typename E2>
    bool EqualFunc(S1 s1, S2 s2, std::function<bool (E1, E2)> eq)
    {
        if(len(s1) != len(s2))
        {
            return false;
        }
        for(auto [i, v1] : s1)
        {
            auto v2 = s2[i];
            if(! eq(v1, v2))
            {
                return false;
            }
        }
        return true;
    }


    template<typename S, typename E>
    int Compare(S s1, S s2)
    {
        for(auto [i, v1] : s1)
        {
            if(i >= len(s2))
            {
                return + 1;
            }
            auto v2 = s2[i];
            if(auto c = cmp::Compare(v1, v2); c != 0)
            {
                return c;
            }
        }
        if(len(s1) < len(s2))
        {
            return - 1;
        }
        return 0;
    }


    template<typename S1, typename S2, typename E1, typename E2>
    int CompareFunc(S1 s1, S2 s2, std::function<int (E1, E2)> cmp)
    {
        for(auto [i, v1] : s1)
        {
            if(i >= len(s2))
            {
                return + 1;
            }
            auto v2 = s2[i];
            if(auto c = cmp(v1, v2); c != 0)
            {
                return c;
            }
        }
        if(len(s1) < len(s2))
        {
            return - 1;
        }
        return 0;
    }


    template<typename S, typename E>
    int Index(S s, E v)
    {
        for(auto [i, gocpp_ignored] : s)
        {
            if(v == s[i])
            {
                return i;
            }
        }
        return - 1;
    }


    template<typename S, typename E>
    int IndexFunc(S s, std::function<bool (E)> f)
    {
        for(auto [i, gocpp_ignored] : s)
        {
            if(f(s[i]))
            {
                return i;
            }
        }
        return - 1;
    }


    template<typename S, typename E>
    bool Contains(S s, E v)
    {
        return Index(s, v) >= 0;
    }


    template<typename S, typename E>
    bool ContainsFunc(S s, std::function<bool (E)> f)
    {
        return IndexFunc(s, f) >= 0;
    }


    template<typename S, typename E>
    S Insert(S s, int i, gocpp::slice<E> v)
    {
        _ = s.make_slice(i);
        auto m = len(v);
        if(m == 0)
        {
            return s;
        }
        auto n = len(s);
        if(i == n)
        {
            return append(s, v);
        }
        if(n + m > cap(s))
        {
            auto s2 = append(s.make_slice(0, i), gocpp::make(S, n + m - i));
            copy(s2.make_slice(i), v);
            copy(s2.make_slice(i + m), s.make_slice(i));
            return s2;
        }
        s = s.make_slice(0, n + m);
        if(! overlaps(v, s.make_slice(i + m)))
        {
            copy(s.make_slice(i + m), s.make_slice(i));
            copy(s.make_slice(i), v);
            return s;
        }
        copy(s.make_slice(n), v);
        rotateRight(s.make_slice(i), m);
        return s;
    }


    template<typename S, typename E>
    S Delete(S s, int i, int j)
    {
        _ = s.make_slice(i, j, len(s));
        if(i == j)
        {
            return s;
        }
        auto oldlen = len(s);
        s = append(s.make_slice(0, i), s.make_slice(j));
        clear(s.make_slice(len(s), oldlen));
        return s;
    }


    template<typename S, typename E>
    S DeleteFunc(S s, std::function<bool (E)> del)
    {
        auto i = IndexFunc(s, del);
        if(i == - 1)
        {
            return s;
        }
        for(auto j = i + 1; j < len(s); j++)
        {
            if(auto v = s[j]; ! del(v))
            {
                s[i] = v;
                i++;
            }
        }
        clear(s.make_slice(i));
        return s.make_slice(0, i);
    }


    template<typename S, typename E>
    S Replace(S s, int i, int j, gocpp::slice<E> v)
    {
        _ = s.make_slice(i, j);
        if(i == j)
        {
            return Insert(s, i, v);
        }
        if(j == len(s))
        {
            return append(s.make_slice(0, i), v);
        }
        auto tot = len(s.make_slice(0, i)) + len(v) + len(s.make_slice(j));
        if(tot > cap(s))
        {
            auto s2 = append(s.make_slice(0, i), gocpp::make(S, tot - i));
            copy(s2.make_slice(i), v);
            copy(s2.make_slice(i + len(v)), s.make_slice(j));
            return s2;
        }
        auto r = s.make_slice(0, tot);
        if(i + len(v) <= j)
        {
            copy(r.make_slice(i), v);
            copy(r.make_slice(i + len(v)), s.make_slice(j));
            clear(s.make_slice(tot));
            return r;
        }
        if(! overlaps(r.make_slice(i + len(v)), v))
        {
            copy(r.make_slice(i + len(v)), s.make_slice(j));
            copy(r.make_slice(i), v);
            return r;
        }
        auto y = len(v) - (j - i);
        if(! overlaps(r.make_slice(i, j), v))
        {
            copy(r.make_slice(i, j), v.make_slice(y));
            copy(r.make_slice(len(s)), v.make_slice(0, y));
            rotateRight(r.make_slice(i), y);
            return r;
        }
        if(! overlaps(r.make_slice(len(s)), v))
        {
            copy(r.make_slice(len(s)), v.make_slice(0, y));
            copy(r.make_slice(i, j), v.make_slice(y));
            rotateRight(r.make_slice(i), y);
            return r;
        }
        auto k = startIdx(v, s.make_slice(j));
        copy(r.make_slice(i), v);
        copy(r.make_slice(i + len(v)), r.make_slice(i + k));
        return r;
    }


    template<typename S, typename E>
    S Clone(S s)
    {
        return append(s.make_slice(, 0, 0), s);
    }


    template<typename S, typename E>
    S Compact(S s)
    {
        if(len(s) < 2)
        {
            return s;
        }
        auto i = 1;
        for(auto k = 1; k < len(s); k++)
        {
            if(s[k] != s[k - 1])
            {
                if(i != k)
                {
                    s[i] = s[k];
                }
                i++;
            }
        }
        clear(s.make_slice(i));
        return s.make_slice(0, i);
    }


    template<typename S, typename E>
    S CompactFunc(S s, std::function<bool (E, E)> eq)
    {
        if(len(s) < 2)
        {
            return s;
        }
        auto i = 1;
        for(auto k = 1; k < len(s); k++)
        {
            if(! eq(s[k], s[k - 1]))
            {
                if(i != k)
                {
                    s[i] = s[k];
                }
                i++;
            }
        }
        clear(s.make_slice(i));
        return s.make_slice(0, i);
    }


    template<typename S, typename E>
    S Grow(S s, int n)
    {
        if(n < 0)
        {
            gocpp::panic("cannot be negative");
        }
        if(n -= cap(s) - len(s); n > 0)
        {
            s = append(s.make_slice(0, cap(s)), gocpp::make(gocpp::Tag<gocpp::slice<E>>(), n)).make_slice(0, len(s));
        }
        return s;
    }


    template<typename S, typename E>
    S Clip(S s)
    {
        return s.make_slice(, len(s), len(s));
    }


    template<typename E>
    void rotateLeft(gocpp::slice<E> s, int r)
    {
        for(; r != 0 && r != len(s); )
        {
            if(r * 2 <= len(s))
            {
                swap(s.make_slice(0, r), s.make_slice(len(s) - r));
                s = s.make_slice(0, len(s) - r);
            }
            else
            {
                swap(s.make_slice(0, len(s) - r), s.make_slice(r));
                std::tie(s, r) = std::tuple{s.make_slice(len(s) - r), r * 2 - len(s)};
            }
        }
    }


    template<typename E>
    void rotateRight(gocpp::slice<E> s, int r)
    {
        rotateLeft(s, len(s) - r);
    }


    template<typename E>
    void swap(gocpp::slice<E> x, gocpp::slice<E> y)
    {
        for(auto i = 0; i < len(x); i++)
        {
            std::tie(x[i], y[i]) = std::tuple{y[i], x[i]};
        }
    }


    template<typename E>
    bool overlaps(gocpp::slice<E> a, gocpp::slice<E> b)
    {
        if(len(a) == 0 || len(b) == 0)
        {
            return false;
        }
        auto elemSize = gocpp::Sizeof<E>();
        if(elemSize == 0)
        {
            return false;
        }
        return uintptr_t(unsafe::Pointer(& a[0])) <= uintptr_t(unsafe::Pointer(& b[len(b) - 1])) + (elemSize - 1) && uintptr_t(unsafe::Pointer(& b[0])) <= uintptr_t(unsafe::Pointer(& a[len(a) - 1])) + (elemSize - 1);
    }


    template<typename E>
    int startIdx(gocpp::slice<E> haystack, gocpp::slice<E> needle)
    {
        auto p = & needle[0];
        for(auto [i, gocpp_ignored] : haystack)
        {
            if(p == & haystack[i])
            {
                return i;
            }
        }
        gocpp::panic("needle not found");
    }


    template<typename S, typename E>
    void Reverse(S s)
    {
        for(auto [i, j] = std::tuple{0, len(s) - 1}; i < j; std::tie(i, j) = std::tuple{i + 1, j - 1})
        {
            std::tie(s[i], s[j]) = std::tuple{s[j], s[i]};
        }
    }


    template<typename S, typename E>
    S Concat(gocpp::slice<S> slices)
    {
        auto size = 0;
        for(auto [gocpp_ignored, s] : slices)
        {
            size += len(s);
            if(size < 0)
            {
                gocpp::panic("len out of range");
            }
        }
        auto newslice = Grow<S>(nullptr, size);
        for(auto [gocpp_ignored, s] : slices)
        {
            newslice = append(newslice, s);
        }
        return newslice;
    }

}

