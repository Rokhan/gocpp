// generated by GoCpp from file '$(ImportDir)/image/geom.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/geom.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/math/bits/bits.h"
#include "golang/strconv/itoa.h"

namespace golang::image
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Point::operator T()
    {
        T result;
        result.X = this->X;
        result.Y = this->Y;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Point::operator==(const T& ref) const
    {
        if (X != ref.X) return false;
        if (Y != ref.Y) return false;
        return true;
    }

    std::ostream& Point::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << X;
        os << " " << Y;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Point& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::String(struct Point p)
    {
        return "(" + strconv::Itoa(p.X) + "," + strconv::Itoa(p.Y) + ")";
    }

    struct Point rec::Add(struct Point p, struct Point q)
    {
        return Point {p.X + q.X, p.Y + q.Y};
    }

    struct Point rec::Sub(struct Point p, struct Point q)
    {
        return Point {p.X - q.X, p.Y - q.Y};
    }

    struct Point rec::Mul(struct Point p, int k)
    {
        return Point {p.X * k, p.Y * k};
    }

    struct Point rec::Div(struct Point p, int k)
    {
        return Point {p.X / k, p.Y / k};
    }

    bool rec::In(struct Point p, struct Rectangle r)
    {
        return r.Min.X <= p.X && p.X < r.Max.X && r.Min.Y <= p.Y && p.Y < r.Max.Y;
    }

    struct Point rec::Mod(struct Point p, struct Rectangle r)
    {
        auto [w, h] = std::tuple{rec::Dx(gocpp::recv(r)), rec::Dy(gocpp::recv(r))};
        p = rec::Sub(gocpp::recv(p), r.Min);
        p.X = p.X % w;
        if(p.X < 0)
        {
            p.X += w;
        }
        p.Y = p.Y % h;
        if(p.Y < 0)
        {
            p.Y += h;
        }
        return rec::Add(gocpp::recv(p), r.Min);
    }

    bool rec::Eq(struct Point p, struct Point q)
    {
        return p == q;
    }

    Point ZP;
    struct Point Pt(int X, int Y)
    {
        return Point {X, Y};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Rectangle::operator T()
    {
        T result;
        result.Min = this->Min;
        result.Max = this->Max;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rectangle::operator==(const T& ref) const
    {
        if (Min != ref.Min) return false;
        if (Max != ref.Max) return false;
        return true;
    }

    std::ostream& Rectangle::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Min;
        os << " " << Max;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rectangle& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::String(struct Rectangle r)
    {
        return rec::String(gocpp::recv(r.Min)) + "-" + rec::String(gocpp::recv(r.Max));
    }

    int rec::Dx(struct Rectangle r)
    {
        return r.Max.X - r.Min.X;
    }

    int rec::Dy(struct Rectangle r)
    {
        return r.Max.Y - r.Min.Y;
    }

    struct Point rec::Size(struct Rectangle r)
    {
        return Point {r.Max.X - r.Min.X, r.Max.Y - r.Min.Y};
    }

    struct Rectangle rec::Add(struct Rectangle r, struct Point p)
    {
        return Rectangle {Point {r.Min.X + p.X, r.Min.Y + p.Y}, Point {r.Max.X + p.X, r.Max.Y + p.Y}};
    }

    struct Rectangle rec::Sub(struct Rectangle r, struct Point p)
    {
        return Rectangle {Point {r.Min.X - p.X, r.Min.Y - p.Y}, Point {r.Max.X - p.X, r.Max.Y - p.Y}};
    }

    struct Rectangle rec::Inset(struct Rectangle r, int n)
    {
        if(rec::Dx(gocpp::recv(r)) < 2 * n)
        {
            r.Min.X = (r.Min.X + r.Max.X) / 2;
            r.Max.X = r.Min.X;
        }
        else
        {
            r.Min.X += n;
            r.Max.X -= n;
        }
        if(rec::Dy(gocpp::recv(r)) < 2 * n)
        {
            r.Min.Y = (r.Min.Y + r.Max.Y) / 2;
            r.Max.Y = r.Min.Y;
        }
        else
        {
            r.Min.Y += n;
            r.Max.Y -= n;
        }
        return r;
    }

    struct Rectangle rec::Intersect(struct Rectangle r, struct Rectangle s)
    {
        if(r.Min.X < s.Min.X)
        {
            r.Min.X = s.Min.X;
        }
        if(r.Min.Y < s.Min.Y)
        {
            r.Min.Y = s.Min.Y;
        }
        if(r.Max.X > s.Max.X)
        {
            r.Max.X = s.Max.X;
        }
        if(r.Max.Y > s.Max.Y)
        {
            r.Max.Y = s.Max.Y;
        }
        if(rec::Empty(gocpp::recv(r)))
        {
            return ZR;
        }
        return r;
    }

    struct Rectangle rec::Union(struct Rectangle r, struct Rectangle s)
    {
        if(rec::Empty(gocpp::recv(r)))
        {
            return s;
        }
        if(rec::Empty(gocpp::recv(s)))
        {
            return r;
        }
        if(r.Min.X > s.Min.X)
        {
            r.Min.X = s.Min.X;
        }
        if(r.Min.Y > s.Min.Y)
        {
            r.Min.Y = s.Min.Y;
        }
        if(r.Max.X < s.Max.X)
        {
            r.Max.X = s.Max.X;
        }
        if(r.Max.Y < s.Max.Y)
        {
            r.Max.Y = s.Max.Y;
        }
        return r;
    }

    bool rec::Empty(struct Rectangle r)
    {
        return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y;
    }

    bool rec::Eq(struct Rectangle r, struct Rectangle s)
    {
        return r == s || rec::Empty(gocpp::recv(r)) && rec::Empty(gocpp::recv(s));
    }

    bool rec::Overlaps(struct Rectangle r, struct Rectangle s)
    {
        return ! rec::Empty(gocpp::recv(r)) && ! rec::Empty(gocpp::recv(s)) && r.Min.X < s.Max.X && s.Min.X < r.Max.X && r.Min.Y < s.Max.Y && s.Min.Y < r.Max.Y;
    }

    bool rec::In(struct Rectangle r, struct Rectangle s)
    {
        if(rec::Empty(gocpp::recv(r)))
        {
            return true;
        }
        return s.Min.X <= r.Min.X && r.Max.X <= s.Max.X && s.Min.Y <= r.Min.Y && r.Max.Y <= s.Max.Y;
    }

    struct Rectangle rec::Canon(struct Rectangle r)
    {
        if(r.Max.X < r.Min.X)
        {
            std::tie(r.Min.X, r.Max.X) = std::tuple{r.Max.X, r.Min.X};
        }
        if(r.Max.Y < r.Min.Y)
        {
            std::tie(r.Min.Y, r.Max.Y) = std::tuple{r.Max.Y, r.Min.Y};
        }
        return r;
    }

    color::Color rec::At(struct Rectangle r, int x, int y)
    {
        if(rec::In(gocpp::recv((Point {x, y})), r))
        {
            return color::Opaque;
        }
        return color::Transparent;
    }

    color::RGBA64 rec::RGBA64At(struct Rectangle r, int x, int y)
    {
        if(rec::In(gocpp::recv((Point {x, y})), r))
        {
            return color::RGBA64 {0xffff, 0xffff, 0xffff, 0xffff};
        }
        return color::RGBA64 {};
    }

    struct Rectangle rec::Bounds(struct Rectangle r)
    {
        return r;
    }

    color::Model rec::ColorModel(struct Rectangle r)
    {
        return color::Alpha16Model;
    }

    Rectangle ZR;
    struct Rectangle Rect(int x0, int y0, int x1, int y1)
    {
        if(x0 > x1)
        {
            std::tie(x0, x1) = std::tuple{x1, x0};
        }
        if(y0 > y1)
        {
            std::tie(y0, y1) = std::tuple{y1, y0};
        }
        return Rectangle {Point {x0, y0}, Point {x1, y1}};
    }

    int mul3NonNeg(int x, int y, int z)
    {
        if((x < 0) || (y < 0) || (z < 0))
        {
            return - 1;
        }
        auto [hi, lo] = bits::Mul64(uint64_t(x), uint64_t(y));
        if(hi != 0)
        {
            return - 1;
        }
        std::tie(hi, lo) = bits::Mul64(lo, uint64_t(z));
        if(hi != 0)
        {
            return - 1;
        }
        auto a = int(lo);
        if((a < 0) || (uint64_t(a) != lo))
        {
            return - 1;
        }
        return a;
    }

    int add2NonNeg(int x, int y)
    {
        if((x < 0) || (y < 0))
        {
            return - 1;
        }
        auto a = x + y;
        if(a < 0)
        {
            return - 1;
        }
        return a;
    }

}

