// generated by GoCpp from file '$(ImportDir)/syscall/exec_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/exec_windows.h"
#include "gocpp/support.h"

#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/runtime/mfinal.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/rwmutex.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unicode/utf16/utf16.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    sync::RWMutex ForkLock;
    std::string EscapeArg(std::string s)
    {
        if(len(s) == 0)
        {
            return """";
        }
        for(auto i = 0; i < len(s); i++)
        {
            //Go switch emulation
            {
                auto condition = s[i];
                int conditionId = -1;
                if(condition == '"') { conditionId = 0; }
                else if(condition == '\\') { conditionId = 1; }
                else if(condition == ' ') { conditionId = 2; }
                else if(condition == '\t') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(s) + 2);
                        b = appendEscapeArg(b, s);
                        return std::string(b);
                        break;
                }
            }
        }
        return s;
    }

    gocpp::slice<unsigned char> appendEscapeArg(gocpp::slice<unsigned char> b, std::string s)
    {
        if(len(s) == 0)
        {
            return append(b, """");
        }
        auto needsBackslash = false;
        auto hasSpace = false;
        for(auto i = 0; i < len(s); i++)
        {
            //Go switch emulation
            {
                auto condition = s[i];
                int conditionId = -1;
                if(condition == '"') { conditionId = 0; }
                else if(condition == '\\') { conditionId = 1; }
                else if(condition == ' ') { conditionId = 2; }
                else if(condition == '\t') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        needsBackslash = true;
                        break;
                    case 2:
                    case 3:
                        hasSpace = true;
                        break;
                }
            }
        }
        if(! needsBackslash && ! hasSpace)
        {
            return append(b, s);
        }
        if(! needsBackslash)
        {
            b = append(b, '"');
            b = append(b, s);
            return append(b, '"');
        }
        if(hasSpace)
        {
            b = append(b, '"');
        }
        auto slashes = 0;
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            //Go switch emulation
            {
                auto condition = c;
                int conditionId = -1;
                if(condition == '\\') { conditionId = 0; }
                else if(condition == '"') { conditionId = 1; }
                switch(conditionId)
                {
                    default:
                        slashes = 0;
                        break;
                    case 0:
                        slashes++;
                        break;
                    case 1:
                        for(; slashes > 0; slashes--)
                        {
                            b = append(b, '\\');
                        }
                        b = append(b, '\\');
                        break;
                }
            }
            b = append(b, c);
        }
        if(hasSpace)
        {
            for(; slashes > 0; slashes--)
            {
                b = append(b, '\\');
            }
            b = append(b, '"');
        }
        return b;
    }

    std::string makeCmdLine(gocpp::slice<std::string> args)
    {
        gocpp::slice<unsigned char> b = {};
        for(auto [gocpp_ignored, v] : args)
        {
            if(len(b) > 0)
            {
                b = append(b, ' ');
            }
            b = appendEscapeArg(b, v);
        }
        return std::string(b);
    }

    std::tuple<gocpp::slice<uint16_t>, struct gocpp::error> createEnvBlock(gocpp::slice<std::string> envv)
    {
        if(len(envv) == 0)
        {
            return {utf16::Encode(gocpp::Tag<gocpp::slice<gocpp::rune>>()("\x00\x00")), nullptr};
        }
        int length = {};
        for(auto [gocpp_ignored, s] : envv)
        {
            if(bytealg::IndexByteString(s, 0) != - 1)
            {
                return {nullptr, go_EINVAL};
            }
            length += len(s) + 1;
        }
        length += 1;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 0, length);
        for(auto [gocpp_ignored, s] : envv)
        {
            for(auto [gocpp_ignored, c] : s)
            {
                b = utf16::AppendRune(b, c);
            }
            b = utf16::AppendRune(b, 0);
        }
        b = utf16::AppendRune(b, 0);
        return {b, nullptr};
    }

    void CloseOnExec(golang::syscall::Handle fd)
    {
        SetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0);
    }

    struct gocpp::error SetNonblock(golang::syscall::Handle fd, bool nonblocking)
    {
        struct gocpp::error err;
        return nullptr;
    }

    std::tuple<std::string, struct gocpp::error> FullPath(std::string name)
    {
        std::string path;
        struct gocpp::error err;
        auto [p, err] = UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return {"", err};
        }
        auto n = uint32_t(100);
        for(; ; )
        {
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            std::tie(n, err) = GetFullPathName(p, uint32_t(len(buf)), & buf[0], nullptr);
            if(err != nullptr)
            {
                return {"", err};
            }
            if(n <= uint32_t(len(buf)))
            {
                return {UTF16ToString(buf.make_slice(0, n)), nullptr};
            }
        }
    }

    bool isSlash(uint8_t c)
    {
        return c == '\\' || c == '/';
    }

    std::tuple<std::string, struct gocpp::error> normalizeDir(std::string dir)
    {
        std::string name;
        struct gocpp::error err;
        auto [ndir, err] = FullPath(dir);
        if(err != nullptr)
        {
            return {"", err};
        }
        if(len(ndir) > 2 && isSlash(ndir[0]) && isSlash(ndir[1]))
        {
            return {"", go_EINVAL};
        }
        return {ndir, nullptr};
    }

    int volToUpper(int ch)
    {
        if('a' <= ch && ch <= 'z')
        {
            ch += 'A' - 'a';
        }
        return ch;
    }

    std::tuple<std::string, struct gocpp::error> joinExeDirAndFName(std::string dir, std::string p)
    {
        std::string name;
        struct gocpp::error err;
        if(len(p) == 0)
        {
            return {"", go_EINVAL};
        }
        if(len(p) > 2 && isSlash(p[0]) && isSlash(p[1]))
        {
            return {p, nullptr};
        }
        if(len(p) > 1 && p[1] == ':')
        {
            if(len(p) == 2)
            {
                return {"", go_EINVAL};
            }
            if(isSlash(p[2]))
            {
                return {p, nullptr};
            }
            else
            {
                auto [d, err] = normalizeDir(dir);
                if(err != nullptr)
                {
                    return {"", err};
                }
                if(volToUpper(int(p[0])) == volToUpper(int(d[0])))
                {
                    return FullPath(d + "\\" + p.make_slice(2));
                }
                else
                {
                    return FullPath(p);
                }
            }
        }
        else
        {
            auto [d, err] = normalizeDir(dir);
            if(err != nullptr)
            {
                return {"", err};
            }
            if(isSlash(p[0]))
            {
                return FullPath(d.make_slice(0, 2) + p);
            }
            else
            {
                return FullPath(d + "\\" + p);
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ProcAttr::operator T()
    {
        T result;
        result.Dir = this->Dir;
        result.Env = this->Env;
        result.Files = this->Files;
        result.Sys = this->Sys;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ProcAttr::operator==(const T& ref) const
    {
        if (Dir != ref.Dir) return false;
        if (Env != ref.Env) return false;
        if (Files != ref.Files) return false;
        if (Sys != ref.Sys) return false;
        return true;
    }

    std::ostream& ProcAttr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Dir;
        os << " " << Env;
        os << " " << Files;
        os << " " << Sys;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ProcAttr& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SysProcAttr::operator T()
    {
        T result;
        result.HideWindow = this->HideWindow;
        result.CmdLine = this->CmdLine;
        result.CreationFlags = this->CreationFlags;
        result.Token = this->Token;
        result.ProcessAttributes = this->ProcessAttributes;
        result.ThreadAttributes = this->ThreadAttributes;
        result.NoInheritHandles = this->NoInheritHandles;
        result.AdditionalInheritedHandles = this->AdditionalInheritedHandles;
        result.ParentProcess = this->ParentProcess;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SysProcAttr::operator==(const T& ref) const
    {
        if (HideWindow != ref.HideWindow) return false;
        if (CmdLine != ref.CmdLine) return false;
        if (CreationFlags != ref.CreationFlags) return false;
        if (Token != ref.Token) return false;
        if (ProcessAttributes != ref.ProcessAttributes) return false;
        if (ThreadAttributes != ref.ThreadAttributes) return false;
        if (NoInheritHandles != ref.NoInheritHandles) return false;
        if (AdditionalInheritedHandles != ref.AdditionalInheritedHandles) return false;
        if (ParentProcess != ref.ParentProcess) return false;
        return true;
    }

    std::ostream& SysProcAttr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << HideWindow;
        os << " " << CmdLine;
        os << " " << CreationFlags;
        os << " " << Token;
        os << " " << ProcessAttributes;
        os << " " << ThreadAttributes;
        os << " " << NoInheritHandles;
        os << " " << AdditionalInheritedHandles;
        os << " " << ParentProcess;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SysProcAttr& value)
    {
        return value.PrintTo(os);
    }

    ProcAttr zeroProcAttr;
    SysProcAttr zeroSysProcAttr;
    std::tuple<int, uintptr_t, struct gocpp::error> StartProcess(std::string argv0, gocpp::slice<std::string> argv, struct ProcAttr* attr)
    {
        gocpp::Defer defer;
        try
        {
            int pid;
            uintptr_t handle;
            struct gocpp::error err;
            if(len(argv0) == 0)
            {
                return {0, 0, go_EWINDOWS};
            }
            if(attr == nullptr)
            {
                attr = & zeroProcAttr;
            }
            auto sys = attr->Sys;
            if(sys == nullptr)
            {
                sys = & zeroSysProcAttr;
            }
            if(len(attr->Files) > 3)
            {
                return {0, 0, go_EWINDOWS};
            }
            if(len(attr->Files) < 3)
            {
                return {0, 0, go_EINVAL};
            }
            if(len(attr->Dir) != 0)
            {
                gocpp::error err = {};
                std::tie(argv0, err) = joinExeDirAndFName(attr->Dir, argv0);
                if(err != nullptr)
                {
                    return {0, 0, err};
                }
            }
            auto [argv0p, err] = UTF16PtrFromString(argv0);
            if(err != nullptr)
            {
                return {0, 0, err};
            }
            std::string cmdline = {};
            if(sys->CmdLine != "")
            {
                cmdline = sys->CmdLine;
            }
            else
            {
                cmdline = makeCmdLine(argv);
            }
            uint16_t* argvp = {};
            if(len(cmdline) != 0)
            {
                std::tie(argvp, err) = UTF16PtrFromString(cmdline);
                if(err != nullptr)
                {
                    return {0, 0, err};
                }
            }
            uint16_t* dirp = {};
            if(len(attr->Dir) != 0)
            {
                std::tie(dirp, err) = UTF16PtrFromString(attr->Dir);
                if(err != nullptr)
                {
                    return {0, 0, err};
                }
            }
            auto [p, gocpp_id_1] = GetCurrentProcess();
            auto parentProcess = p;
            if(sys->ParentProcess != 0)
            {
                parentProcess = sys->ParentProcess;
            }
            auto fd = gocpp::make(gocpp::Tag<gocpp::slice<syscall::Handle>>(), len(attr->Files));
            for(auto [i, gocpp_ignored] : attr->Files)
            {
                if(attr->Files[i] > 0)
                {
                    auto err = DuplicateHandle(p, Handle(attr->Files[i]), parentProcess, & fd[i], 0, true, DUPLICATE_SAME_ACCESS);
                    if(err != nullptr)
                    {
                        return {0, 0, err};
                    }
                    defer.push_back([=]{ DuplicateHandle(parentProcess, fd[i], 0, nullptr, 0, false, DUPLICATE_CLOSE_SOURCE); });
                }
            }
            auto si = new(_STARTUPINFOEXW);
            std::tie(si->ProcThreadAttributeList, err) = newProcThreadAttributeList(2);
            if(err != nullptr)
            {
                return {0, 0, err};
            }
            defer.push_back([=]{ deleteProcThreadAttributeList(si->ProcThreadAttributeList); });
            si->Cb = uint32_t(gocpp::Sizeof<_STARTUPINFOEXW>());
            si->Flags = STARTF_USESTDHANDLES;
            if(sys->HideWindow)
            {
                si->Flags |= STARTF_USESHOWWINDOW;
                si->ShowWindow = SW_HIDE;
            }
            if(sys->ParentProcess != 0)
            {
                err = updateProcThreadAttribute(si->ProcThreadAttributeList, 0, _PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, unsafe::Pointer(& sys->ParentProcess), gocpp::Sizeof<Handle>(), nullptr, nullptr);
                if(err != nullptr)
                {
                    return {0, 0, err};
                }
            }
            si->StdInput = fd[0];
            si->StdOutput = fd[1];
            si->StdErr = fd[2];
            fd = append(fd, sys->AdditionalInheritedHandles);
            auto j = 0;
            for(auto [i, gocpp_ignored] : fd)
            {
                if(fd[i] != 0)
                {
                    fd[j] = fd[i];
                    j++;
                }
            }
            fd = fd.make_slice(0, j);
            auto willInheritHandles = len(fd) > 0 && ! sys->NoInheritHandles;
            if(willInheritHandles)
            {
                err = updateProcThreadAttribute(si->ProcThreadAttributeList, 0, _PROC_THREAD_ATTRIBUTE_HANDLE_LIST, unsafe::Pointer(& fd[0]), uintptr_t(len(fd)) * gocpp::Sizeof<Handle>(), nullptr, nullptr);
                if(err != nullptr)
                {
                    return {0, 0, err};
                }
            }
            gocpp::slice<uint16_t> envBlock;
            std::tie(envBlock, err) = createEnvBlock(attr->Env);
            if(err != nullptr)
            {
                return {0, 0, err};
            }
            auto pi = new(ProcessInformation);
            auto flags = sys->CreationFlags | CREATE_UNICODE_ENVIRONMENT | _EXTENDED_STARTUPINFO_PRESENT;
            if(sys->Token != 0)
            {
                err = CreateProcessAsUser(sys->Token, argv0p, argvp, sys->ProcessAttributes, sys->ThreadAttributes, willInheritHandles, flags, & envBlock[0], dirp, & si->StartupInfo, pi);
            }
            else
            {
                err = CreateProcess(argv0p, argvp, sys->ProcessAttributes, sys->ThreadAttributes, willInheritHandles, flags, & envBlock[0], dirp, & si->StartupInfo, pi);
            }
            if(err != nullptr)
            {
                return {0, 0, err};
            }
            defer.push_back([=]{ CloseHandle(Handle(pi->Thread)); });
            runtime::KeepAlive(fd);
            runtime::KeepAlive(sys);
            return {int(pi->ProcessId), uintptr_t(pi->Process), nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error Exec(std::string argv0, gocpp::slice<std::string> argv, gocpp::slice<std::string> envv)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

}

