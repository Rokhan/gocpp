// generated by GoCpp from file '$(ImportDir)/os/path_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/path_windows.h"
#include "gocpp/support.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // IsPathSeparator reports whether c is a directory separator character.
    bool IsPathSeparator(uint8_t c)
    {
        return c == '\\' || c == '/';
    }

    // basename removes trailing slashes and the leading
    // directory name and drive letter from path name.
    std::string basename(std::string name)
    {
        if(len(name) == 2 && name[1] == ':')
        {
            name = "."s;
        }
        else
        if(len(name) > 2 && name[1] == ':')
        {
            name = name.make_slice(2);
        }
        auto i = len(name) - 1;
        for(; i > 0 && (name[i] == '/' || name[i] == '\\'); i--)
        {
            name = name.make_slice(0, i);
        }
        for(i--; i >= 0; i--)
        {
            if(name[i] == '/' || name[i] == '\\')
            {
                name = name.make_slice(i + 1);
                break;
            }
        }
        return name;
    }

    bool isAbs(std::string path)
    {
        bool b;
        auto v = volumeName(path);
        if(v == ""s)
        {
            return false;
        }
        path = path.make_slice(len(v));
        if(path == ""s)
        {
            return false;
        }
        return IsPathSeparator(path[0]);
    }

    std::string volumeName(std::string path)
    {
        std::string v;
        if(len(path) < 2)
        {
            return ""s;
        }
        auto c = path[0];
        if(path[1] == ':' && ('0' <= c && c <= '9' || 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'))
        {
            return path.make_slice(0, 2);
        }
        if(auto l = len(path); l >= 5 && IsPathSeparator(path[0]) && IsPathSeparator(path[1]) && ! IsPathSeparator(path[2]) && path[2] != '.')
        {
            for(auto n = 3; n < l - 1; n++)
            {
                if(IsPathSeparator(path[n]))
                {
                    n++;
                    if(! IsPathSeparator(path[n]))
                    {
                        if(path[n] == '.')
                        {
                            break;
                        }
                        for(; n < l; n++)
                        {
                            if(IsPathSeparator(path[n]))
                            {
                                break;
                            }
                        }
                        return path.make_slice(0, n);
                    }
                    break;
                }
            }
        }
        return ""s;
    }

    std::string fromSlash(std::string path)
    {
        // Replace each '/' with '\\' if present
        gocpp::slice<unsigned char> pathbuf = {};
        int lastSlash = {};
        for(auto [i, b] : path)
        {
            if(b == '/')
            {
                if(pathbuf == nullptr)
                {
                    pathbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(path));
                }
                copy(pathbuf.make_slice(lastSlash), path.make_slice(lastSlash, i));
                pathbuf[i] = '\\';
                lastSlash = i + 1;
            }
        }
        if(pathbuf == nullptr)
        {
            return path;
        }
        copy(pathbuf.make_slice(lastSlash), path.make_slice(lastSlash));
        return std::string(pathbuf);
    }

    std::string dirname(std::string path)
    {
        auto vol = volumeName(path);
        auto i = len(path) - 1;
        for(; i >= len(vol) && ! IsPathSeparator(path[i]); )
        {
            i--;
        }
        auto dir = path.make_slice(len(vol), i + 1);
        auto last = len(dir) - 1;
        if(last > 0 && IsPathSeparator(dir[last]))
        {
            dir = dir.make_slice(0, last);
        }
        if(dir == ""s)
        {
            dir = "."s;
        }
        return vol + dir;
    }

    // This is set via go:linkname on runtime.canUseLongPaths, and is true when the OS
    // supports opting into proper long path handling without the need for fixups.
    bool canUseLongPaths;
    // fixLongPath returns the extended-length (\\?\-prefixed) form of
    // path when needed, in order to avoid the default 260 character file
    // path limit imposed by Windows. If path is not easily converted to
    // the extended-length form (for example, if path is a relative path
    // or contains .. elements), or is short enough, fixLongPath returns
    // path unmodified.
    //
    // See https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
    std::string fixLongPath(std::string path)
    {
        if(canUseLongPaths)
        {
            return path;
        }
        if(len(path) < 248)
        {
            return path;
        }
        if(len(path) >= 2 && path.make_slice(0, 2) == "\\\\"s)
        {
            return path;
        }
        if(! isAbs(path))
        {
            return path;
        }
        auto prefix = "\\\\?"s;
        auto pathbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(prefix) + len(path) + len("\\"s));
        copy(pathbuf, prefix);
        auto n = len(path);
        auto [r, w] = std::tuple{0, len(prefix)};
        for(; r < n; )
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if(IsPathSeparator(path[r])) { conditionId = 0; }
                else if(path[r] == '.' && (r + 1 == n || IsPathSeparator(path[r + 1]))) { conditionId = 1; }
                else if(r + 1 < n && path[r] == '.' && path[r + 1] == '.' && (r + 2 == n || IsPathSeparator(path[r + 2]))) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        r++;
                        break;
                    case 1:
                        r++;
                        break;
                    case 2:
                        return path;
                        break;
                    default:
                        pathbuf[w] = '\\';
                        w++;
                        for(; r < n && ! IsPathSeparator(path[r]); r++)
                        {
                            pathbuf[w] = path[r];
                            w++;
                        }
                        break;
                }
            }
        }
        if(w == len("\\\\?\\c:"s))
        {
            pathbuf[w] = '\\';
            w++;
        }
        return std::string(pathbuf.make_slice(0, w));
    }

}

