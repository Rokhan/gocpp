// generated by GoCpp from file '$(ImportDir)/runtime/error.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/error.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"

namespace golang::runtime
{
    struct Error : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        Error(){}
        Error(Error& i) = default;
        Error(const Error& i) = default;
        Error& operator=(Error& i) = default;
        Error& operator=(const Error& i) = default;

        template<typename T>
        Error(T& ref);

        template<typename T>
        Error(const T& ref);

        template<typename T>
        Error(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IError
        {
            virtual void vRuntimeError() = 0;
            virtual void* getPtr() = 0;
        };

        template<typename T, typename StoreT>
        struct ErrorImpl : IError
        {
            explicit ErrorImpl(T* ptr)
            {
                value.reset(ptr);
            }

            void vRuntimeError() override;

            void* getPtr() override
            {
                return value.get();
            }

            StoreT value;
        };

        std::shared_ptr<IError> value;
    };

    namespace rec
    {
        void RuntimeError(const gocpp::PtrRecv<struct Error, false>& self);
        void RuntimeError(const gocpp::ObjRecv<struct Error>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct Error& value);
    struct TypeAssertionError
    {
        golang::runtime::_type* _interface;
        golang::runtime::_type* concrete;
        golang::runtime::_type* asserted;
        gocpp::string missingMethod;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct TypeAssertionError& value);
    gocpp::slice<unsigned char> itoa(gocpp::slice<unsigned char> buf, uint64_t val);
    struct errorAddressString
    {
        gocpp::string msg;
        uintptr_t addr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct errorAddressString& value);
    struct boundsError
    {
        int64_t x;
        int y;
        bool go_signed;
        golang::runtime::boundsErrorCode code;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct boundsError& value);
    extern gocpp::array<gocpp::string, 9> boundsErrorFmts;
    extern gocpp::array<gocpp::string, 8> boundsNegErrorFmts;
    gocpp::slice<unsigned char> appendIntStr(gocpp::slice<unsigned char> b, int64_t v, bool go_signed);
    struct stringer : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        stringer(){}
        stringer(stringer& i) = default;
        stringer(const stringer& i) = default;
        stringer& operator=(stringer& i) = default;
        stringer& operator=(const stringer& i) = default;

        template<typename T>
        stringer(T& ref);

        template<typename T>
        stringer(const T& ref);

        template<typename T>
        stringer(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Istringer
        {
            virtual gocpp::string vString() = 0;
            virtual void* getPtr() = 0;
        };

        template<typename T, typename StoreT>
        struct stringerImpl : Istringer
        {
            explicit stringerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            gocpp::string vString() override;

            void* getPtr() override
            {
                return value.get();
            }

            StoreT value;
        };

        std::shared_ptr<Istringer> value;
    };

    namespace rec
    {
        gocpp::string String(const gocpp::PtrRecv<struct stringer, false>& self);
        gocpp::string String(const gocpp::ObjRecv<struct stringer>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct stringer& value);
    void printany(go_any i);
    void printanycustomtype(go_any i);
    void panicwrap();

    namespace rec
    {
        void RuntimeError(golang::runtime::TypeAssertionError*);
        gocpp::string Error(golang::runtime::TypeAssertionError* e);
        void RuntimeError(golang::runtime::errorString e);
        gocpp::string Error(golang::runtime::errorString e);
        void RuntimeError(golang::runtime::errorAddressString e);
        gocpp::string Error(golang::runtime::errorAddressString e);
        uintptr_t Addr(golang::runtime::errorAddressString e);
        void RuntimeError(golang::runtime::plainError e);
        gocpp::string Error(golang::runtime::plainError e);
        void RuntimeError(golang::runtime::boundsError e);
        gocpp::string Error(golang::runtime::boundsError e);
    }
}

