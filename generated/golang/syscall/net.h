// generated by GoCpp from file '$(ImportDir)/syscall/net.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/net.fwd.h"
#include "gocpp/support.h"

namespace golang::syscall
{
    struct RawConn : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        RawConn(){}
        RawConn(RawConn& i) = default;
        RawConn(const RawConn& i) = default;
        RawConn& operator=(RawConn& i) = default;
        RawConn& operator=(const RawConn& i) = default;

        template<typename T>
        RawConn(T& ref);

        template<typename T>
        RawConn(const T& ref);

        template<typename T>
        RawConn(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IRawConn
        {
            virtual struct gocpp::error vControl(std::function<void (uintptr_t fd)> f) = 0;
            virtual struct gocpp::error vRead(std::function<bool (uintptr_t fd)> f) = 0;
            virtual struct gocpp::error vWrite(std::function<bool (uintptr_t fd)> f) = 0;
        };

        template<typename T, typename StoreT>
        struct RawConnImpl : IRawConn
        {
            explicit RawConnImpl(T* ptr)
            {
                value.reset(ptr);
            }

            struct gocpp::error vControl(std::function<void (uintptr_t fd)> f) override;

            struct gocpp::error vRead(std::function<bool (uintptr_t fd)> f) override;

            struct gocpp::error vWrite(std::function<bool (uintptr_t fd)> f) override;

            StoreT value;
        };

        std::shared_ptr<IRawConn> value;
    };

    namespace rec
    {
        struct gocpp::error Control(const gocpp::PtrRecv<struct RawConn, false>& self, std::function<void (uintptr_t fd)> f);
        struct gocpp::error Control(const gocpp::ObjRecv<struct RawConn>& self, std::function<void (uintptr_t fd)> f);

        struct gocpp::error Read(const gocpp::PtrRecv<struct RawConn, false>& self, std::function<bool (uintptr_t fd)> f);
        struct gocpp::error Read(const gocpp::ObjRecv<struct RawConn>& self, std::function<bool (uintptr_t fd)> f);

        struct gocpp::error Write(const gocpp::PtrRecv<struct RawConn, false>& self, std::function<bool (uintptr_t fd)> f);
        struct gocpp::error Write(const gocpp::ObjRecv<struct RawConn>& self, std::function<bool (uintptr_t fd)> f);
    }

    std::ostream& operator<<(std::ostream& os, const struct RawConn& value);
    struct Conn : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        Conn(){}
        Conn(Conn& i) = default;
        Conn(const Conn& i) = default;
        Conn& operator=(Conn& i) = default;
        Conn& operator=(const Conn& i) = default;

        template<typename T>
        Conn(T& ref);

        template<typename T>
        Conn(const T& ref);

        template<typename T>
        Conn(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IConn
        {
            virtual std::tuple<struct RawConn, struct gocpp::error> vSyscallConn() = 0;
        };

        template<typename T, typename StoreT>
        struct ConnImpl : IConn
        {
            explicit ConnImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<struct RawConn, struct gocpp::error> vSyscallConn() override;

            StoreT value;
        };

        std::shared_ptr<IConn> value;
    };

    namespace rec
    {
        std::tuple<struct RawConn, struct gocpp::error> SyscallConn(const gocpp::PtrRecv<struct Conn, false>& self);
        std::tuple<struct RawConn, struct gocpp::error> SyscallConn(const gocpp::ObjRecv<struct Conn>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct Conn& value);

    namespace rec
    {
    }
}

