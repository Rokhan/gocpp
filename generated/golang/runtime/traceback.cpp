// generated by GoCpp from file '$(ImportDir)/runtime/traceback.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/traceback.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
// #include "golang/runtime/alg.h"  [Ignored, known errors]
#include "golang/runtime/asan0.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/msan0.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/symtabinl.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace bytealg::rec;
        using namespace chacha8rand::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    unwinder::operator T()
    {
        T result;
        result.frame = this->frame;
        result.g = this->g;
        result.cgoCtxt = this->cgoCtxt;
        result.calleeFuncID = this->calleeFuncID;
        result.flags = this->flags;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool unwinder::operator==(const T& ref) const
    {
        if (frame != ref.frame) return false;
        if (g != ref.g) return false;
        if (cgoCtxt != ref.cgoCtxt) return false;
        if (calleeFuncID != ref.calleeFuncID) return false;
        if (flags != ref.flags) return false;
        return true;
    }

    std::ostream& unwinder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << frame;
        os << " " << g;
        os << " " << cgoCtxt;
        os << " " << calleeFuncID;
        os << " " << flags;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct unwinder& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct unwinder* u, struct g* gp, golang::runtime::unwindFlags flags)
    {
        rec::initAt(gocpp::recv(u), ~ uintptr_t(0), ~ uintptr_t(0), ~ uintptr_t(0), gp, flags);
    }

    void rec::initAt(struct unwinder* u, uintptr_t pc0, uintptr_t sp0, uintptr_t lr0, struct g* gp, golang::runtime::unwindFlags flags)
    {
        if(auto ourg = getg(); ourg == gp && ourg == ourg->m->curg)
        {
            go_throw("cannot trace user goroutine on its own stack");
        }
        if(pc0 == ~ uintptr_t(0) && sp0 == ~ uintptr_t(0))
        {
            if(gp->syscallsp != 0)
            {
                pc0 = gp->syscallpc;
                sp0 = gp->syscallsp;
                if(usesLR)
                {
                    lr0 = 0;
                }
            }
            else
            {
                pc0 = gp->sched.pc;
                sp0 = gp->sched.sp;
                if(usesLR)
                {
                    lr0 = gp->sched.lr;
                }
            }
        }
        stkframe frame = {};
        frame.pc = pc0;
        frame.sp = sp0;
        if(usesLR)
        {
            frame.lr = lr0;
        }
        if(frame.pc == 0)
        {
            if(usesLR)
            {
                frame.pc = *(uintptr_t*)(unsafe::Pointer(frame.sp));
                frame.lr = 0;
            }
            else
            {
                frame.pc = *(uintptr_t*)(unsafe::Pointer(frame.sp));
                frame.sp += goarch::PtrSize;
            }
        }
        if(GOARCH == "arm" && goarm < 7 && GOOS == "linux" && frame.pc & 0xffff0000 == 0xffff0000)
        {
            frame.pc = frame.lr;
            frame.lr = 0;
        }
        auto f = findfunc(frame.pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            if(flags & unwindSilentErrors == 0)
            {
                print("runtime: g ", gp->goid, " gp=", gp, ": unknown pc ", hex(frame.pc), "\n");
                tracebackHexdump(gp->stack, & frame, 0);
            }
            if(flags & (unwindPrintErrors | unwindSilentErrors) == 0)
            {
                go_throw("unknown pc");
            }
            *u = unwinder {};
            return;
        }
        frame.fn = f;
        *u = gocpp::Init<unwinder>([](unwinder& x) { x.frame = frame; x.g = rec::guintptr(gocpp::recv(gp)); x.cgoCtxt = len(gp->cgoCtxt) - 1; x.calleeFuncID = abi::FuncIDNormal; x.flags = flags; });
        auto isSyscall = frame.pc == pc0 && frame.sp == sp0 && pc0 == gp->syscallpc && sp0 == gp->syscallsp;
        rec::resolveInternal(gocpp::recv(u), true, isSyscall);
    }

    bool rec::valid(struct unwinder* u)
    {
        return u->frame.pc != 0;
    }

    void rec::resolveInternal(struct unwinder* u, bool innermost, bool isSyscall)
    {
        auto frame = & u->frame;
        auto gp = rec::ptr(gocpp::recv(u->g));
        auto f = frame->fn;
        if(f.pcsp == 0)
        {
            rec::finishInternal(gocpp::recv(u));
            return;
        }
        auto flag = f.flag;
        if(f.funcID == abi::FuncID_cgocallback)
        {
            flag &^= abi::FuncFlagSPWrite;
        }
        if(isSyscall)
        {
            flag &^= abi::FuncFlagSPWrite;
        }
        if(frame->fp == 0)
        {
            if(u->flags & unwindJumpStack != 0 && gp == gp->m->g0 && gp->m->curg != nullptr && gp->m->curg->m == gp->m)
            {
                //Go switch emulation
                {
                    auto condition = f.funcID;
                    int conditionId = -1;
                    if(condition == abi::FuncID_morestack) { conditionId = 0; }
                    else if(condition == abi::FuncID_systemstack) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                            gp = gp->m->curg;
                            rec::set(gocpp::recv(u->g), gp);
                            frame->pc = gp->sched.pc;
                            frame->fn = findfunc(frame->pc);
                            f = frame->fn;
                            flag = f.flag;
                            frame->lr = gp->sched.lr;
                            frame->sp = gp->sched.sp;
                            u->cgoCtxt = len(gp->cgoCtxt) - 1;
                            break;
                        case 1:
                            if(usesLR && funcspdelta(f, frame->pc) == 0)
                            {
                                flag &^= abi::FuncFlagSPWrite;
                                break;
                            }
                            gp = gp->m->curg;
                            rec::set(gocpp::recv(u->g), gp);
                            frame->sp = gp->sched.sp;
                            u->cgoCtxt = len(gp->cgoCtxt) - 1;
                            flag &^= abi::FuncFlagSPWrite;
                            break;
                    }
                }
            }
            frame->fp = frame->sp + uintptr_t(funcspdelta(f, frame->pc));
            if(! usesLR)
            {
                frame->fp += goarch::PtrSize;
            }
        }
        if(flag & abi::FuncFlagTopFrame != 0)
        {
            frame->lr = 0;
        }
        else
        if(flag & abi::FuncFlagSPWrite != 0 && (! innermost || u->flags & (unwindPrintErrors | unwindSilentErrors) != 0))
        {
            if(u->flags & (unwindPrintErrors | unwindSilentErrors) == 0 && ! innermost)
            {
                println("traceback: unexpected SPWRITE function", funcname(f));
                go_throw("traceback");
            }
            frame->lr = 0;
        }
        else
        {
            uintptr_t lrPtr = {};
            if(usesLR)
            {
                if(innermost && frame->sp < frame->fp || frame->lr == 0)
                {
                    lrPtr = frame->sp;
                    frame->lr = *(uintptr_t*)(unsafe::Pointer(lrPtr));
                }
            }
            else
            {
                if(frame->lr == 0)
                {
                    lrPtr = frame->fp - goarch::PtrSize;
                    frame->lr = *(uintptr_t*)(unsafe::Pointer(lrPtr));
                }
            }
        }
        frame->varp = frame->fp;
        if(! usesLR)
        {
            frame->varp -= goarch::PtrSize;
        }
        if(frame->varp > frame->sp && framepointer_enabled)
        {
            frame->varp -= goarch::PtrSize;
        }
        frame->argp = frame->fp + sys::MinFrameSize;
        frame->continpc = frame->pc;
        if(u->calleeFuncID == abi::FuncID_sigpanic)
        {
            if(frame->fn.deferreturn != 0)
            {
                frame->continpc = rec::entry(gocpp::recv(frame->fn)) + uintptr_t(frame->fn.deferreturn) + 1;
            }
            else
            {
                frame->continpc = 0;
            }
        }
    }

    void rec::next(struct unwinder* u)
    {
        auto frame = & u->frame;
        auto f = frame->fn;
        auto gp = rec::ptr(gocpp::recv(u->g));
        if(frame->lr == 0)
        {
            rec::finishInternal(gocpp::recv(u));
            return;
        }
        auto flr = findfunc(frame->lr);
        if(! rec::valid(gocpp::recv(flr)))
        {
            auto fail = u->flags & (unwindPrintErrors | unwindSilentErrors) == 0;
            auto doPrint = u->flags & unwindSilentErrors == 0;
            if(doPrint && gp->m->incgo && f.funcID == abi::FuncID_sigpanic)
            {
                doPrint = false;
            }
            if(fail || doPrint)
            {
                print("runtime: g ", gp->goid, ": unexpected return pc for ", funcname(f), " called from ", hex(frame->lr), "\n");
                tracebackHexdump(gp->stack, frame, 0);
            }
            if(fail)
            {
                go_throw("unknown caller pc");
            }
            frame->lr = 0;
            rec::finishInternal(gocpp::recv(u));
            return;
        }
        if(frame->pc == frame->lr && frame->sp == frame->fp)
        {
            print("runtime: traceback stuck. pc=", hex(frame->pc), " sp=", hex(frame->sp), "\n");
            tracebackHexdump(gp->stack, frame, frame->sp);
            go_throw("traceback stuck");
        }
        auto injectedCall = f.funcID == abi::FuncID_sigpanic || f.funcID == abi::FuncID_asyncPreempt || f.funcID == abi::FuncID_debugCallV2;
        if(injectedCall)
        {
            u->flags |= unwindTrap;
        }
        else
        {
            u->flags &^= unwindTrap;
        }
        u->calleeFuncID = f.funcID;
        frame->fn = flr;
        frame->pc = frame->lr;
        frame->lr = 0;
        frame->sp = frame->fp;
        frame->fp = 0;
        if(usesLR && injectedCall)
        {
            auto x = *(uintptr_t*)(unsafe::Pointer(frame->sp));
            frame->sp += alignUp(sys::MinFrameSize, sys::StackAlign);
            f = findfunc(frame->pc);
            frame->fn = f;
            if(! rec::valid(gocpp::recv(f)))
            {
                frame->pc = x;
            }
            else
            if(funcspdelta(f, frame->pc) == 0)
            {
                frame->lr = x;
            }
        }
        rec::resolveInternal(gocpp::recv(u), false, false);
    }

    void rec::finishInternal(struct unwinder* u)
    {
        u->frame.pc = 0;
        auto gp = rec::ptr(gocpp::recv(u->g));
        if(u->flags & (unwindPrintErrors | unwindSilentErrors) == 0 && u->frame.sp != gp->stktopsp)
        {
            print("runtime: g", gp->goid, ": frame.sp=", hex(u->frame.sp), " top=", hex(gp->stktopsp), "\n");
            print("\tstack=[", hex(gp->stack.lo), "-", hex(gp->stack.hi), "\n");
            go_throw("traceback did not unwind completely");
        }
    }

    uintptr_t rec::symPC(struct unwinder* u)
    {
        if(u->flags & unwindTrap == 0 && u->frame.pc > rec::entry(gocpp::recv(u->frame.fn)))
        {
            return u->frame.pc - 1;
        }
        return u->frame.pc;
    }

    int rec::cgoCallers(struct unwinder* u, gocpp::slice<uintptr_t> pcBuf)
    {
        if(cgoTraceback == nullptr || u->frame.fn.funcID != abi::FuncID_cgocallback || u->cgoCtxt < 0)
        {
            return 0;
        }
        auto ctxt = rec::ptr(gocpp::recv(u->g))->cgoCtxt[u->cgoCtxt];
        u->cgoCtxt--;
        cgoContextPCs(ctxt, pcBuf);
        for(auto [i, pc] : pcBuf)
        {
            if(pc == 0)
            {
                return i;
            }
        }
        return len(pcBuf);
    }

    int tracebackPCs(struct unwinder* u, int skip, gocpp::slice<uintptr_t> pcBuf)
    {
        gocpp::array<uintptr_t, 32> cgoBuf = {};
        auto n = 0;
        for(; n < len(pcBuf) && rec::valid(gocpp::recv(u)); rec::next(gocpp::recv(u)))
        {
            auto f = u->frame.fn;
            auto cgoN = rec::cgoCallers(gocpp::recv(u), cgoBuf.make_slice(0, ));
            for(auto [iu, uf] = newInlineUnwinder(f, rec::symPC(gocpp::recv(u))); n < len(pcBuf) && rec::valid(gocpp::recv(uf)); uf = rec::next(gocpp::recv(iu), uf))
            {
                auto sf = rec::srcFunc(gocpp::recv(iu), uf);
                if(sf.funcID == abi::FuncIDWrapper && elideWrapperCalling(u->calleeFuncID))
                {
                }
                else
                if(skip > 0)
                {
                    skip--;
                }
                else
                {
                    pcBuf[n] = uf.pc + 1;
                    n++;
                }
                u->calleeFuncID = sf.funcID;
            }
            if(skip == 0)
            {
                n += copy(pcBuf.make_slice(n), cgoBuf.make_slice(0, cgoN));
            }
        }
        return n;
    }

    void printArgs(struct funcInfo f, unsafe::Pointer argp, uintptr_t pc)
    {
        auto _endSeq = 0xff;
        auto _startAgg = 0xfe;
        auto _endAgg = 0xfd;
        auto _dotdotdot = 0xfc;
        auto _offsetTooLarge = 0xfb;
        auto limit = 10;
        auto maxDepth = 5;
        auto maxLen = (maxDepth * 3 + 2) * limit + 1;
        auto p = (gocpp::array<uint8_t, maxLen>*)(funcdata(f, abi::FUNCDATA_ArgInfo));
        if(p == nullptr)
        {
            return;
        }
        auto liveInfo = funcdata(f, abi::FUNCDATA_ArgLiveInfo);
        auto liveIdx = pcdatavalue(f, abi::PCDATA_ArgLiveIndex, pc);
        auto startOffset = uint8_t(0xff);
        if(liveInfo != nullptr)
        {
            startOffset = *(uint8_t*)(liveInfo);
        }
        auto isLive = [=](uint8_t off, uint8_t slotIdx) mutable -> bool
        {
            if(liveInfo == nullptr || liveIdx <= 0)
            {
                return true;
            }
            if(off < startOffset)
            {
                return true;
            }
            auto bits = *(uint8_t*)(add(liveInfo, uintptr_t(liveIdx) + uintptr_t(slotIdx / 8)));
            return bits & (1 << (slotIdx % 8)) != 0;
        };
        auto print1 = [=](uint8_t off, uint8_t sz, uint8_t slotIdx) mutable -> void
        {
            auto x = readUnaligned64(add(argp, uintptr_t(off)));
            if(sz < 8)
            {
                auto shift = 64 - sz * 8;
                if(goarch::BigEndian)
                {
                    x = x >> shift;
                }
                else
                {
                    x = (x << shift) >> shift;
                }
            }
            print(hex(x));
            if(! isLive(off, slotIdx))
            {
                print("?");
            }
        };
        auto start = true;
        auto printcomma = [=]() mutable -> void
        {
            if(! start)
            {
                print(", ");
            }
        };
        auto pi = 0;
        auto slotIdx = uint8_t(0);
        printloop:
        for(; ; )
        {
            auto o = p[pi];
            pi++;
            //Go switch emulation
            {
                auto condition = o;
                int conditionId = -1;
                if(condition == _endSeq) { conditionId = 0; }
                else if(condition == _startAgg) { conditionId = 1; }
                else if(condition == _endAgg) { conditionId = 2; }
                else if(condition == _dotdotdot) { conditionId = 3; }
                else if(condition == _offsetTooLarge) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                        goto printloop_break;
                        break;
                    case 1:
                        printcomma();
                        print("{");
                        start = true;
                        continue;
                        break;
                    case 2:
                        print("}");
                        break;
                    case 3:
                        printcomma();
                        print("...");
                        break;
                    case 4:
                        printcomma();
                        print("_");
                        break;
                    default:
                        printcomma();
                        auto sz = p[pi];
                        pi++;
                        print1(o, sz, slotIdx);
                        if(o >= startOffset)
                        {
                            slotIdx++;
                        }
                        break;
                }
            }
            start = false;
            if(false) {
            printloop_continue:
                continue;
            printloop_break:
                break;
            }
        }
    }

    std::tuple<std::string, std::string, std::string> funcNamePiecesForPrint(std::string name)
    {
        auto i = bytealg::IndexByteString(name, '[');
        if(i < 0)
        {
            return {name, "", ""};
        }
        auto j = len(name) - 1;
        for(; name[j] != ']'; )
        {
            j--;
        }
        if(j <= i)
        {
            return {name, "", ""};
        }
        return {name.make_slice(0, i), "[...]", name.make_slice(j + 1)};
    }

    std::string funcNameForPrint(std::string name)
    {
        auto [a, b, c] = funcNamePiecesForPrint(name);
        return a + b + c;
    }

    void printFuncName(std::string name)
    {
        if(name == "runtime.gopanic")
        {
            print("panic");
            return;
        }
        auto [a, b, c] = funcNamePiecesForPrint(name);
        print(a, b, c);
    }

    void printcreatedby(struct g* gp)
    {
        auto pc = gp->gopc;
        auto f = findfunc(pc);
        if(rec::valid(gocpp::recv(f)) && showframe(rec::srcFunc(gocpp::recv(f)), gp, false, abi::FuncIDNormal) && gp->goid != 1)
        {
            printcreatedby1(f, pc, gp->parentGoid);
        }
    }

    void printcreatedby1(struct funcInfo f, uintptr_t pc, uint64_t goid)
    {
        print("created by ");
        printFuncName(funcname(f));
        if(goid != 0)
        {
            print(" in goroutine ", goid);
        }
        print("\n");
        auto tracepc = pc;
        if(pc > rec::entry(gocpp::recv(f)))
        {
            tracepc -= sys::PCQuantum;
        }
        auto [file, line] = funcline(f, tracepc);
        print("\t", file, ":", line);
        if(pc > rec::entry(gocpp::recv(f)))
        {
            print(" +", hex(pc - rec::entry(gocpp::recv(f))));
        }
        print("\n");
    }

    void traceback(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp)
    {
        traceback1(pc, sp, lr, gp, 0);
    }

    void tracebacktrap(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp)
    {
        if(gp->m->libcallsp != 0)
        {
            traceback1(gp->m->libcallpc, gp->m->libcallsp, 0, rec::ptr(gocpp::recv(gp->m->libcallg)), 0);
            return;
        }
        traceback1(pc, sp, lr, gp, unwindTrap);
    }

    void traceback1(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp, golang::runtime::unwindFlags flags)
    {
        if(iscgo && gp->m != nullptr && gp->m->ncgo > 0 && gp->syscallsp != 0 && gp->m->cgoCallers != nullptr && gp->m->cgoCallers[0] != 0)
        {
            rec::Store(gocpp::recv(gp->m->cgoCallersUse), 1);
            auto cgoCallers = *gp->m->cgoCallers;
            gp->m->cgoCallers[0] = 0;
            rec::Store(gocpp::recv(gp->m->cgoCallersUse), 0);
            printCgoTraceback(& cgoCallers);
        }
        if(readgstatus(gp) &^ _Gscan == _Gsyscall)
        {
            pc = gp->syscallpc;
            sp = gp->syscallsp;
            flags &^= unwindTrap;
        }
        if(gp->m != nullptr && gp->m->vdsoSP != 0)
        {
            pc = gp->m->vdsoPC;
            sp = gp->m->vdsoSP;
            flags &^= unwindTrap;
        }
        flags |= unwindPrintErrors;
        unwinder u = {};
        auto tracebackWithRuntime = [=](bool showRuntime) mutable -> int
        {
            int maxInt = 0x7fffffff;
            rec::initAt(gocpp::recv(u), pc, sp, lr, gp, flags);
            auto [n, lastN] = traceback2(& u, showRuntime, 0, tracebackInnerFrames);
            if(n < tracebackInnerFrames)
            {
                return n;
            }
            auto u2 = u;
            auto [remaining, gocpp_id_1] = traceback2(& u, showRuntime, maxInt, 0);
            auto elide = remaining - lastN - tracebackOuterFrames;
            if(elide > 0)
            {
                print("...", elide, " frames elided...\n");
                traceback2(& u2, showRuntime, lastN + elide, tracebackOuterFrames);
            }
            else
            if(elide <= 0)
            {
                traceback2(& u2, showRuntime, lastN, tracebackOuterFrames);
            }
            return n;
        };
        if(tracebackWithRuntime(false) == 0)
        {
            tracebackWithRuntime(true);
        }
        printcreatedby(gp);
        if(gp->ancestors == nullptr)
        {
            return;
        }
        for(auto [gocpp_ignored, ancestor] : *gp->ancestors)
        {
            printAncestorTraceback(ancestor);
        }
    }

    std::tuple<int, int> traceback2(struct unwinder* u, bool showRuntime, int skip, int max)
    {
        int n;
        int lastN;
        auto commitFrame = [=]() mutable -> std::tuple<bool, bool>
        {
            bool pr;
            bool stop;
            if(skip == 0 && max == 0)
            {
                bool pr;
                bool stop;
                return {false, true};
            }
            n++;
            lastN++;
            if(skip > 0)
            {
                bool pr;
                bool stop;
                skip--;
                return {false, false};
            }
            max--;
            return {true, false};
        };
        auto gp = rec::ptr(gocpp::recv(u->g));
        auto [level, gocpp_id_4, gocpp_id_5] = gotraceback();
        gocpp::array<uintptr_t, 32> cgoBuf = {};
        for(; rec::valid(gocpp::recv(u)); rec::next(gocpp::recv(u)))
        {
            int n;
            int lastN;
            lastN = 0;
            auto f = u->frame.fn;
            for(auto [iu, uf] = newInlineUnwinder(f, rec::symPC(gocpp::recv(u))); rec::valid(gocpp::recv(uf)); uf = rec::next(gocpp::recv(iu), uf))
            {
                int n;
                int lastN;
                auto sf = rec::srcFunc(gocpp::recv(iu), uf);
                auto callee = u->calleeFuncID;
                u->calleeFuncID = sf.funcID;
                if(! (showRuntime || showframe(sf, gp, n == 0, callee)))
                {
                    int n;
                    int lastN;
                    continue;
                }
                if(auto [pr, stop] = commitFrame(); stop)
                {
                    int n;
                    int lastN;
                    return {n, lastN};
                }
                else
                if(! pr)
                {
                    int n;
                    int lastN;
                    continue;
                }
                auto name = rec::name(gocpp::recv(sf));
                auto [file, line] = rec::fileLine(gocpp::recv(iu), uf);
                printFuncName(name);
                print("(");
                if(rec::isInlined(gocpp::recv(iu), uf))
                {
                    int n;
                    int lastN;
                    print("...");
                }
                else
                {
                    int n;
                    int lastN;
                    auto argp = unsafe::Pointer(u->frame.argp);
                    printArgs(f, argp, rec::symPC(gocpp::recv(u)));
                }
                print(")\n");
                print("\t", file, ":", line);
                if(! rec::isInlined(gocpp::recv(iu), uf))
                {
                    int n;
                    int lastN;
                    if(u->frame.pc > rec::entry(gocpp::recv(f)))
                    {
                        int n;
                        int lastN;
                        print(" +", hex(u->frame.pc - rec::entry(gocpp::recv(f))));
                    }
                    if(gp->m != nullptr && gp->m->throwing >= throwTypeRuntime && gp == gp->m->curg || level >= 2)
                    {
                        int n;
                        int lastN;
                        print(" fp=", hex(u->frame.fp), " sp=", hex(u->frame.sp), " pc=", hex(u->frame.pc));
                    }
                }
                print("\n");
            }
            if(auto cgoN = rec::cgoCallers(gocpp::recv(u), cgoBuf.make_slice(0, )); cgoN > 0)
            {
                int n;
                int lastN;
                cgoSymbolizerArg arg = {};
                auto anySymbolized = false;
                auto stop = false;
                for(auto [gocpp_ignored, pc] : cgoBuf.make_slice(0, cgoN))
                {
                    int n;
                    int lastN;
                    if(cgoSymbolizer == nullptr)
                    {
                        int n;
                        int lastN;
                        if(auto [pr, stop] = commitFrame(); stop)
                        {
                            int n;
                            int lastN;
                            break;
                        }
                        else
                        if(pr)
                        {
                            int n;
                            int lastN;
                            print("non-Go function at pc=", hex(pc), "\n");
                        }
                    }
                    else
                    {
                        int n;
                        int lastN;
                        stop = printOneCgoTraceback(pc, commitFrame, & arg);
                        anySymbolized = true;
                        if(stop)
                        {
                            int n;
                            int lastN;
                            break;
                        }
                    }
                }
                if(anySymbolized)
                {
                    int n;
                    int lastN;
                    arg.pc = 0;
                    callCgoSymbolizer(& arg);
                }
                if(stop)
                {
                    int n;
                    int lastN;
                    return {n, lastN};
                }
            }
        }
        return {n, 0};
    }

    void printAncestorTraceback(struct ancestorInfo ancestor)
    {
        print("[originating from goroutine ", ancestor.goid, "]:\n");
        for(auto [fidx, pc] : ancestor.pcs)
        {
            auto f = findfunc(pc);
            if(showfuncinfo(rec::srcFunc(gocpp::recv(f)), fidx == 0, abi::FuncIDNormal))
            {
                printAncestorTracebackFuncInfo(f, pc);
            }
        }
        if(len(ancestor.pcs) == tracebackInnerFrames)
        {
            print("...additional frames elided...\n");
        }
        auto f = findfunc(ancestor.gopc);
        if(rec::valid(gocpp::recv(f)) && showfuncinfo(rec::srcFunc(gocpp::recv(f)), false, abi::FuncIDNormal) && ancestor.goid != 1)
        {
            printcreatedby1(f, ancestor.gopc, 0);
        }
    }

    void printAncestorTracebackFuncInfo(struct funcInfo f, uintptr_t pc)
    {
        auto [u, uf] = newInlineUnwinder(f, pc);
        auto [file, line] = rec::fileLine(gocpp::recv(u), uf);
        printFuncName(rec::name(gocpp::recv(rec::srcFunc(gocpp::recv(u), uf))));
        print("(...)\n");
        print("\t", file, ":", line);
        if(pc > rec::entry(gocpp::recv(f)))
        {
            print(" +", hex(pc - rec::entry(gocpp::recv(f))));
        }
        print("\n");
    }

    int callers(int skip, gocpp::slice<uintptr_t> pcbuf)
    {
        auto sp = getcallersp();
        auto pc = getcallerpc();
        auto gp = getg();
        int n = {};
        systemstack([=]() mutable -> void
        {
            unwinder u = {};
            rec::initAt(gocpp::recv(u), pc, sp, 0, gp, unwindSilentErrors);
            n = tracebackPCs(& u, skip, pcbuf);
        });
        return n;
    }

    int gcallers(struct g* gp, int skip, gocpp::slice<uintptr_t> pcbuf)
    {
        unwinder u = {};
        rec::init(gocpp::recv(u), gp, unwindSilentErrors);
        return tracebackPCs(& u, skip, pcbuf);
    }

    bool showframe(struct srcFunc sf, struct g* gp, bool firstFrame, abi::FuncID calleeID)
    {
        auto mp = getg()->m;
        if(mp->throwing >= throwTypeRuntime && gp != nullptr && (gp == mp->curg || gp == rec::ptr(gocpp::recv(mp->caughtsig))))
        {
            return true;
        }
        return showfuncinfo(sf, firstFrame, calleeID);
    }

    bool showfuncinfo(struct srcFunc sf, bool firstFrame, abi::FuncID calleeID)
    {
        auto [level, gocpp_id_8, gocpp_id_9] = gotraceback();
        if(level > 1)
        {
            return true;
        }
        if(sf.funcID == abi::FuncIDWrapper && elideWrapperCalling(calleeID))
        {
            return false;
        }
        auto name = rec::name(gocpp::recv(sf));
        if(name == "runtime.gopanic" && ! firstFrame)
        {
            return true;
        }
        return bytealg::IndexByteString(name, '.') >= 0 && (! hasPrefix(name, "runtime.") || isExportedRuntime(name));
    }

    bool isExportedRuntime(std::string name)
    {
        auto n = len("runtime.");
        return len(name) > n && name.make_slice(0, n) == "runtime." && 'A' <= name[n] && name[n] <= 'Z';
    }

    bool elideWrapperCalling(abi::FuncID id)
    {
        return ! (id == abi::FuncID_gopanic || id == abi::FuncID_sigpanic || id == abi::FuncID_panicwrap);
    }

    gocpp::array_base<std::string> gStatusStrings = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x._Gidle = "idle"; x._Grunnable = "runnable"; x._Grunning = "running"; x._Gsyscall = "syscall"; x._Gwaiting = "waiting"; x._Gdead = "dead"; x._Gcopystack = "copystack"; x._Gpreempted = "preempted"; });
    void goroutineheader(struct g* gp)
    {
        auto [level, gocpp_id_12, gocpp_id_13] = gotraceback();
        auto gpstatus = readgstatus(gp);
        auto isScan = gpstatus & _Gscan != 0;
        gpstatus &^= _Gscan;
        std::string status = {};
        if(0 <= gpstatus && gpstatus < uint32_t(len(gStatusStrings)))
        {
            status = gStatusStrings[gpstatus];
        }
        else
        {
            status = "???";
        }
        if(gpstatus == _Gwaiting && gp->waitreason != waitReasonZero)
        {
            status = rec::String(gocpp::recv(gp->waitreason));
        }
        int64_t waitfor = {};
        if((gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp->waitsince != 0)
        {
            waitfor = (nanotime() - gp->waitsince) / 60e9;
        }
        print("goroutine ", gp->goid);
        if(gp->m != nullptr && gp->m->throwing >= throwTypeRuntime && gp == gp->m->curg || level >= 2)
        {
            print(" gp=", gp);
            if(gp->m != nullptr)
            {
                print(" m=", gp->m->id, " mp=", gp->m);
            }
            else
            {
                print(" m=nil");
            }
        }
        print(" [", status);
        if(isScan)
        {
            print(" (scan)");
        }
        if(waitfor >= 1)
        {
            print(", ", waitfor, " minutes");
        }
        if(gp->lockedm != 0)
        {
            print(", locked to thread");
        }
        print("]:\n");
    }

    void tracebackothers(struct g* me)
    {
        auto [level, gocpp_id_16, gocpp_id_17] = gotraceback();
        auto curgp = getg()->m->curg;
        if(curgp != nullptr && curgp != me)
        {
            print("\n");
            goroutineheader(curgp);
            traceback(~ uintptr_t(0), ~ uintptr_t(0), 0, curgp);
        }
        forEachGRace([=](struct g* gp) mutable -> void
        {
            if(gp == me || gp == curgp || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2)
            {
                return;
            }
            print("\n");
            goroutineheader(gp);
            if(gp->m != getg()->m && readgstatus(gp) &^ _Gscan == _Grunning)
            {
                print("\tgoroutine running on other thread; stack unavailable\n");
                printcreatedby(gp);
            }
            else
            {
                traceback(~ uintptr_t(0), ~ uintptr_t(0), 0, gp);
            }
        });
    }

    void tracebackHexdump(struct stack stk, struct stkframe* frame, uintptr_t bad)
    {
        auto expand = 32 * goarch::PtrSize;
        auto maxExpand = 256 * goarch::PtrSize;
        auto [lo, hi] = std::tuple{frame->sp, frame->sp};
        if(frame->fp != 0 && frame->fp < lo)
        {
            lo = frame->fp;
        }
        if(frame->fp != 0 && frame->fp > hi)
        {
            hi = frame->fp;
        }
        std::tie(lo, hi) = std::tuple{lo - expand, hi + expand};
        if(lo < frame->sp - maxExpand)
        {
            lo = frame->sp - maxExpand;
        }
        if(hi > frame->sp + maxExpand)
        {
            hi = frame->sp + maxExpand;
        }
        if(lo < stk.lo)
        {
            lo = stk.lo;
        }
        if(hi > stk.hi)
        {
            hi = stk.hi;
        }
        print("stack: frame={sp:", hex(frame->sp), ", fp:", hex(frame->fp), "} stack=[", hex(stk.lo), ",", hex(stk.hi), ")\n");
        hexdumpWords(lo, hi, [=](uintptr_t p) mutable -> unsigned char
        {
            //Go switch emulation
            {
                auto condition = p;
                int conditionId = -1;
                if(condition == frame->fp) { conditionId = 0; }
                else if(condition == frame->sp) { conditionId = 1; }
                else if(condition == bad) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        return '>';
                        break;
                    case 1:
                        return '<';
                        break;
                    case 2:
                        return '!';
                        break;
                }
            }
            return 0;
        });
    }

    bool isSystemGoroutine(struct g* gp, bool fixed)
    {
        auto f = findfunc(gp->startpc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return false;
        }
        if(f.funcID == abi::FuncID_runtime_main || f.funcID == abi::FuncID_corostart || f.funcID == abi::FuncID_handleAsyncEvent)
        {
            return false;
        }
        if(f.funcID == abi::FuncID_runfinq)
        {
            if(fixed)
            {
                return false;
            }
            return rec::Load(gocpp::recv(fingStatus)) & fingRunningFinalizer == 0;
        }
        return hasPrefix(funcname(f), "runtime.");
    }

    void SetCgoTraceback(int version, unsafe::Pointer traceback, unsafe::Pointer context, unsafe::Pointer symbolizer)
    {
        if(version != 0)
        {
            gocpp::panic("unsupported version");
        }
        if(cgoTraceback != nullptr && cgoTraceback != traceback || cgoContext != nullptr && cgoContext != context || cgoSymbolizer != nullptr && cgoSymbolizer != symbolizer)
        {
            gocpp::panic("call SetCgoTraceback only once");
        }
        cgoTraceback = traceback;
        cgoContext = context;
        cgoSymbolizer = symbolizer;
        if(_cgo_set_context_function != nullptr)
        {
            cgocall(_cgo_set_context_function, context);
        }
    }

    unsafe::Pointer cgoTraceback;
    unsafe::Pointer cgoContext;
    unsafe::Pointer cgoSymbolizer;
    
    template<typename T> requires gocpp::GoStruct<T>
    cgoTracebackArg::operator T()
    {
        T result;
        result.context = this->context;
        result.sigContext = this->sigContext;
        result.buf = this->buf;
        result.max = this->max;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgoTracebackArg::operator==(const T& ref) const
    {
        if (context != ref.context) return false;
        if (sigContext != ref.sigContext) return false;
        if (buf != ref.buf) return false;
        if (max != ref.max) return false;
        return true;
    }

    std::ostream& cgoTracebackArg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << context;
        os << " " << sigContext;
        os << " " << buf;
        os << " " << max;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgoTracebackArg& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    cgoContextArg::operator T()
    {
        T result;
        result.context = this->context;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgoContextArg::operator==(const T& ref) const
    {
        if (context != ref.context) return false;
        return true;
    }

    std::ostream& cgoContextArg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << context;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgoContextArg& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    cgoSymbolizerArg::operator T()
    {
        T result;
        result.pc = this->pc;
        result.file = this->file;
        result.lineno = this->lineno;
        result.funcName = this->funcName;
        result.entry = this->entry;
        result.more = this->more;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgoSymbolizerArg::operator==(const T& ref) const
    {
        if (pc != ref.pc) return false;
        if (file != ref.file) return false;
        if (lineno != ref.lineno) return false;
        if (funcName != ref.funcName) return false;
        if (entry != ref.entry) return false;
        if (more != ref.more) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& cgoSymbolizerArg::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pc;
        os << " " << file;
        os << " " << lineno;
        os << " " << funcName;
        os << " " << entry;
        os << " " << more;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgoSymbolizerArg& value)
    {
        return value.PrintTo(os);
    }

    void printCgoTraceback(cgoCallers* callers)
    {
        if(cgoSymbolizer == nullptr)
        {
            for(auto [gocpp_ignored, c] : callers)
            {
                if(c == 0)
                {
                    break;
                }
                print("non-Go function at pc=", hex(c), "\n");
            }
            return;
        }
        auto commitFrame = [=]() mutable -> std::tuple<bool, bool>
        {
            bool pr;
            bool stop;
            return {true, false};
        };
        cgoSymbolizerArg arg = {};
        for(auto [gocpp_ignored, c] : callers)
        {
            if(c == 0)
            {
                break;
            }
            printOneCgoTraceback(c, commitFrame, & arg);
        }
        arg.pc = 0;
        callCgoSymbolizer(& arg);
    }

    bool printOneCgoTraceback(uintptr_t pc, std::function<std::tuple<bool, bool> ()> commitFrame, struct cgoSymbolizerArg* arg)
    {
        arg->pc = pc;
        for(; ; )
        {
            if(auto [pr, stop] = commitFrame(); stop)
            {
                return true;
            }
            else
            if(! pr)
            {
                continue;
            }
            callCgoSymbolizer(arg);
            if(arg->funcName != nullptr)
            {
                println(gostringnocopy(arg->funcName));
            }
            else
            {
                println("non-Go function");
            }
            print("\t");
            if(arg->file != nullptr)
            {
                print(gostringnocopy(arg->file), ":", arg->lineno, " ");
            }
            print("pc=", hex(pc), "\n");
            if(arg->more == 0)
            {
                return false;
            }
        }
    }

    void callCgoSymbolizer(struct cgoSymbolizerArg* arg)
    {
        auto call = cgocall;
        if(rec::Load(gocpp::recv(panicking)) > 0 || getg()->m->curg != getg())
        {
            call = asmcgocall;
        }
        if(msanenabled)
        {
            msanwrite(unsafe::Pointer(arg), gocpp::Sizeof<cgoSymbolizerArg>());
        }
        if(asanenabled)
        {
            asanwrite(unsafe::Pointer(arg), gocpp::Sizeof<cgoSymbolizerArg>());
        }
        call(cgoSymbolizer, noescape(unsafe::Pointer(arg)));
    }

    void cgoContextPCs(uintptr_t ctxt, gocpp::slice<uintptr_t> buf)
    {
        if(cgoTraceback == nullptr)
        {
            return;
        }
        auto call = cgocall;
        if(rec::Load(gocpp::recv(panicking)) > 0 || getg()->m->curg != getg())
        {
            call = asmcgocall;
        }
        auto arg = gocpp::Init<cgoTracebackArg>([](cgoTracebackArg& x) { x.context = ctxt; x.buf = (uintptr_t*)(noescape(unsafe::Pointer(& buf[0]))); x.max = uintptr_t(len(buf)); });
        if(msanenabled)
        {
            msanwrite(unsafe::Pointer(& arg), gocpp::Sizeof<cgoTracebackArg>());
        }
        if(asanenabled)
        {
            asanwrite(unsafe::Pointer(& arg), gocpp::Sizeof<cgoTracebackArg>());
        }
        call(cgoTraceback, noescape(unsafe::Pointer(& arg)));
    }

}

