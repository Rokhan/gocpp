// generated by GoCpp from file '$(ImportDir)/syscall/zsyscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/zsyscall_windows.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/sysdll/sysdll.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    unsafe::Pointer _;
    std::string errERROR_IO_PENDING = Errno(errnoERROR_IO_PENDING);
    std::string errERROR_EINVAL = EINVAL;
    std::string errnoErr(Errno e)
    {
        //Go switch emulation
        {
            auto condition = e;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == errnoERROR_IO_PENDING) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return errERROR_EINVAL;
                    break;
                case 1:
                    return errERROR_IO_PENDING;
                    break;
            }
        }
        return e;
    }

    LazyDLL* modadvapi32 = NewLazyDLL(sysdll::Add("advapi32.dll"));
    LazyDLL* modcrypt32 = NewLazyDLL(sysdll::Add("crypt32.dll"));
    LazyDLL* moddnsapi = NewLazyDLL(sysdll::Add("dnsapi.dll"));
    LazyDLL* modiphlpapi = NewLazyDLL(sysdll::Add("iphlpapi.dll"));
    LazyDLL* modkernel32 = NewLazyDLL(sysdll::Add("kernel32.dll"));
    LazyDLL* modmswsock = NewLazyDLL(sysdll::Add("mswsock.dll"));
    LazyDLL* modnetapi32 = NewLazyDLL(sysdll::Add("netapi32.dll"));
    LazyDLL* modntdll = NewLazyDLL(sysdll::Add("ntdll.dll"));
    LazyDLL* modsecur32 = NewLazyDLL(sysdll::Add("secur32.dll"));
    LazyDLL* modshell32 = NewLazyDLL(sysdll::Add("shell32.dll"));
    LazyDLL* moduserenv = NewLazyDLL(sysdll::Add("userenv.dll"));
    LazyDLL* modws2_32 = NewLazyDLL(sysdll::Add("ws2_32.dll"));
    LazyProc* procConvertSidToStringSidW = NewProc(gocpp::recv(modadvapi32), "ConvertSidToStringSidW");
    LazyProc* procConvertStringSidToSidW = NewProc(gocpp::recv(modadvapi32), "ConvertStringSidToSidW");
    LazyProc* procCopySid = NewProc(gocpp::recv(modadvapi32), "CopySid");
    LazyProc* procCreateProcessAsUserW = NewProc(gocpp::recv(modadvapi32), "CreateProcessAsUserW");
    LazyProc* procCryptAcquireContextW = NewProc(gocpp::recv(modadvapi32), "CryptAcquireContextW");
    LazyProc* procCryptGenRandom = NewProc(gocpp::recv(modadvapi32), "CryptGenRandom");
    LazyProc* procCryptReleaseContext = NewProc(gocpp::recv(modadvapi32), "CryptReleaseContext");
    LazyProc* procGetLengthSid = NewProc(gocpp::recv(modadvapi32), "GetLengthSid");
    LazyProc* procGetTokenInformation = NewProc(gocpp::recv(modadvapi32), "GetTokenInformation");
    LazyProc* procLookupAccountNameW = NewProc(gocpp::recv(modadvapi32), "LookupAccountNameW");
    LazyProc* procLookupAccountSidW = NewProc(gocpp::recv(modadvapi32), "LookupAccountSidW");
    LazyProc* procOpenProcessToken = NewProc(gocpp::recv(modadvapi32), "OpenProcessToken");
    LazyProc* procRegCloseKey = NewProc(gocpp::recv(modadvapi32), "RegCloseKey");
    LazyProc* procRegEnumKeyExW = NewProc(gocpp::recv(modadvapi32), "RegEnumKeyExW");
    LazyProc* procRegOpenKeyExW = NewProc(gocpp::recv(modadvapi32), "RegOpenKeyExW");
    LazyProc* procRegQueryInfoKeyW = NewProc(gocpp::recv(modadvapi32), "RegQueryInfoKeyW");
    LazyProc* procRegQueryValueExW = NewProc(gocpp::recv(modadvapi32), "RegQueryValueExW");
    LazyProc* procCertAddCertificateContextToStore = NewProc(gocpp::recv(modcrypt32), "CertAddCertificateContextToStore");
    LazyProc* procCertCloseStore = NewProc(gocpp::recv(modcrypt32), "CertCloseStore");
    LazyProc* procCertCreateCertificateContext = NewProc(gocpp::recv(modcrypt32), "CertCreateCertificateContext");
    LazyProc* procCertEnumCertificatesInStore = NewProc(gocpp::recv(modcrypt32), "CertEnumCertificatesInStore");
    LazyProc* procCertFreeCertificateChain = NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateChain");
    LazyProc* procCertFreeCertificateContext = NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateContext");
    LazyProc* procCertGetCertificateChain = NewProc(gocpp::recv(modcrypt32), "CertGetCertificateChain");
    LazyProc* procCertOpenStore = NewProc(gocpp::recv(modcrypt32), "CertOpenStore");
    LazyProc* procCertOpenSystemStoreW = NewProc(gocpp::recv(modcrypt32), "CertOpenSystemStoreW");
    LazyProc* procCertVerifyCertificateChainPolicy = NewProc(gocpp::recv(modcrypt32), "CertVerifyCertificateChainPolicy");
    LazyProc* procDnsNameCompare_W = NewProc(gocpp::recv(moddnsapi), "DnsNameCompare_W");
    LazyProc* procDnsQuery_W = NewProc(gocpp::recv(moddnsapi), "DnsQuery_W");
    LazyProc* procDnsRecordListFree = NewProc(gocpp::recv(moddnsapi), "DnsRecordListFree");
    LazyProc* procGetAdaptersInfo = NewProc(gocpp::recv(modiphlpapi), "GetAdaptersInfo");
    LazyProc* procGetIfEntry = NewProc(gocpp::recv(modiphlpapi), "GetIfEntry");
    LazyProc* procCancelIo = NewProc(gocpp::recv(modkernel32), "CancelIo");
    LazyProc* procCancelIoEx = NewProc(gocpp::recv(modkernel32), "CancelIoEx");
    LazyProc* procCloseHandle = NewProc(gocpp::recv(modkernel32), "CloseHandle");
    LazyProc* procCreateDirectoryW = NewProc(gocpp::recv(modkernel32), "CreateDirectoryW");
    LazyProc* procCreateFileMappingW = NewProc(gocpp::recv(modkernel32), "CreateFileMappingW");
    LazyProc* procCreateFileW = NewProc(gocpp::recv(modkernel32), "CreateFileW");
    LazyProc* procCreateHardLinkW = NewProc(gocpp::recv(modkernel32), "CreateHardLinkW");
    LazyProc* procCreateIoCompletionPort = NewProc(gocpp::recv(modkernel32), "CreateIoCompletionPort");
    LazyProc* procCreatePipe = NewProc(gocpp::recv(modkernel32), "CreatePipe");
    LazyProc* procCreateProcessW = NewProc(gocpp::recv(modkernel32), "CreateProcessW");
    LazyProc* procCreateSymbolicLinkW = NewProc(gocpp::recv(modkernel32), "CreateSymbolicLinkW");
    LazyProc* procCreateToolhelp32Snapshot = NewProc(gocpp::recv(modkernel32), "CreateToolhelp32Snapshot");
    LazyProc* procDeleteFileW = NewProc(gocpp::recv(modkernel32), "DeleteFileW");
    LazyProc* procDeleteProcThreadAttributeList = NewProc(gocpp::recv(modkernel32), "DeleteProcThreadAttributeList");
    LazyProc* procDeviceIoControl = NewProc(gocpp::recv(modkernel32), "DeviceIoControl");
    LazyProc* procDuplicateHandle = NewProc(gocpp::recv(modkernel32), "DuplicateHandle");
    LazyProc* procExitProcess = NewProc(gocpp::recv(modkernel32), "ExitProcess");
    LazyProc* procFindClose = NewProc(gocpp::recv(modkernel32), "FindClose");
    LazyProc* procFindFirstFileW = NewProc(gocpp::recv(modkernel32), "FindFirstFileW");
    LazyProc* procFindNextFileW = NewProc(gocpp::recv(modkernel32), "FindNextFileW");
    LazyProc* procFlushFileBuffers = NewProc(gocpp::recv(modkernel32), "FlushFileBuffers");
    LazyProc* procFlushViewOfFile = NewProc(gocpp::recv(modkernel32), "FlushViewOfFile");
    LazyProc* procFormatMessageW = NewProc(gocpp::recv(modkernel32), "FormatMessageW");
    LazyProc* procFreeEnvironmentStringsW = NewProc(gocpp::recv(modkernel32), "FreeEnvironmentStringsW");
    LazyProc* procFreeLibrary = NewProc(gocpp::recv(modkernel32), "FreeLibrary");
    LazyProc* procGetCommandLineW = NewProc(gocpp::recv(modkernel32), "GetCommandLineW");
    LazyProc* procGetComputerNameW = NewProc(gocpp::recv(modkernel32), "GetComputerNameW");
    LazyProc* procGetConsoleMode = NewProc(gocpp::recv(modkernel32), "GetConsoleMode");
    LazyProc* procGetCurrentDirectoryW = NewProc(gocpp::recv(modkernel32), "GetCurrentDirectoryW");
    LazyProc* procGetCurrentProcess = NewProc(gocpp::recv(modkernel32), "GetCurrentProcess");
    LazyProc* procGetCurrentProcessId = NewProc(gocpp::recv(modkernel32), "GetCurrentProcessId");
    LazyProc* procGetEnvironmentStringsW = NewProc(gocpp::recv(modkernel32), "GetEnvironmentStringsW");
    LazyProc* procGetEnvironmentVariableW = NewProc(gocpp::recv(modkernel32), "GetEnvironmentVariableW");
    LazyProc* procGetExitCodeProcess = NewProc(gocpp::recv(modkernel32), "GetExitCodeProcess");
    LazyProc* procGetFileAttributesExW = NewProc(gocpp::recv(modkernel32), "GetFileAttributesExW");
    LazyProc* procGetFileAttributesW = NewProc(gocpp::recv(modkernel32), "GetFileAttributesW");
    LazyProc* procGetFileInformationByHandle = NewProc(gocpp::recv(modkernel32), "GetFileInformationByHandle");
    LazyProc* procGetFileType = NewProc(gocpp::recv(modkernel32), "GetFileType");
    LazyProc* procGetFinalPathNameByHandleW = NewProc(gocpp::recv(modkernel32), "GetFinalPathNameByHandleW");
    LazyProc* procGetFullPathNameW = NewProc(gocpp::recv(modkernel32), "GetFullPathNameW");
    LazyProc* procGetLastError = NewProc(gocpp::recv(modkernel32), "GetLastError");
    LazyProc* procGetLongPathNameW = NewProc(gocpp::recv(modkernel32), "GetLongPathNameW");
    LazyProc* procGetProcAddress = NewProc(gocpp::recv(modkernel32), "GetProcAddress");
    LazyProc* procGetProcessTimes = NewProc(gocpp::recv(modkernel32), "GetProcessTimes");
    LazyProc* procGetQueuedCompletionStatus = NewProc(gocpp::recv(modkernel32), "GetQueuedCompletionStatus");
    LazyProc* procGetShortPathNameW = NewProc(gocpp::recv(modkernel32), "GetShortPathNameW");
    LazyProc* procGetStartupInfoW = NewProc(gocpp::recv(modkernel32), "GetStartupInfoW");
    LazyProc* procGetStdHandle = NewProc(gocpp::recv(modkernel32), "GetStdHandle");
    LazyProc* procGetSystemTimeAsFileTime = NewProc(gocpp::recv(modkernel32), "GetSystemTimeAsFileTime");
    LazyProc* procGetTempPathW = NewProc(gocpp::recv(modkernel32), "GetTempPathW");
    LazyProc* procGetTimeZoneInformation = NewProc(gocpp::recv(modkernel32), "GetTimeZoneInformation");
    LazyProc* procGetVersion = NewProc(gocpp::recv(modkernel32), "GetVersion");
    LazyProc* procInitializeProcThreadAttributeList = NewProc(gocpp::recv(modkernel32), "InitializeProcThreadAttributeList");
    LazyProc* procLoadLibraryW = NewProc(gocpp::recv(modkernel32), "LoadLibraryW");
    LazyProc* procLocalFree = NewProc(gocpp::recv(modkernel32), "LocalFree");
    LazyProc* procMapViewOfFile = NewProc(gocpp::recv(modkernel32), "MapViewOfFile");
    LazyProc* procMoveFileW = NewProc(gocpp::recv(modkernel32), "MoveFileW");
    LazyProc* procOpenProcess = NewProc(gocpp::recv(modkernel32), "OpenProcess");
    LazyProc* procPostQueuedCompletionStatus = NewProc(gocpp::recv(modkernel32), "PostQueuedCompletionStatus");
    LazyProc* procProcess32FirstW = NewProc(gocpp::recv(modkernel32), "Process32FirstW");
    LazyProc* procProcess32NextW = NewProc(gocpp::recv(modkernel32), "Process32NextW");
    LazyProc* procReadConsoleW = NewProc(gocpp::recv(modkernel32), "ReadConsoleW");
    LazyProc* procReadDirectoryChangesW = NewProc(gocpp::recv(modkernel32), "ReadDirectoryChangesW");
    LazyProc* procReadFile = NewProc(gocpp::recv(modkernel32), "ReadFile");
    LazyProc* procRemoveDirectoryW = NewProc(gocpp::recv(modkernel32), "RemoveDirectoryW");
    LazyProc* procSetCurrentDirectoryW = NewProc(gocpp::recv(modkernel32), "SetCurrentDirectoryW");
    LazyProc* procSetEndOfFile = NewProc(gocpp::recv(modkernel32), "SetEndOfFile");
    LazyProc* procSetEnvironmentVariableW = NewProc(gocpp::recv(modkernel32), "SetEnvironmentVariableW");
    LazyProc* procSetFileAttributesW = NewProc(gocpp::recv(modkernel32), "SetFileAttributesW");
    LazyProc* procSetFileCompletionNotificationModes = NewProc(gocpp::recv(modkernel32), "SetFileCompletionNotificationModes");
    LazyProc* procSetFilePointer = NewProc(gocpp::recv(modkernel32), "SetFilePointer");
    LazyProc* procSetFileTime = NewProc(gocpp::recv(modkernel32), "SetFileTime");
    LazyProc* procSetHandleInformation = NewProc(gocpp::recv(modkernel32), "SetHandleInformation");
    LazyProc* procTerminateProcess = NewProc(gocpp::recv(modkernel32), "TerminateProcess");
    LazyProc* procUnmapViewOfFile = NewProc(gocpp::recv(modkernel32), "UnmapViewOfFile");
    LazyProc* procUpdateProcThreadAttribute = NewProc(gocpp::recv(modkernel32), "UpdateProcThreadAttribute");
    LazyProc* procVirtualLock = NewProc(gocpp::recv(modkernel32), "VirtualLock");
    LazyProc* procVirtualUnlock = NewProc(gocpp::recv(modkernel32), "VirtualUnlock");
    LazyProc* procWaitForSingleObject = NewProc(gocpp::recv(modkernel32), "WaitForSingleObject");
    LazyProc* procWriteConsoleW = NewProc(gocpp::recv(modkernel32), "WriteConsoleW");
    LazyProc* procWriteFile = NewProc(gocpp::recv(modkernel32), "WriteFile");
    LazyProc* procAcceptEx = NewProc(gocpp::recv(modmswsock), "AcceptEx");
    LazyProc* procGetAcceptExSockaddrs = NewProc(gocpp::recv(modmswsock), "GetAcceptExSockaddrs");
    LazyProc* procTransmitFile = NewProc(gocpp::recv(modmswsock), "TransmitFile");
    LazyProc* procNetApiBufferFree = NewProc(gocpp::recv(modnetapi32), "NetApiBufferFree");
    LazyProc* procNetGetJoinInformation = NewProc(gocpp::recv(modnetapi32), "NetGetJoinInformation");
    LazyProc* procNetUserGetInfo = NewProc(gocpp::recv(modnetapi32), "NetUserGetInfo");
    LazyProc* procRtlGetNtVersionNumbers = NewProc(gocpp::recv(modntdll), "RtlGetNtVersionNumbers");
    LazyProc* procGetUserNameExW = NewProc(gocpp::recv(modsecur32), "GetUserNameExW");
    LazyProc* procTranslateNameW = NewProc(gocpp::recv(modsecur32), "TranslateNameW");
    LazyProc* procCommandLineToArgvW = NewProc(gocpp::recv(modshell32), "CommandLineToArgvW");
    LazyProc* procGetUserProfileDirectoryW = NewProc(gocpp::recv(moduserenv), "GetUserProfileDirectoryW");
    LazyProc* procFreeAddrInfoW = NewProc(gocpp::recv(modws2_32), "FreeAddrInfoW");
    LazyProc* procGetAddrInfoW = NewProc(gocpp::recv(modws2_32), "GetAddrInfoW");
    LazyProc* procWSACleanup = NewProc(gocpp::recv(modws2_32), "WSACleanup");
    LazyProc* procWSAEnumProtocolsW = NewProc(gocpp::recv(modws2_32), "WSAEnumProtocolsW");
    LazyProc* procWSAIoctl = NewProc(gocpp::recv(modws2_32), "WSAIoctl");
    LazyProc* procWSARecv = NewProc(gocpp::recv(modws2_32), "WSARecv");
    LazyProc* procWSARecvFrom = NewProc(gocpp::recv(modws2_32), "WSARecvFrom");
    LazyProc* procWSASend = NewProc(gocpp::recv(modws2_32), "WSASend");
    LazyProc* procWSASendTo = NewProc(gocpp::recv(modws2_32), "WSASendTo");
    LazyProc* procWSAStartup = NewProc(gocpp::recv(modws2_32), "WSAStartup");
    LazyProc* procbind = NewProc(gocpp::recv(modws2_32), "bind");
    LazyProc* procclosesocket = NewProc(gocpp::recv(modws2_32), "closesocket");
    LazyProc* procconnect = NewProc(gocpp::recv(modws2_32), "connect");
    LazyProc* procgethostbyname = NewProc(gocpp::recv(modws2_32), "gethostbyname");
    LazyProc* procgetpeername = NewProc(gocpp::recv(modws2_32), "getpeername");
    LazyProc* procgetprotobyname = NewProc(gocpp::recv(modws2_32), "getprotobyname");
    LazyProc* procgetservbyname = NewProc(gocpp::recv(modws2_32), "getservbyname");
    LazyProc* procgetsockname = NewProc(gocpp::recv(modws2_32), "getsockname");
    LazyProc* procgetsockopt = NewProc(gocpp::recv(modws2_32), "getsockopt");
    LazyProc* proclisten = NewProc(gocpp::recv(modws2_32), "listen");
    LazyProc* procntohs = NewProc(gocpp::recv(modws2_32), "ntohs");
    LazyProc* procsetsockopt = NewProc(gocpp::recv(modws2_32), "setsockopt");
    LazyProc* procshutdown = NewProc(gocpp::recv(modws2_32), "shutdown");
    LazyProc* procsocket = NewProc(gocpp::recv(modws2_32), "socket");
    std::string ConvertSidToStringSid(SID* sid, uint16_t** stringSid)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procConvertSidToStringSidW)), 2, uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(stringSid)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string ConvertStringSidToSid(uint16_t* stringSid, SID** sid)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procConvertStringSidToSidW)), 2, uintptr_t(unsafe::Pointer(stringSid)), uintptr_t(unsafe::Pointer(sid)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CopySid(uint32_t destSidLen, SID* destSid, SID* srcSid)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCopySid)), 3, uintptr_t(destSidLen), uintptr_t(unsafe::Pointer(destSid)), uintptr_t(unsafe::Pointer(srcSid)));
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CreateProcessAsUser(Token token, uint16_t* appName, uint16_t* commandLine, SecurityAttributes* procSecurity, SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, StartupInfo* startupInfo, ProcessInformation* outProcInfo)
    {
        std::string err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            std::string err;
            _p0 = 1;
        }
        auto [r1, _, e1] = Syscall12(Addr(gocpp::recv(procCreateProcessAsUserW)), 11, uintptr_t(token), uintptr_t(unsafe::Pointer(appName)), uintptr_t(unsafe::Pointer(commandLine)), uintptr_t(unsafe::Pointer(procSecurity)), uintptr_t(unsafe::Pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(unsafe::Pointer(env)), uintptr_t(unsafe::Pointer(currentDir)), uintptr_t(unsafe::Pointer(startupInfo)), uintptr_t(unsafe::Pointer(outProcInfo)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CryptAcquireContext(Handle* provhandle, uint16_t* container, uint16_t* provider, uint32_t provtype, uint32_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procCryptAcquireContextW)), 5, uintptr_t(unsafe::Pointer(provhandle)), uintptr_t(unsafe::Pointer(container)), uintptr_t(unsafe::Pointer(provider)), uintptr_t(provtype), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CryptGenRandom(Handle provhandle, uint32_t buflen, unsigned char* buf)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCryptGenRandom)), 3, uintptr_t(provhandle), uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)));
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CryptReleaseContext(Handle provhandle, uint32_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCryptReleaseContext)), 2, uintptr_t(provhandle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    uint32_t GetLengthSid(SID* sid)
    {
        uint32_t len;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procGetLengthSid)), 1, uintptr_t(unsafe::Pointer(sid)), 0, 0);
        len = uint32_t(r0);
        return len;
    }

    std::string GetTokenInformation(Token t, uint32_t infoClass, unsigned char* info, uint32_t infoLen, uint32_t* returnedLen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procGetTokenInformation)), 5, uintptr_t(t), uintptr_t(infoClass), uintptr_t(unsafe::Pointer(info)), uintptr_t(infoLen), uintptr_t(unsafe::Pointer(returnedLen)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string LookupAccountName(uint16_t* systemName, uint16_t* accountName, SID* sid, uint32_t* sidLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procLookupAccountNameW)), 7, uintptr_t(unsafe::Pointer(systemName)), uintptr_t(unsafe::Pointer(accountName)), uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(sidLen)), uintptr_t(unsafe::Pointer(refdDomainName)), uintptr_t(unsafe::Pointer(refdDomainNameLen)), uintptr_t(unsafe::Pointer(use)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string LookupAccountSid(uint16_t* systemName, SID* sid, uint16_t* name, uint32_t* nameLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procLookupAccountSidW)), 7, uintptr_t(unsafe::Pointer(systemName)), uintptr_t(unsafe::Pointer(sid)), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(nameLen)), uintptr_t(unsafe::Pointer(refdDomainName)), uintptr_t(unsafe::Pointer(refdDomainNameLen)), uintptr_t(unsafe::Pointer(use)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string OpenProcessToken(Handle h, uint32_t access, Token* token)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procOpenProcessToken)), 3, uintptr_t(h), uintptr_t(access), uintptr_t(unsafe::Pointer(token)));
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string RegCloseKey(Handle key)
    {
        std::string regerrno;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procRegCloseKey)), 1, uintptr_t(key), 0, 0);
        if(r0 != 0)
        {
            std::string regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    std::string regEnumKeyEx(Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, Filetime* lastWriteTime)
    {
        std::string regerrno;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall9(Addr(gocpp::recv(procRegEnumKeyExW)), 8, uintptr_t(key), uintptr_t(index), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(nameLen)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(go_class)), uintptr_t(unsafe::Pointer(classLen)), uintptr_t(unsafe::Pointer(lastWriteTime)), 0);
        if(r0 != 0)
        {
            std::string regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    std::string RegOpenKeyEx(Handle key, uint16_t* subkey, uint32_t options, uint32_t desiredAccess, Handle* result)
    {
        std::string regerrno;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall6(Addr(gocpp::recv(procRegOpenKeyExW)), 5, uintptr_t(key), uintptr_t(unsafe::Pointer(subkey)), uintptr_t(options), uintptr_t(desiredAccess), uintptr_t(unsafe::Pointer(result)), 0);
        if(r0 != 0)
        {
            std::string regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    std::string RegQueryInfoKey(Handle key, uint16_t* go_class, uint32_t* classLen, uint32_t* reserved, uint32_t* subkeysLen, uint32_t* maxSubkeyLen, uint32_t* maxClassLen, uint32_t* valuesLen, uint32_t* maxValueNameLen, uint32_t* maxValueLen, uint32_t* saLen, Filetime* lastWriteTime)
    {
        std::string regerrno;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall12(Addr(gocpp::recv(procRegQueryInfoKeyW)), 12, uintptr_t(key), uintptr_t(unsafe::Pointer(go_class)), uintptr_t(unsafe::Pointer(classLen)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(subkeysLen)), uintptr_t(unsafe::Pointer(maxSubkeyLen)), uintptr_t(unsafe::Pointer(maxClassLen)), uintptr_t(unsafe::Pointer(valuesLen)), uintptr_t(unsafe::Pointer(maxValueNameLen)), uintptr_t(unsafe::Pointer(maxValueLen)), uintptr_t(unsafe::Pointer(saLen)), uintptr_t(unsafe::Pointer(lastWriteTime)));
        if(r0 != 0)
        {
            std::string regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    std::string RegQueryValueEx(Handle key, uint16_t* name, uint32_t* reserved, uint32_t* valtype, unsigned char* buf, uint32_t* buflen)
    {
        std::string regerrno;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall6(Addr(gocpp::recv(procRegQueryValueExW)), 6, uintptr_t(key), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(reserved)), uintptr_t(unsafe::Pointer(valtype)), uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(buflen)));
        if(r0 != 0)
        {
            std::string regerrno;
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    std::string CertAddCertificateContextToStore(Handle store, CertContext* certContext, uint32_t addDisposition, CertContext** storeContext)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procCertAddCertificateContextToStore)), 4, uintptr_t(store), uintptr_t(unsafe::Pointer(certContext)), uintptr_t(addDisposition), uintptr_t(unsafe::Pointer(storeContext)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CertCloseStore(Handle store, uint32_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCertCloseStore)), 2, uintptr_t(store), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<CertContext*, std::string> CertCreateCertificateContext(uint32_t certEncodingType, unsigned char* certEncoded, uint32_t encodedLen)
    {
        CertContext* context;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procCertCreateCertificateContext)), 3, uintptr_t(certEncodingType), uintptr_t(unsafe::Pointer(certEncoded)), uintptr_t(encodedLen));
        context = (CertContext*)(unsafe::Pointer(r0));
        if(context == nullptr)
        {
            CertContext* context;
            std::string err;
            err = errnoErr(e1);
        }
        return {context, err};
    }

    std::tuple<CertContext*, std::string> CertEnumCertificatesInStore(Handle store, CertContext* prevContext)
    {
        CertContext* context;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procCertEnumCertificatesInStore)), 2, uintptr_t(store), uintptr_t(unsafe::Pointer(prevContext)), 0);
        context = (CertContext*)(unsafe::Pointer(r0));
        if(context == nullptr)
        {
            CertContext* context;
            std::string err;
            err = errnoErr(e1);
        }
        return {context, err};
    }

    void CertFreeCertificateChain(CertChainContext* ctx)
    {
        Syscall(Addr(gocpp::recv(procCertFreeCertificateChain)), 1, uintptr_t(unsafe::Pointer(ctx)), 0, 0);
        return;
    }

    std::string CertFreeCertificateContext(CertContext* ctx)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCertFreeCertificateContext)), 1, uintptr_t(unsafe::Pointer(ctx)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CertGetCertificateChain(Handle engine, CertContext* leaf, Filetime* time, Handle additionalStore, CertChainPara* para, uint32_t flags, uintptr_t reserved, CertChainContext** chainCtx)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procCertGetCertificateChain)), 8, uintptr_t(engine), uintptr_t(unsafe::Pointer(leaf)), uintptr_t(unsafe::Pointer(time)), uintptr_t(additionalStore), uintptr_t(unsafe::Pointer(para)), uintptr_t(flags), uintptr_t(reserved), uintptr_t(unsafe::Pointer(chainCtx)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> CertOpenStore(uintptr_t storeProvider, uint32_t msgAndCertEncodingType, uintptr_t cryptProv, uint32_t flags, uintptr_t para)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procCertOpenStore)), 5, uintptr_t(storeProvider), uintptr_t(msgAndCertEncodingType), uintptr_t(cryptProv), uintptr_t(flags), uintptr_t(para), 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<Handle, std::string> CertOpenSystemStore(Handle hprov, uint16_t* name)
    {
        Handle store;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procCertOpenSystemStoreW)), 2, uintptr_t(hprov), uintptr_t(unsafe::Pointer(name)), 0);
        store = Handle(r0);
        if(store == 0)
        {
            Handle store;
            std::string err;
            err = errnoErr(e1);
        }
        return {store, err};
    }

    std::string CertVerifyCertificateChainPolicy(uintptr_t policyOID, CertChainContext* chain, CertChainPolicyPara* para, CertChainPolicyStatus* status)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procCertVerifyCertificateChainPolicy)), 4, uintptr_t(policyOID), uintptr_t(unsafe::Pointer(chain)), uintptr_t(unsafe::Pointer(para)), uintptr_t(unsafe::Pointer(status)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    bool DnsNameCompare(uint16_t* name1, uint16_t* name2)
    {
        bool same;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procDnsNameCompare_W)), 2, uintptr_t(unsafe::Pointer(name1)), uintptr_t(unsafe::Pointer(name2)), 0);
        same = r0 != 0;
        return same;
    }

    std::string DnsQuery(std::string name, uint16_t qtype, uint32_t options, unsigned char* extra, DNSRecord** qrs, unsigned char* pr)
    {
        std::string status;
        uint16_t* _p0 = {};
        std::tie(_p0, status) = UTF16PtrFromString(name);
        if(status != nullptr)
        {
            std::string status;
            return status;
        }
        return _DnsQuery(_p0, qtype, options, extra, qrs, pr);
    }

    std::string _DnsQuery(uint16_t* name, uint16_t qtype, uint32_t options, unsigned char* extra, DNSRecord** qrs, unsigned char* pr)
    {
        std::string status;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall6(Addr(gocpp::recv(procDnsQuery_W)), 6, uintptr_t(unsafe::Pointer(name)), uintptr_t(qtype), uintptr_t(options), uintptr_t(unsafe::Pointer(extra)), uintptr_t(unsafe::Pointer(qrs)), uintptr_t(unsafe::Pointer(pr)));
        if(r0 != 0)
        {
            std::string status;
            status = Errno(r0);
        }
        return status;
    }

    void DnsRecordListFree(DNSRecord* rl, uint32_t freetype)
    {
        Syscall(Addr(gocpp::recv(procDnsRecordListFree)), 2, uintptr_t(unsafe::Pointer(rl)), uintptr_t(freetype), 0);
        return;
    }

    std::string GetAdaptersInfo(IpAdapterInfo* ai, uint32_t* ol)
    {
        std::string errcode;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procGetAdaptersInfo)), 2, uintptr_t(unsafe::Pointer(ai)), uintptr_t(unsafe::Pointer(ol)), 0);
        if(r0 != 0)
        {
            std::string errcode;
            errcode = Errno(r0);
        }
        return errcode;
    }

    std::string GetIfEntry(MibIfRow* pIfRow)
    {
        std::string errcode;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procGetIfEntry)), 1, uintptr_t(unsafe::Pointer(pIfRow)), 0, 0);
        if(r0 != 0)
        {
            std::string errcode;
            errcode = Errno(r0);
        }
        return errcode;
    }

    std::string CancelIo(Handle s)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCancelIo)), 1, uintptr_t(s), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CancelIoEx(Handle s, Overlapped* o)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCancelIoEx)), 2, uintptr_t(s), uintptr_t(unsafe::Pointer(o)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CloseHandle(Handle handle)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCloseHandle)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CreateDirectory(uint16_t* path, SecurityAttributes* sa)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCreateDirectoryW)), 2, uintptr_t(unsafe::Pointer(path)), uintptr_t(unsafe::Pointer(sa)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> CreateFileMapping(Handle fhandle, SecurityAttributes* sa, uint32_t prot, uint32_t maxSizeHigh, uint32_t maxSizeLow, uint16_t* name)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procCreateFileMappingW)), 6, uintptr_t(fhandle), uintptr_t(unsafe::Pointer(sa)), uintptr_t(prot), uintptr_t(maxSizeHigh), uintptr_t(maxSizeLow), uintptr_t(unsafe::Pointer(name)));
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<Handle, std::string> CreateFile(uint16_t* name, uint32_t access, uint32_t mode, SecurityAttributes* sa, uint32_t createmode, uint32_t attrs, int32_t templatefile)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall9(Addr(gocpp::recv(procCreateFileW)), 7, uintptr_t(unsafe::Pointer(name)), uintptr_t(access), uintptr_t(mode), uintptr_t(unsafe::Pointer(sa)), uintptr_t(createmode), uintptr_t(attrs), uintptr_t(templatefile), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::string CreateHardLink(uint16_t* filename, uint16_t* existingfilename, uintptr_t reserved)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCreateHardLinkW)), 3, uintptr_t(unsafe::Pointer(filename)), uintptr_t(unsafe::Pointer(existingfilename)), uintptr_t(reserved));
        if(r1 & 0xff == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> createIoCompletionPort(Handle filehandle, Handle cphandle, uintptr_t key, uint32_t threadcnt)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procCreateIoCompletionPort)), 4, uintptr_t(filehandle), uintptr_t(cphandle), uintptr_t(key), uintptr_t(threadcnt), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::string CreatePipe(Handle* readhandle, Handle* writehandle, SecurityAttributes* sa, uint32_t size)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procCreatePipe)), 4, uintptr_t(unsafe::Pointer(readhandle)), uintptr_t(unsafe::Pointer(writehandle)), uintptr_t(unsafe::Pointer(sa)), uintptr_t(size), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CreateProcess(uint16_t* appName, uint16_t* commandLine, SecurityAttributes* procSecurity, SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, StartupInfo* startupInfo, ProcessInformation* outProcInfo)
    {
        std::string err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            std::string err;
            _p0 = 1;
        }
        auto [r1, _, e1] = Syscall12(Addr(gocpp::recv(procCreateProcessW)), 10, uintptr_t(unsafe::Pointer(appName)), uintptr_t(unsafe::Pointer(commandLine)), uintptr_t(unsafe::Pointer(procSecurity)), uintptr_t(unsafe::Pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(unsafe::Pointer(env)), uintptr_t(unsafe::Pointer(currentDir)), uintptr_t(unsafe::Pointer(startupInfo)), uintptr_t(unsafe::Pointer(outProcInfo)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string CreateSymbolicLink(uint16_t* symlinkfilename, uint16_t* targetfilename, uint32_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procCreateSymbolicLinkW)), 3, uintptr_t(unsafe::Pointer(symlinkfilename)), uintptr_t(unsafe::Pointer(targetfilename)), uintptr_t(flags));
        if(r1 & 0xff == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> CreateToolhelp32Snapshot(uint32_t flags, uint32_t processId)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procCreateToolhelp32Snapshot)), 2, uintptr_t(flags), uintptr_t(processId), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::string DeleteFile(uint16_t* path)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procDeleteFileW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    void deleteProcThreadAttributeList(_PROC_THREAD_ATTRIBUTE_LIST* attrlist)
    {
        Syscall(Addr(gocpp::recv(procDeleteProcThreadAttributeList)), 1, uintptr_t(unsafe::Pointer(attrlist)), 0, 0);
        return;
    }

    std::string DeviceIoControl(Handle handle, uint32_t ioControlCode, unsigned char* inBuffer, uint32_t inBufferSize, unsigned char* outBuffer, uint32_t outBufferSize, uint32_t* bytesReturned, Overlapped* overlapped)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procDeviceIoControl)), 8, uintptr_t(handle), uintptr_t(ioControlCode), uintptr_t(unsafe::Pointer(inBuffer)), uintptr_t(inBufferSize), uintptr_t(unsafe::Pointer(outBuffer)), uintptr_t(outBufferSize), uintptr_t(unsafe::Pointer(bytesReturned)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string DuplicateHandle(Handle hSourceProcessHandle, Handle hSourceHandle, Handle hTargetProcessHandle, Handle* lpTargetHandle, uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwOptions)
    {
        std::string err;
        uint32_t _p0 = {};
        if(bInheritHandle)
        {
            std::string err;
            _p0 = 1;
        }
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procDuplicateHandle)), 7, uintptr_t(hSourceProcessHandle), uintptr_t(hSourceHandle), uintptr_t(hTargetProcessHandle), uintptr_t(unsafe::Pointer(lpTargetHandle)), uintptr_t(dwDesiredAccess), uintptr_t(_p0), uintptr_t(dwOptions), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    void ExitProcess(uint32_t exitcode)
    {
        Syscall(Addr(gocpp::recv(procExitProcess)), 1, uintptr_t(exitcode), 0, 0);
        return;
    }

    std::string FindClose(Handle handle)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procFindClose)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> findFirstFile1(uint16_t* name, win32finddata1* data)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procFindFirstFileW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(data)), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::string findNextFile1(Handle handle, win32finddata1* data)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procFindNextFileW)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(data)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string FlushFileBuffers(Handle handle)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procFlushFileBuffers)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string FlushViewOfFile(uintptr_t addr, uintptr_t length)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procFlushViewOfFile)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> formatMessage(uint32_t flags, uintptr_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args)
    {
        uint32_t n;
        std::string err;
        uint16_t* _p0 = {};
        if(len(buf) > 0)
        {
            uint32_t n;
            std::string err;
            _p0 = & buf[0];
        }
        auto [r0, _, e1] = Syscall9(Addr(gocpp::recv(procFormatMessageW)), 7, uintptr_t(flags), uintptr_t(msgsrc), uintptr_t(msgid), uintptr_t(langid), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(args)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::string FreeEnvironmentStrings(uint16_t* envs)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procFreeEnvironmentStringsW)), 1, uintptr_t(unsafe::Pointer(envs)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string FreeLibrary(Handle handle)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procFreeLibrary)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t* GetCommandLine()
    {
        uint16_t* cmd;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procGetCommandLineW)), 0, 0, 0, 0);
        cmd = (uint16_t*)(unsafe::Pointer(r0));
        return cmd;
    }

    std::string GetComputerName(uint16_t* buf, uint32_t* n)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetComputerNameW)), 2, uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(n)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string GetConsoleMode(Handle console, uint32_t* mode)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetConsoleMode)), 2, uintptr_t(console), uintptr_t(unsafe::Pointer(mode)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> GetCurrentDirectory(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetCurrentDirectoryW)), 2, uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<Handle, std::string> GetCurrentProcess()
    {
        Handle pseudoHandle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetCurrentProcess)), 0, 0, 0, 0);
        pseudoHandle = Handle(r0);
        if(pseudoHandle == 0)
        {
            Handle pseudoHandle;
            std::string err;
            err = errnoErr(e1);
        }
        return {pseudoHandle, err};
    }

    uint32_t getCurrentProcessId()
    {
        uint32_t pid;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procGetCurrentProcessId)), 0, 0, 0, 0);
        pid = uint32_t(r0);
        return pid;
    }

    std::tuple<uint16_t*, std::string> GetEnvironmentStrings()
    {
        uint16_t* envs;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetEnvironmentStringsW)), 0, 0, 0, 0);
        envs = (uint16_t*)(unsafe::Pointer(r0));
        if(envs == nullptr)
        {
            uint16_t* envs;
            std::string err;
            err = errnoErr(e1);
        }
        return {envs, err};
    }

    std::tuple<uint32_t, std::string> GetEnvironmentVariable(uint16_t* name, uint16_t* buffer, uint32_t size)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetEnvironmentVariableW)), 3, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(buffer)), uintptr_t(size));
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::string GetExitCodeProcess(Handle handle, uint32_t* exitcode)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetExitCodeProcess)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(exitcode)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string GetFileAttributesEx(uint16_t* name, uint32_t level, unsigned char* info)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetFileAttributesExW)), 3, uintptr_t(unsafe::Pointer(name)), uintptr_t(level), uintptr_t(unsafe::Pointer(info)));
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> GetFileAttributes(uint16_t* name)
    {
        uint32_t attrs;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetFileAttributesW)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        attrs = uint32_t(r0);
        if(attrs == INVALID_FILE_ATTRIBUTES)
        {
            uint32_t attrs;
            std::string err;
            err = errnoErr(e1);
        }
        return {attrs, err};
    }

    std::string GetFileInformationByHandle(Handle handle, ByHandleFileInformation* data)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetFileInformationByHandle)), 2, uintptr_t(handle), uintptr_t(unsafe::Pointer(data)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> GetFileType(Handle filehandle)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetFileType)), 1, uintptr_t(filehandle), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, std::string> getFinalPathNameByHandle(Handle file, uint16_t* filePath, uint32_t filePathSize, uint32_t flags)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procGetFinalPathNameByHandleW)), 4, uintptr_t(file), uintptr_t(unsafe::Pointer(filePath)), uintptr_t(filePathSize), uintptr_t(flags), 0, 0);
        n = uint32_t(r0);
        if(n == 0 || n >= filePathSize)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, std::string> GetFullPathName(uint16_t* path, uint32_t buflen, uint16_t* buf, uint16_t** fname)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procGetFullPathNameW)), 4, uintptr_t(unsafe::Pointer(path)), uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), uintptr_t(unsafe::Pointer(fname)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::string GetLastError()
    {
        std::string lasterr;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procGetLastError)), 0, 0, 0, 0);
        if(r0 != 0)
        {
            std::string lasterr;
            lasterr = Errno(r0);
        }
        return lasterr;
    }

    std::tuple<uint32_t, std::string> GetLongPathName(uint16_t* path, uint16_t* buf, uint32_t buflen)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetLongPathNameW)), 3, uintptr_t(unsafe::Pointer(path)), uintptr_t(unsafe::Pointer(buf)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uintptr_t, std::string> GetProcAddress(Handle module, std::string procname)
    {
        uintptr_t proc;
        std::string err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(procname);
        if(err != nullptr)
        {
            uintptr_t proc;
            std::string err;
            return {proc, err};
        }
        return _GetProcAddress(module, _p0);
    }

    std::tuple<uintptr_t, std::string> _GetProcAddress(Handle module, unsigned char* procname)
    {
        uintptr_t proc;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetProcAddress)), 2, uintptr_t(module), uintptr_t(unsafe::Pointer(procname)), 0);
        proc = uintptr_t(r0);
        if(proc == 0)
        {
            uintptr_t proc;
            std::string err;
            err = errnoErr(e1);
        }
        return {proc, err};
    }

    std::string GetProcessTimes(Handle handle, Filetime* creationTime, Filetime* exitTime, Filetime* kernelTime, Filetime* userTime)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procGetProcessTimes)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(creationTime)), uintptr_t(unsafe::Pointer(exitTime)), uintptr_t(unsafe::Pointer(kernelTime)), uintptr_t(unsafe::Pointer(userTime)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string getQueuedCompletionStatus(Handle cphandle, uint32_t* qty, uintptr_t* key, Overlapped** overlapped, uint32_t timeout)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procGetQueuedCompletionStatus)), 5, uintptr_t(cphandle), uintptr_t(unsafe::Pointer(qty)), uintptr_t(unsafe::Pointer(key)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(timeout), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> GetShortPathName(uint16_t* longpath, uint16_t* shortpath, uint32_t buflen)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetShortPathNameW)), 3, uintptr_t(unsafe::Pointer(longpath)), uintptr_t(unsafe::Pointer(shortpath)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    void getStartupInfo(StartupInfo* startupInfo)
    {
        Syscall(Addr(gocpp::recv(procGetStartupInfoW)), 1, uintptr_t(unsafe::Pointer(startupInfo)), 0, 0);
        return;
    }

    std::tuple<Handle, std::string> GetStdHandle(int stdhandle)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetStdHandle)), 1, uintptr_t(stdhandle), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    void GetSystemTimeAsFileTime(Filetime* time)
    {
        Syscall(Addr(gocpp::recv(procGetSystemTimeAsFileTime)), 1, uintptr_t(unsafe::Pointer(time)), 0, 0);
        return;
    }

    std::tuple<uint32_t, std::string> GetTempPath(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetTempPathW)), 2, uintptr_t(buflen), uintptr_t(unsafe::Pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            uint32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, std::string> GetTimeZoneInformation(Timezoneinformation* tzi)
    {
        uint32_t rc;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetTimeZoneInformation)), 1, uintptr_t(unsafe::Pointer(tzi)), 0, 0);
        rc = uint32_t(r0);
        if(rc == 0xffffffff)
        {
            uint32_t rc;
            std::string err;
            err = errnoErr(e1);
        }
        return {rc, err};
    }

    std::tuple<uint32_t, std::string> GetVersion()
    {
        uint32_t ver;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procGetVersion)), 0, 0, 0, 0);
        ver = uint32_t(r0);
        if(ver == 0)
        {
            uint32_t ver;
            std::string err;
            err = errnoErr(e1);
        }
        return {ver, err};
    }

    std::string initializeProcThreadAttributeList(_PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t attrcount, uint32_t flags, uintptr_t* size)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procInitializeProcThreadAttributeList)), 4, uintptr_t(unsafe::Pointer(attrlist)), uintptr_t(attrcount), uintptr_t(flags), uintptr_t(unsafe::Pointer(size)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> LoadLibrary(std::string libname)
    {
        Handle handle;
        std::string err;
        uint16_t* _p0 = {};
        std::tie(_p0, err) = UTF16PtrFromString(libname);
        if(err != nullptr)
        {
            Handle handle;
            std::string err;
            return {handle, err};
        }
        return _LoadLibrary(_p0);
    }

    std::tuple<Handle, std::string> _LoadLibrary(uint16_t* libname)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procLoadLibraryW)), 1, uintptr_t(unsafe::Pointer(libname)), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<Handle, std::string> LocalFree(Handle hmem)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procLocalFree)), 1, uintptr_t(hmem), 0, 0);
        handle = Handle(r0);
        if(handle != 0)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<uintptr_t, std::string> MapViewOfFile(Handle handle, uint32_t access, uint32_t offsetHigh, uint32_t offsetLow, uintptr_t length)
    {
        uintptr_t addr;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procMapViewOfFile)), 5, uintptr_t(handle), uintptr_t(access), uintptr_t(offsetHigh), uintptr_t(offsetLow), uintptr_t(length), 0);
        addr = uintptr_t(r0);
        if(addr == 0)
        {
            uintptr_t addr;
            std::string err;
            err = errnoErr(e1);
        }
        return {addr, err};
    }

    std::string MoveFile(uint16_t* from, uint16_t* to)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procMoveFileW)), 2, uintptr_t(unsafe::Pointer(from)), uintptr_t(unsafe::Pointer(to)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> OpenProcess(uint32_t da, bool inheritHandle, uint32_t pid)
    {
        Handle handle;
        std::string err;
        uint32_t _p0 = {};
        if(inheritHandle)
        {
            Handle handle;
            std::string err;
            _p0 = 1;
        }
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procOpenProcess)), 3, uintptr_t(da), uintptr_t(_p0), uintptr_t(pid));
        handle = Handle(r0);
        if(handle == 0)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::string postQueuedCompletionStatus(Handle cphandle, uint32_t qty, uintptr_t key, Overlapped* overlapped)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procPostQueuedCompletionStatus)), 4, uintptr_t(cphandle), uintptr_t(qty), uintptr_t(key), uintptr_t(unsafe::Pointer(overlapped)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string Process32First(Handle snapshot, ProcessEntry32* procEntry)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procProcess32FirstW)), 2, uintptr_t(snapshot), uintptr_t(unsafe::Pointer(procEntry)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string Process32Next(Handle snapshot, ProcessEntry32* procEntry)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procProcess32NextW)), 2, uintptr_t(snapshot), uintptr_t(unsafe::Pointer(procEntry)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string ReadConsole(Handle console, uint16_t* buf, uint32_t toread, uint32_t* read, unsigned char* inputControl)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procReadConsoleW)), 5, uintptr_t(console), uintptr_t(unsafe::Pointer(buf)), uintptr_t(toread), uintptr_t(unsafe::Pointer(read)), uintptr_t(unsafe::Pointer(inputControl)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string ReadDirectoryChanges(Handle handle, unsigned char* buf, uint32_t buflen, bool watchSubTree, uint32_t mask, uint32_t* retlen, Overlapped* overlapped, uintptr_t completionRoutine)
    {
        std::string err;
        uint32_t _p0 = {};
        if(watchSubTree)
        {
            std::string err;
            _p0 = 1;
        }
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procReadDirectoryChangesW)), 8, uintptr_t(handle), uintptr_t(unsafe::Pointer(buf)), uintptr_t(buflen), uintptr_t(_p0), uintptr_t(mask), uintptr_t(unsafe::Pointer(retlen)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(completionRoutine), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string readFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, Overlapped* overlapped)
    {
        std::string err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            std::string err;
            _p0 = & buf[0];
        }
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procReadFile)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(done)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string RemoveDirectory(uint16_t* path)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procRemoveDirectoryW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string SetCurrentDirectory(uint16_t* path)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procSetCurrentDirectoryW)), 1, uintptr_t(unsafe::Pointer(path)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string SetEndOfFile(Handle handle)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procSetEndOfFile)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string SetEnvironmentVariable(uint16_t* name, uint16_t* value)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procSetEnvironmentVariableW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(value)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string SetFileAttributes(uint16_t* name, uint32_t attrs)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procSetFileAttributesW)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(attrs), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string SetFileCompletionNotificationModes(Handle handle, uint8_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procSetFileCompletionNotificationModes)), 2, uintptr_t(handle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> SetFilePointer(Handle handle, int32_t lowoffset, int32_t* highoffsetptr, uint32_t whence)
    {
        uint32_t newlowoffset;
        std::string err;
        auto [r0, _, e1] = Syscall6(Addr(gocpp::recv(procSetFilePointer)), 4, uintptr_t(handle), uintptr_t(lowoffset), uintptr_t(unsafe::Pointer(highoffsetptr)), uintptr_t(whence), 0, 0);
        newlowoffset = uint32_t(r0);
        if(newlowoffset == 0xffffffff)
        {
            uint32_t newlowoffset;
            std::string err;
            err = errnoErr(e1);
        }
        return {newlowoffset, err};
    }

    std::string SetFileTime(Handle handle, Filetime* ctime, Filetime* atime, Filetime* wtime)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procSetFileTime)), 4, uintptr_t(handle), uintptr_t(unsafe::Pointer(ctime)), uintptr_t(unsafe::Pointer(atime)), uintptr_t(unsafe::Pointer(wtime)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string SetHandleInformation(Handle handle, uint32_t mask, uint32_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procSetHandleInformation)), 3, uintptr_t(handle), uintptr_t(mask), uintptr_t(flags));
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string TerminateProcess(Handle handle, uint32_t exitcode)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procTerminateProcess)), 2, uintptr_t(handle), uintptr_t(exitcode), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string UnmapViewOfFile(uintptr_t addr)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procUnmapViewOfFile)), 1, uintptr_t(addr), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string updateProcThreadAttribute(_PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t flags, uintptr_t attr, unsafe::Pointer value, uintptr_t size, unsafe::Pointer prevvalue, uintptr_t* returnedsize)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procUpdateProcThreadAttribute)), 7, uintptr_t(unsafe::Pointer(attrlist)), uintptr_t(flags), uintptr_t(attr), uintptr_t(value), uintptr_t(size), uintptr_t(prevvalue), uintptr_t(unsafe::Pointer(returnedsize)), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string VirtualLock(uintptr_t addr, uintptr_t length)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procVirtualLock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string VirtualUnlock(uintptr_t addr, uintptr_t length)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procVirtualUnlock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, std::string> WaitForSingleObject(Handle handle, uint32_t waitMilliseconds)
    {
        uint32_t event;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procWaitForSingleObject)), 2, uintptr_t(handle), uintptr_t(waitMilliseconds), 0);
        event = uint32_t(r0);
        if(event == 0xffffffff)
        {
            uint32_t event;
            std::string err;
            err = errnoErr(e1);
        }
        return {event, err};
    }

    std::string WriteConsole(Handle console, uint16_t* buf, uint32_t towrite, uint32_t* written, unsigned char* reserved)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procWriteConsoleW)), 5, uintptr_t(console), uintptr_t(unsafe::Pointer(buf)), uintptr_t(towrite), uintptr_t(unsafe::Pointer(written)), uintptr_t(unsafe::Pointer(reserved)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string writeFile(Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, Overlapped* overlapped)
    {
        std::string err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            std::string err;
            _p0 = & buf[0];
        }
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procWriteFile)), 5, uintptr_t(handle), uintptr_t(unsafe::Pointer(_p0)), uintptr_t(len(buf)), uintptr_t(unsafe::Pointer(done)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string AcceptEx(Handle ls, Handle as, unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, uint32_t* recvd, Overlapped* overlapped)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procAcceptEx)), 8, uintptr_t(ls), uintptr_t(as), uintptr_t(unsafe::Pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(overlapped)), 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    void GetAcceptExSockaddrs(unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, RawSockaddrAny** lrsa, int32_t* lrsalen, RawSockaddrAny** rrsa, int32_t* rrsalen)
    {
        Syscall9(Addr(gocpp::recv(procGetAcceptExSockaddrs)), 8, uintptr_t(unsafe::Pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(unsafe::Pointer(lrsa)), uintptr_t(unsafe::Pointer(lrsalen)), uintptr_t(unsafe::Pointer(rrsa)), uintptr_t(unsafe::Pointer(rrsalen)), 0);
        return;
    }

    std::string TransmitFile(Handle s, Handle handle, uint32_t bytesToWrite, uint32_t bytsPerSend, Overlapped* overlapped, TransmitFileBuffers* transmitFileBuf, uint32_t flags)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procTransmitFile)), 7, uintptr_t(s), uintptr_t(handle), uintptr_t(bytesToWrite), uintptr_t(bytsPerSend), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(transmitFileBuf)), uintptr_t(flags), 0, 0);
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string NetApiBufferFree(unsigned char* buf)
    {
        std::string neterr;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procNetApiBufferFree)), 1, uintptr_t(unsafe::Pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            std::string neterr;
            neterr = Errno(r0);
        }
        return neterr;
    }

    std::string NetGetJoinInformation(uint16_t* server, uint16_t** name, uint32_t* bufType)
    {
        std::string neterr;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procNetGetJoinInformation)), 3, uintptr_t(unsafe::Pointer(server)), uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(bufType)));
        if(r0 != 0)
        {
            std::string neterr;
            neterr = Errno(r0);
        }
        return neterr;
    }

    std::string NetUserGetInfo(uint16_t* serverName, uint16_t* userName, uint32_t level, unsigned char** buf)
    {
        std::string neterr;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall6(Addr(gocpp::recv(procNetUserGetInfo)), 4, uintptr_t(unsafe::Pointer(serverName)), uintptr_t(unsafe::Pointer(userName)), uintptr_t(level), uintptr_t(unsafe::Pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            std::string neterr;
            neterr = Errno(r0);
        }
        return neterr;
    }

    void rtlGetNtVersionNumbers(uint32_t* majorVersion, uint32_t* minorVersion, uint32_t* buildNumber)
    {
        Syscall(Addr(gocpp::recv(procRtlGetNtVersionNumbers)), 3, uintptr_t(unsafe::Pointer(majorVersion)), uintptr_t(unsafe::Pointer(minorVersion)), uintptr_t(unsafe::Pointer(buildNumber)));
        return;
    }

    std::string GetUserNameEx(uint32_t nameFormat, uint16_t* nameBuffre, uint32_t* nSize)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetUserNameExW)), 3, uintptr_t(nameFormat), uintptr_t(unsafe::Pointer(nameBuffre)), uintptr_t(unsafe::Pointer(nSize)));
        if(r1 & 0xff == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string TranslateName(uint16_t* accName, uint32_t accNameFormat, uint32_t desiredNameFormat, uint16_t* translatedName, uint32_t* nSize)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procTranslateNameW)), 5, uintptr_t(unsafe::Pointer(accName)), uintptr_t(accNameFormat), uintptr_t(desiredNameFormat), uintptr_t(unsafe::Pointer(translatedName)), uintptr_t(unsafe::Pointer(nSize)), 0);
        if(r1 & 0xff == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*, std::string> CommandLineToArgv(uint16_t* cmd, int32_t* argc)
    {
        gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>* argv;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procCommandLineToArgvW)), 2, uintptr_t(unsafe::Pointer(cmd)), uintptr_t(unsafe::Pointer(argc)), 0);
        argv = (gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>*)(unsafe::Pointer(r0));
        if(argv == nullptr)
        {
            gocpp::array<gocpp::array<uint16_t, 8192>*, 8192>* argv;
            std::string err;
            err = errnoErr(e1);
        }
        return {argv, err};
    }

    std::string GetUserProfileDirectory(Token t, uint16_t* dir, uint32_t* dirLen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procGetUserProfileDirectoryW)), 3, uintptr_t(t), uintptr_t(unsafe::Pointer(dir)), uintptr_t(unsafe::Pointer(dirLen)));
        if(r1 == 0)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    void FreeAddrInfoW(AddrinfoW* addrinfo)
    {
        Syscall(Addr(gocpp::recv(procFreeAddrInfoW)), 1, uintptr_t(unsafe::Pointer(addrinfo)), 0, 0);
        return;
    }

    std::string GetAddrInfoW(uint16_t* nodename, uint16_t* servicename, AddrinfoW* hints, AddrinfoW** result)
    {
        std::string sockerr;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall6(Addr(gocpp::recv(procGetAddrInfoW)), 4, uintptr_t(unsafe::Pointer(nodename)), uintptr_t(unsafe::Pointer(servicename)), uintptr_t(unsafe::Pointer(hints)), uintptr_t(unsafe::Pointer(result)), 0, 0);
        if(r0 != 0)
        {
            std::string sockerr;
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    std::string WSACleanup()
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procWSACleanup)), 0, 0, 0, 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<int32_t, std::string> WSAEnumProtocols(int32_t* protocols, WSAProtocolInfo* protocolBuffer, uint32_t* bufferLength)
    {
        int32_t n;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procWSAEnumProtocolsW)), 3, uintptr_t(unsafe::Pointer(protocols)), uintptr_t(unsafe::Pointer(protocolBuffer)), uintptr_t(unsafe::Pointer(bufferLength)));
        n = int32_t(r0);
        if(n == - 1)
        {
            int32_t n;
            std::string err;
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::string WSAIoctl(Handle s, uint32_t iocc, unsigned char* inbuf, uint32_t cbif, unsigned char* outbuf, uint32_t cbob, uint32_t* cbbr, Overlapped* overlapped, uintptr_t completionRoutine)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procWSAIoctl)), 9, uintptr_t(s), uintptr_t(iocc), uintptr_t(unsafe::Pointer(inbuf)), uintptr_t(cbif), uintptr_t(unsafe::Pointer(outbuf)), uintptr_t(cbob), uintptr_t(unsafe::Pointer(cbbr)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(completionRoutine));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string WSARecv(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procWSARecv)), 7, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(flags)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string WSARecvFrom(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, RawSockaddrAny* from, int32_t* fromlen, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procWSARecvFrom)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(recvd)), uintptr_t(unsafe::Pointer(flags)), uintptr_t(unsafe::Pointer(from)), uintptr_t(unsafe::Pointer(fromlen)), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string WSASend(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procWSASend)), 7, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string WSASendTo(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, RawSockaddrAny* to, int32_t tolen, Overlapped* overlapped, unsigned char* croutine)
    {
        std::string err;
        auto [r1, _, e1] = Syscall9(Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(to)), uintptr_t(tolen), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string WSAStartup(uint32_t verreq, WSAData* data)
    {
        std::string sockerr;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procWSAStartup)), 2, uintptr_t(verreq), uintptr_t(unsafe::Pointer(data)), 0);
        if(r0 != 0)
        {
            std::string sockerr;
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    std::string bind(Handle s, unsafe::Pointer name, int32_t namelen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procbind)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string Closesocket(Handle s)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procclosesocket)), 1, uintptr_t(s), 0, 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string connect(Handle s, unsafe::Pointer name, int32_t namelen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procconnect)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Hostent*, std::string> GetHostByName(std::string name)
    {
        Hostent* h;
        std::string err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            Hostent* h;
            std::string err;
            return {h, err};
        }
        return _GetHostByName(_p0);
    }

    std::tuple<Hostent*, std::string> _GetHostByName(unsigned char* name)
    {
        Hostent* h;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procgethostbyname)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        h = (Hostent*)(unsafe::Pointer(r0));
        if(h == nullptr)
        {
            Hostent* h;
            std::string err;
            err = errnoErr(e1);
        }
        return {h, err};
    }

    std::string getpeername(Handle s, RawSockaddrAny* rsa, int32_t* addrlen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procgetpeername)), 3, uintptr_t(s), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(unsafe::Pointer(addrlen)));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Protoent*, std::string> GetProtoByName(std::string name)
    {
        Protoent* p;
        std::string err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            Protoent* p;
            std::string err;
            return {p, err};
        }
        return _GetProtoByName(_p0);
    }

    std::tuple<Protoent*, std::string> _GetProtoByName(unsigned char* name)
    {
        Protoent* p;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procgetprotobyname)), 1, uintptr_t(unsafe::Pointer(name)), 0, 0);
        p = (Protoent*)(unsafe::Pointer(r0));
        if(p == nullptr)
        {
            Protoent* p;
            std::string err;
            err = errnoErr(e1);
        }
        return {p, err};
    }

    std::tuple<Servent*, std::string> GetServByName(std::string name, std::string proto)
    {
        Servent* s;
        std::string err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            Servent* s;
            std::string err;
            return {s, err};
        }
        unsigned char* _p1 = {};
        std::tie(_p1, err) = BytePtrFromString(proto);
        if(err != nullptr)
        {
            Servent* s;
            std::string err;
            return {s, err};
        }
        return _GetServByName(_p0, _p1);
    }

    std::tuple<Servent*, std::string> _GetServByName(unsigned char* name, unsigned char* proto)
    {
        Servent* s;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procgetservbyname)), 2, uintptr_t(unsafe::Pointer(name)), uintptr_t(unsafe::Pointer(proto)), 0);
        s = (Servent*)(unsafe::Pointer(r0));
        if(s == nullptr)
        {
            Servent* s;
            std::string err;
            err = errnoErr(e1);
        }
        return {s, err};
    }

    std::string getsockname(Handle s, RawSockaddrAny* rsa, int32_t* addrlen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procgetsockname)), 3, uintptr_t(s), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(unsafe::Pointer(addrlen)));
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string Getsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t* optlen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procgetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(unsafe::Pointer(optval)), uintptr_t(unsafe::Pointer(optlen)), 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string listen(Handle s, int32_t backlog)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(proclisten)), 2, uintptr_t(s), uintptr_t(backlog), 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t Ntohs(uint16_t netshort)
    {
        uint16_t u;
        uintptr_t r0;
        uintptr_t _;
        Errno _;
        std::tie(r0, _, _) = Syscall(Addr(gocpp::recv(procntohs)), 1, uintptr_t(netshort), 0, 0);
        u = uint16_t(r0);
        return u;
    }

    std::string Setsockopt(Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t optlen)
    {
        std::string err;
        auto [r1, _, e1] = Syscall6(Addr(gocpp::recv(procsetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(unsafe::Pointer(optval)), uintptr_t(optlen), 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::string shutdown(Handle s, int32_t how)
    {
        std::string err;
        auto [r1, _, e1] = Syscall(Addr(gocpp::recv(procshutdown)), 2, uintptr_t(s), uintptr_t(how), 0);
        if(r1 == socket_error)
        {
            std::string err;
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<Handle, std::string> socket(int32_t af, int32_t typ, int32_t protocol)
    {
        Handle handle;
        std::string err;
        auto [r0, _, e1] = Syscall(Addr(gocpp::recv(procsocket)), 3, uintptr_t(af), uintptr_t(typ), uintptr_t(protocol));
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            Handle handle;
            std::string err;
            err = errnoErr(e1);
        }
        return {handle, err};
    }

}

