// generated by GoCpp from file '$(ImportDir)/runtime/trace2runtime.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2runtime.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::Load;
    }

    // gTraceState is per-G state for the tracer.
    
    template<typename T> requires gocpp::GoStruct<T>
    gTraceState::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gTraceState::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gTraceState& value)
    {
        return value.PrintTo(os);
    }

    // reset resets the gTraceState for a new goroutine.
    void rec::reset(struct gTraceState* s)
    {
        s->seq = gocpp::array<uint64_t, 2> {};
    }

    // mTraceState is per-M state for the tracer.
    
    template<typename T> requires gocpp::GoStruct<T>
    mTraceState::operator T()
    {
        T result;
        result.seqlock = this->seqlock;
        result.buf = this->buf;
        result.link = this->link;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mTraceState::operator==(const T& ref) const
    {
        if (seqlock != ref.seqlock) return false;
        if (buf != ref.buf) return false;
        if (link != ref.link) return false;
        return true;
    }

    std::ostream& mTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << seqlock;
        os << " " << buf;
        os << " " << link;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mTraceState& value)
    {
        return value.PrintTo(os);
    }

    // pTraceState is per-P state for the tracer.
    
    template<typename T> requires gocpp::GoStruct<T>
    pTraceState::operator T()
    {
        T result;
        result.mSyscallID = this->mSyscallID;
        result.maySweep = this->maySweep;
        result.inSweep = this->inSweep;
        result.swept = this->swept;
        result.reclaimed = this->reclaimed;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pTraceState::operator==(const T& ref) const
    {
        if (mSyscallID != ref.mSyscallID) return false;
        if (maySweep != ref.maySweep) return false;
        if (inSweep != ref.inSweep) return false;
        if (swept != ref.swept) return false;
        if (reclaimed != ref.reclaimed) return false;
        return true;
    }

    std::ostream& pTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mSyscallID;
        os << " " << maySweep;
        os << " " << inSweep;
        os << " " << swept;
        os << " " << reclaimed;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pTraceState& value)
    {
        return value.PrintTo(os);
    }

    // traceLockInit initializes global trace locks.
    void traceLockInit()
    {
        lockInit(& trace.stringTab[0].lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[0].tab.lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[1].lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[1].tab.lock, lockRankTraceStrings);
        lockInit(& trace.stackTab[0].tab.lock, lockRankTraceStackTab);
        lockInit(& trace.stackTab[1].tab.lock, lockRankTraceStackTab);
        lockInit(& trace.lock, lockRankTrace);
    }

    // lockRankMayTraceFlush records the lock ranking effects of a
    // potential call to traceFlush.
    //
    // nosplit because traceAcquire is nosplit.
    //
    //go:nosplit
    void lockRankMayTraceFlush()
    {
        lockWithRankMayAcquire(& trace.lock, getLockRank(& trace.lock));
    }

    // traceBlockReason is an enumeration of reasons a goroutine might block.
    // This is the interface the rest of the runtime uses to tell the
    // tracer why a goroutine blocked. The tracer then propagates this information
    // into the trace however it sees fit.
    //
    // Note that traceBlockReasons should not be compared, since reasons that are
    // distinct by name may *not* be distinct by value.
    gocpp::array<std::string, 15> traceBlockReasonStrings = gocpp::Init<gocpp::array<std::string, 15>>([](auto& x) {
        x[traceBlockGeneric] = "unspecified"s;
        x[traceBlockForever] = "forever"s;
        x[traceBlockNet] = "network"s;
        x[traceBlockSelect] = "select"s;
        x[traceBlockCondWait] = "sync.(*Cond).Wait"s;
        x[traceBlockSync] = "sync"s;
        x[traceBlockChanSend] = "chan send"s;
        x[traceBlockChanRecv] = "chan receive"s;
        x[traceBlockGCMarkAssist] = "GC mark assist wait for work"s;
        x[traceBlockGCSweep] = "GC background sweeper wait"s;
        x[traceBlockSystemGoroutine] = "system goroutine wait"s;
        x[traceBlockPreempted] = "preempted"s;
        x[traceBlockDebugCall] = "wait for debug call"s;
        x[traceBlockUntilGCEnds] = "wait until GC ends"s;
        x[traceBlockSleep] = "sleep"s;
    });
    // traceGoStopReason is an enumeration of reasons a goroutine might yield.
    //
    // Note that traceGoStopReasons should not be compared, since reasons that are
    // distinct by name may *not* be distinct by value.
    gocpp::array<std::string, 3> traceGoStopReasonStrings = gocpp::Init<gocpp::array<std::string, 3>>([](auto& x) {
        x[traceGoStopGeneric] = "unspecified"s;
        x[traceGoStopGoSched] = "runtime.Gosched"s;
        x[traceGoStopPreempted] = "preempted"s;
    });
    // traceEnabled returns true if the trace is currently enabled.
    //
    //go:nosplit
    bool traceEnabled()
    {
        return rec::Load(gocpp::recv(trace.gen)) != 0;
    }

    // traceShuttingDown returns true if the trace is currently shutting down.
    bool traceShuttingDown()
    {
        return rec::Load(gocpp::recv(trace.shutdown));
    }

    // traceLocker represents an M writing trace events. While a traceLocker value
    // is valid, the tracer observes all operations on the G/M/P or trace events being
    // written as happening atomically.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceLocker::operator T()
    {
        T result;
        result.mp = this->mp;
        result.gen = this->gen;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceLocker::operator==(const T& ref) const
    {
        if (mp != ref.mp) return false;
        if (gen != ref.gen) return false;
        return true;
    }

    std::ostream& traceLocker::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mp;
        os << " " << gen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceLocker& value)
    {
        return value.PrintTo(os);
    }

    // debugTraceReentrancy checks if the trace is reentrant.
    //
    // This is optional because throwing in a function makes it instantly
    // not inlineable, and we want traceAcquire to be inlineable for
    // low overhead when the trace is disabled.
    // traceAcquire prepares this M for writing one or more trace events.
    //
    // nosplit because it's called on the syscall path when stack movement is forbidden.
    //
    //go:nosplit
    struct traceLocker traceAcquire()
    {
        if(! traceEnabled())
        {
            return traceLocker {};
        }
        return traceAcquireEnabled();
    }

    // traceAcquireEnabled is the traceEnabled path for traceAcquire. It's explicitly
    // broken out to make traceAcquire inlineable to keep the overhead of the tracer
    // when it's disabled low.
    //
    // nosplit because it's called by traceAcquire, which is nosplit.
    //
    //go:nosplit
    struct traceLocker traceAcquireEnabled()
    {
        lockRankMayTraceFlush();
        auto mp = acquirem();
        auto seq = rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 1)
        {
            go_throw("bad use of trace.seqlock or tracer is reentrant"s);
        }
        auto gen = rec::Load(gocpp::recv(trace.gen));
        if(gen == 0)
        {
            rec::Add(gocpp::recv(mp->trace.seqlock), 1);
            releasem(mp);
            return traceLocker {};
        }
        return traceLocker {mp, gen};
    }

    // ok returns true if the traceLocker is valid (i.e. tracing is enabled).
    //
    // nosplit because it's called on the syscall path when stack movement is forbidden.
    //
    //go:nosplit
    bool rec::ok(struct traceLocker tl)
    {
        return tl.gen != 0;
    }

    // traceRelease indicates that this M is done writing trace events.
    //
    // nosplit because it's called on the syscall path when stack movement is forbidden.
    //
    //go:nosplit
    void traceRelease(struct traceLocker tl)
    {
        auto seq = rec::Add(gocpp::recv(tl.mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 0)
        {
            print("runtime: seq="s, seq, "\n"s);
            go_throw("bad use of trace.seqlock"s);
        }
        releasem(tl.mp);
    }

    // traceExitingSyscall marks a goroutine as exiting the syscall slow path.
    //
    // Must be paired with a traceExitedSyscall call.
    void traceExitingSyscall()
    {
        rec::Add(gocpp::recv(trace.exitingSyscall), 1);
    }

    // traceExitedSyscall marks a goroutine as having exited the syscall slow path.
    void traceExitedSyscall()
    {
        rec::Add(gocpp::recv(trace.exitingSyscall), - 1);
    }

    // Gomaxprocs emits a ProcsChange event.
    void rec::Gomaxprocs(struct traceLocker tl, int32_t procs)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvProcsChange, traceArg(procs), rec::stack(gocpp::recv(tl), 1));
    }

    // ProcStart traces a ProcStart event.
    //
    // Must be called with a valid P.
    void rec::ProcStart(struct traceLocker tl)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcIdle)), traceEvProcStart, traceArg(pp->id), rec::nextSeq(gocpp::recv(pp->trace), tl.gen));
    }

    // ProcStop traces a ProcStop event.
    void rec::ProcStop(struct traceLocker tl, struct p* pp)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcRunning)), traceEvProcStop);
    }

    // GCActive traces a GCActive event.
    //
    // Must be emitted by an actively running goroutine on an active P. This restriction can be changed
    // easily and only depends on where it's currently called.
    void rec::GCActive(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCActive, traceArg(trace.seqGC));
        trace.seqGC++;
    }

    // GCStart traces a GCBegin event.
    //
    // Must be emitted by an actively running goroutine on an active P. This restriction can be changed
    // easily and only depends on where it's currently called.
    void rec::GCStart(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCBegin, traceArg(trace.seqGC), rec::stack(gocpp::recv(tl), 3));
        trace.seqGC++;
    }

    // GCDone traces a GCEnd event.
    //
    // Must be emitted by an actively running goroutine on an active P. This restriction can be changed
    // easily and only depends on where it's currently called.
    void rec::GCDone(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCEnd, traceArg(trace.seqGC));
        trace.seqGC++;
    }

    // STWStart traces a STWBegin event.
    void rec::STWStart(struct traceLocker tl, golang::runtime::stwReason reason)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvSTWBegin, rec::string(gocpp::recv(tl), rec::String(gocpp::recv(reason))), rec::stack(gocpp::recv(tl), 2));
    }

    // STWDone traces a STWEnd event.
    void rec::STWDone(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvSTWEnd);
    }

    // GCSweepStart prepares to trace a sweep loop. This does not
    // emit any events until traceGCSweepSpan is called.
    //
    // GCSweepStart must be paired with traceGCSweepDone and there
    // must be no preemption points between these two calls.
    //
    // Must be called with a valid P.
    void rec::GCSweepStart(struct traceLocker tl)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        if(pp->trace.maySweep)
        {
            go_throw("double traceGCSweepStart"s);
        }
        std::tie(pp->trace.maySweep, pp->trace.swept, pp->trace.reclaimed) = std::tuple{true, 0, 0};
    }

    // GCSweepSpan traces the sweep of a single span. If this is
    // the first span swept since traceGCSweepStart was called, this
    // will emit a GCSweepBegin event.
    //
    // This may be called outside a traceGCSweepStart/traceGCSweepDone
    // pair; however, it will not emit any trace events in this case.
    //
    // Must be called with a valid P.
    void rec::GCSweepSpan(struct traceLocker tl, uintptr_t bytesSwept)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        if(pp->trace.maySweep)
        {
            if(pp->trace.swept == 0)
            {
                rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCSweepBegin, rec::stack(gocpp::recv(tl), 1));
                pp->trace.inSweep = true;
            }
            pp->trace.swept += bytesSwept;
        }
    }

    // GCSweepDone finishes tracing a sweep loop. If any memory was
    // swept (i.e. traceGCSweepSpan emitted an event) then this will emit
    // a GCSweepEnd event.
    //
    // Must be called with a valid P.
    void rec::GCSweepDone(struct traceLocker tl)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        if(! pp->trace.maySweep)
        {
            go_throw("missing traceGCSweepStart"s);
        }
        if(pp->trace.inSweep)
        {
            rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCSweepEnd, traceArg(pp->trace.swept), traceArg(pp->trace.reclaimed));
            pp->trace.inSweep = false;
        }
        pp->trace.maySweep = false;
    }

    // GCMarkAssistStart emits a MarkAssistBegin event.
    void rec::GCMarkAssistStart(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCMarkAssistBegin, rec::stack(gocpp::recv(tl), 1));
    }

    // GCMarkAssistDone emits a MarkAssistEnd event.
    void rec::GCMarkAssistDone(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCMarkAssistEnd);
    }

    // GoCreate emits a GoCreate event.
    void rec::GoCreate(struct traceLocker tl, struct g* newg, uintptr_t pc)
    {
        rec::setStatusTraced(gocpp::recv(newg->trace), tl.gen);
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoCreate, traceArg(newg->goid), rec::startPC(gocpp::recv(tl), pc), rec::stack(gocpp::recv(tl), 2));
    }

    // GoStart emits a GoStart event.
    //
    // Must be called with a valid P.
    void rec::GoStart(struct traceLocker tl)
    {
        auto gp = getg()->m->curg;
        auto pp = gp->m->p;
        auto w = rec::eventWriter(gocpp::recv(tl), traceGoRunnable, traceProcRunning);
        w = rec::write(gocpp::recv(w), traceEvGoStart, traceArg(gp->goid), rec::nextSeq(gocpp::recv(gp->trace), tl.gen));
        if(rec::ptr(gocpp::recv(pp))->gcMarkWorkerMode != gcMarkWorkerNotWorker)
        {
            w = rec::write(gocpp::recv(w), traceEvGoLabel, trace.markWorkerLabels[tl.gen % 2][rec::ptr(gocpp::recv(pp))->gcMarkWorkerMode]);
        }
        rec::end(gocpp::recv(w));
    }

    // GoEnd emits a GoDestroy event.
    //
    // TODO(mknyszek): Rename this to GoDestroy.
    void rec::GoEnd(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoDestroy);
    }

    // GoSched emits a GoStop event with a GoSched reason.
    void rec::GoSched(struct traceLocker tl)
    {
        rec::GoStop(gocpp::recv(tl), traceGoStopGoSched);
    }

    // GoPreempt emits a GoStop event with a GoPreempted reason.
    void rec::GoPreempt(struct traceLocker tl)
    {
        rec::GoStop(gocpp::recv(tl), traceGoStopPreempted);
    }

    // GoStop emits a GoStop event with the provided reason.
    void rec::GoStop(struct traceLocker tl, golang::runtime::traceGoStopReason reason)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoStop, traceArg(trace.goStopReasons[tl.gen % 2][reason]), rec::stack(gocpp::recv(tl), 1));
    }

    // GoPark emits a GoBlock event with the provided reason.
    //
    // TODO(mknyszek): Replace traceBlockReason with waitReason. It's silly
    // that we have both, and waitReason is way more descriptive.
    void rec::GoPark(struct traceLocker tl, golang::runtime::traceBlockReason reason, int skip)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoBlock, traceArg(trace.goBlockReasons[tl.gen % 2][reason]), rec::stack(gocpp::recv(tl), skip));
    }

    // GoUnpark emits a GoUnblock event.
    void rec::GoUnpark(struct traceLocker tl, struct g* gp, int skip)
    {
        auto w = rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning);
        if(! rec::statusWasTraced(gocpp::recv(gp->trace), tl.gen) && rec::acquireStatus(gocpp::recv(gp->trace), tl.gen))
        {
            w.w = rec::writeGoStatus(gocpp::recv(w.w), gp->goid, - 1, traceGoWaiting, gp->inMarkAssist);
        }
        rec::commit(gocpp::recv(w), traceEvGoUnblock, traceArg(gp->goid), rec::nextSeq(gocpp::recv(gp->trace), tl.gen), rec::stack(gocpp::recv(tl), skip));
    }

    // GoSysCall emits a GoSyscallBegin event.
    //
    // Must be called with a valid P.
    void rec::GoSysCall(struct traceLocker tl)
    {
        int skip = {};
        //Go switch emulation
        {
            int conditionId = -1;
            if(tracefpunwindoff()) { conditionId = 0; }
            else if(GOOS == "solaris"s || GOOS == "illumos"s) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    skip = 1;
                    break;
                case 1:
                    skip = 3;
                    break;
                default:
                    skip = 4;
                    break;
            }
        }
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        pp->trace.mSyscallID = int64_t(tl.mp->procid);
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoSyscallBegin, rec::nextSeq(gocpp::recv(pp->trace), tl.gen), rec::stack(gocpp::recv(tl), skip));
    }

    // GoSysExit emits a GoSyscallEnd event, possibly along with a GoSyscallBlocked event
    // if lostP is true.
    //
    // lostP must be true in all cases that a goroutine loses its P during a syscall.
    // This means it's not sufficient to check if it has no P. In particular, it needs to be
    // true in the following cases:
    // - The goroutine lost its P, it ran some other code, and then got it back. It's now running with that P.
    // - The goroutine lost its P and was unable to reacquire it, and is now running without a P.
    // - The goroutine lost its P and acquired a different one, and is now running with that P.
    void rec::GoSysExit(struct traceLocker tl, bool lostP)
    {
        auto ev = traceEvGoSyscallEnd;
        auto procStatus = traceProcSyscall;
        if(lostP)
        {
            ev = traceEvGoSyscallEndBlocked;
            procStatus = traceProcRunning;
        }
        else
        {
            rec::ptr(gocpp::recv(tl.mp->p))->trace.mSyscallID = - 1;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, procStatus)), ev);
    }

    // ProcSteal indicates that our current M stole a P from another M.
    //
    // inSyscall indicates that we're stealing the P from a syscall context.
    //
    // The caller must have ownership of pp.
    void rec::ProcSteal(struct traceLocker tl, struct p* pp, bool inSyscall)
    {
        auto mStolenFrom = pp->trace.mSyscallID;
        pp->trace.mSyscallID = - 1;
        auto goStatus = traceGoRunning;
        auto procStatus = traceProcRunning;
        if(inSyscall)
        {
            goStatus = traceGoSyscall;
            procStatus = traceProcSyscallAbandoned;
        }
        auto w = rec::eventWriter(gocpp::recv(tl), goStatus, procStatus);
        if(! rec::statusWasTraced(gocpp::recv(pp->trace), tl.gen) && rec::acquireStatus(gocpp::recv(pp->trace), tl.gen))
        {
            w.w = rec::writeProcStatus(gocpp::recv(w.w), uint64_t(pp->id), traceProcSyscallAbandoned, pp->trace.inSweep);
        }
        rec::commit(gocpp::recv(w), traceEvProcSteal, traceArg(pp->id), rec::nextSeq(gocpp::recv(pp->trace), tl.gen), traceArg(mStolenFrom));
    }

    // GoSysBlock is a no-op in the new tracer.
    void rec::GoSysBlock(struct traceLocker tl, struct p* pp)
    {
    }

    // HeapAlloc emits a HeapAlloc event.
    void rec::HeapAlloc(struct traceLocker tl, uint64_t live)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvHeapAlloc, traceArg(live));
    }

    // HeapGoal reads the current heap goal and emits a HeapGoal event.
    void rec::HeapGoal(struct traceLocker tl)
    {
        auto heapGoal = rec::heapGoal(gocpp::recv(gcController));
        if(heapGoal == ~ uint64_t(0))
        {
            heapGoal = 0;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvHeapGoal, traceArg(heapGoal));
    }

    // OneNewExtraM is a no-op in the new tracer. This is worth keeping around though because
    // it's a good place to insert a thread-level event about the new extra M.
    void rec::OneNewExtraM(struct traceLocker tl, struct g* _1)
    {
    }

    // GoCreateSyscall indicates that a goroutine has transitioned from dead to GoSyscall.
    //
    // Unlike GoCreate, the caller must be running on gp.
    //
    // This occurs when C code calls into Go. On pthread platforms it occurs only when
    // a C thread calls into Go code for the first time.
    void rec::GoCreateSyscall(struct traceLocker tl, struct g* gp)
    {
        rec::setStatusTraced(gocpp::recv(gp->trace), tl.gen);
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoBad, traceProcBad)), traceEvGoCreateSyscall, traceArg(gp->goid));
    }

    // GoDestroySyscall indicates that a goroutine has transitioned from GoSyscall to dead.
    //
    // Must not have a P.
    //
    // This occurs when Go code returns back to C. On pthread platforms it occurs only when
    // the C thread is destroyed.
    void rec::GoDestroySyscall(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcBad)), traceEvGoDestroySyscall);
    }

    // trace_userTaskCreate emits a UserTaskCreate event.
    //
    //go:linkname trace_userTaskCreate runtime/trace.userTaskCreate
    void trace_userTaskCreate(uint64_t id, uint64_t parentID, std::string taskType)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserTaskBegin, traceArg(id), traceArg(parentID), rec::string(gocpp::recv(tl), taskType), rec::stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    // trace_userTaskEnd emits a UserTaskEnd event.
    //
    //go:linkname trace_userTaskEnd runtime/trace.userTaskEnd
    void trace_userTaskEnd(uint64_t id)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserTaskEnd, traceArg(id), rec::stack(gocpp::recv(tl), 2));
        traceRelease(tl);
    }

    // trace_userTaskEnd emits a UserRegionBegin or UserRegionEnd event,
    // depending on mode (0 == Begin, 1 == End).
    //
    // TODO(mknyszek): Just make this two functions.
    //
    //go:linkname trace_userRegion runtime/trace.userRegion
    void trace_userRegion(uint64_t id, uint64_t mode, std::string name)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        runtime::traceEv ev = {};
        //Go switch emulation
        {
            auto condition = mode;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    ev = traceEvUserRegionBegin;
                    break;
                case 1:
                    ev = traceEvUserRegionEnd;
                    break;
                default:
                    return;
                    break;
            }
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), ev, traceArg(id), rec::string(gocpp::recv(tl), name), rec::stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    // trace_userTaskEnd emits a UserRegionBegin or UserRegionEnd event.
    //
    //go:linkname trace_userLog runtime/trace.userLog
    void trace_userLog(uint64_t id, std::string category, std::string message)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserLog, traceArg(id), rec::string(gocpp::recv(tl), category), rec::uniqueString(gocpp::recv(tl), message), rec::stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    // traceProcFree is called when a P is destroyed.
    //
    // This must run on the system stack to match the old tracer.
    //
    //go:systemstack
    void traceProcFree(struct p* _1)
    {
    }

    // traceThreadDestroy is called when a thread is removed from
    // sched.freem.
    //
    // mp must not be able to emit trace events anymore.
    //
    // sched.lock must be held to synchronize with traceAdvance.
    void traceThreadDestroy(struct m* mp)
    {
        assertLockHeld(& sched.lock);
        auto seq = rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 1)
        {
            go_throw("bad use of trace.seqlock or tracer is reentrant"s);
        }
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            for(auto [i, gocpp_ignored] : mp->trace.buf)
            {
                if(mp->trace.buf[i] != nullptr)
                {
                    traceBufFlush(mp->trace.buf[i], uintptr_t(i));
                    mp->trace.buf[i] = nullptr;
                }
            }
            unlock(& trace.lock);
        });
        auto seq1 = rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        if(seq1 != seq + 1)
        {
            print("runtime: seq1="s, seq1, "\n"s);
            go_throw("bad use of trace.seqlock"s);
        }
    }

    // Not used in the new tracer; solely for compatibility with the old tracer.
    // nosplit because it's called from exitsyscall without a P.
    //
    //go:nosplit
    void rec::RecordSyscallExitedTime(struct traceLocker _1, struct g* _1, struct p* _2)
    {
    }

}

