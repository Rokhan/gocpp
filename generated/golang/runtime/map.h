// generated by GoCpp from file '$(ImportDir)/runtime/map.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/map.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/slice.h"

namespace golang::runtime
{
    bool isEmpty(uint8_t x);
    struct hmap
    {
        int count;
        uint8_t flags;
        uint8_t B;
        uint16_t noverflow;
        uint32_t hash0;
        unsafe::Pointer buckets;
        unsafe::Pointer oldbuckets;
        uintptr_t nevacuate;
        mapextra* extra;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hmap& value);
    struct mapextra
    {
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        bmap* nextOverflow;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapextra& value);
    struct bmap
    {
        gocpp::array<uint8_t, bucketCnt> tophash;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bmap& value);
    struct hiter
    {
        unsafe::Pointer key;
        unsafe::Pointer elem;
        maptype* t;
        hmap* h;
        unsafe::Pointer buckets;
        bmap* bptr;
        gocpp::slice<bmap*>* overflow;
        gocpp::slice<bmap*>* oldoverflow;
        uintptr_t startBucket;
        uint8_t offset;
        bool wrapped;
        uint8_t B;
        uint8_t i;
        uintptr_t bucket;
        uintptr_t checkBucket;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hiter& value);
    uintptr_t bucketShift(uint8_t b);
    uintptr_t bucketMask(uint8_t b);
    uint8_t tophash(uintptr_t hash);
    bool evacuated(struct bmap* b);
    struct bmap* overflow(struct bmap* b, struct maptype* t);
    void setoverflow(struct bmap* b, struct maptype* t, struct bmap* ovf);
    unsafe::Pointer keys(struct bmap* b);
    void incrnoverflow(struct hmap* h);
    struct bmap* newoverflow(struct hmap* h, struct maptype* t, struct bmap* b);
    void createOverflow(struct hmap* h);
    struct hmap* makemap64(struct maptype* t, int64_t hint, struct hmap* h);
    struct hmap* makemap_small();
    struct hmap* makemap(struct maptype* t, int hint, struct hmap* h);
    std::tuple<unsafe::Pointer, struct bmap*> makeBucketArray(struct maptype* t, uint8_t b, unsafe::Pointer dirtyalloc);
    unsafe::Pointer mapaccess1(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    std::tuple<unsafe::Pointer, bool> mapaccess2(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    std::tuple<unsafe::Pointer, unsafe::Pointer> mapaccessK(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    unsafe::Pointer mapaccess1_fat(struct maptype* t, struct hmap* h, unsafe::Pointer key, unsafe::Pointer zero);
    std::tuple<unsafe::Pointer, bool> mapaccess2_fat(struct maptype* t, struct hmap* h, unsafe::Pointer key, unsafe::Pointer zero);
    unsafe::Pointer mapassign(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    void mapdelete(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    void mapiterinit(struct maptype* t, struct hmap* h, struct hiter* it);
    void mapiternext(struct hiter* it);
    void mapclear(struct maptype* t, struct hmap* h);
    void hashGrow(struct maptype* t, struct hmap* h);
    bool overLoadFactor(int count, uint8_t B);
    bool tooManyOverflowBuckets(uint16_t noverflow, uint8_t B);
    bool growing(struct hmap* h);
    bool sameSizeGrow(struct hmap* h);
    uintptr_t noldbuckets(struct hmap* h);
    uintptr_t oldbucketmask(struct hmap* h);
    void growWork(struct maptype* t, struct hmap* h, uintptr_t bucket);
    bool bucketEvacuated(struct maptype* t, struct hmap* h, uintptr_t bucket);
    struct evacDst
    {
        bmap* b;
        int i;
        unsafe::Pointer k;
        unsafe::Pointer e;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct evacDst& value);
    void evacuate(struct maptype* t, struct hmap* h, uintptr_t oldbucket);
    void advanceEvacuationMark(struct hmap* h, struct maptype* t, uintptr_t newbit);
    struct hmap* reflect_makemap(struct maptype* t, int cap);
    unsafe::Pointer reflect_mapaccess(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    unsafe::Pointer reflect_mapaccess_faststr(struct maptype* t, struct hmap* h, std::string key);
    void reflect_mapassign(struct maptype* t, struct hmap* h, unsafe::Pointer key, unsafe::Pointer elem);
    void reflect_mapassign_faststr(struct maptype* t, struct hmap* h, std::string key, unsafe::Pointer elem);
    void reflect_mapdelete(struct maptype* t, struct hmap* h, unsafe::Pointer key);
    void reflect_mapdelete_faststr(struct maptype* t, struct hmap* h, std::string key);
    void reflect_mapiterinit(struct maptype* t, struct hmap* h, struct hiter* it);
    void reflect_mapiternext(struct hiter* it);
    unsafe::Pointer reflect_mapiterkey(struct hiter* it);
    unsafe::Pointer reflect_mapiterelem(struct hiter* it);
    int reflect_maplen(struct hmap* h);
    void reflect_mapclear(struct maptype* t, struct hmap* h);
    int reflectlite_maplen(struct hmap* h);
    void mapinitnoop();
    go_any mapclone(go_any m);
    std::tuple<struct bmap*, int> moveToBmap(struct maptype* t, struct hmap* h, struct bmap* dst, int pos, struct bmap* src);
    struct hmap* mapclone2(struct maptype* t, struct hmap* src);
    void keys(go_any m, unsafe::Pointer p);
    void copyKeys(struct maptype* t, struct hmap* h, struct bmap* b, struct slice* s, uint8_t offset);
    void values(go_any m, unsafe::Pointer p);
    void copyValues(struct maptype* t, struct hmap* h, struct bmap* b, struct slice* s, uint8_t offset);
}

