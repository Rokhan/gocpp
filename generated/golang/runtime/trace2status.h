// generated by GoCpp from file '$(ImportDir)/runtime/trace2status.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2status.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"

namespace golang::runtime
{
    traceWriter writeGoStatus(struct traceWriter w, uint64_t goid, int64_t mid, traceGoStatus status, bool markAssist);
    traceWriter writeProcStatusForP(struct traceWriter w, p* pp, bool inSTW);
    traceWriter writeProcStatus(struct traceWriter w, uint64_t pid, traceProcStatus status, bool inSweep);
    traceGoStatus goStatusToTraceGoStatus(uint32_t status, waitReason wr);
    struct traceSchedResourceState
    {
        gocpp::array<atomic::Uint32, 3> statusTraced;
        gocpp::array<uint64_t, 2> seq;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct traceSchedResourceState& value);
    bool acquireStatus(struct traceSchedResourceState* r, uintptr_t gen);
    void readyNextGen(struct traceSchedResourceState* r, uintptr_t gen);
    bool statusWasTraced(struct traceSchedResourceState* r, uintptr_t gen);
    void setStatusTraced(struct traceSchedResourceState* r, uintptr_t gen);
    traceArg nextSeq(struct traceSchedResourceState* r, uintptr_t gen);
}

