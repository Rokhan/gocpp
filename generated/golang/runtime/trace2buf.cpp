// generated by GoCpp from file '$(ImportDir)/runtime/trace2buf.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2buf.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // Maximum number of bytes required to encode uint64 in base-128.
    // traceWriter is the interface for writing all trace data.
    //
    // This type is passed around as a value, and all of its methods return
    // a new traceWriter. This allows for chaining together calls in a fluent-style
    // API. This is partly stylistic, and very slightly for performance, since
    // the compiler can destructure this value and pass it between calls as
    // just regular arguments. However, this style is not load-bearing, and
    // we can change it if it's deemed too error-prone.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceWriter::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceWriter::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& traceWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceWriter& value)
    {
        return value.PrintTo(os);
    }

    // write returns an a traceWriter that writes into the current M's stream.
    struct traceWriter rec::writer(struct traceLocker tl)
    {
        return gocpp::Init<traceWriter>([=](auto& x) {
            x.traceLocker = tl;
            x.traceBuf = tl.mp->trace.buf[tl.gen % 2];
        });
    }

    // unsafeTraceWriter produces a traceWriter that doesn't lock the trace.
    //
    // It should only be used in contexts where either:
    // - Another traceLocker is held.
    // - trace.gen is prevented from advancing.
    //
    // buf may be nil.
    struct traceWriter unsafeTraceWriter(uintptr_t gen, struct traceBuf* buf)
    {
        return gocpp::Init<traceWriter>([=](auto& x) {
            x.traceLocker = gocpp::Init<traceLocker>([=](auto& x) {
                x.gen = gen;
            });
            x.traceBuf = buf;
        });
    }

    // end writes the buffer back into the m.
    void rec::end(struct traceWriter w)
    {
        if(w.mp == nullptr)
        {
            return;
        }
        w.mp->trace.buf[w.gen % 2] = w.traceBuf;
    }

    // ensure makes sure that at least maxSize bytes are available to write.
    //
    // Returns whether the buffer was flushed.
    std::tuple<struct traceWriter, bool> rec::ensure(struct traceWriter w, int maxSize)
    {
        auto refill = w.traceBuf == nullptr || ! rec::available(gocpp::recv(w), maxSize);
        if(refill)
        {
            w = rec::refill(gocpp::recv(w));
        }
        return {w, refill};
    }

    // flush puts w.traceBuf on the queue of full buffers.
    struct traceWriter rec::flush(struct traceWriter w)
    {
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(w.traceBuf != nullptr)
            {
                traceBufFlush(w.traceBuf, w.gen);
            }
            unlock(& trace.lock);
        });
        w.traceBuf = nullptr;
        return w;
    }

    // refill puts w.traceBuf on the queue of full buffers and refresh's w's buffer.
    struct traceWriter rec::refill(struct traceWriter w)
    {
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(w.traceBuf != nullptr)
            {
                traceBufFlush(w.traceBuf, w.gen);
            }
            if(trace.empty != nullptr)
            {
                w.traceBuf = trace.empty;
                trace.empty = w.traceBuf->link;
                unlock(& trace.lock);
            }
            else
            {
                unlock(& trace.lock);
                w.traceBuf = (traceBuf*)(sysAlloc(gocpp::Sizeof<traceBuf>(), & memstats.other_sys));
                if(w.traceBuf == nullptr)
                {
                    go_throw("trace: out of memory"s);
                }
            }
        });
        auto ts = traceClockNow();
        if(ts <= w.traceBuf->lastTime)
        {
            ts = w.traceBuf->lastTime + 1;
        }
        w.traceBuf->lastTime = ts;
        w.traceBuf->link = nullptr;
        w.traceBuf->pos = 0;
        auto mID = ~ uint64_t(0);
        if(w.mp != nullptr)
        {
            mID = uint64_t(w.mp->procid);
        }
        rec::byte(gocpp::recv(w), (unsigned char)(traceEvEventBatch));
        rec::varint(gocpp::recv(w), uint64_t(w.gen));
        rec::varint(gocpp::recv(w), uint64_t(mID));
        rec::varint(gocpp::recv(w), uint64_t(ts));
        w.traceBuf->lenPos = rec::varintReserve(gocpp::recv(w));
        return w;
    }

    // traceBufQueue is a FIFO of traceBufs.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceBufQueue::operator T()
    {
        T result;
        result.head = this->head;
        result.tail = this->tail;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceBufQueue::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        if (tail != ref.tail) return false;
        return true;
    }

    std::ostream& traceBufQueue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBufQueue& value)
    {
        return value.PrintTo(os);
    }

    // push queues buf into queue of buffers.
    void rec::push(struct traceBufQueue* q, struct traceBuf* buf)
    {
        buf->link = nullptr;
        if(q->head == nullptr)
        {
            q->head = buf;
        }
        else
        {
            q->tail->link = buf;
        }
        q->tail = buf;
    }

    // pop dequeues from the queue of buffers.
    struct traceBuf* rec::pop(struct traceBufQueue* q)
    {
        auto buf = q->head;
        if(buf == nullptr)
        {
            return nullptr;
        }
        q->head = buf->link;
        if(q->head == nullptr)
        {
            q->tail = nullptr;
        }
        buf->link = nullptr;
        return buf;
    }

    bool rec::empty(struct traceBufQueue* q)
    {
        return q->head == nullptr;
    }

    // traceBufHeader is per-P tracing buffer.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceBufHeader::operator T()
    {
        T result;
        result.link = this->link;
        result.lastTime = this->lastTime;
        result.pos = this->pos;
        result.lenPos = this->lenPos;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceBufHeader::operator==(const T& ref) const
    {
        if (link != ref.link) return false;
        if (lastTime != ref.lastTime) return false;
        if (pos != ref.pos) return false;
        if (lenPos != ref.lenPos) return false;
        return true;
    }

    std::ostream& traceBufHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << link;
        os << " " << lastTime;
        os << " " << pos;
        os << " " << lenPos;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBufHeader& value)
    {
        return value.PrintTo(os);
    }

    // traceBuf is per-M tracing buffer.
    //
    // TODO(mknyszek): Rename traceBuf to traceBatch, since they map 1:1 with event batches.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceBuf::operator T()
    {
        T result;
        result._1 = this->_1;
        result.arr = this->arr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceBuf::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (arr != ref.arr) return false;
        return true;
    }

    std::ostream& traceBuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << arr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBuf& value)
    {
        return value.PrintTo(os);
    }

    // byte appends v to buf.
    void rec::byte(struct traceBuf* buf, unsigned char v)
    {
        buf->arr[buf->pos] = v;
        buf->pos++;
    }

    // varint appends v to buf in little-endian-base-128 encoding.
    void rec::varint(struct traceBuf* buf, uint64_t v)
    {
        auto pos = buf->pos;
        auto arr = buf->arr.make_slice(pos, pos + traceBytesPerNumber);
        for(auto [i, gocpp_ignored] : arr)
        {
            if(v < 0x80)
            {
                pos += i + 1;
                arr[i] = (unsigned char)(v);
                break;
            }
            arr[i] = 0x80 | (unsigned char)(v);
            v >>= 7;
        }
        buf->pos = pos;
    }

    // varintReserve reserves enough space in buf to hold any varint.
    //
    // Space reserved this way can be filled in with the varintAt method.
    int rec::varintReserve(struct traceBuf* buf)
    {
        auto p = buf->pos;
        buf->pos += traceBytesPerNumber;
        return p;
    }

    // stringData appends s's data directly to buf.
    void rec::stringData(struct traceBuf* buf, std::string s)
    {
        buf->pos += copy(buf->arr.make_slice(buf->pos), s);
    }

    bool rec::available(struct traceBuf* buf, int size)
    {
        return len(buf->arr) - buf->pos >= size;
    }

    // varintAt writes varint v at byte position pos in buf. This always
    // consumes traceBytesPerNumber bytes. This is intended for when the caller
    // needs to reserve space for a varint but can't populate it until later.
    // Use varintReserve to reserve this space.
    void rec::varintAt(struct traceBuf* buf, int pos, uint64_t v)
    {
        for(auto i = 0; i < traceBytesPerNumber; i++)
        {
            if(i < traceBytesPerNumber - 1)
            {
                buf->arr[pos] = 0x80 | (unsigned char)(v);
            }
            else
            {
                buf->arr[pos] = (unsigned char)(v);
            }
            v >>= 7;
            pos++;
        }
        if(v != 0)
        {
            go_throw("v could not fit in traceBytesPerNumber"s);
        }
    }

    // traceBufFlush flushes a trace buffer.
    //
    // Must run on the system stack because trace.lock must be held.
    //
    //go:systemstack
    void traceBufFlush(struct traceBuf* buf, uintptr_t gen)
    {
        assertLockHeld(& trace.lock);
        rec::varintAt(gocpp::recv(buf), buf->lenPos, uint64_t(buf->pos - (buf->lenPos + traceBytesPerNumber)));
        rec::push(gocpp::recv(trace.full[gen % 2]), buf);
        if(! rec::Load(gocpp::recv(trace.workAvailable)))
        {
            rec::Store(gocpp::recv(trace.workAvailable), true);
        }
    }

}

