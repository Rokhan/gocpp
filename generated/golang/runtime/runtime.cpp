// generated by GoCpp from file '$(ImportDir)/runtime/runtime.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime.h"
#include "gocpp/support.h"

#include "golang/runtime/cputicks.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    ticksType ticks;
    
    template<typename T> requires gocpp::GoStruct<T>
    ticksType::operator T()
    {
        T result;
        result.lock = this->lock;
        result.startTicks = this->startTicks;
        result.startTime = this->startTime;
        result.val = this->val;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ticksType::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (startTicks != ref.startTicks) return false;
        if (startTime != ref.startTime) return false;
        if (val != ref.val) return false;
        return true;
    }

    std::ostream& ticksType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << startTicks;
        os << " " << startTime;
        os << " " << val;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ticksType& value)
    {
        return value.PrintTo(os);
    }

    // init initializes ticks to maximize the chance that we have a good ticksPerSecond reference.
    //
    // Must not run concurrently with ticksPerSecond.
    void rec::init(struct ticksType* t)
    {
        lock(& ticks.lock);
        t->startTime = nanotime();
        t->startTicks = cputicks();
        unlock(& ticks.lock);
    }

    // minTimeForTicksPerSecond is the minimum elapsed time we require to consider our ticksPerSecond
    // measurement to be of decent enough quality for profiling.
    //
    // There's a linear relationship here between minimum time and error from the true value.
    // The error from the true ticks-per-second in a linux/amd64 VM seems to be:
    // -   1 ms -> ~0.02% error
    // -   5 ms -> ~0.004% error
    // -  10 ms -> ~0.002% error
    // -  50 ms -> ~0.0003% error
    // - 100 ms -> ~0.0001% error
    //
    // We're willing to take 0.004% error here, because ticksPerSecond is intended to be used for
    // converting durations, not timestamps. Durations are usually going to be much larger, and so
    // the tiny error doesn't matter. The error is definitely going to be a problem when trying to
    // use this for timestamps, as it'll make those timestamps much less likely to line up.
    // ticksPerSecond returns a conversion rate between the cputicks clock and the nanotime clock.
    //
    // Note: Clocks are hard. Using this as an actual conversion rate for timestamps is ill-advised
    // and should be avoided when possible. Use only for durations, where a tiny error term isn't going
    // to make a meaningful difference in even a 1ms duration. If an accurate timestamp is needed,
    // use nanotime instead. (The entire Windows platform is a broad exception to this rule, where nanotime
    // produces timestamps on such a coarse granularity that the error from this conversion is actually
    // preferable.)
    //
    // The strategy for computing the conversion rate is to write down nanotime and cputicks as
    // early in process startup as possible. From then, we just need to wait until we get values
    // from nanotime that we can use (some platforms have a really coarse system time granularity).
    // We require some amount of time to pass to ensure that the conversion rate is fairly accurate
    // in aggregate. But because we compute this rate lazily, there's a pretty good chance a decent
    // amount of time has passed by the time we get here.
    //
    // Must be called from a normal goroutine context (running regular goroutine with a P).
    //
    // Called by runtime/pprof in addition to runtime code.
    //
    // TODO(mknyszek): This doesn't account for things like CPU frequency scaling. Consider
    // a more sophisticated and general approach in the future.
    int64_t ticksPerSecond()
    {
        auto r = rec::Load(gocpp::recv(ticks.val));
        if(r != 0)
        {
            return r;
        }
        for(; ; )
        {
            lock(& ticks.lock);
            r = rec::Load(gocpp::recv(ticks.val));
            if(r != 0)
            {
                unlock(& ticks.lock);
                return r;
            }
            auto nowTime = nanotime();
            auto nowTicks = cputicks();
            if(nowTicks > ticks.startTicks && nowTime - ticks.startTime > minTimeForTicksPerSecond)
            {
                r = int64_t(double(nowTicks - ticks.startTicks) * 1e9 / double(nowTime - ticks.startTime));
                if(r == 0)
                {
                    r++;
                }
                rec::Store(gocpp::recv(ticks.val), r);
                unlock(& ticks.lock);
                break;
            }
            unlock(& ticks.lock);
            timeSleep(1000000);
        }
        return r;
    }

    gocpp::slice<std::string> envs;
    gocpp::slice<std::string> argslice;
    //go:linkname syscall_runtime_envs syscall.runtime_envs
    gocpp::slice<std::string> syscall_runtime_envs()
    {
        return append(gocpp::slice<std::string> {}, envs);
    }

    //go:linkname syscall_Getpagesize syscall.Getpagesize
    int syscall_Getpagesize()
    {
        return int(physPageSize);
    }

    //go:linkname os_runtime_args os.runtime_args
    gocpp::slice<std::string> os_runtime_args()
    {
        return append(gocpp::slice<std::string> {}, argslice);
    }

    //go:linkname syscall_Exit syscall.Exit
    //go:nosplit
    void syscall_Exit(int code)
    {
        exit(int32_t(code));
    }

    std::string godebugDefault;
    atomic::Pointer<std::function<void (std::string, std::string)>> godebugUpdate;
    atomic::Pointer<std::string> godebugEnv;
    atomic::Pointer<std::function<std::function<void ()> (std::string)>> godebugNewIncNonDefault;
    //go:linkname godebug_setUpdate internal/godebug.setUpdate
    void godebug_setUpdate(std::function<void (std::string, std::string)> update)
    {
        auto p = new(gocpp::Tag<std::function<void (std::string, std::string)>>());
        *p = update;
        rec::Store(gocpp::recv(godebugUpdate), p);
        godebugNotify(false);
    }

    //go:linkname godebug_setNewIncNonDefault internal/godebug.setNewIncNonDefault
    void godebug_setNewIncNonDefault(std::function<std::function<void ()> (std::string)> newIncNonDefault)
    {
        auto p = new(gocpp::Tag<std::function<std::function<void ()> (std::string)>>());
        *p = newIncNonDefault;
        rec::Store(gocpp::recv(godebugNewIncNonDefault), p);
    }

    // A godebugInc provides access to internal/godebug's IncNonDefault function
    // for a given GODEBUG setting.
    // Calls before internal/godebug registers itself are dropped on the floor.
    
    template<typename T> requires gocpp::GoStruct<T>
    godebugInc::operator T()
    {
        T result;
        result.name = this->name;
        result.inc = this->inc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool godebugInc::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (inc != ref.inc) return false;
        return true;
    }

    std::ostream& godebugInc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << inc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct godebugInc& value)
    {
        return value.PrintTo(os);
    }

    void rec::IncNonDefault(struct godebugInc* g)
    {
        auto inc = rec::Load(gocpp::recv(g->inc));
        if(inc == nullptr)
        {
            auto newInc = rec::Load(gocpp::recv(godebugNewIncNonDefault));
            if(newInc == nullptr)
            {
                return;
            }
            inc = new(gocpp::Tag<std::function<void ()>>());
            *inc = (runtime::newInc*)(g->name);
            if(raceenabled)
            {
                racereleasemerge(unsafe::Pointer(& g->inc));
            }
            if(! rec::CompareAndSwap(gocpp::recv(g->inc), nullptr, inc))
            {
                inc = rec::Load(gocpp::recv(g->inc));
            }
        }
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& g->inc));
        }
        (runtime::inc*)();
    }

    void godebugNotify(bool envChanged)
    {
        auto update = rec::Load(gocpp::recv(godebugUpdate));
        std::string env = {};
        if(auto p = rec::Load(gocpp::recv(godebugEnv)); p != nullptr)
        {
            env = *p;
        }
        if(envChanged)
        {
            reparsedebugvars(env);
        }
        if(update != nullptr)
        {
            (runtime::update*)(godebugDefault, env);
        }
    }

    //go:linkname syscall_runtimeSetenv syscall.runtimeSetenv
    void syscall_runtimeSetenv(std::string key, std::string value)
    {
        setenv_c(key, value);
        if(key == "GODEBUG"s)
        {
            auto p = new(string);
            *p = value;
            rec::Store(gocpp::recv(godebugEnv), p);
            godebugNotify(true);
        }
    }

    //go:linkname syscall_runtimeUnsetenv syscall.runtimeUnsetenv
    void syscall_runtimeUnsetenv(std::string key)
    {
        unsetenv_c(key);
        if(key == "GODEBUG"s)
        {
            rec::Store(gocpp::recv(godebugEnv), nullptr);
            godebugNotify(true);
        }
    }

    // writeErrStr writes a string to descriptor 2.
    //
    //go:nosplit
    void writeErrStr(std::string s)
    {
        write(2, unsafe::Pointer(unsafe::StringData(s)), int32_t(len(s)));
    }

    // auxv is populated on relevant platforms but defined here for all platforms
    // so x/sys/cpu can assume the getAuxv symbol exists without keeping its list
    // of auxv-using GOOS build tags in sync.
    //
    // It contains an even number of elements, (tag, value) pairs.
    gocpp::slice<uintptr_t> auxv;
    gocpp::slice<uintptr_t> getAuxv()
    {
        return auxv;
    }

}

