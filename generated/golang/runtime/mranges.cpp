// generated by GoCpp from file '$(ImportDir)/runtime/mranges.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mranges.h"
#include "gocpp/support.h"

#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& addrRange::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << base;
        os << " " << limit;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct addrRange& value)
    {
        return value.PrintTo(os);
    }

    addrRange makeAddrRange(uintptr_t base, uintptr_t limit)
    {
        auto r = addrRange {offAddr {base}, offAddr {limit}};
        if((base - arenaBaseOffset >= base) != (limit - arenaBaseOffset >= limit))
        {
            go_throw("addr range base and limit are not in the same memory segment");
        }
        return r;
    }

    uintptr_t size(struct addrRange a)
    {
        if(! lessThan(gocpp::recv(a.base), a.limit))
        {
            return 0;
        }
        return diff(gocpp::recv(a.limit), a.base);
    }

    bool contains(struct addrRange a, uintptr_t addr)
    {
        return lessEqual(gocpp::recv(a.base), offAddr {addr}) && lessThan(gocpp::recv((offAddr {addr})), a.limit);
    }

    addrRange subtract(struct addrRange a, addrRange b)
    {
        if(lessEqual(gocpp::recv(b.base), a.base) && lessEqual(gocpp::recv(a.limit), b.limit))
        {
            return addrRange {};
        }
        else
        if(lessThan(gocpp::recv(a.base), b.base) && lessThan(gocpp::recv(b.limit), a.limit))
        {
            go_throw("bad prune");
        }
        else
        if(lessThan(gocpp::recv(b.limit), a.limit) && lessThan(gocpp::recv(a.base), b.limit))
        {
            a.base = b.limit;
        }
        else
        if(lessThan(gocpp::recv(a.base), b.base) && lessThan(gocpp::recv(b.base), a.limit))
        {
            a.limit = b.base;
        }
        return a;
    }

    std::tuple<uintptr_t, bool> takeFromFront(struct addrRange* a, uintptr_t len, uint8_t align)
    {
        auto base = alignUp(addr(gocpp::recv(a->base)), uintptr_t(align)) + len;
        if(base > addr(gocpp::recv(a->limit)))
        {
            return {0, false};
        }
        a->base = offAddr {base};
        return {base - len, true};
    }

    std::tuple<uintptr_t, bool> takeFromBack(struct addrRange* a, uintptr_t len, uint8_t align)
    {
        auto limit = alignDown(addr(gocpp::recv(a->limit)) - len, uintptr_t(align));
        if(addr(gocpp::recv(a->base)) > limit)
        {
            return {0, false};
        }
        a->limit = offAddr {limit};
        return {limit, true};
    }

    addrRange removeGreaterEqual(struct addrRange a, uintptr_t addr)
    {
        if(lessEqual(gocpp::recv((offAddr {addr})), a.base))
        {
            return addrRange {};
        }
        if(lessEqual(gocpp::recv(a.limit), offAddr {addr}))
        {
            return a;
        }
        return makeAddrRange(addr(gocpp::recv(a.base)), addr);
    }

    offAddr minOffAddr = offAddr {arenaBaseOffset};
    offAddr maxOffAddr = offAddr {(((1 << heapAddrBits) - 1) + arenaBaseOffset) & uintptrMask};
    
    std::ostream& offAddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct offAddr& value)
    {
        return value.PrintTo(os);
    }

    offAddr add(struct offAddr l, uintptr_t bytes)
    {
        return gocpp::Init<offAddr>([](offAddr& x) { x.a = l.a + bytes; });
    }

    offAddr sub(struct offAddr l, uintptr_t bytes)
    {
        return gocpp::Init<offAddr>([](offAddr& x) { x.a = l.a - bytes; });
    }

    uintptr_t diff(struct offAddr l1, offAddr l2)
    {
        return l1.a - l2.a;
    }

    bool lessThan(struct offAddr l1, offAddr l2)
    {
        return (l1.a - arenaBaseOffset) < (l2.a - arenaBaseOffset);
    }

    bool lessEqual(struct offAddr l1, offAddr l2)
    {
        return (l1.a - arenaBaseOffset) <= (l2.a - arenaBaseOffset);
    }

    bool equal(struct offAddr l1, offAddr l2)
    {
        return l1 == l2;
    }

    uintptr_t addr(struct offAddr l)
    {
        return l.a;
    }

    
    std::ostream& atomicOffAddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicOffAddr& value)
    {
        return value.PrintTo(os);
    }

    void Clear(struct atomicOffAddr* b)
    {
        for(; ; )
        {
            auto old = Load(gocpp::recv(b->a));
            if(old < 0)
            {
                return;
            }
            if(CompareAndSwap(gocpp::recv(b->a), old, int64_t(addr(gocpp::recv(minOffAddr)) - arenaBaseOffset)))
            {
                return;
            }
        }
    }

    void StoreMin(struct atomicOffAddr* b, uintptr_t addr)
    {
        auto go_new = int64_t(addr - arenaBaseOffset);
        for(; ; )
        {
            auto old = Load(gocpp::recv(b->a));
            if(old < go_new)
            {
                return;
            }
            if(CompareAndSwap(gocpp::recv(b->a), old, go_new))
            {
                return;
            }
        }
    }

    void StoreUnmark(struct atomicOffAddr* b, uintptr_t markedAddr, uintptr_t newAddr)
    {
        CompareAndSwap(gocpp::recv(b->a), - int64_t(markedAddr - arenaBaseOffset), int64_t(newAddr - arenaBaseOffset));
    }

    void StoreMarked(struct atomicOffAddr* b, uintptr_t addr)
    {
        Store(gocpp::recv(b->a), - int64_t(addr - arenaBaseOffset));
    }

    std::tuple<uintptr_t, bool> Load(struct atomicOffAddr* b)
    {
        auto v = Load(gocpp::recv(b->a));
        auto wasMarked = false;
        if(v < 0)
        {
            wasMarked = true;
            v = - v;
        }
        return {uintptr_t(v) + arenaBaseOffset, wasMarked};
    }

    
    std::ostream& addrRanges::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ranges;
        os << " " << totalBytes;
        os << " " << sysStat;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct addrRanges& value)
    {
        return value.PrintTo(os);
    }

    void init(struct addrRanges* a, sysMemStat* sysStat)
    {
        auto ranges = (notInHeapSlice*)(unsafe::Pointer(& a->ranges));
        ranges->len = 0;
        ranges->cap = 16;
        ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, sysStat));
        a->sysStat = sysStat;
        a->totalBytes = 0;
    }

    int findSucc(struct addrRanges* a, uintptr_t addr)
    {
        auto base = offAddr {addr};
        auto iterMax = 8;
        auto [bot, top] = std::tuple{0, len(a->ranges)};
        for(; top - bot > iterMax; )
        {
            auto i = int((unsigned int)(bot + top) >> 1);
            if(contains(gocpp::recv(a->ranges[i]), addr(gocpp::recv(base))))
            {
                return i + 1;
            }
            if(lessThan(gocpp::recv(base), a->ranges[i].base))
            {
                top = i;
            }
            else
            {
                bot = i + 1;
            }
        }
        for(auto i = bot; i < top; i++)
        {
            if(lessThan(gocpp::recv(base), a->ranges[i].base))
            {
                return i;
            }
        }
        return top;
    }

    std::tuple<uintptr_t, bool> findAddrGreaterEqual(struct addrRanges* a, uintptr_t addr)
    {
        auto i = findSucc(gocpp::recv(a), addr);
        if(i == 0)
        {
            return {addr(gocpp::recv(a->ranges[0].base)), true};
        }
        if(contains(gocpp::recv(a->ranges[i - 1]), addr))
        {
            return {addr, true};
        }
        if(i < len(a->ranges))
        {
            return {addr(gocpp::recv(a->ranges[i].base)), true};
        }
        return {0, false};
    }

    bool contains(struct addrRanges* a, uintptr_t addr)
    {
        auto i = findSucc(gocpp::recv(a), addr);
        if(i == 0)
        {
            return false;
        }
        return contains(gocpp::recv(a->ranges[i - 1]), addr);
    }

    void add(struct addrRanges* a, addrRange r)
    {
        if(size(gocpp::recv(r)) == 0)
        {
            print("runtime: range = {", hex(addr(gocpp::recv(r.base))), ", ", hex(addr(gocpp::recv(r.limit))), "}\n");
            go_throw("attempted to add zero-sized address range");
        }
        auto i = findSucc(gocpp::recv(a), addr(gocpp::recv(r.base)));
        auto coalescesDown = i > 0 && equal(gocpp::recv(a->ranges[i - 1].limit), r.base);
        auto coalescesUp = i < len(a->ranges) && equal(gocpp::recv(r.limit), a->ranges[i].base);
        if(coalescesUp && coalescesDown)
        {
            a->ranges[i - 1].limit = a->ranges[i].limit;
            copy(a->ranges.make_slice(i), a->ranges.make_slice(i + 1));
            a->ranges = a->ranges.make_slice(0, len(a->ranges) - 1);
        }
        else
        if(coalescesDown)
        {
            a->ranges[i - 1].limit = r.limit;
        }
        else
        if(coalescesUp)
        {
            a->ranges[i].base = r.base;
        }
        else
        {
            if(len(a->ranges) + 1 > cap(a->ranges))
            {
                auto oldRanges = a->ranges;
                auto ranges = (notInHeapSlice*)(unsafe::Pointer(& a->ranges));
                ranges->len = len(oldRanges) + 1;
                ranges->cap = cap(oldRanges) * 2;
                ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, a->sysStat));
                copy(a->ranges.make_slice(0, i), oldRanges.make_slice(0, i));
                copy(a->ranges.make_slice(i + 1), oldRanges.make_slice(i));
            }
            else
            {
                a->ranges = a->ranges.make_slice(0, len(a->ranges) + 1);
                copy(a->ranges.make_slice(i + 1), a->ranges.make_slice(i));
            }
            a->ranges[i] = r;
        }
        a->totalBytes += size(gocpp::recv(r));
    }

    addrRange removeLast(struct addrRanges* a, uintptr_t nBytes)
    {
        if(len(a->ranges) == 0)
        {
            return addrRange {};
        }
        auto r = a->ranges[len(a->ranges) - 1];
        auto size = size(gocpp::recv(r));
        if(size > nBytes)
        {
            auto newEnd = sub(gocpp::recv(r.limit), nBytes);
            a->ranges[len(a->ranges) - 1].limit = newEnd;
            a->totalBytes -= nBytes;
            return addrRange {newEnd, r.limit};
        }
        a->ranges = a->ranges.make_slice(0, len(a->ranges) - 1);
        a->totalBytes -= size;
        return r;
    }

    void removeGreaterEqual(struct addrRanges* a, uintptr_t addr)
    {
        auto pivot = findSucc(gocpp::recv(a), addr);
        if(pivot == 0)
        {
            a->totalBytes = 0;
            a->ranges = a->ranges.make_slice(0, 0);
            return;
        }
        auto removed = uintptr_t(0);
        for(auto [_, r] : a->ranges.make_slice(pivot))
        {
            removed += size(gocpp::recv(r));
        }
        if(auto r = a->ranges[pivot - 1]; contains(gocpp::recv(r), addr))
        {
            removed += size(gocpp::recv(r));
            r = removeGreaterEqual(gocpp::recv(r), addr);
            if(size(gocpp::recv(r)) == 0)
            {
                pivot--;
            }
            else
            {
                removed -= size(gocpp::recv(r));
                a->ranges[pivot - 1] = r;
            }
        }
        a->ranges = a->ranges.make_slice(0, pivot);
        a->totalBytes -= removed;
    }

    void cloneInto(struct addrRanges* a, addrRanges* b)
    {
        if(len(a->ranges) > cap(b->ranges))
        {
            auto ranges = (notInHeapSlice*)(unsafe::Pointer(& b->ranges));
            ranges->len = 0;
            ranges->cap = cap(a->ranges);
            ranges->array = (notInHeap*)(persistentalloc(gocpp::Sizeof<addrRange>() * uintptr_t(ranges->cap), goarch::PtrSize, b->sysStat));
        }
        b->ranges = b->ranges.make_slice(0, len(a->ranges));
        b->totalBytes = a->totalBytes;
        copy(b->ranges, a->ranges);
    }

}

