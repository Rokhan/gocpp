// generated by GoCpp from file '$(ImportDir)/internal/chacha8rand/chacha8.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/chacha8rand/chacha8.h"
#include "gocpp/support.h"

namespace golang::chacha8rand
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    void block(gocpp::array<uint64_t, 4>* seed, gocpp::array<uint64_t, 32>* blocks, uint32_t counter)
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    State::operator T()
    {
        T result;
        result.buf = this->buf;
        result.seed = this->seed;
        result.i = this->i;
        result.n = this->n;
        result.c = this->c;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool State::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (seed != ref.seed) return false;
        if (i != ref.i) return false;
        if (n != ref.n) return false;
        if (c != ref.c) return false;
        return true;
    }

    std::ostream& State::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << seed;
        os << " " << i;
        os << " " << n;
        os << " " << c;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct State& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint64_t, bool> rec::Next(struct State* s)
    {
        auto i = s->i;
        if(i >= s->n)
        {
            return {0, false};
        }
        s->i = i + 1;
        return {s->buf[i & 31], true};
    }

    void rec::Init(struct State* s, gocpp::array<unsigned char, 32> seed)
    {
        rec::Init64(gocpp::recv(s), gocpp::array<uint64_t, 4> {leUint64(seed.make_slice(0 * 8)), leUint64(seed.make_slice(1 * 8)), leUint64(seed.make_slice(2 * 8)), leUint64(seed.make_slice(3 * 8))});
    }

    void rec::Init64(struct State* s, gocpp::array<uint64_t, 4> seed)
    {
        s->seed = seed;
        block(& s->seed, & s->buf, 0);
        s->c = 0;
        s->i = 0;
        s->n = chunk;
    }

    void rec::Refill(struct State* s)
    {
        s->c += ctrInc;
        if(s->c == ctrMax)
        {
            s->seed[0] = s->buf[len(s->buf) - reseed + 0];
            s->seed[1] = s->buf[len(s->buf) - reseed + 1];
            s->seed[2] = s->buf[len(s->buf) - reseed + 2];
            s->seed[3] = s->buf[len(s->buf) - reseed + 3];
            s->c = 0;
        }
        block(& s->seed, & s->buf, s->c);
        s->i = 0;
        s->n = uint32_t(len(s->buf));
        if(s->c == ctrMax - ctrInc)
        {
            s->n = uint32_t(len(s->buf)) - reseed;
        }
    }

    void rec::Reseed(struct State* s)
    {
        gocpp::array<uint64_t, 4> seed = {};
        for(auto [i, gocpp_ignored] : seed)
        {
            for(; ; )
            {
                auto [x, ok] = rec::Next(gocpp::recv(s));
                if(ok)
                {
                    seed[i] = x;
                    break;
                }
                rec::Refill(gocpp::recv(s));
            }
        }
        rec::Init64(gocpp::recv(s), seed);
    }

    gocpp::slice<unsigned char> Marshal(struct State* s)
    {
        auto data = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 6 * 8);
        copy(data, "chacha8:");
        auto used = (s->c / ctrInc) * chunk + s->i;
        bePutUint64(data.make_slice(1 * 8), uint64_t(used));
        for(auto [i, seed] : s->seed)
        {
            lePutUint64(data.make_slice((2 + i) * 8), seed);
        }
        return data;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    errUnmarshalChaCha8::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool errUnmarshalChaCha8::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& errUnmarshalChaCha8::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct errUnmarshalChaCha8& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(errUnmarshalChaCha8*)
    {
        return "invalid ChaCha8 encoding";
    }

    struct gocpp::error Unmarshal(struct State* s, gocpp::slice<unsigned char> data)
    {
        if(len(data) != 6 * 8 || string(data.make_slice(0, 8)) != "chacha8:")
        {
            return go_new(errUnmarshalChaCha8);
        }
        auto used = beUint64(data.make_slice(1 * 8));
        if(used > (ctrMax / ctrInc) * chunk - reseed)
        {
            return go_new(errUnmarshalChaCha8);
        }
        for(auto [i, gocpp_ignored] : s->seed)
        {
            s->seed[i] = leUint64(data.make_slice((2 + i) * 8));
        }
        s->c = ctrInc * (uint32_t(used) / chunk);
        block(& s->seed, & s->buf, s->c);
        s->i = uint32_t(used) % chunk;
        s->n = chunk;
        if(s->c == ctrMax - ctrInc)
        {
            s->n = chunk - reseed;
        }
        return nullptr;
    }

    uint64_t beUint64(gocpp::slice<unsigned char> b)
    {
        _ = b[7];
        return uint64_t(b[7]) | (uint64_t(b[6]) << 8) | (uint64_t(b[5]) << 16) | (uint64_t(b[4]) << 24) | (uint64_t(b[3]) << 32) | (uint64_t(b[2]) << 40) | (uint64_t(b[1]) << 48) | (uint64_t(b[0]) << 56);
    }

    void bePutUint64(gocpp::slice<unsigned char> b, uint64_t v)
    {
        _ = b[7];
        b[0] = unsigned char(v >> 56);
        b[1] = unsigned char(v >> 48);
        b[2] = unsigned char(v >> 40);
        b[3] = unsigned char(v >> 32);
        b[4] = unsigned char(v >> 24);
        b[5] = unsigned char(v >> 16);
        b[6] = unsigned char(v >> 8);
        b[7] = unsigned char(v);
    }

    uint64_t leUint64(gocpp::slice<unsigned char> b)
    {
        _ = b[7];
        return uint64_t(b[0]) | (uint64_t(b[1]) << 8) | (uint64_t(b[2]) << 16) | (uint64_t(b[3]) << 24) | (uint64_t(b[4]) << 32) | (uint64_t(b[5]) << 40) | (uint64_t(b[6]) << 48) | (uint64_t(b[7]) << 56);
    }

    void lePutUint64(gocpp::slice<unsigned char> b, uint64_t v)
    {
        _ = b[7];
        b[0] = unsigned char(v);
        b[1] = unsigned char(v >> 8);
        b[2] = unsigned char(v >> 16);
        b[3] = unsigned char(v >> 24);
        b[4] = unsigned char(v >> 32);
        b[5] = unsigned char(v >> 40);
        b[6] = unsigned char(v >> 48);
        b[7] = unsigned char(v >> 56);
    }

}

