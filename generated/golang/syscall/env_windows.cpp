// generated by GoCpp from file '$(ImportDir)/syscall/env_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/env_windows.h"
#include "gocpp/support.h"

#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace syscall::rec;
        using namespace unsafe::rec;
    }

    std::tuple<std::string, bool> Getenv(std::string key)
    {
        std::string value;
        bool found;
        auto [keyp, err] = UTF16PtrFromString(key);
        if(err != nullptr)
        {
            std::string value;
            bool found;
            return {"", false};
        }
        auto n = uint32_t(100);
        for(; ; )
        {
            std::string value;
            bool found;
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            std::tie(n, err) = GetEnvironmentVariable(keyp, & b[0], uint32_t(len(b)));
            if(n == 0 && err == ERROR_ENVVAR_NOT_FOUND)
            {
                std::string value;
                bool found;
                return {"", false};
            }
            if(n <= uint32_t(len(b)))
            {
                std::string value;
                bool found;
                return {UTF16ToString(b.make_slice(0, n)), true};
            }
        }
    }

    struct gocpp::error Setenv(std::string key, std::string value)
    {
        auto [v, err] = UTF16PtrFromString(value);
        if(err != nullptr)
        {
            return err;
        }
        uint16_t* keyp;
        std::tie(keyp, err) = UTF16PtrFromString(key);
        if(err != nullptr)
        {
            return err;
        }
        auto e = SetEnvironmentVariable(keyp, v);
        if(e != nullptr)
        {
            return e;
        }
        runtimeSetenv(key, value);
        return nullptr;
    }

    struct gocpp::error Unsetenv(std::string key)
    {
        auto [keyp, err] = UTF16PtrFromString(key);
        if(err != nullptr)
        {
            return err;
        }
        auto e = SetEnvironmentVariable(keyp, nullptr);
        if(e != nullptr)
        {
            return e;
        }
        runtimeUnsetenv(key);
        return nullptr;
    }

    void Clearenv()
    {
        for(auto [gocpp_ignored, s] : Environ())
        {
            for(auto j = 1; j < len(s); j++)
            {
                if(s[j] == '=')
                {
                    Unsetenv(s.make_slice(0, j));
                    break;
                }
            }
        }
    }

    gocpp::slice<std::string> Environ()
    {
        gocpp::Defer defer;
        try
        {
            auto [envp, e] = GetEnvironmentStrings();
            if(e != nullptr)
            {
                return nullptr;
            }
            defer.push_back([=]{ FreeEnvironmentStrings(envp); });
            auto r = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), 0, 50);
            auto size = gocpp::Sizeof<uint16_t>();
            for(; *envp != 0; )
            {
                auto end = unsafe::Pointer(envp);
                for(; *(uint16_t*)(end) != 0; )
                {
                    end = unsafe::Add(end, size);
                }
                auto entry = unsafe::Slice(envp, (uintptr_t(end) - uintptr_t(unsafe::Pointer(envp))) / size);
                r = append(r, UTF16ToString(entry));
                envp = (uint16_t*)(unsafe::Add(end, size));
            }
            return r;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

