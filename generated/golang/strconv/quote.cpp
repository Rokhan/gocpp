// generated by GoCpp from file '$(ImportDir)/strconv/quote.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/quote.h"
#include "gocpp/support.h"

#include "golang/strconv/bytealg.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::strconv
{
    std::string lowerhex = "0123456789abcdef";
    std::string upperhex = "0123456789ABCDEF";
    bool contains(std::string s, unsigned char c)
    {
        return index(s, c) != - 1;
    }

    std::string quoteWith(std::string s, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        return string(appendQuotedWith(gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 3 * len(s) / 2), s, quote, ASCIIonly, graphicOnly));
    }

    std::string quoteRuneWith(gocpp::rune r, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        return string(appendQuotedRuneWith(nullptr, r, quote, ASCIIonly, graphicOnly));
    }

    gocpp::slice<unsigned char> appendQuotedWith(gocpp::slice<unsigned char> buf, std::string s, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        if(cap(buf) - len(buf) < len(s))
        {
            auto nBuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(buf), len(buf) + 1 + len(s) + 1);
            copy(nBuf, buf);
            buf = nBuf;
        }
        buf = append(buf, quote);
        for(auto width = 0; len(s) > 0; s = s.make_slice(width))
        {
            auto r = rune(s[0]);
            width = 1;
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, width) = utf8::DecodeRuneInString(s);
            }
            if(width == 1 && r == utf8::RuneError)
            {
                buf = append(buf, "\\x");
                buf = append(buf, lowerhex[s[0] >> 4]);
                buf = append(buf, lowerhex[s[0] & 0xF]);
                continue;
            }
            buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
        }
        buf = append(buf, quote);
        return buf;
    }

    gocpp::slice<unsigned char> appendQuotedRuneWith(gocpp::slice<unsigned char> buf, gocpp::rune r, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        buf = append(buf, quote);
        if(! utf8::ValidRune(r))
        {
            r = utf8::RuneError;
        }
        buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
        buf = append(buf, quote);
        return buf;
    }

    gocpp::slice<unsigned char> appendEscapedRune(gocpp::slice<unsigned char> buf, gocpp::rune r, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        if(r == rune(quote) || r == '\\')
        {
            buf = append(buf, '\\');
            buf = append(buf, unsigned char(r));
            return buf;
        }
        if(ASCIIonly)
        {
            if(r < utf8::RuneSelf && IsPrint(r))
            {
                buf = append(buf, unsigned char(r));
                return buf;
            }
        }
        else
        if(IsPrint(r) || graphicOnly && isInGraphicList(r))
        {
            return utf8::AppendRune(buf, r);
        }
        //Go switch emulation
        {
            auto condition = r;
            int conditionId = -1;
            if(condition == '\a') { conditionId = 0; }
            else if(condition == '\b') { conditionId = 1; }
            else if(condition == '\f') { conditionId = 2; }
            else if(condition == '\n') { conditionId = 3; }
            else if(condition == '\r') { conditionId = 4; }
            else if(condition == '\t') { conditionId = 5; }
            else if(condition == '\v') { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    buf = append(buf, "\\a");
                    break;
                case 1:
                    buf = append(buf, "\\b");
                    break;
                case 2:
                    buf = append(buf, "\\f");
                    break;
                case 3:
                    buf = append(buf, "\\n");
                    break;
                case 4:
                    buf = append(buf, "\\r");
                    break;
                case 5:
                    buf = append(buf, "\\t");
                    break;
                case 6:
                    buf = append(buf, "\\v");
                    break;
                default:
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(r < ' ' || r == 0x7f) { conditionId = 0; }
                        else if(! utf8::ValidRune(r)) { conditionId = 1; }
                        else if(r < 0x10000) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                buf = append(buf, "\\x");
                                buf = append(buf, lowerhex[unsigned char(r) >> 4]);
                                buf = append(buf, lowerhex[unsigned char(r) & 0xF]);
                                break;
                            case 1:
                                r = 0xFFFD;
                            case 2:
                                buf = append(buf, "\\u");
                                for(auto s = 12; s >= 0; s -= 4)
                                {
                                    buf = append(buf, lowerhex[(r >> (unsigned int)(s)) & 0xF]);
                                }
                                break;
                            default:
                                buf = append(buf, "\\U");
                                for(auto s = 28; s >= 0; s -= 4)
                                {
                                    buf = append(buf, lowerhex[(r >> (unsigned int)(s)) & 0xF]);
                                }
                                break;
                        }
                    }
                    break;
            }
        }
        return buf;
    }

    std::string Quote(std::string s)
    {
        return quoteWith(s, '"', false, false);
    }

    gocpp::slice<unsigned char> AppendQuote(gocpp::slice<unsigned char> dst, std::string s)
    {
        return appendQuotedWith(dst, s, '"', false, false);
    }

    std::string QuoteToASCII(std::string s)
    {
        return quoteWith(s, '"', true, false);
    }

    gocpp::slice<unsigned char> AppendQuoteToASCII(gocpp::slice<unsigned char> dst, std::string s)
    {
        return appendQuotedWith(dst, s, '"', true, false);
    }

    std::string QuoteToGraphic(std::string s)
    {
        return quoteWith(s, '"', false, true);
    }

    gocpp::slice<unsigned char> AppendQuoteToGraphic(gocpp::slice<unsigned char> dst, std::string s)
    {
        return appendQuotedWith(dst, s, '"', false, true);
    }

    std::string QuoteRune(gocpp::rune r)
    {
        return quoteRuneWith(r, '\'', false, false);
    }

    gocpp::slice<unsigned char> AppendQuoteRune(gocpp::slice<unsigned char> dst, gocpp::rune r)
    {
        return appendQuotedRuneWith(dst, r, '\'', false, false);
    }

    std::string QuoteRuneToASCII(gocpp::rune r)
    {
        return quoteRuneWith(r, '\'', true, false);
    }

    gocpp::slice<unsigned char> AppendQuoteRuneToASCII(gocpp::slice<unsigned char> dst, gocpp::rune r)
    {
        return appendQuotedRuneWith(dst, r, '\'', true, false);
    }

    std::string QuoteRuneToGraphic(gocpp::rune r)
    {
        return quoteRuneWith(r, '\'', false, true);
    }

    gocpp::slice<unsigned char> AppendQuoteRuneToGraphic(gocpp::slice<unsigned char> dst, gocpp::rune r)
    {
        return appendQuotedRuneWith(dst, r, '\'', false, true);
    }

    bool CanBackquote(std::string s)
    {
        for(; len(s) > 0; )
        {
            auto [r, wid] = utf8::DecodeRuneInString(s);
            s = s.make_slice(wid);
            if(wid > 1)
            {
                if(r == '\ufeff')
                {
                    return false;
                }
                continue;
            }
            if(r == utf8::RuneError)
            {
                return false;
            }
            if((r < ' ' && r != '\t') || r == '`' || r == '\u007F')
            {
                return false;
            }
        }
        return true;
    }

    std::tuple<gocpp::rune, bool> unhex(unsigned char b)
    {
        gocpp::rune v;
        bool ok;
        auto c = rune(b);
        //Go switch emulation
        {
            int conditionId = -1;
            if('0' <= c && c <= '9') { conditionId = 0; }
            else if('a' <= c && c <= 'f') { conditionId = 1; }
            else if('A' <= c && c <= 'F') { conditionId = 2; }
            switch(conditionId)
            {
                gocpp::rune v;
                bool ok;
                case 0:
                    return {c - '0', true};
                    break;
                case 1:
                    return {c - 'a' + 10, true};
                    break;
                case 2:
                    return {c - 'A' + 10, true};
                    break;
            }
        }
        return {v, ok};
    }

    std::tuple<gocpp::rune, bool, std::string, struct gocpp::error> UnquoteChar(std::string s, unsigned char quote)
    {
        gocpp::rune value;
        bool multibyte;
        std::string tail;
        struct gocpp::error err;
        if(len(s) == 0)
        {
            gocpp::rune value;
            bool multibyte;
            std::string tail;
            struct gocpp::error err;
            err = ErrSyntax;
            return {value, multibyte, tail, err};
        }
        //Go switch emulation
        {
            auto c = s[0];
            int conditionId = -1;
            if(c == quote && (quote == '\'' || quote == '"')) { conditionId = 0; }
            else if(c >= utf8::RuneSelf) { conditionId = 1; }
            else if(c != '\\') { conditionId = 2; }
            switch(conditionId)
            {
                gocpp::rune value;
                bool multibyte;
                std::string tail;
                struct gocpp::error err;
                case 0:
                    err = ErrSyntax;
                    return {value, multibyte, tail, err};
                    break;
                case 1:
                    auto [r, size] = utf8::DecodeRuneInString(s);
                    return {r, true, s.make_slice(size), nullptr};
                    break;
                case 2:
                    return {rune(s[0]), false, s.make_slice(1), nullptr};
                    break;
            }
        }
        if(len(s) <= 1)
        {
            gocpp::rune value;
            bool multibyte;
            std::string tail;
            struct gocpp::error err;
            err = ErrSyntax;
            return {value, multibyte, tail, err};
        }
        auto c = s[1];
        s = s.make_slice(2);
        //Go switch emulation
        {
            auto condition = c;
            int conditionId = -1;
            if(condition == 'a') { conditionId = 0; }
            else if(condition == 'b') { conditionId = 1; }
            else if(condition == 'f') { conditionId = 2; }
            else if(condition == 'n') { conditionId = 3; }
            else if(condition == 'r') { conditionId = 4; }
            else if(condition == 't') { conditionId = 5; }
            else if(condition == 'v') { conditionId = 6; }
            else if(condition == 'x') { conditionId = 7; }
            else if(condition == 'u') { conditionId = 8; }
            else if(condition == 'U') { conditionId = 9; }
            else if(condition == '0') { conditionId = 10; }
            else if(condition == '1') { conditionId = 11; }
            else if(condition == '2') { conditionId = 12; }
            else if(condition == '3') { conditionId = 13; }
            else if(condition == '4') { conditionId = 14; }
            else if(condition == '5') { conditionId = 15; }
            else if(condition == '6') { conditionId = 16; }
            else if(condition == '7') { conditionId = 17; }
            else if(condition == '\\') { conditionId = 18; }
            else if(condition == '\'') { conditionId = 19; }
            else if(condition == '"') { conditionId = 20; }
            switch(conditionId)
            {
                gocpp::rune value;
                bool multibyte;
                std::string tail;
                struct gocpp::error err;
                case 0:
                    value = '\a';
                    break;
                case 1:
                    value = '\b';
                    break;
                case 2:
                    value = '\f';
                    break;
                case 3:
                    value = '\n';
                    break;
                case 4:
                    value = '\r';
                    break;
                case 5:
                    value = '\t';
                    break;
                case 6:
                    value = '\v';
                    break;
                case 7:
                case 8:
                case 9:
                    auto n = 0;
                    //Go switch emulation
                    {
                        auto condition = c;
                        int conditionId = -1;
                        if(condition == 'x') { conditionId = 0; }
                        else if(condition == 'u') { conditionId = 1; }
                        else if(condition == 'U') { conditionId = 2; }
                        switch(conditionId)
                        {
                            gocpp::rune value;
                            bool multibyte;
                            std::string tail;
                            struct gocpp::error err;
                            case 0:
                                n = 2;
                                break;
                            case 1:
                                n = 4;
                                break;
                            case 2:
                                n = 8;
                                break;
                        }
                    }
                    gocpp::rune v = {};
                    if(len(s) < n)
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    for(auto j = 0; j < n; j++)
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        auto [x, ok] = unhex(s[j]);
                        if(! ok)
                        {
                            gocpp::rune value;
                            bool multibyte;
                            std::string tail;
                            struct gocpp::error err;
                            err = ErrSyntax;
                            return {value, multibyte, tail, err};
                        }
                        v = (v << 4) | x;
                    }
                    s = s.make_slice(n);
                    if(c == 'x')
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        value = v;
                        break;
                    }
                    if(! utf8::ValidRune(v))
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    value = v;
                    multibyte = true;
                    break;
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                    auto v = rune(c) - '0';
                    if(len(s) < 2)
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    for(auto j = 0; j < 2; j++)
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        auto x = rune(s[j]) - '0';
                        if(x < 0 || x > 7)
                        {
                            gocpp::rune value;
                            bool multibyte;
                            std::string tail;
                            struct gocpp::error err;
                            err = ErrSyntax;
                            return {value, multibyte, tail, err};
                        }
                        v = (v << 3) | x;
                    }
                    s = s.make_slice(2);
                    if(v > 255)
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    value = v;
                    break;
                case 18:
                    value = '\\';
                    break;
                case 19:
                case 20:
                    if(c != quote)
                    {
                        gocpp::rune value;
                        bool multibyte;
                        std::string tail;
                        struct gocpp::error err;
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    value = rune(c);
                    break;
                default:
                    err = ErrSyntax;
                    return {value, multibyte, tail, err};
                    break;
            }
        }
        tail = s;
        return {value, multibyte, tail, err};
    }

    std::tuple<std::string, struct gocpp::error> QuotedPrefix(std::string s)
    {
        auto [out, gocpp_id_1, err] = unquote(s, false);
        return {out, err};
    }

    std::tuple<std::string, struct gocpp::error> Unquote(std::string s)
    {
        auto [out, rem, err] = unquote(s, true);
        if(len(rem) > 0)
        {
            return {"", ErrSyntax};
        }
        return {out, err};
    }

    std::tuple<std::string, std::string, struct gocpp::error> unquote(std::string in, bool unescape)
    {
        std::string out;
        std::string rem;
        struct gocpp::error err;
        if(len(in) < 2)
        {
            std::string out;
            std::string rem;
            struct gocpp::error err;
            return {"", in, ErrSyntax};
        }
        auto quote = in[0];
        auto end = index(in.make_slice(1), quote);
        if(end < 0)
        {
            std::string out;
            std::string rem;
            struct gocpp::error err;
            return {"", in, ErrSyntax};
        }
        end += 2;
        //Go switch emulation
        {
            auto condition = quote;
            int conditionId = -1;
            if(condition == '`') { conditionId = 0; }
            else if(condition == '"') { conditionId = 1; }
            else if(condition == '\'') { conditionId = 2; }
            switch(conditionId)
            {
                std::string out;
                std::string rem;
                struct gocpp::error err;
                case 0:
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(! unescape) { conditionId = 0; }
                        else if(! contains(in.make_slice(0, end), '\r')) { conditionId = 1; }
                        switch(conditionId)
                        {
                            std::string out;
                            std::string rem;
                            struct gocpp::error err;
                            case 0:
                                out = in.make_slice(0, end);
                                break;
                            case 1:
                                out = in.make_slice(len("`"), end - len("`"));
                                break;
                            default:
                                auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, end - len("`") - len("\r") - len("`"));
                                for(auto i = len("`"); i < end - len("`"); i++)
                                {
                                    std::string out;
                                    std::string rem;
                                    struct gocpp::error err;
                                    if(in[i] != '\r')
                                    {
                                        std::string out;
                                        std::string rem;
                                        struct gocpp::error err;
                                        buf = append(buf, in[i]);
                                    }
                                }
                                out = string(buf);
                                break;
                        }
                    }
                    return {out, in.make_slice(end), nullptr};
                    break;
                case 1:
                case 2:
                    if(! contains(in.make_slice(0, end), '\\') && ! contains(in.make_slice(0, end), '\n'))
                    {
                        std::string out;
                        std::string rem;
                        struct gocpp::error err;
                        bool valid = {};
                        //Go switch emulation
                        {
                            auto condition = quote;
                            int conditionId = -1;
                            if(condition == '"') { conditionId = 0; }
                            else if(condition == '\'') { conditionId = 1; }
                            switch(conditionId)
                            {
                                std::string out;
                                std::string rem;
                                struct gocpp::error err;
                                case 0:
                                    valid = utf8::ValidString(in.make_slice(len("""), end - len(""")));
                                    break;
                                case 1:
                                    auto [r, n] = utf8::DecodeRuneInString(in.make_slice(len("'"), end - len("'")));
                                    valid = len("'") + n + len("'") == end && (r != utf8::RuneError || n != 1);
                                    break;
                            }
                        }
                        if(valid)
                        {
                            std::string out;
                            std::string rem;
                            struct gocpp::error err;
                            out = in.make_slice(0, end);
                            if(unescape)
                            {
                                std::string out;
                                std::string rem;
                                struct gocpp::error err;
                                out = out.make_slice(1, end - 1);
                            }
                            return {out, in.make_slice(end), nullptr};
                        }
                    }
                    gocpp::slice<unsigned char> buf = {};
                    auto in0 = in;
                    in = in.make_slice(1);
                    if(unescape)
                    {
                        std::string out;
                        std::string rem;
                        struct gocpp::error err;
                        buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 3 * end / 2);
                    }
                    for(; len(in) > 0 && in[0] != quote; )
                    {
                        std::string out;
                        std::string rem;
                        struct gocpp::error err;
                        auto [r, multibyte, rem, err] = UnquoteChar(in, quote);
                        if(in[0] == '\n' || err != nullptr)
                        {
                            std::string out;
                            std::string rem;
                            struct gocpp::error err;
                            return {"", in0, ErrSyntax};
                        }
                        in = rem;
                        if(unescape)
                        {
                            std::string out;
                            std::string rem;
                            struct gocpp::error err;
                            if(r < utf8::RuneSelf || ! multibyte)
                            {
                                std::string out;
                                std::string rem;
                                struct gocpp::error err;
                                buf = append(buf, unsigned char(r));
                            }
                            else
                            {
                                std::string out;
                                std::string rem;
                                struct gocpp::error err;
                                buf = utf8::AppendRune(buf, r);
                            }
                        }
                        if(quote == '\'')
                        {
                            std::string out;
                            std::string rem;
                            struct gocpp::error err;
                            break;
                        }
                    }
                    if(! (len(in) > 0 && in[0] == quote))
                    {
                        std::string out;
                        std::string rem;
                        struct gocpp::error err;
                        return {"", in0, ErrSyntax};
                    }
                    in = in.make_slice(1);
                    if(unescape)
                    {
                        std::string out;
                        std::string rem;
                        struct gocpp::error err;
                        return {string(buf), in, nullptr};
                    }
                    return {in0.make_slice(0, len(in0) - len(in)), in, nullptr};
                    break;
                default:
                    return {"", in, ErrSyntax};
                    break;
            }
        }
    }

    int bsearch16(gocpp::slice<uint16_t> a, uint16_t x)
    {
        auto [i, j] = std::tuple{0, len(a)};
        for(; i < j; )
        {
            auto h = i + ((j - i) >> 1);
            if(a[h] < x)
            {
                i = h + 1;
            }
            else
            {
                j = h;
            }
        }
        return i;
    }

    int bsearch32(gocpp::slice<uint32_t> a, uint32_t x)
    {
        auto [i, j] = std::tuple{0, len(a)};
        for(; i < j; )
        {
            auto h = i + ((j - i) >> 1);
            if(a[h] < x)
            {
                i = h + 1;
            }
            else
            {
                j = h;
            }
        }
        return i;
    }

    bool IsPrint(gocpp::rune r)
    {
        if(r <= 0xFF)
        {
            if(0x20 <= r && r <= 0x7E)
            {
                return true;
            }
            if(0xA1 <= r && r <= 0xFF)
            {
                return r != 0xAD;
            }
            return false;
        }
        if(0 <= r && r < (1 << 16))
        {
            auto [rr, isPrint, isNotPrint] = std::tuple{uint16_t(r), isPrint16, isNotPrint16};
            auto i = bsearch16(isPrint, rr);
            if(i >= len(isPrint) || rr < isPrint[i &^ 1] || isPrint[i | 1] < rr)
            {
                return false;
            }
            auto j = bsearch16(isNotPrint, rr);
            return j >= len(isNotPrint) || isNotPrint[j] != rr;
        }
        auto [rr, isPrint, isNotPrint] = std::tuple{uint32_t(r), isPrint32, isNotPrint32};
        auto i = bsearch32(isPrint, rr);
        if(i >= len(isPrint) || rr < isPrint[i &^ 1] || isPrint[i | 1] < rr)
        {
            return false;
        }
        if(r >= 0x20000)
        {
            return true;
        }
        r -= 0x10000;
        auto j = bsearch16(isNotPrint, uint16_t(r));
        return j >= len(isNotPrint) || isNotPrint[j] != uint16_t(r);
    }

    bool IsGraphic(gocpp::rune r)
    {
        if(IsPrint(r))
        {
            return true;
        }
        return isInGraphicList(r);
    }

    bool isInGraphicList(gocpp::rune r)
    {
        if(r > 0xFFFF)
        {
            return false;
        }
        auto rr = uint16_t(r);
        auto i = bsearch16(isGraphic, rr);
        return i < len(isGraphic) && rr == isGraphic[i];
    }

}

