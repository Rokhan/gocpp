// generated by GoCpp from file '$(ImportDir)/syscall/dll_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/dll_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"

namespace golang::syscall
{
    struct DLLError
    {
        gocpp::error Err;
        std::string ObjName;
        std::string Msg;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct DLLError& value);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall6(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall9(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall12(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall15(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> Syscall18(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15, uintptr_t a16, uintptr_t a17, uintptr_t a18);
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> SyscallN(uintptr_t trap, gocpp::slice<uintptr_t> args);
    
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> SyscallN(uintptr_t trap, Args... args)
    {
        return SyscallN(trap, gocpp::ToSlice<uintptr_t>(args...));
    }
    
    template<typename... Args>
    std::tuple<uintptr_t, uintptr_t, syscall::Errno> SyscallN(uintptr_t trap, uintptr_t value, Args... args)
    {
        return SyscallN(trap, gocpp::ToSlice<uintptr_t>(value, args...));
    }
    std::tuple<uintptr_t, syscall::Errno> loadlibrary(uint16_t* filename);
    std::tuple<uintptr_t, syscall::Errno> loadsystemlibrary(uint16_t* filename);
    std::tuple<uintptr_t, syscall::Errno> getprocaddress(uintptr_t handle, uint8_t* procname);
    struct DLL
    {
        std::string Name;
        syscall::Handle Handle;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct DLL& value);
    std::tuple<struct DLL*, struct gocpp::error> LoadDLL(std::string name);
    struct DLL* MustLoadDLL(std::string name);
    struct Proc
    {
        DLL* Dll;
        std::string Name;
        uintptr_t addr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Proc& value);
    struct LazyDLL
    {
        mocklib::Mutex mu;
        DLL* dll;
        std::string Name;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct LazyDLL& value);
    struct LazyDLL* NewLazyDLL(std::string name);
    struct LazyProc
    {
        mocklib::Mutex mu;
        std::string Name;
        LazyDLL* l;
        Proc* proc;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct LazyProc& value);

    namespace rec
    {
        std::string Error(struct DLLError* e);
        struct gocpp::error Unwrap(struct DLLError* e);
        std::tuple<struct Proc*, struct gocpp::error> FindProc(struct DLL* d, std::string name);
        struct Proc* MustFindProc(struct DLL* d, std::string name);
        struct gocpp::error Release(struct DLL* d);
        uintptr_t Addr(struct Proc* p);
        std::tuple<uintptr_t, uintptr_t, struct gocpp::error> Call(struct Proc* p, gocpp::slice<uintptr_t> a);
        
        template<typename... Args>
        std::tuple<uintptr_t, uintptr_t, struct gocpp::error> Call(struct Proc* p, Args... a)
        {
            return Call(p, gocpp::ToSlice<uintptr_t>(a...));
        }
        
        template<typename... Args>
        std::tuple<uintptr_t, uintptr_t, struct gocpp::error> Call(struct Proc* p, uintptr_t value, Args... a)
        {
            return Call(p, gocpp::ToSlice<uintptr_t>(value, a...));
        }
        struct gocpp::error Load(struct LazyDLL* d);
        void mustLoad(struct LazyDLL* d);
        uintptr_t Handle(struct LazyDLL* d);
        struct LazyProc* NewProc(struct LazyDLL* d, std::string name);
        struct gocpp::error Find(struct LazyProc* p);
        void mustFind(struct LazyProc* p);
        uintptr_t Addr(struct LazyProc* p);
        std::tuple<uintptr_t, uintptr_t, struct gocpp::error> Call(struct LazyProc* p, gocpp::slice<uintptr_t> a);
        
        template<typename... Args>
        std::tuple<uintptr_t, uintptr_t, struct gocpp::error> Call(struct LazyProc* p, Args... a)
        {
            return Call(p, gocpp::ToSlice<uintptr_t>(a...));
        }
        
        template<typename... Args>
        std::tuple<uintptr_t, uintptr_t, struct gocpp::error> Call(struct LazyProc* p, uintptr_t value, Args... a)
        {
            return Call(p, gocpp::ToSlice<uintptr_t>(value, a...));
        }
    }
}

