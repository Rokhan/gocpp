// generated by GoCpp from file '$(ImportDir)/runtime/signal_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/signal_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/arena.h"
// #include "golang/runtime/defs_windows.h"  [Ignored, known errors]
#include "golang/runtime/defs_windows_amd64.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/preempt.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/traceback.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    extern int _SEM_FAILCRITICALERRORS;
    extern int _SEM_NOGPFAULTERRORBOX;
    extern int _SEM_NOOPENFILEERRORBOX;
    extern int _WER_FAULT_REPORTING_NO_UI;
    void preventErrorDialogs();
    void enableWER();
    void exceptiontramp();
    void firstcontinuetramp();
    void lastcontinuetramp();
    void sehtramp();
    void sigresume();
    void initExceptionHandler();
    bool isAbort(context* r);
    bool isgoexception(exceptionrecord* info, context* r);
    extern int callbackVEH;
    extern int callbackFirstVCH;
    extern int callbackLastVCH;
    g* sigFetchGSafe();
    g* sigFetchG();
    int32_t sigtrampgo(exceptionpointers* ep, int kind);
    int32_t exceptionhandler(exceptionrecord* info, context* r, g* gp);
    int32_t sehhandler(exceptionrecord* _, uint64_t _, context* _, _DISPATCHER_CONTEXT* dctxt);
    int32_t firstcontinuehandler(exceptionrecord* info, context* r, g* gp);
    int32_t lastcontinuehandler(exceptionrecord* info, context* r, g* gp);
    void winthrow(exceptionrecord* info, context* r, g* gp);
    void sigpanic();
    void initsig(bool preinit);
    void sigenable(uint32_t sig);
    void sigdisable(uint32_t sig);
    void sigignore(uint32_t sig);
    std::string signame(uint32_t sig);
    void crash();
    void dieFromException(exceptionrecord* info, context* r);
    struct gsignalStack
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const gsignalStack& value);
}

