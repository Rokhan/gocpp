// generated by GoCpp from file '$(ImportDir)/io/fs/fs.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/io/fs/fs.h"
#include "gocpp/support.h"

#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/unicode/utf8/utf8.h"

// Package fs defines basic interfaces to a file system.
// A file system can be provided by the host operating system
// but also by other packages.
//
// See the [testing/fstest] package for support with testing
// implementations of file systems.
namespace golang::fs
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // An FS provides access to a hierarchical file system.
    //
    // The FS interface is the minimum implementation required of the file system.
    // A file system may implement additional interfaces,
    // such as [ReadFileFS], to provide additional or optimized functionality.
    //
    // [testing/fstest.TestFS] may be used to test implementations of an FS for
    // correctness.
    
    template<typename T>
    FS::FS(T& ref)
    {
        value.reset(new FSImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FS::FS(const T& ref)
    {
        value.reset(new FSImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FS::FS(T* ptr)
    {
        value.reset(new FSImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& FS::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<struct File, struct gocpp::error> FS::FSImpl<T, StoreT>::vOpen(gocpp::string name)
    {
        return rec::Open(gocpp::PtrRecv<T, false>(value.get()), name);
    }

    namespace rec
    {
        std::tuple<struct File, struct gocpp::error> Open(const gocpp::PtrRecv<struct FS, false>& self, gocpp::string name)
        {
            return self.ptr->value->vOpen(name);
        }

        std::tuple<struct File, struct gocpp::error> Open(const gocpp::ObjRecv<struct FS>& self, gocpp::string name)
        {
            return self.obj.value->vOpen(name);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct FS& value)
    {
        return value.PrintTo(os);
    }

    // ValidPath reports whether the given path name
    // is valid for use in a call to Open.
    //
    // Path names passed to open are UTF-8-encoded,
    // unrooted, slash-separated sequences of path elements, like “x/y/z”.
    // Path names must not contain an element that is “.” or “..” or the empty string,
    // except for the special case that the root directory is named “.”.
    // Paths must not start or end with a slash: “/x” and “x/” are invalid.
    //
    // Note that paths are slash-separated on all systems, even Windows.
    // Paths containing other characters such as backslash and colon
    // are accepted as valid, but those characters must never be
    // interpreted by an [FS] implementation as path element separators.
    bool ValidPath(gocpp::string name)
    {
        if(! utf8::ValidString(name))
        {
            return false;
        }
        if(name == "."_s)
        {
            return true;
        }
        for(; ; )
        {
            auto i = 0;
            for(; i < len(name) && name[i] != '/'; )
            {
                i++;
            }
            auto elem = name.make_slice(0, i);
            if(elem == ""_s || elem == "."_s || elem == ".."_s)
            {
                return false;
            }
            if(i == len(name))
            {
                return true;
            }
            name = name.make_slice(i + 1);
        }
    }

    // A File provides access to a single file.
    // The File interface is the minimum implementation required of the file.
    // Directory files should also implement [ReadDirFile].
    // A file may implement [io.ReaderAt] or [io.Seeker] as optimizations.
    
    template<typename T>
    File::File(T& ref)
    {
        value.reset(new FileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    File::File(const T& ref)
    {
        value.reset(new FileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    File::File(T* ptr)
    {
        value.reset(new FileImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& File::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<struct FileInfo, struct gocpp::error> File::FileImpl<T, StoreT>::vStat()
    {
        return rec::Stat(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> File::FileImpl<T, StoreT>::vRead(gocpp::slice<unsigned char> _1)
    {
        return rec::Read(gocpp::PtrRecv<T, false>(value.get()), _1);
    }
    template<typename T, typename StoreT>
    struct gocpp::error File::FileImpl<T, StoreT>::vClose()
    {
        return rec::Close(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<struct FileInfo, struct gocpp::error> Stat(const gocpp::PtrRecv<struct File, false>& self)
        {
            return self.ptr->value->vStat();
        }

        std::tuple<struct FileInfo, struct gocpp::error> Stat(const gocpp::ObjRecv<struct File>& self)
        {
            return self.obj.value->vStat();
        }

        std::tuple<int, struct gocpp::error> Read(const gocpp::PtrRecv<struct File, false>& self, gocpp::slice<unsigned char> _1)
        {
            return self.ptr->value->vRead(_1);
        }

        std::tuple<int, struct gocpp::error> Read(const gocpp::ObjRecv<struct File>& self, gocpp::slice<unsigned char> _1)
        {
            return self.obj.value->vRead(_1);
        }

        struct gocpp::error Close(const gocpp::PtrRecv<struct File, false>& self)
        {
            return self.ptr->value->vClose();
        }

        struct gocpp::error Close(const gocpp::ObjRecv<struct File>& self)
        {
            return self.obj.value->vClose();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct File& value)
    {
        return value.PrintTo(os);
    }

    // A DirEntry is an entry read from a directory
    // (using the [ReadDir] function or a [ReadDirFile]'s ReadDir method).
    
    template<typename T>
    DirEntry::DirEntry(T& ref)
    {
        value.reset(new DirEntryImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    DirEntry::DirEntry(const T& ref)
    {
        value.reset(new DirEntryImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    DirEntry::DirEntry(T* ptr)
    {
        value.reset(new DirEntryImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& DirEntry::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::string DirEntry::DirEntryImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool DirEntry::DirEntryImpl<T, StoreT>::vIsDir()
    {
        return rec::IsDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    fs::FileMode DirEntry::DirEntryImpl<T, StoreT>::vType()
    {
        return rec::Type(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<struct FileInfo, struct gocpp::error> DirEntry::DirEntryImpl<T, StoreT>::vInfo()
    {
        return rec::Info(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        gocpp::string Name(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vName();
        }

        gocpp::string Name(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vName();
        }

        bool IsDir(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vIsDir();
        }

        bool IsDir(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vIsDir();
        }

        fs::FileMode Type(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vType();
        }

        fs::FileMode Type(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vType();
        }

        std::tuple<struct FileInfo, struct gocpp::error> Info(const gocpp::PtrRecv<struct DirEntry, false>& self)
        {
            return self.ptr->value->vInfo();
        }

        std::tuple<struct FileInfo, struct gocpp::error> Info(const gocpp::ObjRecv<struct DirEntry>& self)
        {
            return self.obj.value->vInfo();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct DirEntry& value)
    {
        return value.PrintTo(os);
    }

    // A ReadDirFile is a directory file whose entries can be read with the ReadDir method.
    // Every directory file should implement this interface.
    // (It is permissible for any file to implement this interface,
    // but if so ReadDir should return an error for non-directories.)
    
    template<typename T>
    ReadDirFile::ReadDirFile(T& ref)
    {
        value.reset(new ReadDirFileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadDirFile::ReadDirFile(const T& ref)
    {
        value.reset(new ReadDirFileImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    ReadDirFile::ReadDirFile(T* ptr)
    {
        value.reset(new ReadDirFileImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& ReadDirFile::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDirFile::ReadDirFileImpl<T, StoreT>::vReadDir(int n)
    {
        return rec::ReadDir(gocpp::PtrRecv<T, false>(value.get()), n);
    }

    namespace rec
    {
        std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDir(const gocpp::PtrRecv<struct ReadDirFile, false>& self, int n)
        {
            return self.ptr->value->vReadDir(n);
        }

        std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDir(const gocpp::ObjRecv<struct ReadDirFile>& self, int n)
        {
            return self.obj.value->vReadDir(n);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct ReadDirFile& value)
    {
        return value.PrintTo(os);
    }

    // Generic file system errors.
    // Errors returned by file systems can be tested against these errors
    // using [errors.Is].
    gocpp::error ErrInvalid = errInvalid();
    gocpp::error ErrPermission = errPermission();
    gocpp::error ErrExist = errExist();
    gocpp::error ErrNotExist = errNotExist();
    gocpp::error ErrClosed = errClosed();
    struct gocpp::error errInvalid()
    {
        return oserror::ErrInvalid;
    }

    struct gocpp::error errPermission()
    {
        return oserror::ErrPermission;
    }

    struct gocpp::error errExist()
    {
        return oserror::ErrExist;
    }

    struct gocpp::error errNotExist()
    {
        return oserror::ErrNotExist;
    }

    struct gocpp::error errClosed()
    {
        return oserror::ErrClosed;
    }

    // A FileInfo describes a file and is returned by [Stat].
    
    template<typename T>
    FileInfo::FileInfo(T& ref)
    {
        value.reset(new FileInfoImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FileInfo::FileInfo(const T& ref)
    {
        value.reset(new FileInfoImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    FileInfo::FileInfo(T* ptr)
    {
        value.reset(new FileInfoImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& FileInfo::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::string FileInfo::FileInfoImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int64_t FileInfo::FileInfoImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    fs::FileMode FileInfo::FileInfoImpl<T, StoreT>::vMode()
    {
        return rec::Mode(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    mocklib::Date FileInfo::FileInfoImpl<T, StoreT>::vModTime()
    {
        return rec::ModTime(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool FileInfo::FileInfoImpl<T, StoreT>::vIsDir()
    {
        return rec::IsDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    go_any FileInfo::FileInfoImpl<T, StoreT>::vSys()
    {
        return rec::Sys(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        gocpp::string Name(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vName();
        }

        gocpp::string Name(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vName();
        }

        int64_t Size(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vSize();
        }

        int64_t Size(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vSize();
        }

        fs::FileMode Mode(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vMode();
        }

        fs::FileMode Mode(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vMode();
        }

        mocklib::Date ModTime(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vModTime();
        }

        mocklib::Date ModTime(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vModTime();
        }

        bool IsDir(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vIsDir();
        }

        bool IsDir(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vIsDir();
        }

        go_any Sys(const gocpp::PtrRecv<struct FileInfo, false>& self)
        {
            return self.ptr->value->vSys();
        }

        go_any Sys(const gocpp::ObjRecv<struct FileInfo>& self)
        {
            return self.obj.value->vSys();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct FileInfo& value)
    {
        return value.PrintTo(os);
    }

    // A FileMode represents a file's mode and permission bits.
    // The bits have the same definition on all systems, so that
    // information about files can be moved from one system
    // to another portably. Not all bits apply to all systems.
    // The only required bit is [ModeDir] for directories.
    // The defined file mode bits are the most significant bits of the [FileMode].
    // The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
    // The values of these bits should be considered part of the public API and
    // may be used in wire protocols or disk representations: they must not be
    // changed, although new bits might be added.
    // The single letters are the abbreviations
    // used by the String method's formatting.
    // Mask for the type bits. For regular files, none will be set.
    gocpp::string rec::String(golang::fs::FileMode m)
    {
        auto str = "dalTLDpSugct?"_s;
        gocpp::array<unsigned char, 32> buf = {};
        auto w = 0;
        for(auto [i, c] : str)
        {
            if(m & (1 << (unsigned int)(32 - 1 - i)) != 0)
            {
                buf[w] = (unsigned char)(c);
                w++;
            }
        }
        if(w == 0)
        {
            buf[w] = '-';
            w++;
        }
        auto rwx = "rwxrwxrwx"_s;
        for(auto [i, c] : rwx)
        {
            if(m & (1 << (unsigned int)(9 - 1 - i)) != 0)
            {
                buf[w] = (unsigned char)(c);
            }
            else
            {
                buf[w] = '-';
            }
            w++;
        }
        return gocpp::string(buf.make_slice(0, w));
    }

    // IsDir reports whether m describes a directory.
    // That is, it tests for the [ModeDir] bit being set in m.
    bool rec::IsDir(golang::fs::FileMode m)
    {
        return m & ModeDir != 0;
    }

    // IsRegular reports whether m describes a regular file.
    // That is, it tests that no mode type bits are set.
    bool rec::IsRegular(golang::fs::FileMode m)
    {
        return m & ModeType == 0;
    }

    // Perm returns the Unix permission bits in m (m & [ModePerm]).
    fs::FileMode rec::Perm(golang::fs::FileMode m)
    {
        return m & ModePerm;
    }

    // Type returns type bits in m (m & [ModeType]).
    fs::FileMode rec::Type(golang::fs::FileMode m)
    {
        return m & ModeType;
    }

    // PathError records an error and the operation and file path that caused it.
    
    template<typename T> requires gocpp::GoStruct<T>
    PathError::operator T()
    {
        T result;
        result.Op = this->Op;
        result.Path = this->Path;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool PathError::operator==(const T& ref) const
    {
        if (Op != ref.Op) return false;
        if (Path != ref.Path) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& PathError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Op;
        os << " " << Path;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct PathError& value)
    {
        return value.PrintTo(os);
    }

    gocpp::string rec::Error(struct PathError* e)
    {
        return e->Op + " "_s + e->Path + ": "_s + rec::Error(gocpp::recv(e->Err));
    }

    struct gocpp::error rec::Unwrap(struct PathError* e)
    {
        return e->Err;
    }

    
        template<typename T>
        gocpp_id_0::gocpp_id_0(T& ref)
        {
            value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
        }

        template<typename T>
        gocpp_id_0::gocpp_id_0(const T& ref)
        {
            value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
        }

        template<typename T>
        gocpp_id_0::gocpp_id_0(T* ptr)
        {
            value.reset(new gocpp_id_0Impl<T, gocpp::ptr<T>>(ptr));
        }

        std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
        {
            return os;
        }

        template<typename T, typename StoreT>
        bool gocpp_id_0::gocpp_id_0Impl<T, StoreT>::vTimeout()
        {
            return rec::Timeout(gocpp::PtrRecv<T, false>(value.get()));
        }

        namespace rec
        {
            bool Timeout(const gocpp::PtrRecv<struct gocpp_id_0, false>& self)
            {
                return self.ptr->value->vTimeout();
            }

            bool Timeout(const gocpp::ObjRecv<struct gocpp_id_0>& self)
            {
                return self.obj.value->vTimeout();
            }
        }

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
        {
            return value.PrintTo(os);
        }


    // Timeout reports whether this error represents a timeout.
    bool rec::Timeout(struct PathError* e)
    {
        auto [t, ok] = gocpp::getValue<gocpp_id_0>(e->Err);
        return ok && rec::Timeout(gocpp::recv(t));
    }

}

