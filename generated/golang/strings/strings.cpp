// generated by GoCpp from file '$(ImportDir)/strings/strings.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strings/strings.h"
#include "gocpp/support.h"

#include "golang/internal/bytealg/bytealg.h"
#include "golang/internal/bytealg/count_native.h"
#include "golang/internal/bytealg/index_amd64.h"
#include "golang/internal/bytealg/index_native.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/bytealg/lastindexbyte_generic.h"
#include "golang/strings/builder.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/letter.h"
#include "golang/unicode/utf8/utf8.h"

// Package strings implements simple functions to manipulate UTF-8 encoded strings.
//
// For information about UTF-8 strings in Go, see https://blog.golang.org/strings.
namespace golang::strings
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // explode splits s into a slice of UTF-8 strings,
    // one string per Unicode character up to a maximum of n (n < 0 means no limit).
    // Invalid UTF-8 bytes are sliced individually.
    gocpp::slice<std::string> explode(std::string s, int n)
    {
        auto l = utf8::RuneCountInString(s);
        if(n < 0 || n > l)
        {
            n = l;
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        for(auto i = 0; i < n - 1; i++)
        {
            auto [gocpp_id_0, size] = utf8::DecodeRuneInString(s);
            a[i] = s.make_slice(0, size);
            s = s.make_slice(size);
        }
        if(n > 0)
        {
            a[n - 1] = s;
        }
        return a;
    }

    // Count counts the number of non-overlapping instances of substr in s.
    // If substr is an empty string, Count returns 1 + the number of Unicode code points in s.
    int Count(std::string s, std::string substr)
    {
        if(len(substr) == 0)
        {
            return utf8::RuneCountInString(s) + 1;
        }
        if(len(substr) == 1)
        {
            return bytealg::CountString(s, substr[0]);
        }
        auto n = 0;
        for(; ; )
        {
            auto i = Index(s, substr);
            if(i == - 1)
            {
                return n;
            }
            n++;
            s = s.make_slice(i + len(substr));
        }
    }

    // Contains reports whether substr is within s.
    bool Contains(std::string s, std::string substr)
    {
        return Index(s, substr) >= 0;
    }

    // ContainsAny reports whether any Unicode code points in chars are within s.
    bool ContainsAny(std::string s, std::string chars)
    {
        return IndexAny(s, chars) >= 0;
    }

    // ContainsRune reports whether the Unicode code point r is within s.
    bool ContainsRune(std::string s, gocpp::rune r)
    {
        return IndexRune(s, r) >= 0;
    }

    // ContainsFunc reports whether any Unicode code points r within s satisfy f(r).
    bool ContainsFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        return IndexFunc(s, f) >= 0;
    }

    // LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.
    int LastIndex(std::string s, std::string substr)
    {
        auto n = len(substr);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return len(s);
                    break;
                case 1:
                    return bytealg::LastIndexByteString(s, substr[0]);
                    break;
                case 2:
                    if(substr == s)
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
            }
        }
        auto [hashss, pow] = bytealg::HashStrRev(substr);
        auto last = len(s) - n;
        uint32_t h = {};
        for(auto i = len(s) - 1; i >= last; i--)
        {
            h = h * bytealg::PrimeRK + uint32_t(s[i]);
        }
        if(h == hashss && s.make_slice(last) == substr)
        {
            return last;
        }
        for(auto i = last - 1; i >= 0; i--)
        {
            h *= bytealg::PrimeRK;
            h += uint32_t(s[i]);
            h -= pow * uint32_t(s[i + n]);
            if(h == hashss && s.make_slice(i, i + n) == substr)
            {
                return i;
            }
        }
        return - 1;
    }

    // IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.
    int IndexByte(std::string s, unsigned char c)
    {
        return bytealg::IndexByteString(s, c);
    }

    // IndexRune returns the index of the first instance of the Unicode code point
    // r, or -1 if rune is not present in s.
    // If r is utf8.RuneError, it returns the first instance of any
    // invalid UTF-8 byte sequence.
    int IndexRune(std::string s, gocpp::rune r)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(0 <= r && r < utf8::RuneSelf) { conditionId = 0; }
            else if(r == utf8::RuneError) { conditionId = 1; }
            else if(! utf8::ValidRune(r)) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return IndexByte(s, (unsigned char)(r));
                    break;
                case 1:
                    for(auto [i, r] : s)
                    {
                        if(r == utf8::RuneError)
                        {
                            return i;
                        }
                    }
                    return - 1;
                    break;
                case 2:
                    return - 1;
                    break;
                default:
                    return Index(s, std::string(r));
                    break;
            }
        }
    }

    // IndexAny returns the index of the first instance of any Unicode code point
    // from chars in s, or -1 if no Unicode code point from chars is present in s.
    int IndexAny(std::string s, std::string chars)
    {
        if(chars == ""s)
        {
            return - 1;
        }
        if(len(chars) == 1)
        {
            auto r = gocpp::rune(chars[0]);
            if(r >= utf8::RuneSelf)
            {
                r = utf8::RuneError;
            }
            return IndexRune(s, r);
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto i = 0; i < len(s); i++)
                {
                    if(rec::contains(gocpp::recv(as), s[i]))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        for(auto [i, c] : s)
        {
            if(IndexRune(chars, c) >= 0)
            {
                return i;
            }
        }
        return - 1;
    }

    // LastIndexAny returns the index of the last instance of any Unicode code
    // point from chars in s, or -1 if no Unicode code point from chars is
    // present in s.
    int LastIndexAny(std::string s, std::string chars)
    {
        if(chars == ""s)
        {
            return - 1;
        }
        if(len(s) == 1)
        {
            auto rc = gocpp::rune(s[0]);
            if(rc >= utf8::RuneSelf)
            {
                rc = utf8::RuneError;
            }
            if(IndexRune(chars, rc) >= 0)
            {
                return 0;
            }
            return - 1;
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto i = len(s) - 1; i >= 0; i--)
                {
                    if(rec::contains(gocpp::recv(as), s[i]))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        if(len(chars) == 1)
        {
            auto rc = gocpp::rune(chars[0]);
            if(rc >= utf8::RuneSelf)
            {
                rc = utf8::RuneError;
            }
            for(auto i = len(s); i > 0; )
            {
                auto [r, size] = utf8::DecodeLastRuneInString(s.make_slice(0, i));
                i -= size;
                if(rc == r)
                {
                    return i;
                }
            }
            return - 1;
        }
        for(auto i = len(s); i > 0; )
        {
            auto [r, size] = utf8::DecodeLastRuneInString(s.make_slice(0, i));
            i -= size;
            if(IndexRune(chars, r) >= 0)
            {
                return i;
            }
        }
        return - 1;
    }

    // LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.
    int LastIndexByte(std::string s, unsigned char c)
    {
        return bytealg::LastIndexByteString(s, c);
    }

    // Generic split: splits after each instance of sep,
    // including sepSave bytes of sep in the subarrays.
    gocpp::slice<std::string> genSplit(std::string s, std::string sep, int sepSave, int n)
    {
        if(n == 0)
        {
            return nullptr;
        }
        if(sep == ""s)
        {
            return explode(s, n);
        }
        if(n < 0)
        {
            n = Count(s, sep) + 1;
        }
        if(n > len(s) + 1)
        {
            n = len(s) + 1;
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        n--;
        auto i = 0;
        for(; i < n; )
        {
            auto m = Index(s, sep);
            if(m < 0)
            {
                break;
            }
            a[i] = s.make_slice(0, m + sepSave);
            s = s.make_slice(m + len(sep));
            i++;
        }
        a[i] = s;
        return a.make_slice(0, i + 1);
    }

    // SplitN slices s into substrings separated by sep and returns a slice of
    // the substrings between those separators.
    //
    // The count determines the number of substrings to return:
    //
    //	n > 0: at most n substrings; the last substring will be the unsplit remainder.
    //	n == 0: the result is nil (zero substrings)
    //	n < 0: all substrings
    //
    // Edge cases for s and sep (for example, empty strings) are handled
    // as described in the documentation for [Split].
    //
    // To split around the first instance of a separator, see Cut.
    gocpp::slice<std::string> SplitN(std::string s, std::string sep, int n)
    {
        return genSplit(s, sep, 0, n);
    }

    // SplitAfterN slices s into substrings after each instance of sep and
    // returns a slice of those substrings.
    //
    // The count determines the number of substrings to return:
    //
    //	n > 0: at most n substrings; the last substring will be the unsplit remainder.
    //	n == 0: the result is nil (zero substrings)
    //	n < 0: all substrings
    //
    // Edge cases for s and sep (for example, empty strings) are handled
    // as described in the documentation for SplitAfter.
    gocpp::slice<std::string> SplitAfterN(std::string s, std::string sep, int n)
    {
        return genSplit(s, sep, len(sep), n);
    }

    // Split slices s into all substrings separated by sep and returns a slice of
    // the substrings between those separators.
    //
    // If s does not contain sep and sep is not empty, Split returns a
    // slice of length 1 whose only element is s.
    //
    // If sep is empty, Split splits after each UTF-8 sequence. If both s
    // and sep are empty, Split returns an empty slice.
    //
    // It is equivalent to [SplitN] with a count of -1.
    //
    // To split around the first instance of a separator, see Cut.
    gocpp::slice<std::string> Split(std::string s, std::string sep)
    {
        return genSplit(s, sep, 0, - 1);
    }

    // SplitAfter slices s into all substrings after each instance of sep and
    // returns a slice of those substrings.
    //
    // If s does not contain sep and sep is not empty, SplitAfter returns
    // a slice of length 1 whose only element is s.
    //
    // If sep is empty, SplitAfter splits after each UTF-8 sequence. If
    // both s and sep are empty, SplitAfter returns an empty slice.
    //
    // It is equivalent to [SplitAfterN] with a count of -1.
    gocpp::slice<std::string> SplitAfter(std::string s, std::string sep)
    {
        return genSplit(s, sep, len(sep), - 1);
    }

    gocpp::array<uint8_t, 256> asciiSpace = gocpp::Init<gocpp::array<uint8_t, 256>>([](auto& x) {
        x['\t'] = 1;
        x['\n'] = 1;
        x['\v'] = 1;
        x['\f'] = 1;
        x['\r'] = 1;
        x[' '] = 1;
    });
    // Fields splits the string s around each instance of one or more consecutive white space
    // characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an
    // empty slice if s contains only white space.
    gocpp::slice<std::string> Fields(std::string s)
    {
        auto n = 0;
        auto wasSpace = 1;
        auto setBits = uint8_t(0);
        for(auto i = 0; i < len(s); i++)
        {
            auto r = s[i];
            setBits |= r;
            auto isSpace = int(asciiSpace[r]);
            n += wasSpace & ~ isSpace;
            wasSpace = isSpace;
        }
        if(setBits >= utf8::RuneSelf)
        {
            return FieldsFunc(s, unicode::IsSpace);
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), n);
        auto na = 0;
        auto fieldStart = 0;
        auto i = 0;
        for(; i < len(s) && asciiSpace[s[i]] != 0; )
        {
            i++;
        }
        fieldStart = i;
        for(; i < len(s); )
        {
            if(asciiSpace[s[i]] == 0)
            {
                i++;
                continue;
            }
            a[na] = s.make_slice(fieldStart, i);
            na++;
            i++;
            for(; i < len(s) && asciiSpace[s[i]] != 0; )
            {
                i++;
            }
            fieldStart = i;
        }
        if(fieldStart < len(s))
        {
            a[na] = s.make_slice(fieldStart);
        }
        return a;
    }

    // FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)
    // and returns an array of slices of s. If all code points in s satisfy f(c) or the
    // string is empty, an empty slice is returned.
    //
    // FieldsFunc makes no guarantees about the order in which it calls f(c)
    // and assumes that f always returns the same value for a given c.
    gocpp::slice<std::string> FieldsFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        // A span is used to record a slice of s of the form s[start:end].
        // The start index is inclusive and the end index is exclusive.
        
        template<typename T> requires gocpp::GoStruct<T>
        span::operator T()
        {
            T result;
            result.start = this->start;
            result.end = this->end;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool span::operator==(const T& ref) const
        {
            if (start != ref.start) return false;
            if (end != ref.end) return false;
            return true;
        }

        std::ostream& span::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << start;
            os << " " << end;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct span& value)
        {
            return value.PrintTo(os);
        }

        auto spans = gocpp::make(gocpp::Tag<gocpp::slice<span>>(), 0, 32);
        auto start = - 1;
        for(auto [end, rune] : s)
        {
            if(f(rune))
            {
                if(start >= 0)
                {
                    spans = append(spans, span {start, end});
                    start = ~ start;
                }
            }
            else
            {
                if(start < 0)
                {
                    start = end;
                }
            }
        }
        if(start >= 0)
        {
            spans = append(spans, span {start, len(s)});
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<std::string>>(), len(spans));
        for(auto [i, span] : spans)
        {
            a[i] = s.make_slice(span.start, span.end);
        }
        return a;
    }

    // Join concatenates the elements of its first argument to create a single string. The separator
    // string sep is placed between elements in the resulting string.
    std::string Join(gocpp::slice<std::string> elems, std::string sep)
    {
        //Go switch emulation
        {
            auto condition = len(elems);
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return ""s;
                    break;
                case 1:
                    return elems[0];
                    break;
            }
        }
        int n = {};
        if(len(sep) > 0)
        {
            if(len(sep) >= maxInt / (len(elems) - 1))
            {
                gocpp::panic("strings: Join output length overflow"s);
            }
            n += len(sep) * (len(elems) - 1);
        }
        for(auto [gocpp_ignored, elem] : elems)
        {
            if(len(elem) > maxInt - n)
            {
                gocpp::panic("strings: Join output length overflow"s);
            }
            n += len(elem);
        }
        Builder b = {};
        rec::Grow(gocpp::recv(b), n);
        rec::WriteString(gocpp::recv(b), elems[0]);
        for(auto [gocpp_ignored, s] : elems.make_slice(1))
        {
            rec::WriteString(gocpp::recv(b), sep);
            rec::WriteString(gocpp::recv(b), s);
        }
        return rec::String(gocpp::recv(b));
    }

    // HasPrefix reports whether the string s begins with prefix.
    bool HasPrefix(std::string s, std::string prefix)
    {
        return len(s) >= len(prefix) && s.make_slice(0, len(prefix)) == prefix;
    }

    // HasSuffix reports whether the string s ends with suffix.
    bool HasSuffix(std::string s, std::string suffix)
    {
        return len(s) >= len(suffix) && s.make_slice(len(s) - len(suffix)) == suffix;
    }

    // Map returns a copy of the string s with all its characters modified
    // according to the mapping function. If mapping returns a negative value, the character is
    // dropped from the string with no replacement.
    std::string Map(std::function<gocpp::rune (gocpp::rune _1)> mapping, std::string s)
    {
        // The output buffer b is initialized on demand, the first
        // time a character differs.
        Builder b = {};
        for(auto [i, c] : s)
        {
            auto r = mapping(c);
            if(r == c && c != utf8::RuneError)
            {
                continue;
            }
            int width = {};
            if(c == utf8::RuneError)
            {
                std::tie(c, width) = utf8::DecodeRuneInString(s.make_slice(i));
                if(width != 1 && r == c)
                {
                    continue;
                }
            }
            else
            {
                width = utf8::RuneLen(c);
            }
            rec::Grow(gocpp::recv(b), len(s) + utf8::UTFMax);
            rec::WriteString(gocpp::recv(b), s.make_slice(0, i));
            if(r >= 0)
            {
                rec::WriteRune(gocpp::recv(b), r);
            }
            s = s.make_slice(i + width);
            break;
        }
        if(rec::Cap(gocpp::recv(b)) == 0)
        {
            return s;
        }
        for(auto [gocpp_ignored, c] : s)
        {
            auto r = mapping(c);
            if(r >= 0)
            {
                if(r < utf8::RuneSelf)
                {
                    rec::WriteByte(gocpp::recv(b), (unsigned char)(r));
                }
                else
                {
                    rec::WriteRune(gocpp::recv(b), r);
                }
            }
        }
        return rec::String(gocpp::recv(b));
    }

    // Repeat returns a new string consisting of count copies of the string s.
    //
    // It panics if count is negative or if the result of (len(s) * count)
    // overflows.
    std::string Repeat(std::string s, int count)
    {
        //Go switch emulation
        {
            auto condition = count;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return ""s;
                    break;
                case 1:
                    return s;
                    break;
            }
        }
        if(count < 0)
        {
            gocpp::panic("strings: negative Repeat count"s);
        }
        if(len(s) >= maxInt / count)
        {
            gocpp::panic("strings: Repeat output length overflow"s);
        }
        auto n = len(s) * count;
        if(len(s) == 0)
        {
            return ""s;
        }
        // Past a certain chunk size it is counterproductive to use
        // larger chunks as the source of the write, as when the source
        // is too large we are basically just thrashing the CPU D-cache.
        // So if the result length is larger than an empirically-found
        // limit (8KB), we stop growing the source string once the limit
        // is reached and keep reusing the same source string - that
        // should therefore be always resident in the L1 cache - until we
        // have completed the construction of the result.
        // This yields significant speedups (up to +100%) in cases where
        // the result length is large (roughly, over L2 cache size).
        auto chunkLimit = 8 * 1024;
        auto chunkMax = n;
        if(n > chunkLimit)
        {
            chunkMax = chunkLimit / len(s) * len(s);
            if(chunkMax == 0)
            {
                chunkMax = len(s);
            }
        }
        Builder b = {};
        rec::Grow(gocpp::recv(b), n);
        rec::WriteString(gocpp::recv(b), s);
        for(; rec::Len(gocpp::recv(b)) < n; )
        {
            auto chunk = n - rec::Len(gocpp::recv(b));
            if(chunk > rec::Len(gocpp::recv(b)))
            {
                chunk = rec::Len(gocpp::recv(b));
            }
            if(chunk > chunkMax)
            {
                chunk = chunkMax;
            }
            rec::WriteString(gocpp::recv(b), rec::String(gocpp::recv(b)).make_slice(0, chunk));
        }
        return rec::String(gocpp::recv(b));
    }

    // ToUpper returns s with all Unicode letters mapped to their upper case.
    std::string ToUpper(std::string s)
    {
        auto [isASCII, hasLower] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasLower = hasLower || ('a' <= c && c <= 'z');
        }
        if(isASCII)
        {
            if(! hasLower)
            {
                return s;
            }
            Builder b = {};
            int pos = {};
            rec::Grow(gocpp::recv(b), len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('a' <= c && c <= 'z')
                {
                    c -= 'a' - 'A';
                    if(pos < i)
                    {
                        rec::WriteString(gocpp::recv(b), s.make_slice(pos, i));
                    }
                    rec::WriteByte(gocpp::recv(b), c);
                    pos = i + 1;
                }
            }
            if(pos < len(s))
            {
                rec::WriteString(gocpp::recv(b), s.make_slice(pos));
            }
            return rec::String(gocpp::recv(b));
        }
        return Map(unicode::ToUpper, s);
    }

    // ToLower returns s with all Unicode letters mapped to their lower case.
    std::string ToLower(std::string s)
    {
        auto [isASCII, hasUpper] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasUpper = hasUpper || ('A' <= c && c <= 'Z');
        }
        if(isASCII)
        {
            if(! hasUpper)
            {
                return s;
            }
            Builder b = {};
            int pos = {};
            rec::Grow(gocpp::recv(b), len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('A' <= c && c <= 'Z')
                {
                    c += 'a' - 'A';
                    if(pos < i)
                    {
                        rec::WriteString(gocpp::recv(b), s.make_slice(pos, i));
                    }
                    rec::WriteByte(gocpp::recv(b), c);
                    pos = i + 1;
                }
            }
            if(pos < len(s))
            {
                rec::WriteString(gocpp::recv(b), s.make_slice(pos));
            }
            return rec::String(gocpp::recv(b));
        }
        return Map(unicode::ToLower, s);
    }

    // ToTitle returns a copy of the string s with all Unicode letters mapped to
    // their Unicode title case.
    std::string ToTitle(std::string s)
    {
        return Map(unicode::ToTitle, s);
    }

    // ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their
    // upper case using the case mapping specified by c.
    std::string ToUpperSpecial(unicode::SpecialCase c, std::string s)
    {
        return Map(c.ToUpper, s);
    }

    // ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their
    // lower case using the case mapping specified by c.
    std::string ToLowerSpecial(unicode::SpecialCase c, std::string s)
    {
        return Map(c.ToLower, s);
    }

    // ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their
    // Unicode title case, giving priority to the special casing rules.
    std::string ToTitleSpecial(unicode::SpecialCase c, std::string s)
    {
        return Map(c.ToTitle, s);
    }

    // ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences
    // replaced by the replacement string, which may be empty.
    std::string ToValidUTF8(std::string s, std::string replacement)
    {
        Builder b = {};
        for(auto [i, c] : s)
        {
            if(c != utf8::RuneError)
            {
                continue;
            }
            auto [gocpp_id_1, wid] = utf8::DecodeRuneInString(s.make_slice(i));
            if(wid == 1)
            {
                rec::Grow(gocpp::recv(b), len(s) + len(replacement));
                rec::WriteString(gocpp::recv(b), s.make_slice(0, i));
                s = s.make_slice(i);
                break;
            }
        }
        if(rec::Cap(gocpp::recv(b)) == 0)
        {
            return s;
        }
        auto invalid = false;
        for(auto i = 0; i < len(s); )
        {
            auto c = s[i];
            if(c < utf8::RuneSelf)
            {
                i++;
                invalid = false;
                rec::WriteByte(gocpp::recv(b), c);
                continue;
            }
            auto [gocpp_id_2, wid] = utf8::DecodeRuneInString(s.make_slice(i));
            if(wid == 1)
            {
                i++;
                if(! invalid)
                {
                    invalid = true;
                    rec::WriteString(gocpp::recv(b), replacement);
                }
                continue;
            }
            invalid = false;
            rec::WriteString(gocpp::recv(b), s.make_slice(i, i + wid));
            i += wid;
        }
        return rec::String(gocpp::recv(b));
    }

    // isSeparator reports whether the rune could mark a word boundary.
    // TODO: update when package unicode captures more of the properties.
    bool isSeparator(gocpp::rune r)
    {
        if(r <= 0x7F)
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if('0' <= r && r <= '9') { conditionId = 0; }
                else if('a' <= r && r <= 'z') { conditionId = 1; }
                else if('A' <= r && r <= 'Z') { conditionId = 2; }
                else if(r == '_') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        return false;
                        break;
                    case 1:
                        return false;
                        break;
                    case 2:
                        return false;
                        break;
                    case 3:
                        return false;
                        break;
                }
            }
            return true;
        }
        if(unicode::IsLetter(r) || unicode::IsDigit(r))
        {
            return false;
        }
        return unicode::IsSpace(r);
    }

    // Title returns a copy of the string s with all Unicode letters that begin words
    // mapped to their Unicode title case.
    //
    // Deprecated: The rule Title uses for word boundaries does not handle Unicode
    // punctuation properly. Use golang.org/x/text/cases instead.
    std::string Title(std::string s)
    {
        auto prev = ' ';
        return Map([=](gocpp::rune r) mutable -> gocpp::rune
        {
            if(isSeparator(prev))
            {
                prev = r;
                return unicode::ToTitle(r);
            }
            prev = r;
            return r;
        }, s);
    }

    // TrimLeftFunc returns a slice of the string s with all leading
    // Unicode code points c satisfying f(c) removed.
    std::string TrimLeftFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        auto i = indexFunc(s, f, false);
        if(i == - 1)
        {
            return ""s;
        }
        return s.make_slice(i);
    }

    // TrimRightFunc returns a slice of the string s with all trailing
    // Unicode code points c satisfying f(c) removed.
    std::string TrimRightFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        auto i = lastIndexFunc(s, f, false);
        if(i >= 0 && s[i] >= utf8::RuneSelf)
        {
            auto [gocpp_id_3, wid] = utf8::DecodeRuneInString(s.make_slice(i));
            i += wid;
        }
        else
        {
            i++;
        }
        return s.make_slice(0, i);
    }

    // TrimFunc returns a slice of the string s with all leading
    // and trailing Unicode code points c satisfying f(c) removed.
    std::string TrimFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        return TrimRightFunc(TrimLeftFunc(s, f), f);
    }

    // IndexFunc returns the index into s of the first Unicode
    // code point satisfying f(c), or -1 if none do.
    int IndexFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        return indexFunc(s, f, true);
    }

    // LastIndexFunc returns the index into s of the last
    // Unicode code point satisfying f(c), or -1 if none do.
    int LastIndexFunc(std::string s, std::function<bool (gocpp::rune _1)> f)
    {
        return lastIndexFunc(s, f, true);
    }

    // indexFunc is the same as IndexFunc except that if
    // truth==false, the sense of the predicate function is
    // inverted.
    int indexFunc(std::string s, std::function<bool (gocpp::rune _1)> f, bool truth)
    {
        for(auto [i, r] : s)
        {
            if(f(r) == truth)
            {
                return i;
            }
        }
        return - 1;
    }

    // lastIndexFunc is the same as LastIndexFunc except that if
    // truth==false, the sense of the predicate function is
    // inverted.
    int lastIndexFunc(std::string s, std::function<bool (gocpp::rune _1)> f, bool truth)
    {
        for(auto i = len(s); i > 0; )
        {
            auto [r, size] = utf8::DecodeLastRuneInString(s.make_slice(0, i));
            i -= size;
            if(f(r) == truth)
            {
                return i;
            }
        }
        return - 1;
    }

    // asciiSet is a 32-byte value, where each bit represents the presence of a
    // given ASCII character in the set. The 128-bits of the lower 16 bytes,
    // starting with the least-significant bit of the lowest word to the
    // most-significant bit of the highest word, map to the full range of all
    // 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,
    // ensuring that any non-ASCII character will be reported as not in the set.
    // This allocates a total of 32 bytes even though the upper half
    // is unused to avoid bounds checks in asciiSet.contains.
    // makeASCIISet creates a set of ASCII characters and reports whether all
    // characters in chars are ASCII.
    std::tuple<strings::asciiSet, bool> makeASCIISet(std::string chars)
    {
        strings::asciiSet as;
        bool ok;
        for(auto i = 0; i < len(chars); i++)
        {
            auto c = chars[i];
            if(c >= utf8::RuneSelf)
            {
                return {as, false};
            }
            as[c / 32] |= 1 << (c % 32);
        }
        return {as, true};
    }

    // contains reports whether c is inside the set.
    bool rec::contains(golang::strings::asciiSet* as, unsigned char c)
    {
        return (as[c / 32] & (1 << (c % 32))) != 0;
    }

    // Trim returns a slice of the string s with all leading and
    // trailing Unicode code points contained in cutset removed.
    std::string Trim(std::string s, std::string cutset)
    {
        if(s == ""s || cutset == ""s)
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(trimRightByte(s, cutset[0]), cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(trimRightASCII(s, & as), & as);
        }
        return trimLeftUnicode(trimRightUnicode(s, cutset), cutset);
    }

    // TrimLeft returns a slice of the string s with all leading
    // Unicode code points contained in cutset removed.
    //
    // To remove a prefix, use [TrimPrefix] instead.
    std::string TrimLeft(std::string s, std::string cutset)
    {
        if(s == ""s || cutset == ""s)
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(s, & as);
        }
        return trimLeftUnicode(s, cutset);
    }

    std::string trimLeftByte(std::string s, unsigned char c)
    {
        for(; len(s) > 0 && s[0] == c; )
        {
            s = s.make_slice(1);
        }
        return s;
    }

    std::string trimLeftASCII(std::string s, golang::strings::asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[0]))
            {
                break;
            }
            s = s.make_slice(1);
        }
        return s;
    }

    std::string trimLeftUnicode(std::string s, std::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{gocpp::rune(s[0]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeRuneInString(s);
            }
            if(! ContainsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(n);
        }
        return s;
    }

    // TrimRight returns a slice of the string s, with all trailing
    // Unicode code points contained in cutset removed.
    //
    // To remove a suffix, use [TrimSuffix] instead.
    std::string TrimRight(std::string s, std::string cutset)
    {
        if(s == ""s || cutset == ""s)
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimRightByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimRightASCII(s, & as);
        }
        return trimRightUnicode(s, cutset);
    }

    std::string trimRightByte(std::string s, unsigned char c)
    {
        for(; len(s) > 0 && s[len(s) - 1] == c; )
        {
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    std::string trimRightASCII(std::string s, golang::strings::asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[len(s) - 1]))
            {
                break;
            }
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    std::string trimRightUnicode(std::string s, std::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{gocpp::rune(s[len(s) - 1]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeLastRuneInString(s);
            }
            if(! ContainsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(0, len(s) - n);
        }
        return s;
    }

    // TrimSpace returns a slice of the string s, with all leading
    // and trailing white space removed, as defined by Unicode.
    std::string TrimSpace(std::string s)
    {
        auto start = 0;
        for(; start < len(s); start++)
        {
            auto c = s[start];
            if(c >= utf8::RuneSelf)
            {
                return TrimFunc(s.make_slice(start), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        auto stop = len(s);
        for(; stop > start; stop--)
        {
            auto c = s[stop - 1];
            if(c >= utf8::RuneSelf)
            {
                return TrimRightFunc(s.make_slice(start, stop), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        return s.make_slice(start, stop);
    }

    // TrimPrefix returns s without the provided leading prefix string.
    // If s doesn't start with prefix, s is returned unchanged.
    std::string TrimPrefix(std::string s, std::string prefix)
    {
        if(HasPrefix(s, prefix))
        {
            return s.make_slice(len(prefix));
        }
        return s;
    }

    // TrimSuffix returns s without the provided trailing suffix string.
    // If s doesn't end with suffix, s is returned unchanged.
    std::string TrimSuffix(std::string s, std::string suffix)
    {
        if(HasSuffix(s, suffix))
        {
            return s.make_slice(0, len(s) - len(suffix));
        }
        return s;
    }

    // Replace returns a copy of the string s with the first n
    // non-overlapping instances of old replaced by new.
    // If old is empty, it matches at the beginning of the string
    // and after each UTF-8 sequence, yielding up to k+1 replacements
    // for a k-rune string.
    // If n < 0, there is no limit on the number of replacements.
    std::string Replace(std::string s, std::string old, std::string go_new, int n)
    {
        if(old == go_new || n == 0)
        {
            return s;
        }
        if(auto m = Count(s, old); m == 0)
        {
            return s;
        }
        else
        if(n < 0 || m < n)
        {
            n = m;
        }
        // Apply replacements to buffer.
        Builder b = {};
        rec::Grow(gocpp::recv(b), len(s) + n * (len(go_new) - len(old)));
        auto start = 0;
        for(auto i = 0; i < n; i++)
        {
            auto j = start;
            if(len(old) == 0)
            {
                if(i > 0)
                {
                    auto [gocpp_id_4, wid] = utf8::DecodeRuneInString(s.make_slice(start));
                    j += wid;
                }
            }
            else
            {
                j += Index(s.make_slice(start), old);
            }
            rec::WriteString(gocpp::recv(b), s.make_slice(start, j));
            rec::WriteString(gocpp::recv(b), go_new);
            start = j + len(old);
        }
        rec::WriteString(gocpp::recv(b), s.make_slice(start));
        return rec::String(gocpp::recv(b));
    }

    // ReplaceAll returns a copy of the string s with all
    // non-overlapping instances of old replaced by new.
    // If old is empty, it matches at the beginning of the string
    // and after each UTF-8 sequence, yielding up to k+1 replacements
    // for a k-rune string.
    std::string ReplaceAll(std::string s, std::string old, std::string go_new)
    {
        return Replace(s, old, go_new, - 1);
    }

    // EqualFold reports whether s and t, interpreted as UTF-8 strings,
    // are equal under simple Unicode case-folding, which is a more general
    // form of case-insensitivity.
    bool EqualFold(std::string s, std::string t)
    {
        auto i = 0;
        for(; i < len(s) && i < len(t); i++)
        {
            auto sr = s[i];
            auto tr = t[i];
            if(sr | tr >= utf8::RuneSelf)
            {
                goto hasUnicode;
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
            {
                continue;
            }
            return false;
        }
        return len(s) == len(t);
        hasUnicode:
        s = s.make_slice(i);
        t = t.make_slice(i);
        for(auto [gocpp_ignored, sr] : s)
        {
            if(len(t) == 0)
            {
                return false;
            }
            // Extract first rune from second string.
            gocpp::rune tr = {};
            if(t[0] < utf8::RuneSelf)
            {
                std::tie(tr, t) = std::tuple{gocpp::rune(t[0]), t.make_slice(1)};
            }
            else
            {
                auto [r, size] = utf8::DecodeRuneInString(t);
                std::tie(tr, t) = std::tuple{r, t.make_slice(size)};
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if(tr < utf8::RuneSelf)
            {
                if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
                {
                    continue;
                }
                return false;
            }
            auto r = unicode::SimpleFold(sr);
            for(; r != sr && r < tr; )
            {
                r = unicode::SimpleFold(r);
            }
            if(r == tr)
            {
                continue;
            }
            return false;
        }
        return len(t) == 0;
    }

    // Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.
    int Index(std::string s, std::string substr)
    {
        auto n = len(substr);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            else if(n <= bytealg::MaxLen) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    return 0;
                    break;
                case 1:
                    return IndexByte(s, substr[0]);
                    break;
                case 2:
                    if(substr == s)
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
                case 4:
                    if(len(s) <= bytealg::MaxBruteForce)
                    {
                        return bytealg::IndexString(s, substr);
                    }
                    auto c0 = substr[0];
                    auto c1 = substr[1];
                    auto i = 0;
                    auto t = len(s) - n + 1;
                    auto fails = 0;
                    for(; i < t; )
                    {
                        if(s[i] != c0)
                        {
                            auto o = IndexByte(s.make_slice(i + 1, t), c0);
                            if(o < 0)
                            {
                                return - 1;
                            }
                            i += o + 1;
                        }
                        if(s[i + 1] == c1 && s.make_slice(i, i + n) == substr)
                        {
                            return i;
                        }
                        fails++;
                        i++;
                        if(fails > bytealg::Cutover(i))
                        {
                            auto r = bytealg::IndexString(s.make_slice(i), substr);
                            if(r >= 0)
                            {
                                return r + i;
                            }
                            return - 1;
                        }
                    }
                    return - 1;
                    break;
            }
        }
        auto c0 = substr[0];
        auto c1 = substr[1];
        auto i = 0;
        auto t = len(s) - n + 1;
        auto fails = 0;
        for(; i < t; )
        {
            if(s[i] != c0)
            {
                auto o = IndexByte(s.make_slice(i + 1, t), c0);
                if(o < 0)
                {
                    return - 1;
                }
                i += o + 1;
            }
            if(s[i + 1] == c1 && s.make_slice(i, i + n) == substr)
            {
                return i;
            }
            i++;
            fails++;
            if(fails >= 4 + (i >> 4) && i < t)
            {
                auto j = bytealg::IndexRabinKarp(s.make_slice(i), substr);
                if(j < 0)
                {
                    return - 1;
                }
                return i + j;
            }
        }
        return - 1;
    }

    // Cut slices s around the first instance of sep,
    // returning the text before and after sep.
    // The found result reports whether sep appears in s.
    // If sep does not appear in s, cut returns s, "", false.
    std::tuple<std::string, std::string, bool> Cut(std::string s, std::string sep)
    {
        std::string before;
        std::string after;
        bool found;
        if(auto i = Index(s, sep); i >= 0)
        {
            return {s.make_slice(0, i), s.make_slice(i + len(sep)), true};
        }
        return {s, ""s, false};
    }

    // CutPrefix returns s without the provided leading prefix string
    // and reports whether it found the prefix.
    // If s doesn't start with prefix, CutPrefix returns s, false.
    // If prefix is the empty string, CutPrefix returns s, true.
    std::tuple<std::string, bool> CutPrefix(std::string s, std::string prefix)
    {
        std::string after;
        bool found;
        if(! HasPrefix(s, prefix))
        {
            return {s, false};
        }
        return {s.make_slice(len(prefix)), true};
    }

    // CutSuffix returns s without the provided ending suffix string
    // and reports whether it found the suffix.
    // If s doesn't end with suffix, CutSuffix returns s, false.
    // If suffix is the empty string, CutSuffix returns s, true.
    std::tuple<std::string, bool> CutSuffix(std::string s, std::string suffix)
    {
        std::string before;
        bool found;
        if(! HasSuffix(s, suffix))
        {
            return {s, false};
        }
        return {s.make_slice(0, len(s) - len(suffix)), true};
    }

}

