// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/value.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/value.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/reflectlite/type.h"

namespace golang::reflectlite
{
    struct Value
    {
        abi::Type* typ_;
        unsafe::Pointer ptr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Value& value);
    go_any packEface(struct Value v);
    struct Value unpackEface(go_any i);
    struct ValueError
    {
        std::string Method;
        abi::Kind Kind;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value);
    std::string methodName();
    struct emptyInterface
    {
        abi::Type* typ;
        unsafe::Pointer word;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value);
    struct gocpp_id_6 : gocpp::Interface
    {
        gocpp_id_6(){}
        gocpp_id_6(gocpp_id_6& i) = default;
        gocpp_id_6(const gocpp_id_6& i) = default;
        gocpp_id_6& operator=(gocpp_id_6& i) = default;
        gocpp_id_6& operator=(const gocpp_id_6& i) = default;

        template<typename T>
        gocpp_id_6(T& ref);

        template<typename T>
        gocpp_id_6(const T& ref);

        template<typename T>
        gocpp_id_6(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_6
        {
            virtual void vM() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_6Impl : Igocpp_id_6
        {
            explicit gocpp_id_6Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_6> value;
    };

    namespace rec
    {
        void M(const gocpp::PtrRecv<gocpp_id_6, false>& self);
        void M(const gocpp::ObjRecv<gocpp_id_6>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value);
    go_any valueInterface(struct Value v);
    struct gocpp_id_7 : gocpp::Interface
    {
        gocpp_id_7(){}
        gocpp_id_7(gocpp_id_7& i) = default;
        gocpp_id_7(const gocpp_id_7& i) = default;
        gocpp_id_7& operator=(gocpp_id_7& i) = default;
        gocpp_id_7& operator=(const gocpp_id_7& i) = default;

        template<typename T>
        gocpp_id_7(T& ref);

        template<typename T>
        gocpp_id_7(const T& ref);

        template<typename T>
        gocpp_id_7(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_7
        {
            virtual void vM() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_7Impl : Igocpp_id_7
        {
            explicit gocpp_id_7Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_7> value;
    };

    namespace rec
    {
        void M(const gocpp::PtrRecv<gocpp_id_7, false>& self);
        void M(const gocpp::ObjRecv<gocpp_id_7>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value);
    int chanlen(unsafe::Pointer);
    int maplen(unsafe::Pointer);
    unsafe::Pointer unsafe_New(abi::Type*);
    struct Value ValueOf(go_any i);
    unsafe::Pointer arrayAt(unsafe::Pointer p, int i, uintptr_t eltSize, std::string whySafe);
    void ifaceE2I(struct abi::Type* t, go_any src, unsafe::Pointer dst);
    void typedmemmove(struct abi::Type* t, unsafe::Pointer dst, unsafe::Pointer src);
    void escapes(go_any x);
    unsafe::Pointer noescape(unsafe::Pointer p);

    namespace rec
    {
        abi::Kind kind(reflectlite::flag f);
        reflectlite::flag ro(reflectlite::flag f);
        struct abi::Type* typ(struct Value v);
        unsafe::Pointer pointer(struct Value v);
        std::string Error(struct ValueError* e);
        void mustBeExported(reflectlite::flag f);
        void mustBeAssignable(reflectlite::flag f);
        bool CanSet(struct Value v);
        struct Value Elem(struct Value v);
        bool IsNil(struct Value v);
        bool IsValid(struct Value v);
        abi::Kind Kind(struct Value v);
        int Len(struct Value v);
        int numMethod(struct Value v);
        void Set(struct Value v, struct Value x);
        struct Type Type(struct Value v);
        struct Value assignTo(struct Value v, std::string context, struct abi::Type* dst, unsafe::Pointer target);
    }
}

