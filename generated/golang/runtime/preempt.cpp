// generated by GoCpp from file '$(ImportDir)/runtime/preempt.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/preempt.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/symtabinl.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    suspendGState::operator T()
    {
        T result;
        result.g = this->g;
        result.dead = this->dead;
        result.stopped = this->stopped;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool suspendGState::operator==(const T& ref) const
    {
        if (g != ref.g) return false;
        if (dead != ref.dead) return false;
        if (stopped != ref.stopped) return false;
        return true;
    }

    std::ostream& suspendGState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g;
        os << " " << dead;
        os << " " << stopped;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct suspendGState& value)
    {
        return value.PrintTo(os);
    }

    // suspendG suspends goroutine gp at a safe-point and returns the
    // state of the suspended goroutine. The caller gets read access to
    // the goroutine until it calls resumeG.
    //
    // It is safe for multiple callers to attempt to suspend the same
    // goroutine at the same time. The goroutine may execute between
    // subsequent successful suspend operations. The current
    // implementation grants exclusive access to the goroutine, and hence
    // multiple callers will serialize. However, the intent is to grant
    // shared read access, so please don't depend on exclusive access.
    //
    // This must be called from the system stack and the user goroutine on
    // the current M (if any) must be in a preemptible state. This
    // prevents deadlocks where two goroutines attempt to suspend each
    // other and both are in non-preemptible states. There are other ways
    // to resolve this deadlock, but this seems simplest.
    //
    // TODO(austin): What if we instead required this to be called from a
    // user goroutine? Then we could deschedule the goroutine while
    // waiting instead of blocking the thread. If two goroutines tried to
    // suspend each other, one of them would win and the other wouldn't
    // complete the suspend until it was resumed. We would have to be
    // careful that they couldn't actually queue up suspend for each other
    // and then both be suspended. This would also avoid the need for a
    // kernel context switch in the synchronous case because we could just
    // directly schedule the waiter. The context switch is unavoidable in
    // the signal case.
    //
    //go:systemstack
    struct suspendGState suspendG(struct g* gp)
    {
        if(auto mp = getg()->m; mp->curg != nullptr && readgstatus(mp->curg) == _Grunning)
        {
            go_throw("suspendG from non-preemptible goroutine"s);
        }
        // See https://golang.org/cl/21503 for justification of the yield delay.
        auto yieldDelay = 10 * 1000;
        int64_t nextYield = {};
        auto stopped = false;
        m* asyncM = {};
        uint32_t asyncGen = {};
        int64_t nextPreemptM = {};
        for(auto i = 0; ; i++)
        {
            //Go switch emulation
            {
                auto s = readgstatus(gp);
                auto condition = s;
                int conditionId = -1;
                if(condition == _Gdead) { conditionId = 0; }
                else if(condition == _Gcopystack) { conditionId = 1; }
                else if(condition == _Gpreempted) { conditionId = 2; }
                else if(condition == _Grunnable) { conditionId = 3; }
                else if(condition == _Gsyscall) { conditionId = 4; }
                else if(condition == _Gwaiting) { conditionId = 5; }
                else if(condition == _Grunning) { conditionId = 6; }
                switch(conditionId)
                {
                    default:
                        if(s & _Gscan != 0)
                        {
                            break;
                        }
                        dumpgstatus(gp);
                        go_throw("invalid g status"s);
                        break;
                    case 0:
                        return gocpp::Init<suspendGState>([=](auto& x) {
                            x.dead = true;
                        });
                        break;
                    case 1:
                        break;
                    case 2:
                        if(! casGFromPreempted(gp, _Gpreempted, _Gwaiting))
                        {
                            break;
                        }
                        stopped = true;
                        s = _Gwaiting;
                    case 3:
                    case 4:
                    case 5:
                        if(! castogscanstatus(gp, s, s | _Gscan))
                        {
                            break;
                        }
                        gp->preemptStop = false;
                        gp->preempt = false;
                        gp->stackguard0 = gp->stack.lo + stackGuard;
                        return gocpp::Init<suspendGState>([=](auto& x) {
                            x.g = gp;
                            x.stopped = stopped;
                        });
                        break;
                    case 6:
                        if(gp->preemptStop && gp->preempt && gp->stackguard0 == stackPreempt && asyncM == gp->m && rec::Load(gocpp::recv(asyncM->preemptGen)) == asyncGen)
                        {
                            break;
                        }
                        if(! castogscanstatus(gp, _Grunning, _Gscanrunning))
                        {
                            break;
                        }
                        gp->preemptStop = true;
                        gp->preempt = true;
                        gp->stackguard0 = stackPreempt;
                        auto asyncM2 = gp->m;
                        auto asyncGen2 = rec::Load(gocpp::recv(asyncM2->preemptGen));
                        auto needAsync = asyncM != asyncM2 || asyncGen != asyncGen2;
                        asyncM = asyncM2;
                        asyncGen = asyncGen2;
                        casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning);
                        if(preemptMSupported && debug.asyncpreemptoff == 0 && needAsync)
                        {
                            auto now = nanotime();
                            if(now >= nextPreemptM)
                            {
                                nextPreemptM = now + yieldDelay / 2;
                                preemptM(asyncM);
                            }
                        }
                        break;
                }
            }
            if(i == 0)
            {
                nextYield = nanotime() + yieldDelay;
            }
            if(nanotime() < nextYield)
            {
                procyield(10);
            }
            else
            {
                osyield();
                nextYield = nanotime() + yieldDelay / 2;
            }
        }
    }

    // resumeG undoes the effects of suspendG, allowing the suspended
    // goroutine to continue from its current safe-point.
    void resumeG(struct suspendGState state)
    {
        if(state.dead)
        {
            return;
        }
        auto gp = state.g;
        //Go switch emulation
        {
            auto s = readgstatus(gp);
            auto condition = s;
            int conditionId = -1;
            if(condition == _Grunnable | _Gscan) { conditionId = 0; }
            else if(condition == _Gwaiting | _Gscan) { conditionId = 1; }
            else if(condition == _Gsyscall | _Gscan) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    dumpgstatus(gp);
                    go_throw("unexpected g status"s);
                    break;
                case 0:
                case 1:
                case 2:
                    casfrom_Gscanstatus(gp, s, s &^ _Gscan);
                    break;
            }
        }
        if(state.stopped)
        {
            ready(gp, 0, true);
        }
    }

    // canPreemptM reports whether mp is in a state that is safe to preempt.
    //
    // It is nosplit because it has nosplit callers.
    //
    //go:nosplit
    bool canPreemptM(struct m* mp)
    {
        return mp->locks == 0 && mp->mallocing == 0 && mp->preemptoff == ""s && rec::ptr(gocpp::recv(mp->p))->status == _Prunning;
    }

    // asyncPreempt saves all user registers and calls asyncPreempt2.
    //
    // When stack scanning encounters an asyncPreempt frame, it scans that
    // frame and its parent frame conservatively.
    //
    // asyncPreempt is implemented in assembly.
    void asyncPreempt()
    /* convertBlockStmt, nil block */;

    //go:nosplit
    void asyncPreempt2()
    {
        auto gp = getg();
        gp->asyncSafePoint = true;
        if(gp->preemptStop)
        {
            mcall(preemptPark);
        }
        else
        {
            mcall(gopreempt_m);
        }
        gp->asyncSafePoint = false;
    }

    // asyncPreemptStack is the bytes of stack space required to inject an
    // asyncPreempt call.
    uintptr_t asyncPreemptStack = ~ uintptr_t(0);
    void init()
    {
        auto f = findfunc(abi::FuncPCABI0(asyncPreempt));
        auto total = funcMaxSPDelta(f);
        f = findfunc(abi::FuncPCABIInternal(asyncPreempt2));
        total += funcMaxSPDelta(f);
        asyncPreemptStack = uintptr_t(total) + 8 * goarch::PtrSize;
        if(asyncPreemptStack > stackNosplit)
        {
            print("runtime: asyncPreemptStack="s, asyncPreemptStack, "\n"s);
            go_throw("async stack too large"s);
        }
    }

    // wantAsyncPreempt returns whether an asynchronous preemption is
    // queued for gp.
    bool wantAsyncPreempt(struct g* gp)
    {
        return (gp->preempt || gp->m->p != 0 && rec::ptr(gocpp::recv(gp->m->p))->preempt) && readgstatus(gp) &^ _Gscan == _Grunning;
    }

    // isAsyncSafePoint reports whether gp at instruction PC is an
    // asynchronous safe point. This indicates that:
    //
    // 1. It's safe to suspend gp and conservatively scan its stack and
    // registers. There are no potentially hidden pointer values and it's
    // not in the middle of an atomic sequence like a write barrier.
    //
    // 2. gp has enough stack space to inject the asyncPreempt call.
    //
    // 3. It's generally safe to interact with the runtime, even if we're
    // in a signal handler stopped here. For example, there are no runtime
    // locks held, so acquiring a runtime lock won't self-deadlock.
    //
    // In some cases the PC is safe for asynchronous preemption but it
    // also needs to adjust the resumption PC. The new PC is returned in
    // the second result.
    std::tuple<bool, uintptr_t> isAsyncSafePoint(struct g* gp, uintptr_t pc, uintptr_t sp, uintptr_t lr)
    {
        auto mp = gp->m;
        if(mp->curg != gp)
        {
            return {false, 0};
        }
        if(mp->p == 0 || ! canPreemptM(mp))
        {
            return {false, 0};
        }
        if(sp < gp->stack.lo || sp - gp->stack.lo < asyncPreemptStack)
        {
            return {false, 0};
        }
        auto f = findfunc(pc);
        if(! rec::valid(gocpp::recv(f)))
        {
            return {false, 0};
        }
        if((GOARCH == "mips"s || GOARCH == "mipsle"s || GOARCH == "mips64"s || GOARCH == "mips64le"s) && lr == pc + 8 && funcspdelta(f, pc) == 0)
        {
            return {false, 0};
        }
        auto [up, startpc] = pcdatavalue2(f, abi::PCDATA_UnsafePoint, pc);
        if(up == abi::UnsafePointUnsafe)
        {
            return {false, 0};
        }
        if(auto fd = funcdata(f, abi::FUNCDATA_LocalsPointerMaps); fd == nullptr || f.flag & abi::FuncFlagAsm != 0)
        {
            return {false, 0};
        }
        auto [u, uf] = newInlineUnwinder(f, pc);
        auto name = rec::name(gocpp::recv(rec::srcFunc(gocpp::recv(u), uf)));
        if(hasPrefix(name, "runtime."s) || hasPrefix(name, "runtime/internal/"s) || hasPrefix(name, "reflect."s))
        {
            return {false, 0};
        }
        //Go switch emulation
        {
            auto condition = up;
            int conditionId = -1;
            if(condition == abi::UnsafePointRestart1) { conditionId = 0; }
            else if(condition == abi::UnsafePointRestart2) { conditionId = 1; }
            else if(condition == abi::UnsafePointRestartAtEntry) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    if(startpc == 0 || startpc > pc || pc - startpc > 20)
                    {
                        go_throw("bad restart PC"s);
                    }
                    return {true, startpc};
                    break;
                case 2:
                    return {true, rec::entry(gocpp::recv(f))};
                    break;
            }
        }
        return {true, pc};
    }

}

