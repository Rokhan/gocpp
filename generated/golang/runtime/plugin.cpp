// generated by GoCpp from file '$(ImportDir)/runtime/plugin.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/plugin.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/iface.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    std::tuple<std::string, gocpp::map<std::string, go_any>, gocpp::slice<initTask*>, std::string> plugin_lastmoduleinit()
    {
        std::string path;
        gocpp::map<std::string, go_any> syms;
        gocpp::slice<initTask*> initTasks;
        std::string errstr;
        moduledata* md = {};
        for(auto pmd = firstmoduledata.next; pmd != nullptr; pmd = pmd->next)
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            if(pmd->bad)
            {
                std::string path;
                gocpp::map<std::string, go_any> syms;
                gocpp::slice<initTask*> initTasks;
                std::string errstr;
                md = nullptr;
                continue;
            }
            md = pmd;
        }
        if(md == nullptr)
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            go_throw("runtime: no plugin module data");
        }
        if(md->pluginpath == "")
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            go_throw("runtime: plugin has empty pluginpath");
        }
        if(md->typemap != nullptr)
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            return {"", nullptr, nullptr, "plugin already loaded"};
        }
        for(auto [_, pmd] : activeModules())
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            if(pmd->pluginpath == md->pluginpath)
            {
                std::string path;
                gocpp::map<std::string, go_any> syms;
                gocpp::slice<initTask*> initTasks;
                std::string errstr;
                md->bad = true;
                return {"", nullptr, nullptr, "plugin already loaded"};
            }
            if(inRange(pmd->text, pmd->etext, md->text, md->etext) || inRange(pmd->bss, pmd->ebss, md->bss, md->ebss) || inRange(pmd->data, pmd->edata, md->data, md->edata) || inRange(pmd->types, pmd->etypes, md->types, md->etypes))
            {
                std::string path;
                gocpp::map<std::string, go_any> syms;
                gocpp::slice<initTask*> initTasks;
                std::string errstr;
                println("plugin: new module data overlaps with previous moduledata");
                println("\tpmd.text-etext=", hex(pmd->text), "-", hex(pmd->etext));
                println("\tpmd.bss-ebss=", hex(pmd->bss), "-", hex(pmd->ebss));
                println("\tpmd.data-edata=", hex(pmd->data), "-", hex(pmd->edata));
                println("\tpmd.types-etypes=", hex(pmd->types), "-", hex(pmd->etypes));
                println("\tmd.text-etext=", hex(md->text), "-", hex(md->etext));
                println("\tmd.bss-ebss=", hex(md->bss), "-", hex(md->ebss));
                println("\tmd.data-edata=", hex(md->data), "-", hex(md->edata));
                println("\tmd.types-etypes=", hex(md->types), "-", hex(md->etypes));
                go_throw("plugin: new module data overlaps with previous moduledata");
            }
        }
        for(auto [_, pkghash] : md->pkghashes)
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            if(pkghash.linktimehash != *pkghash.runtimehash)
            {
                std::string path;
                gocpp::map<std::string, go_any> syms;
                gocpp::slice<initTask*> initTasks;
                std::string errstr;
                md->bad = true;
                return {"", nullptr, nullptr, "plugin was built with a different version of package " + pkghash.modulename};
            }
        }
        modulesinit();
        typelinksinit();
        pluginftabverify(md);
        moduledataverify1(md);
        lock(& itabLock);
        for(auto [_, i] : md->itablinks)
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            itabAdd(i);
        }
        unlock(& itabLock);
        syms = gocpp::make(gocpp::Tag<gocpp::map<std::string, go_any>>(), len(md->ptab));
        for(auto [_, ptab] : md->ptab)
        {
            std::string path;
            gocpp::map<std::string, go_any> syms;
            gocpp::slice<initTask*> initTasks;
            std::string errstr;
            auto symName = resolveNameOff(Pointer(gocpp::recv(unsafe), md->types), ptab.name);
            auto t = typeOff(gocpp::recv(toRType((_type*)(Pointer(gocpp::recv(unsafe), md->types)))), ptab.typ);
            go_any val = {};
            auto valp = (gocpp::array<unsafe::Pointer, 2>*)(Pointer(gocpp::recv(unsafe), & val));
            (*valp)[0] = Pointer(gocpp::recv(unsafe), t);
            auto name = Name(gocpp::recv(symName));
            if(t->Kind_ & kindMask == kindFunc)
            {
                std::string path;
                gocpp::map<std::string, go_any> syms;
                gocpp::slice<initTask*> initTasks;
                std::string errstr;
                name = "." + name;
            }
            syms[name] = val;
        }
        return {md->pluginpath, syms, md->inittasks, ""};
    }

    void pluginftabverify(moduledata* md)
    {
        auto badtable = false;
        for(auto i = 0; i < len(md->ftab); i++)
        {
            auto entry = textAddr(gocpp::recv(md), md->ftab[i].entryoff);
            if(md->minpc <= entry && entry <= md->maxpc)
            {
                continue;
            }
            auto f = funcInfo {(_func*)(Pointer(gocpp::recv(unsafe), & md->pclntable[md->ftab[i].funcoff])), md};
            auto name = funcname(f);
            auto name2 = "none";
            auto entry2 = uintptr(0);
            auto f2 = findfunc(entry);
            if(valid(gocpp::recv(f2)))
            {
                name2 = funcname(f2);
                entry2 = entry(gocpp::recv(f2));
            }
            badtable = true;
            println("ftab entry", hex(entry), "/", hex(entry2), ": ", name, "/", name2, "outside pc range:[", hex(md->minpc), ",", hex(md->maxpc), "], modulename=", md->modulename, ", pluginpath=", md->pluginpath);
        }
        if(badtable)
        {
            go_throw("runtime: plugin has bad symbol table");
        }
    }

    bool inRange(uintptr_t r0, uintptr_t r1, uintptr_t v0, uintptr_t v1)
    {
        return (v0 >= r0 && v0 <= r1) || (v1 >= r0 && v1 <= r1);
    }

    
    std::ostream& ptabEntry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << typ;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ptabEntry& value)
    {
        return value.PrintTo(os);
    }

}

