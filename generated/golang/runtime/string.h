// generated by GoCpp from file '$(ImportDir)/runtime/string.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/string.fwd.h"
#include "gocpp/support.h"


namespace golang::runtime
{
    gocpp::string concatstrings(golang::runtime::tmpBuf* buf, gocpp::slice<gocpp::string> a);
    gocpp::string concatstring2(golang::runtime::tmpBuf* buf, gocpp::string a0, gocpp::string a1);
    gocpp::string concatstring3(golang::runtime::tmpBuf* buf, gocpp::string a0, gocpp::string a1, gocpp::string a2);
    gocpp::string concatstring4(golang::runtime::tmpBuf* buf, gocpp::string a0, gocpp::string a1, gocpp::string a2, gocpp::string a3);
    gocpp::string concatstring5(golang::runtime::tmpBuf* buf, gocpp::string a0, gocpp::string a1, gocpp::string a2, gocpp::string a3, gocpp::string a4);
    gocpp::string slicebytetostring(golang::runtime::tmpBuf* buf, unsigned char* ptr, int n);
    bool stringDataOnStack(gocpp::string s);
    std::tuple<gocpp::string, gocpp::slice<unsigned char>> rawstringtmp(golang::runtime::tmpBuf* buf, int l);
    gocpp::string slicebytetostringtmp(unsigned char* ptr, int n);
    gocpp::slice<unsigned char> stringtoslicebyte(golang::runtime::tmpBuf* buf, gocpp::string s);
    gocpp::slice<gocpp::rune> stringtoslicerune(gocpp::array<gocpp::rune, tmpStringBufSize>* buf, gocpp::string s);
    gocpp::string slicerunetostring(golang::runtime::tmpBuf* buf, gocpp::slice<gocpp::rune> a);
    struct stringStruct
    {
        unsafe::Pointer str;
        int len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stringStruct& value);
    struct stringStructDWARF
    {
        unsigned char* str;
        int len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stringStructDWARF& value);
    struct stringStruct* stringStructOf(gocpp::string* sp);
    gocpp::string intstring(gocpp::array<unsigned char, 4>* buf, int64_t v);
    std::tuple<gocpp::string, gocpp::slice<unsigned char>> rawstring(int size);
    gocpp::slice<unsigned char> rawbyteslice(int size);
    gocpp::slice<gocpp::rune> rawruneslice(int size);
    gocpp::slice<unsigned char> gobytes(unsigned char* p, int n);
    gocpp::string gostring(unsigned char* p);
    gocpp::string internal_syscall_gostring(unsigned char* p);
    gocpp::string gostringn(unsigned char* p, int l);
    bool hasPrefix(gocpp::string s, gocpp::string prefix);
    bool hasSuffix(gocpp::string s, gocpp::string suffix);
    std::tuple<int64_t, bool> atoi64(gocpp::string s);
    std::tuple<int, bool> atoi(gocpp::string s);
    std::tuple<int32_t, bool> atoi32(gocpp::string s);
    std::tuple<int64_t, bool> parseByteCount(gocpp::string s);
    int findnull(unsigned char* s);
    int findnullw(uint16_t* s);
    gocpp::string gostringnocopy(unsigned char* str);
    gocpp::string gostringw(uint16_t* strw);

    namespace rec
    {
    }
}

