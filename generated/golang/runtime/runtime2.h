// generated by GoCpp from file '$(ImportDir)/runtime/runtime2.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/runtime2.fwd.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct mutex
    {
        uintptr_t key;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mutex& value);
    struct note
    {
        uintptr_t key;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct note& value);
    struct funcval
    {
        uintptr_t fn;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct funcval& value);
    struct iface
    {
        itab* tab;
        unsafe::Pointer data;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct iface& value);
    struct eface
    {
        _type* _type;
        unsafe::Pointer data;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct eface& value);
    eface* efaceOf(go_any* ep);
    g* ptr(guintptr gp);
    void set(guintptr* gp, g* g);
    bool cas(guintptr* gp, guintptr old, guintptr go_new);
    guintptr guintptr(struct g* gp);
    void setGNoWB(g** gp, g* go_new);
    p* ptr(puintptr pp);
    void set(puintptr* pp, p* p);
    m* ptr(muintptr mp);
    void set(muintptr* mp, m* m);
    void setMNoWB(m** mp, m* go_new);
    struct gobuf
    {
        uintptr_t sp;
        uintptr_t pc;
        guintptr g;
        unsafe::Pointer ctxt;
        uintptr_t ret;
        uintptr_t lr;
        uintptr_t bp;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gobuf& value);
    struct sudog
    {
        g* g;
        sudog* next;
        sudog* prev;
        unsafe::Pointer elem;
        int64_t acquiretime;
        int64_t releasetime;
        uint32_t ticket;
        bool isSelect;
        bool success;
        uint16_t waiters;
        sudog* parent;
        sudog* waitlink;
        sudog* waittail;
        hchan* c;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sudog& value);
    struct libcall
    {
        uintptr_t fn;
        uintptr_t n;
        uintptr_t args;
        uintptr_t r1;
        uintptr_t r2;
        uintptr_t err;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct libcall& value);
    struct stack
    {
        uintptr_t lo;
        uintptr_t hi;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stack& value);
    struct heldLockInfo
    {
        uintptr_t lockAddr;
        lockRank rank;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heldLockInfo& value);
    struct g
    {
        stack stack;
        uintptr_t stackguard0;
        uintptr_t stackguard1;
        _panic* _panic;
        _defer* _defer;
        m* m;
        gobuf sched;
        uintptr_t syscallsp;
        uintptr_t syscallpc;
        uintptr_t stktopsp;
        unsafe::Pointer param;
        atomic::Uint32 atomicstatus;
        uint32_t stackLock;
        uint64_t goid;
        guintptr schedlink;
        int64_t waitsince;
        waitReason waitreason;
        bool preempt;
        bool preemptStop;
        bool preemptShrink;
        bool asyncSafePoint;
        bool paniconfault;
        bool gcscandone;
        bool throwsplit;
        bool activeStackChans;
        atomic::Bool parkingOnChan;
        bool inMarkAssist;
        bool coroexit;
        int8_t raceignore;
        bool nocgocallback;
        bool tracking;
        uint8_t trackingSeq;
        int64_t trackingStamp;
        int64_t runnableTime;
        muintptr lockedm;
        uint32_t sig;
        gocpp::slice<unsigned char> writebuf;
        uintptr_t sigcode0;
        uintptr_t sigcode1;
        uintptr_t sigpc;
        uint64_t parentGoid;
        uintptr_t gopc;
        gocpp::slice<ancestorInfo>* ancestors;
        uintptr_t startpc;
        uintptr_t racectx;
        sudog* waiting;
        gocpp::slice<uintptr_t> cgoCtxt;
        unsafe::Pointer labels;
        timer* timer;
        atomic::Uint32 selectDone;
        coro* coroarg;
        goroutineProfileStateHolder goroutineProfiled;
        gTraceState trace;
        int64_t gcAssistBytes;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct g& value);
    struct m
    {
        g* g0;
        gobuf morebuf;
        uint32_t divmod;
        uint32_t _;
        uint64_t procid;
        g* gsignal;
        gsignalStack goSigStack;
        sigset sigmask;
        gocpp::array<uintptr_t, tlsSlots> tls;
        std::function<void ()> mstartfn;
        g* curg;
        guintptr caughtsig;
        puintptr p;
        puintptr nextp;
        puintptr oldp;
        int64_t id;
        int32_t mallocing;
        throwType throwing;
        std::string preemptoff;
        int32_t locks;
        int32_t dying;
        int32_t profilehz;
        bool spinning;
        bool blocked;
        bool newSigstack;
        int8_t printlock;
        bool incgo;
        bool isextra;
        bool isExtraInC;
        bool isExtraInSig;
        atomic::Uint32 freeWait;
        bool needextram;
        uint8_t traceback;
        uint64_t ncgocall;
        int32_t ncgo;
        atomic::Uint32 cgoCallersUse;
        cgoCallers* cgoCallers;
        note park;
        m* alllink;
        muintptr schedlink;
        guintptr lockedg;
        gocpp::array<uintptr_t, 32> createstack;
        uint32_t lockedExt;
        uint32_t lockedInt;
        muintptr nextwaitm;
        mLockProfile mLockProfile;
        std::function<bool (g*, unsafe::Pointer)> waitunlockf;
        unsafe::Pointer waitlock;
        traceBlockReason waitTraceBlockReason;
        int waitTraceSkip;
        uint32_t syscalltick;
        m* freelink;
        mTraceState trace;
        libcall libcall;
        uintptr_t libcallpc;
        uintptr_t libcallsp;
        guintptr libcallg;
        libcall syscall;
        uintptr_t vdsoSP;
        uintptr_t vdsoPC;
        atomic::Uint32 preemptGen;
        atomic::Uint32 signalPending;
        pcvalueCache pcvalueCache;
        chacha8rand::State chacha8;
        uint64_t cheaprand;
        int locksHeldLen;
        gocpp::array<heldLockInfo, 10> locksHeld;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct m& value);
    struct p
    {
        int32_t id;
        uint32_t status;
        puintptr link;
        uint32_t schedtick;
        uint32_t syscalltick;
        sysmontick sysmontick;
        muintptr m;
        mcache* mcache;
        pageCache pcache;
        uintptr_t raceprocctx;
        gocpp::slice<_defer*> deferpool;
        gocpp::array<_defer*, 32> deferpoolbuf;
        uint64_t goidcache;
        uint64_t goidcacheend;
        uint32_t runqhead;
        uint32_t runqtail;
        gocpp::array<guintptr, 256> runq;
        guintptr runnext;
        gocpp_id_0 gFree;
        gocpp::slice<sudog*> sudogcache;
        gocpp::array<sudog*, 128> sudogbuf;
        gocpp_id_1 mspancache;
        pinner* pinnerCache;
        pTraceState trace;
        persistentAlloc palloc;
        atomic::Int64 timer0When;
        atomic::Int64 timerModifiedEarliest;
        int64_t gcAssistTime;
        int64_t gcFractionalMarkTime;
        limiterEvent limiterEvent;
        gcMarkWorkerMode gcMarkWorkerMode;
        int64_t gcMarkWorkerStartTime;
        gcWork gcw;
        wbBuf wbBuf;
        uint32_t runSafePointFn;
        atomic::Uint32 statsSeq;
        mutex timersLock;
        gocpp::slice<timer*> timers;
        atomic::Uint32 numTimers;
        atomic::Uint32 deletedTimers;
        uintptr_t timerRaceCtx;
        int64_t maxStackScanDelta;
        uint64_t scannedStackSize;
        uint64_t scannedStacks;
        bool preempt;
        pageTraceBuf pageTraceBuf;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct p& value);
    struct schedt
    {
        atomic::Uint64 goidgen;
        atomic::Int64 lastpoll;
        atomic::Int64 pollUntil;
        mutex lock;
        muintptr midle;
        int32_t nmidle;
        int32_t nmidlelocked;
        int64_t mnext;
        int32_t maxmcount;
        int32_t nmsys;
        int64_t nmfreed;
        atomic::Int32 ngsys;
        puintptr pidle;
        atomic::Int32 npidle;
        atomic::Int32 nmspinning;
        atomic::Uint32 needspinning;
        gQueue runq;
        int32_t runqsize;
        gocpp_id_2 disable;
        gocpp_id_3 gFree;
        mutex sudoglock;
        sudog* sudogcache;
        mutex deferlock;
        _defer* deferpool;
        m* freem;
        atomic::Bool gcwaiting;
        int32_t stopwait;
        note stopnote;
        atomic::Bool sysmonwait;
        note sysmonnote;
        std::function<void (p*)> safePointFn;
        int32_t safePointWait;
        note safePointNote;
        int32_t profilehz;
        int64_t procresizetime;
        int64_t totaltime;
        mutex sysmonlock;
        timeHistogram timeToRun;
        atomic::Int64 idleTime;
        atomic::Int64 totalMutexWaitTime;
        timeHistogram stwStoppingTimeGC;
        timeHistogram stwStoppingTimeOther;
        timeHistogram stwTotalTimeGC;
        timeHistogram stwTotalTimeOther;
        atomic::Int64 totalRuntimeLockWaitTime;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct schedt& value);
    struct _func
    {
        uint32_t entryOff;
        int32_t nameOff;
        int32_t args;
        uint32_t deferreturn;
        uint32_t pcsp;
        uint32_t pcfile;
        uint32_t pcln;
        uint32_t npcdata;
        uint32_t cuOffset;
        int32_t startLine;
        abi::FuncID funcID;
        abi::FuncFlag flag;
        gocpp::array<unsigned char, 1> _;
        uint8_t nfuncdata;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct _func& value);
    struct funcinl
    {
        uint32_t ones;
        uintptr_t entry;
        std::string name;
        std::string file;
        int32_t line;
        int32_t startLine;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct funcinl& value);
    struct itab
    {
        interfacetype* inter;
        _type* _type;
        uint32_t hash;
        gocpp::array<unsigned char, 4> _;
        gocpp::array<uintptr_t, 1> fun;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct itab& value);
    struct lfnode
    {
        uint64_t next;
        uintptr_t pushcnt;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct lfnode& value);
    struct forcegcstate
    {
        mutex lock;
        g* g;
        atomic::Bool idle;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct forcegcstate& value);
    struct _defer
    {
        bool heap;
        bool rangefunc;
        uintptr_t sp;
        uintptr_t pc;
        std::function<void ()> fn;
        _defer* link;
        atomic::Pointer<_defer>* head;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct _defer& value);
    struct _panic
    {
        unsafe::Pointer argp;
        go_any arg;
        _panic* link;
        uintptr_t startPC;
        unsafe::Pointer startSP;
        unsafe::Pointer sp;
        uintptr_t lr;
        unsafe::Pointer fp;
        uintptr_t retpc;
        uint8_t* deferBitsPtr;
        unsafe::Pointer slotsPtr;
        bool recovered;
        bool goexit;
        bool deferreturn;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct _panic& value);
    struct savedOpenDeferState
    {
        uintptr_t retpc;
        uintptr_t deferBitsOffset;
        uintptr_t slotsOffset;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct savedOpenDeferState& value);
    struct ancestorInfo
    {
        gocpp::slice<uintptr_t> pcs;
        uint64_t goid;
        uintptr_t gopc;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ancestorInfo& value);
    extern gocpp::array_base<std::string> waitReasonStrings;
    std::string String(waitReason w);
    bool isMutexWait(waitReason w);
    extern bool framepointer_enabled;
}

