// generated by GoCpp from file '$(ImportDir)/runtime/trace2runtime.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2runtime.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
// #include "golang/runtime/trace2map.h"  [Ignored, known errors]
// #include "golang/runtime/trace2region.h"  [Ignored, known errors]
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gTraceState::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gTraceState::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gTraceState& value)
    {
        return value.PrintTo(os);
    }

    void rec::reset(struct gTraceState* s)
    {
        s->seq = gocpp::array<uint64_t, 2> {};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mTraceState::operator T()
    {
        T result;
        result.seqlock = this->seqlock;
        result.buf = this->buf;
        result.link = this->link;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mTraceState::operator==(const T& ref) const
    {
        if (seqlock != ref.seqlock) return false;
        if (buf != ref.buf) return false;
        if (link != ref.link) return false;
        return true;
    }

    std::ostream& mTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << seqlock;
        os << " " << buf;
        os << " " << link;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mTraceState& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pTraceState::operator T()
    {
        T result;
        result.mSyscallID = this->mSyscallID;
        result.maySweep = this->maySweep;
        result.inSweep = this->inSweep;
        result.swept = this->swept;
        result.reclaimed = this->reclaimed;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pTraceState::operator==(const T& ref) const
    {
        if (mSyscallID != ref.mSyscallID) return false;
        if (maySweep != ref.maySweep) return false;
        if (inSweep != ref.inSweep) return false;
        if (swept != ref.swept) return false;
        if (reclaimed != ref.reclaimed) return false;
        return true;
    }

    std::ostream& pTraceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mSyscallID;
        os << " " << maySweep;
        os << " " << inSweep;
        os << " " << swept;
        os << " " << reclaimed;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pTraceState& value)
    {
        return value.PrintTo(os);
    }

    void traceLockInit()
    {
        lockInit(& trace.stringTab[0].lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[0].tab.lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[1].lock, lockRankTraceStrings);
        lockInit(& trace.stringTab[1].tab.lock, lockRankTraceStrings);
        lockInit(& trace.stackTab[0].tab.lock, lockRankTraceStackTab);
        lockInit(& trace.stackTab[1].tab.lock, lockRankTraceStackTab);
        lockInit(& trace.lock, lockRankTrace);
    }

    void lockRankMayTraceFlush()
    {
        lockWithRankMayAcquire(& trace.lock, getLockRank(& trace.lock));
    }

    gocpp::array_base<std::string> traceBlockReasonStrings = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.traceBlockGeneric = "unspecified"; x.traceBlockForever = "forever"; x.traceBlockNet = "network"; x.traceBlockSelect = "select"; x.traceBlockCondWait = "sync.(*Cond).Wait"; x.traceBlockSync = "sync"; x.traceBlockChanSend = "chan send"; x.traceBlockChanRecv = "chan receive"; x.traceBlockGCMarkAssist = "GC mark assist wait for work"; x.traceBlockGCSweep = "GC background sweeper wait"; x.traceBlockSystemGoroutine = "system goroutine wait"; x.traceBlockPreempted = "preempted"; x.traceBlockDebugCall = "wait for debug call"; x.traceBlockUntilGCEnds = "wait until GC ends"; x.traceBlockSleep = "sleep"; });
    gocpp::array_base<std::string> traceGoStopReasonStrings = gocpp::Init<gocpp::array_base<std::string>>([](gocpp::array_base<std::string>& x) { x.traceGoStopGeneric = "unspecified"; x.traceGoStopGoSched = "runtime.Gosched"; x.traceGoStopPreempted = "preempted"; });
    bool traceEnabled()
    {
        return rec::Load(gocpp::recv(trace.gen)) != 0;
    }

    bool traceShuttingDown()
    {
        return rec::Load(gocpp::recv(trace.shutdown));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceLocker::operator T()
    {
        T result;
        result.mp = this->mp;
        result.gen = this->gen;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceLocker::operator==(const T& ref) const
    {
        if (mp != ref.mp) return false;
        if (gen != ref.gen) return false;
        return true;
    }

    std::ostream& traceLocker::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mp;
        os << " " << gen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceLocker& value)
    {
        return value.PrintTo(os);
    }

    struct traceLocker traceAcquire()
    {
        if(! traceEnabled())
        {
            return traceLocker {};
        }
        return traceAcquireEnabled();
    }

    struct traceLocker traceAcquireEnabled()
    {
        lockRankMayTraceFlush();
        auto mp = acquirem();
        auto seq = rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 1)
        {
            go_throw("bad use of trace.seqlock or tracer is reentrant");
        }
        auto gen = rec::Load(gocpp::recv(trace.gen));
        if(gen == 0)
        {
            rec::Add(gocpp::recv(mp->trace.seqlock), 1);
            releasem(mp);
            return traceLocker {};
        }
        return traceLocker {mp, gen};
    }

    bool rec::ok(struct traceLocker tl)
    {
        return tl.gen != 0;
    }

    void traceRelease(struct traceLocker tl)
    {
        auto seq = rec::Add(gocpp::recv(tl.mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 0)
        {
            print("runtime: seq=", seq, "\n");
            go_throw("bad use of trace.seqlock");
        }
        releasem(tl.mp);
    }

    void traceExitingSyscall()
    {
        rec::Add(gocpp::recv(trace.exitingSyscall), 1);
    }

    void traceExitedSyscall()
    {
        rec::Add(gocpp::recv(trace.exitingSyscall), - 1);
    }

    void rec::Gomaxprocs(struct traceLocker tl, int32_t procs)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvProcsChange, traceArg(procs), rec::stack(gocpp::recv(tl), 1));
    }

    void rec::ProcStart(struct traceLocker tl)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcIdle)), traceEvProcStart, traceArg(pp->id), rec::nextSeq(gocpp::recv(pp->trace), tl.gen));
    }

    void rec::ProcStop(struct traceLocker tl, struct p* pp)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcRunning)), traceEvProcStop);
    }

    void rec::GCActive(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCActive, traceArg(trace.seqGC));
        trace.seqGC++;
    }

    void rec::GCStart(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCBegin, traceArg(trace.seqGC), rec::stack(gocpp::recv(tl), 3));
        trace.seqGC++;
    }

    void rec::GCDone(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCEnd, traceArg(trace.seqGC));
        trace.seqGC++;
    }

    void rec::STWStart(struct traceLocker tl, runtime::stwReason reason)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvSTWBegin, rec::string(gocpp::recv(tl), rec::String(gocpp::recv(reason))), rec::stack(gocpp::recv(tl), 2));
    }

    void rec::STWDone(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvSTWEnd);
    }

    void rec::GCSweepStart(struct traceLocker tl)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        if(pp->trace.maySweep)
        {
            go_throw("double traceGCSweepStart");
        }
        std::tie(pp->trace.maySweep, pp->trace.swept, pp->trace.reclaimed) = std::tuple{true, 0, 0};
    }

    void rec::GCSweepSpan(struct traceLocker tl, uintptr_t bytesSwept)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        if(pp->trace.maySweep)
        {
            if(pp->trace.swept == 0)
            {
                rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCSweepBegin, rec::stack(gocpp::recv(tl), 1));
                pp->trace.inSweep = true;
            }
            pp->trace.swept += bytesSwept;
        }
    }

    void rec::GCSweepDone(struct traceLocker tl)
    {
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        if(! pp->trace.maySweep)
        {
            go_throw("missing traceGCSweepStart");
        }
        if(pp->trace.inSweep)
        {
            rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCSweepEnd, traceArg(pp->trace.swept), traceArg(pp->trace.reclaimed));
            pp->trace.inSweep = false;
        }
        pp->trace.maySweep = false;
    }

    void rec::GCMarkAssistStart(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCMarkAssistBegin, rec::stack(gocpp::recv(tl), 1));
    }

    void rec::GCMarkAssistDone(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGCMarkAssistEnd);
    }

    void rec::GoCreate(struct traceLocker tl, struct g* newg, uintptr_t pc)
    {
        rec::setStatusTraced(gocpp::recv(newg->trace), tl.gen);
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoCreate, traceArg(newg->goid), rec::startPC(gocpp::recv(tl), pc), rec::stack(gocpp::recv(tl), 2));
    }

    void rec::GoStart(struct traceLocker tl)
    {
        auto gp = getg()->m->curg;
        auto pp = gp->m->p;
        auto w = rec::eventWriter(gocpp::recv(tl), traceGoRunnable, traceProcRunning);
        w = rec::write(gocpp::recv(w), traceEvGoStart, traceArg(gp->goid), rec::nextSeq(gocpp::recv(gp->trace), tl.gen));
        if(rec::ptr(gocpp::recv(pp))->gcMarkWorkerMode != gcMarkWorkerNotWorker)
        {
            w = rec::write(gocpp::recv(w), traceEvGoLabel, trace.markWorkerLabels[tl.gen % 2][rec::ptr(gocpp::recv(pp))->gcMarkWorkerMode]);
        }
        rec::end(gocpp::recv(w));
    }

    void rec::GoEnd(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoDestroy);
    }

    void rec::GoSched(struct traceLocker tl)
    {
        rec::GoStop(gocpp::recv(tl), traceGoStopGoSched);
    }

    void rec::GoPreempt(struct traceLocker tl)
    {
        rec::GoStop(gocpp::recv(tl), traceGoStopPreempted);
    }

    void rec::GoStop(struct traceLocker tl, runtime::traceGoStopReason reason)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoStop, traceArg(trace.goStopReasons[tl.gen % 2][reason]), rec::stack(gocpp::recv(tl), 1));
    }

    void rec::GoPark(struct traceLocker tl, runtime::traceBlockReason reason, int skip)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoBlock, traceArg(trace.goBlockReasons[tl.gen % 2][reason]), rec::stack(gocpp::recv(tl), skip));
    }

    void rec::GoUnpark(struct traceLocker tl, struct g* gp, int skip)
    {
        auto w = rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning);
        if(! rec::statusWasTraced(gocpp::recv(gp->trace), tl.gen) && rec::acquireStatus(gocpp::recv(gp->trace), tl.gen))
        {
            w.w = rec::writeGoStatus(gocpp::recv(w.w), gp->goid, - 1, traceGoWaiting, gp->inMarkAssist);
        }
        rec::commit(gocpp::recv(w), traceEvGoUnblock, traceArg(gp->goid), rec::nextSeq(gocpp::recv(gp->trace), tl.gen), rec::stack(gocpp::recv(tl), skip));
    }

    void rec::GoSysCall(struct traceLocker tl)
    {
        int skip = {};
        //Go switch emulation
        {
            int conditionId = -1;
            if(tracefpunwindoff()) { conditionId = 0; }
            else if(GOOS == "solaris" || GOOS == "illumos") { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    skip = 1;
                    break;
                case 1:
                    skip = 3;
                    break;
                default:
                    skip = 4;
                    break;
            }
        }
        auto pp = rec::ptr(gocpp::recv(tl.mp->p));
        pp->trace.mSyscallID = int64_t(tl.mp->procid);
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvGoSyscallBegin, rec::nextSeq(gocpp::recv(pp->trace), tl.gen), rec::stack(gocpp::recv(tl), skip));
    }

    void rec::GoSysExit(struct traceLocker tl, bool lostP)
    {
        auto ev = traceEvGoSyscallEnd;
        auto procStatus = traceProcSyscall;
        if(lostP)
        {
            ev = traceEvGoSyscallEndBlocked;
            procStatus = traceProcRunning;
        }
        else
        {
            rec::ptr(gocpp::recv(tl.mp->p))->trace.mSyscallID = - 1;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, procStatus)), ev);
    }

    void rec::ProcSteal(struct traceLocker tl, struct p* pp, bool inSyscall)
    {
        auto mStolenFrom = pp->trace.mSyscallID;
        pp->trace.mSyscallID = - 1;
        auto goStatus = traceGoRunning;
        auto procStatus = traceProcRunning;
        if(inSyscall)
        {
            goStatus = traceGoSyscall;
            procStatus = traceProcSyscallAbandoned;
        }
        auto w = rec::eventWriter(gocpp::recv(tl), goStatus, procStatus);
        if(! rec::statusWasTraced(gocpp::recv(pp->trace), tl.gen) && rec::acquireStatus(gocpp::recv(pp->trace), tl.gen))
        {
            w.w = rec::writeProcStatus(gocpp::recv(w.w), uint64_t(pp->id), traceProcSyscallAbandoned, pp->trace.inSweep);
        }
        rec::commit(gocpp::recv(w), traceEvProcSteal, traceArg(pp->id), rec::nextSeq(gocpp::recv(pp->trace), tl.gen), traceArg(mStolenFrom));
    }

    void rec::GoSysBlock(struct traceLocker tl, struct p* pp)
    {
    }

    void rec::HeapAlloc(struct traceLocker tl, uint64_t live)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvHeapAlloc, traceArg(live));
    }

    void rec::HeapGoal(struct traceLocker tl)
    {
        auto heapGoal = rec::heapGoal(gocpp::recv(gcController));
        if(heapGoal == ~ uint64_t(0))
        {
            heapGoal = 0;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvHeapGoal, traceArg(heapGoal));
    }

    void rec::OneNewExtraM(struct traceLocker tl, struct g* _)
    {
    }

    void rec::GoCreateSyscall(struct traceLocker tl, struct g* gp)
    {
        rec::setStatusTraced(gocpp::recv(gp->trace), tl.gen);
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoBad, traceProcBad)), traceEvGoCreateSyscall, traceArg(gp->goid));
    }

    void rec::GoDestroySyscall(struct traceLocker tl)
    {
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoSyscall, traceProcBad)), traceEvGoDestroySyscall);
    }

    void trace_userTaskCreate(uint64_t id, uint64_t parentID, std::string taskType)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserTaskBegin, traceArg(id), traceArg(parentID), rec::string(gocpp::recv(tl), taskType), rec::stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    void trace_userTaskEnd(uint64_t id)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserTaskEnd, traceArg(id), rec::stack(gocpp::recv(tl), 2));
        traceRelease(tl);
    }

    void trace_userRegion(uint64_t id, uint64_t mode, std::string name)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        runtime::traceEv ev = {};
        //Go switch emulation
        {
            auto condition = mode;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    ev = traceEvUserRegionBegin;
                    break;
                case 1:
                    ev = traceEvUserRegionEnd;
                    break;
                default:
                    return;
                    break;
            }
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), ev, traceArg(id), rec::string(gocpp::recv(tl), name), rec::stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    void trace_userLog(uint64_t id, std::string category, std::string message)
    {
        auto tl = traceAcquire();
        if(! rec::ok(gocpp::recv(tl)))
        {
            return;
        }
        rec::commit(gocpp::recv(rec::eventWriter(gocpp::recv(tl), traceGoRunning, traceProcRunning)), traceEvUserLog, traceArg(id), rec::string(gocpp::recv(tl), category), rec::uniqueString(gocpp::recv(tl), message), rec::stack(gocpp::recv(tl), 3));
        traceRelease(tl);
    }

    void traceProcFree(struct p* _)
    {
    }

    void traceThreadDestroy(struct m* mp)
    {
        assertLockHeld(& sched.lock);
        auto seq = rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        if(debugTraceReentrancy && seq % 2 != 1)
        {
            go_throw("bad use of trace.seqlock or tracer is reentrant");
        }
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            for(auto [i, gocpp_ignored] : mp->trace.buf)
            {
                if(mp->trace.buf[i] != nullptr)
                {
                    traceBufFlush(mp->trace.buf[i], uintptr_t(i));
                    mp->trace.buf[i] = nullptr;
                }
            }
            unlock(& trace.lock);
        });
        auto seq1 = rec::Add(gocpp::recv(mp->trace.seqlock), 1);
        if(seq1 != seq + 1)
        {
            print("runtime: seq1=", seq1, "\n");
            go_throw("bad use of trace.seqlock");
        }
    }

    void rec::RecordSyscallExitedTime(struct traceLocker _, struct g* _, struct p* _)
    {
    }

}

