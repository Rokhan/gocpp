// generated by GoCpp from file '$(ImportDir)/compress/zlib/writer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/zlib/writer.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/encoding/binary/binary.h"
#include "golang/fmt/errors.h"
#include "golang/hash/adler32/adler32.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"

namespace golang::zlib
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace adler32::rec;
        using namespace binary::rec;
        using namespace flate::rec;
        using namespace fmt::rec;
        using namespace hash::rec;
        using namespace io::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Writer::operator T()
    {
        T result;
        result.w = this->w;
        result.level = this->level;
        result.dict = this->dict;
        result.compressor = this->compressor;
        result.digest = this->digest;
        result.err = this->err;
        result.scratch = this->scratch;
        result.wroteHeader = this->wroteHeader;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Writer::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (level != ref.level) return false;
        if (dict != ref.dict) return false;
        if (compressor != ref.compressor) return false;
        if (digest != ref.digest) return false;
        if (err != ref.err) return false;
        if (scratch != ref.scratch) return false;
        if (wroteHeader != ref.wroteHeader) return false;
        return true;
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << level;
        os << " " << dict;
        os << " " << compressor;
        os << " " << digest;
        os << " " << err;
        os << " " << scratch;
        os << " " << wroteHeader;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    struct Writer* NewWriter(struct io::Writer w)
    {
        auto [z, gocpp_id_1] = NewWriterLevelDict(w, DefaultCompression, nullptr);
        return z;
    }

    std::tuple<struct Writer*, struct gocpp::error> NewWriterLevel(struct io::Writer w, int level)
    {
        return NewWriterLevelDict(w, level, nullptr);
    }

    std::tuple<struct Writer*, struct gocpp::error> NewWriterLevelDict(struct io::Writer w, int level, gocpp::slice<unsigned char> dict)
    {
        if(level < HuffmanOnly || level > BestCompression)
        {
            return {nullptr, mocklib::Errorf("zlib: invalid compression level: %d", level)};
        }
        return {gocpp::InitPtr<Writer>([](Writer& x) { x.w = w; x.level = level; x.dict = dict; }), nullptr};
    }

    void rec::Reset(struct Writer* z, struct io::Writer w)
    {
        z->w = w;
        if(z->compressor != nullptr)
        {
            rec::Reset(gocpp::recv(z->compressor), w);
        }
        if(z->digest != nullptr)
        {
            rec::Reset(gocpp::recv(z->digest));
        }
        z->err = nullptr;
        z->scratch = gocpp::array<unsigned char, 4> {};
        z->wroteHeader = false;
    }

    struct gocpp::error rec::writeHeader(struct Writer* z)
    {
        struct gocpp::error err;
        z->wroteHeader = true;
        z->scratch[0] = 0x78;
        //Go switch emulation
        {
            auto condition = z->level;
            int conditionId = -1;
            if(condition == - 2) { conditionId = 0; }
            if(condition == 0) { conditionId = 1; }
            if(condition == 1) { conditionId = 2; }
            else if(condition == 2) { conditionId = 3; }
            else if(condition == 3) { conditionId = 4; }
            else if(condition == 4) { conditionId = 5; }
            else if(condition == 5) { conditionId = 6; }
            else if(condition == 6) { conditionId = 7; }
            else if(condition == - 1) { conditionId = 8; }
            else if(condition == 7) { conditionId = 9; }
            else if(condition == 8) { conditionId = 10; }
            else if(condition == 9) { conditionId = 11; }
            switch(conditionId)
            {
                struct gocpp::error err;
                case 0:
                case 1:
                case 2:
                    z->scratch[1] = 0 << 6;
                    break;
                case 3:
                case 4:
                case 5:
                case 6:
                    z->scratch[1] = 1 << 6;
                    break;
                case 7:
                case 8:
                    z->scratch[1] = 2 << 6;
                    break;
                case 9:
                case 10:
                case 11:
                    z->scratch[1] = 3 << 6;
                    break;
                default:
                    gocpp::panic("unreachable");
                    break;
            }
        }
        if(z->dict != nullptr)
        {
            struct gocpp::error err;
            z->scratch[1] |= 1 << 5;
        }
        z->scratch[1] += uint8_t(31 - rec::Uint16(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 2)) % 31);
        if(std::tie(gocpp_id_2, err) = rec::Write(gocpp::recv(z->w), z->scratch.make_slice(0, 2)); err != nullptr)
        {
            struct gocpp::error err;
            return err;
        }
        if(z->dict != nullptr)
        {
            struct gocpp::error err;
            rec::PutUint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, ), adler32::Checksum(z->dict));
            if(std::tie(gocpp_id_3, err) = rec::Write(gocpp::recv(z->w), z->scratch.make_slice(0, 4)); err != nullptr)
            {
                struct gocpp::error err;
                return err;
            }
        }
        if(z->compressor == nullptr)
        {
            struct gocpp::error err;
            std::tie(z->compressor, err) = flate::NewWriterDict(z->w, z->level, z->dict);
            if(err != nullptr)
            {
                struct gocpp::error err;
                return err;
            }
            z->digest = adler32::New();
        }
        return nullptr;
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct Writer* z, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(! z->wroteHeader)
        {
            int n;
            struct gocpp::error err;
            z->err = rec::writeHeader(gocpp::recv(z));
        }
        if(z->err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, z->err};
        }
        if(len(p) == 0)
        {
            int n;
            struct gocpp::error err;
            return {0, nullptr};
        }
        std::tie(n, err) = rec::Write(gocpp::recv(z->compressor), p);
        if(err != nullptr)
        {
            int n;
            struct gocpp::error err;
            z->err = err;
            return {n, err};
        }
        rec::Write(gocpp::recv(z->digest), p);
        return {n, err};
    }

    struct gocpp::error rec::Flush(struct Writer* z)
    {
        if(! z->wroteHeader)
        {
            z->err = rec::writeHeader(gocpp::recv(z));
        }
        if(z->err != nullptr)
        {
            return z->err;
        }
        z->err = rec::Flush(gocpp::recv(z->compressor));
        return z->err;
    }

    struct gocpp::error rec::Close(struct Writer* z)
    {
        if(! z->wroteHeader)
        {
            z->err = rec::writeHeader(gocpp::recv(z));
        }
        if(z->err != nullptr)
        {
            return z->err;
        }
        z->err = rec::Close(gocpp::recv(z->compressor));
        if(z->err != nullptr)
        {
            return z->err;
        }
        auto checksum = rec::Sum32(gocpp::recv(z->digest));
        rec::PutUint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, ), checksum);
        std::tie(gocpp_id_4, z->err) = rec::Write(gocpp::recv(z->w), z->scratch.make_slice(0, 4));
        return z->err;
    }

}

