// generated by GoCpp from file '$(ImportDir)/runtime/pinner.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/pinner.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/arena.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcsweep.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Pinner is a set of Go objects each pinned to a fixed location in memory. The
    // [Pinner.Pin] method pins one object, while [Pinner.Unpin] unpins all pinned
    // objects. See their comments for more information.
    
    template<typename T> requires gocpp::GoStruct<T>
    Pinner::operator T()
    {
        T result;
        result.pinner = this->pinner;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Pinner::operator==(const T& ref) const
    {
        if (pinner != ref.pinner) return false;
        return true;
    }

    std::ostream& Pinner::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pinner;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Pinner& value)
    {
        return value.PrintTo(os);
    }

    // Pin pins a Go object, preventing it from being moved or freed by the garbage
    // collector until the [Pinner.Unpin] method has been called.
    //
    // A pointer to a pinned object can be directly stored in C memory or can be
    // contained in Go memory passed to C functions. If the pinned object itself
    // contains pointers to Go objects, these objects must be pinned separately if they
    // are going to be accessed from C code.
    //
    // The argument must be a pointer of any type or an [unsafe.Pointer].
    // It's safe to call Pin on non-Go pointers, in which case Pin will do nothing.
    void rec::Pin(struct Pinner* p, go_any pointer)
    {
        if(p->pinner == nullptr)
        {
            auto mp = acquirem();
            if(auto pp = rec::ptr(gocpp::recv(mp->p)); pp != nullptr)
            {
                p->pinner = pp->pinnerCache;
                pp->pinnerCache = nullptr;
            }
            releasem(mp);
            if(p->pinner == nullptr)
            {
                p->pinner = new(pinner);
                p->refs = p->refStore.make_slice(0, 0);
                SetFinalizer(p->pinner, [=](struct pinner* i) mutable -> void
                {
                    if(len(i->refs) != 0)
                    {
                        rec::unpin(gocpp::recv(i));
                        pinnerLeakPanic();
                    }
                });
            }
        }
        auto ptr = pinnerGetPtr(& pointer);
        if(setPinned(ptr, true))
        {
            p->refs = append(p->refs, ptr);
        }
    }

    // Unpin unpins all pinned objects of the [Pinner].
    void rec::Unpin(struct Pinner* p)
    {
        rec::unpin(gocpp::recv(p->pinner));
        auto mp = acquirem();
        if(auto pp = rec::ptr(gocpp::recv(mp->p)); pp != nullptr && pp->pinnerCache == nullptr)
        {
            pp->pinnerCache = p->pinner;
            p->pinner = nullptr;
        }
        releasem(mp);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pinner::operator T()
    {
        T result;
        result.refs = this->refs;
        result.refStore = this->refStore;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pinner::operator==(const T& ref) const
    {
        if (refs != ref.refs) return false;
        if (refStore != ref.refStore) return false;
        return true;
    }

    std::ostream& pinner::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << refs;
        os << " " << refStore;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pinner& value)
    {
        return value.PrintTo(os);
    }

    void rec::unpin(struct pinner* p)
    {
        if(p == nullptr || p->refs == nullptr)
        {
            return;
        }
        for(auto [i, gocpp_ignored] : p->refs)
        {
            setPinned(p->refs[i], false);
        }
        p->refStore = gocpp::array<unsafe::Pointer, pinnerRefStoreSize> {};
        p->refs = p->refStore.make_slice(0, 0);
    }

    unsafe::Pointer pinnerGetPtr(go_any* i)
    {
        auto e = efaceOf(i);
        auto etyp = e->_type;
        if(etyp == nullptr)
        {
            gocpp::panic(errorString("runtime.Pinner: argument is nil"s));
        }
        if(auto kind = etyp->Kind_ & kindMask; kind != kindPtr && kind != kindUnsafePointer)
        {
            gocpp::panic(errorString("runtime.Pinner: argument is not a pointer: "s + rec::string(gocpp::recv(toRType(etyp)))));
        }
        if(inUserArenaChunk(uintptr_t(e->data)))
        {
            gocpp::panic(errorString("runtime.Pinner: object was allocated into an arena"s));
        }
        return e->data;
    }

    // isPinned checks if a Go pointer is pinned.
    // nosplit, because it's called from nosplit code in cgocheck.
    //
    //go:nosplit
    bool isPinned(unsafe::Pointer ptr)
    {
        auto span = spanOfHeap(uintptr_t(ptr));
        if(span == nullptr)
        {
            return true;
        }
        auto pinnerBits = rec::getPinnerBits(gocpp::recv(span));
        if(pinnerBits == nullptr)
        {
            return false;
        }
        auto objIndex = rec::objIndex(gocpp::recv(span), uintptr_t(ptr));
        auto pinState = rec::ofObject(gocpp::recv(pinnerBits), objIndex);
        KeepAlive(ptr);
        return rec::isPinned(gocpp::recv(pinState));
    }

    // setPinned marks or unmarks a Go pointer as pinned, when the ptr is a Go pointer.
    // It will be ignored while try to pin a non-Go pointer,
    // and it will be panic while try to unpin a non-Go pointer,
    // which should not happen in normal usage.
    bool setPinned(unsafe::Pointer ptr, bool pin)
    {
        auto span = spanOfHeap(uintptr_t(ptr));
        if(span == nullptr)
        {
            if(! pin)
            {
                gocpp::panic(errorString("tried to unpin non-Go pointer"s));
            }
            return false;
        }
        auto mp = acquirem();
        rec::ensureSwept(gocpp::recv(span));
        KeepAlive(ptr);
        auto objIndex = rec::objIndex(gocpp::recv(span), uintptr_t(ptr));
        lock(& span->speciallock);
        auto pinnerBits = rec::getPinnerBits(gocpp::recv(span));
        if(pinnerBits == nullptr)
        {
            pinnerBits = rec::newPinnerBits(gocpp::recv(span));
            rec::setPinnerBits(gocpp::recv(span), pinnerBits);
        }
        auto pinState = rec::ofObject(gocpp::recv(pinnerBits), objIndex);
        if(pin)
        {
            if(rec::isPinned(gocpp::recv(pinState)))
            {
                rec::setMultiPinned(gocpp::recv(pinState), true);
                systemstack([=]() mutable -> void
                {
                    auto offset = objIndex * span->elemsize;
                    rec::incPinCounter(gocpp::recv(span), offset);
                });
            }
            else
            {
                rec::setPinned(gocpp::recv(pinState), true);
            }
        }
        else
        {
            if(rec::isPinned(gocpp::recv(pinState)))
            {
                if(rec::isMultiPinned(gocpp::recv(pinState)))
                {
                    bool exists = {};
                    systemstack([=]() mutable -> void
                    {
                        auto offset = objIndex * span->elemsize;
                        exists = rec::decPinCounter(gocpp::recv(span), offset);
                    });
                    if(! exists)
                    {
                        rec::setMultiPinned(gocpp::recv(pinState), false);
                    }
                }
                else
                {
                    rec::setPinned(gocpp::recv(pinState), false);
                }
            }
            else
            {
                go_throw("runtime.Pinner: object already unpinned"s);
            }
        }
        unlock(& span->speciallock);
        releasem(mp);
        return true;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pinState::operator T()
    {
        T result;
        result.bytep = this->bytep;
        result.byteVal = this->byteVal;
        result.mask = this->mask;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pinState::operator==(const T& ref) const
    {
        if (bytep != ref.bytep) return false;
        if (byteVal != ref.byteVal) return false;
        if (mask != ref.mask) return false;
        return true;
    }

    std::ostream& pinState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << bytep;
        os << " " << byteVal;
        os << " " << mask;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pinState& value)
    {
        return value.PrintTo(os);
    }

    // nosplit, because it's called by isPinned, which is nosplit
    //
    //go:nosplit
    bool rec::isPinned(struct pinState* v)
    {
        return (v->byteVal & v->mask) != 0;
    }

    bool rec::isMultiPinned(struct pinState* v)
    {
        return (v->byteVal & (v->mask << 1)) != 0;
    }

    void rec::setPinned(struct pinState* v, bool val)
    {
        rec::set(gocpp::recv(v), val, false);
    }

    void rec::setMultiPinned(struct pinState* v, bool val)
    {
        rec::set(gocpp::recv(v), val, true);
    }

    // set sets the pin bit of the pinState to val. If multipin is true, it
    // sets/unsets the multipin bit instead.
    void rec::set(struct pinState* v, bool val, bool multipin)
    {
        auto mask = v->mask;
        if(multipin)
        {
            mask <<= 1;
        }
        if(val)
        {
            atomic::Or8(v->bytep, mask);
        }
        else
        {
            atomic::And8(v->bytep, ~ mask);
        }
    }

    // pinnerBits is the same type as gcBits but has different methods.
    // ofObject returns the pinState of the n'th object.
    // nosplit, because it's called by isPinned, which is nosplit
    //
    //go:nosplit
    struct pinState rec::ofObject(golang::runtime::pinnerBits* p, uintptr_t n)
    {
        auto [bytep, mask] = rec::bitp(gocpp::recv((gcBits*)(p)), n * 2);
        auto byteVal = atomic::Load8(bytep);
        return pinState {bytep, byteVal, mask};
    }

    uintptr_t rec::pinnerBitSize(struct mspan* s)
    {
        return divRoundUp(uintptr_t(s->nelems) * 2, 8);
    }

    // newPinnerBits returns a pointer to 8 byte aligned bytes to be used for this
    // span's pinner bits. newPinneBits is used to mark objects that are pinned.
    // They are copied when the span is swept.
    runtime::pinnerBits* rec::newPinnerBits(struct mspan* s)
    {
        return (runtime::pinnerBits*)(newMarkBits(uintptr_t(s->nelems) * 2));
    }

    // nosplit, because it's called by isPinned, which is nosplit
    //
    //go:nosplit
    runtime::pinnerBits* rec::getPinnerBits(struct mspan* s)
    {
        return (runtime::pinnerBits*)(atomic::Loadp(unsafe::Pointer(& s->pinnerBits)));
    }

    void rec::setPinnerBits(struct mspan* s, golang::runtime::pinnerBits* p)
    {
        atomicstorep(unsafe::Pointer(& s->pinnerBits), unsafe::Pointer(p));
    }

    // refreshPinnerBits replaces pinnerBits with a fresh copy in the arenas for the
    // next GC cycle. If it does not contain any pinned objects, pinnerBits of the
    // span is set to nil.
    void rec::refreshPinnerBits(struct mspan* s)
    {
        auto p = rec::getPinnerBits(gocpp::recv(s));
        if(p == nullptr)
        {
            return;
        }
        auto hasPins = false;
        auto bytes = alignUp(rec::pinnerBitSize(gocpp::recv(s)), 8);
        for(auto [gocpp_ignored, x] : unsafe::Slice((uint64_t*)(unsafe::Pointer(& p->x)), bytes / 8))
        {
            if(x != 0)
            {
                hasPins = true;
                break;
            }
        }
        if(hasPins)
        {
            auto newPinnerBits = rec::newPinnerBits(gocpp::recv(s));
            memmove(unsafe::Pointer(& newPinnerBits->x), unsafe::Pointer(& p->x), bytes);
            rec::setPinnerBits(gocpp::recv(s), newPinnerBits);
        }
        else
        {
            rec::setPinnerBits(gocpp::recv(s), nullptr);
        }
    }

    // incPinCounter is only called for multiple pins of the same object and records
    // the _additional_ pins.
    void rec::incPinCounter(struct mspan* span, uintptr_t offset)
    {
        specialPinCounter* rec = {};
        auto [ref, exists] = rec::specialFindSplicePoint(gocpp::recv(span), offset, _KindSpecialPinCounter);
        if(! exists)
        {
            lock(& mheap_.speciallock);
            rec = (specialPinCounter*)(rec::alloc(gocpp::recv(mheap_.specialPinCounterAlloc)));
            unlock(& mheap_.speciallock);
            rec->special.offset = uint16_t(offset);
            rec->special.kind = _KindSpecialPinCounter;
            rec->special.next = *ref;
            *ref = (special*)(unsafe::Pointer(rec));
            spanHasSpecials(span);
        }
        else
        {
            rec = (specialPinCounter*)(unsafe::Pointer(*ref));
        }
        rec->counter++;
    }

    // decPinCounter decreases the counter. If the counter reaches 0, the counter
    // special is deleted and false is returned. Otherwise true is returned.
    bool rec::decPinCounter(struct mspan* span, uintptr_t offset)
    {
        auto [ref, exists] = rec::specialFindSplicePoint(gocpp::recv(span), offset, _KindSpecialPinCounter);
        if(! exists)
        {
            go_throw("runtime.Pinner: decreased non-existing pin counter"s);
        }
        auto counter = (specialPinCounter*)(unsafe::Pointer(*ref));
        counter->counter--;
        if(counter->counter == 0)
        {
            *ref = counter->special.next;
            if(span->specials == nullptr)
            {
                spanHasNoSpecials(span);
            }
            lock(& mheap_.speciallock);
            rec::free(gocpp::recv(mheap_.specialPinCounterAlloc), unsafe::Pointer(counter));
            unlock(& mheap_.speciallock);
            return false;
        }
        return true;
    }

    // only for tests
    uintptr_t* pinnerGetPinCounter(unsafe::Pointer addr)
    {
        auto [gocpp_id_0, span, objIndex] = findObject(uintptr_t(addr), 0, 0);
        auto offset = objIndex * span->elemsize;
        auto [t, exists] = rec::specialFindSplicePoint(gocpp::recv(span), offset, _KindSpecialPinCounter);
        if(! exists)
        {
            return nullptr;
        }
        auto counter = (specialPinCounter*)(unsafe::Pointer(*t));
        return & counter->counter;
    }

    // to be able to test that the GC panics when a pinned pointer is leaking, this
    // panic function is a variable, that can be overwritten by a test.
    std::function<void (void)> pinnerLeakPanic = []() mutable -> void
    {
        gocpp::panic(errorString("runtime.Pinner: found leaking pinned pointer; forgot to call Unpin()?"s));
    };
}

