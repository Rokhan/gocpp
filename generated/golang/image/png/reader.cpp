// generated by GoCpp from file '$(ImportDir)/image/png/reader.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/png/reader.h"
#include "gocpp/support.h"

#include "golang/compress/zlib/reader.h"
#include "golang/encoding/binary/binary.h"
#include "golang/fmt/print.h"
#include "golang/hash/crc32/crc32.h"
#include "golang/hash/hash.h"
#include "golang/image/color/color.h"
#include "golang/image/format.h"
#include "golang/image/geom.h"
#include "golang/image/image.h"
#include "golang/image/png/paeth.h"
#include "golang/io/io.h"

// Package png implements a PNG image decoder and encoder.
//
// The PNG specification is at https://www.w3.org/TR/PNG/.
namespace golang::png
{
    namespace rec
    {
        using namespace mocklib::rec;
        using binary::rec::Uint32;
        using hash::rec::Reset;
        using hash::rec::Sum32;
        using image::rec::Bounds;
        using image::rec::SetColorIndex;
        using image::rec::SetGray;
        using image::rec::SetGray16;
        using image::rec::SetNRGBA;
        using image::rec::SetNRGBA64;
        using image::rec::SetRGBA64;
        using io::rec::Close;
        using io::rec::Read;
        using io::rec::Write;
    }

    // Color type, as per the PNG spec.
    // A cb is a combination of color type and bit depth.
    bool cbPaletted(int cb)
    {
        return cbP1 <= cb && cb <= cbP8;
    }

    bool cbTrueColor(int cb)
    {
        return cb == cbTC8 || cb == cbTC16;
    }

    // Filter type, as per the PNG spec.
    // Interlace type.
    // interlaceScan defines the placement and size of a pass for Adam7 interlacing.
    
    template<typename T> requires gocpp::GoStruct<T>
    interlaceScan::operator T()
    {
        T result;
        result.xFactor = this->xFactor;
        result.yFactor = this->yFactor;
        result.xOffset = this->xOffset;
        result.yOffset = this->yOffset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool interlaceScan::operator==(const T& ref) const
    {
        if (xFactor != ref.xFactor) return false;
        if (yFactor != ref.yFactor) return false;
        if (xOffset != ref.xOffset) return false;
        if (yOffset != ref.yOffset) return false;
        return true;
    }

    std::ostream& interlaceScan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << xFactor;
        os << " " << yFactor;
        os << " " << xOffset;
        os << " " << yOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct interlaceScan& value)
    {
        return value.PrintTo(os);
    }

    // interlacing defines Adam7 interlacing, with 7 passes of reduced images.
    // See https://www.w3.org/TR/PNG/#8Interlace
    gocpp::slice<interlaceScan> interlacing = gocpp::slice<interlaceScan> { {8, 8, 0, 0},  {8, 8, 4, 0},  {4, 8, 0, 4},  {4, 4, 2, 0},  {2, 4, 0, 2},  {2, 2, 1, 0},  {1, 2, 0, 1}};
    // Decoding stage.
    // The PNG specification says that the IHDR, PLTE (if present), tRNS (if
    // present), IDAT and IEND chunks must appear in that order. There may be
    // multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
    // have any other chunks between them).
    // https://www.w3.org/TR/PNG/#5ChunkOrdering
    std::string pngHeader = "\x89PNG\r\n\x1a\n"s;
    
    template<typename T> requires gocpp::GoStruct<T>
    decoder::operator T()
    {
        T result;
        result.r = this->r;
        result.img = this->img;
        result.crc = this->crc;
        result.width = this->width;
        result.height = this->height;
        result.depth = this->depth;
        result.palette = this->palette;
        result.cb = this->cb;
        result.stage = this->stage;
        result.idatLength = this->idatLength;
        result.tmp = this->tmp;
        result.interlace = this->interlace;
        result.useTransparent = this->useTransparent;
        result.transparent = this->transparent;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decoder::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (img != ref.img) return false;
        if (crc != ref.crc) return false;
        if (width != ref.width) return false;
        if (height != ref.height) return false;
        if (depth != ref.depth) return false;
        if (palette != ref.palette) return false;
        if (cb != ref.cb) return false;
        if (stage != ref.stage) return false;
        if (idatLength != ref.idatLength) return false;
        if (tmp != ref.tmp) return false;
        if (interlace != ref.interlace) return false;
        if (useTransparent != ref.useTransparent) return false;
        if (transparent != ref.transparent) return false;
        return true;
    }

    std::ostream& decoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << img;
        os << " " << crc;
        os << " " << width;
        os << " " << height;
        os << " " << depth;
        os << " " << palette;
        os << " " << cb;
        os << " " << stage;
        os << " " << idatLength;
        os << " " << tmp;
        os << " " << interlace;
        os << " " << useTransparent;
        os << " " << transparent;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decoder& value)
    {
        return value.PrintTo(os);
    }

    // A FormatError reports that the input is not a valid PNG.
    std::string rec::Error(golang::png::FormatError e)
    {
        return "png: invalid format: "s + std::string(e);
    }

    FormatError chunkOrderError = FormatError("chunk out of order"s);
    // An UnsupportedError reports that the input uses a valid but unimplemented PNG feature.
    std::string rec::Error(golang::png::UnsupportedError e)
    {
        return "png: unsupported feature: "s + std::string(e);
    }

    struct gocpp::error rec::parseIHDR(struct decoder* d, uint32_t length)
    {
        if(length != 13)
        {
            return FormatError("bad IHDR length"s);
        }
        if(auto [gocpp_id_0, err] = io::ReadFull(d->r, d->tmp.make_slice(0, 13)); err != nullptr)
        {
            return err;
        }
        rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(0, 13));
        if(d->tmp[10] != 0)
        {
            return UnsupportedError("compression method"s);
        }
        if(d->tmp[11] != 0)
        {
            return UnsupportedError("filter method"s);
        }
        if(d->tmp[12] != itNone && d->tmp[12] != itAdam7)
        {
            return FormatError("invalid interlace method"s);
        }
        d->interlace = int(d->tmp[12]);
        auto w = int32_t(rec::Uint32(gocpp::recv(binary::BigEndian), d->tmp.make_slice(0, 4)));
        auto h = int32_t(rec::Uint32(gocpp::recv(binary::BigEndian), d->tmp.make_slice(4, 8)));
        if(w <= 0 || h <= 0)
        {
            return FormatError("non-positive dimension"s);
        }
        auto nPixels64 = int64_t(w) * int64_t(h);
        auto nPixels = int(nPixels64);
        if(nPixels64 != int64_t(nPixels))
        {
            return UnsupportedError("dimension overflow"s);
        }
        if(nPixels != (nPixels * 8) / 8)
        {
            return UnsupportedError("dimension overflow"s);
        }
        d->cb = cbInvalid;
        d->depth = int(d->tmp[8]);
        //Go switch emulation
        {
            auto condition = d->depth;
            int conditionId = -1;
            if(condition == 1) { conditionId = 0; }
            else if(condition == 2) { conditionId = 1; }
            else if(condition == 4) { conditionId = 2; }
            else if(condition == 8) { conditionId = 3; }
            else if(condition == 16) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctPaletted) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG1;
                                break;
                            case 1:
                                d->cb = cbP1;
                                break;
                        }
                    }
                    break;
                case 1:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctPaletted) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG2;
                                break;
                            case 1:
                                d->cb = cbP2;
                                break;
                        }
                    }
                    break;
                case 2:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctPaletted) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG4;
                                break;
                            case 1:
                                d->cb = cbP4;
                                break;
                        }
                    }
                    break;
                case 3:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctTrueColor) { conditionId = 1; }
                        else if(condition == ctPaletted) { conditionId = 2; }
                        else if(condition == ctGrayscaleAlpha) { conditionId = 3; }
                        else if(condition == ctTrueColorAlpha) { conditionId = 4; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG8;
                                break;
                            case 1:
                                d->cb = cbTC8;
                                break;
                            case 2:
                                d->cb = cbP8;
                                break;
                            case 3:
                                d->cb = cbGA8;
                                break;
                            case 4:
                                d->cb = cbTCA8;
                                break;
                        }
                    }
                    break;
                case 4:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctTrueColor) { conditionId = 1; }
                        else if(condition == ctGrayscaleAlpha) { conditionId = 2; }
                        else if(condition == ctTrueColorAlpha) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG16;
                                break;
                            case 1:
                                d->cb = cbTC16;
                                break;
                            case 2:
                                d->cb = cbGA16;
                                break;
                            case 3:
                                d->cb = cbTCA16;
                                break;
                        }
                    }
                    break;
            }
        }
        if(d->cb == cbInvalid)
        {
            return UnsupportedError(mocklib::Sprintf("bit depth %d, color type %d"s, d->tmp[8], d->tmp[9]));
        }
        std::tie(d->width, d->height) = std::tuple{int(w), int(h)};
        return rec::verifyChecksum(gocpp::recv(d));
    }

    struct gocpp::error rec::parsePLTE(struct decoder* d, uint32_t length)
    {
        auto np = int(length / 3);
        if(length % 3 != 0 || np <= 0 || np > 256 || np > (1 << (unsigned int)(d->depth)))
        {
            return FormatError("bad PLTE length"s);
        }
        auto [n, err] = io::ReadFull(d->r, d->tmp.make_slice(0, 3 * np));
        if(err != nullptr)
        {
            return err;
        }
        rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbP1) { conditionId = 0; }
            else if(condition == cbP2) { conditionId = 1; }
            else if(condition == cbP4) { conditionId = 2; }
            else if(condition == cbP8) { conditionId = 3; }
            else if(condition == cbTC8) { conditionId = 4; }
            else if(condition == cbTCA8) { conditionId = 5; }
            else if(condition == cbTC16) { conditionId = 6; }
            else if(condition == cbTCA16) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    d->palette = gocpp::make(color::Palette, 256);
                    for(auto i = 0; i < np; i++)
                    {
                        d->palette[i] = color::RGBA {d->tmp[3 * i + 0], d->tmp[3 * i + 1], d->tmp[3 * i + 2], 0xff};
                    }
                    for(auto i = np; i < 256; i++)
                    {
                        d->palette[i] = color::RGBA {0x00, 0x00, 0x00, 0xff};
                    }
                    d->palette = d->palette.make_slice(0, np);
                    break;
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                default:
                    return FormatError("PLTE, color type mismatch"s);
                    break;
            }
        }
        return rec::verifyChecksum(gocpp::recv(d));
    }

    struct gocpp::error rec::parsetRNS(struct decoder* d, uint32_t length)
    {
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbG1) { conditionId = 0; }
            else if(condition == cbG2) { conditionId = 1; }
            else if(condition == cbG4) { conditionId = 2; }
            else if(condition == cbG8) { conditionId = 3; }
            else if(condition == cbG16) { conditionId = 4; }
            else if(condition == cbTC8) { conditionId = 5; }
            else if(condition == cbTC16) { conditionId = 6; }
            else if(condition == cbP1) { conditionId = 7; }
            else if(condition == cbP2) { conditionId = 8; }
            else if(condition == cbP4) { conditionId = 9; }
            else if(condition == cbP8) { conditionId = 10; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    if(length != 2)
                    {
                        return FormatError("bad tRNS length"s);
                    }
                    auto [n, err] = io::ReadFull(d->r, d->tmp.make_slice(0, length));
                    if(err != nullptr)
                    {
                        return err;
                    }
                    rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
                    copy(d->transparent.make_slice(0), d->tmp.make_slice(0, length));
                    //Go switch emulation
                    {
                        auto condition = d->cb;
                        int conditionId = -1;
                        if(condition == cbG1) { conditionId = 0; }
                        else if(condition == cbG2) { conditionId = 1; }
                        else if(condition == cbG4) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                d->transparent[1] *= 0xff;
                                break;
                            case 1:
                                d->transparent[1] *= 0x55;
                                break;
                            case 2:
                                d->transparent[1] *= 0x11;
                                break;
                        }
                    }
                    d->useTransparent = true;
                    break;
                case 5:
                case 6:
                    if(length != 6)
                    {
                        return FormatError("bad tRNS length"s);
                    }
                    std::tie(n, err) = io::ReadFull(d->r, d->tmp.make_slice(0, length));
                    if(err != nullptr)
                    {
                        return err;
                    }
                    rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
                    copy(d->transparent.make_slice(0), d->tmp.make_slice(0, length));
                    d->useTransparent = true;
                    break;
                case 7:
                case 8:
                case 9:
                case 10:
                    if(length > 256)
                    {
                        return FormatError("bad tRNS length"s);
                    }
                    std::tie(n, err) = io::ReadFull(d->r, d->tmp.make_slice(0, length));
                    if(err != nullptr)
                    {
                        return err;
                    }
                    rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
                    if(len(d->palette) < n)
                    {
                        d->palette = d->palette.make_slice(0, n);
                    }
                    for(auto i = 0; i < n; i++)
                    {
                        auto rgba = gocpp::getValue<color::RGBA>(d->palette[i]);
                        d->palette[i] = color::NRGBA {rgba.R, rgba.G, rgba.B, d->tmp[i]};
                    }
                    break;
                default:
                    return FormatError("tRNS, color type mismatch"s);
                    break;
            }
        }
        return rec::verifyChecksum(gocpp::recv(d));
    }

    // Read presents one or more IDAT chunks as one continuous stream (minus the
    // intermediate chunk headers and footers). If the PNG data looked like:
    //
    //	... len0 IDAT xxx crc0 len1 IDAT yy crc1 len2 IEND crc2
    //
    // then this reader presents xxxyy. For well-formed PNG data, the decoder state
    // immediately before the first Read call is that d.r is positioned between the
    // first IDAT and xxx, and the decoder state immediately after the last Read
    // call is that d.r is positioned between yy and crc1.
    std::tuple<int, struct gocpp::error> rec::Read(struct decoder* d, gocpp::slice<unsigned char> p)
    {
        if(len(p) == 0)
        {
            return {0, nullptr};
        }
        for(; d->idatLength == 0; )
        {
            if(auto err = rec::verifyChecksum(gocpp::recv(d)); err != nullptr)
            {
                return {0, err};
            }
            if(auto [gocpp_id_1, err] = io::ReadFull(d->r, d->tmp.make_slice(0, 8)); err != nullptr)
            {
                return {0, err};
            }
            d->idatLength = rec::Uint32(gocpp::recv(binary::BigEndian), d->tmp.make_slice(0, 4));
            if(std::string(d->tmp.make_slice(4, 8)) != "IDAT"s)
            {
                return {0, FormatError("not enough pixel data"s)};
            }
            rec::Reset(gocpp::recv(d->crc));
            rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(4, 8));
        }
        if(int(d->idatLength) < 0)
        {
            return {0, UnsupportedError("IDAT chunk length overflow"s)};
        }
        auto [n, err] = rec::Read(gocpp::recv(d->r), p.make_slice(0, gocpp::min(len(p), int(d->idatLength))));
        rec::Write(gocpp::recv(d->crc), p.make_slice(0, n));
        d->idatLength -= uint32_t(n);
        return {n, err};
    }

    // decode decodes the IDAT data into an image.
    std::tuple<image::Image, struct gocpp::error> rec::decode(struct decoder* d)
    {
        gocpp::Defer defer;
        try
        {
            auto [r, err] = zlib::NewReader(d);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(r)); });
            image::Image img = {};
            if(d->interlace == itNone)
            {
                std::tie(img, err) = rec::readImagePass(gocpp::recv(d), r, 0, false);
                if(err != nullptr)
                {
                    return {nullptr, err};
                }
            }
            else
            if(d->interlace == itAdam7)
            {
                std::tie(img, err) = rec::readImagePass(gocpp::recv(d), nullptr, 0, true);
                if(err != nullptr)
                {
                    return {nullptr, err};
                }
                for(auto pass = 0; pass < 7; pass++)
                {
                    auto [imagePass, err] = rec::readImagePass(gocpp::recv(d), r, pass, false);
                    if(err != nullptr)
                    {
                        return {nullptr, err};
                    }
                    if(imagePass != nullptr)
                    {
                        rec::mergePassInto(gocpp::recv(d), img, imagePass, pass);
                    }
                }
            }
            auto n = 0;
            for(auto i = 0; n == 0 && err == nullptr; i++)
            {
                if(i == 100)
                {
                    return {nullptr, io::ErrNoProgress};
                }
                std::tie(n, err) = rec::Read(gocpp::recv(r), d->tmp.make_slice(0, 1));
            }
            if(err != nullptr && err != io::go_EOF)
            {
                return {nullptr, FormatError(rec::Error(gocpp::recv(err)))};
            }
            if(n != 0 || d->idatLength != 0)
            {
                return {nullptr, FormatError("too much pixel data"s)};
            }
            return {img, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // readImagePass reads a single image pass, sized according to the pass number.
    std::tuple<image::Image, struct gocpp::error> rec::readImagePass(struct decoder* d, io::Reader r, int pass, bool allocateOnly)
    {
        auto bitsPerPixel = 0;
        auto pixOffset = 0;
        image::Gray* gray = {};
        image::RGBA* rgba = {};
        image::Paletted* paletted = {};
        image::NRGBA* nrgba = {};
        image::Gray16* gray16 = {};
        image::RGBA64* rgba64 = {};
        image::NRGBA64* nrgba64 = {};
        image::Image img = {};
        auto [width, height] = std::tuple{d->width, d->height};
        if(d->interlace == itAdam7 && ! allocateOnly)
        {
            auto p = interlacing[pass];
            width = (width - p.xOffset + p.xFactor - 1) / p.xFactor;
            height = (height - p.yOffset + p.yFactor - 1) / p.yFactor;
            if(width == 0 || height == 0)
            {
                return {nullptr, nullptr};
            }
        }
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbG1) { conditionId = 0; }
            else if(condition == cbG2) { conditionId = 1; }
            else if(condition == cbG4) { conditionId = 2; }
            else if(condition == cbG8) { conditionId = 3; }
            else if(condition == cbGA8) { conditionId = 4; }
            else if(condition == cbTC8) { conditionId = 5; }
            else if(condition == cbP1) { conditionId = 6; }
            else if(condition == cbP2) { conditionId = 7; }
            else if(condition == cbP4) { conditionId = 8; }
            else if(condition == cbP8) { conditionId = 9; }
            else if(condition == cbTCA8) { conditionId = 10; }
            else if(condition == cbG16) { conditionId = 11; }
            else if(condition == cbGA16) { conditionId = 12; }
            else if(condition == cbTC16) { conditionId = 13; }
            else if(condition == cbTCA16) { conditionId = 14; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    bitsPerPixel = d->depth;
                    if(d->useTransparent)
                    {
                        nrgba = image::NewNRGBA(image::Rect(0, 0, width, height));
                        img = nrgba;
                    }
                    else
                    {
                        gray = image::NewGray(image::Rect(0, 0, width, height));
                        img = gray;
                    }
                    break;
                case 4:
                    bitsPerPixel = 16;
                    nrgba = image::NewNRGBA(image::Rect(0, 0, width, height));
                    img = nrgba;
                    break;
                case 5:
                    bitsPerPixel = 24;
                    if(d->useTransparent)
                    {
                        nrgba = image::NewNRGBA(image::Rect(0, 0, width, height));
                        img = nrgba;
                    }
                    else
                    {
                        rgba = image::NewRGBA(image::Rect(0, 0, width, height));
                        img = rgba;
                    }
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                    bitsPerPixel = d->depth;
                    paletted = image::NewPaletted(image::Rect(0, 0, width, height), d->palette);
                    img = paletted;
                    break;
                case 10:
                    bitsPerPixel = 32;
                    nrgba = image::NewNRGBA(image::Rect(0, 0, width, height));
                    img = nrgba;
                    break;
                case 11:
                    bitsPerPixel = 16;
                    if(d->useTransparent)
                    {
                        nrgba64 = image::NewNRGBA64(image::Rect(0, 0, width, height));
                        img = nrgba64;
                    }
                    else
                    {
                        gray16 = image::NewGray16(image::Rect(0, 0, width, height));
                        img = gray16;
                    }
                    break;
                case 12:
                    bitsPerPixel = 32;
                    nrgba64 = image::NewNRGBA64(image::Rect(0, 0, width, height));
                    img = nrgba64;
                    break;
                case 13:
                    bitsPerPixel = 48;
                    if(d->useTransparent)
                    {
                        nrgba64 = image::NewNRGBA64(image::Rect(0, 0, width, height));
                        img = nrgba64;
                    }
                    else
                    {
                        rgba64 = image::NewRGBA64(image::Rect(0, 0, width, height));
                        img = rgba64;
                    }
                    break;
                case 14:
                    bitsPerPixel = 64;
                    nrgba64 = image::NewNRGBA64(image::Rect(0, 0, width, height));
                    img = nrgba64;
                    break;
            }
        }
        if(allocateOnly)
        {
            return {img, nullptr};
        }
        auto bytesPerPixel = (bitsPerPixel + 7) / 8;
        auto rowSize = 1 + (int64_t(bitsPerPixel) * int64_t(width) + 7) / 8;
        if(rowSize != int64_t(int(rowSize)))
        {
            return {nullptr, UnsupportedError("dimension overflow"s)};
        }
        auto cr = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), rowSize);
        auto pr = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), rowSize);
        for(auto y = 0; y < height; y++)
        {
            auto [gocpp_id_2, err] = io::ReadFull(r, cr);
            if(err != nullptr)
            {
                if(err == io::go_EOF || err == io::ErrUnexpectedEOF)
                {
                    return {nullptr, FormatError("not enough pixel data"s)};
                }
                return {nullptr, err};
            }
            auto cdat = cr.make_slice(1);
            auto pdat = pr.make_slice(1);
            //Go switch emulation
            {
                auto condition = cr[0];
                int conditionId = -1;
                if(condition == ftNone) { conditionId = 0; }
                else if(condition == ftSub) { conditionId = 1; }
                else if(condition == ftUp) { conditionId = 2; }
                else if(condition == ftAverage) { conditionId = 3; }
                else if(condition == ftPaeth) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                        break;
                    case 1:
                        for(auto i = bytesPerPixel; i < len(cdat); i++)
                        {
                            cdat[i] += cdat[i - bytesPerPixel];
                        }
                        break;
                    case 2:
                        for(auto [i, p] : pdat)
                        {
                            cdat[i] += p;
                        }
                        break;
                    case 3:
                        for(auto i = 0; i < bytesPerPixel; i++)
                        {
                            cdat[i] += pdat[i] / 2;
                        }
                        for(auto i = bytesPerPixel; i < len(cdat); i++)
                        {
                            cdat[i] += uint8_t((int(cdat[i - bytesPerPixel]) + int(pdat[i])) / 2);
                        }
                        break;
                    case 4:
                        filterPaeth(cdat, pdat, bytesPerPixel);
                        break;
                    default:
                        return {nullptr, FormatError("bad filter type"s)};
                        break;
                }
            }
            //Go switch emulation
            {
                auto condition = d->cb;
                int conditionId = -1;
                if(condition == cbG1) { conditionId = 0; }
                else if(condition == cbG2) { conditionId = 1; }
                else if(condition == cbG4) { conditionId = 2; }
                else if(condition == cbG8) { conditionId = 3; }
                else if(condition == cbGA8) { conditionId = 4; }
                else if(condition == cbTC8) { conditionId = 5; }
                else if(condition == cbP1) { conditionId = 6; }
                else if(condition == cbP2) { conditionId = 7; }
                else if(condition == cbP4) { conditionId = 8; }
                else if(condition == cbP8) { conditionId = 9; }
                else if(condition == cbTCA8) { conditionId = 10; }
                else if(condition == cbG16) { conditionId = 11; }
                else if(condition == cbGA16) { conditionId = 12; }
                else if(condition == cbTC16) { conditionId = 13; }
                else if(condition == cbTCA16) { conditionId = 14; }
                switch(conditionId)
                {
                    case 0:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x += 8)
                            {
                                auto b = cdat[x / 8];
                                for(auto x2 = 0; x2 < 8 && x + x2 < width; x2++)
                                {
                                    auto ycol = (b >> 7) * 0xff;
                                    auto acol = uint8_t(0xff);
                                    if(ycol == ty)
                                    {
                                        acol = 0x00;
                                    }
                                    rec::SetNRGBA(gocpp::recv(nrgba), x + x2, y, color::NRGBA {ycol, ycol, ycol, acol});
                                    b <<= 1;
                                }
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x += 8)
                            {
                                auto b = cdat[x / 8];
                                for(auto x2 = 0; x2 < 8 && x + x2 < width; x2++)
                                {
                                    rec::SetGray(gocpp::recv(gray), x + x2, y, color::Gray {(b >> 7) * 0xff});
                                    b <<= 1;
                                }
                            }
                        }
                        break;
                    case 1:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x += 4)
                            {
                                auto b = cdat[x / 4];
                                for(auto x2 = 0; x2 < 4 && x + x2 < width; x2++)
                                {
                                    auto ycol = (b >> 6) * 0x55;
                                    auto acol = uint8_t(0xff);
                                    if(ycol == ty)
                                    {
                                        acol = 0x00;
                                    }
                                    rec::SetNRGBA(gocpp::recv(nrgba), x + x2, y, color::NRGBA {ycol, ycol, ycol, acol});
                                    b <<= 2;
                                }
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x += 4)
                            {
                                auto b = cdat[x / 4];
                                for(auto x2 = 0; x2 < 4 && x + x2 < width; x2++)
                                {
                                    rec::SetGray(gocpp::recv(gray), x + x2, y, color::Gray {(b >> 6) * 0x55});
                                    b <<= 2;
                                }
                            }
                        }
                        break;
                    case 2:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x += 2)
                            {
                                auto b = cdat[x / 2];
                                for(auto x2 = 0; x2 < 2 && x + x2 < width; x2++)
                                {
                                    auto ycol = (b >> 4) * 0x11;
                                    auto acol = uint8_t(0xff);
                                    if(ycol == ty)
                                    {
                                        acol = 0x00;
                                    }
                                    rec::SetNRGBA(gocpp::recv(nrgba), x + x2, y, color::NRGBA {ycol, ycol, ycol, acol});
                                    b <<= 4;
                                }
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x += 2)
                            {
                                auto b = cdat[x / 2];
                                for(auto x2 = 0; x2 < 2 && x + x2 < width; x2++)
                                {
                                    rec::SetGray(gocpp::recv(gray), x + x2, y, color::Gray {(b >> 4) * 0x11});
                                    b <<= 4;
                                }
                            }
                        }
                        break;
                    case 3:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x++)
                            {
                                auto ycol = cdat[x];
                                auto acol = uint8_t(0xff);
                                if(ycol == ty)
                                {
                                    acol = 0x00;
                                }
                                rec::SetNRGBA(gocpp::recv(nrgba), x, y, color::NRGBA {ycol, ycol, ycol, acol});
                            }
                        }
                        else
                        {
                            copy(gray->Pix.make_slice(pixOffset), cdat);
                            pixOffset += gray->Stride;
                        }
                        break;
                    case 4:
                        for(auto x = 0; x < width; x++)
                        {
                            auto ycol = cdat[2 * x + 0];
                            rec::SetNRGBA(gocpp::recv(nrgba), x, y, color::NRGBA {ycol, ycol, ycol, cdat[2 * x + 1]});
                        }
                        break;
                    case 5:
                        if(d->useTransparent)
                        {
                            auto [pix, i, j] = std::tuple{nrgba->Pix, pixOffset, 0};
                            auto [tr, tg, tb] = std::tuple{d->transparent[1], d->transparent[3], d->transparent[5]};
                            for(auto x = 0; x < width; x++)
                            {
                                auto r = cdat[j + 0];
                                auto g = cdat[j + 1];
                                auto b = cdat[j + 2];
                                auto a = uint8_t(0xff);
                                if(r == tr && g == tg && b == tb)
                                {
                                    a = 0x00;
                                }
                                pix[i + 0] = r;
                                pix[i + 1] = g;
                                pix[i + 2] = b;
                                pix[i + 3] = a;
                                i += 4;
                                j += 3;
                            }
                            pixOffset += nrgba->Stride;
                        }
                        else
                        {
                            auto [pix, i, j] = std::tuple{rgba->Pix, pixOffset, 0};
                            for(auto x = 0; x < width; x++)
                            {
                                pix[i + 0] = cdat[j + 0];
                                pix[i + 1] = cdat[j + 1];
                                pix[i + 2] = cdat[j + 2];
                                pix[i + 3] = 0xff;
                                i += 4;
                                j += 3;
                            }
                            pixOffset += rgba->Stride;
                        }
                        break;
                    case 6:
                        for(auto x = 0; x < width; x += 8)
                        {
                            auto b = cdat[x / 8];
                            for(auto x2 = 0; x2 < 8 && x + x2 < width; x2++)
                            {
                                auto idx = b >> 7;
                                if(len(paletted->Palette) <= int(idx))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(idx) + 1);
                                }
                                rec::SetColorIndex(gocpp::recv(paletted), x + x2, y, idx);
                                b <<= 1;
                            }
                        }
                        break;
                    case 7:
                        for(auto x = 0; x < width; x += 4)
                        {
                            auto b = cdat[x / 4];
                            for(auto x2 = 0; x2 < 4 && x + x2 < width; x2++)
                            {
                                auto idx = b >> 6;
                                if(len(paletted->Palette) <= int(idx))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(idx) + 1);
                                }
                                rec::SetColorIndex(gocpp::recv(paletted), x + x2, y, idx);
                                b <<= 2;
                            }
                        }
                        break;
                    case 8:
                        for(auto x = 0; x < width; x += 2)
                        {
                            auto b = cdat[x / 2];
                            for(auto x2 = 0; x2 < 2 && x + x2 < width; x2++)
                            {
                                auto idx = b >> 4;
                                if(len(paletted->Palette) <= int(idx))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(idx) + 1);
                                }
                                rec::SetColorIndex(gocpp::recv(paletted), x + x2, y, idx);
                                b <<= 4;
                            }
                        }
                        break;
                    case 9:
                        if(len(paletted->Palette) != 256)
                        {
                            for(auto x = 0; x < width; x++)
                            {
                                if(len(paletted->Palette) <= int(cdat[x]))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(cdat[x]) + 1);
                                }
                            }
                        }
                        copy(paletted->Pix.make_slice(pixOffset), cdat);
                        pixOffset += paletted->Stride;
                        break;
                    case 10:
                        copy(nrgba->Pix.make_slice(pixOffset), cdat);
                        pixOffset += nrgba->Stride;
                        break;
                    case 11:
                        if(d->useTransparent)
                        {
                            auto ty = (uint16_t(d->transparent[0]) << 8) | uint16_t(d->transparent[1]);
                            for(auto x = 0; x < width; x++)
                            {
                                auto ycol = (uint16_t(cdat[2 * x + 0]) << 8) | uint16_t(cdat[2 * x + 1]);
                                auto acol = uint16_t(0xffff);
                                if(ycol == ty)
                                {
                                    acol = 0x0000;
                                }
                                rec::SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {ycol, ycol, ycol, acol});
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x++)
                            {
                                auto ycol = (uint16_t(cdat[2 * x + 0]) << 8) | uint16_t(cdat[2 * x + 1]);
                                rec::SetGray16(gocpp::recv(gray16), x, y, color::Gray16 {ycol});
                            }
                        }
                        break;
                    case 12:
                        for(auto x = 0; x < width; x++)
                        {
                            auto ycol = (uint16_t(cdat[4 * x + 0]) << 8) | uint16_t(cdat[4 * x + 1]);
                            auto acol = (uint16_t(cdat[4 * x + 2]) << 8) | uint16_t(cdat[4 * x + 3]);
                            rec::SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {ycol, ycol, ycol, acol});
                        }
                        break;
                    case 13:
                        if(d->useTransparent)
                        {
                            auto tr = (uint16_t(d->transparent[0]) << 8) | uint16_t(d->transparent[1]);
                            auto tg = (uint16_t(d->transparent[2]) << 8) | uint16_t(d->transparent[3]);
                            auto tb = (uint16_t(d->transparent[4]) << 8) | uint16_t(d->transparent[5]);
                            for(auto x = 0; x < width; x++)
                            {
                                auto rcol = (uint16_t(cdat[6 * x + 0]) << 8) | uint16_t(cdat[6 * x + 1]);
                                auto gcol = (uint16_t(cdat[6 * x + 2]) << 8) | uint16_t(cdat[6 * x + 3]);
                                auto bcol = (uint16_t(cdat[6 * x + 4]) << 8) | uint16_t(cdat[6 * x + 5]);
                                auto acol = uint16_t(0xffff);
                                if(rcol == tr && gcol == tg && bcol == tb)
                                {
                                    acol = 0x0000;
                                }
                                rec::SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {rcol, gcol, bcol, acol});
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x++)
                            {
                                auto rcol = (uint16_t(cdat[6 * x + 0]) << 8) | uint16_t(cdat[6 * x + 1]);
                                auto gcol = (uint16_t(cdat[6 * x + 2]) << 8) | uint16_t(cdat[6 * x + 3]);
                                auto bcol = (uint16_t(cdat[6 * x + 4]) << 8) | uint16_t(cdat[6 * x + 5]);
                                rec::SetRGBA64(gocpp::recv(rgba64), x, y, color::RGBA64 {rcol, gcol, bcol, 0xffff});
                            }
                        }
                        break;
                    case 14:
                        for(auto x = 0; x < width; x++)
                        {
                            auto rcol = (uint16_t(cdat[8 * x + 0]) << 8) | uint16_t(cdat[8 * x + 1]);
                            auto gcol = (uint16_t(cdat[8 * x + 2]) << 8) | uint16_t(cdat[8 * x + 3]);
                            auto bcol = (uint16_t(cdat[8 * x + 4]) << 8) | uint16_t(cdat[8 * x + 5]);
                            auto acol = (uint16_t(cdat[8 * x + 6]) << 8) | uint16_t(cdat[8 * x + 7]);
                            rec::SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {rcol, gcol, bcol, acol});
                        }
                        break;
                }
            }
            std::tie(pr, cr) = std::tuple{cr, pr};
        }
        return {img, nullptr};
    }

    // mergePassInto merges a single pass into a full sized image.
    void rec::mergePassInto(struct decoder* d, image::Image dst, image::Image src, int pass)
    {
        auto p = interlacing[pass];
        gocpp::slice<uint8_t> srcPix = {};
        gocpp::slice<uint8_t> dstPix = {};
        int stride = {};
        image::Rectangle rect = {};
        int bytesPerPixel = {};
        //Go type switch emulation
        {
            const auto& gocpp_id_3 = gocpp::type_info(dst);
            int conditionId = -1;
            if(gocpp_id_3 == typeid(image::Alpha*)) { conditionId = 0; }
            else if(gocpp_id_3 == typeid(image::Alpha16*)) { conditionId = 1; }
            else if(gocpp_id_3 == typeid(image::Gray*)) { conditionId = 2; }
            else if(gocpp_id_3 == typeid(image::Gray16*)) { conditionId = 3; }
            else if(gocpp_id_3 == typeid(image::NRGBA*)) { conditionId = 4; }
            else if(gocpp_id_3 == typeid(image::NRGBA64*)) { conditionId = 5; }
            else if(gocpp_id_3 == typeid(image::Paletted*)) { conditionId = 6; }
            else if(gocpp_id_3 == typeid(image::RGBA*)) { conditionId = 7; }
            else if(gocpp_id_3 == typeid(image::RGBA64*)) { conditionId = 8; }
            switch(conditionId)
            {
                case 0:
                {
                    image::Alpha* target = gocpp::any_cast<image::Alpha*>(dst);
                    srcPix = gocpp::getValue<image::Alpha*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 1;
                    break;
                }
                case 1:
                {
                    image::Alpha16* target = gocpp::any_cast<image::Alpha16*>(dst);
                    srcPix = gocpp::getValue<image::Alpha16*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 2;
                    break;
                }
                case 2:
                {
                    image::Gray* target = gocpp::any_cast<image::Gray*>(dst);
                    srcPix = gocpp::getValue<image::Gray*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 1;
                    break;
                }
                case 3:
                {
                    image::Gray16* target = gocpp::any_cast<image::Gray16*>(dst);
                    srcPix = gocpp::getValue<image::Gray16*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 2;
                    break;
                }
                case 4:
                {
                    image::NRGBA* target = gocpp::any_cast<image::NRGBA*>(dst);
                    srcPix = gocpp::getValue<image::NRGBA*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 4;
                    break;
                }
                case 5:
                {
                    image::NRGBA64* target = gocpp::any_cast<image::NRGBA64*>(dst);
                    srcPix = gocpp::getValue<image::NRGBA64*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 8;
                    break;
                }
                case 6:
                {
                    image::Paletted* target = gocpp::any_cast<image::Paletted*>(dst);
                    auto source = gocpp::getValue<image::Paletted*>(src);
                    srcPix = source->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 1;
                    if(len(target->Palette) < len(source->Palette))
                    {
                        target->Palette = source->Palette;
                    }
                    break;
                }
                case 7:
                {
                    image::RGBA* target = gocpp::any_cast<image::RGBA*>(dst);
                    srcPix = gocpp::getValue<image::RGBA*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 4;
                    break;
                }
                case 8:
                {
                    image::RGBA64* target = gocpp::any_cast<image::RGBA64*>(dst);
                    srcPix = gocpp::getValue<image::RGBA64*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 8;
                    break;
                }
            }
        }
        auto [s, bounds] = std::tuple{0, rec::Bounds(gocpp::recv(src))};
        for(auto y = bounds.Min.Y; y < bounds.Max.Y; y++)
        {
            auto dBase = (y * p.yFactor + p.yOffset - rect.Min.Y) * stride + (p.xOffset - rect.Min.X) * bytesPerPixel;
            for(auto x = bounds.Min.X; x < bounds.Max.X; x++)
            {
                auto d = dBase + x * p.xFactor * bytesPerPixel;
                copy(dstPix.make_slice(d), srcPix.make_slice(s, s + bytesPerPixel));
                s += bytesPerPixel;
            }
        }
    }

    struct gocpp::error rec::parseIDAT(struct decoder* d, uint32_t length)
    {
        struct gocpp::error err;
        d->idatLength = length;
        std::tie(d->img, err) = rec::decode(gocpp::recv(d));
        if(err != nullptr)
        {
            return err;
        }
        return rec::verifyChecksum(gocpp::recv(d));
    }

    struct gocpp::error rec::parseIEND(struct decoder* d, uint32_t length)
    {
        if(length != 0)
        {
            return FormatError("bad IEND length"s);
        }
        return rec::verifyChecksum(gocpp::recv(d));
    }

    struct gocpp::error rec::parseChunk(struct decoder* d, bool configOnly)
    {
        if(auto [gocpp_id_4, err] = io::ReadFull(d->r, d->tmp.make_slice(0, 8)); err != nullptr)
        {
            return err;
        }
        auto length = rec::Uint32(gocpp::recv(binary::BigEndian), d->tmp.make_slice(0, 4));
        rec::Reset(gocpp::recv(d->crc));
        rec::Write(gocpp::recv(d->crc), d->tmp.make_slice(4, 8));
        //Go switch emulation
        {
            auto condition = std::string(d->tmp.make_slice(4, 8));
            int conditionId = -1;
            if(condition == "IHDR"s) { conditionId = 0; }
            else if(condition == "PLTE"s) { conditionId = 1; }
            else if(condition == "tRNS"s) { conditionId = 2; }
            else if(condition == "IDAT"s) { conditionId = 3; }
            else if(condition == "IEND"s) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    if(d->stage != dsStart)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeenIHDR;
                    return rec::parseIHDR(gocpp::recv(d), length);
                    break;
                case 1:
                    if(d->stage != dsSeenIHDR)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeenPLTE;
                    return rec::parsePLTE(gocpp::recv(d), length);
                    break;
                case 2:
                    if(cbPaletted(d->cb))
                    {
                        if(d->stage != dsSeenPLTE)
                        {
                            return chunkOrderError;
                        }
                    }
                    else
                    if(cbTrueColor(d->cb))
                    {
                        if(d->stage != dsSeenIHDR && d->stage != dsSeenPLTE)
                        {
                            return chunkOrderError;
                        }
                    }
                    else
                    if(d->stage != dsSeenIHDR)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeentRNS;
                    return rec::parsetRNS(gocpp::recv(d), length);
                    break;
                case 3:
                    if(d->stage < dsSeenIHDR || d->stage > dsSeenIDAT || (d->stage == dsSeenIHDR && cbPaletted(d->cb)))
                    {
                        return chunkOrderError;
                    }
                    else
                    if(d->stage == dsSeenIDAT)
                    {
                        break;
                    }
                    d->stage = dsSeenIDAT;
                    if(configOnly)
                    {
                        return nullptr;
                    }
                    return rec::parseIDAT(gocpp::recv(d), length);
                    break;
                case 4:
                    if(d->stage != dsSeenIDAT)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeenIEND;
                    return rec::parseIEND(gocpp::recv(d), length);
                    break;
            }
        }
        if(length > 0x7fffffff)
        {
            return FormatError(mocklib::Sprintf("Bad chunk length: %d"s, length));
        }
        // Ignore this chunk (of a known length).
        gocpp::array<unsigned char, 4096> ignored = {};
        for(; length > 0; )
        {
            auto [n, err] = io::ReadFull(d->r, ignored.make_slice(0, gocpp::min(len(ignored), int(length))));
            if(err != nullptr)
            {
                return err;
            }
            rec::Write(gocpp::recv(d->crc), ignored.make_slice(0, n));
            length -= uint32_t(n);
        }
        return rec::verifyChecksum(gocpp::recv(d));
    }

    struct gocpp::error rec::verifyChecksum(struct decoder* d)
    {
        if(auto [gocpp_id_5, err] = io::ReadFull(d->r, d->tmp.make_slice(0, 4)); err != nullptr)
        {
            return err;
        }
        if(rec::Uint32(gocpp::recv(binary::BigEndian), d->tmp.make_slice(0, 4)) != rec::Sum32(gocpp::recv(d->crc)))
        {
            return FormatError("invalid checksum"s);
        }
        return nullptr;
    }

    struct gocpp::error rec::checkHeader(struct decoder* d)
    {
        auto [gocpp_id_6, err] = io::ReadFull(d->r, d->tmp.make_slice(0, len(pngHeader)));
        if(err != nullptr)
        {
            return err;
        }
        if(std::string(d->tmp.make_slice(0, len(pngHeader))) != pngHeader)
        {
            return FormatError("not a PNG file"s);
        }
        return nullptr;
    }

    // Decode reads a PNG image from r and returns it as an [image.Image].
    // The type of Image returned depends on the PNG contents.
    std::tuple<image::Image, struct gocpp::error> Decode(io::Reader r)
    {
        auto d = gocpp::InitPtr<decoder>([=](auto& x) {
            x.r = r;
            x.crc = crc32::NewIEEE();
        });
        if(auto err = rec::checkHeader(gocpp::recv(d)); err != nullptr)
        {
            if(err == io::go_EOF)
            {
                err = io::ErrUnexpectedEOF;
            }
            return {nullptr, err};
        }
        for(; d->stage != dsSeenIEND; )
        {
            if(auto err = rec::parseChunk(gocpp::recv(d), false); err != nullptr)
            {
                if(err == io::go_EOF)
                {
                    err = io::ErrUnexpectedEOF;
                }
                return {nullptr, err};
            }
        }
        return {d->img, nullptr};
    }

    // DecodeConfig returns the color model and dimensions of a PNG image without
    // decoding the entire image.
    std::tuple<image::Config, struct gocpp::error> DecodeConfig(io::Reader r)
    {
        auto d = gocpp::InitPtr<decoder>([=](auto& x) {
            x.r = r;
            x.crc = crc32::NewIEEE();
        });
        if(auto err = rec::checkHeader(gocpp::recv(d)); err != nullptr)
        {
            if(err == io::go_EOF)
            {
                err = io::ErrUnexpectedEOF;
            }
            return {image::Config {}, err};
        }
        for(; ; )
        {
            if(auto err = rec::parseChunk(gocpp::recv(d), true); err != nullptr)
            {
                if(err == io::go_EOF)
                {
                    err = io::ErrUnexpectedEOF;
                }
                return {image::Config {}, err};
            }
            if(cbPaletted(d->cb))
            {
                if(d->stage >= dsSeentRNS)
                {
                    break;
                }
            }
            else
            {
                if(d->stage >= dsSeenIHDR)
                {
                    break;
                }
            }
        }
        color::Model cm = {};
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbG1) { conditionId = 0; }
            else if(condition == cbG2) { conditionId = 1; }
            else if(condition == cbG4) { conditionId = 2; }
            else if(condition == cbG8) { conditionId = 3; }
            else if(condition == cbGA8) { conditionId = 4; }
            else if(condition == cbTC8) { conditionId = 5; }
            else if(condition == cbP1) { conditionId = 6; }
            else if(condition == cbP2) { conditionId = 7; }
            else if(condition == cbP4) { conditionId = 8; }
            else if(condition == cbP8) { conditionId = 9; }
            else if(condition == cbTCA8) { conditionId = 10; }
            else if(condition == cbG16) { conditionId = 11; }
            else if(condition == cbGA16) { conditionId = 12; }
            else if(condition == cbTC16) { conditionId = 13; }
            else if(condition == cbTCA16) { conditionId = 14; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    cm = color::GrayModel;
                    break;
                case 4:
                    cm = color::NRGBAModel;
                    break;
                case 5:
                    cm = color::RGBAModel;
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                    cm = d->palette;
                    break;
                case 10:
                    cm = color::NRGBAModel;
                    break;
                case 11:
                    cm = color::Gray16Model;
                    break;
                case 12:
                    cm = color::NRGBA64Model;
                    break;
                case 13:
                    cm = color::RGBA64Model;
                    break;
                case 14:
                    cm = color::NRGBA64Model;
                    break;
            }
        }
        return {gocpp::Init<image::Config>([=](auto& x) {
            x.ColorModel = cm;
            x.Width = d->width;
            x.Height = d->height;
        }), nullptr};
    }

    void init()
    {
        image::RegisterFormat("png"s, pngHeader, Decode, DecodeConfig);
    }

}

