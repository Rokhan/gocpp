// generated by GoCpp from file '$(ImportDir)/io/fs/fs.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/io/fs/fs.fwd.h"
#include "gocpp/support.h"

#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::fs
{
    struct FS : gocpp::Interface
    {
        FS(){}
        FS(FS& i) = default;
        FS(const FS& i) = default;
        FS& operator=(FS& i) = default;
        FS& operator=(const FS& i) = default;

        template<typename T>
        FS(T& ref);

        template<typename T>
        FS(const T& ref);

        template<typename T>
        FS(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IFS
        {
            virtual std::tuple<struct File, struct gocpp::error> vOpen(std::string name) = 0;
        };

        template<typename T, typename StoreT>
        struct FSImpl : IFS
        {
            explicit FSImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<struct File, struct gocpp::error> vOpen(std::string name) override;

            StoreT value;
        };

        std::shared_ptr<IFS> value;
    };

    std::tuple<struct File, struct gocpp::error> Open(const gocpp::PtrRecv<FS, false>& self, std::string name);
    std::tuple<struct File, struct gocpp::error> Open(const gocpp::ObjRecv<FS>& self, std::string name);

    std::ostream& operator<<(std::ostream& os, const struct FS& value);
    bool ValidPath(std::string name);
    struct File : gocpp::Interface
    {
        File(){}
        File(File& i) = default;
        File(const File& i) = default;
        File& operator=(File& i) = default;
        File& operator=(const File& i) = default;

        template<typename T>
        File(T& ref);

        template<typename T>
        File(const T& ref);

        template<typename T>
        File(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IFile
        {
            virtual std::tuple<struct FileInfo, struct gocpp::error> vStat() = 0;
            virtual std::tuple<int, struct gocpp::error> vRead(gocpp::slice<unsigned char>) = 0;
            virtual struct gocpp::error vClose() = 0;
        };

        template<typename T, typename StoreT>
        struct FileImpl : IFile
        {
            explicit FileImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<struct FileInfo, struct gocpp::error> vStat() override;

            std::tuple<int, struct gocpp::error> vRead(gocpp::slice<unsigned char>) override;

            struct gocpp::error vClose() override;

            StoreT value;
        };

        std::shared_ptr<IFile> value;
    };

    std::tuple<struct FileInfo, struct gocpp::error> Stat(const gocpp::PtrRecv<File, false>& self);
    std::tuple<struct FileInfo, struct gocpp::error> Stat(const gocpp::ObjRecv<File>& self);

    std::tuple<int, struct gocpp::error> Read(const gocpp::PtrRecv<File, false>& self, gocpp::slice<unsigned char>);
    std::tuple<int, struct gocpp::error> Read(const gocpp::ObjRecv<File>& self, gocpp::slice<unsigned char>);

    struct gocpp::error Close(const gocpp::PtrRecv<File, false>& self);
    struct gocpp::error Close(const gocpp::ObjRecv<File>& self);

    std::ostream& operator<<(std::ostream& os, const struct File& value);
    struct DirEntry : gocpp::Interface
    {
        DirEntry(){}
        DirEntry(DirEntry& i) = default;
        DirEntry(const DirEntry& i) = default;
        DirEntry& operator=(DirEntry& i) = default;
        DirEntry& operator=(const DirEntry& i) = default;

        template<typename T>
        DirEntry(T& ref);

        template<typename T>
        DirEntry(const T& ref);

        template<typename T>
        DirEntry(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IDirEntry
        {
            virtual std::string vName() = 0;
            virtual bool vIsDir() = 0;
            virtual FileMode vType() = 0;
            virtual std::tuple<struct FileInfo, struct gocpp::error> vInfo() = 0;
        };

        template<typename T, typename StoreT>
        struct DirEntryImpl : IDirEntry
        {
            explicit DirEntryImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vName() override;

            bool vIsDir() override;

            FileMode vType() override;

            std::tuple<struct FileInfo, struct gocpp::error> vInfo() override;

            StoreT value;
        };

        std::shared_ptr<IDirEntry> value;
    };

    std::string Name(const gocpp::PtrRecv<DirEntry, false>& self);
    std::string Name(const gocpp::ObjRecv<DirEntry>& self);

    bool IsDir(const gocpp::PtrRecv<DirEntry, false>& self);
    bool IsDir(const gocpp::ObjRecv<DirEntry>& self);

    FileMode Type(const gocpp::PtrRecv<DirEntry, false>& self);
    FileMode Type(const gocpp::ObjRecv<DirEntry>& self);

    std::tuple<struct FileInfo, struct gocpp::error> Info(const gocpp::PtrRecv<DirEntry, false>& self);
    std::tuple<struct FileInfo, struct gocpp::error> Info(const gocpp::ObjRecv<DirEntry>& self);

    std::ostream& operator<<(std::ostream& os, const struct DirEntry& value);
    struct ReadDirFile : gocpp::Interface
    {
        ReadDirFile(){}
        ReadDirFile(ReadDirFile& i) = default;
        ReadDirFile(const ReadDirFile& i) = default;
        ReadDirFile& operator=(ReadDirFile& i) = default;
        ReadDirFile& operator=(const ReadDirFile& i) = default;

        template<typename T>
        ReadDirFile(T& ref);

        template<typename T>
        ReadDirFile(const T& ref);

        template<typename T>
        ReadDirFile(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IReadDirFile
        {
            virtual std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> vReadDir(int n) = 0;
        };

        template<typename T, typename StoreT>
        struct ReadDirFileImpl : IReadDirFile
        {
            explicit ReadDirFileImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> vReadDir(int n) override;

            StoreT value;
        };

        std::shared_ptr<IReadDirFile> value;
    };

    std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDir(const gocpp::PtrRecv<ReadDirFile, false>& self, int n);
    std::tuple<gocpp::slice<DirEntry>, struct gocpp::error> ReadDir(const gocpp::ObjRecv<ReadDirFile>& self, int n);

    std::ostream& operator<<(std::ostream& os, const struct ReadDirFile& value);
    extern gocpp::error ErrInvalid;
    extern gocpp::error ErrPermission;
    extern gocpp::error ErrExist;
    extern gocpp::error ErrNotExist;
    extern gocpp::error ErrClosed;
    struct gocpp::error errInvalid();
    struct gocpp::error errPermission();
    struct gocpp::error errExist();
    struct gocpp::error errNotExist();
    struct gocpp::error errClosed();
    struct FileInfo : gocpp::Interface
    {
        FileInfo(){}
        FileInfo(FileInfo& i) = default;
        FileInfo(const FileInfo& i) = default;
        FileInfo& operator=(FileInfo& i) = default;
        FileInfo& operator=(const FileInfo& i) = default;

        template<typename T>
        FileInfo(T& ref);

        template<typename T>
        FileInfo(const T& ref);

        template<typename T>
        FileInfo(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IFileInfo
        {
            virtual std::string vName() = 0;
            virtual int64_t vSize() = 0;
            virtual FileMode vMode() = 0;
            virtual struct mocklib::Date vModTime() = 0;
            virtual bool vIsDir() = 0;
            virtual go_any vSys() = 0;
        };

        template<typename T, typename StoreT>
        struct FileInfoImpl : IFileInfo
        {
            explicit FileInfoImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vName() override;

            int64_t vSize() override;

            FileMode vMode() override;

            struct mocklib::Date vModTime() override;

            bool vIsDir() override;

            go_any vSys() override;

            StoreT value;
        };

        std::shared_ptr<IFileInfo> value;
    };

    std::string Name(const gocpp::PtrRecv<FileInfo, false>& self);
    std::string Name(const gocpp::ObjRecv<FileInfo>& self);

    int64_t Size(const gocpp::PtrRecv<FileInfo, false>& self);
    int64_t Size(const gocpp::ObjRecv<FileInfo>& self);

    FileMode Mode(const gocpp::PtrRecv<FileInfo, false>& self);
    FileMode Mode(const gocpp::ObjRecv<FileInfo>& self);

    struct mocklib::Date ModTime(const gocpp::PtrRecv<FileInfo, false>& self);
    struct mocklib::Date ModTime(const gocpp::ObjRecv<FileInfo>& self);

    bool IsDir(const gocpp::PtrRecv<FileInfo, false>& self);
    bool IsDir(const gocpp::ObjRecv<FileInfo>& self);

    go_any Sys(const gocpp::PtrRecv<FileInfo, false>& self);
    go_any Sys(const gocpp::ObjRecv<FileInfo>& self);

    std::ostream& operator<<(std::ostream& os, const struct FileInfo& value);
    std::string String(FileMode m);
    bool IsDir(FileMode m);
    bool IsRegular(FileMode m);
    FileMode Perm(FileMode m);
    FileMode Type(FileMode m);
    struct PathError
    {
        std::string Op;
        std::string Path;
        gocpp::error Err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct PathError& value);
    std::string Error(struct PathError* e);
    struct gocpp::error Unwrap(struct PathError* e);
    bool Timeout(struct PathError* e);
    struct gocpp_id_0 : gocpp::Interface
    {
        gocpp_id_0(){}
        gocpp_id_0(gocpp_id_0& i) = default;
        gocpp_id_0(const gocpp_id_0& i) = default;
        gocpp_id_0& operator=(gocpp_id_0& i) = default;
        gocpp_id_0& operator=(const gocpp_id_0& i) = default;

        template<typename T>
        gocpp_id_0(T& ref);

        template<typename T>
        gocpp_id_0(const T& ref);

        template<typename T>
        gocpp_id_0(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_0
        {
            virtual bool vTimeout() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_0Impl : Igocpp_id_0
        {
            explicit gocpp_id_0Impl(T* ptr)
            {
                value.reset(ptr);
            }

            bool vTimeout() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_0> value;
    };

    bool Timeout(const gocpp::PtrRecv<gocpp_id_0, false>& self);
    bool Timeout(const gocpp::ObjRecv<gocpp_id_0>& self);

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
}

