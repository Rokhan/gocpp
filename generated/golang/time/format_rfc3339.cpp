// generated by GoCpp from file '$(ImportDir)/time/format_rfc3339.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/format_rfc3339.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/time/format.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    gocpp::slice<unsigned char> rec::appendFormatRFC3339(struct Time t, gocpp::slice<unsigned char> b, bool nanos)
    {
        auto [gocpp_id_1, offset, abs] = rec::locabs(gocpp::recv(t));
        auto [year, month, day, gocpp_id_3] = absDate(abs, true);
        b = appendInt(b, year, 4);
        b = append(b, '-');
        b = appendInt(b, int(month), 2);
        b = append(b, '-');
        b = appendInt(b, day, 2);
        b = append(b, 'T');
        auto [hour, min, sec] = absClock(abs);
        b = appendInt(b, hour, 2);
        b = append(b, ':');
        b = appendInt(b, min, 2);
        b = append(b, ':');
        b = appendInt(b, sec, 2);
        if(nanos)
        {
            auto std = stdFracSecond(stdFracSecond9, 9, '.');
            b = appendNano(b, rec::Nanosecond(gocpp::recv(t)), std);
        }
        if(offset == 0)
        {
            return append(b, 'Z');
        }
        auto zone = offset / 60;
        if(zone < 0)
        {
            b = append(b, '-');
            zone = - zone;
        }
        else
        {
            b = append(b, '+');
        }
        b = appendInt(b, zone / 60, 2);
        b = append(b, ':');
        b = appendInt(b, zone % 60, 2);
        return b;
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::appendStrictRFC3339(struct Time t, gocpp::slice<unsigned char> b)
    {
        auto n0 = len(b);
        b = rec::appendFormatRFC3339(gocpp::recv(t), b, true);
        auto num2 = [=](gocpp::slice<unsigned char> b) mutable -> unsigned char
        {
            return 10 * (b[0] - '0') + (b[1] - '0');
        };
        //Go switch emulation
        {
            int conditionId = -1;
            if(b[n0 + len("9999"s)] != '-') { conditionId = 0; }
            else if(b[len(b) - 1] != 'Z') { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return {b, errors::New("year outside of range [0,9999]"s)};
                    break;
                case 1:
                    auto c = b[len(b) - len("Z07:00"s)];
                    if(('0' <= c && c <= '9') || num2(b.make_slice(len(b) - len("07:00"s))) >= 24)
                    {
                        return {b, errors::New("timezone hour outside of range [0,23]"s)};
                    }
                    break;
            }
        }
        return {b, nullptr};
    }


    template<typename bytes>
    std::tuple<struct Time, bool> parseRFC3339(bytes s, struct Location* local)
    {
        auto ok = true;
        auto parseUint = [=](bytes s, int min, int max) mutable -> int
        {
            int x;
            for(auto [gocpp_ignored, c] : gocpp::slice<unsigned char>(s))
            {
                if(c < '0' || '9' < c)
                {
                    ok = false;
                    return min;
                }
                x = x * 10 + int(c) - '0';
            }
            if(x < min || max < x)
            {
                ok = false;
                return min;
            }
            return x;
        };
        if(len(s) < len("2006-01-02T15:04:05"s))
        {
            return {Time {}, false};
        }
        auto year = parseUint(s.make_slice(0, 4), 0, 9999);
        auto month = parseUint(s.make_slice(5, 7), 1, 12);
        auto day = parseUint(s.make_slice(8, 10), 1, daysIn(Month(month), year));
        auto hour = parseUint(s.make_slice(11, 13), 0, 23);
        auto min = parseUint(s.make_slice(14, 16), 0, 59);
        auto sec = parseUint(s.make_slice(17, 19), 0, 59);
        if(! ok || ! (s[4] == '-' && s[7] == '-' && s[10] == 'T' && s[13] == ':' && s[16] == ':'))
        {
            return {Time {}, false};
        }
        s = s.make_slice(19);
        int nsec = {};
        if(len(s) >= 2 && s[0] == '.' && isDigit(s, 1))
        {
            auto n = 2;
            for(; n < len(s) && isDigit(s, n); n++)
            {
            }
            std::tie(nsec, gocpp_id_4, gocpp_id_5) = parseNanoseconds(s, n);
            s = s.make_slice(n);
        }
        auto t = Date(year, Month(month), day, hour, min, sec, nsec, UTC);
        if(len(s) != 1 || s[0] != 'Z')
        {
            if(len(s) != len("-07:00"s))
            {
                return {Time {}, false};
            }
            auto hr = parseUint(s.make_slice(1, 3), 0, 23);
            auto mm = parseUint(s.make_slice(4, 6), 0, 59);
            if(! ok || ! ((s[0] == '-' || s[0] == '+') && s[3] == ':'))
            {
                return {Time {}, false};
            }
            auto zoneOffset = (hr * 60 + mm) * 60;
            if(s[0] == '-')
            {
                zoneOffset *= - 1;
            }
            rec::addSec(gocpp::recv(t), - int64_t(zoneOffset));
            if(auto [gocpp_id_10, offset, gocpp_id_11, gocpp_id_12, gocpp_id_13] = rec::lookup(gocpp::recv(local), rec::unixSec(gocpp::recv(t))); offset == zoneOffset)
            {
                rec::setLoc(gocpp::recv(t), local);
            }
            else
            {
                rec::setLoc(gocpp::recv(t), FixedZone(""s, zoneOffset));
            }
        }
        return {t, true};
    }

    std::tuple<struct Time, struct gocpp::error> parseStrictRFC3339(gocpp::slice<unsigned char> b)
    {
        auto [t, ok] = parseRFC3339(b, Local);
        if(! ok)
        {
            auto [t, err] = Parse(RFC3339, std::string(b));
            if(err != nullptr)
            {
                return {Time {}, err};
            }
            auto num2 = [=](gocpp::slice<unsigned char> b) mutable -> unsigned char
            {
                return 10 * (b[0] - '0') + (b[1] - '0');
            };
            //Go switch emulation
            {
                int conditionId = -1;
                if(true) { conditionId = 0; }
                else if(b[len("2006-01-02T"s) + 1] == ':') { conditionId = 1; }
                else if(b[len("2006-01-02T15:04:05"s)] == ',') { conditionId = 2; }
                else if(b[len(b) - 1] != 'Z') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        return {t, nullptr};
                        break;
                    case 1:
                        return {Time {}, new ParseError {RFC3339, std::string(b), "15"s, std::string(b.make_slice(len("2006-01-02T"s)).make_slice(0, 1)), ""s}};
                        break;
                    case 2:
                        return {Time {}, new ParseError {RFC3339, std::string(b), "."s, ","s, ""s}};
                        break;
                    case 3:
                        //Go switch emulation
                        {
                            int conditionId = -1;
                            if(num2(b.make_slice(len(b) - len("07:00"s))) >= 24) { conditionId = 0; }
                            else if(num2(b.make_slice(len(b) - len("00"s))) >= 60) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    return {Time {}, new ParseError {RFC3339, std::string(b), "Z07:00"s, std::string(b.make_slice(len(b) - len("Z07:00"s))), ": timezone hour out of range"s}};
                                    break;
                                case 1:
                                    return {Time {}, new ParseError {RFC3339, std::string(b), "Z07:00"s, std::string(b.make_slice(len(b) - len("Z07:00"s))), ": timezone minute out of range"s}};
                                    break;
                            }
                        }
                        break;
                    default:
                        return {Time {}, new ParseError {RFC3339, std::string(b), RFC3339, std::string(b), ""s}};
                        break;
                }
            }
        }
        return {t, nullptr};
    }

}

