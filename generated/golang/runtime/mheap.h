// generated by GoCpp from file '$(ImportDir)/runtime/mheap.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mheap.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    extern bool physPageAlignedStacks;
    struct gocpp_id_0
    {
        uintptr_t base;
        uintptr_t end;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    struct gocpp_id_1
    {
        mcentral mcentral;
        gocpp::array<unsigned char, (cpu::CacheLinePadSize - gocpp::Sizeof<runtime::mcentral>() % cpu::CacheLinePadSize) % cpu::CacheLinePadSize> pad;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value);
    struct heapArena
    {
        sys::NotInHeap _1;
        heapArenaPtrScalar heapArenaPtrScalar;
        gocpp::array<mspan*, pagesPerArena> spans;
        gocpp::array<uint8_t, pagesPerArena / 8> pageInUse;
        gocpp::array<uint8_t, pagesPerArena / 8> pageMarks;
        gocpp::array<uint8_t, pagesPerArena / 8> pageSpecials;
        checkmarksMap* checkmarks;
        uintptr_t zeroedBase;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heapArena& value);
    struct arenaHint
    {
        sys::NotInHeap _1;
        uintptr_t addr;
        bool down;
        arenaHint* next;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct arenaHint& value);
    extern gocpp::slice<gocpp::string> mSpanStateNames;
    struct mSpanStateBox
    {
        atomic::Uint8 s;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mSpanStateBox& value);
    struct mSpanList
    {
        sys::NotInHeap _1;
        mspan* first;
        mspan* last;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mSpanList& value);
    void recordspan(unsafe::Pointer vh, unsafe::Pointer p);
    runtime::spanClass makeSpanClass(uint8_t sizeclass, bool noscan);
    runtime::arenaIdx arenaIndex(uintptr_t p);
    uintptr_t arenaBase(golang::runtime::arenaIdx i);
    bool inheap(uintptr_t b);
    bool inHeapOrStack(uintptr_t b);
    struct mspan* spanOf(uintptr_t p);
    struct mspan* spanOfUnchecked(uintptr_t p);
    struct mspan* spanOfHeap(uintptr_t p);
    std::tuple<struct heapArena*, uintptr_t, uint8_t> pageIndexOf(uintptr_t p);
    void runtime_debug_freeOSMemory();
    struct special
    {
        sys::NotInHeap _1;
        special* next;
        uint16_t offset;
        unsigned char kind;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct special& value);
    void spanHasSpecials(struct mspan* s);
    void spanHasNoSpecials(struct mspan* s);
    bool addspecial(unsafe::Pointer p, struct special* s);
    struct special* removespecial(unsafe::Pointer p, uint8_t kind);
    bool addfinalizer(unsafe::Pointer p, struct funcval* f, uintptr_t nret, golang::runtime::_type* fint, golang::runtime::ptrtype* ot);
    void removefinalizer(unsafe::Pointer p);
    void setprofilebucket(unsafe::Pointer p, struct bucket* b);
    struct specialsIter
    {
        special** pprev;
        special* s;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct specialsIter& value);
    struct specialsIter newSpecialsIter(struct mspan* span);
    void freeSpecial(struct special* s, unsafe::Pointer p, uintptr_t size);
    struct gcBits
    {
        sys::NotInHeap _1;
        uint8_t x;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcBits& value);
    struct gcBitsHeader
    {
        uintptr_t free;
        uintptr_t next;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcBitsHeader& value);
    struct gcBits* newMarkBits(uintptr_t nelems);
    struct gcBits* newAllocBits(uintptr_t nelems);
    void nextMarkBitArenaEpoch();
    struct gcBitsArena* newArenaMayUnlock();
    struct gocpp_id_2
    {
        arenaHint* arenaHints;
        mSpanList quarantineList;
        mSpanList readyList;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value);
    struct mspan
    {
        sys::NotInHeap _1;
        mspan* next;
        mspan* prev;
        mSpanList* list;
        uintptr_t startAddr;
        uintptr_t npages;
        golang::runtime::gclinkptr manualFreeList;
        uint16_t freeindex;
        uint16_t nelems;
        uint16_t freeIndexForScan;
        uint64_t allocCache;
        gcBits* allocBits;
        gcBits* gcmarkBits;
        gcBits* pinnerBits;
        uint32_t sweepgen;
        uint32_t divMul;
        uint16_t allocCount;
        golang::runtime::spanClass spanclass;
        mSpanStateBox state;
        uint8_t needzero;
        bool isUserArenaChunk;
        uint16_t allocCountBeforeCache;
        uintptr_t elemsize;
        uintptr_t limit;
        mutex speciallock;
        special* specials;
        addrRange userArenaChunkFree;
        golang::runtime::_type* largeType;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mspan& value);
    struct specialfinalizer
    {
        sys::NotInHeap _1;
        special special;
        funcval* fn;
        uintptr_t nret;
        golang::runtime::_type* fint;
        golang::runtime::ptrtype* ot;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct specialfinalizer& value);
    struct specialprofile
    {
        sys::NotInHeap _1;
        special special;
        bucket* b;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct specialprofile& value);
    struct specialReachable
    {
        special special;
        bool done;
        bool reachable;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct specialReachable& value);
    struct specialPinCounter
    {
        special special;
        uintptr_t counter;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct specialPinCounter& value);
    struct gcBitsArena
    {
        sys::NotInHeap _1;
        uintptr_t free;
        gcBitsArena* next;
        /* gocpp::array<gcBits, gcBitsChunkBytes - gcBitsHeaderBytes> bits; [Known incomplete type] */

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcBitsArena& value);
    struct mheap
    {
        sys::NotInHeap _1;
        mutex lock;
        pageAlloc pages;
        uint32_t sweepgen;
        gocpp::slice<mspan*> allspans;
        atomic::Uintptr pagesInUse;
        atomic::Uint64 pagesSwept;
        atomic::Uint64 pagesSweptBasis;
        uint64_t sweepHeapLiveBasis;
        double sweepPagesPerByte;
        atomic::Uint64 reclaimIndex;
        atomic::Uintptr reclaimCredit;
        cpu::CacheLinePad _2;
        gocpp::array<gocpp::array<heapArena*, 1 << arenaL2Bits>*, 1 << arenaL1Bits> arenas;
        bool arenasHugePages;
        linearAlloc heapArenaAlloc;
        arenaHint* arenaHints;
        linearAlloc arena;
        gocpp::slice<golang::runtime::arenaIdx> allArenas;
        gocpp::slice<golang::runtime::arenaIdx> sweepArenas;
        gocpp::slice<golang::runtime::arenaIdx> markArenas;
        gocpp_id_0 curArena;
        gocpp::array<gocpp_id_1, numSpanClasses> central;
        fixalloc spanalloc;
        fixalloc cachealloc;
        fixalloc specialfinalizeralloc;
        fixalloc specialprofilealloc;
        fixalloc specialReachableAlloc;
        fixalloc specialPinCounterAlloc;
        mutex speciallock;
        fixalloc arenaHintAlloc;
        gocpp_id_2 userArena;
        specialfinalizer* unused;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mheap& value);
    extern gocpp_id_6 gcBitsArenas;
    extern mheap mheap_;

    namespace rec
    {
        void set(struct mSpanStateBox* b, golang::runtime::mSpanState s);
        runtime::mSpanState get(struct mSpanStateBox* b);
        uintptr_t base(struct mspan* s);
        std::tuple<uintptr_t, uintptr_t, uintptr_t> layout(struct mspan* s);
        int8_t sizeclass(golang::runtime::spanClass sc);
        bool noscan(golang::runtime::spanClass sc);
        unsigned int l1(golang::runtime::arenaIdx i);
        unsigned int l2(golang::runtime::arenaIdx i);
        void init(struct mheap* h);
        void reclaim(struct mheap* h, uintptr_t npage);
        uintptr_t reclaimChunk(struct mheap* h, gocpp::slice<golang::runtime::arenaIdx> arenas, uintptr_t pageIdx, uintptr_t n);
        bool manual(golang::runtime::spanAllocType s);
        struct mspan* alloc(struct mheap* h, uintptr_t npages, golang::runtime::spanClass spanclass);
        struct mspan* allocManual(struct mheap* h, uintptr_t npages, golang::runtime::spanAllocType typ);
        void setSpans(struct mheap* h, uintptr_t base, uintptr_t npage, struct mspan* s);
        bool allocNeedsZero(struct mheap* h, uintptr_t base, uintptr_t npage);
        struct mspan* tryAllocMSpan(struct mheap* h);
        struct mspan* allocMSpanLocked(struct mheap* h);
        void freeMSpanLocked(struct mheap* h, struct mspan* s);
        struct mspan* allocSpan(struct mheap* h, uintptr_t npages, golang::runtime::spanAllocType typ, golang::runtime::spanClass spanclass);
        void initSpan(struct mheap* h, struct mspan* s, golang::runtime::spanAllocType typ, golang::runtime::spanClass spanclass, uintptr_t base, uintptr_t npages);
        std::tuple<uintptr_t, bool> grow(struct mheap* h, uintptr_t npage);
        void freeSpan(struct mheap* h, struct mspan* s);
        void freeManual(struct mheap* h, struct mspan* s, golang::runtime::spanAllocType typ);
        void freeSpanLocked(struct mheap* h, struct mspan* s, golang::runtime::spanAllocType typ);
        void scavengeAll(struct mheap* h);
        void init(struct mspan* span, uintptr_t base, uintptr_t npages);
        bool inList(struct mspan* span);
        void init(struct mSpanList* list);
        void remove(struct mSpanList* list, struct mspan* span);
        bool isEmpty(struct mSpanList* list);
        void insert(struct mSpanList* list, struct mspan* span);
        void insertBack(struct mSpanList* list, struct mspan* span);
        void takeAll(struct mSpanList* list, struct mSpanList* other);
        std::tuple<struct special**, bool> specialFindSplicePoint(struct mspan* span, uintptr_t offset, unsigned char kind);
        bool valid(struct specialsIter* i);
        void next(struct specialsIter* i);
        struct special* unlinkAndNext(struct specialsIter* i);
        uint8_t* bytep(struct gcBits* b, uintptr_t n);
        std::tuple<uint8_t*, uint8_t> bitp(struct gcBits* b, uintptr_t n);
        struct gcBits* tryAlloc(struct gcBitsArena* b, uintptr_t bytes);
    }
}

