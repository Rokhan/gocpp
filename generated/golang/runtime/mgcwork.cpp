// generated by GoCpp from file '$(ImportDir)/runtime/mgcwork.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcwork.h"
#include "gocpp/support.h"

#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    void init()
    {
        if(workbufAlloc % pageSize != 0 || workbufAlloc % _WorkbufSize != 0)
        {
            go_throw("bad workbufAlloc");
        }
    }

    
    std::ostream& gcWork::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wbuf1;
        os << " " << wbuf2;
        os << " " << bytesMarked;
        os << " " << heapScanWork;
        os << " " << flushedWork;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcWork& value)
    {
        return value.PrintTo(os);
    }

    void init(struct gcWork* w)
    {
        w->wbuf1 = getempty();
        auto wbuf2 = trygetfull();
        if(wbuf2 == nullptr)
        {
            wbuf2 = getempty();
        }
        w->wbuf2 = wbuf2;
    }

    void put(struct gcWork* w, uintptr_t obj)
    {
        auto flushed = false;
        auto wbuf = w->wbuf1;
        lockWithRankMayAcquire(& work.wbufSpans.lock, lockRankWbufSpans);
        lockWithRankMayAcquire(& mheap_.lock, lockRankMheap);
        if(wbuf == nullptr)
        {
            init(gocpp::recv(w));
            wbuf = w->wbuf1;
        }
        else
        if(wbuf->nobj == len(wbuf->obj))
        {
            std::tie(w->wbuf1, w->wbuf2) = std::tuple{w->wbuf2, w->wbuf1};
            wbuf = w->wbuf1;
            if(wbuf->nobj == len(wbuf->obj))
            {
                putfull(wbuf);
                w->flushedWork = true;
                wbuf = getempty();
                w->wbuf1 = wbuf;
                flushed = true;
            }
        }
        wbuf->obj[wbuf->nobj] = obj;
        wbuf->nobj++;
        if(flushed && gcphase == _GCmark)
        {
            enlistWorker(gocpp::recv(gcController));
        }
    }

    bool putFast(struct gcWork* w, uintptr_t obj)
    {
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr || wbuf->nobj == len(wbuf->obj))
        {
            return false;
        }
        wbuf->obj[wbuf->nobj] = obj;
        wbuf->nobj++;
        return true;
    }

    void putBatch(struct gcWork* w, gocpp::slice<uintptr_t> obj)
    {
        if(len(obj) == 0)
        {
            return;
        }
        auto flushed = false;
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr)
        {
            init(gocpp::recv(w));
            wbuf = w->wbuf1;
        }
        for(; len(obj) > 0; )
        {
            for(; wbuf->nobj == len(wbuf->obj); )
            {
                putfull(wbuf);
                w->flushedWork = true;
                std::tie(w->wbuf1, w->wbuf2) = std::tuple{w->wbuf2, getempty()};
                wbuf = w->wbuf1;
                flushed = true;
            }
            auto n = copy(wbuf->obj.make_slice(wbuf->nobj), obj);
            wbuf->nobj += n;
            obj = obj.make_slice(n);
        }
        if(flushed && gcphase == _GCmark)
        {
            enlistWorker(gocpp::recv(gcController));
        }
    }

    uintptr_t tryGet(struct gcWork* w)
    {
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr)
        {
            init(gocpp::recv(w));
            wbuf = w->wbuf1;
        }
        if(wbuf->nobj == 0)
        {
            std::tie(w->wbuf1, w->wbuf2) = std::tuple{w->wbuf2, w->wbuf1};
            wbuf = w->wbuf1;
            if(wbuf->nobj == 0)
            {
                auto owbuf = wbuf;
                wbuf = trygetfull();
                if(wbuf == nullptr)
                {
                    return 0;
                }
                putempty(owbuf);
                w->wbuf1 = wbuf;
            }
        }
        wbuf->nobj--;
        return wbuf->obj[wbuf->nobj];
    }

    uintptr_t tryGetFast(struct gcWork* w)
    {
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr || wbuf->nobj == 0)
        {
            return 0;
        }
        wbuf->nobj--;
        return wbuf->obj[wbuf->nobj];
    }

    void dispose(struct gcWork* w)
    {
        if(auto wbuf = w->wbuf1; wbuf != nullptr)
        {
            if(wbuf->nobj == 0)
            {
                putempty(wbuf);
            }
            else
            {
                putfull(wbuf);
                w->flushedWork = true;
            }
            w->wbuf1 = nullptr;
            wbuf = w->wbuf2;
            if(wbuf->nobj == 0)
            {
                putempty(wbuf);
            }
            else
            {
                putfull(wbuf);
                w->flushedWork = true;
            }
            w->wbuf2 = nullptr;
        }
        if(w->bytesMarked != 0)
        {
            atomic::Xadd64(& work.bytesMarked, int64_t(w->bytesMarked));
            w->bytesMarked = 0;
        }
        if(w->heapScanWork != 0)
        {
            Add(gocpp::recv(gcController.heapScanWork), w->heapScanWork);
            w->heapScanWork = 0;
        }
    }

    void balance(struct gcWork* w)
    {
        if(w->wbuf1 == nullptr)
        {
            return;
        }
        if(auto wbuf = w->wbuf2; wbuf->nobj != 0)
        {
            putfull(wbuf);
            w->flushedWork = true;
            w->wbuf2 = getempty();
        }
        else
        if(auto wbuf = w->wbuf1; wbuf->nobj > 4)
        {
            w->wbuf1 = handoff(wbuf);
            w->flushedWork = true;
        }
        else
        {
            return;
        }
        if(gcphase == _GCmark)
        {
            enlistWorker(gocpp::recv(gcController));
        }
    }

    bool empty(struct gcWork* w)
    {
        return w->wbuf1 == nullptr || (w->wbuf1->nobj == 0 && w->wbuf2->nobj == 0);
    }

    
    std::ostream& workbufhdr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << node;
        os << " " << nobj;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct workbufhdr& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& workbuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << obj;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct workbuf& value)
    {
        return value.PrintTo(os);
    }

    void checknonempty(struct workbuf* b)
    {
        if(b->nobj == 0)
        {
            go_throw("workbuf is empty");
        }
    }

    void checkempty(struct workbuf* b)
    {
        if(b->nobj != 0)
        {
            go_throw("workbuf is not empty");
        }
    }

    workbuf* getempty()
    {
        workbuf* b = {};
        if(work.empty != 0)
        {
            b = (workbuf*)(pop(gocpp::recv(work.empty)));
            if(b != nullptr)
            {
                checkempty(gocpp::recv(b));
            }
        }
        lockWithRankMayAcquire(& work.wbufSpans.lock, lockRankWbufSpans);
        lockWithRankMayAcquire(& mheap_.lock, lockRankMheap);
        if(b == nullptr)
        {
            mspan* s = {};
            if(work.wbufSpans.free.first != nullptr)
            {
                lock(& work.wbufSpans.lock);
                s = work.wbufSpans.free.first;
                if(s != nullptr)
                {
                    remove(gocpp::recv(work.wbufSpans.free), s);
                    insert(gocpp::recv(work.wbufSpans.busy), s);
                }
                unlock(& work.wbufSpans.lock);
            }
            if(s == nullptr)
            {
                systemstack([=]() mutable -> void
                {
                    s = allocManual(gocpp::recv(mheap_), workbufAlloc / pageSize, spanAllocWorkBuf);
                }
);
                if(s == nullptr)
                {
                    go_throw("out of memory");
                }
                lock(& work.wbufSpans.lock);
                insert(gocpp::recv(work.wbufSpans.busy), s);
                unlock(& work.wbufSpans.lock);
            }
            for(auto i = uintptr_t(0); i + _WorkbufSize <= workbufAlloc; i += _WorkbufSize)
            {
                auto newb = (workbuf*)(unsafe::Pointer(base(gocpp::recv(s)) + i));
                newb->nobj = 0;
                lfnodeValidate(& newb->node);
                if(i == 0)
                {
                    b = newb;
                }
                else
                {
                    putempty(newb);
                }
            }
        }
        return b;
    }

    void putempty(workbuf* b)
    {
        checkempty(gocpp::recv(b));
        push(gocpp::recv(work.empty), & b->node);
    }

    void putfull(workbuf* b)
    {
        checknonempty(gocpp::recv(b));
        push(gocpp::recv(work.full), & b->node);
    }

    workbuf* trygetfull()
    {
        auto b = (workbuf*)(pop(gocpp::recv(work.full)));
        if(b != nullptr)
        {
            checknonempty(gocpp::recv(b));
            return b;
        }
        return b;
    }

    workbuf* handoff(workbuf* b)
    {
        auto b1 = getempty();
        auto n = b->nobj / 2;
        b->nobj -= n;
        b1->nobj = n;
        memmove(unsafe::Pointer(& b1->obj[0]), unsafe::Pointer(& b->obj[b->nobj]), uintptr_t(n) * unsafe::Sizeof(b1->obj[0]));
        putfull(b);
        return b1;
    }

    void prepareFreeWorkbufs()
    {
        lock(& work.wbufSpans.lock);
        if(work.full != 0)
        {
            go_throw("cannot free workbufs when work.full != 0");
        }
        work.empty = 0;
        takeAll(gocpp::recv(work.wbufSpans.free), & work.wbufSpans.busy);
        unlock(& work.wbufSpans.lock);
    }

    bool freeSomeWbufs(bool preemptible)
    {
        auto batchSize = 64;
        lock(& work.wbufSpans.lock);
        if(gcphase != _GCoff || isEmpty(gocpp::recv(work.wbufSpans.free)))
        {
            unlock(& work.wbufSpans.lock);
            return false;
        }
        systemstack([=]() mutable -> void
        {
            auto gp = getg()->m->curg;
            for(auto i = 0; i < batchSize && ! (preemptible && gp->preempt); i++)
            {
                auto span = work.wbufSpans.free.first;
                if(span == nullptr)
                {
                    break;
                }
                remove(gocpp::recv(work.wbufSpans.free), span);
                freeManual(gocpp::recv(mheap_), span, spanAllocWorkBuf);
            }
        }
);
        auto more = ! isEmpty(gocpp::recv(work.wbufSpans.free));
        unlock(& work.wbufSpans.lock);
        return more;
    }

}

