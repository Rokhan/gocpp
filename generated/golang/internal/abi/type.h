// generated by GoCpp from file '$(ImportDir)/internal/abi/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/type.fwd.h"
#include "gocpp/support.h"


namespace golang::abi
{
    struct Type
    {
        uintptr_t Size_;
        uintptr_t PtrBytes;
        uint32_t Hash;
        golang::abi::TFlag TFlag;
        uint8_t Align_;
        uint8_t FieldAlign_;
        uint8_t Kind_;
        std::function<bool (unsafe::Pointer _1, unsafe::Pointer _2)> Equal;
        unsigned char* GCData;
        golang::abi::NameOff Str;
        golang::abi::TypeOff PtrToThis;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    extern gocpp::slice<gocpp::string> kindNames;
    struct Method
    {
        golang::abi::NameOff Name;
        golang::abi::TypeOff Mtyp;
        golang::abi::TextOff Ifn;
        golang::abi::TextOff Tfn;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Method& value);
    struct UncommonType
    {
        golang::abi::NameOff PkgPath;
        uint16_t Mcount;
        uint16_t Xcount;
        uint32_t Moff;
        uint32_t _1;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct UncommonType& value);
    unsafe::Pointer addChecked(unsafe::Pointer p, uintptr_t x, gocpp::string whySafe);
    struct Imethod
    {
        golang::abi::NameOff Name;
        golang::abi::TypeOff Typ;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Imethod& value);
    struct Name
    {
        unsigned char* Bytes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Name& value);
    int writeVarint(gocpp::slice<unsigned char> buf, int n);
    struct Name NewName(gocpp::string n, gocpp::string tag, bool exported, bool embedded);
    struct ArrayType
    {
        Type Type;
        golang::abi::Type* Elem;
        golang::abi::Type* Slice;
        uintptr_t Len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ArrayType& value);
    struct ChanType
    {
        Type Type;
        golang::abi::Type* Elem;
        golang::abi::ChanDir Dir;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ChanType& value);
    struct InterfaceType
    {
        Type Type;
        Name PkgPath;
        gocpp::slice<Imethod> Methods;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct InterfaceType& value);
    struct MapType
    {
        Type Type;
        golang::abi::Type* Key;
        golang::abi::Type* Elem;
        golang::abi::Type* Bucket;
        std::function<uintptr_t (unsafe::Pointer _1, uintptr_t _2)> Hasher;
        uint8_t KeySize;
        uint8_t ValueSize;
        uint16_t BucketSize;
        uint32_t Flags;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MapType& value);
    struct SliceType
    {
        Type Type;
        golang::abi::Type* Elem;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SliceType& value);
    struct FuncType
    {
        Type Type;
        uint16_t InCount;
        uint16_t OutCount;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct FuncType& value);
    struct PtrType
    {
        Type Type;
        golang::abi::Type* Elem;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct PtrType& value);
    struct StructField
    {
        Name Name;
        Type* Typ;
        uintptr_t Offset;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructField& value);
    struct StructType
    {
        Type Type;
        Name PkgPath;
        gocpp::slice<StructField> Fields;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructType& value);
    struct structTypeUncommon
    {
        StructType StructType;
        UncommonType u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value);

    namespace rec
    {
        gocpp::string String(golang::abi::Kind k);
        abi::Kind Kind(golang::abi::Type* t);
        bool HasName(golang::abi::Type* t);
        bool Pointers(golang::abi::Type* t);
        bool IfaceIndir(golang::abi::Type* t);
        bool IsDirectIface(golang::abi::Type* t);
        gocpp::slice<unsigned char> GcSlice(golang::abi::Type* t, uintptr_t begin, uintptr_t end);
        gocpp::slice<Method> Methods(golang::abi::UncommonType* t);
        gocpp::slice<Method> ExportedMethods(golang::abi::UncommonType* t);
        int Len(golang::abi::Type* t);
        struct Type* Common(golang::abi::Type* t);
        abi::ChanDir ChanDir(golang::abi::Type* t);
        struct UncommonType* Uncommon(golang::abi::Type* t);
        struct Type* Elem(golang::abi::Type* t);
        struct StructType* StructType(golang::abi::Type* t);
        struct MapType* MapType(golang::abi::Type* t);
        struct ArrayType* ArrayType(golang::abi::Type* t);
        struct FuncType* FuncType(golang::abi::Type* t);
        struct InterfaceType* InterfaceType(golang::abi::Type* t);
        uintptr_t Size(golang::abi::Type* t);
        int Align(golang::abi::Type* t);
        int FieldAlign(golang::abi::Type* t);
        gocpp::slice<Method> ExportedMethods(golang::abi::Type* t);
        int NumMethod(golang::abi::Type* t);
        int NumMethod(golang::abi::InterfaceType* t);
        bool IndirectKey(golang::abi::MapType* mt);
        bool IndirectElem(golang::abi::MapType* mt);
        bool ReflexiveKey(golang::abi::MapType* mt);
        bool NeedKeyUpdate(golang::abi::MapType* mt);
        bool HashMightPanic(golang::abi::MapType* mt);
        struct Type* Key(golang::abi::Type* t);
        struct Type* In(golang::abi::FuncType* t, int i);
        int NumIn(golang::abi::FuncType* t);
        int NumOut(golang::abi::FuncType* t);
        struct Type* Out(golang::abi::FuncType* t, int i);
        gocpp::slice<Type*> InSlice(golang::abi::FuncType* t);
        gocpp::slice<Type*> OutSlice(golang::abi::FuncType* t);
        bool IsVariadic(golang::abi::FuncType* t);
        bool Embedded(golang::abi::StructField* f);
        unsigned char* DataChecked(golang::abi::Name n, int off, gocpp::string whySafe);
        unsigned char* Data(golang::abi::Name n, int off);
        bool IsExported(golang::abi::Name n);
        bool HasTag(golang::abi::Name n);
        bool IsEmbedded(golang::abi::Name n);
        std::tuple<int, int> ReadVarint(golang::abi::Name n, int off);
        bool IsBlank(golang::abi::Name n);
        gocpp::string Name(golang::abi::Name n);
        gocpp::string Tag(golang::abi::Name n);
    }
}

