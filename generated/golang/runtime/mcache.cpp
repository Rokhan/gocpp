// generated by GoCpp from file '$(ImportDir)/runtime/mcache.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mcache.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcsweep.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mspanset.h"
// #include "golang/runtime/mstats.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/sizeclasses.h"  [Ignored, known errors]
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& mcache::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << nextSample;
        os << " " << scanAlloc;
        os << " " << tiny;
        os << " " << tinyoffset;
        os << " " << tinyAllocs;
        os << " " << alloc;
        os << " " << stackcache;
        os << " " << flushGen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const mcache& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& gclink::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const gclink& value)
    {
        return value.PrintTo(os);
    }

    gclink* ptr(gclinkptr p)
    {
        return (*gclink)(Pointer(gocpp::recv(unsafe), p));
    }

    
    std::ostream& stackfreelist::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << list;
        os << " " << size;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const stackfreelist& value)
    {
        return value.PrintTo(os);
    }

    mspan emptymspan;
    mcache* allocmcache()
    {
        mcache* c = {};
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            c = (*mcache)(alloc(gocpp::recv(mheap_.cachealloc)));
            Store(gocpp::recv(c->flushGen), mheap_.sweepgen);
            unlock(& mheap_.lock);
        }
);
        for(auto [i, gocpp_ignored] : c->alloc)
        {
            c->alloc[i] = & emptymspan;
        }
        c->nextSample = nextSample();
        return c;
    }

    void freemcache(mcache* c)
    {
        systemstack([=]() mutable -> void
        {
            releaseAll(gocpp::recv(c));
            stackcache_clear(c);
            lock(& mheap_.lock);
            free(gocpp::recv(mheap_.cachealloc), Pointer(gocpp::recv(unsafe), c));
            unlock(& mheap_.lock);
        }
);
    }

    mcache* getMCache(m* mp)
    {
        auto pp = ptr(gocpp::recv(mp->p));
        mcache* c = {};
        if(pp == nullptr)
        {
            c = mcache0;
        }
        else
        {
            c = pp->mcache;
        }
        return c;
    }

    void refill(mcache* c, spanClass spc)
    {
        auto s = c->alloc[spc];
        if(s->allocCount != s->nelems)
        {
            go_throw("refill of span with free space remaining");
        }
        if(s != & emptymspan)
        {
            if(s->sweepgen != mheap_.sweepgen + 3)
            {
                go_throw("bad sweepgen in refill");
            }
            uncacheSpan(gocpp::recv(mheap_.central[spc].mcentral), s);
            auto stats = acquire(gocpp::recv(memstats.heapStats));
            auto slotsUsed = int64(s->allocCount) - int64(s->allocCountBeforeCache);
            Xadd64(gocpp::recv(atomic), & stats->smallAllocCount[sizeclass(gocpp::recv(spc))], slotsUsed);
            if(spc == tinySpanClass)
            {
                Xadd64(gocpp::recv(atomic), & stats->tinyAllocCount, int64(c->tinyAllocs));
                c->tinyAllocs = 0;
            }
            release(gocpp::recv(memstats.heapStats));
            auto bytesAllocated = slotsUsed * int64(s->elemsize);
            Add(gocpp::recv(gcController.totalAlloc), bytesAllocated);
            s->allocCountBeforeCache = 0;
        }
        s = cacheSpan(gocpp::recv(mheap_.central[spc].mcentral));
        if(s == nullptr)
        {
            go_throw("out of memory");
        }
        if(s->allocCount == s->nelems)
        {
            go_throw("span has no free space");
        }
        s->sweepgen = mheap_.sweepgen + 3;
        s->allocCountBeforeCache = s->allocCount;
        auto usedBytes = uintptr(s->allocCount) * s->elemsize;
        update(gocpp::recv(gcController), int64(s->npages * pageSize) - int64(usedBytes), int64(c->scanAlloc));
        c->scanAlloc = 0;
        c->alloc[spc] = s;
    }

    mspan* allocLarge(mcache* c, uintptr_t size, bool noscan)
    {
        if(size + _PageSize < size)
        {
            go_throw("out of memory");
        }
        auto npages = size >> _PageShift;
        if(size & _PageMask != 0)
        {
            npages++;
        }
        deductSweepCredit(npages * _PageSize, npages);
        auto spc = makeSpanClass(0, noscan);
        auto s = alloc(gocpp::recv(mheap_), npages, spc);
        if(s == nullptr)
        {
            go_throw("out of memory");
        }
        auto stats = acquire(gocpp::recv(memstats.heapStats));
        Xadd64(gocpp::recv(atomic), & stats->largeAlloc, int64(npages * pageSize));
        Xadd64(gocpp::recv(atomic), & stats->largeAllocCount, 1);
        release(gocpp::recv(memstats.heapStats));
        Add(gocpp::recv(gcController.totalAlloc), int64(npages * pageSize));
        update(gocpp::recv(gcController), int64(s->npages * pageSize), 0);
        push(gocpp::recv(fullSwept(gocpp::recv(mheap_.central[spc].mcentral), mheap_.sweepgen)), s);
        s->limit = base(gocpp::recv(s)) + size;
        initHeapBits(gocpp::recv(s), false);
        return s;
    }

    void releaseAll(mcache* c)
    {
        auto scanAlloc = int64(c->scanAlloc);
        c->scanAlloc = 0;
        auto sg = mheap_.sweepgen;
        auto dHeapLive = int64(0);
        for(auto [i, gocpp_ignored] : c->alloc)
        {
            auto s = c->alloc[i];
            if(s != & emptymspan)
            {
                auto slotsUsed = int64(s->allocCount) - int64(s->allocCountBeforeCache);
                s->allocCountBeforeCache = 0;
                auto stats = acquire(gocpp::recv(memstats.heapStats));
                Xadd64(gocpp::recv(atomic), & stats->smallAllocCount[sizeclass(gocpp::recv(spanClass(i)))], slotsUsed);
                release(gocpp::recv(memstats.heapStats));
                Add(gocpp::recv(gcController.totalAlloc), slotsUsed * int64(s->elemsize));
                if(s->sweepgen != sg + 1)
                {
                    dHeapLive -= int64(s->nelems - s->allocCount) * int64(s->elemsize);
                }
                uncacheSpan(gocpp::recv(mheap_.central[i].mcentral), s);
                c->alloc[i] = & emptymspan;
            }
        }
        c->tiny = 0;
        c->tinyoffset = 0;
        auto stats = acquire(gocpp::recv(memstats.heapStats));
        Xadd64(gocpp::recv(atomic), & stats->tinyAllocCount, int64(c->tinyAllocs));
        c->tinyAllocs = 0;
        release(gocpp::recv(memstats.heapStats));
        update(gocpp::recv(gcController), dHeapLive, scanAlloc);
    }

    void prepareForSweep(mcache* c)
    {
        auto sg = mheap_.sweepgen;
        auto flushGen = Load(gocpp::recv(c->flushGen));
        if(flushGen == sg)
        {
            return;
        }
        else
        if(flushGen != sg - 2)
        {
            println("bad flushGen", flushGen, "in prepareForSweep; sweepgen", sg);
            go_throw("bad flushGen");
        }
        releaseAll(gocpp::recv(c));
        stackcache_clear(c);
        Store(gocpp::recv(c->flushGen), mheap_.sweepgen);
    }

}

