// generated by GoCpp from file '$(ImportDir)/runtime/iface.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/iface.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/switch.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/sys/intrinsics.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbarrier.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/slice.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    mutex itabLock;
    itabTableType* itabTable = & itabTableInit;
    itabTableType itabTableInit = gocpp::Init<itabTableType>([](itabTableType& x) { x.size = itabInitSize; });
    
    std::ostream& itabTableType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << size;
        os << " " << count;
        os << " " << entries;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct itabTableType& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t itabHashFunc(interfacetype* inter, _type* typ)
    {
        return uintptr_t(inter->Type.Hash ^ typ->Hash);
    }

    itab* getitab(interfacetype* inter, _type* typ, bool canfail)
    {
        if(len(inter->Methods) == 0)
        {
            go_throw("internal error - misuse of itab");
        }
        if(typ->TFlag & abi::TFlagUncommon == 0)
        {
            if(canfail)
            {
                return nullptr;
            }
            auto name = nameOff(gocpp::recv(toRType(& inter->Type)), inter->Methods[0].Name);
            gocpp::panic(new TypeAssertionError {nullptr, typ, & inter->Type, Name(gocpp::recv(name))});
        }
        itab* m = {};
        auto t = (itabTableType*)(atomic::Loadp(unsafe::Pointer(& itabTable)));
        if(m = find(gocpp::recv(t), inter, typ); m != nullptr)
        {
            goto finish;
        }
        lock(& itabLock);
        if(m = find(gocpp::recv(itabTable), inter, typ); m != nullptr)
        {
            unlock(& itabLock);
            goto finish;
        }
        m = (itab*)(persistentalloc(unsafe::Sizeof(itab {}) + uintptr_t(len(inter->Methods) - 1) * goarch::PtrSize, 0, & memstats.other_sys));
        m->inter = inter;
        m->_type = typ;
        m->hash = 0;
        init(gocpp::recv(m));
        itabAdd(m);
        unlock(& itabLock);
        finish:
        if(m->fun[0] != 0)
        {
            return m;
        }
        if(canfail)
        {
            return nullptr;
        }
        gocpp::panic(gocpp::InitPtr<TypeAssertionError>([](TypeAssertionError& x) { x.concrete = typ; x.asserted = & inter->Type; x.missingMethod = init(gocpp::recv(m)); }));
    }

    itab* find(struct itabTableType* t, interfacetype* inter, _type* typ)
    {
        auto mask = t->size - 1;
        auto h = itabHashFunc(inter, typ) & mask;
        for(auto i = uintptr_t(1); ; i++)
        {
            auto p = (itab**)(add(unsafe::Pointer(& t->entries), h * goarch::PtrSize));
            auto m = (itab*)(atomic::Loadp(unsafe::Pointer(p)));
            if(m == nullptr)
            {
                return nullptr;
            }
            if(m->inter == inter && m->_type == typ)
            {
                return m;
            }
            h += i;
            h &= mask;
        }
    }

    void itabAdd(itab* m)
    {
        if(getg()->m->mallocing != 0)
        {
            go_throw("malloc deadlock");
        }
        auto t = itabTable;
        if(t->count >= 3 * (t->size / 4))
        {
            auto t2 = (itabTableType*)(mallocgc((2 + 2 * t->size) * goarch::PtrSize, nullptr, true));
            t2->size = t->size * 2;
            iterate_itabs(t2->add);
            if(t2->count != t->count)
            {
                go_throw("mismatched count during itab table copy");
            }
            atomicstorep(unsafe::Pointer(& itabTable), unsafe::Pointer(t2));
            t = itabTable;
        }
        add(gocpp::recv(t), m);
    }

    void add(struct itabTableType* t, itab* m)
    {
        auto mask = t->size - 1;
        auto h = itabHashFunc(m->inter, m->_type) & mask;
        for(auto i = uintptr_t(1); ; i++)
        {
            auto p = (itab**)(add(unsafe::Pointer(& t->entries), h * goarch::PtrSize));
            auto m2 = *p;
            if(m2 == m)
            {
                return;
            }
            if(m2 == nullptr)
            {
                atomic::StorepNoWB(unsafe::Pointer(p), unsafe::Pointer(m));
                t->count++;
                return;
            }
            h += i;
            h &= mask;
        }
    }

    std::string init(struct itab* m)
    {
        auto inter = m->inter;
        auto typ = m->_type;
        auto x = Uncommon(gocpp::recv(typ));
        auto ni = len(inter->Methods);
        auto nt = int(x->Mcount);
        auto xmhdr = (gocpp::array<abi::Method, 1 << 16>*)(add(unsafe::Pointer(x), uintptr_t(x->Moff))).make_slice(, nt, nt);
        auto j = 0;
        auto methods = (gocpp::array<unsafe::Pointer, 1 << 16>*)(unsafe::Pointer(& m->fun[0])).make_slice(, ni, ni);
        unsafe::Pointer fun0 = {};
        imethods:
        for(auto k = 0; k < ni; k++)
        {
            auto i = & inter->Methods[k];
            auto itype = typeOff(gocpp::recv(toRType(& inter->Type)), i->Typ);
            auto name = nameOff(gocpp::recv(toRType(& inter->Type)), i->Name);
            auto iname = Name(gocpp::recv(name));
            auto ipkg = pkgPath(name);
            if(ipkg == "")
            {
                ipkg = Name(gocpp::recv(inter->PkgPath));
            }
            for(; j < nt; j++)
            {
                auto t = & xmhdr[j];
                auto rtyp = toRType(typ);
                auto tname = nameOff(gocpp::recv(rtyp), t->Name);
                if(typeOff(gocpp::recv(rtyp), t->Mtyp) == itype && Name(gocpp::recv(tname)) == iname)
                {
                    auto pkgPath = pkgPath(tname);
                    if(pkgPath == "")
                    {
                        pkgPath = Name(gocpp::recv(nameOff(gocpp::recv(rtyp), x->PkgPath)));
                    }
                    if(IsExported(gocpp::recv(tname)) || pkgPath == ipkg)
                    {
                        auto ifn = textOff(gocpp::recv(rtyp), t->Ifn);
                        if(k == 0)
                        {
                            fun0 = ifn;
                        }
                        else
                        {
                            methods[k] = ifn;
                        }
                        goto imethods_continue;
                    }
                }
            }
            m->fun[0] = 0;
            return iname;
            if(false) {
            imethods_continue:
                continue;
            imethods_break:
                break;
            }
        }
        m->fun[0] = uintptr_t(fun0);
        return "";
    }

    void itabsinit()
    {
        lockInit(& itabLock, lockRankItab);
        lock(& itabLock);
        for(auto [_, md] : activeModules())
        {
            for(auto [_, i] : md->itablinks)
            {
                itabAdd(i);
            }
        }
        unlock(& itabLock);
    }

    void panicdottypeE(_type* have, _type* want, _type* iface)
    {
        gocpp::panic(new TypeAssertionError {iface, have, want, ""});
    }

    void panicdottypeI(itab* have, _type* want, _type* iface)
    {
        _type* t = {};
        if(have != nullptr)
        {
            t = have->_type;
        }
        panicdottypeE(t, want, iface);
    }

    void panicnildottype(_type* want)
    {
        gocpp::panic(new TypeAssertionError {nullptr, nullptr, want, ""});
    }

    go_any uint16Eface = uint16InterfacePtr(0);
    go_any uint32Eface = uint32InterfacePtr(0);
    go_any uint64Eface = uint64InterfacePtr(0);
    go_any stringEface = stringInterfacePtr("");
    go_any sliceEface = sliceInterfacePtr(nullptr);
    _type* uint16Type = efaceOf(& uint16Eface)->_type;
    _type* uint32Type = efaceOf(& uint32Eface)->_type;
    _type* uint64Type = efaceOf(& uint64Eface)->_type;
    _type* stringType = efaceOf(& stringEface)->_type;
    _type* sliceType = efaceOf(& sliceEface)->_type;
    unsafe::Pointer convT(_type* t, unsafe::Pointer v)
    {
        if(raceenabled)
        {
            raceReadObjectPC(t, v, getcallerpc(), abi::FuncPCABIInternal(convT));
        }
        if(msanenabled)
        {
            msanread(v, t->Size_);
        }
        if(asanenabled)
        {
            asanread(v, t->Size_);
        }
        auto x = mallocgc(t->Size_, t, true);
        typedmemmove(t, x, v);
        return x;
    }

    unsafe::Pointer convTnoptr(_type* t, unsafe::Pointer v)
    {
        if(raceenabled)
        {
            raceReadObjectPC(t, v, getcallerpc(), abi::FuncPCABIInternal(convTnoptr));
        }
        if(msanenabled)
        {
            msanread(v, t->Size_);
        }
        if(asanenabled)
        {
            asanread(v, t->Size_);
        }
        auto x = mallocgc(t->Size_, t, false);
        memmove(x, v, t->Size_);
        return x;
    }

    unsafe::Pointer convT16(uint16_t val)
    {
        unsafe::Pointer x;
        if(val < uint16_t(len(staticuint64s)))
        {
            unsafe::Pointer x;
            x = unsafe::Pointer(& staticuint64s[val]);
            if(goarch::BigEndian)
            {
                unsafe::Pointer x;
                x = add(x, 6);
            }
        }
        else
        {
            unsafe::Pointer x;
            x = mallocgc(2, uint16Type, false);
            *(uint16_t*)(x) = val;
        }
        return x;
    }

    unsafe::Pointer convT32(uint32_t val)
    {
        unsafe::Pointer x;
        if(val < uint32_t(len(staticuint64s)))
        {
            unsafe::Pointer x;
            x = unsafe::Pointer(& staticuint64s[val]);
            if(goarch::BigEndian)
            {
                unsafe::Pointer x;
                x = add(x, 4);
            }
        }
        else
        {
            unsafe::Pointer x;
            x = mallocgc(4, uint32Type, false);
            *(uint32_t*)(x) = val;
        }
        return x;
    }

    unsafe::Pointer convT64(uint64_t val)
    {
        unsafe::Pointer x;
        if(val < uint64_t(len(staticuint64s)))
        {
            unsafe::Pointer x;
            x = unsafe::Pointer(& staticuint64s[val]);
        }
        else
        {
            unsafe::Pointer x;
            x = mallocgc(8, uint64Type, false);
            *(uint64_t*)(x) = val;
        }
        return x;
    }

    unsafe::Pointer convTstring(std::string val)
    {
        unsafe::Pointer x;
        if(val == "")
        {
            unsafe::Pointer x;
            x = unsafe::Pointer(& zeroVal[0]);
        }
        else
        {
            unsafe::Pointer x;
            x = mallocgc(unsafe::Sizeof(val), stringType, true);
            *(std::string*)(x) = val;
        }
        return x;
    }

    unsafe::Pointer convTslice(gocpp::slice<unsigned char> val)
    {
        unsafe::Pointer x;
        if((slice*)(unsafe::Pointer(& val))->array == nullptr)
        {
            unsafe::Pointer x;
            x = unsafe::Pointer(& zeroVal[0]);
        }
        else
        {
            unsafe::Pointer x;
            x = mallocgc(unsafe::Sizeof(val), sliceType, true);
            *(gocpp::slice<unsigned char>*)(x) = val;
        }
        return x;
    }

    itab* assertE2I(interfacetype* inter, _type* t)
    {
        if(t == nullptr)
        {
            gocpp::panic(new TypeAssertionError {nullptr, nullptr, & inter->Type, ""});
        }
        return getitab(inter, t, false);
    }

    itab* assertE2I2(interfacetype* inter, _type* t)
    {
        if(t == nullptr)
        {
            return nullptr;
        }
        return getitab(inter, t, true);
    }

    itab* typeAssert(abi::TypeAssert* s, _type* t)
    {
        itab* tab = {};
        if(t == nullptr)
        {
            if(! s->CanFail)
            {
                gocpp::panic(new TypeAssertionError {nullptr, nullptr, & s->Inter->Type, ""});
            }
        }
        else
        {
            tab = getitab(s->Inter, t, s->CanFail);
        }
        if(! abi::UseInterfaceSwitchCache(GOARCH))
        {
            return tab;
        }
        if(cheaprand() & 1023 != 0)
        {
            return tab;
        }
        auto oldC = (abi::TypeAssertCache*)(atomic::Loadp(unsafe::Pointer(& s->Cache)));
        if(cheaprand() & uint32_t(oldC->Mask) != 0)
        {
            return tab;
        }
        auto newC = buildTypeAssertCache(oldC, t, tab);
        atomic_casPointer((unsafe::Pointer*)(unsafe::Pointer(& s->Cache)), unsafe::Pointer(oldC), unsafe::Pointer(newC));
        return tab;
    }

    abi::TypeAssertCache* buildTypeAssertCache(abi::TypeAssertCache* oldC, _type* typ, itab* tab)
    {
        auto oldEntries = unsafe::Slice(& oldC->Entries[0], oldC->Mask + 1);
        auto n = 1;
        for(auto [_, e] : oldEntries)
        {
            if(e.Typ != 0)
            {
                n++;
            }
        }
        auto newN = n * 2;
        newN = 1 << sys::Len64(uint64_t(newN - 1));
        auto newSize = unsafe::Sizeof(abi::TypeAssertCache {}) + uintptr_t(newN - 1) * unsafe::Sizeof(abi::TypeAssertCacheEntry {});
        auto newC = (abi::TypeAssertCache*)(mallocgc(newSize, nullptr, true));
        newC->Mask = uintptr_t(newN - 1);
        auto newEntries = unsafe::Slice(& newC->Entries[0], newN);
        auto addEntry = [=](_type* typ, itab* tab) mutable -> void
        {
            auto h = int(typ->Hash) & (newN - 1);
            for(; ; )
            {
                if(newEntries[h].Typ == 0)
                {
                    newEntries[h].Typ = uintptr_t(unsafe::Pointer(typ));
                    newEntries[h].Itab = uintptr_t(unsafe::Pointer(tab));
                    return;
                }
                h = (h + 1) & (newN - 1);
            }
        }
;
        for(auto [_, e] : oldEntries)
        {
            if(e.Typ != 0)
            {
                addEntry((_type*)(unsafe::Pointer(e.Typ)), (itab*)(unsafe::Pointer(e.Itab)));
            }
        }
        addEntry(typ, tab);
        return newC;
    }

    abi::TypeAssertCache emptyTypeAssertCache = gocpp::Init<abi::TypeAssertCache>([](abi::TypeAssertCache& x) { x.Mask = 0; });
    std::tuple<int, itab*> interfaceSwitch(abi::InterfaceSwitch* s, _type* t)
    {
        auto cases = unsafe::Slice(& s->Cases[0], s->NCases);
        auto case_ = len(cases);
        itab* tab = {};
        for(auto [i, c] : cases)
        {
            tab = getitab(c, t, true);
            if(tab != nullptr)
            {
                case_ = i;
                break;
            }
        }
        if(! abi::UseInterfaceSwitchCache(GOARCH))
        {
            return {case_, tab};
        }
        if(cheaprand() & 1023 != 0)
        {
            return {case_, tab};
        }
        auto oldC = (abi::InterfaceSwitchCache*)(atomic::Loadp(unsafe::Pointer(& s->Cache)));
        if(cheaprand() & uint32_t(oldC->Mask) != 0)
        {
            return {case_, tab};
        }
        auto newC = buildInterfaceSwitchCache(oldC, t, case_, tab);
        atomic_casPointer((unsafe::Pointer*)(unsafe::Pointer(& s->Cache)), unsafe::Pointer(oldC), unsafe::Pointer(newC));
        return {case_, tab};
    }

    abi::InterfaceSwitchCache* buildInterfaceSwitchCache(abi::InterfaceSwitchCache* oldC, _type* typ, int case_, itab* tab)
    {
        auto oldEntries = unsafe::Slice(& oldC->Entries[0], oldC->Mask + 1);
        auto n = 1;
        for(auto [_, e] : oldEntries)
        {
            if(e.Typ != 0)
            {
                n++;
            }
        }
        auto newN = n * 2;
        newN = 1 << sys::Len64(uint64_t(newN - 1));
        auto newSize = unsafe::Sizeof(abi::InterfaceSwitchCache {}) + uintptr_t(newN - 1) * unsafe::Sizeof(abi::InterfaceSwitchCacheEntry {});
        auto newC = (abi::InterfaceSwitchCache*)(mallocgc(newSize, nullptr, true));
        newC->Mask = uintptr_t(newN - 1);
        auto newEntries = unsafe::Slice(& newC->Entries[0], newN);
        auto addEntry = [=](_type* typ, int case_, itab* tab) mutable -> void
        {
            auto h = int(typ->Hash) & (newN - 1);
            for(; ; )
            {
                if(newEntries[h].Typ == 0)
                {
                    newEntries[h].Typ = uintptr_t(unsafe::Pointer(typ));
                    newEntries[h].Case = case_;
                    newEntries[h].Itab = uintptr_t(unsafe::Pointer(tab));
                    return;
                }
                h = (h + 1) & (newN - 1);
            }
        }
;
        for(auto [_, e] : oldEntries)
        {
            if(e.Typ != 0)
            {
                addEntry((_type*)(unsafe::Pointer(e.Typ)), e.Case, (itab*)(unsafe::Pointer(e.Itab)));
            }
        }
        addEntry(typ, case_, tab);
        return newC;
    }

    abi::InterfaceSwitchCache emptyInterfaceSwitchCache = gocpp::Init<abi::InterfaceSwitchCache>([](abi::InterfaceSwitchCache& x) { x.Mask = 0; });
    void reflect_ifaceE2I(interfacetype* inter, eface e, iface* dst)
    {
        *dst = iface {assertE2I(inter, e._type), e.data};
    }

    void reflectlite_ifaceE2I(interfacetype* inter, eface e, iface* dst)
    {
        *dst = iface {assertE2I(inter, e._type), e.data};
    }

    void iterate_itabs(std::function<void (itab*)> fn)
    {
        auto t = itabTable;
        for(auto i = uintptr_t(0); i < t->size; i++)
        {
            auto m = *(itab**)(add(unsafe::Pointer(& t->entries), i * goarch::PtrSize));
            if(m != nullptr)
            {
                fn(m);
            }
        }
    }

    gocpp::array_base<uint64_t> staticuint64s = gocpp::array_base<uint64_t> {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
    void unreachableMethod()
    {
        go_throw("unreachable method called. linker bug?");
    }

}

