// generated by GoCpp from file '$(ImportDir)/golang.org/x/tour/pic/pic.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/golang.org/x/tour/pic/pic.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/compress/zlib/writer.h"
#include "golang/encoding/base64/base64.h"
#include "golang/hash/hash.h"
#include "golang/image/color/color.h"
#include "golang/image/geom.h"
#include "golang/image/image.h"
// #include "golang/image/png/writer.h"  [Ignored, known errors]
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/io.h"
#include "golang/os/dir_windows.h"
#include "golang/os/file_windows.h"
#include "golang/os/types.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"

namespace golang::pic
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace base64::rec;
        using namespace bufio::rec;
        using namespace color::rec;
        using namespace flate::rec;
        using namespace hash::rec;
        using namespace image::rec;
        using namespace io::rec;
        using namespace os::rec;
        using namespace poll::rec;
        using namespace sync::rec;
        using namespace syscall::rec;
        using namespace windows::rec;
        using namespace zlib::rec;
    }

    void Show(std::function<gocpp::slice<gocpp::slice<uint8_t>> (int dx, int dy)> f)
    {
        auto dx = 256;
        auto dy = 256;
        auto data = f(dx, dy);
        auto m = image::NewNRGBA(image::Rect(0, 0, dx, dy));
        for(auto y = 0; y < dy; y++)
        {
            for(auto x = 0; x < dx; x++)
            {
                auto v = data[y][x];
                auto i = y * m->Stride + x * 4;
                m->Pix[i] = v;
                m->Pix[i + 1] = v;
                m->Pix[i + 2] = 255;
                m->Pix[i + 3] = 255;
            }
        }
        ShowImage(m);
    }

    void ShowImage(struct image::Image m)
    {
        gocpp::Defer defer;
        try
        {
            auto w = bufio::NewWriter(os::Stdout);
            defer.push_back([=]{ rec::Flush(gocpp::recv(w)); });
            io::WriteString(w, "IMAGE:");
            auto b64 = base64::NewEncoder(base64::StdEncoding, w);
            auto err = rec::Encode(gocpp::recv((gocpp::InitPtr<png::Encoder>([](png::Encoder& x) { x.CompressionLevel = png::BestCompression; }))), b64, m);
            if(err != nullptr)
            {
                gocpp::panic(err);
            }
            rec::Close(gocpp::recv(b64));
            io::WriteString(w, "\n");
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

