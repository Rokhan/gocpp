// generated by GoCpp from file '$(ImportDir)/encoding/base64/base64.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/encoding/base64/base64.h"
#include "gocpp/support.h"

#include "golang/encoding/binary/binary.h"
#include "golang/io/io.h"
#include "golang/slices/slices.h"
#include "golang/strconv/atoi.h"
#include "golang/strconv/itoa.h"

namespace golang::base64
{
    namespace rec
    {
        using namespace mocklib::rec;
        using binary::rec::PutUint32;
        using binary::rec::PutUint64;
        using io::rec::Read;
        using io::rec::Write;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Encoding::operator T()
    {
        T result;
        result.encode = this->encode;
        result.decodeMap = this->decodeMap;
        result.padChar = this->padChar;
        result.strict = this->strict;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Encoding::operator==(const T& ref) const
    {
        if (encode != ref.encode) return false;
        if (decodeMap != ref.decodeMap) return false;
        if (padChar != ref.padChar) return false;
        if (strict != ref.strict) return false;
        return true;
    }

    std::ostream& Encoding::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << encode;
        os << " " << decodeMap;
        os << " " << padChar;
        os << " " << strict;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Encoding& value)
    {
        return value.PrintTo(os);
    }

    std::string decodeMapInitialize = "" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff";
    struct Encoding* NewEncoding(std::string encoder)
    {
        if(len(encoder) != 64)
        {
            gocpp::panic("encoding alphabet is not 64-bytes long");
        }
        auto e = new(Encoding);
        e->padChar = StdPadding;
        copy(e->encode.make_slice(0), encoder);
        copy(e->decodeMap.make_slice(0), decodeMapInitialize);
        for(auto i = 0; i < len(encoder); i++)
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if(encoder[i] == '\n' || encoder[i] == '\r') { conditionId = 0; }
                else if(e->decodeMap[encoder[i]] != invalidIndex) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        gocpp::panic("encoding alphabet contains newline character");
                        break;
                    case 1:
                        gocpp::panic("encoding alphabet includes duplicate symbols");
                        break;
                }
            }
            e->decodeMap[encoder[i]] = uint8_t(i);
        }
        return e;
    }

    struct Encoding* rec::WithPadding(struct Encoding enc, gocpp::rune padding)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(padding < NoPadding || padding == '\r' || padding == '\n' || padding > 0xff) { conditionId = 0; }
            else if(padding != NoPadding && enc.decodeMap[unsigned char(padding)] != invalidIndex) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    gocpp::panic("invalid padding");
                    break;
                case 1:
                    gocpp::panic("padding contained in alphabet");
                    break;
            }
        }
        enc.padChar = padding;
        return & enc;
    }

    struct Encoding* rec::Strict(struct Encoding enc)
    {
        enc.strict = true;
        return & enc;
    }

    Encoding* StdEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    Encoding* URLEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_");
    Encoding* RawStdEncoding = rec::WithPadding(gocpp::recv(StdEncoding), NoPadding);
    Encoding* RawURLEncoding = rec::WithPadding(gocpp::recv(URLEncoding), NoPadding);
    void rec::Encode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        if(len(src) == 0)
        {
            return;
        }
        _ = enc->encode;
        auto [di, si] = std::tuple{0, 0};
        auto n = (len(src) / 3) * 3;
        for(; si < n; )
        {
            auto val = ((unsigned int)(src[si + 0]) << 16) | ((unsigned int)(src[si + 1]) << 8) | (unsigned int)(src[si + 2]);
            dst[di + 0] = enc->encode[(val >> 18) & 0x3F];
            dst[di + 1] = enc->encode[(val >> 12) & 0x3F];
            dst[di + 2] = enc->encode[(val >> 6) & 0x3F];
            dst[di + 3] = enc->encode[val & 0x3F];
            si += 3;
            di += 4;
        }
        auto remain = len(src) - si;
        if(remain == 0)
        {
            return;
        }
        auto val = (unsigned int)(src[si + 0]) << 16;
        if(remain == 2)
        {
            val |= (unsigned int)(src[si + 1]) << 8;
        }
        dst[di + 0] = enc->encode[(val >> 18) & 0x3F];
        dst[di + 1] = enc->encode[(val >> 12) & 0x3F];
        //Go switch emulation
        {
            auto condition = remain;
            int conditionId = -1;
            if(condition == 2) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    dst[di + 2] = enc->encode[(val >> 6) & 0x3F];
                    if(enc->padChar != NoPadding)
                    {
                        dst[di + 3] = unsigned char(enc->padChar);
                    }
                    break;
                case 1:
                    if(enc->padChar != NoPadding)
                    {
                        dst[di + 2] = unsigned char(enc->padChar);
                        dst[di + 3] = unsigned char(enc->padChar);
                    }
                    break;
            }
        }
    }

    gocpp::slice<unsigned char> rec::AppendEncode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto n = rec::EncodedLen(gocpp::recv(enc), len(src));
        dst = slices::Grow(dst, n);
        rec::Encode(gocpp::recv(enc), dst.make_slice(len(dst)).make_slice(0, n), src);
        return dst.make_slice(0, len(dst) + n);
    }

    std::string rec::EncodeToString(struct Encoding* enc, gocpp::slice<unsigned char> src)
    {
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), rec::EncodedLen(gocpp::recv(enc), len(src)));
        rec::Encode(gocpp::recv(enc), buf, src);
        return std::string(buf);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    encoder::operator T()
    {
        T result;
        result.err = this->err;
        result.enc = this->enc;
        result.w = this->w;
        result.buf = this->buf;
        result.nbuf = this->nbuf;
        result.out = this->out;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool encoder::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (enc != ref.enc) return false;
        if (w != ref.w) return false;
        if (buf != ref.buf) return false;
        if (nbuf != ref.nbuf) return false;
        if (out != ref.out) return false;
        return true;
    }

    std::ostream& encoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << enc;
        os << " " << w;
        os << " " << buf;
        os << " " << nbuf;
        os << " " << out;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct encoder& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct encoder* e, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(e->err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, e->err};
        }
        if(e->nbuf > 0)
        {
            int n;
            struct gocpp::error err;
            int i = {};
            for(i = 0; i < len(p) && e->nbuf < 3; i++)
            {
                int n;
                struct gocpp::error err;
                e->buf[e->nbuf] = p[i];
                e->nbuf++;
            }
            n += i;
            p = p.make_slice(i);
            if(e->nbuf < 3)
            {
                int n;
                struct gocpp::error err;
                return {n, err};
            }
            rec::Encode(gocpp::recv(e->enc), e->out.make_slice(0), e->buf.make_slice(0));
            if(std::tie(gocpp_id_0, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, 4)); e->err != nullptr)
            {
                int n;
                struct gocpp::error err;
                return {n, e->err};
            }
            e->nbuf = 0;
        }
        for(; len(p) >= 3; )
        {
            int n;
            struct gocpp::error err;
            auto nn = len(e->out) / 4 * 3;
            if(nn > len(p))
            {
                int n;
                struct gocpp::error err;
                nn = len(p);
                nn -= nn % 3;
            }
            rec::Encode(gocpp::recv(e->enc), e->out.make_slice(0), p.make_slice(0, nn));
            if(std::tie(gocpp_id_1, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, nn / 3 * 4)); e->err != nullptr)
            {
                int n;
                struct gocpp::error err;
                return {n, e->err};
            }
            n += nn;
            p = p.make_slice(nn);
        }
        copy(e->buf.make_slice(0), p);
        e->nbuf = len(p);
        n += len(p);
        return {n, err};
    }

    struct gocpp::error rec::Close(struct encoder* e)
    {
        if(e->err == nullptr && e->nbuf > 0)
        {
            rec::Encode(gocpp::recv(e->enc), e->out.make_slice(0), e->buf.make_slice(0, e->nbuf));
            std::tie(gocpp_id_2, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, rec::EncodedLen(gocpp::recv(e->enc), e->nbuf)));
            e->nbuf = 0;
        }
        return e->err;
    }

    io::WriteCloser NewEncoder(struct Encoding* enc, io::Writer w)
    {
        return gocpp::InitPtr<encoder>([=](auto& x) {
            x.enc = enc;
            x.w = w;
        });
    }

    int rec::EncodedLen(struct Encoding* enc, int n)
    {
        if(enc->padChar == NoPadding)
        {
            return n / 3 * 4 + (n % 3 * 8 + 5) / 6;
        }
        return (n + 2) / 3 * 4;
    }

    std::string rec::Error(golang::base64::CorruptInputError e)
    {
        return "illegal base64 data at input byte " + strconv::FormatInt(int64_t(e), 10);
    }

    std::tuple<int, int, struct gocpp::error> rec::decodeQuantum(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src, int si)
    {
        int nsi;
        int n;
        struct gocpp::error err;
        gocpp::array<unsigned char, 4> dbuf = {};
        auto dlen = 4;
        _ = enc->decodeMap;
        for(auto j = 0; j < len(dbuf); j++)
        {
            int nsi;
            int n;
            struct gocpp::error err;
            if(len(src) == si)
            {
                int nsi;
                int n;
                struct gocpp::error err;
                //Go switch emulation
                {
                    int conditionId = -1;
                    if(j == 0) { conditionId = 0; }
                    else if(j == 1) { conditionId = 1; }
                    else if(enc->padChar != NoPadding) { conditionId = 2; }
                    switch(conditionId)
                    {
                        int nsi;
                        int n;
                        struct gocpp::error err;
                        case 0:
                            return {si, 0, nullptr};
                            break;
                        case 1:
                        case 2:
                            return {si, 0, CorruptInputError(si - j)};
                            break;
                    }
                }
                dlen = j;
                break;
            }
            auto in = src[si];
            si++;
            auto out = enc->decodeMap[in];
            if(out != 0xff)
            {
                int nsi;
                int n;
                struct gocpp::error err;
                dbuf[j] = out;
                continue;
            }
            if(in == '\n' || in == '\r')
            {
                int nsi;
                int n;
                struct gocpp::error err;
                j--;
                continue;
            }
            if(gocpp::rune(in) != enc->padChar)
            {
                int nsi;
                int n;
                struct gocpp::error err;
                return {si, 0, CorruptInputError(si - 1)};
            }
            //Go switch emulation
            {
                auto condition = j;
                int conditionId = -1;
                if(condition == 0) { conditionId = 0; }
                if(condition == 1) { conditionId = 1; }
                else if(condition == 2) { conditionId = 2; }
                switch(conditionId)
                {
                    int nsi;
                    int n;
                    struct gocpp::error err;
                    case 0:
                    case 1:
                        return {si, 0, CorruptInputError(si - 1)};
                        break;
                    case 2:
                        for(; si < len(src) && (src[si] == '\n' || src[si] == '\r'); )
                        {
                            int nsi;
                            int n;
                            struct gocpp::error err;
                            si++;
                        }
                        if(si == len(src))
                        {
                            int nsi;
                            int n;
                            struct gocpp::error err;
                            return {si, 0, CorruptInputError(len(src))};
                        }
                        if(gocpp::rune(src[si]) != enc->padChar)
                        {
                            int nsi;
                            int n;
                            struct gocpp::error err;
                            return {si, 0, CorruptInputError(si - 1)};
                        }
                        si++;
                        break;
                }
            }
            for(; si < len(src) && (src[si] == '\n' || src[si] == '\r'); )
            {
                int nsi;
                int n;
                struct gocpp::error err;
                si++;
            }
            if(si < len(src))
            {
                int nsi;
                int n;
                struct gocpp::error err;
                err = CorruptInputError(si);
            }
            dlen = j;
            break;
        }
        auto val = ((unsigned int)(dbuf[0]) << 18) | ((unsigned int)(dbuf[1]) << 12) | ((unsigned int)(dbuf[2]) << 6) | (unsigned int)(dbuf[3]);
        std::tie(dbuf[2], dbuf[1], dbuf[0]) = std::tuple{unsigned char(val >> 0), unsigned char(val >> 8), unsigned char(val >> 16)};
        //Go switch emulation
        {
            auto condition = dlen;
            int conditionId = -1;
            if(condition == 4) { conditionId = 0; }
            else if(condition == 3) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                int nsi;
                int n;
                struct gocpp::error err;
                case 0:
                    dst[2] = dbuf[2];
                    dbuf[2] = 0;
                case 1:
                    dst[1] = dbuf[1];
                    if(enc->strict && dbuf[2] != 0)
                    {
                        int nsi;
                        int n;
                        struct gocpp::error err;
                        return {si, 0, CorruptInputError(si - 1)};
                    }
                    dbuf[1] = 0;
                case 2:
                    dst[0] = dbuf[0];
                    if(enc->strict && (dbuf[1] != 0 || dbuf[2] != 0))
                    {
                        int nsi;
                        int n;
                        struct gocpp::error err;
                        return {si, 0, CorruptInputError(si - 2)};
                    }
                    break;
            }
        }
        return {si, dlen - 1, err};
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::AppendDecode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto n = len(src);
        for(; n > 0 && gocpp::rune(src[n - 1]) == enc->padChar; )
        {
            n--;
        }
        n = decodedLen(n, NoPadding);
        dst = slices::Grow(dst, n);
        gocpp::error err;
        std::tie(n, err) = rec::Decode(gocpp::recv(enc), dst.make_slice(len(dst)).make_slice(0, n), src);
        return {dst.make_slice(0, len(dst) + n), err};
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::DecodeString(struct Encoding* enc, std::string s)
    {
        auto dbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), rec::DecodedLen(gocpp::recv(enc), len(s)));
        auto [n, err] = rec::Decode(gocpp::recv(enc), dbuf, gocpp::Tag<gocpp::slice<unsigned char>>()(s));
        return {dbuf.make_slice(0, n), err};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    decoder::operator T()
    {
        T result;
        result.err = this->err;
        result.readErr = this->readErr;
        result.enc = this->enc;
        result.r = this->r;
        result.buf = this->buf;
        result.nbuf = this->nbuf;
        result.out = this->out;
        result.outbuf = this->outbuf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decoder::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (readErr != ref.readErr) return false;
        if (enc != ref.enc) return false;
        if (r != ref.r) return false;
        if (buf != ref.buf) return false;
        if (nbuf != ref.nbuf) return false;
        if (out != ref.out) return false;
        if (outbuf != ref.outbuf) return false;
        return true;
    }

    std::ostream& decoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << readErr;
        os << " " << enc;
        os << " " << r;
        os << " " << buf;
        os << " " << nbuf;
        os << " " << out;
        os << " " << outbuf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decoder& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct decoder* d, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(len(d->out) > 0)
        {
            int n;
            struct gocpp::error err;
            n = copy(p, d->out);
            d->out = d->out.make_slice(n);
            return {n, nullptr};
        }
        if(d->err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, d->err};
        }
        for(; d->nbuf < 4 && d->readErr == nullptr; )
        {
            int n;
            struct gocpp::error err;
            auto nn = len(p) / 3 * 4;
            if(nn < 4)
            {
                int n;
                struct gocpp::error err;
                nn = 4;
            }
            if(nn > len(d->buf))
            {
                int n;
                struct gocpp::error err;
                nn = len(d->buf);
            }
            std::tie(nn, d->readErr) = rec::Read(gocpp::recv(d->r), d->buf.make_slice(d->nbuf, nn));
            d->nbuf += nn;
        }
        if(d->nbuf < 4)
        {
            int n;
            struct gocpp::error err;
            if(d->enc->padChar == NoPadding && d->nbuf > 0)
            {
                int n;
                struct gocpp::error err;
                int nw = {};
                std::tie(nw, d->err) = rec::Decode(gocpp::recv(d->enc), d->outbuf.make_slice(0), d->buf.make_slice(0, d->nbuf));
                d->nbuf = 0;
                d->out = d->outbuf.make_slice(0, nw);
                n = copy(p, d->out);
                d->out = d->out.make_slice(n);
                if(n > 0 || len(p) == 0 && len(d->out) > 0)
                {
                    int n;
                    struct gocpp::error err;
                    return {n, nullptr};
                }
                if(d->err != nullptr)
                {
                    int n;
                    struct gocpp::error err;
                    return {0, d->err};
                }
            }
            d->err = d->readErr;
            if(d->err == io::go_EOF && d->nbuf > 0)
            {
                int n;
                struct gocpp::error err;
                d->err = io::ErrUnexpectedEOF;
            }
            return {0, d->err};
        }
        auto nr = d->nbuf / 4 * 4;
        auto nw = d->nbuf / 4 * 3;
        if(nw > len(p))
        {
            int n;
            struct gocpp::error err;
            std::tie(nw, d->err) = rec::Decode(gocpp::recv(d->enc), d->outbuf.make_slice(0), d->buf.make_slice(0, nr));
            d->out = d->outbuf.make_slice(0, nw);
            n = copy(p, d->out);
            d->out = d->out.make_slice(n);
        }
        else
        {
            int n;
            struct gocpp::error err;
            std::tie(n, d->err) = rec::Decode(gocpp::recv(d->enc), p, d->buf.make_slice(0, nr));
        }
        d->nbuf -= nr;
        copy(d->buf.make_slice(0, d->nbuf), d->buf.make_slice(nr));
        return {n, d->err};
    }

    std::tuple<int, struct gocpp::error> rec::Decode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        int n;
        struct gocpp::error err;
        if(len(src) == 0)
        {
            int n;
            struct gocpp::error err;
            return {0, nullptr};
        }
        _ = enc->decodeMap;
        auto si = 0;
        for(; strconv::IntSize >= 64 && len(src) - si >= 8 && len(dst) - n >= 8; )
        {
            int n;
            struct gocpp::error err;
            auto src2 = src.make_slice(si, si + 8);
            if(auto [dn, ok] = assemble64(enc->decodeMap[src2[0]], enc->decodeMap[src2[1]], enc->decodeMap[src2[2]], enc->decodeMap[src2[3]], enc->decodeMap[src2[4]], enc->decodeMap[src2[5]], enc->decodeMap[src2[6]], enc->decodeMap[src2[7]]); ok)
            {
                int n;
                struct gocpp::error err;
                rec::PutUint64(gocpp::recv(binary::BigEndian), dst.make_slice(n), dn);
                n += 6;
                si += 8;
            }
            else
            {
                int n;
                struct gocpp::error err;
                int ninc = {};
                std::tie(si, ninc, err) = rec::decodeQuantum(gocpp::recv(enc), dst.make_slice(n), src, si);
                n += ninc;
                if(err != nullptr)
                {
                    int n;
                    struct gocpp::error err;
                    return {n, err};
                }
            }
        }
        for(; len(src) - si >= 4 && len(dst) - n >= 4; )
        {
            int n;
            struct gocpp::error err;
            auto src2 = src.make_slice(si, si + 4);
            if(auto [dn, ok] = assemble32(enc->decodeMap[src2[0]], enc->decodeMap[src2[1]], enc->decodeMap[src2[2]], enc->decodeMap[src2[3]]); ok)
            {
                int n;
                struct gocpp::error err;
                rec::PutUint32(gocpp::recv(binary::BigEndian), dst.make_slice(n), dn);
                n += 3;
                si += 4;
            }
            else
            {
                int n;
                struct gocpp::error err;
                int ninc = {};
                std::tie(si, ninc, err) = rec::decodeQuantum(gocpp::recv(enc), dst.make_slice(n), src, si);
                n += ninc;
                if(err != nullptr)
                {
                    int n;
                    struct gocpp::error err;
                    return {n, err};
                }
            }
        }
        for(; si < len(src); )
        {
            int n;
            struct gocpp::error err;
            int ninc = {};
            std::tie(si, ninc, err) = rec::decodeQuantum(gocpp::recv(enc), dst.make_slice(n), src, si);
            n += ninc;
            if(err != nullptr)
            {
                int n;
                struct gocpp::error err;
                return {n, err};
            }
        }
        return {n, err};
    }

    std::tuple<uint32_t, bool> assemble32(unsigned char n1, unsigned char n2, unsigned char n3, unsigned char n4)
    {
        uint32_t dn;
        bool ok;
        if(n1 | n2 | n3 | n4 == 0xff)
        {
            uint32_t dn;
            bool ok;
            return {0, false};
        }
        return {(uint32_t(n1) << 26) | (uint32_t(n2) << 20) | (uint32_t(n3) << 14) | (uint32_t(n4) << 8), true};
    }

    std::tuple<uint64_t, bool> assemble64(unsigned char n1, unsigned char n2, unsigned char n3, unsigned char n4, unsigned char n5, unsigned char n6, unsigned char n7, unsigned char n8)
    {
        uint64_t dn;
        bool ok;
        if(n1 | n2 | n3 | n4 | n5 | n6 | n7 | n8 == 0xff)
        {
            uint64_t dn;
            bool ok;
            return {0, false};
        }
        return {(uint64_t(n1) << 58) | (uint64_t(n2) << 52) | (uint64_t(n3) << 46) | (uint64_t(n4) << 40) | (uint64_t(n5) << 34) | (uint64_t(n6) << 28) | (uint64_t(n7) << 22) | (uint64_t(n8) << 16), true};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    newlineFilteringReader::operator T()
    {
        T result;
        result.wrapped = this->wrapped;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool newlineFilteringReader::operator==(const T& ref) const
    {
        if (wrapped != ref.wrapped) return false;
        return true;
    }

    std::ostream& newlineFilteringReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wrapped;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct newlineFilteringReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct newlineFilteringReader* r, gocpp::slice<unsigned char> p)
    {
        auto [n, err] = rec::Read(gocpp::recv(r->wrapped), p);
        for(; n > 0; )
        {
            auto offset = 0;
            for(auto [i, b] : p.make_slice(0, n))
            {
                if(b != '\r' && b != '\n')
                {
                    if(i != offset)
                    {
                        p[offset] = b;
                    }
                    offset++;
                }
            }
            if(offset > 0)
            {
                return {offset, err};
            }
            std::tie(n, err) = rec::Read(gocpp::recv(r->wrapped), p);
        }
        return {n, err};
    }

    io::Reader NewDecoder(struct Encoding* enc, io::Reader r)
    {
        return gocpp::InitPtr<decoder>([=](auto& x) {
            x.enc = enc;
            x.r = new newlineFilteringReader {r};
        });
    }

    int rec::DecodedLen(struct Encoding* enc, int n)
    {
        return decodedLen(n, enc->padChar);
    }

    int decodedLen(int n, gocpp::rune padChar)
    {
        if(padChar == NoPadding)
        {
            return n / 4 * 3 + n % 4 * 6 / 8;
        }
        return n / 4 * 3;
    }

}

