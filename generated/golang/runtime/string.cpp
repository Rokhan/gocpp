// generated by GoCpp from file '$(ImportDir)/runtime/string.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/string.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/msize_allocheaders.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // The constant is known to the compiler.
    // There is no fundamental theory behind this number.
    // concatstrings implements a Go string concatenation x+y+z+...
    // The operands are passed in the slice a.
    // If buf != nil, the compiler has determined that the result does not
    // escape the calling function, so the string data can be stored in buf
    // if small enough.
    gocpp::string concatstrings(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::slice<gocpp::string> a)
    {
        auto idx = 0;
        auto l = 0;
        auto count = 0;
        for(auto [i, x] : a)
        {
            auto n = len(x);
            if(n == 0)
            {
                continue;
            }
            if(l + n < l)
            {
                go_throw("string concatenation too long"_s);
            }
            l += n;
            count++;
            idx = i;
        }
        if(count == 0)
        {
            return ""_s;
        }
        if(count == 1 && (buf != nullptr || ! stringDataOnStack(a[idx])))
        {
            return a[idx];
        }
        auto [s, b] = rawstringtmp(buf, l);
        for(auto [gocpp_ignored, x] : a)
        {
            copy(b, x);
            b = b.make_slice(len(x));
        }
        return s;
    }

    gocpp::string concatstring2(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::string a0, gocpp::string a1)
    {
        return concatstrings(buf, gocpp::slice<gocpp::string> {a0, a1});
    }

    gocpp::string concatstring3(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::string a0, gocpp::string a1, gocpp::string a2)
    {
        return concatstrings(buf, gocpp::slice<gocpp::string> {a0, a1, a2});
    }

    gocpp::string concatstring4(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::string a0, gocpp::string a1, gocpp::string a2, gocpp::string a3)
    {
        return concatstrings(buf, gocpp::slice<gocpp::string> {a0, a1, a2, a3});
    }

    gocpp::string concatstring5(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::string a0, gocpp::string a1, gocpp::string a2, gocpp::string a3, gocpp::string a4)
    {
        return concatstrings(buf, gocpp::slice<gocpp::string> {a0, a1, a2, a3, a4});
    }

    // slicebytetostring converts a byte slice to a string.
    // It is inserted by the compiler into generated code.
    // ptr is a pointer to the first element of the slice;
    // n is the length of the slice.
    // Buf is a fixed-size buffer for the result,
    // it is not nil if the result does not escape.
    gocpp::string slicebytetostring(gocpp::array_ptr<golang::runtime::tmpBuf> buf, unsigned char* ptr, int n)
    {
        if(n == 0)
        {
            return ""_s;
        }
        if(raceenabled)
        {
            racereadrangepc(gocpp::unsafe_pointer(ptr), uintptr_t(n), getcallerpc(), abi::FuncPCABIInternal(slicebytetostring));
        }
        if(msanenabled)
        {
            msanread(gocpp::unsafe_pointer(ptr), uintptr_t(n));
        }
        if(asanenabled)
        {
            asanread(gocpp::unsafe_pointer(ptr), uintptr_t(n));
        }
        if(n == 1)
        {
            auto p = gocpp::unsafe_pointer(& staticuint64s[*ptr]);
            if(goarch::BigEndian)
            {
                p = add(p, 7);
            }
            return unsafe::String((unsigned char*)(p), 1);
        }
        gocpp::unsafe_pointer p = {};
        if(buf != nullptr && n <= len(buf))
        {
            p = gocpp::unsafe_pointer(buf);
        }
        else
        {
            p = mallocgc(uintptr_t(n), nullptr, false);
        }
        memmove(p, gocpp::unsafe_pointer(ptr), uintptr_t(n));
        return unsafe::String((unsigned char*)(p), n);
    }

    // stringDataOnStack reports whether the string's data is
    // stored on the current goroutine's stack.
    bool stringDataOnStack(gocpp::string s)
    {
        auto ptr = uintptr_t(gocpp::unsafe_pointer(unsafe::StringData(s)));
        auto stk = getg()->stack;
        return stk.lo <= ptr && ptr < stk.hi;
    }

    std::tuple<gocpp::string, gocpp::slice<unsigned char>> rawstringtmp(gocpp::array_ptr<golang::runtime::tmpBuf> buf, int l)
    {
        gocpp::string s;
        gocpp::slice<unsigned char> b;
        if(buf != nullptr && l <= len(buf))
        {
            b = buf.make_slice(0, l);
            s = slicebytetostringtmp(& b[0], len(b));
        }
        else
        {
            std::tie(s, b) = rawstring(l);
        }
        return {s, b};
    }

    // slicebytetostringtmp returns a "string" referring to the actual []byte bytes.
    //
    // Callers need to ensure that the returned string will not be used after
    // the calling goroutine modifies the original slice or synchronizes with
    // another goroutine.
    //
    // The function is only called when instrumenting
    // and otherwise intrinsified by the compiler.
    //
    // Some internal compiler optimizations use this function.
    //   - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)]
    //     where k is []byte, T1 to Tn is a nesting of struct and array literals.
    //   - Used for "<"+string(b)+">" concatenation where b is []byte.
    //   - Used for string(b)=="foo" comparison where b is []byte.
    gocpp::string slicebytetostringtmp(unsigned char* ptr, int n)
    {
        if(raceenabled && n > 0)
        {
            racereadrangepc(gocpp::unsafe_pointer(ptr), uintptr_t(n), getcallerpc(), abi::FuncPCABIInternal(slicebytetostringtmp));
        }
        if(msanenabled && n > 0)
        {
            msanread(gocpp::unsafe_pointer(ptr), uintptr_t(n));
        }
        if(asanenabled && n > 0)
        {
            asanread(gocpp::unsafe_pointer(ptr), uintptr_t(n));
        }
        return unsafe::String(ptr, n);
    }

    gocpp::slice<unsigned char> stringtoslicebyte(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::string s)
    {
        gocpp::slice<unsigned char> b = {};
        if(buf != nullptr && len(s) <= len(buf))
        {
            *buf = runtime::tmpBuf {};
            b = buf.make_slice(0, len(s));
        }
        else
        {
            b = rawbyteslice(len(s));
        }
        copy(b, s);
        return b;
    }

    gocpp::slice<gocpp::rune> stringtoslicerune(gocpp::array_ptr<gocpp::array<gocpp::rune, tmpStringBufSize>> buf, gocpp::string s)
    {
        auto n = 0;
        for(const auto& _ : s)
        {
            n++;
        }
        gocpp::slice<gocpp::rune> a = {};
        if(buf != nullptr && n <= len(buf))
        {
            *buf = gocpp::array<gocpp::rune, tmpStringBufSize> {};
            a = buf.make_slice(0, n);
        }
        else
        {
            a = rawruneslice(n);
        }
        n = 0;
        for(auto [gocpp_ignored, r] : s)
        {
            a[n] = r;
            n++;
        }
        return a;
    }

    gocpp::string slicerunetostring(gocpp::array_ptr<golang::runtime::tmpBuf> buf, gocpp::slice<gocpp::rune> a)
    {
        if(raceenabled && len(a) > 0)
        {
            racereadrangepc(gocpp::unsafe_pointer(& a[0]), uintptr_t(len(a)) * gocpp::Sizeof<gocpp::rune>(), getcallerpc(), abi::FuncPCABIInternal(slicerunetostring));
        }
        if(msanenabled && len(a) > 0)
        {
            msanread(gocpp::unsafe_pointer(& a[0]), uintptr_t(len(a)) * gocpp::Sizeof<gocpp::rune>());
        }
        if(asanenabled && len(a) > 0)
        {
            asanread(gocpp::unsafe_pointer(& a[0]), uintptr_t(len(a)) * gocpp::Sizeof<gocpp::rune>());
        }
        gocpp::array<unsigned char, 4> dum = {};
        auto size1 = 0;
        for(auto [gocpp_ignored, r] : a)
        {
            size1 += encoderune(dum.make_slice(0), r);
        }
        auto [s, b] = rawstringtmp(buf, size1 + 3);
        auto size2 = 0;
        for(auto [gocpp_ignored, r] : a)
        {
            if(size2 >= size1)
            {
                break;
            }
            size2 += encoderune(b.make_slice(size2), r);
        }
        return s.make_slice(0, size2);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    stringStruct::operator T()
    {
        T result;
        result.str = this->str;
        result.len = this->len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stringStruct::operator==(const T& ref) const
    {
        if (str != ref.str) return false;
        if (len != ref.len) return false;
        return true;
    }

    std::ostream& stringStruct::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << str;
        os << " " << len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stringStruct& value)
    {
        return value.PrintTo(os);
    }

    // Variant with *byte pointer type for DWARF debugging.
    
    template<typename T> requires gocpp::GoStruct<T>
    stringStructDWARF::operator T()
    {
        T result;
        result.str = this->str;
        result.len = this->len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stringStructDWARF::operator==(const T& ref) const
    {
        if (str != ref.str) return false;
        if (len != ref.len) return false;
        return true;
    }

    std::ostream& stringStructDWARF::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << str;
        os << " " << len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stringStructDWARF& value)
    {
        return value.PrintTo(os);
    }

    struct stringStruct* stringStructOf(gocpp::string* sp)
    {
        return (stringStruct*)(gocpp::unsafe_pointer(sp));
    }

    gocpp::string intstring(gocpp::array_ptr<gocpp::array<unsigned char, 4>> buf, int64_t v)
    {
        gocpp::string s;
        gocpp::slice<unsigned char> b = {};
        if(buf != nullptr)
        {
            b = buf.make_slice(0);
            s = slicebytetostringtmp(& b[0], len(b));
        }
        else
        {
            std::tie(s, b) = rawstring(4);
        }
        if(int64_t(gocpp::rune(v)) != v)
        {
            v = runeError;
        }
        auto n = encoderune(b, gocpp::rune(v));
        return s.make_slice(0, n);
    }

    // rawstring allocates storage for a new string. The returned
    // string and byte slice both refer to the same storage.
    // The storage is not zeroed. Callers should use
    // b to set the string contents and then drop b.
    std::tuple<gocpp::string, gocpp::slice<unsigned char>> rawstring(int size)
    {
        gocpp::string s;
        gocpp::slice<unsigned char> b;
        auto p = mallocgc(uintptr_t(size), nullptr, false);
        return {unsafe::String((unsigned char*)(p), size), unsafe::Slice((unsigned char*)(p), size)};
    }

    // rawbyteslice allocates a new byte slice. The byte slice is not zeroed.
    gocpp::slice<unsigned char> rawbyteslice(int size)
    {
        gocpp::slice<unsigned char> b;
        auto cap = roundupsize(uintptr_t(size), true);
        auto p = mallocgc(cap, nullptr, false);
        if(cap != uintptr_t(size))
        {
            memclrNoHeapPointers(add(p, uintptr_t(size)), cap - uintptr_t(size));
        }
        *(slice*)(gocpp::unsafe_pointer(& b)) = slice {p, size, int(cap)};
        return b;
    }

    // rawruneslice allocates a new rune slice. The rune slice is not zeroed.
    gocpp::slice<gocpp::rune> rawruneslice(int size)
    {
        gocpp::slice<gocpp::rune> b;
        if(uintptr_t(size) > maxAlloc / 4)
        {
            go_throw("out of memory"_s);
        }
        auto mem = roundupsize(uintptr_t(size) * 4, true);
        auto p = mallocgc(mem, nullptr, false);
        if(mem != uintptr_t(size) * 4)
        {
            memclrNoHeapPointers(add(p, uintptr_t(size) * 4), mem - uintptr_t(size) * 4);
        }
        *(slice*)(gocpp::unsafe_pointer(& b)) = slice {p, size, int(mem / 4)};
        return b;
    }

    // used by cmd/cgo
    gocpp::slice<unsigned char> gobytes(unsigned char* p, int n)
    {
        gocpp::slice<unsigned char> b;
        if(n == 0)
        {
            return gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0);
        }
        if(n < 0 || uintptr_t(n) > maxAlloc)
        {
            gocpp::panic(errorString("gobytes: length out of range"_s));
        }
        auto bp = mallocgc(uintptr_t(n), nullptr, false);
        memmove(bp, gocpp::unsafe_pointer(p), uintptr_t(n));
        *(slice*)(gocpp::unsafe_pointer(& b)) = slice {bp, n, n};
        return b;
    }

    // This is exported via linkname to assembly in syscall (for Plan9).
    //
    //go:linkname gostring
    gocpp::string gostring(unsigned char* p)
    {
        auto l = findnull(p);
        if(l == 0)
        {
            return ""_s;
        }
        auto [s, b] = rawstring(l);
        memmove(gocpp::unsafe_pointer(& b[0]), gocpp::unsafe_pointer(p), uintptr_t(l));
        return s;
    }

    // internal_syscall_gostring is a version of gostring for internal/syscall/unix.
    //
    //go:linkname internal_syscall_gostring internal/syscall/unix.gostring
    gocpp::string internal_syscall_gostring(unsigned char* p)
    {
        return gostring(p);
    }

    gocpp::string gostringn(unsigned char* p, int l)
    {
        if(l == 0)
        {
            return ""_s;
        }
        auto [s, b] = rawstring(l);
        memmove(gocpp::unsafe_pointer(& b[0]), gocpp::unsafe_pointer(p), uintptr_t(l));
        return s;
    }

    bool hasPrefix(gocpp::string s, gocpp::string prefix)
    {
        return len(s) >= len(prefix) && s.make_slice(0, len(prefix)) == prefix;
    }

    bool hasSuffix(gocpp::string s, gocpp::string suffix)
    {
        return len(s) >= len(suffix) && s.make_slice(len(s) - len(suffix)) == suffix;
    }

    // atoi64 parses an int64 from a string s.
    // The bool result reports whether s is a number
    // representable by a value of type int64.
    std::tuple<int64_t, bool> atoi64(gocpp::string s)
    {
        if(s == ""_s)
        {
            return {0, false};
        }
        auto neg = false;
        if(s[0] == '-')
        {
            neg = true;
            s = s.make_slice(1);
        }
        auto un = uint64_t(0);
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c < '0' || c > '9')
            {
                return {0, false};
            }
            if(un > maxUint64 / 10)
            {
                return {0, false};
            }
            un *= 10;
            auto un1 = un + uint64_t(c) - '0';
            if(un1 < un)
            {
                return {0, false};
            }
            un = un1;
        }
        if(! neg && un > uint64_t(maxInt64))
        {
            return {0, false};
        }
        if(neg && un > uint64_t(maxInt64) + 1)
        {
            return {0, false};
        }
        auto n = int64_t(un);
        if(neg)
        {
            n = - n;
        }
        return {n, true};
    }

    // atoi is like atoi64 but for integers
    // that fit into an int.
    std::tuple<int, bool> atoi(gocpp::string s)
    {
        if(auto [n, ok] = atoi64(s); n == int64_t(int(n)))
        {
            return {int(n), ok};
        }
        return {0, false};
    }

    // atoi32 is like atoi but for integers
    // that fit into an int32.
    std::tuple<int32_t, bool> atoi32(gocpp::string s)
    {
        if(auto [n, ok] = atoi64(s); n == int64_t(int32_t(n)))
        {
            return {int32_t(n), ok};
        }
        return {0, false};
    }

    // parseByteCount parses a string that represents a count of bytes.
    //
    // s must match the following regular expression:
    //
    //	^[0-9]+(([KMGT]i)?B)?$
    //
    // In other words, an integer byte count with an optional unit
    // suffix. Acceptable suffixes include one of
    // - KiB, MiB, GiB, TiB which represent binary IEC/ISO 80000 units, or
    // - B, which just represents bytes.
    //
    // Returns an int64 because that's what its callers want and receive,
    // but the result is always non-negative.
    std::tuple<int64_t, bool> parseByteCount(gocpp::string s)
    {
        if(s == ""_s)
        {
            return {0, false};
        }
        auto last = s[len(s) - 1];
        if(last >= '0' && last <= '9')
        {
            auto [n, ok] = atoi64(s);
            if(! ok || n < 0)
            {
                return {0, false};
            }
            return {n, ok};
        }
        if(last != 'B' || len(s) < 2)
        {
            return {0, false};
        }
        if(auto c = s[len(s) - 2]; c >= '0' && c <= '9')
        {
            auto [n, ok] = atoi64(s.make_slice(0, len(s) - 1));
            if(! ok || n < 0)
            {
                return {0, false};
            }
            return {n, ok};
        }
        else
        if(c != 'i')
        {
            return {0, false};
        }
        if(len(s) < 4)
        {
            return {0, false};
        }
        auto power = 0;
        //Go switch emulation
        {
            auto condition = s[len(s) - 3];
            int conditionId = -1;
            if(condition == 'K') { conditionId = 0; }
            else if(condition == 'M') { conditionId = 1; }
            else if(condition == 'G') { conditionId = 2; }
            else if(condition == 'T') { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    power = 1;
                    break;
                case 1:
                    power = 2;
                    break;
                case 2:
                    power = 3;
                    break;
                case 3:
                    power = 4;
                    break;
                default:
                    return {0, false};
                    break;
            }
        }
        auto m = uint64_t(1);
        for(auto i = 0; i < power; i++)
        {
            m *= 1024;
        }
        auto [n, ok] = atoi64(s.make_slice(0, len(s) - 3));
        if(! ok || n < 0)
        {
            return {0, false};
        }
        auto un = uint64_t(n);
        if(un > maxUint64 / m)
        {
            return {0, false};
        }
        un *= m;
        if(un > uint64_t(maxInt64))
        {
            return {0, false};
        }
        return {int64_t(un), true};
    }

    //go:nosplit
    int findnull(unsigned char* s)
    {
        if(s == nullptr)
        {
            return 0;
        }
        if(GOOS == "plan9"_s)
        {
            auto p = (gocpp::array_ptr<gocpp::array<unsigned char, maxAlloc / 2 - 1>>)(gocpp::unsafe_pointer(s));
            auto l = 0;
            for(; p[l] != 0; )
            {
                l++;
            }
            return l;
        }
        // pageSize is the unit we scan at a time looking for NULL.
        // It must be the minimum page size for any architecture Go
        // runs on. It's okay (just a minor performance loss) if the
        // actual system page size is larger than this value.
        auto pageSize = 4096;
        auto offset = 0;
        auto ptr = gocpp::unsafe_pointer(s);
        auto safeLen = int(pageSize - uintptr_t(ptr) % pageSize);
        for(; ; )
        {
            auto t = *(gocpp::string*)(gocpp::unsafe_pointer(new stringStruct {ptr, safeLen}));
            if(auto i = bytealg::IndexByteString(t, 0); i != - 1)
            {
                return offset + i;
            }
            ptr = gocpp::unsafe_pointer(uintptr_t(ptr) + uintptr_t(safeLen));
            offset += safeLen;
            safeLen = pageSize;
        }
    }

    int findnullw(uint16_t* s)
    {
        if(s == nullptr)
        {
            return 0;
        }
        auto p = (gocpp::array_ptr<gocpp::array<uint16_t, maxAlloc / 2 / 2 - 1>>)(gocpp::unsafe_pointer(s));
        auto l = 0;
        for(; p[l] != 0; )
        {
            l++;
        }
        return l;
    }

    //go:nosplit
    gocpp::string gostringnocopy(unsigned char* str)
    {
        auto ss = gocpp::Init<stringStruct>([=](auto& x) {
            x.str = gocpp::unsafe_pointer(str);
            x.len = findnull(str);
        });
        auto s = *(gocpp::string*)(gocpp::unsafe_pointer(& ss));
        return s;
    }

    gocpp::string gostringw(uint16_t* strw)
    {
        gocpp::array<unsigned char, 8> buf = {};
        auto str = (gocpp::array_ptr<gocpp::array<uint16_t, maxAlloc / 2 / 2 - 1>>)(gocpp::unsafe_pointer(strw));
        auto n1 = 0;
        for(auto i = 0; str[i] != 0; i++)
        {
            n1 += encoderune(buf.make_slice(0), gocpp::rune(str[i]));
        }
        auto [s, b] = rawstring(n1 + 4);
        auto n2 = 0;
        for(auto i = 0; str[i] != 0; i++)
        {
            if(n2 >= n1)
            {
                break;
            }
            n2 += encoderune(b.make_slice(n2), gocpp::rune(str[i]));
        }
        b[n2] = 0;
        return s.make_slice(0, n2);
    }

}

