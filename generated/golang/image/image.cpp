// generated by GoCpp from file '$(ImportDir)/image/image.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/image.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/image/color/ycbcr.h"
#include "golang/image/geom.h"

// Package image implements a basic 2-D image library.
//
// The fundamental interface is called [Image]. An [Image] contains colors, which
// are described in the image/color package.
//
// Values of the [Image] interface are created either by calling functions such
// as [NewRGBA] and [NewPaletted], or by calling [Decode] on an [io.Reader] containing
// image data in a format such as GIF, JPEG or PNG. Decoding any particular
// image format requires the prior registration of a decoder function.
// Registration is typically automatic as a side effect of initializing that
// format's package so that, to decode a PNG image, it suffices to have
//
//	import _ "image/png"
//
// in a program's main package. The _ means to import a package purely for its
// initialization side effects.
//
// See "The Go image package" for more details:
// https://golang.org/doc/articles/image_package.html
//
// # Security Considerations
//
// The image package can be used to parse arbitrarily large images, which can
// cause resource exhaustion on machines which do not have enough memory to
// store them. When operating on arbitrary images, [DecodeConfig] should be called
// before [Decode], so that the program can decide whether the image, as defined
// in the returned header, can be safely decoded with the available resources. A
// call to [Decode] which produces an extremely large image, as defined in the
// header returned by [DecodeConfig], is not considered a security issue,
// regardless of whether the image is itself malformed or not. A call to
// [DecodeConfig] which returns a header which does not match the image returned
// by [Decode] may be considered a security issue, and should be reported per the
// [Go Security Policy](https://go.dev/security/policy).
namespace golang::image
{
    namespace rec
    {
        using namespace mocklib::rec;
        using color::rec::Convert;
        using color::rec::Index;
        using color::rec::RGBA;
    }

    // Config holds an image's color model and dimensions.
    
    template<typename T> requires gocpp::GoStruct<T>
    Config::operator T()
    {
        T result;
        result.ColorModel = this->ColorModel;
        result.Width = this->Width;
        result.Height = this->Height;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Config::operator==(const T& ref) const
    {
        if (ColorModel != ref.ColorModel) return false;
        if (Width != ref.Width) return false;
        if (Height != ref.Height) return false;
        return true;
    }

    std::ostream& Config::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ColorModel;
        os << " " << Width;
        os << " " << Height;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Config& value)
    {
        return value.PrintTo(os);
    }

    // Image is a finite rectangular grid of [color.Color] values taken from a color
    // model.
    
    template<typename T>
    Image::Image(T& ref)
    {
        value.reset(new ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Image::Image(const T& ref)
    {
        value.reset(new ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Image::Image(T* ptr)
    {
        value.reset(new ImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Image::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    color::Model Image::ImageImpl<T, StoreT>::vColorModel()
    {
        return rec::ColorModel(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Rectangle Image::ImageImpl<T, StoreT>::vBounds()
    {
        return rec::Bounds(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    color::Color Image::ImageImpl<T, StoreT>::vAt(int x, int y)
    {
        return rec::At(gocpp::PtrRecv<T, false>(value.get()), x, y);
    }

    namespace rec
    {
        color::Model ColorModel(const gocpp::PtrRecv<struct Image, false>& self)
        {
            return self.ptr->value->vColorModel();
        }

        color::Model ColorModel(const gocpp::ObjRecv<struct Image>& self)
        {
            return self.obj.value->vColorModel();
        }

        struct Rectangle Bounds(const gocpp::PtrRecv<struct Image, false>& self)
        {
            return self.ptr->value->vBounds();
        }

        struct Rectangle Bounds(const gocpp::ObjRecv<struct Image>& self)
        {
            return self.obj.value->vBounds();
        }

        color::Color At(const gocpp::PtrRecv<struct Image, false>& self, int x, int y)
        {
            return self.ptr->value->vAt(x, y);
        }

        color::Color At(const gocpp::ObjRecv<struct Image>& self, int x, int y)
        {
            return self.obj.value->vAt(x, y);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Image& value)
    {
        return value.PrintTo(os);
    }

    // RGBA64Image is an [Image] whose pixels can be converted directly to a
    // color.RGBA64.
    
    template<typename T>
    RGBA64Image::RGBA64Image(T& ref)
    {
        value.reset(new RGBA64ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RGBA64Image::RGBA64Image(const T& ref)
    {
        value.reset(new RGBA64ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RGBA64Image::RGBA64Image(T* ptr)
    {
        value.reset(new RGBA64ImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RGBA64Image::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    color::RGBA64 RGBA64Image::RGBA64ImageImpl<T, StoreT>::vRGBA64At(int x, int y)
    {
        return rec::RGBA64At(gocpp::PtrRecv<T, false>(value.get()), x, y);
    }

    namespace rec
    {
        color::RGBA64 RGBA64At(const gocpp::PtrRecv<struct RGBA64Image, false>& self, int x, int y)
        {
            return self.ptr->value->vRGBA64At(x, y);
        }

        color::RGBA64 RGBA64At(const gocpp::ObjRecv<struct RGBA64Image>& self, int x, int y)
        {
            return self.obj.value->vRGBA64At(x, y);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64Image& value)
    {
        return value.PrintTo(os);
    }

    // PalettedImage is an image whose colors may come from a limited palette.
    // If m is a PalettedImage and m.ColorModel() returns a [color.Palette] p,
    // then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's
    // color model is not a color.Palette, then ColorIndexAt's behavior is
    // undefined.
    
    template<typename T>
    PalettedImage::PalettedImage(T& ref)
    {
        value.reset(new PalettedImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    PalettedImage::PalettedImage(const T& ref)
    {
        value.reset(new PalettedImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    PalettedImage::PalettedImage(T* ptr)
    {
        value.reset(new PalettedImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& PalettedImage::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint8_t PalettedImage::PalettedImageImpl<T, StoreT>::vColorIndexAt(int x, int y)
    {
        return rec::ColorIndexAt(gocpp::PtrRecv<T, false>(value.get()), x, y);
    }

    namespace rec
    {
        uint8_t ColorIndexAt(const gocpp::PtrRecv<struct PalettedImage, false>& self, int x, int y)
        {
            return self.ptr->value->vColorIndexAt(x, y);
        }

        uint8_t ColorIndexAt(const gocpp::ObjRecv<struct PalettedImage>& self, int x, int y)
        {
            return self.obj.value->vColorIndexAt(x, y);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct PalettedImage& value)
    {
        return value.PrintTo(os);
    }

    // pixelBufferLength returns the length of the []uint8 typed Pix slice field
    // for the NewXxx functions. Conceptually, this is just (bpp * width * height),
    // but this function panics if at least one of those is negative or if the
    // computation would overflow the int type.
    //
    // This panics instead of returning an error because of backwards
    // compatibility. The NewXxx functions do not return an error.
    int pixelBufferLength(int bytesPerPixel, struct Rectangle r, gocpp::string imageTypeName)
    {
        auto totalLength = mul3NonNeg(bytesPerPixel, rec::Dx(gocpp::recv(r)), rec::Dy(gocpp::recv(r)));
        if(totalLength < 0)
        {
            gocpp::panic("image: New"_s + imageTypeName + " Rectangle has huge or negative dimensions"_s);
        }
        return totalLength;
    }

    // RGBA is an in-memory image whose At method returns [color.RGBA] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    RGBA::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RGBA::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& RGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::RGBA* p)
    {
        return color::RGBAModel;
    }

    struct Rectangle rec::Bounds(golang::image::RGBA* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::RGBA* p, int x, int y)
    {
        return rec::RGBAAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::RGBA* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        auto r = uint16_t(s[0]);
        auto g = uint16_t(s[1]);
        auto b = uint16_t(s[2]);
        auto a = uint16_t(s[3]);
        return color::RGBA64 {(r << 8) | r, (g << 8) | g, (b << 8) | b, (a << 8) | a};
    }

    color::RGBA rec::RGBAAt(golang::image::RGBA* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::RGBA {s[0], s[1], s[2], s[3]};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::RGBA* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void rec::Set(golang::image::RGBA* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::RGBA>(rec::Convert(gocpp::recv(color::RGBAModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.R;
        s[1] = c1.G;
        s[2] = c1.B;
        s[3] = c1.A;
    }

    void rec::SetRGBA64(golang::image::RGBA* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = uint8_t(c.R >> 8);
        s[1] = uint8_t(c.G >> 8);
        s[2] = uint8_t(c.B >> 8);
        s[3] = uint8_t(c.A >> 8);
    }

    void rec::SetRGBA(golang::image::RGBA* p, int x, int y, color::RGBA c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c.R;
        s[1] = c.G;
        s[2] = c.B;
        s[3] = c.A;
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::RGBA* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new RGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<RGBA>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::RGBA* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{3, rec::Dx(gocpp::recv(p->Rect)) * 4};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 4)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    // NewRGBA returns a new [RGBA] image with the given bounds.
    struct RGBA* NewRGBA(struct Rectangle r)
    {
        return gocpp::InitPtr<RGBA>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "RGBA"_s));
            x.Stride = 4 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // RGBA64 is an in-memory image whose At method returns [color.RGBA64] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    RGBA64::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RGBA64::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& RGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::RGBA64* p)
    {
        return color::RGBA64Model;
    }

    struct Rectangle rec::Bounds(golang::image::RGBA64* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::RGBA64* p, int x, int y)
    {
        return rec::RGBA64At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::RGBA64* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        return color::RGBA64 {(uint16_t(s[0]) << 8) | uint16_t(s[1]), (uint16_t(s[2]) << 8) | uint16_t(s[3]), (uint16_t(s[4]) << 8) | uint16_t(s[5]), (uint16_t(s[6]) << 8) | uint16_t(s[7])};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::RGBA64* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 8;
    }

    void rec::Set(golang::image::RGBA64* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::RGBA64>(rec::Convert(gocpp::recv(color::RGBA64Model), c));
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c1.R >> 8);
        s[1] = uint8_t(c1.R);
        s[2] = uint8_t(c1.G >> 8);
        s[3] = uint8_t(c1.G);
        s[4] = uint8_t(c1.B >> 8);
        s[5] = uint8_t(c1.B);
        s[6] = uint8_t(c1.A >> 8);
        s[7] = uint8_t(c1.A);
    }

    void rec::SetRGBA64(golang::image::RGBA64* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c.R >> 8);
        s[1] = uint8_t(c.R);
        s[2] = uint8_t(c.G >> 8);
        s[3] = uint8_t(c.G);
        s[4] = uint8_t(c.B >> 8);
        s[5] = uint8_t(c.B);
        s[6] = uint8_t(c.A >> 8);
        s[7] = uint8_t(c.A);
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::RGBA64* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new RGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<RGBA64>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::RGBA64* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{6, rec::Dx(gocpp::recv(p->Rect)) * 8};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 8)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    // NewRGBA64 returns a new [RGBA64] image with the given bounds.
    struct RGBA64* NewRGBA64(struct Rectangle r)
    {
        return gocpp::InitPtr<RGBA64>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(8, r, "RGBA64"_s));
            x.Stride = 8 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // NRGBA is an in-memory image whose At method returns [color.NRGBA] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    NRGBA::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NRGBA::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& NRGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::NRGBA* p)
    {
        return color::NRGBAModel;
    }

    struct Rectangle rec::Bounds(golang::image::NRGBA* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::NRGBA* p, int x, int y)
    {
        return rec::NRGBAAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::NRGBA* p, int x, int y)
    {
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(rec::NRGBAAt(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::NRGBA rec::NRGBAAt(golang::image::NRGBA* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::NRGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::NRGBA {s[0], s[1], s[2], s[3]};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::NRGBA* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void rec::Set(golang::image::NRGBA* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::NRGBA>(rec::Convert(gocpp::recv(color::NRGBAModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.R;
        s[1] = c1.G;
        s[2] = c1.B;
        s[3] = c1.A;
    }

    void rec::SetRGBA64(golang::image::NRGBA* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [r, g, b, a] = std::tuple{uint32_t(c.R), uint32_t(c.G), uint32_t(c.B), uint32_t(c.A)};
        if((a != 0) && (a != 0xffff))
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = uint8_t(r >> 8);
        s[1] = uint8_t(g >> 8);
        s[2] = uint8_t(b >> 8);
        s[3] = uint8_t(a >> 8);
    }

    void rec::SetNRGBA(golang::image::NRGBA* p, int x, int y, color::NRGBA c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c.R;
        s[1] = c.G;
        s[2] = c.B;
        s[3] = c.A;
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::NRGBA* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new NRGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<NRGBA>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::NRGBA* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{3, rec::Dx(gocpp::recv(p->Rect)) * 4};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 4)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    // NewNRGBA returns a new [NRGBA] image with the given bounds.
    struct NRGBA* NewNRGBA(struct Rectangle r)
    {
        return gocpp::InitPtr<NRGBA>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "NRGBA"_s));
            x.Stride = 4 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // NRGBA64 is an in-memory image whose At method returns [color.NRGBA64] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    NRGBA64::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NRGBA64::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& NRGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::NRGBA64* p)
    {
        return color::NRGBA64Model;
    }

    struct Rectangle rec::Bounds(golang::image::NRGBA64* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::NRGBA64* p, int x, int y)
    {
        return rec::NRGBA64At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::NRGBA64* p, int x, int y)
    {
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(rec::NRGBA64At(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::NRGBA64 rec::NRGBA64At(golang::image::NRGBA64* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::NRGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        return color::NRGBA64 {(uint16_t(s[0]) << 8) | uint16_t(s[1]), (uint16_t(s[2]) << 8) | uint16_t(s[3]), (uint16_t(s[4]) << 8) | uint16_t(s[5]), (uint16_t(s[6]) << 8) | uint16_t(s[7])};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::NRGBA64* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 8;
    }

    void rec::Set(golang::image::NRGBA64* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::NRGBA64>(rec::Convert(gocpp::recv(color::NRGBA64Model), c));
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c1.R >> 8);
        s[1] = uint8_t(c1.R);
        s[2] = uint8_t(c1.G >> 8);
        s[3] = uint8_t(c1.G);
        s[4] = uint8_t(c1.B >> 8);
        s[5] = uint8_t(c1.B);
        s[6] = uint8_t(c1.A >> 8);
        s[7] = uint8_t(c1.A);
    }

    void rec::SetRGBA64(golang::image::NRGBA64* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [r, g, b, a] = std::tuple{uint32_t(c.R), uint32_t(c.G), uint32_t(c.B), uint32_t(c.A)};
        if((a != 0) && (a != 0xffff))
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(r >> 8);
        s[1] = uint8_t(r);
        s[2] = uint8_t(g >> 8);
        s[3] = uint8_t(g);
        s[4] = uint8_t(b >> 8);
        s[5] = uint8_t(b);
        s[6] = uint8_t(a >> 8);
        s[7] = uint8_t(a);
    }

    void rec::SetNRGBA64(golang::image::NRGBA64* p, int x, int y, color::NRGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c.R >> 8);
        s[1] = uint8_t(c.R);
        s[2] = uint8_t(c.G >> 8);
        s[3] = uint8_t(c.G);
        s[4] = uint8_t(c.B >> 8);
        s[5] = uint8_t(c.B);
        s[6] = uint8_t(c.A >> 8);
        s[7] = uint8_t(c.A);
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::NRGBA64* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new NRGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<NRGBA64>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::NRGBA64* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{6, rec::Dx(gocpp::recv(p->Rect)) * 8};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 8)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    // NewNRGBA64 returns a new [NRGBA64] image with the given bounds.
    struct NRGBA64* NewNRGBA64(struct Rectangle r)
    {
        return gocpp::InitPtr<NRGBA64>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(8, r, "NRGBA64"_s));
            x.Stride = 8 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // Alpha is an in-memory image whose At method returns [color.Alpha] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    Alpha::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Alpha::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Alpha::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::Alpha* p)
    {
        return color::AlphaModel;
    }

    struct Rectangle rec::Bounds(golang::image::Alpha* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::Alpha* p, int x, int y)
    {
        return rec::AlphaAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::Alpha* p, int x, int y)
    {
        auto a = uint16_t(rec::AlphaAt(gocpp::recv(p), x, y).A);
        a |= a << 8;
        return color::RGBA64 {a, a, a, a};
    }

    color::Alpha rec::AlphaAt(golang::image::Alpha* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Alpha {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Alpha {p->Pix[i]};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::Alpha* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void rec::Set(golang::image::Alpha* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = gocpp::getValue<color::Alpha>(rec::Convert(gocpp::recv(color::AlphaModel), c)).A;
    }

    void rec::SetRGBA64(golang::image::Alpha* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(c.A >> 8);
    }

    void rec::SetAlpha(golang::image::Alpha* p, int x, int y, color::Alpha c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = c.A;
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::Alpha* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Alpha {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Alpha>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::Alpha* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{0, rec::Dx(gocpp::recv(p->Rect))};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i++)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    // NewAlpha returns a new [Alpha] image with the given bounds.
    struct Alpha* NewAlpha(struct Rectangle r)
    {
        return gocpp::InitPtr<Alpha>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Alpha"_s));
            x.Stride = 1 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // Alpha16 is an in-memory image whose At method returns [color.Alpha16] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    Alpha16::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Alpha16::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Alpha16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::Alpha16* p)
    {
        return color::Alpha16Model;
    }

    struct Rectangle rec::Bounds(golang::image::Alpha16* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::Alpha16* p, int x, int y)
    {
        return rec::Alpha16At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::Alpha16* p, int x, int y)
    {
        auto a = rec::Alpha16At(gocpp::recv(p), x, y).A;
        return color::RGBA64 {a, a, a, a};
    }

    color::Alpha16 rec::Alpha16At(golang::image::Alpha16* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Alpha16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Alpha16 {(uint16_t(p->Pix[i + 0]) << 8) | uint16_t(p->Pix[i + 1])};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::Alpha16* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 2;
    }

    void rec::Set(golang::image::Alpha16* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::Alpha16>(rec::Convert(gocpp::recv(color::Alpha16Model), c));
        p->Pix[i + 0] = uint8_t(c1.A >> 8);
        p->Pix[i + 1] = uint8_t(c1.A);
    }

    void rec::SetRGBA64(golang::image::Alpha16* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c.A >> 8);
        p->Pix[i + 1] = uint8_t(c.A);
    }

    void rec::SetAlpha16(golang::image::Alpha16* p, int x, int y, color::Alpha16 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c.A >> 8);
        p->Pix[i + 1] = uint8_t(c.A);
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::Alpha16* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Alpha16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Alpha16>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::Alpha16* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{0, rec::Dx(gocpp::recv(p->Rect)) * 2};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 2)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    // NewAlpha16 returns a new [Alpha16] image with the given bounds.
    struct Alpha16* NewAlpha16(struct Rectangle r)
    {
        return gocpp::InitPtr<Alpha16>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(2, r, "Alpha16"_s));
            x.Stride = 2 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // Gray is an in-memory image whose At method returns [color.Gray] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    Gray::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Gray::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Gray::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::Gray* p)
    {
        return color::GrayModel;
    }

    struct Rectangle rec::Bounds(golang::image::Gray* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::Gray* p, int x, int y)
    {
        return rec::GrayAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::Gray* p, int x, int y)
    {
        auto gray = uint16_t(rec::GrayAt(gocpp::recv(p), x, y).Y);
        gray |= gray << 8;
        return color::RGBA64 {gray, gray, gray, 0xffff};
    }

    color::Gray rec::GrayAt(golang::image::Gray* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Gray {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Gray {p->Pix[i]};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::Gray* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void rec::Set(golang::image::Gray* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = gocpp::getValue<color::Gray>(rec::Convert(gocpp::recv(color::GrayModel), c)).Y;
    }

    void rec::SetRGBA64(golang::image::Gray* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto gray = (19595 * uint32_t(c.R) + 38470 * uint32_t(c.G) + 7471 * uint32_t(c.B) + (1 << 15)) >> 24;
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(gray);
    }

    void rec::SetGray(golang::image::Gray* p, int x, int y, color::Gray c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = c.Y;
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::Gray* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Gray {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Gray>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::Gray* p)
    {
        return true;
    }

    // NewGray returns a new [Gray] image with the given bounds.
    struct Gray* NewGray(struct Rectangle r)
    {
        return gocpp::InitPtr<Gray>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Gray"_s));
            x.Stride = 1 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // Gray16 is an in-memory image whose At method returns [color.Gray16] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    Gray16::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Gray16::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Gray16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::Gray16* p)
    {
        return color::Gray16Model;
    }

    struct Rectangle rec::Bounds(golang::image::Gray16* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::Gray16* p, int x, int y)
    {
        return rec::Gray16At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::Gray16* p, int x, int y)
    {
        auto gray = rec::Gray16At(gocpp::recv(p), x, y).Y;
        return color::RGBA64 {gray, gray, gray, 0xffff};
    }

    color::Gray16 rec::Gray16At(golang::image::Gray16* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Gray16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Gray16 {(uint16_t(p->Pix[i + 0]) << 8) | uint16_t(p->Pix[i + 1])};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::Gray16* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 2;
    }

    void rec::Set(golang::image::Gray16* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::Gray16>(rec::Convert(gocpp::recv(color::Gray16Model), c));
        p->Pix[i + 0] = uint8_t(c1.Y >> 8);
        p->Pix[i + 1] = uint8_t(c1.Y);
    }

    void rec::SetRGBA64(golang::image::Gray16* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto gray = (19595 * uint32_t(c.R) + 38470 * uint32_t(c.G) + 7471 * uint32_t(c.B) + (1 << 15)) >> 16;
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(gray >> 8);
        p->Pix[i + 1] = uint8_t(gray);
    }

    void rec::SetGray16(golang::image::Gray16* p, int x, int y, color::Gray16 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c.Y >> 8);
        p->Pix[i + 1] = uint8_t(c.Y);
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::Gray16* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Gray16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Gray16>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::Gray16* p)
    {
        return true;
    }

    // NewGray16 returns a new [Gray16] image with the given bounds.
    struct Gray16* NewGray16(struct Rectangle r)
    {
        return gocpp::InitPtr<Gray16>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(2, r, "Gray16"_s));
            x.Stride = 2 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // CMYK is an in-memory image whose At method returns [color.CMYK] values.
    
    template<typename T> requires gocpp::GoStruct<T>
    CMYK::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CMYK::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& CMYK::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::CMYK* p)
    {
        return color::CMYKModel;
    }

    struct Rectangle rec::Bounds(golang::image::CMYK* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::CMYK* p, int x, int y)
    {
        return rec::CMYKAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(golang::image::CMYK* p, int x, int y)
    {
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(rec::CMYKAt(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::CMYK rec::CMYKAt(golang::image::CMYK* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::CMYK {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::CMYK {s[0], s[1], s[2], s[3]};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::CMYK* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void rec::Set(golang::image::CMYK* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::CMYK>(rec::Convert(gocpp::recv(color::CMYKModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.C;
        s[1] = c1.M;
        s[2] = c1.Y;
        s[3] = c1.K;
    }

    void rec::SetRGBA64(golang::image::CMYK* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [cc, mm, yy, kk] = color::RGBToCMYK(uint8_t(c.R >> 8), uint8_t(c.G >> 8), uint8_t(c.B >> 8));
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = cc;
        s[1] = mm;
        s[2] = yy;
        s[3] = kk;
    }

    void rec::SetCMYK(golang::image::CMYK* p, int x, int y, color::CMYK c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c.C;
        s[1] = c.M;
        s[2] = c.Y;
        s[3] = c.K;
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::CMYK* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new CMYK {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<CMYK>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::CMYK* p)
    {
        return true;
    }

    // NewCMYK returns a new CMYK image with the given bounds.
    struct CMYK* NewCMYK(struct Rectangle r)
    {
        return gocpp::InitPtr<CMYK>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "CMYK"_s));
            x.Stride = 4 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    // Paletted is an in-memory image of uint8 indices into a given palette.
    
    template<typename T> requires gocpp::GoStruct<T>
    Paletted::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        result.Palette = this->Palette;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Paletted::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        if (Palette != ref.Palette) return false;
        return true;
    }

    std::ostream& Paletted::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << " " << Palette;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Paletted& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(golang::image::Paletted* p)
    {
        return p->Palette;
    }

    struct Rectangle rec::Bounds(golang::image::Paletted* p)
    {
        return p->Rect;
    }

    color::Color rec::At(golang::image::Paletted* p, int x, int y)
    {
        if(len(p->Palette) == 0)
        {
            return nullptr;
        }
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return p->Palette[0];
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return p->Palette[p->Pix[i]];
    }

    color::RGBA64 rec::RGBA64At(golang::image::Paletted* p, int x, int y)
    {
        if(len(p->Palette) == 0)
        {
            return color::RGBA64 {};
        }
        auto c = color::Color(nullptr);
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            c = p->Palette[0];
        }
        else
        {
            auto i = rec::PixOffset(gocpp::recv(p), x, y);
            c = p->Palette[p->Pix[i]];
        }
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(c));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    // PixOffset returns the index of the first element of Pix that corresponds to
    // the pixel at (x, y).
    int rec::PixOffset(golang::image::Paletted* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void rec::Set(golang::image::Paletted* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(rec::Index(gocpp::recv(p->Palette), c));
    }

    void rec::SetRGBA64(golang::image::Paletted* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(rec::Index(gocpp::recv(p->Palette), c));
    }

    uint8_t rec::ColorIndexAt(golang::image::Paletted* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return 0;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return p->Pix[i];
    }

    void rec::SetColorIndex(golang::image::Paletted* p, int x, int y, uint8_t index)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = index;
    }

    // SubImage returns an image representing the portion of the image p visible
    // through r. The returned value shares pixels with the original image.
    struct Image rec::SubImage(golang::image::Paletted* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return gocpp::InitPtr<Paletted>([=](auto& x) {
                x.Palette = p->Palette;
            });
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Paletted>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = rec::Intersect(gocpp::recv(p->Rect), r);
            x.Palette = p->Palette;
        });
    }

    // Opaque scans the entire image and reports whether it is fully opaque.
    bool rec::Opaque(golang::image::Paletted* p)
    {
        gocpp::array<bool, 256> present = {};
        auto [i0, i1] = std::tuple{0, rec::Dx(gocpp::recv(p->Rect))};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto [gocpp_ignored, c] : p->Pix.make_slice(i0, i1))
            {
                present[c] = true;
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        for(auto [i, c] : p->Palette)
        {
            if(! present[i])
            {
                continue;
            }
            auto [gocpp_id_0, gocpp_id_1, gocpp_id_2, a] = rec::RGBA(gocpp::recv(c));
            if(a != 0xffff)
            {
                return false;
            }
        }
        return true;
    }

    // NewPaletted returns a new [Paletted] image with the given width, height and
    // palette.
    struct Paletted* NewPaletted(struct Rectangle r, color::Palette p)
    {
        return gocpp::InitPtr<Paletted>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Paletted"_s));
            x.Stride = 1 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
            x.Palette = p;
        });
    }

}

