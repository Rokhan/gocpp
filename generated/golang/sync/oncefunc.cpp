// generated by GoCpp from file '$(ImportDir)/sync/oncefunc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/oncefunc.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

namespace golang::sync
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace atomic::rec;
        using namespace sync::rec;
    }

    std::function<void ()> OnceFunc(std::function<void ()> f)
    {
        Once once = {};
        bool valid = {};
        go_any p = {};
        auto g = [=]() mutable -> void
        {
            gocpp::Defer defer;
            try
            {
                defer.push_back([=]{ [=]() mutable -> void
                {
                    p = gocpp::recover();
                    if(! valid)
                    {
                        gocpp::panic(p);
                    }
                }(); });
                f();
                f = nullptr;
                valid = true;
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        };
        return [=]() mutable -> void
        {
            rec::Do(gocpp::recv(once), g);
            if(! valid)
            {
                gocpp::panic(p);
            }
        };
    }


    template<typename T>
    std::function<T ()> OnceValue(std::function<T ()> f)
    {
        Once once = {};
        bool valid = {};
        go_any p = {};
        T result = {};
        auto g = [=]() mutable -> void
        {
            gocpp::Defer defer;
            try
            {
                defer.push_back([=]{ [=]() mutable -> void
                {
                    p = gocpp::recover();
                    if(! valid)
                    {
                        gocpp::panic(p);
                    }
                }(); });
                result = f();
                f = nullptr;
                valid = true;
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        };
        return [=]() mutable -> T
        {
            rec::Do(gocpp::recv(once), g);
            if(! valid)
            {
                gocpp::panic(p);
            }
            return result;
        };
    }


    template<typename T1, typename T2>
    std::function<std::tuple<T1, T2> ()> OnceValues(std::function<std::tuple<T1, T2> ()> f)
    {
        Once once = {};
        bool valid = {};
        go_any p = {};
        T1 r1 = {};
        T2 r2 = {};
        auto g = [=]() mutable -> void
        {
            gocpp::Defer defer;
            try
            {
                defer.push_back([=]{ [=]() mutable -> void
                {
                    p = gocpp::recover();
                    if(! valid)
                    {
                        gocpp::panic(p);
                    }
                }(); });
                std::tie(r1, r2) = f();
                f = nullptr;
                valid = true;
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        };
        return [=]() mutable -> std::tuple<T1, T2>
        {
            rec::Do(gocpp::recv(once), g);
            if(! valid)
            {
                gocpp::panic(p);
            }
            return {r1, r2};
        };
    }

}

