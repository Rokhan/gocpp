// generated by GoCpp from file '$(ImportDir)/runtime/time.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/time.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/netpoll.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // Package time knows the layout of this structure.
    // If this struct changes, adjust ../time/sleep.go:/runtimeTimer.
    
    template<typename T> requires gocpp::GoStruct<T>
    timer::operator T()
    {
        T result;
        result.pp = this->pp;
        result.when = this->when;
        result.period = this->period;
        result.f = this->f;
        result.arg = this->arg;
        result.seq = this->seq;
        result.nextwhen = this->nextwhen;
        result.status = this->status;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool timer::operator==(const T& ref) const
    {
        if (pp != ref.pp) return false;
        if (when != ref.when) return false;
        if (period != ref.period) return false;
        if (f != ref.f) return false;
        if (arg != ref.arg) return false;
        if (seq != ref.seq) return false;
        if (nextwhen != ref.nextwhen) return false;
        if (status != ref.status) return false;
        return true;
    }

    std::ostream& timer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pp;
        os << " " << when;
        os << " " << period;
        os << " " << f;
        os << " " << arg;
        os << " " << seq;
        os << " " << nextwhen;
        os << " " << status;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct timer& value)
    {
        return value.PrintTo(os);
    }

    // Values for the timer status field.
    // Timer has no status set yet.
    // Waiting for timer to fire.
    // The timer is in some P's heap.
    // Running the timer function.
    // A timer will only have this status briefly.
    // The timer is deleted and should be removed.
    // It should not be run, but it is still in some P's heap.
    // The timer is being removed.
    // The timer will only have this status briefly.
    // The timer has been stopped.
    // It is not in any P's heap.
    // The timer is being modified.
    // The timer will only have this status briefly.
    // The timer has been modified to an earlier time.
    // The new when value is in the nextwhen field.
    // The timer is in some P's heap, possibly in the wrong place.
    // The timer has been modified to the same or a later time.
    // The new when value is in the nextwhen field.
    // The timer is in some P's heap, possibly in the wrong place.
    // The timer has been modified and is being moved.
    // The timer will only have this status briefly.
    // maxWhen is the maximum value for timer's when field.
    // verifyTimers can be set to true to add debugging checks that the
    // timer heaps are valid.
    // timeSleep puts the current goroutine to sleep for at least ns nanoseconds.
    //
    //go:linkname timeSleep time.Sleep
    void timeSleep(int64_t ns)
    {
        if(ns <= 0)
        {
            return;
        }
        auto gp = getg();
        auto t = gp->timer;
        if(t == nullptr)
        {
            t = new(timer);
            gp->timer = t;
        }
        t->f = goroutineReady;
        t->arg = gp;
        t->nextwhen = nanotime() + ns;
        if(t->nextwhen < 0)
        {
            t->nextwhen = maxWhen;
        }
        gopark(resetForSleep, unsafe::Pointer(t), waitReasonSleep, traceBlockSleep, 1);
    }

    // resetForSleep is called after the goroutine is parked for timeSleep.
    // We can't call resettimer in timeSleep itself because if this is a short
    // sleep and there are many goroutines then the P can wind up running the
    // timer function, goroutineReady, before the goroutine has been parked.
    bool resetForSleep(struct g* gp, unsafe::Pointer ut)
    {
        auto t = (timer*)(ut);
        resettimer(t, t->nextwhen);
        return true;
    }

    // startTimer adds t to the timer heap.
    //
    //go:linkname startTimer time.startTimer
    void startTimer(struct timer* t)
    {
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(t));
        }
        addtimer(t);
    }

    // stopTimer stops a timer.
    // It reports whether t was stopped before being run.
    //
    //go:linkname stopTimer time.stopTimer
    bool stopTimer(struct timer* t)
    {
        return deltimer(t);
    }

    // resetTimer resets an inactive timer, adding it to the heap.
    //
    // Reports whether the timer was modified before it was run.
    //
    //go:linkname resetTimer time.resetTimer
    bool resetTimer(struct timer* t, int64_t when)
    {
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(t));
        }
        return resettimer(t, when);
    }

    // modTimer modifies an existing timer.
    //
    //go:linkname modTimer time.modTimer
    void modTimer(struct timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq)
    {
        modtimer(t, when, period, f, arg, seq);
    }

    // Ready the goroutine arg.
    void goroutineReady(go_any arg, uintptr_t seq)
    {
        goready(gocpp::getValue<g*>(arg), 0);
    }

    // Note: this changes some unsynchronized operations to synchronized operations
    // addtimer adds a timer to the current P.
    // This should only be called with a newly created timer.
    // That avoids the risk of changing the when field of a timer in some P's heap,
    // which could cause the heap to become unsorted.
    void addtimer(struct timer* t)
    {
        if(t->when <= 0)
        {
            go_throw("timer when must be positive"s);
        }
        if(t->period < 0)
        {
            go_throw("timer period must be non-negative"s);
        }
        if(rec::Load(gocpp::recv(t->status)) != timerNoStatus)
        {
            go_throw("addtimer called with initialized timer"s);
        }
        rec::Store(gocpp::recv(t->status), timerWaiting);
        auto when = t->when;
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(getg()->m->p));
        lock(& pp->timersLock);
        cleantimers(pp);
        doaddtimer(pp, t);
        unlock(& pp->timersLock);
        wakeNetPoller(when);
        releasem(mp);
    }

    // doaddtimer adds t to the current P's heap.
    // The caller must have locked the timers for pp.
    void doaddtimer(struct p* pp, struct timer* t)
    {
        if(rec::Load(gocpp::recv(netpollInited)) == 0)
        {
            netpollGenericInit();
        }
        if(t->pp != 0)
        {
            go_throw("doaddtimer: P already set in timer"s);
        }
        rec::set(gocpp::recv(t->pp), pp);
        auto i = len(pp->timers);
        pp->timers = append(pp->timers, t);
        siftupTimer(pp->timers, i);
        if(t == pp->timers[0])
        {
            rec::Store(gocpp::recv(pp->timer0When), t->when);
        }
        rec::Add(gocpp::recv(pp->numTimers), 1);
    }

    // deltimer deletes the timer t. It may be on some other P, so we can't
    // actually remove it from the timers heap. We can only mark it as deleted.
    // It will be removed in due course by the P whose heap it is on.
    // Reports whether the timer was removed before it was run.
    bool deltimer(struct timer* t)
    {
        for(; ; )
        {
            //Go switch emulation
            {
                auto s = rec::Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerWaiting) { conditionId = 0; }
                else if(condition == timerModifiedLater) { conditionId = 1; }
                else if(condition == timerModifiedEarlier) { conditionId = 2; }
                else if(condition == timerDeleted) { conditionId = 3; }
                else if(condition == timerRemoving) { conditionId = 4; }
                else if(condition == timerRemoved) { conditionId = 5; }
                else if(condition == timerRunning) { conditionId = 6; }
                else if(condition == timerMoving) { conditionId = 7; }
                else if(condition == timerNoStatus) { conditionId = 8; }
                else if(condition == timerModifying) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        auto mp = acquirem();
                        if(rec::CompareAndSwap(gocpp::recv(t->status), s, timerModifying))
                        {
                            auto tpp = rec::ptr(gocpp::recv(t->pp));
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerModifying, timerDeleted))
                            {
                                badTimer();
                            }
                            releasem(mp);
                            rec::Add(gocpp::recv(tpp->deletedTimers), 1);
                            return true;
                        }
                        else
                        {
                            releasem(mp);
                        }
                        break;
                    case 2:
                        auto mp = acquirem();
                        if(rec::CompareAndSwap(gocpp::recv(t->status), s, timerModifying))
                        {
                            auto tpp = rec::ptr(gocpp::recv(t->pp));
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerModifying, timerDeleted))
                            {
                                badTimer();
                            }
                            releasem(mp);
                            rec::Add(gocpp::recv(tpp->deletedTimers), 1);
                            return true;
                        }
                        else
                        {
                            releasem(mp);
                        }
                        break;
                    case 3:
                    case 4:
                    case 5:
                        return false;
                        break;
                    case 6:
                    case 7:
                        osyield();
                        break;
                    case 8:
                        return false;
                        break;
                    case 9:
                        osyield();
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
        }
    }

    // dodeltimer removes timer i from the current P's heap.
    // We are locked on the P when this is called.
    // It returns the smallest changed index in pp.timers.
    // The caller must have locked the timers for pp.
    int dodeltimer(struct p* pp, int i)
    {
        if(auto t = pp->timers[i]; rec::ptr(gocpp::recv(t->pp)) != pp)
        {
            go_throw("dodeltimer: wrong P"s);
        }
        else
        {
            t->pp = 0;
        }
        auto last = len(pp->timers) - 1;
        if(i != last)
        {
            pp->timers[i] = pp->timers[last];
        }
        pp->timers[last] = nullptr;
        pp->timers = pp->timers.make_slice(0, last);
        auto smallestChanged = i;
        if(i != last)
        {
            smallestChanged = siftupTimer(pp->timers, i);
            siftdownTimer(pp->timers, i);
        }
        if(i == 0)
        {
            updateTimer0When(pp);
        }
        auto n = rec::Add(gocpp::recv(pp->numTimers), - 1);
        if(n == 0)
        {
            rec::Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        }
        return smallestChanged;
    }

    // dodeltimer0 removes timer 0 from the current P's heap.
    // We are locked on the P when this is called.
    // It reports whether it saw no problems due to races.
    // The caller must have locked the timers for pp.
    void dodeltimer0(struct p* pp)
    {
        if(auto t = pp->timers[0]; rec::ptr(gocpp::recv(t->pp)) != pp)
        {
            go_throw("dodeltimer0: wrong P"s);
        }
        else
        {
            t->pp = 0;
        }
        auto last = len(pp->timers) - 1;
        if(last > 0)
        {
            pp->timers[0] = pp->timers[last];
        }
        pp->timers[last] = nullptr;
        pp->timers = pp->timers.make_slice(0, last);
        if(last > 0)
        {
            siftdownTimer(pp->timers, 0);
        }
        updateTimer0When(pp);
        auto n = rec::Add(gocpp::recv(pp->numTimers), - 1);
        if(n == 0)
        {
            rec::Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        }
    }

    // modtimer modifies an existing timer.
    // This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset.
    // Reports whether the timer was modified before it was run.
    bool modtimer(struct timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq)
    {
        if(when <= 0)
        {
            go_throw("timer when must be positive"s);
        }
        if(period < 0)
        {
            go_throw("timer period must be non-negative"s);
        }
        auto status = uint32_t(timerNoStatus);
        auto wasRemoved = false;
        bool pending = {};
        m* mp = {};
        loop:
        for(; ; )
        {
            //Go switch emulation
            {
                status = rec::Load(gocpp::recv(t->status));
                auto condition = status;
                int conditionId = -1;
                if(condition == timerWaiting) { conditionId = 0; }
                else if(condition == timerModifiedEarlier) { conditionId = 1; }
                else if(condition == timerModifiedLater) { conditionId = 2; }
                else if(condition == timerNoStatus) { conditionId = 3; }
                else if(condition == timerRemoved) { conditionId = 4; }
                else if(condition == timerDeleted) { conditionId = 5; }
                else if(condition == timerRunning) { conditionId = 6; }
                else if(condition == timerRemoving) { conditionId = 7; }
                else if(condition == timerMoving) { conditionId = 8; }
                else if(condition == timerModifying) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                        mp = acquirem();
                        if(rec::CompareAndSwap(gocpp::recv(t->status), status, timerModifying))
                        {
                            pending = true;
                            goto loop_break;
                        }
                        releasem(mp);
                        break;
                    case 3:
                    case 4:
                        mp = acquirem();
                        if(rec::CompareAndSwap(gocpp::recv(t->status), status, timerModifying))
                        {
                            wasRemoved = true;
                            pending = false;
                            goto loop_break;
                        }
                        releasem(mp);
                        break;
                    case 5:
                        mp = acquirem();
                        if(rec::CompareAndSwap(gocpp::recv(t->status), status, timerModifying))
                        {
                            rec::Add(gocpp::recv(rec::ptr(gocpp::recv(t->pp))->deletedTimers), - 1);
                            pending = false;
                            goto loop_break;
                        }
                        releasem(mp);
                        break;
                    case 6:
                    case 7:
                    case 8:
                        osyield();
                        break;
                    case 9:
                        osyield();
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
            if(false) {
            loop_continue:
                continue;
            loop_break:
                break;
            }
        }
        t->period = period;
        t->f = f;
        t->arg = arg;
        t->seq = seq;
        if(wasRemoved)
        {
            t->when = when;
            auto pp = rec::ptr(gocpp::recv(getg()->m->p));
            lock(& pp->timersLock);
            doaddtimer(pp, t);
            unlock(& pp->timersLock);
            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerModifying, timerWaiting))
            {
                badTimer();
            }
            releasem(mp);
            wakeNetPoller(when);
        }
        else
        {
            t->nextwhen = when;
            auto newStatus = uint32_t(timerModifiedLater);
            if(when < t->when)
            {
                newStatus = timerModifiedEarlier;
            }
            auto tpp = rec::ptr(gocpp::recv(t->pp));
            if(newStatus == timerModifiedEarlier)
            {
                updateTimerModifiedEarliest(tpp, when);
            }
            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerModifying, newStatus))
            {
                badTimer();
            }
            releasem(mp);
            if(newStatus == timerModifiedEarlier)
            {
                wakeNetPoller(when);
            }
        }
        return pending;
    }

    // resettimer resets the time when a timer should fire.
    // If used for an inactive timer, the timer will become active.
    // This should be called instead of addtimer if the timer value has been,
    // or may have been, used previously.
    // Reports whether the timer was modified before it was run.
    bool resettimer(struct timer* t, int64_t when)
    {
        return modtimer(t, when, t->period, t->f, t->arg, t->seq);
    }

    // cleantimers cleans up the head of the timer queue. This speeds up
    // programs that create and delete timers; leaving them in the heap
    // slows down addtimer. Reports whether no timer problems were found.
    // The caller must have locked the timers for pp.
    void cleantimers(struct p* pp)
    {
        auto gp = getg();
        for(; ; )
        {
            if(len(pp->timers) == 0)
            {
                return;
            }
            if(gp->preemptStop)
            {
                return;
            }
            auto t = pp->timers[0];
            if(rec::ptr(gocpp::recv(t->pp)) != pp)
            {
                go_throw("cleantimers: bad p"s);
            }
            //Go switch emulation
            {
                auto s = rec::Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerDeleted) { conditionId = 0; }
                else if(condition == timerModifiedEarlier) { conditionId = 1; }
                else if(condition == timerModifiedLater) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                        {
                            continue;
                        }
                        dodeltimer0(pp);
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                        {
                            badTimer();
                        }
                        rec::Add(gocpp::recv(pp->deletedTimers), - 1);
                        break;
                    case 1:
                    case 2:
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                        {
                            continue;
                        }
                        t->when = t->nextwhen;
                        dodeltimer0(pp);
                        doaddtimer(pp, t);
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                        {
                            badTimer();
                        }
                        break;
                    default:
                        return;
                        break;
                }
            }
        }
    }

    // moveTimers moves a slice of timers to pp. The slice has been taken
    // from a different P.
    // This is currently called when the world is stopped, but the caller
    // is expected to have locked the timers for pp.
    void moveTimers(struct p* pp, gocpp::slice<timer*> timers)
    {
        for(auto [gocpp_ignored, t] : timers)
        {
            loop:
            for(; ; )
            {
                //Go switch emulation
                {
                    auto s = rec::Load(gocpp::recv(t->status));
                    auto condition = s;
                    int conditionId = -1;
                    if(condition == timerWaiting) { conditionId = 0; }
                    else if(condition == timerModifiedEarlier) { conditionId = 1; }
                    else if(condition == timerModifiedLater) { conditionId = 2; }
                    else if(condition == timerDeleted) { conditionId = 3; }
                    else if(condition == timerModifying) { conditionId = 4; }
                    else if(condition == timerNoStatus) { conditionId = 5; }
                    else if(condition == timerRemoved) { conditionId = 6; }
                    else if(condition == timerRunning) { conditionId = 7; }
                    else if(condition == timerRemoving) { conditionId = 8; }
                    else if(condition == timerMoving) { conditionId = 9; }
                    switch(conditionId)
                    {
                        case 0:
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                            {
                                continue;
                            }
                            t->pp = 0;
                            doaddtimer(pp, t);
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                            {
                                badTimer();
                            }
                            goto loop_break;
                            break;
                        case 1:
                        case 2:
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                            {
                                continue;
                            }
                            t->when = t->nextwhen;
                            t->pp = 0;
                            doaddtimer(pp, t);
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                            {
                                badTimer();
                            }
                            goto loop_break;
                            break;
                        case 3:
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerRemoved))
                            {
                                continue;
                            }
                            t->pp = 0;
                            goto loop_break;
                            break;
                        case 4:
                            osyield();
                            break;
                        case 5:
                        case 6:
                            badTimer();
                            break;
                        case 7:
                        case 8:
                        case 9:
                            badTimer();
                            break;
                        default:
                            badTimer();
                            break;
                    }
                }
                if(false) {
                loop_continue:
                    continue;
                loop_break:
                    break;
                }
            }
        }
    }

    // adjusttimers looks through the timers in the current P's heap for
    // any timers that have been modified to run earlier, and puts them in
    // the correct place in the heap. While looking for those timers,
    // it also moves timers that have been modified to run later,
    // and removes deleted timers. The caller must have locked the timers for pp.
    void adjusttimers(struct p* pp, int64_t now)
    {
        auto first = rec::Load(gocpp::recv(pp->timerModifiedEarliest));
        if(first == 0 || first > now)
        {
            if(verifyTimers)
            {
                verifyTimerHeap(pp);
            }
            return;
        }
        rec::Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        gocpp::slice<timer*> moved = {};
        for(auto i = 0; i < len(pp->timers); i++)
        {
            auto t = pp->timers[i];
            if(rec::ptr(gocpp::recv(t->pp)) != pp)
            {
                go_throw("adjusttimers: bad p"s);
            }
            //Go switch emulation
            {
                auto s = rec::Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerDeleted) { conditionId = 0; }
                else if(condition == timerModifiedEarlier) { conditionId = 1; }
                else if(condition == timerModifiedLater) { conditionId = 2; }
                else if(condition == timerNoStatus) { conditionId = 3; }
                else if(condition == timerRunning) { conditionId = 4; }
                else if(condition == timerRemoving) { conditionId = 5; }
                else if(condition == timerRemoved) { conditionId = 6; }
                else if(condition == timerMoving) { conditionId = 7; }
                else if(condition == timerWaiting) { conditionId = 8; }
                else if(condition == timerModifying) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                        if(rec::CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                        {
                            auto changed = dodeltimer(pp, i);
                            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                            {
                                badTimer();
                            }
                            rec::Add(gocpp::recv(pp->deletedTimers), - 1);
                            i = changed - 1;
                        }
                        break;
                    case 1:
                    case 2:
                        if(rec::CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                        {
                            t->when = t->nextwhen;
                            auto changed = dodeltimer(pp, i);
                            moved = append(moved, t);
                            i = changed - 1;
                        }
                        break;
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        badTimer();
                        break;
                    case 8:
                        break;
                    case 9:
                        osyield();
                        i--;
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
        }
        if(len(moved) > 0)
        {
            addAdjustedTimers(pp, moved);
        }
        if(verifyTimers)
        {
            verifyTimerHeap(pp);
        }
    }

    // addAdjustedTimers adds any timers we adjusted in adjusttimers
    // back to the timer heap.
    void addAdjustedTimers(struct p* pp, gocpp::slice<timer*> moved)
    {
        for(auto [gocpp_ignored, t] : moved)
        {
            doaddtimer(pp, t);
            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
            {
                badTimer();
            }
        }
    }

    // nobarrierWakeTime looks at P's timers and returns the time when we
    // should wake up the netpoller. It returns 0 if there are no timers.
    // This function is invoked when dropping a P, and must run without
    // any write barriers.
    //
    //go:nowritebarrierrec
    int64_t nobarrierWakeTime(struct p* pp)
    {
        auto next = rec::Load(gocpp::recv(pp->timer0When));
        auto nextAdj = rec::Load(gocpp::recv(pp->timerModifiedEarliest));
        if(next == 0 || (nextAdj != 0 && nextAdj < next))
        {
            next = nextAdj;
        }
        return next;
    }

    // runtimer examines the first timer in timers. If it is ready based on now,
    // it runs the timer and removes or updates it.
    // Returns 0 if it ran a timer, -1 if there are no more timers, or the time
    // when the first timer should run.
    // The caller must have locked the timers for pp.
    // If a timer is run, this will temporarily unlock the timers.
    //
    //go:systemstack
    int64_t runtimer(struct p* pp, int64_t now)
    {
        for(; ; )
        {
            auto t = pp->timers[0];
            if(rec::ptr(gocpp::recv(t->pp)) != pp)
            {
                go_throw("runtimer: bad p"s);
            }
            //Go switch emulation
            {
                auto s = rec::Load(gocpp::recv(t->status));
                auto condition = s;
                int conditionId = -1;
                if(condition == timerWaiting) { conditionId = 0; }
                else if(condition == timerDeleted) { conditionId = 1; }
                else if(condition == timerModifiedEarlier) { conditionId = 2; }
                else if(condition == timerModifiedLater) { conditionId = 3; }
                else if(condition == timerModifying) { conditionId = 4; }
                else if(condition == timerNoStatus) { conditionId = 5; }
                else if(condition == timerRemoved) { conditionId = 6; }
                else if(condition == timerRunning) { conditionId = 7; }
                else if(condition == timerRemoving) { conditionId = 8; }
                else if(condition == timerMoving) { conditionId = 9; }
                switch(conditionId)
                {
                    case 0:
                        if(t->when > now)
                        {
                            return t->when;
                        }
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerRunning))
                        {
                            continue;
                        }
                        runOneTimer(pp, t, now);
                        return 0;
                        break;
                    case 1:
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                        {
                            continue;
                        }
                        dodeltimer0(pp);
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                        {
                            badTimer();
                        }
                        rec::Add(gocpp::recv(pp->deletedTimers), - 1);
                        if(len(pp->timers) == 0)
                        {
                            return - 1;
                        }
                        break;
                    case 2:
                    case 3:
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                        {
                            continue;
                        }
                        t->when = t->nextwhen;
                        dodeltimer0(pp);
                        doaddtimer(pp, t);
                        if(! rec::CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                        {
                            badTimer();
                        }
                        break;
                    case 4:
                        osyield();
                        break;
                    case 5:
                    case 6:
                        badTimer();
                        break;
                    case 7:
                    case 8:
                    case 9:
                        badTimer();
                        break;
                    default:
                        badTimer();
                        break;
                }
            }
        }
    }

    // runOneTimer runs a single timer.
    // The caller must have locked the timers for pp.
    // This will temporarily unlock the timers while running the timer function.
    //
    //go:systemstack
    void runOneTimer(struct p* pp, struct timer* t, int64_t now)
    {
        if(raceenabled)
        {
            auto ppcur = rec::ptr(gocpp::recv(getg()->m->p));
            if(ppcur->timerRaceCtx == 0)
            {
                ppcur->timerRaceCtx = racegostart(abi::FuncPCABIInternal(runtimer) + sys::PCQuantum);
            }
            raceacquirectx(ppcur->timerRaceCtx, unsafe::Pointer(t));
        }
        auto f = t->f;
        auto arg = t->arg;
        auto seq = t->seq;
        if(t->period > 0)
        {
            auto delta = t->when - now;
            t->when += t->period * (1 + - delta / t->period);
            if(t->when < 0)
            {
                t->when = maxWhen;
            }
            siftdownTimer(pp->timers, 0);
            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerRunning, timerWaiting))
            {
                badTimer();
            }
            updateTimer0When(pp);
        }
        else
        {
            dodeltimer0(pp);
            if(! rec::CompareAndSwap(gocpp::recv(t->status), timerRunning, timerNoStatus))
            {
                badTimer();
            }
        }
        if(raceenabled)
        {
            auto gp = getg();
            if(gp->racectx != 0)
            {
                go_throw("runOneTimer: unexpected racectx"s);
            }
            gp->racectx = rec::ptr(gocpp::recv(gp->m->p))->timerRaceCtx;
        }
        unlock(& pp->timersLock);
        f(arg, seq);
        lock(& pp->timersLock);
        if(raceenabled)
        {
            auto gp = getg();
            gp->racectx = 0;
        }
    }

    // clearDeletedTimers removes all deleted timers from the P's timer heap.
    // This is used to avoid clogging up the heap if the program
    // starts a lot of long-running timers and then stops them.
    // For example, this can happen via context.WithTimeout.
    //
    // This is the only function that walks through the entire timer heap,
    // other than moveTimers which only runs when the world is stopped.
    //
    // The caller must have locked the timers for pp.
    void clearDeletedTimers(struct p* pp)
    {
        rec::Store(gocpp::recv(pp->timerModifiedEarliest), 0);
        auto cdel = int32_t(0);
        auto to = 0;
        auto changedHeap = false;
        auto timers = pp->timers;
        nextTimer:
        for(auto [gocpp_ignored, t] : timers)
        {
            for(; ; )
            {
                //Go switch emulation
                {
                    auto s = rec::Load(gocpp::recv(t->status));
                    auto condition = s;
                    int conditionId = -1;
                    if(condition == timerWaiting) { conditionId = 0; }
                    else if(condition == timerModifiedEarlier) { conditionId = 1; }
                    else if(condition == timerModifiedLater) { conditionId = 2; }
                    else if(condition == timerDeleted) { conditionId = 3; }
                    else if(condition == timerModifying) { conditionId = 4; }
                    else if(condition == timerNoStatus) { conditionId = 5; }
                    else if(condition == timerRemoved) { conditionId = 6; }
                    else if(condition == timerRunning) { conditionId = 7; }
                    else if(condition == timerRemoving) { conditionId = 8; }
                    else if(condition == timerMoving) { conditionId = 9; }
                    switch(conditionId)
                    {
                        case 0:
                            if(changedHeap)
                            {
                                timers[to] = t;
                                siftupTimer(timers, to);
                            }
                            to++;
                            goto nextTimer_continue;
                            break;
                        case 1:
                        case 2:
                            if(rec::CompareAndSwap(gocpp::recv(t->status), s, timerMoving))
                            {
                                t->when = t->nextwhen;
                                timers[to] = t;
                                siftupTimer(timers, to);
                                to++;
                                changedHeap = true;
                                if(! rec::CompareAndSwap(gocpp::recv(t->status), timerMoving, timerWaiting))
                                {
                                    badTimer();
                                }
                                goto nextTimer_continue;
                            }
                            break;
                        case 3:
                            if(rec::CompareAndSwap(gocpp::recv(t->status), s, timerRemoving))
                            {
                                t->pp = 0;
                                cdel++;
                                if(! rec::CompareAndSwap(gocpp::recv(t->status), timerRemoving, timerRemoved))
                                {
                                    badTimer();
                                }
                                changedHeap = true;
                                goto nextTimer_continue;
                            }
                            break;
                        case 4:
                            osyield();
                            break;
                        case 5:
                        case 6:
                            badTimer();
                            break;
                        case 7:
                        case 8:
                        case 9:
                            badTimer();
                            break;
                        default:
                            badTimer();
                            break;
                    }
                }
            }
            if(false) {
            nextTimer_continue:
                continue;
            nextTimer_break:
                break;
            }
        }
        for(auto i = to; i < len(timers); i++)
        {
            timers[i] = nullptr;
        }
        rec::Add(gocpp::recv(pp->deletedTimers), - cdel);
        rec::Add(gocpp::recv(pp->numTimers), - cdel);
        timers = timers.make_slice(0, to);
        pp->timers = timers;
        updateTimer0When(pp);
        if(verifyTimers)
        {
            verifyTimerHeap(pp);
        }
    }

    // verifyTimerHeap verifies that the timer heap is in a valid state.
    // This is only for debugging, and is only called if verifyTimers is true.
    // The caller must have locked the timers.
    void verifyTimerHeap(struct p* pp)
    {
        for(auto [i, t] : pp->timers)
        {
            if(i == 0)
            {
                continue;
            }
            auto p = (i - 1) / 4;
            if(t->when < pp->timers[p]->when)
            {
                print("bad timer heap at "s, i, ": "s, p, ": "s, pp->timers[p]->when, ", "s, i, ": "s, t->when, "\n"s);
                go_throw("bad timer heap"s);
            }
        }
        if(auto numTimers = int(rec::Load(gocpp::recv(pp->numTimers))); len(pp->timers) != numTimers)
        {
            println("timer heap len"s, len(pp->timers), "!= numTimers"s, numTimers);
            go_throw("bad timer heap len"s);
        }
    }

    // updateTimer0When sets the P's timer0When field.
    // The caller must have locked the timers for pp.
    void updateTimer0When(struct p* pp)
    {
        if(len(pp->timers) == 0)
        {
            rec::Store(gocpp::recv(pp->timer0When), 0);
        }
        else
        {
            rec::Store(gocpp::recv(pp->timer0When), pp->timers[0]->when);
        }
    }

    // updateTimerModifiedEarliest updates the recorded nextwhen field of the
    // earlier timerModifiedEarier value.
    // The timers for pp will not be locked.
    void updateTimerModifiedEarliest(struct p* pp, int64_t nextwhen)
    {
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(pp->timerModifiedEarliest));
            if(old != 0 && old < nextwhen)
            {
                return;
            }
            if(rec::CompareAndSwap(gocpp::recv(pp->timerModifiedEarliest), old, nextwhen))
            {
                return;
            }
        }
    }

    // timeSleepUntil returns the time when the next timer should fire. Returns
    // maxWhen if there are no timers.
    // This is only called by sysmon and checkdead.
    int64_t timeSleepUntil()
    {
        auto next = int64_t(maxWhen);
        lock(& allpLock);
        for(auto [gocpp_ignored, pp] : allp)
        {
            if(pp == nullptr)
            {
                continue;
            }
            auto w = rec::Load(gocpp::recv(pp->timer0When));
            if(w != 0 && w < next)
            {
                next = w;
            }
            w = rec::Load(gocpp::recv(pp->timerModifiedEarliest));
            if(w != 0 && w < next)
            {
                next = w;
            }
        }
        unlock(& allpLock);
        return next;
    }

    // siftupTimer puts the timer at position i in the right place
    // in the heap by moving it up toward the top of the heap.
    // It returns the smallest changed index.
    int siftupTimer(gocpp::slice<timer*> t, int i)
    {
        if(i >= len(t))
        {
            badTimer();
        }
        auto when = t[i]->when;
        if(when <= 0)
        {
            badTimer();
        }
        auto tmp = t[i];
        for(; i > 0; )
        {
            auto p = (i - 1) / 4;
            if(when >= t[p]->when)
            {
                break;
            }
            t[i] = t[p];
            i = p;
        }
        if(tmp != t[i])
        {
            t[i] = tmp;
        }
        return i;
    }

    // siftdownTimer puts the timer at position i in the right place
    // in the heap by moving it down toward the bottom of the heap.
    void siftdownTimer(gocpp::slice<timer*> t, int i)
    {
        auto n = len(t);
        if(i >= n)
        {
            badTimer();
        }
        auto when = t[i]->when;
        if(when <= 0)
        {
            badTimer();
        }
        auto tmp = t[i];
        for(; ; )
        {
            auto c = i * 4 + 1;
            auto c3 = c + 2;
            if(c >= n)
            {
                break;
            }
            auto w = t[c]->when;
            if(c + 1 < n && t[c + 1]->when < w)
            {
                w = t[c + 1]->when;
                c++;
            }
            if(c3 < n)
            {
                auto w3 = t[c3]->when;
                if(c3 + 1 < n && t[c3 + 1]->when < w3)
                {
                    w3 = t[c3 + 1]->when;
                    c3++;
                }
                if(w3 < w)
                {
                    w = w3;
                    c = c3;
                }
            }
            if(w >= when)
            {
                break;
            }
            t[i] = t[c];
            i = c;
        }
        if(tmp != t[i])
        {
            t[i] = tmp;
        }
    }

    // badTimer is called if the timer data structures have been corrupted,
    // presumably due to racy use by the program. We panic here rather than
    // panicking due to invalid slice access while holding locks.
    // See issue #25686.
    void badTimer()
    {
        go_throw("timer data corruption"s);
    }

}

