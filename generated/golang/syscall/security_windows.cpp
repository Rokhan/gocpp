// generated by GoCpp from file '$(ImportDir)/syscall/security_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/security_windows.h"
#include "gocpp/support.h"

#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // TranslateAccountName converts a directory service
    // object name from one format to another.
    std::tuple<std::string, struct gocpp::error> TranslateAccountName(std::string username, uint32_t from, uint32_t to, int initSize)
    {
        auto [u, e] = UTF16PtrFromString(username);
        if(e != nullptr)
        {
            return {""s, e};
        }
        auto n = uint32_t(50);
        for(; ; )
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            e = TranslateName(u, from, to, & b[0], & n);
            if(e == nullptr)
            {
                return {UTF16ToString(b.make_slice(0, n)), nullptr};
            }
            if(e != ERROR_INSUFFICIENT_BUFFER)
            {
                return {""s, e};
            }
            if(n <= uint32_t(len(b)))
            {
                return {""s, e};
            }
        }
    }

    // do not reorder
    
    template<typename T> requires gocpp::GoStruct<T>
    UserInfo10::operator T()
    {
        T result;
        result.Name = this->Name;
        result.Comment = this->Comment;
        result.UsrComment = this->UsrComment;
        result.FullName = this->FullName;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool UserInfo10::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (Comment != ref.Comment) return false;
        if (UsrComment != ref.UsrComment) return false;
        if (FullName != ref.FullName) return false;
        return true;
    }

    std::ostream& UserInfo10::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Comment;
        os << " " << UsrComment;
        os << " " << FullName;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct UserInfo10& value)
    {
        return value.PrintTo(os);
    }

    // do not reorder
    // The security identifier (SID) structure is a variable-length
    // structure used to uniquely identify users or groups.
    
    template<typename T> requires gocpp::GoStruct<T>
    SID::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SID::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& SID::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SID& value)
    {
        return value.PrintTo(os);
    }

    // StringToSid converts a string-format security identifier
    // sid into a valid, functional sid.
    std::tuple<struct SID*, struct gocpp::error> StringToSid(std::string s)
    {
        gocpp::Defer defer;
        try
        {
            SID* sid = {};
            auto [p, e] = UTF16PtrFromString(s);
            if(e != nullptr)
            {
                return {nullptr, e};
            }
            e = ConvertStringSidToSid(p, & sid);
            if(e != nullptr)
            {
                return {nullptr, e};
            }
            defer.push_back([=]{ LocalFree((syscall::Handle)(unsafe::Pointer(sid))); });
            return rec::Copy(gocpp::recv(sid));
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // LookupSID retrieves a security identifier sid for the account
    // and the name of the domain on which the account was found.
    // System specify target computer to search.
    std::tuple<struct SID*, std::string, uint32_t, struct gocpp::error> LookupSID(std::string system, std::string account)
    {
        struct SID* sid;
        std::string domain;
        uint32_t accType;
        struct gocpp::error err;
        if(len(account) == 0)
        {
            return {nullptr, ""s, 0, go_EINVAL};
        }
        auto [acc, e] = UTF16PtrFromString(account);
        if(e != nullptr)
        {
            return {nullptr, ""s, 0, e};
        }
        uint16_t* sys = {};
        if(len(system) > 0)
        {
            std::tie(sys, e) = UTF16PtrFromString(system);
            if(e != nullptr)
            {
                return {nullptr, ""s, 0, e};
            }
        }
        auto n = uint32_t(50);
        auto dn = uint32_t(50);
        for(; ; )
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            auto db = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), dn);
            sid = (SID*)(unsafe::Pointer(& b[0]));
            e = LookupAccountName(sys, acc, sid, & n, & db[0], & dn, & accType);
            if(e == nullptr)
            {
                return {sid, UTF16ToString(db), accType, nullptr};
            }
            if(e != ERROR_INSUFFICIENT_BUFFER)
            {
                return {nullptr, ""s, 0, e};
            }
            if(n <= uint32_t(len(b)))
            {
                return {nullptr, ""s, 0, e};
            }
        }
    }

    // String converts sid to a string format
    // suitable for display, storage, or transmission.
    std::tuple<std::string, struct gocpp::error> rec::String(struct SID* sid)
    {
        gocpp::Defer defer;
        try
        {
            uint16_t* s = {};
            auto e = ConvertSidToStringSid(sid, & s);
            if(e != nullptr)
            {
                return {""s, e};
            }
            defer.push_back([=]{ LocalFree((syscall::Handle)(unsafe::Pointer(s))); });
            return {utf16PtrToString(s), nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // Len returns the length, in bytes, of a valid security identifier sid.
    int rec::Len(struct SID* sid)
    {
        return int(GetLengthSid(sid));
    }

    // Copy creates a duplicate of security identifier sid.
    std::tuple<struct SID*, struct gocpp::error> rec::Copy(struct SID* sid)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), rec::Len(gocpp::recv(sid)));
        auto sid2 = (SID*)(unsafe::Pointer(& b[0]));
        auto e = CopySid(uint32_t(len(b)), sid2, sid);
        if(e != nullptr)
        {
            return {nullptr, e};
        }
        return {sid2, nullptr};
    }

    // LookupAccount retrieves the name of the account for this sid
    // and the name of the first domain on which this sid is found.
    // System specify target computer to search for.
    std::tuple<std::string, std::string, uint32_t, struct gocpp::error> rec::LookupAccount(struct SID* sid, std::string system)
    {
        std::string account;
        std::string domain;
        uint32_t accType;
        struct gocpp::error err;
        uint16_t* sys = {};
        if(len(system) > 0)
        {
            std::tie(sys, err) = UTF16PtrFromString(system);
            if(err != nullptr)
            {
                return {""s, ""s, 0, err};
            }
        }
        auto n = uint32_t(50);
        auto dn = uint32_t(50);
        for(; ; )
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            auto db = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), dn);
            auto e = LookupAccountSid(sys, sid, & b[0], & n, & db[0], & dn, & accType);
            if(e == nullptr)
            {
                return {UTF16ToString(b), UTF16ToString(db), accType, nullptr};
            }
            if(e != ERROR_INSUFFICIENT_BUFFER)
            {
                return {""s, ""s, 0, e};
            }
            if(n <= uint32_t(len(b)))
            {
                return {""s, ""s, 0, e};
            }
        }
    }

    // do not reorder
    // do not reorder
    
    template<typename T> requires gocpp::GoStruct<T>
    SIDAndAttributes::operator T()
    {
        T result;
        result.Sid = this->Sid;
        result.Attributes = this->Attributes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SIDAndAttributes::operator==(const T& ref) const
    {
        if (Sid != ref.Sid) return false;
        if (Attributes != ref.Attributes) return false;
        return true;
    }

    std::ostream& SIDAndAttributes::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Sid;
        os << " " << Attributes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SIDAndAttributes& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Tokenuser::operator T()
    {
        T result;
        result.User = this->User;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Tokenuser::operator==(const T& ref) const
    {
        if (User != ref.User) return false;
        return true;
    }

    std::ostream& Tokenuser::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << User;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Tokenuser& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Tokenprimarygroup::operator T()
    {
        T result;
        result.PrimaryGroup = this->PrimaryGroup;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Tokenprimarygroup::operator==(const T& ref) const
    {
        if (PrimaryGroup != ref.PrimaryGroup) return false;
        return true;
    }

    std::ostream& Tokenprimarygroup::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PrimaryGroup;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Tokenprimarygroup& value)
    {
        return value.PrintTo(os);
    }

    // An access token contains the security information for a logon session.
    // The system creates an access token when a user logs on, and every
    // process executed on behalf of the user has a copy of the token.
    // The token identifies the user, the user's groups, and the user's
    // privileges. The system uses the token to control access to securable
    // objects and to control the ability of the user to perform various
    // system-related operations on the local computer.
    // OpenCurrentProcessToken opens the access token
    // associated with current process.
    std::tuple<syscall::Token, struct gocpp::error> OpenCurrentProcessToken()
    {
        auto [p, e] = GetCurrentProcess();
        if(e != nullptr)
        {
            return {0, e};
        }
        syscall::Token t = {};
        e = OpenProcessToken(p, TOKEN_QUERY, & t);
        if(e != nullptr)
        {
            return {0, e};
        }
        return {t, nullptr};
    }

    // Close releases access to access token.
    struct gocpp::error rec::Close(golang::syscall::Token t)
    {
        return CloseHandle(Handle(t));
    }

    // getInfo retrieves a specified type of information about an access token.
    std::tuple<unsafe::Pointer, struct gocpp::error> rec::getInfo(golang::syscall::Token t, uint32_t go_class, int initSize)
    {
        auto n = uint32_t(initSize);
        for(; ; )
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            auto e = GetTokenInformation(t, go_class, & b[0], uint32_t(len(b)), & n);
            if(e == nullptr)
            {
                return {unsafe::Pointer(& b[0]), nullptr};
            }
            if(e != ERROR_INSUFFICIENT_BUFFER)
            {
                return {nullptr, e};
            }
            if(n <= uint32_t(len(b)))
            {
                return {nullptr, e};
            }
        }
    }

    // GetTokenUser retrieves access token t user account information.
    std::tuple<struct Tokenuser*, struct gocpp::error> rec::GetTokenUser(golang::syscall::Token t)
    {
        auto [i, e] = rec::getInfo(gocpp::recv(t), TokenUser, 50);
        if(e != nullptr)
        {
            return {nullptr, e};
        }
        return {(Tokenuser*)(i), nullptr};
    }

    // GetTokenPrimaryGroup retrieves access token t primary group information.
    // A pointer to a SID structure representing a group that will become
    // the primary group of any objects created by a process using this access token.
    std::tuple<struct Tokenprimarygroup*, struct gocpp::error> rec::GetTokenPrimaryGroup(golang::syscall::Token t)
    {
        auto [i, e] = rec::getInfo(gocpp::recv(t), TokenPrimaryGroup, 50);
        if(e != nullptr)
        {
            return {nullptr, e};
        }
        return {(Tokenprimarygroup*)(i), nullptr};
    }

    // GetUserProfileDirectory retrieves path to the
    // root directory of the access token t user's profile.
    std::tuple<std::string, struct gocpp::error> rec::GetUserProfileDirectory(golang::syscall::Token t)
    {
        auto n = uint32_t(100);
        for(; ; )
        {
            auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
            auto e = GetUserProfileDirectory(t, & b[0], & n);
            if(e == nullptr)
            {
                return {UTF16ToString(b), nullptr};
            }
            if(e != ERROR_INSUFFICIENT_BUFFER)
            {
                return {""s, e};
            }
            if(n <= uint32_t(len(b)))
            {
                return {""s, e};
            }
        }
    }

}

