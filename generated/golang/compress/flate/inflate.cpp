// generated by GoCpp from file '$(ImportDir)/compress/flate/inflate.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/inflate.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/dict_decoder.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/io/io.h"
#include "golang/math/bits/bits.h"
#include "golang/strconv/itoa.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

namespace golang::flate
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace atomic::rec;
        using namespace bits::rec;
        using namespace bufio::rec;
        using namespace flate::rec;
        using namespace io::rec;
        using namespace strconv::rec;
        using namespace sync::rec;
    }

    sync::Once fixedOnce;
    huffmanDecoder fixedHuffmanDecoder;
    std::string rec::Error(flate::CorruptInputError e)
    {
        return "flate: corrupt input before offset " + strconv::FormatInt(int64_t(e), 10);
    }

    std::string rec::Error(flate::InternalError e)
    {
        return "flate: internal error: " + string(e);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ReadError::operator T()
    {
        T result;
        result.Offset = this->Offset;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ReadError::operator==(const T& ref) const
    {
        if (Offset != ref.Offset) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& ReadError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Offset;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ReadError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct ReadError* e)
    {
        return "flate: read error at offset " + strconv::FormatInt(e->Offset, 10) + ": " + rec::Error(gocpp::recv(e->Err));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    WriteError::operator T()
    {
        T result;
        result.Offset = this->Offset;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WriteError::operator==(const T& ref) const
    {
        if (Offset != ref.Offset) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& WriteError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Offset;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WriteError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct WriteError* e)
    {
        return "flate: write error at offset " + strconv::FormatInt(e->Offset, 10) + ": " + rec::Error(gocpp::recv(e->Err));
    }

    
    template<typename T>
    Resetter::Resetter(T& ref)
    {
        value.reset(new ResetterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Resetter::Resetter(const T& ref)
    {
        value.reset(new ResetterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Resetter::Resetter(T* ptr)
    {
        value.reset(new ResetterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Resetter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    struct gocpp::error Resetter::ResetterImpl<T, StoreT>::vReset(struct io::Reader r, gocpp::slice<unsigned char> dict)
    {
        return rec::Reset(gocpp::PtrRecv<T, false>(value.get()), r, dict);
    }

    namespace rec
    {
        struct gocpp::error Reset(const gocpp::PtrRecv<Resetter, false>& self, struct io::Reader r, gocpp::slice<unsigned char> dict)
        {
            return self.ptr->value->vReset(r, dict);
        }

        struct gocpp::error Reset(const gocpp::ObjRecv<Resetter>& self, struct io::Reader r, gocpp::slice<unsigned char> dict)
        {
            return self.obj.value->vReset(r, dict);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Resetter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    huffmanDecoder::operator T()
    {
        T result;
        result.min = this->min;
        result.chunks = this->chunks;
        result.links = this->links;
        result.linkMask = this->linkMask;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool huffmanDecoder::operator==(const T& ref) const
    {
        if (min != ref.min) return false;
        if (chunks != ref.chunks) return false;
        if (links != ref.links) return false;
        if (linkMask != ref.linkMask) return false;
        return true;
    }

    std::ostream& huffmanDecoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << min;
        os << " " << chunks;
        os << " " << links;
        os << " " << linkMask;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct huffmanDecoder& value)
    {
        return value.PrintTo(os);
    }

    bool rec::init(struct huffmanDecoder* h, gocpp::slice<int> lengths)
    {
        auto sanity = false;
        if(h->min != 0)
        {
            *h = huffmanDecoder {};
        }
        gocpp::array<int, maxCodeLen> count = {};
        int min = {};
        int max = {};
        for(auto [gocpp_ignored, n] : lengths)
        {
            if(n == 0)
            {
                continue;
            }
            if(min == 0 || n < min)
            {
                min = n;
            }
            if(n > max)
            {
                max = n;
            }
            count[n]++;
        }
        if(max == 0)
        {
            return true;
        }
        auto code = 0;
        gocpp::array<int, maxCodeLen> nextcode = {};
        for(auto i = min; i <= max; i++)
        {
            code <<= 1;
            nextcode[i] = code;
            code += count[i];
        }
        if(code != (1 << (unsigned int)(max)) && ! (code == 1 && max == 1))
        {
            return false;
        }
        h->min = min;
        if(max > huffmanChunkBits)
        {
            auto numLinks = 1 << ((unsigned int)(max) - huffmanChunkBits);
            h->linkMask = uint32_t(numLinks - 1);
            auto link = nextcode[huffmanChunkBits + 1] >> 1;
            h->links = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<uint32_t>>>(), huffmanNumChunks - link);
            for(auto j = (unsigned int)(link); j < huffmanNumChunks; j++)
            {
                auto reverse = int(bits::Reverse16(uint16_t(j)));
                reverse >>= (unsigned int)(16 - huffmanChunkBits);
                auto off = j - (unsigned int)(link);
                if(sanity && h->chunks[reverse] != 0)
                {
                    gocpp::panic("impossible: overwriting existing chunk");
                }
                h->chunks[reverse] = uint32_t((off << huffmanValueShift) | (huffmanChunkBits + 1));
                h->links[off] = gocpp::make(gocpp::Tag<gocpp::slice<uint32_t>>(), numLinks);
            }
        }
        for(auto [i, n] : lengths)
        {
            if(n == 0)
            {
                continue;
            }
            auto code = nextcode[n];
            nextcode[n]++;
            auto chunk = uint32_t((i << huffmanValueShift) | n);
            auto reverse = int(bits::Reverse16(uint16_t(code)));
            reverse >>= (unsigned int)(16 - n);
            if(n <= huffmanChunkBits)
            {
                for(auto off = reverse; off < len(h->chunks); off += 1 << (unsigned int)(n))
                {
                    if(sanity && h->chunks[off] != 0)
                    {
                        gocpp::panic("impossible: overwriting existing chunk");
                    }
                    h->chunks[off] = chunk;
                }
            }
            else
            {
                auto j = reverse & (huffmanNumChunks - 1);
                if(sanity && h->chunks[j] & huffmanCountMask != huffmanChunkBits + 1)
                {
                    gocpp::panic("impossible: not an indirect chunk");
                }
                auto value = h->chunks[j] >> huffmanValueShift;
                auto linktab = h->links[value];
                reverse >>= huffmanChunkBits;
                for(auto off = reverse; off < len(linktab); off += 1 << (unsigned int)(n - huffmanChunkBits))
                {
                    if(sanity && linktab[off] != 0)
                    {
                        gocpp::panic("impossible: overwriting existing chunk");
                    }
                    linktab[off] = chunk;
                }
            }
        }
        if(sanity)
        {
            for(auto [i, chunk] : h->chunks)
            {
                if(chunk == 0)
                {
                    if(code == 1 && i % 2 == 1)
                    {
                        continue;
                    }
                    gocpp::panic("impossible: missing chunk");
                }
            }
            for(auto [gocpp_ignored, linktab] : h->links)
            {
                for(auto [gocpp_ignored, chunk] : linktab)
                {
                    if(chunk == 0)
                    {
                        gocpp::panic("impossible: missing chunk");
                    }
                }
            }
        }
        return true;
    }

    
    template<typename T>
    Reader::Reader(T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(const T& ref)
    {
        value.reset(new ReaderImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Reader::Reader(T* ptr)
    {
        value.reset(new ReaderImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        return os;
    }


    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    decompressor::operator T()
    {
        T result;
        result.r = this->r;
        result.rBuf = this->rBuf;
        result.roffset = this->roffset;
        result.b = this->b;
        result.nb = this->nb;
        result.h1 = this->h1;
        result.h2 = this->h2;
        result.bits = this->bits;
        result.codebits = this->codebits;
        result.dict = this->dict;
        result.buf = this->buf;
        result.step = this->step;
        result.stepState = this->stepState;
        result.final = this->final;
        result.err = this->err;
        result.toRead = this->toRead;
        result.hl = this->hl;
        result.hd = this->hd;
        result.copyLen = this->copyLen;
        result.copyDist = this->copyDist;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decompressor::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (rBuf != ref.rBuf) return false;
        if (roffset != ref.roffset) return false;
        if (b != ref.b) return false;
        if (nb != ref.nb) return false;
        if (h1 != ref.h1) return false;
        if (h2 != ref.h2) return false;
        if (bits != ref.bits) return false;
        if (codebits != ref.codebits) return false;
        if (dict != ref.dict) return false;
        if (buf != ref.buf) return false;
        if (step != ref.step) return false;
        if (stepState != ref.stepState) return false;
        if (final != ref.final) return false;
        if (err != ref.err) return false;
        if (toRead != ref.toRead) return false;
        if (hl != ref.hl) return false;
        if (hd != ref.hd) return false;
        if (copyLen != ref.copyLen) return false;
        if (copyDist != ref.copyDist) return false;
        return true;
    }

    std::ostream& decompressor::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << rBuf;
        os << " " << roffset;
        os << " " << b;
        os << " " << nb;
        os << " " << h1;
        os << " " << h2;
        os << " " << bits;
        os << " " << codebits;
        os << " " << dict;
        os << " " << buf;
        os << " " << step;
        os << " " << stepState;
        os << " " << final;
        os << " " << err;
        os << " " << toRead;
        os << " " << hl;
        os << " " << hd;
        os << " " << copyLen;
        os << " " << copyDist;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decompressor& value)
    {
        return value.PrintTo(os);
    }

    void rec::nextBlock(struct decompressor* f)
    {
        for(; f->nb < 1 + 2; )
        {
            if(f->err = rec::moreBits(gocpp::recv(f)); f->err != nullptr)
            {
                return;
            }
        }
        f->final = f->b & 1 == 1;
        f->b >>= 1;
        auto typ = f->b & 3;
        f->b >>= 2;
        f->nb -= 1 + 2;
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    rec::dataBlock(gocpp::recv(f));
                    break;
                case 1:
                    f->hl = & fixedHuffmanDecoder;
                    f->hd = nullptr;
                    rec::huffmanBlock(gocpp::recv(f));
                    break;
                case 2:
                    if(f->err = rec::readHuffman(gocpp::recv(f)); f->err != nullptr)
                    {
                        break;
                    }
                    f->hl = & f->h1;
                    f->hd = & f->h2;
                    rec::huffmanBlock(gocpp::recv(f));
                    break;
                default:
                    f->err = CorruptInputError(f->roffset);
                    break;
            }
        }
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct decompressor* f, gocpp::slice<unsigned char> b)
    {
        for(; ; )
        {
            if(len(f->toRead) > 0)
            {
                auto n = copy(b, f->toRead);
                f->toRead = f->toRead.make_slice(n);
                if(len(f->toRead) == 0)
                {
                    return {n, f->err};
                }
                return {n, nullptr};
            }
            if(f->err != nullptr)
            {
                return {0, f->err};
            }
            rec::step(gocpp::recv(f), f);
            if(f->err != nullptr && len(f->toRead) == 0)
            {
                f->toRead = rec::readFlush(gocpp::recv(f->dict));
            }
        }
    }

    struct gocpp::error rec::Close(struct decompressor* f)
    {
        if(f->err == io::go_EOF)
        {
            return nullptr;
        }
        return f->err;
    }

    gocpp::array_base<int> codeOrder = gocpp::array_base<int> {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
    struct gocpp::error rec::readHuffman(struct decompressor* f)
    {
        for(; f->nb < 5 + 5 + 4; )
        {
            if(auto err = rec::moreBits(gocpp::recv(f)); err != nullptr)
            {
                return err;
            }
        }
        auto nlit = int(f->b & 0x1F) + 257;
        if(nlit > maxNumLit)
        {
            return CorruptInputError(f->roffset);
        }
        f->b >>= 5;
        auto ndist = int(f->b & 0x1F) + 1;
        if(ndist > maxNumDist)
        {
            return CorruptInputError(f->roffset);
        }
        f->b >>= 5;
        auto nclen = int(f->b & 0xF) + 4;
        f->b >>= 4;
        f->nb -= 5 + 5 + 4;
        for(auto i = 0; i < nclen; i++)
        {
            for(; f->nb < 3; )
            {
                if(auto err = rec::moreBits(gocpp::recv(f)); err != nullptr)
                {
                    return err;
                }
            }
            f->codebits[codeOrder[i]] = int(f->b & 0x7);
            f->b >>= 3;
            f->nb -= 3;
        }
        for(auto i = nclen; i < len(codeOrder); i++)
        {
            f->codebits[codeOrder[i]] = 0;
        }
        if(! rec::init(gocpp::recv(f->h1), f->codebits.make_slice(0)))
        {
            return CorruptInputError(f->roffset);
        }
        for(auto [i, n] = std::tuple{0, nlit + ndist}; i < n; )
        {
            auto [x, err] = rec::huffSym(gocpp::recv(f), & f->h1);
            if(err != nullptr)
            {
                return err;
            }
            if(x < 16)
            {
                f->bits[i] = x;
                i++;
                continue;
            }
            int rep = {};
            unsigned int nb = {};
            int b = {};
            //Go switch emulation
            {
                auto condition = x;
                int conditionId = -1;
                else if(condition == 16) { conditionId = 0; }
                else if(condition == 17) { conditionId = 1; }
                else if(condition == 18) { conditionId = 2; }
                switch(conditionId)
                {
                    default:
                        return InternalError("unexpected length code");
                        break;
                    case 0:
                        rep = 3;
                        nb = 2;
                        if(i == 0)
                        {
                            return CorruptInputError(f->roffset);
                        }
                        b = f->bits[i - 1];
                        break;
                    case 1:
                        rep = 3;
                        nb = 3;
                        b = 0;
                        break;
                    case 2:
                        rep = 11;
                        nb = 7;
                        b = 0;
                        break;
                }
            }
            for(; f->nb < nb; )
            {
                if(auto err = rec::moreBits(gocpp::recv(f)); err != nullptr)
                {
                    return err;
                }
            }
            rep += int(f->b & uint32_t((1 << nb) - 1));
            f->b >>= nb;
            f->nb -= nb;
            if(i + rep > n)
            {
                return CorruptInputError(f->roffset);
            }
            for(auto j = 0; j < rep; j++)
            {
                f->bits[i] = b;
                i++;
            }
        }
        if(! rec::init(gocpp::recv(f->h1), f->bits.make_slice(0, nlit)) || ! rec::init(gocpp::recv(f->h2), f->bits.make_slice(nlit, nlit + ndist)))
        {
            return CorruptInputError(f->roffset);
        }
        if(f->h1.min < f->bits[endBlockMarker])
        {
            f->h1.min = f->bits[endBlockMarker];
        }
        return nullptr;
    }

    void rec::huffmanBlock(struct decompressor* f)
    {
        auto stateInit = 0;
        auto stateDict = 1;
        //Go switch emulation
        {
            auto condition = f->stepState;
            int conditionId = -1;
            if(condition == stateInit) { conditionId = 0; }
            else if(condition == stateDict) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    goto readLiteral;
                    break;
                case 1:
                    goto copyHistory;
                    break;
            }
        }
        readLiteral:
        {
            auto [v, err] = rec::huffSym(gocpp::recv(f), f->hl);
            if(err != nullptr)
            {
                f->err = err;
                return;
            }
            unsigned int n = {};
            int length = {};
            //Go switch emulation
            {
                int conditionId = -1;
                if(v < 256) { conditionId = 0; }
                else if(v == 256) { conditionId = 1; }
                else if(v < 265) { conditionId = 2; }
                else if(v < 269) { conditionId = 3; }
                else if(v < 273) { conditionId = 4; }
                else if(v < 277) { conditionId = 5; }
                else if(v < 281) { conditionId = 6; }
                else if(v < 285) { conditionId = 7; }
                else if(v < maxNumLit) { conditionId = 8; }
                switch(conditionId)
                {
                    case 0:
                        rec::writeByte(gocpp::recv(f->dict), unsigned char(v));
                        if(rec::availWrite(gocpp::recv(f->dict)) == 0)
                        {
                            f->toRead = rec::readFlush(gocpp::recv(f->dict));
                            f->step = (*decompressor)->huffmanBlock;
                            f->stepState = stateInit;
                            return;
                        }
                        goto readLiteral;
                        break;
                    case 1:
                        rec::finishBlock(gocpp::recv(f));
                        return;
                        break;
                    case 2:
                        length = v - (257 - 3);
                        n = 0;
                        break;
                    case 3:
                        length = v * 2 - (265 * 2 - 11);
                        n = 1;
                        break;
                    case 4:
                        length = v * 4 - (269 * 4 - 19);
                        n = 2;
                        break;
                    case 5:
                        length = v * 8 - (273 * 8 - 35);
                        n = 3;
                        break;
                    case 6:
                        length = v * 16 - (277 * 16 - 67);
                        n = 4;
                        break;
                    case 7:
                        length = v * 32 - (281 * 32 - 131);
                        n = 5;
                        break;
                    case 8:
                        length = 258;
                        n = 0;
                        break;
                    default:
                        f->err = CorruptInputError(f->roffset);
                        return;
                        break;
                }
            }
            if(n > 0)
            {
                for(; f->nb < n; )
                {
                    if(err = rec::moreBits(gocpp::recv(f)); err != nullptr)
                    {
                        f->err = err;
                        return;
                    }
                }
                length += int(f->b & uint32_t((1 << n) - 1));
                f->b >>= n;
                f->nb -= n;
            }
            int dist = {};
            if(f->hd == nullptr)
            {
                for(; f->nb < 5; )
                {
                    if(err = rec::moreBits(gocpp::recv(f)); err != nullptr)
                    {
                        f->err = err;
                        return;
                    }
                }
                dist = int(bits::Reverse8(uint8_t(f->b & 0x1F << 3)));
                f->b >>= 5;
                f->nb -= 5;
            }
            else
            {
                if(std::tie(dist, err) = rec::huffSym(gocpp::recv(f), f->hd); err != nullptr)
                {
                    f->err = err;
                    return;
                }
            }
            //Go switch emulation
            {
                int conditionId = -1;
                if(dist < 4) { conditionId = 0; }
                else if(dist < maxNumDist) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        dist++;
                        break;
                    case 1:
                        auto nb = (unsigned int)(dist - 2) >> 1;
                        auto extra = (dist & 1) << nb;
                        for(; f->nb < nb; )
                        {
                            if(err = rec::moreBits(gocpp::recv(f)); err != nullptr)
                            {
                                f->err = err;
                                return;
                            }
                        }
                        extra |= int(f->b & uint32_t((1 << nb) - 1));
                        f->b >>= nb;
                        f->nb -= nb;
                        dist = (1 << (nb + 1)) + 1 + extra;
                        break;
                    default:
                        f->err = CorruptInputError(f->roffset);
                        return;
                        break;
                }
            }
            if(dist > rec::histSize(gocpp::recv(f->dict)))
            {
                f->err = CorruptInputError(f->roffset);
                return;
            }
            std::tie(f->copyLen, f->copyDist) = std::tuple{length, dist};
            goto copyHistory;
        }
        copyHistory:
        {
            auto cnt = rec::tryWriteCopy(gocpp::recv(f->dict), f->copyDist, f->copyLen);
            if(cnt == 0)
            {
                cnt = rec::writeCopy(gocpp::recv(f->dict), f->copyDist, f->copyLen);
            }
            f->copyLen -= cnt;
            if(rec::availWrite(gocpp::recv(f->dict)) == 0 || f->copyLen > 0)
            {
                f->toRead = rec::readFlush(gocpp::recv(f->dict));
                f->step = (*decompressor)->huffmanBlock;
                f->stepState = stateDict;
                return;
            }
            goto readLiteral;
        }
    }

    void rec::dataBlock(struct decompressor* f)
    {
        f->nb = 0;
        f->b = 0;
        auto [nr, err] = io::ReadFull(f->r, f->buf.make_slice(0, 4));
        f->roffset += int64_t(nr);
        if(err != nullptr)
        {
            f->err = noEOF(err);
            return;
        }
        auto n = int(f->buf[0]) | (int(f->buf[1]) << 8);
        auto nn = int(f->buf[2]) | (int(f->buf[3]) << 8);
        if(uint16_t(nn) != uint16_t(~ n))
        {
            f->err = CorruptInputError(f->roffset);
            return;
        }
        if(n == 0)
        {
            f->toRead = rec::readFlush(gocpp::recv(f->dict));
            rec::finishBlock(gocpp::recv(f));
            return;
        }
        f->copyLen = n;
        rec::copyData(gocpp::recv(f));
    }

    void rec::copyData(struct decompressor* f)
    {
        auto buf = rec::writeSlice(gocpp::recv(f->dict));
        if(len(buf) > f->copyLen)
        {
            buf = buf.make_slice(0, f->copyLen);
        }
        auto [cnt, err] = io::ReadFull(f->r, buf);
        f->roffset += int64_t(cnt);
        f->copyLen -= cnt;
        rec::writeMark(gocpp::recv(f->dict), cnt);
        if(err != nullptr)
        {
            f->err = noEOF(err);
            return;
        }
        if(rec::availWrite(gocpp::recv(f->dict)) == 0 || f->copyLen > 0)
        {
            f->toRead = rec::readFlush(gocpp::recv(f->dict));
            f->step = (*decompressor)->copyData;
            return;
        }
        rec::finishBlock(gocpp::recv(f));
    }

    void rec::finishBlock(struct decompressor* f)
    {
        if(f->final)
        {
            if(rec::availRead(gocpp::recv(f->dict)) > 0)
            {
                f->toRead = rec::readFlush(gocpp::recv(f->dict));
            }
            f->err = io::go_EOF;
        }
        f->step = (*decompressor)->nextBlock;
    }

    struct gocpp::error noEOF(struct gocpp::error e)
    {
        if(e == io::go_EOF)
        {
            return io::ErrUnexpectedEOF;
        }
        return e;
    }

    struct gocpp::error rec::moreBits(struct decompressor* f)
    {
        auto [c, err] = rec::ReadByte(gocpp::recv(f->r));
        if(err != nullptr)
        {
            return noEOF(err);
        }
        f->roffset++;
        f->b |= uint32_t(c) << f->nb;
        f->nb += 8;
        return nullptr;
    }

    std::tuple<int, struct gocpp::error> rec::huffSym(struct decompressor* f, struct huffmanDecoder* h)
    {
        auto n = (unsigned int)(h->min);
        auto [nb, b] = std::tuple{f->nb, f->b};
        for(; ; )
        {
            for(; nb < n; )
            {
                auto [c, err] = rec::ReadByte(gocpp::recv(f->r));
                if(err != nullptr)
                {
                    f->b = b;
                    f->nb = nb;
                    return {0, noEOF(err)};
                }
                f->roffset++;
                b |= uint32_t(c) << (nb & 31);
                nb += 8;
            }
            auto chunk = h->chunks[b & (huffmanNumChunks - 1)];
            n = (unsigned int)(chunk & huffmanCountMask);
            if(n > huffmanChunkBits)
            {
                chunk = h->links[chunk >> huffmanValueShift][(b >> huffmanChunkBits) & h->linkMask];
                n = (unsigned int)(chunk & huffmanCountMask);
            }
            if(n <= nb)
            {
                if(n == 0)
                {
                    f->b = b;
                    f->nb = nb;
                    f->err = CorruptInputError(f->roffset);
                    return {0, f->err};
                }
                f->b = b >> (n & 31);
                f->nb = nb - n;
                return {int(chunk >> huffmanValueShift), nullptr};
            }
        }
    }

    void rec::makeReader(struct decompressor* f, struct io::Reader r)
    {
        if(auto [rr, ok] = gocpp::getValue<Reader>(r); ok)
        {
            f->rBuf = nullptr;
            f->r = rr;
            return;
        }
        if(f->rBuf != nullptr)
        {
            rec::Reset(gocpp::recv(f->rBuf), r);
        }
        else
        {
            f->rBuf = bufio::NewReader(r);
        }
        f->r = f->rBuf;
    }

    void fixedHuffmanDecoderInit()
    {
        rec::Do(gocpp::recv(fixedOnce), [=]() mutable -> void
        {
            gocpp::array<int, 288> bits = {};
            for(auto i = 0; i < 144; i++)
            {
                bits[i] = 8;
            }
            for(auto i = 144; i < 256; i++)
            {
                bits[i] = 9;
            }
            for(auto i = 256; i < 280; i++)
            {
                bits[i] = 7;
            }
            for(auto i = 280; i < 288; i++)
            {
                bits[i] = 8;
            }
            rec::init(gocpp::recv(fixedHuffmanDecoder), bits.make_slice(0, ));
        });
    }

    struct gocpp::error rec::Reset(struct decompressor* f, struct io::Reader r, gocpp::slice<unsigned char> dict)
    {
        *f = gocpp::Init<decompressor>([](decompressor& x) { x.rBuf = f->rBuf; x.bits = f->bits; x.codebits = f->codebits; x.dict = f->dict; x.step = (*decompressor)->nextBlock; });
        rec::makeReader(gocpp::recv(f), r);
        rec::init(gocpp::recv(f->dict), maxMatchOffset, dict);
        return nullptr;
    }

    struct io::ReadCloser NewReader(struct io::Reader r)
    {
        fixedHuffmanDecoderInit();
        decompressor f = {};
        rec::makeReader(gocpp::recv(f), r);
        f->bits = go_new(gocpp::Tag<gocpp::array<int, maxNumLit + maxNumDist>>());
        f->codebits = go_new(gocpp::Tag<gocpp::array<int, numCodes>>());
        f->step = (*decompressor)->nextBlock;
        rec::init(gocpp::recv(f->dict), maxMatchOffset, nullptr);
        return & f;
    }

    struct io::ReadCloser NewReaderDict(struct io::Reader r, gocpp::slice<unsigned char> dict)
    {
        fixedHuffmanDecoderInit();
        decompressor f = {};
        rec::makeReader(gocpp::recv(f), r);
        f->bits = go_new(gocpp::Tag<gocpp::array<int, maxNumLit + maxNumDist>>());
        f->codebits = go_new(gocpp::Tag<gocpp::array<int, numCodes>>());
        f->step = (*decompressor)->nextBlock;
        rec::init(gocpp::recv(f->dict), maxMatchOffset, dict);
        return & f;
    }

}

