// generated by GoCpp from file '$(ImportDir)/image/format.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/format.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/errors/errors.h"
#include "golang/image/image.h"
// #include "golang/io/io.h"  [Ignored, known errors]
#include "golang/sync/atomic/value.h"
#include "golang/sync/mutex.h"

namespace golang::image
{
    std::string ErrFormat = errors::New("image: unknown format");
    
    std::ostream& format::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << magic;
        os << " " << decode;
        os << " " << decodeConfig;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct format& value)
    {
        return value.PrintTo(os);
    }

    mocklib::Mutex formatsMu;
    atomic::Value atomicFormats;
    void RegisterFormat(std::string name, std::string magic, std::function<std::tuple<Image, std::string> (io::Reader)> decode, std::function<std::tuple<Config, std::string> (io::Reader)> decodeConfig)
    {
        Lock(gocpp::recv(formatsMu));
        auto [formats, _] = gocpp::getValue<gocpp::slice<image::format>>(Load(gocpp::recv(atomicFormats)));
        Store(gocpp::recv(atomicFormats), append(formats, format {name, magic, decode, decodeConfig}));
        Unlock(gocpp::recv(formatsMu));
    }

    
    template<typename T>
    reader::reader(T& ref)
    {
        value.reset(new readerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    reader::reader(const T& ref)
    {
        value.reset(new readerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    reader::reader(T* ptr)
    {
        value.reset(new readerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& reader::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<gocpp::slice<unsigned char>, std::string> reader::readerImpl<T, StoreT>::vPeek(int)
    {
        return Peek(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> Peek(const gocpp::PtrRecv<reader, false>& self, int)
    {
        return self.ptr->value->vPeek(int);
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> Peek(const gocpp::ObjRecv<reader>& self, int)
    {
        return self.obj.value->vPeek(int);
    }

    std::ostream& operator<<(std::ostream& os, const struct reader& value)
    {
        return value.PrintTo(os);
    }

    reader asReader(io::Reader r)
    {
        if(auto [rr, ok] = gocpp::getValue<reader>(r); ok)
        {
            return rr;
        }
        return bufio::NewReader(r);
    }

    bool match(std::string magic, gocpp::slice<unsigned char> b)
    {
        if(len(magic) != len(b))
        {
            return false;
        }
        for(auto [i, c] : b)
        {
            if(magic[i] != c && magic[i] != '?')
            {
                return false;
            }
        }
        return true;
    }

    format sniff(reader r)
    {
        auto [formats, _] = gocpp::getValue<gocpp::slice<image::format>>(Load(gocpp::recv(atomicFormats)));
        for(auto [_, f] : formats)
        {
            auto [b, err] = Peek(gocpp::recv(r), len(f.magic));
            if(err == nullptr && match(f.magic, b))
            {
                return f;
            }
        }
        return format {};
    }

    std::tuple<Image, std::string, std::string> Decode(io::Reader r)
    {
        auto rr = asReader(r);
        auto f = sniff(rr);
        if(f.decode == nullptr)
        {
            return {nullptr, "", ErrFormat};
        }
        auto [m, err] = decode(gocpp::recv(f), rr);
        return {m, f.name, err};
    }

    std::tuple<Config, std::string, std::string> DecodeConfig(io::Reader r)
    {
        auto rr = asReader(r);
        auto f = sniff(rr);
        if(f.decodeConfig == nullptr)
        {
            return {Config {}, "", ErrFormat};
        }
        auto [c, err] = decodeConfig(gocpp::recv(f), rr);
        return {c, f.name, err};
    }

}

