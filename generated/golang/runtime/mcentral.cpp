// generated by GoCpp from file '$(ImportDir)/runtime/mcentral.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mcentral.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
// #include "golang/runtime/mgcsweep.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/sizeclasses.h"
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    
    std::ostream& mcentral::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << spanclass;
        os << " " << partial;
        os << " " << full;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mcentral& value)
    {
        return value.PrintTo(os);
    }

    void init(struct mcentral* c, spanClass spc)
    {
        c->spanclass = spc;
        lockInit(& c->partial[0].spineLock, lockRankSpanSetSpine);
        lockInit(& c->partial[1].spineLock, lockRankSpanSetSpine);
        lockInit(& c->full[0].spineLock, lockRankSpanSetSpine);
        lockInit(& c->full[1].spineLock, lockRankSpanSetSpine);
    }

    spanSet* partialUnswept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->partial[1 - sweepgen / 2 % 2];
    }

    spanSet* partialSwept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->partial[sweepgen / 2 % 2];
    }

    spanSet* fullUnswept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->full[1 - sweepgen / 2 % 2];
    }

    spanSet* fullSwept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->full[sweepgen / 2 % 2];
    }

    mspan* cacheSpan(struct mcentral* c)
    {
        auto spanBytes = uintptr_t(class_to_allocnpages[sizeclass(gocpp::recv(c->spanclass))]) * _PageSize;
        deductSweepCredit(spanBytes, 0);
        auto traceDone = false;
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepStart(gocpp::recv(trace));
            traceRelease(trace);
        }
        auto spanBudget = 100;
        mspan* s = {};
        sweepLocker sl = {};
        auto sg = mheap_.sweepgen;
        if(s = pop(gocpp::recv(partialSwept(gocpp::recv(c), sg))); s != nullptr)
        {
            goto havespan;
        }
        sl = begin(gocpp::recv(sweep.active));
        if(sl.valid)
        {
            for(; spanBudget >= 0; spanBudget--)
            {
                s = pop(gocpp::recv(partialUnswept(gocpp::recv(c), sg)));
                if(s == nullptr)
                {
                    break;
                }
                if(auto [s, ok] = tryAcquire(gocpp::recv(sl), s); ok)
                {
                    sweep(gocpp::recv(s), true);
                    end(gocpp::recv(sweep.active), sl);
                    goto havespan;
                }
            }
            for(; spanBudget >= 0; spanBudget--)
            {
                s = pop(gocpp::recv(fullUnswept(gocpp::recv(c), sg)));
                if(s == nullptr)
                {
                    break;
                }
                if(auto [s, ok] = tryAcquire(gocpp::recv(sl), s); ok)
                {
                    sweep(gocpp::recv(s), true);
                    auto freeIndex = nextFreeIndex(gocpp::recv(s));
                    if(freeIndex != s.nelems)
                    {
                        s.freeindex = freeIndex;
                        end(gocpp::recv(sweep.active), sl);
                        goto havespan;
                    }
                    push(gocpp::recv(fullSwept(gocpp::recv(c), sg)), s.mspan);
                }
            }
            end(gocpp::recv(sweep.active), sl);
        }
        trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepDone(gocpp::recv(trace));
            traceDone = true;
            traceRelease(trace);
        }
        s = grow(gocpp::recv(c));
        if(s == nullptr)
        {
            return nullptr;
        }
        havespan:
        if(! traceDone)
        {
            auto trace = traceAcquire();
            if(ok(gocpp::recv(trace)))
            {
                GCSweepDone(gocpp::recv(trace));
                traceRelease(trace);
            }
        }
        auto n = int(s->nelems) - int(s->allocCount);
        if(n == 0 || s->freeindex == s->nelems || s->allocCount == s->nelems)
        {
            go_throw("span has no free objects");
        }
        auto freeByteBase = s->freeindex &^ (64 - 1);
        auto whichByte = freeByteBase / 8;
        refillAllocCache(gocpp::recv(s), whichByte);
        s->allocCache >>= s->freeindex % 64;
        return s;
    }

    void uncacheSpan(struct mcentral* c, mspan* s)
    {
        if(s->allocCount == 0)
        {
            go_throw("uncaching span but s.allocCount == 0");
        }
        auto sg = mheap_.sweepgen;
        auto stale = s->sweepgen == sg + 1;
        if(stale)
        {
            atomic::Store(& s->sweepgen, sg - 1);
        }
        else
        {
            atomic::Store(& s->sweepgen, sg);
        }
        if(stale)
        {
            auto ss = sweepLocked {s};
            sweep(gocpp::recv(ss), false);
        }
        else
        {
            if(int(s->nelems) - int(s->allocCount) > 0)
            {
                push(gocpp::recv(partialSwept(gocpp::recv(c), sg)), s);
            }
            else
            {
                push(gocpp::recv(fullSwept(gocpp::recv(c), sg)), s);
            }
        }
    }

    mspan* grow(struct mcentral* c)
    {
        auto npages = uintptr_t(class_to_allocnpages[sizeclass(gocpp::recv(c->spanclass))]);
        auto size = uintptr_t(class_to_size[sizeclass(gocpp::recv(c->spanclass))]);
        auto s = alloc(gocpp::recv(mheap_), npages, c->spanclass);
        if(s == nullptr)
        {
            return nullptr;
        }
        auto n = divideByElemSize(gocpp::recv(s), npages << _PageShift);
        s->limit = base(gocpp::recv(s)) + size * n;
        initHeapBits(gocpp::recv(s), false);
        return s;
    }

}

