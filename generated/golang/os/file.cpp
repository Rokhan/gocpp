// generated by GoCpp from file '$(ImportDir)/os/file.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/errors/wrap.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/safefilepath/path.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/internal/testlog/log.h"
#include "golang/io/fs/fs.h"
#include "golang/io/io.h"
#include "golang/os/dir.h"
#include "golang/os/dir_windows.h"
#include "golang/os/env.h"
#include "golang/os/error.h"
#include "golang/os/file_posix.h"
#include "golang/os/file_windows.h"
#include "golang/os/getwd.h"
#include "golang/os/path_windows.h"
#include "golang/os/rawconn.h"
#include "golang/os/stat.h"
#include "golang/os/stat_windows.h"
#include "golang/os/sticky_notbsd.h"
#include "golang/os/types.h"
#include "golang/os/zero_copy_stub.h"
#include "golang/runtime/extern.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/net.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

// Package os provides a platform-independent interface to operating system
// functionality. The design is Unix-like, although the error handling is
// Go-like; failing calls return values of type error rather than error numbers.
// Often, more information is available within the error. For example,
// if a call that takes a file name fails, such as Open or Stat, the error
// will include the failing file name when printed and will be of type
// *PathError, which may be unpacked for more information.
//
// The os interface is intended to be uniform across all operating systems.
// Features not generally available appear in the system-specific package syscall.
//
// Here is a simple example, opening a file and reading some of it.
//
//	file, err := os.Open("file.go") // For read access.
//	if err != nil {
//		log.Fatal(err)
//	}
//
// If the open fails, the error string will be self-explanatory, like
//
//	open file.go: no such file or directory
//
// The file's data can then be read into a slice of bytes. Read and
// Write take their byte counts from the length of the argument slice.
//
//	data := make([]byte, 100)
//	count, err := file.Read(data)
//	if err != nil {
//		log.Fatal(err)
//	}
//	fmt.Printf("read %d bytes: %q\n", count, data[:count])
//
// Note: The maximum number of concurrent operations on a File may be limited by
// the OS or the system. The number should be high, but exceeding it may degrade
// performance or cause other issues.
namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using fs::rec::Mode;
        using fs::rec::Size;
        using testlog::rec::Chdir;
    }

    // Name returns the name of the file as presented to Open.
    std::string rec::Name(struct File* f)
    {
        return f->name;
    }

    // Stdin, Stdout, and Stderr are open Files pointing to the standard input,
    // standard output, and standard error file descriptors.
    //
    // Note that the Go runtime writes to standard error for panics and crashes;
    // closing Stderr may cause those messages to go elsewhere, perhaps
    // to a file opened later.
    File* Stdin = NewFile(uintptr_t(syscall::Stdin), "/dev/stdin"s);
    File* Stdout = NewFile(uintptr_t(syscall::Stdout), "/dev/stdout"s);
    File* Stderr = NewFile(uintptr_t(syscall::Stderr), "/dev/stderr"s);
    // Flags to OpenFile wrapping those of the underlying system. Not all
    // flags may be implemented on a given system.
    // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
    // The remaining values may be or'ed in to control behavior.
    // Seek whence values.
    //
    // Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.
    // LinkError records an error during a link or symlink or rename
    // system call and the paths that caused it.
    
    template<typename T> requires gocpp::GoStruct<T>
    LinkError::operator T()
    {
        T result;
        result.Op = this->Op;
        result.Old = this->Old;
        result.New = this->New;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool LinkError::operator==(const T& ref) const
    {
        if (Op != ref.Op) return false;
        if (Old != ref.Old) return false;
        if (New != ref.New) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& LinkError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Op;
        os << " " << Old;
        os << " " << New;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LinkError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct LinkError* e)
    {
        return e->Op + " "s + e->Old + " "s + e->New + ": "s + rec::Error(gocpp::recv(e->Err));
    }

    struct gocpp::error rec::Unwrap(struct LinkError* e)
    {
        return e->Err;
    }

    // Read reads up to len(b) bytes from the File and stores them in b.
    // It returns the number of bytes read and any error encountered.
    // At end of file, Read returns 0, io.EOF.
    std::tuple<int, struct gocpp::error> rec::Read(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "read"s); err != nullptr)
        {
            return {0, err};
        }
        gocpp::error e;
        std::tie(n, e) = rec::read(gocpp::recv(f), b);
        return {n, rec::wrapErr(gocpp::recv(f), "read"s, e)};
    }

    // ReadAt reads len(b) bytes from the File starting at byte offset off.
    // It returns the number of bytes read and the error, if any.
    // ReadAt always returns a non-nil error when n < len(b).
    // At end of file, that error is io.EOF.
    std::tuple<int, struct gocpp::error> rec::ReadAt(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "read"s); err != nullptr)
        {
            return {0, err};
        }
        if(off < 0)
        {
            return {0, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "readat"s;
                x.Path = f->name;
                x.Err = errors::New("negative offset"s);
            })};
        }
        for(; len(b) > 0; )
        {
            auto [m, e] = rec::pread(gocpp::recv(f), b, off);
            if(e != nullptr)
            {
                err = rec::wrapErr(gocpp::recv(f), "read"s, e);
                break;
            }
            n += m;
            b = b.make_slice(m);
            off += int64_t(m);
        }
        return {n, err};
    }

    // ReadFrom implements io.ReaderFrom.
    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(struct File* f, io::Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "write"s); err != nullptr)
        {
            return {0, err};
        }
        bool handled;
        gocpp::error e;
        std::tie(n, handled, e) = rec::readFrom(gocpp::recv(f), r);
        if(! handled)
        {
            return genericReadFrom(f, r);
        }
        return {n, rec::wrapErr(gocpp::recv(f), "write"s, e)};
    }

    // noReadFrom can be embedded alongside another type to
    // hide the ReadFrom method of that other type.
    
    template<typename T> requires gocpp::GoStruct<T>
    noReadFrom::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noReadFrom::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noReadFrom::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noReadFrom& value)
    {
        return value.PrintTo(os);
    }

    // ReadFrom hides another ReadFrom method.
    // It should never be called.
    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(noReadFrom, io::Reader)
    {
        gocpp::panic("can't happen"s);
    }

    // fileWithoutReadFrom implements all the methods of *File other
    // than ReadFrom. This is used to permit ReadFrom to call io.Copy
    // without leading to a recursive call to ReadFrom.
    
    template<typename T> requires gocpp::GoStruct<T>
    fileWithoutReadFrom::operator T()
    {
        T result;
        result.noReadFrom = this->noReadFrom;
        result.File = this->File;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fileWithoutReadFrom::operator==(const T& ref) const
    {
        if (noReadFrom != ref.noReadFrom) return false;
        if (File != ref.File) return false;
        return true;
    }

    std::ostream& fileWithoutReadFrom::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noReadFrom;
        os << " " << File;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fileWithoutReadFrom& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int64_t, struct gocpp::error> genericReadFrom(struct File* f, io::Reader r)
    {
        return io::Copy(gocpp::Init<fileWithoutReadFrom>([=](auto& x) {
            x.File = f;
        }), r);
    }

    // Write writes len(b) bytes from b to the File.
    // It returns the number of bytes written and an error, if any.
    // Write returns a non-nil error when n != len(b).
    std::tuple<int, struct gocpp::error> rec::Write(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "write"s); err != nullptr)
        {
            return {0, err};
        }
        gocpp::error e;
        std::tie(n, e) = rec::write(gocpp::recv(f), b);
        if(n < 0)
        {
            n = 0;
        }
        if(n != len(b))
        {
            err = io::ErrShortWrite;
        }
        epipecheck(f, e);
        if(e != nullptr)
        {
            err = rec::wrapErr(gocpp::recv(f), "write"s, e);
        }
        return {n, err};
    }

    gocpp::error errWriteAtInAppendMode = errors::New("os: invalid use of WriteAt on file opened with O_APPEND"s);
    // WriteAt writes len(b) bytes to the File starting at byte offset off.
    // It returns the number of bytes written and an error, if any.
    // WriteAt returns a non-nil error when n != len(b).
    //
    // If file was opened with the O_APPEND flag, WriteAt returns an error.
    std::tuple<int, struct gocpp::error> rec::WriteAt(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "write"s); err != nullptr)
        {
            return {0, err};
        }
        if(f->appendMode)
        {
            return {0, errWriteAtInAppendMode};
        }
        if(off < 0)
        {
            return {0, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "writeat"s;
                x.Path = f->name;
                x.Err = errors::New("negative offset"s);
            })};
        }
        for(; len(b) > 0; )
        {
            auto [m, e] = rec::pwrite(gocpp::recv(f), b, off);
            if(e != nullptr)
            {
                err = rec::wrapErr(gocpp::recv(f), "write"s, e);
                break;
            }
            n += m;
            b = b.make_slice(m);
            off += int64_t(m);
        }
        return {n, err};
    }

    // WriteTo implements io.WriterTo.
    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct File* f, io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "read"s); err != nullptr)
        {
            return {0, err};
        }
        bool handled;
        gocpp::error e;
        std::tie(n, handled, e) = rec::writeTo(gocpp::recv(f), w);
        if(handled)
        {
            return {n, rec::wrapErr(gocpp::recv(f), "read"s, e)};
        }
        return genericWriteTo(f, w);
    }

    // noWriteTo can be embedded alongside another type to
    // hide the WriteTo method of that other type.
    
    template<typename T> requires gocpp::GoStruct<T>
    noWriteTo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noWriteTo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noWriteTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noWriteTo& value)
    {
        return value.PrintTo(os);
    }

    // WriteTo hides another WriteTo method.
    // It should never be called.
    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(noWriteTo, io::Writer)
    {
        gocpp::panic("can't happen"s);
    }

    // fileWithoutWriteTo implements all the methods of *File other
    // than WriteTo. This is used to permit WriteTo to call io.Copy
    // without leading to a recursive call to WriteTo.
    
    template<typename T> requires gocpp::GoStruct<T>
    fileWithoutWriteTo::operator T()
    {
        T result;
        result.noWriteTo = this->noWriteTo;
        result.File = this->File;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fileWithoutWriteTo::operator==(const T& ref) const
    {
        if (noWriteTo != ref.noWriteTo) return false;
        if (File != ref.File) return false;
        return true;
    }

    std::ostream& fileWithoutWriteTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noWriteTo;
        os << " " << File;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fileWithoutWriteTo& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int64_t, struct gocpp::error> genericWriteTo(struct File* f, io::Writer w)
    {
        return io::Copy(w, gocpp::Init<fileWithoutWriteTo>([=](auto& x) {
            x.File = f;
        }));
    }

    // Seek sets the offset for the next Read or Write on file to offset, interpreted
    // according to whence: 0 means relative to the origin of the file, 1 means
    // relative to the current offset, and 2 means relative to the end.
    // It returns the new offset and an error, if any.
    // The behavior of Seek on a file opened with O_APPEND is not specified.
    std::tuple<int64_t, struct gocpp::error> rec::Seek(struct File* f, int64_t offset, int whence)
    {
        int64_t ret;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "seek"s); err != nullptr)
        {
            return {0, err};
        }
        auto [r, e] = rec::seek(gocpp::recv(f), offset, whence);
        if(e == nullptr && f->dirinfo != nullptr && r != 0)
        {
            e = syscall::go_EISDIR;
        }
        if(e != nullptr)
        {
            return {0, rec::wrapErr(gocpp::recv(f), "seek"s, e)};
        }
        return {r, nullptr};
    }

    // WriteString is like Write, but writes the contents of string s rather than
    // a slice of bytes.
    std::tuple<int, struct gocpp::error> rec::WriteString(struct File* f, std::string s)
    {
        int n;
        struct gocpp::error err;
        auto b = unsafe::Slice(unsafe::StringData(s), len(s));
        return rec::Write(gocpp::recv(f), b);
    }

    // Mkdir creates a new directory with the specified name and permission
    // bits (before umask).
    // If there is an error, it will be of type *PathError.
    struct gocpp::error Mkdir(std::string name, golang::os::FileMode perm)
    {
        auto longName = fixLongPath(name);
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Mkdir(longName, syscallMode(perm));
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "mkdir"s;
                x.Path = name;
                x.Err = e;
            });
        }
        if(! supportsCreateWithStickyBit && perm & ModeSticky != 0)
        {
            e = setStickyBit(name);
            if(e != nullptr)
            {
                Remove(name);
                return e;
            }
        }
        return nullptr;
    }

    // setStickyBit adds ModeSticky to the permission bits of path, non atomic.
    struct gocpp::error setStickyBit(std::string name)
    {
        auto [fi, err] = Stat(name);
        if(err != nullptr)
        {
            return err;
        }
        return Chmod(name, rec::Mode(gocpp::recv(fi)) | ModeSticky);
    }

    // Chdir changes the current working directory to the named directory.
    // If there is an error, it will be of type *PathError.
    struct gocpp::error Chdir(std::string dir)
    {
        if(auto e = syscall::Chdir(dir); e != nullptr)
        {
            testlog::Open(dir);
            return gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "chdir"s;
                x.Path = dir;
                x.Err = e;
            });
        }
        if(auto log = testlog::Logger(); log != nullptr)
        {
            auto [wd, err] = Getwd();
            if(err == nullptr)
            {
                rec::Chdir(gocpp::recv(log), wd);
            }
        }
        return nullptr;
    }

    // Open opens the named file for reading. If successful, methods on
    // the returned file can be used for reading; the associated file
    // descriptor has mode O_RDONLY.
    // If there is an error, it will be of type *PathError.
    std::tuple<struct File*, struct gocpp::error> Open(std::string name)
    {
        return OpenFile(name, O_RDONLY, 0);
    }

    // Create creates or truncates the named file. If the file already exists,
    // it is truncated. If the file does not exist, it is created with mode 0666
    // (before umask). If successful, methods on the returned File can
    // be used for I/O; the associated file descriptor has mode O_RDWR.
    // If there is an error, it will be of type *PathError.
    std::tuple<struct File*, struct gocpp::error> Create(std::string name)
    {
        return OpenFile(name, O_RDWR | O_CREATE | O_TRUNC, 0666);
    }

    // OpenFile is the generalized open call; most users will use Open
    // or Create instead. It opens the named file with specified flag
    // (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag
    // is passed, it is created with mode perm (before umask). If successful,
    // methods on the returned File can be used for I/O.
    // If there is an error, it will be of type *PathError.
    std::tuple<struct File*, struct gocpp::error> OpenFile(std::string name, int flag, golang::os::FileMode perm)
    {
        testlog::Open(name);
        auto [f, err] = openFileNolog(name, flag, perm);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        f->appendMode = flag & O_APPEND != 0;
        return {f, nullptr};
    }

    // lstat is overridden in tests.
    fs::FileInfo, gocpp::error> (std::string)> lstat = Lstat;
    // Rename renames (moves) oldpath to newpath.
    // If newpath already exists and is not a directory, Rename replaces it.
    // OS-specific restrictions may apply when oldpath and newpath are in different directories.
    // Even within the same directory, on non-Unix platforms Rename is not an atomic operation.
    // If there is an error, it will be of type *LinkError.
    struct gocpp::error Rename(std::string oldpath, std::string newpath)
    {
        return rename(oldpath, newpath);
    }

    // Readlink returns the destination of the named symbolic link.
    // If there is an error, it will be of type *PathError.
    //
    // If the link destination is relative, Readlink returns the relative path
    // without resolving it to an absolute one.
    std::tuple<std::string, struct gocpp::error> Readlink(std::string name)
    {
        return readlink(name);
    }

    // Many functions in package syscall return a count of -1 instead of 0.
    // Using fixCount(call()) instead of call() corrects the count.
    std::tuple<int, struct gocpp::error> fixCount(int n, struct gocpp::error err)
    {
        if(n < 0)
        {
            n = 0;
        }
        return {n, err};
    }

    // checkWrapErr is the test hook to enable checking unexpected wrapped errors of poll.ErrFileClosing.
    // It is set to true in the export_test.go for tests (including fuzz tests).
    bool checkWrapErr = false;
    // wrapErr wraps an error that occurred during an operation on an open file.
    // It passes io.EOF through unchanged, otherwise converts
    // poll.ErrFileClosing to ErrClosed and wraps the error in a PathError.
    struct gocpp::error rec::wrapErr(struct File* f, std::string op, struct gocpp::error err)
    {
        if(err == nullptr || err == io::go_EOF)
        {
            return err;
        }
        if(err == poll::ErrFileClosing)
        {
            err = ErrClosed;
        }
        else
        if(checkWrapErr && errors::Is(err, poll::ErrFileClosing))
        {
            gocpp::panic("unexpected error wrapping poll.ErrFileClosing: "s + rec::Error(gocpp::recv(err)));
        }
        return gocpp::InitPtr<os::PathError>([=](auto& x) {
            x.Op = op;
            x.Path = f->name;
            x.Err = err;
        });
    }

    // TempDir returns the default directory to use for temporary files.
    //
    // On Unix systems, it returns $TMPDIR if non-empty, else /tmp.
    // On Windows, it uses GetTempPath, returning the first non-empty
    // value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
    // On Plan 9, it returns /tmp.
    //
    // The directory is neither guaranteed to exist nor have accessible
    // permissions.
    std::string TempDir()
    {
        return tempDir();
    }

    // UserCacheDir returns the default root directory to use for user-specific
    // cached data. Users should create their own application-specific subdirectory
    // within this one and use that.
    //
    // On Unix systems, it returns $XDG_CACHE_HOME as specified by
    // https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
    // non-empty, else $HOME/.cache.
    // On Darwin, it returns $HOME/Library/Caches.
    // On Windows, it returns %LocalAppData%.
    // On Plan 9, it returns $home/lib/cache.
    //
    // If the location cannot be determined (for example, $HOME is not defined),
    // then it will return an error.
    std::tuple<std::string, struct gocpp::error> UserCacheDir()
    {
        std::string dir = {};
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "windows"s) { conditionId = 0; }
            else if(condition == "darwin"s) { conditionId = 1; }
            else if(condition == "ios"s) { conditionId = 2; }
            else if(condition == "plan9"s) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    dir = Getenv("LocalAppData"s);
                    if(dir == ""s)
                    {
                        return {""s, errors::New("%LocalAppData% is not defined"s)};
                    }
                    break;
                case 1:
                case 2:
                    dir = Getenv("HOME"s);
                    if(dir == ""s)
                    {
                        return {""s, errors::New("$HOME is not defined"s)};
                    }
                    dir += "/Library/Caches"s;
                    break;
                case 3:
                    dir = Getenv("home"s);
                    if(dir == ""s)
                    {
                        return {""s, errors::New("$home is not defined"s)};
                    }
                    dir += "/lib/cache"s;
                    break;
                default:
                    dir = Getenv("XDG_CACHE_HOME"s);
                    if(dir == ""s)
                    {
                        dir = Getenv("HOME"s);
                        if(dir == ""s)
                        {
                            return {""s, errors::New("neither $XDG_CACHE_HOME nor $HOME are defined"s)};
                        }
                        dir += "/.cache"s;
                    }
                    break;
            }
        }
        return {dir, nullptr};
    }

    // UserConfigDir returns the default root directory to use for user-specific
    // configuration data. Users should create their own application-specific
    // subdirectory within this one and use that.
    //
    // On Unix systems, it returns $XDG_CONFIG_HOME as specified by
    // https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
    // non-empty, else $HOME/.config.
    // On Darwin, it returns $HOME/Library/Application Support.
    // On Windows, it returns %AppData%.
    // On Plan 9, it returns $home/lib.
    //
    // If the location cannot be determined (for example, $HOME is not defined),
    // then it will return an error.
    std::tuple<std::string, struct gocpp::error> UserConfigDir()
    {
        std::string dir = {};
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "windows"s) { conditionId = 0; }
            else if(condition == "darwin"s) { conditionId = 1; }
            else if(condition == "ios"s) { conditionId = 2; }
            else if(condition == "plan9"s) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    dir = Getenv("AppData"s);
                    if(dir == ""s)
                    {
                        return {""s, errors::New("%AppData% is not defined"s)};
                    }
                    break;
                case 1:
                case 2:
                    dir = Getenv("HOME"s);
                    if(dir == ""s)
                    {
                        return {""s, errors::New("$HOME is not defined"s)};
                    }
                    dir += "/Library/Application Support"s;
                    break;
                case 3:
                    dir = Getenv("home"s);
                    if(dir == ""s)
                    {
                        return {""s, errors::New("$home is not defined"s)};
                    }
                    dir += "/lib"s;
                    break;
                default:
                    dir = Getenv("XDG_CONFIG_HOME"s);
                    if(dir == ""s)
                    {
                        dir = Getenv("HOME"s);
                        if(dir == ""s)
                        {
                            return {""s, errors::New("neither $XDG_CONFIG_HOME nor $HOME are defined"s)};
                        }
                        dir += "/.config"s;
                    }
                    break;
            }
        }
        return {dir, nullptr};
    }

    // UserHomeDir returns the current user's home directory.
    //
    // On Unix, including macOS, it returns the $HOME environment variable.
    // On Windows, it returns %USERPROFILE%.
    // On Plan 9, it returns the $home environment variable.
    //
    // If the expected variable is not set in the environment, UserHomeDir
    // returns either a platform-specific default value or a non-nil error.
    std::tuple<std::string, struct gocpp::error> UserHomeDir()
    {
        auto [env, enverr] = std::tuple{"HOME"s, "$HOME"s};
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "windows"s) { conditionId = 0; }
            else if(condition == "plan9"s) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    std::tie(env, enverr) = std::tuple{"USERPROFILE"s, "%userprofile%"s};
                    break;
                case 1:
                    std::tie(env, enverr) = std::tuple{"home"s, "$home"s};
                    break;
            }
        }
        if(auto v = Getenv(env); v != ""s)
        {
            return {v, nullptr};
        }
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "android"s) { conditionId = 0; }
            else if(condition == "ios"s) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return {"/sdcard"s, nullptr};
                    break;
                case 1:
                    return {"/"s, nullptr};
                    break;
            }
        }
        return {""s, errors::New(enverr + " is not defined"s)};
    }

    // Chmod changes the mode of the named file to mode.
    // If the file is a symbolic link, it changes the mode of the link's target.
    // If there is an error, it will be of type *PathError.
    //
    // A different subset of the mode bits are used, depending on the
    // operating system.
    //
    // On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and
    // ModeSticky are used.
    //
    // On Windows, only the 0200 bit (owner writable) of mode is used; it
    // controls whether the file's read-only attribute is set or cleared.
    // The other bits are currently unused. For compatibility with Go 1.12
    // and earlier, use a non-zero mode. Use mode 0400 for a read-only
    // file and 0600 for a readable+writable file.
    //
    // On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,
    // and ModeTemporary are used.
    struct gocpp::error Chmod(std::string name, golang::os::FileMode mode)
    {
        return chmod(name, mode);
    }

    // Chmod changes the mode of the file to mode.
    // If there is an error, it will be of type *PathError.
    struct gocpp::error rec::Chmod(struct File* f, golang::os::FileMode mode)
    {
        return rec::chmod(gocpp::recv(f), mode);
    }

    // SetDeadline sets the read and write deadlines for a File.
    // It is equivalent to calling both SetReadDeadline and SetWriteDeadline.
    //
    // Only some kinds of files support setting a deadline. Calls to SetDeadline
    // for files that do not support deadlines will return ErrNoDeadline.
    // On most systems ordinary files do not support deadlines, but pipes do.
    //
    // A deadline is an absolute time after which I/O operations fail with an
    // error instead of blocking. The deadline applies to all future and pending
    // I/O, not just the immediately following call to Read or Write.
    // After a deadline has been exceeded, the connection can be refreshed
    // by setting a deadline in the future.
    //
    // If the deadline is exceeded a call to Read or Write or to other I/O
    // methods will return an error that wraps ErrDeadlineExceeded.
    // This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
    // That error implements the Timeout method, and calling the Timeout
    // method will return true, but there are other possible errors for which
    // the Timeout will return true even if the deadline has not been exceeded.
    //
    // An idle timeout can be implemented by repeatedly extending
    // the deadline after successful Read or Write calls.
    //
    // A zero value for t means I/O operations will not time out.
    struct gocpp::error rec::SetDeadline(struct File* f, mocklib::Date t)
    {
        return rec::setDeadline(gocpp::recv(f), t);
    }

    // SetReadDeadline sets the deadline for future Read calls and any
    // currently-blocked Read call.
    // A zero value for t means Read will not time out.
    // Not all files support setting deadlines; see SetDeadline.
    struct gocpp::error rec::SetReadDeadline(struct File* f, mocklib::Date t)
    {
        return rec::setReadDeadline(gocpp::recv(f), t);
    }

    // SetWriteDeadline sets the deadline for any future Write calls and any
    // currently-blocked Write call.
    // Even if Write times out, it may return n > 0, indicating that
    // some of the data was successfully written.
    // A zero value for t means Write will not time out.
    // Not all files support setting deadlines; see SetDeadline.
    struct gocpp::error rec::SetWriteDeadline(struct File* f, mocklib::Date t)
    {
        return rec::setWriteDeadline(gocpp::recv(f), t);
    }

    // SyscallConn returns a raw file.
    // This implements the syscall.Conn interface.
    std::tuple<syscall::RawConn, struct gocpp::error> rec::SyscallConn(struct File* f)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SyscallConn"s); err != nullptr)
        {
            return {nullptr, err};
        }
        return newRawConn(f);
    }

    // DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.
    //
    // Note that DirFS("/prefix") only guarantees that the Open calls it makes to the
    // operating system will begin with "/prefix": DirFS("/prefix").Open("file") is the
    // same as os.Open("/prefix/file"). So if /prefix/file is a symbolic link pointing outside
    // the /prefix tree, then using DirFS does not stop the access any more than using
    // os.Open does. Additionally, the root of the fs.FS returned for a relative path,
    // DirFS("prefix"), will be affected by later calls to Chdir. DirFS is therefore not
    // a general substitute for a chroot-style security mechanism when the directory tree
    // contains arbitrary content.
    //
    // The directory dir must not be "".
    //
    // The result implements [io/fs.StatFS], [io/fs.ReadFileFS] and
    // [io/fs.ReadDirFS].
    fs::FS DirFS(std::string dir)
    {
        return dirFS(dir);
    }

    std::tuple<fs::File, struct gocpp::error> rec::Open(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "open"s;
                x.Path = name;
                x.Err = err;
            })};
        }
        File* f;
        std::tie(f, err) = Open(fullname);
        if(err != nullptr)
        {
            gocpp::getValue<os::PathError*>(err)->Path = name;
            return {nullptr, err};
        }
        return {f, nullptr};
    }

    // The ReadFile method calls the [ReadFile] function for the file
    // with the given name in the directory. The function provides
    // robust handling for small files and special file systems.
    // Through this method, dirFS implements [io/fs.ReadFileFS].
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadFile(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "readfile"s;
                x.Path = name;
                x.Err = err;
            })};
        }
        gocpp::slice<unsigned char> b;
        std::tie(b, err) = ReadFile(fullname);
        if(err != nullptr)
        {
            if(auto [e, ok] = gocpp::getValue<os::PathError*>(err); ok)
            {
                e->Path = name;
            }
            return {nullptr, err};
        }
        return {b, nullptr};
    }

    // ReadDir reads the named directory, returning all its directory entries sorted
    // by filename. Through this method, dirFS implements [io/fs.ReadDirFS].
    std::tuple<gocpp::slice<os::DirEntry>, struct gocpp::error> rec::ReadDir(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "readdir"s;
                x.Path = name;
                x.Err = err;
            })};
        }
        fs::DirEntry> entries;
        std::tie(entries, err) = ReadDir(fullname);
        if(err != nullptr)
        {
            if(auto [e, ok] = gocpp::getValue<os::PathError*>(err); ok)
            {
                e->Path = name;
            }
            return {nullptr, err};
        }
        return {entries, nullptr};
    }

    std::tuple<fs::FileInfo, struct gocpp::error> rec::Stat(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "stat"s;
                x.Path = name;
                x.Err = err;
            })};
        }
        fs::FileInfo f;
        std::tie(f, err) = Stat(fullname);
        if(err != nullptr)
        {
            gocpp::getValue<os::PathError*>(err)->Path = name;
            return {nullptr, err};
        }
        return {f, nullptr};
    }

    // join returns the path for name in dir.
    std::tuple<std::string, struct gocpp::error> rec::join(golang::os::dirFS dir, std::string name)
    {
        if(dir == ""s)
        {
            return {""s, errors::New("os: DirFS with empty root"s)};
        }
        if(! fs::ValidPath(name))
        {
            return {""s, ErrInvalid};
        }
        auto [name_tmp, err] = safefilepath::FromFS(name);
        auto& name = name_tmp;
        if(err != nullptr)
        {
            return {""s, ErrInvalid};
        }
        if(IsPathSeparator(dir[len(dir) - 1]))
        {
            return {std::string(dir) + name, nullptr};
        }
        return {std::string(dir) + std::string(PathSeparator) + name, nullptr};
    }

    // ReadFile reads the named file and returns the contents.
    // A successful call returns err == nil, not err == EOF.
    // Because ReadFile reads the whole file, it does not treat an EOF from Read
    // as an error to be reported.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadFile(std::string name)
    {
        gocpp::Defer defer;
        try
        {
            auto [f, err] = Open(name);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(f)); });
            int size = {};
            if(auto [info, err] = rec::Stat(gocpp::recv(f)); err == nullptr)
            {
                auto size64 = rec::Size(gocpp::recv(info));
                if(int64_t(int(size64)) == size64)
                {
                    size = int(size64);
                }
            }
            size++;
            if(size < 512)
            {
                size = 512;
            }
            auto data = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, size);
            for(; ; )
            {
                auto [n, err] = rec::Read(gocpp::recv(f), data.make_slice(len(data), cap(data)));
                data = data.make_slice(0, len(data) + n);
                if(err != nullptr)
                {
                    if(err == io::go_EOF)
                    {
                        err = nullptr;
                    }
                    return {data, err};
                }
                if(len(data) >= cap(data))
                {
                    auto d = append(data.make_slice(0, cap(data)), 0);
                    data = d.make_slice(0, len(data));
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // WriteFile writes data to the named file, creating it if necessary.
    // If the file does not exist, WriteFile creates it with permissions perm (before umask);
    // otherwise WriteFile truncates it before writing, without changing permissions.
    // Since WriteFile requires multiple system calls to complete, a failure mid-operation
    // can leave the file in a partially written state.
    struct gocpp::error WriteFile(std::string name, gocpp::slice<unsigned char> data, golang::os::FileMode perm)
    {
        auto [f, err] = OpenFile(name, O_WRONLY | O_CREATE | O_TRUNC, perm);
        if(err != nullptr)
        {
            return err;
        }
        std::tie(gocpp_id_0, err) = rec::Write(gocpp::recv(f), data);
        if(auto err1 = rec::Close(gocpp::recv(f)); err1 != nullptr && err == nullptr)
        {
            err = err1;
        }
        return err;
    }

}

