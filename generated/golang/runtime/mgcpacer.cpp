// generated by GoCpp from file '$(ImportDir)/runtime/mgcpacer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcpacer.h"
#include "gocpp/support.h"

// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
#include "golang/internal/goexperiment/exp_heapminimum512kib_off.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/lfstack.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
// #include "golang/runtime/mgcsweep.h"  [Ignored, known errors]
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]

namespace golang::runtime
{
    gcControllerState gcController;
    
    std::ostream& gcControllerState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << gcPercent;
        os << " " << memoryLimit;
        os << " " << heapMinimum;
        os << " " << runway;
        os << " " << consMark;
        os << " " << lastConsMark;
        os << " " << gcPercentHeapGoal;
        os << " " << sweepDistMinTrigger;
        os << " " << triggered;
        os << " " << lastHeapGoal;
        os << " " << heapLive;
        os << " " << heapScan;
        os << " " << lastHeapScan;
        os << " " << lastStackScan;
        os << " " << maxStackScan;
        os << " " << globalsScan;
        os << " " << heapMarked;
        os << " " << heapScanWork;
        os << " " << stackScanWork;
        os << " " << globalsScanWork;
        os << " " << bgScanCredit;
        os << " " << assistTime;
        os << " " << dedicatedMarkTime;
        os << " " << fractionalMarkTime;
        os << " " << idleMarkTime;
        os << " " << markStartTime;
        os << " " << dedicatedMarkWorkersNeeded;
        os << " " << idleMarkWorkers;
        os << " " << assistWorkPerByte;
        os << " " << assistBytesPerWork;
        os << " " << fractionalUtilizationGoal;
        os << " " << heapInUse;
        os << " " << heapReleased;
        os << " " << heapFree;
        os << " " << totalAlloc;
        os << " " << totalFree;
        os << " " << mappedReady;
        os << " " << test;
        os << " " << _;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcControllerState& value)
    {
        return value.PrintTo(os);
    }

    void init(struct gcControllerState* c, int32_t gcPercent, int64_t memoryLimit)
    {
        c->heapMinimum = defaultHeapMinimum;
        c->triggered = ~ uint64_t(0);
        setGCPercent(gocpp::recv(c), gcPercent);
        setMemoryLimit(gocpp::recv(c), memoryLimit);
        commit(gocpp::recv(c), true);
    }

    void startCycle(struct gcControllerState* c, int64_t markStartTime, int procs, gcTrigger trigger)
    {
        Store(gocpp::recv(c->heapScanWork), 0);
        Store(gocpp::recv(c->stackScanWork), 0);
        Store(gocpp::recv(c->globalsScanWork), 0);
        Store(gocpp::recv(c->bgScanCredit), 0);
        Store(gocpp::recv(c->assistTime), 0);
        Store(gocpp::recv(c->dedicatedMarkTime), 0);
        Store(gocpp::recv(c->fractionalMarkTime), 0);
        Store(gocpp::recv(c->idleMarkTime), 0);
        c->markStartTime = markStartTime;
        c->triggered = Load(gocpp::recv(c->heapLive));
        auto totalUtilizationGoal = double(procs) * gcBackgroundUtilization;
        auto dedicatedMarkWorkersNeeded = int64_t(totalUtilizationGoal + 0.5);
        auto utilError = double(dedicatedMarkWorkersNeeded) / totalUtilizationGoal - 1;
        auto maxUtilError = 0.3;
        if(utilError < - maxUtilError || utilError > maxUtilError)
        {
            if(double(dedicatedMarkWorkersNeeded) > totalUtilizationGoal)
            {
                dedicatedMarkWorkersNeeded--;
            }
            c->fractionalUtilizationGoal = (totalUtilizationGoal - double(dedicatedMarkWorkersNeeded)) / double(procs);
        }
        else
        {
            c->fractionalUtilizationGoal = 0;
        }
        if(debug.gcstoptheworld > 0)
        {
            dedicatedMarkWorkersNeeded = int64_t(procs);
            c->fractionalUtilizationGoal = 0;
        }
        for(auto [_, p] : allp)
        {
            p->gcAssistTime = 0;
            p->gcFractionalMarkTime = 0;
        }
        if(trigger.kind == gcTriggerTime)
        {
            if(dedicatedMarkWorkersNeeded > 0)
            {
                setMaxIdleMarkWorkers(gocpp::recv(c), 0);
            }
            else
            {
                setMaxIdleMarkWorkers(gocpp::recv(c), 1);
            }
        }
        else
        {
            setMaxIdleMarkWorkers(gocpp::recv(c), int32_t(procs) - int32_t(dedicatedMarkWorkersNeeded));
        }
        Store(gocpp::recv(c->dedicatedMarkWorkersNeeded), dedicatedMarkWorkersNeeded);
        revise(gocpp::recv(c));
        if(debug.gcpacertrace > 0)
        {
            auto heapGoal = heapGoal(gocpp::recv(c));
            auto assistRatio = Load(gocpp::recv(c->assistWorkPerByte));
            print("pacer: assist ratio=", assistRatio, " (scan ", Load(gocpp::recv(gcController.heapScan)) >> 20, " MB in ", work.initialHeapLive >> 20, "->", heapGoal >> 20, " MB)", " workers=", dedicatedMarkWorkersNeeded, "+", c->fractionalUtilizationGoal, "\n");
        }
    }

    void revise(struct gcControllerState* c)
    {
        auto gcPercent = Load(gocpp::recv(c->gcPercent));
        if(gcPercent < 0)
        {
            gcPercent = 100000;
        }
        auto live = Load(gocpp::recv(c->heapLive));
        auto scan = Load(gocpp::recv(c->heapScan));
        auto work = Load(gocpp::recv(c->heapScanWork)) + Load(gocpp::recv(c->stackScanWork)) + Load(gocpp::recv(c->globalsScanWork));
        auto heapGoal = int64_t(heapGoal(gocpp::recv(c)));
        auto scanWorkExpected = int64_t(c->lastHeapScan + Load(gocpp::recv(c->lastStackScan)) + Load(gocpp::recv(c->globalsScan)));
        auto maxStackScan = Load(gocpp::recv(c->maxStackScan));
        auto maxScanWork = int64_t(scan + maxStackScan + Load(gocpp::recv(c->globalsScan)));
        if(work > scanWorkExpected)
        {
            auto extHeapGoal = int64_t(double(heapGoal - int64_t(c->triggered)) / double(scanWorkExpected) * double(maxScanWork)) + int64_t(c->triggered);
            scanWorkExpected = maxScanWork;
            auto hardGoal = int64_t((1.0 + double(gcPercent) / 100.0) * double(heapGoal));
            if(extHeapGoal > hardGoal)
            {
                extHeapGoal = hardGoal;
            }
            heapGoal = extHeapGoal;
        }
        if(int64_t(live) > heapGoal)
        {
            auto maxOvershoot = 1.1;
            heapGoal = int64_t(double(heapGoal) * maxOvershoot);
            scanWorkExpected = maxScanWork;
        }
        auto scanWorkRemaining = scanWorkExpected - work;
        if(scanWorkRemaining < 1000)
        {
            scanWorkRemaining = 1000;
        }
        auto heapRemaining = heapGoal - int64_t(live);
        if(heapRemaining <= 0)
        {
            heapRemaining = 1;
        }
        auto assistWorkPerByte = double(scanWorkRemaining) / double(heapRemaining);
        auto assistBytesPerWork = double(heapRemaining) / double(scanWorkRemaining);
        Store(gocpp::recv(c->assistWorkPerByte), assistWorkPerByte);
        Store(gocpp::recv(c->assistBytesPerWork), assistBytesPerWork);
    }

    void endCycle(struct gcControllerState* c, int64_t now, int procs, bool userForced)
    {
        gcController.lastHeapGoal = heapGoal(gocpp::recv(c));
        auto assistDuration = now - c->markStartTime;
        auto utilization = gcBackgroundUtilization;
        if(assistDuration > 0)
        {
            utilization += double(Load(gocpp::recv(c->assistTime))) / double(assistDuration * int64_t(procs));
        }
        if(Load(gocpp::recv(c->heapLive)) <= c->triggered)
        {
            return;
        }
        auto idleUtilization = 0.0;
        if(assistDuration > 0)
        {
            idleUtilization = double(Load(gocpp::recv(c->idleMarkTime))) / double(assistDuration * int64_t(procs));
        }
        auto scanWork = Load(gocpp::recv(c->heapScanWork)) + Load(gocpp::recv(c->stackScanWork)) + Load(gocpp::recv(c->globalsScanWork));
        auto currentConsMark = (double(Load(gocpp::recv(c->heapLive)) - c->triggered) * (utilization + idleUtilization)) / (double(scanWork) * (1 - utilization));
        auto oldConsMark = c->consMark;
        c->consMark = currentConsMark;
        for(auto [i, gocpp_ignored] : c->lastConsMark)
        {
            if(c->lastConsMark[i] > c->consMark)
            {
                c->consMark = c->lastConsMark[i];
            }
        }
        copy(c->lastConsMark.make_slice(0, ), c->lastConsMark.make_slice(1));
        c->lastConsMark[len(c->lastConsMark) - 1] = currentConsMark;
        if(debug.gcpacertrace > 0)
        {
            printlock();
            auto goal = gcGoalUtilization * 100;
            print("pacer: ", int(utilization * 100), "% CPU (", int(goal), " exp.) for ");
            print(Load(gocpp::recv(c->heapScanWork)), "+", Load(gocpp::recv(c->stackScanWork)), "+", Load(gocpp::recv(c->globalsScanWork)), " B work (", c->lastHeapScan + Load(gocpp::recv(c->lastStackScan)) + Load(gocpp::recv(c->globalsScan)), " B exp.) ");
            auto live = Load(gocpp::recv(c->heapLive));
            print("in ", c->triggered, " B -> ", live, " B (âˆ†goal ", int64_t(live) - int64_t(c->lastHeapGoal), ", cons/mark ", oldConsMark, ")");
            println();
            printunlock();
        }
    }

    void enlistWorker(struct gcControllerState* c)
    {
        if(Load(gocpp::recv(c->dedicatedMarkWorkersNeeded)) <= 0)
        {
            return;
        }
        if(gomaxprocs <= 1)
        {
            return;
        }
        auto gp = getg();
        if(gp == nullptr || gp->m == nullptr || gp->m->p == 0)
        {
            return;
        }
        auto myID = ptr(gocpp::recv(gp->m->p))->id;
        for(auto tries = 0; tries < 5; tries++)
        {
            auto id = int32_t(cheaprandn(uint32_t(gomaxprocs - 1)));
            if(id >= myID)
            {
                id++;
            }
            auto p = allp[id];
            if(p->status != _Prunning)
            {
                continue;
            }
            if(preemptone(p))
            {
                return;
            }
        }
    }

    std::tuple<g*, int64_t> findRunnableGCWorker(struct gcControllerState* c, p* pp, int64_t now)
    {
        if(gcBlackenEnabled == 0)
        {
            go_throw("gcControllerState.findRunnable: blackening not enabled");
        }
        if(now == 0)
        {
            now = nanotime();
        }
        if(needUpdate(gocpp::recv(gcCPULimiter), now))
        {
            update(gocpp::recv(gcCPULimiter), now);
        }
        if(! gcMarkWorkAvailable(pp))
        {
            return {nullptr, now};
        }
        auto node = (gcBgMarkWorkerNode*)(pop(gocpp::recv(gcBgMarkWorkerPool)));
        if(node == nullptr)
        {
            return {nullptr, now};
        }
        auto decIfPositive = [=](atomic::Int64* val) mutable -> bool
        {
            for(; ; )
            {
                auto v = Load(gocpp::recv(val));
                if(v <= 0)
                {
                    return false;
                }
                if(CompareAndSwap(gocpp::recv(val), v, v - 1))
                {
                    return true;
                }
            }
        }
;
        if(decIfPositive(& c->dedicatedMarkWorkersNeeded))
        {
            pp->gcMarkWorkerMode = gcMarkWorkerDedicatedMode;
        }
        else
        if(c->fractionalUtilizationGoal == 0)
        {
            push(gocpp::recv(gcBgMarkWorkerPool), & node->node);
            return {nullptr, now};
        }
        else
        {
            auto delta = now - c->markStartTime;
            if(delta > 0 && double(pp->gcFractionalMarkTime) / double(delta) > c->fractionalUtilizationGoal)
            {
                push(gocpp::recv(gcBgMarkWorkerPool), & node->node);
                return {nullptr, now};
            }
            pp->gcMarkWorkerMode = gcMarkWorkerFractionalMode;
        }
        auto gp = ptr(gocpp::recv(node->gp));
        auto trace = traceAcquire();
        casgstatus(gp, _Gwaiting, _Grunnable);
        if(ok(gocpp::recv(trace)))
        {
            GoUnpark(gocpp::recv(trace), gp, 0);
            traceRelease(trace);
        }
        return {gp, now};
    }

    void resetLive(struct gcControllerState* c, uint64_t bytesMarked)
    {
        c->heapMarked = bytesMarked;
        Store(gocpp::recv(c->heapLive), bytesMarked);
        Store(gocpp::recv(c->heapScan), uint64_t(Load(gocpp::recv(c->heapScanWork))));
        c->lastHeapScan = uint64_t(Load(gocpp::recv(c->heapScanWork)));
        Store(gocpp::recv(c->lastStackScan), uint64_t(Load(gocpp::recv(c->stackScanWork))));
        c->triggered = ~ uint64_t(0);
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            HeapAlloc(gocpp::recv(trace), bytesMarked);
            traceRelease(trace);
        }
    }

    void markWorkerStop(struct gcControllerState* c, gcMarkWorkerMode mode, int64_t duration)
    {
        //Go switch emulation
        {
            auto condition = mode;
            int conditionId = -1;
            if(condition == gcMarkWorkerDedicatedMode) { conditionId = 0; }
            else if(condition == gcMarkWorkerFractionalMode) { conditionId = 1; }
            else if(condition == gcMarkWorkerIdleMode) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    Add(gocpp::recv(c->dedicatedMarkTime), duration);
                    Add(gocpp::recv(c->dedicatedMarkWorkersNeeded), 1);
                    break;
                case 1:
                    Add(gocpp::recv(c->fractionalMarkTime), duration);
                    break;
                case 2:
                    Add(gocpp::recv(c->idleMarkTime), duration);
                    removeIdleMarkWorker(gocpp::recv(c));
                    break;
                default:
                    go_throw("markWorkerStop: unknown mark worker mode");
                    break;
            }
        }
    }

    void update(struct gcControllerState* c, int64_t dHeapLive, int64_t dHeapScan)
    {
        if(dHeapLive != 0)
        {
            auto trace = traceAcquire();
            auto live = Add(gocpp::recv(gcController.heapLive), dHeapLive);
            if(ok(gocpp::recv(trace)))
            {
                HeapAlloc(gocpp::recv(trace), live);
                traceRelease(trace);
            }
        }
        if(gcBlackenEnabled == 0)
        {
            if(dHeapScan != 0)
            {
                Add(gocpp::recv(gcController.heapScan), dHeapScan);
            }
        }
        else
        {
            revise(gocpp::recv(c));
        }
    }

    void addScannableStack(struct gcControllerState* c, p* pp, int64_t amount)
    {
        if(pp == nullptr)
        {
            Add(gocpp::recv(c->maxStackScan), amount);
            return;
        }
        pp->maxStackScanDelta += amount;
        if(pp->maxStackScanDelta >= maxStackScanSlack || pp->maxStackScanDelta <= - maxStackScanSlack)
        {
            Add(gocpp::recv(c->maxStackScan), pp->maxStackScanDelta);
            pp->maxStackScanDelta = 0;
        }
    }

    void addGlobals(struct gcControllerState* c, int64_t amount)
    {
        Add(gocpp::recv(c->globalsScan), amount);
    }

    uint64_t heapGoal(struct gcControllerState* c)
    {
        auto [goal, _] = heapGoalInternal(gocpp::recv(c));
        return goal;
    }

    std::tuple<uint64_t, uint64_t> heapGoalInternal(struct gcControllerState* c)
    {
        uint64_t goal;
        uint64_t minTrigger;
        goal = Load(gocpp::recv(c->gcPercentHeapGoal));
        if(auto newGoal = memoryLimitHeapGoal(gocpp::recv(c)); newGoal < goal)
        {
            uint64_t goal;
            uint64_t minTrigger;
            goal = newGoal;
        }
        else
        {
            uint64_t goal;
            uint64_t minTrigger;
            auto sweepDistTrigger = Load(gocpp::recv(c->sweepDistMinTrigger));
            if(sweepDistTrigger > goal)
            {
                uint64_t goal;
                uint64_t minTrigger;
                goal = sweepDistTrigger;
            }
            minTrigger = sweepDistTrigger;
            auto minRunway = 64 << 10;
            if(c->triggered != ~ uint64_t(0) && goal < c->triggered + minRunway)
            {
                uint64_t goal;
                uint64_t minTrigger;
                goal = c->triggered + minRunway;
            }
        }
        return {goal, minTrigger};
    }

    uint64_t memoryLimitHeapGoal(struct gcControllerState* c)
    {
        uint64_t heapFree = {};
        uint64_t heapAlloc = {};
        uint64_t mappedReady = {};
        for(; ; )
        {
            heapFree = load(gocpp::recv(c->heapFree));
            heapAlloc = Load(gocpp::recv(c->totalAlloc)) - Load(gocpp::recv(c->totalFree));
            mappedReady = Load(gocpp::recv(c->mappedReady));
            if(heapFree + heapAlloc <= mappedReady)
            {
                break;
            }
        }
        auto memoryLimit = uint64_t(Load(gocpp::recv(c->memoryLimit)));
        auto nonHeapMemory = mappedReady - heapFree - heapAlloc;
        uint64_t overage = {};
        if(mappedReady > memoryLimit)
        {
            overage = mappedReady - memoryLimit;
        }
        if(nonHeapMemory + overage >= memoryLimit)
        {
            return c->heapMarked;
        }
        auto goal = memoryLimit - (nonHeapMemory + overage);
        auto headroom = goal / 100 * memoryLimitHeapGoalHeadroomPercent;
        if(headroom < memoryLimitMinHeapGoalHeadroom)
        {
            headroom = memoryLimitMinHeapGoalHeadroom;
        }
        if(goal < headroom || goal - headroom < headroom)
        {
            goal = headroom;
        }
        else
        {
            goal = goal - headroom;
        }
        if(goal < c->heapMarked)
        {
            goal = c->heapMarked;
        }
        return goal;
    }

    std::tuple<uint64_t, uint64_t> trigger(struct gcControllerState* c)
    {
        auto [goal, minTrigger] = heapGoalInternal(gocpp::recv(c));
        if(c->heapMarked >= goal)
        {
            return {goal, goal};
        }
        if(minTrigger < c->heapMarked)
        {
            minTrigger = c->heapMarked;
        }
        auto triggerLowerBound = ((goal - c->heapMarked) / triggerRatioDen) * minTriggerRatioNum + c->heapMarked;
        if(minTrigger < triggerLowerBound)
        {
            minTrigger = triggerLowerBound;
        }
        auto maxTrigger = ((goal - c->heapMarked) / triggerRatioDen) * maxTriggerRatioNum + c->heapMarked;
        if(goal > defaultHeapMinimum && goal - defaultHeapMinimum > maxTrigger)
        {
            maxTrigger = goal - defaultHeapMinimum;
        }
        maxTrigger = max(maxTrigger, minTrigger);
        uint64_t trigger = {};
        auto runway = Load(gocpp::recv(c->runway));
        if(runway > goal)
        {
            trigger = minTrigger;
        }
        else
        {
            trigger = goal - runway;
        }
        trigger = max(trigger, minTrigger);
        trigger = min(trigger, maxTrigger);
        if(trigger > goal)
        {
            print("trigger=", trigger, " heapGoal=", goal, "\n");
            print("minTrigger=", minTrigger, " maxTrigger=", maxTrigger, "\n");
            go_throw("produced a trigger greater than the heap goal");
        }
        return {trigger, goal};
    }

    void commit(struct gcControllerState* c, bool isSweepDone)
    {
        if(! c->test)
        {
            assertWorldStoppedOrLockHeld(& mheap_.lock);
        }
        if(isSweepDone)
        {
            Store(gocpp::recv(c->sweepDistMinTrigger), 0);
        }
        else
        {
            Store(gocpp::recv(c->sweepDistMinTrigger), Load(gocpp::recv(c->heapLive)) + sweepMinHeapDistance);
        }
        auto gcPercentHeapGoal = ~ uint64_t(0);
        if(auto gcPercent = Load(gocpp::recv(c->gcPercent)); gcPercent >= 0)
        {
            gcPercentHeapGoal = c->heapMarked + (c->heapMarked + Load(gocpp::recv(c->lastStackScan)) + Load(gocpp::recv(c->globalsScan))) * uint64_t(gcPercent) / 100;
        }
        if(gcPercentHeapGoal < c->heapMinimum)
        {
            gcPercentHeapGoal = c->heapMinimum;
        }
        Store(gocpp::recv(c->gcPercentHeapGoal), gcPercentHeapGoal);
        Store(gocpp::recv(c->runway), uint64_t((c->consMark * (1 - gcGoalUtilization) / (gcGoalUtilization)) * double(c->lastHeapScan + Load(gocpp::recv(c->lastStackScan)) + Load(gocpp::recv(c->globalsScan)))));
    }

    int32_t setGCPercent(struct gcControllerState* c, int32_t in)
    {
        if(! c->test)
        {
            assertWorldStoppedOrLockHeld(& mheap_.lock);
        }
        auto out = Load(gocpp::recv(c->gcPercent));
        if(in < 0)
        {
            in = - 1;
        }
        c->heapMinimum = defaultHeapMinimum * uint64_t(in) / 100;
        Store(gocpp::recv(c->gcPercent), in);
        return out;
    }

    int32_t setGCPercent(int32_t in)
    {
        int32_t out;
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            out = setGCPercent(gocpp::recv(gcController), in);
            gcControllerCommit();
            unlock(& mheap_.lock);
        }
);
        if(in < 0)
        {
            int32_t out;
            gcWaitOnMark(Load(gocpp::recv(work.cycles)));
        }
        return out;
    }

    int32_t readGOGC()
    {
        auto p = gogetenv("GOGC");
        if(p == "off")
        {
            return - 1;
        }
        if(auto [n, ok] = atoi32(p); ok)
        {
            return n;
        }
        return 100;
    }

    int64_t setMemoryLimit(struct gcControllerState* c, int64_t in)
    {
        if(! c->test)
        {
            assertWorldStoppedOrLockHeld(& mheap_.lock);
        }
        auto out = Load(gocpp::recv(c->memoryLimit));
        if(in >= 0)
        {
            Store(gocpp::recv(c->memoryLimit), in);
        }
        return out;
    }

    int64_t setMemoryLimit(int64_t in)
    {
        int64_t out;
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            out = setMemoryLimit(gocpp::recv(gcController), in);
            if(in < 0 || out == in)
            {
                unlock(& mheap_.lock);
                return;
            }
            gcControllerCommit();
            unlock(& mheap_.lock);
        }
);
        return out;
    }

    int64_t readGOMEMLIMIT()
    {
        auto p = gogetenv("GOMEMLIMIT");
        if(p == "" || p == "off")
        {
            return maxInt64;
        }
        auto [n, ok] = parseByteCount(p);
        if(! ok)
        {
            print("GOMEMLIMIT=", p, "\n");
            go_throw("malformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`");
        }
        return n;
    }

    bool addIdleMarkWorker(struct gcControllerState* c)
    {
        for(; ; )
        {
            auto old = Load(gocpp::recv(c->idleMarkWorkers));
            auto [n, max] = std::tuple{int32_t(old & uint64_t(~ uint32_t(0))), int32_t(old >> 32)};
            if(n >= max)
            {
                return false;
            }
            if(n < 0)
            {
                print("n=", n, " max=", max, "\n");
                go_throw("negative idle mark workers");
            }
            auto go_new = uint64_t(uint32_t(n + 1)) | (uint64_t(max) << 32);
            if(CompareAndSwap(gocpp::recv(c->idleMarkWorkers), old, go_new))
            {
                return true;
            }
        }
    }

    bool needIdleMarkWorker(struct gcControllerState* c)
    {
        auto p = Load(gocpp::recv(c->idleMarkWorkers));
        auto [n, max] = std::tuple{int32_t(p & uint64_t(~ uint32_t(0))), int32_t(p >> 32)};
        return n < max;
    }

    void removeIdleMarkWorker(struct gcControllerState* c)
    {
        for(; ; )
        {
            auto old = Load(gocpp::recv(c->idleMarkWorkers));
            auto [n, max] = std::tuple{int32_t(old & uint64_t(~ uint32_t(0))), int32_t(old >> 32)};
            if(n - 1 < 0)
            {
                print("n=", n, " max=", max, "\n");
                go_throw("negative idle mark workers");
            }
            auto go_new = uint64_t(uint32_t(n - 1)) | (uint64_t(max) << 32);
            if(CompareAndSwap(gocpp::recv(c->idleMarkWorkers), old, go_new))
            {
                return;
            }
        }
    }

    void setMaxIdleMarkWorkers(struct gcControllerState* c, int32_t max)
    {
        for(; ; )
        {
            auto old = Load(gocpp::recv(c->idleMarkWorkers));
            auto n = int32_t(old & uint64_t(~ uint32_t(0)));
            if(n < 0)
            {
                print("n=", n, " max=", max, "\n");
                go_throw("negative idle mark workers");
            }
            auto go_new = uint64_t(uint32_t(n)) | (uint64_t(max) << 32);
            if(CompareAndSwap(gocpp::recv(c->idleMarkWorkers), old, go_new))
            {
                return;
            }
        }
    }

    void gcControllerCommit()
    {
        assertWorldStoppedOrLockHeld(& mheap_.lock);
        commit(gocpp::recv(gcController), isSweepDone());
        if(gcphase != _GCoff)
        {
            revise(gocpp::recv(gcController));
        }
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            HeapGoal(gocpp::recv(trace));
            traceRelease(trace);
        }
        auto [trigger, heapGoal] = trigger(gocpp::recv(gcController));
        gcPaceSweeper(trigger);
        gcPaceScavenger(Load(gocpp::recv(gcController.memoryLimit)), heapGoal, gcController.lastHeapGoal);
    }

}

