// generated by GoCpp from file '$(ImportDir)/runtime/utf8.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/utf8.h"
#include "gocpp/support.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    int countrunes(std::string s)
    {
        auto n = 0;
        for(const auto& _ : s)
        {
            n++;
        }
        return n;
    }

    std::tuple<gocpp::rune, int> decoderune(std::string s, int k)
    {
        gocpp::rune r;
        int pos;
        pos = k;
        if(k >= len(s))
        {
            return {runeError, k + 1};
        }
        s = s.make_slice(k);
        //Go switch emulation
        {
            int conditionId = -1;
            if(t2 <= s[0] && s[0] < t3) { conditionId = 0; }
            else if(t3 <= s[0] && s[0] < t4) { conditionId = 1; }
            else if(t4 <= s[0] && s[0] < t5) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    if(len(s) > 1 && (locb <= s[1] && s[1] <= hicb))
                    {
                        r = (gocpp::rune(s[0] & mask2) << 6) | gocpp::rune(s[1] & maskx);
                        pos += 2;
                        if(rune1Max < r)
                        {
                            return {r, pos};
                        }
                    }
                    break;
                case 1:
                    if(len(s) > 2 && (locb <= s[1] && s[1] <= hicb) && (locb <= s[2] && s[2] <= hicb))
                    {
                        r = (gocpp::rune(s[0] & mask3) << 12) | (gocpp::rune(s[1] & maskx) << 6) | gocpp::rune(s[2] & maskx);
                        pos += 3;
                        if(rune2Max < r && ! (surrogateMin <= r && r <= surrogateMax))
                        {
                            return {r, pos};
                        }
                    }
                    break;
                case 2:
                    if(len(s) > 3 && (locb <= s[1] && s[1] <= hicb) && (locb <= s[2] && s[2] <= hicb) && (locb <= s[3] && s[3] <= hicb))
                    {
                        r = (gocpp::rune(s[0] & mask4) << 18) | (gocpp::rune(s[1] & maskx) << 12) | (gocpp::rune(s[2] & maskx) << 6) | gocpp::rune(s[3] & maskx);
                        pos += 4;
                        if(rune3Max < r && r <= maxRune)
                        {
                            return {r, pos};
                        }
                    }
                    break;
            }
        }
        return {runeError, k + 1};
    }

    int encoderune(gocpp::slice<unsigned char> p, gocpp::rune r)
    {
        //Go switch emulation
        {
            auto i = uint32_t(r);
            int conditionId = -1;
            if(i <= rune1Max) { conditionId = 0; }
            else if(i <= rune2Max) { conditionId = 1; }
            else if(i > maxRune) { conditionId = 2; }
            else if(surrogateMin <= i && i <= surrogateMax) { conditionId = 3; }
            else if(i <= rune3Max) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    p[0] = (unsigned char)(r);
                    return 1;
                    break;
                case 1:
                    _ = p[1];
                    p[0] = t2 | (unsigned char)(r >> 6);
                    p[1] = tx | (unsigned char)(r) & maskx;
                    return 2;
                    break;
                case 2:
                case 3:
                    r = runeError;
                case 4:
                    _ = p[2];
                    p[0] = t3 | (unsigned char)(r >> 12);
                    p[1] = tx | (unsigned char)(r >> 6) & maskx;
                    p[2] = tx | (unsigned char)(r) & maskx;
                    return 3;
                    break;
                default:
                    _ = p[3];
                    p[0] = t4 | (unsigned char)(r >> 18);
                    p[1] = tx | (unsigned char)(r >> 12) & maskx;
                    p[2] = tx | (unsigned char)(r >> 6) & maskx;
                    p[3] = tx | (unsigned char)(r) & maskx;
                    return 4;
                    break;
            }
        }
    }

}

