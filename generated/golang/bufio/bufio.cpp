// generated by GoCpp from file '$(ImportDir)/bufio/bufio.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bufio/bufio.h"
#include "gocpp/support.h"

#include "golang/bytes/bytes.h"
#include "golang/errors/errors.h"
#include "golang/io/io.h"
#include "golang/strings/builder.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::bufio
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Read;
        using io::rec::ReadFrom;
        using io::rec::Write;
        using io::rec::WriteString;
        using io::rec::WriteTo;
        using strings::rec::Grow;
        using strings::rec::String;
        using strings::rec::Write;
    }

    gocpp::error ErrInvalidUnreadByte = errors::New("bufio: invalid use of UnreadByte"s);
    gocpp::error ErrInvalidUnreadRune = errors::New("bufio: invalid use of UnreadRune"s);
    gocpp::error ErrBufferFull = errors::New("bufio: buffer full"s);
    gocpp::error ErrNegativeCount = errors::New("bufio: negative count"s);
    
    template<typename T> requires gocpp::GoStruct<T>
    Reader::operator T()
    {
        T result;
        result.buf = this->buf;
        result.rd = this->rd;
        result.r = this->r;
        result.w = this->w;
        result.err = this->err;
        result.lastByte = this->lastByte;
        result.lastRuneSize = this->lastRuneSize;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Reader::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (rd != ref.rd) return false;
        if (r != ref.r) return false;
        if (w != ref.w) return false;
        if (err != ref.err) return false;
        if (lastByte != ref.lastByte) return false;
        if (lastRuneSize != ref.lastRuneSize) return false;
        return true;
    }

    std::ostream& Reader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << rd;
        os << " " << r;
        os << " " << w;
        os << " " << err;
        os << " " << lastByte;
        os << " " << lastRuneSize;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value)
    {
        return value.PrintTo(os);
    }

    struct Reader* NewReaderSize(io::Reader rd, int size)
    {
        auto [b, ok] = gocpp::getValue<Reader*>(rd);
        if(ok && len(b->buf) >= size)
        {
            return b;
        }
        auto r = new(Reader);
        rec::reset(gocpp::recv(r), gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), gocpp::max(size, minReadBufferSize)), rd);
        return r;
    }

    struct Reader* NewReader(io::Reader rd)
    {
        return NewReaderSize(rd, defaultBufSize);
    }

    int rec::Size(struct Reader* b)
    {
        return len(b->buf);
    }

    void rec::Reset(struct Reader* b, io::Reader r)
    {
        if(b == r)
        {
            return;
        }
        if(b->buf == nullptr)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), defaultBufSize);
        }
        rec::reset(gocpp::recv(b), b->buf, r);
    }

    void rec::reset(struct Reader* b, gocpp::slice<unsigned char> buf, io::Reader r)
    {
        *b = gocpp::Init<Reader>([=](auto& x) {
            x.buf = buf;
            x.rd = r;
            x.lastByte = - 1;
            x.lastRuneSize = - 1;
        });
    }

    gocpp::error errNegativeRead = errors::New("bufio: reader returned negative count from Read"s);
    void rec::fill(struct Reader* b)
    {
        if(b->r > 0)
        {
            copy(b->buf, b->buf.make_slice(b->r, b->w));
            b->w -= b->r;
            b->r = 0;
        }
        if(b->w >= len(b->buf))
        {
            gocpp::panic("bufio: tried to fill full buffer"s);
        }
        for(auto i = maxConsecutiveEmptyReads; i > 0; i--)
        {
            auto [n, err] = rec::Read(gocpp::recv(b->rd), b->buf.make_slice(b->w));
            if(n < 0)
            {
                gocpp::panic(errNegativeRead);
            }
            b->w += n;
            if(err != nullptr)
            {
                b->err = err;
                return;
            }
            if(n > 0)
            {
                return;
            }
        }
        b->err = io::ErrNoProgress;
    }

    struct gocpp::error rec::readErr(struct Reader* b)
    {
        auto err = b->err;
        b->err = nullptr;
        return err;
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::Peek(struct Reader* b, int n)
    {
        if(n < 0)
        {
            return {nullptr, ErrNegativeCount};
        }
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        for(; b->w - b->r < n && b->w - b->r < len(b->buf) && b->err == nullptr; )
        {
            rec::fill(gocpp::recv(b));
        }
        if(n > len(b->buf))
        {
            return {b->buf.make_slice(b->r, b->w), ErrBufferFull};
        }
        gocpp::error err = {};
        if(auto avail = b->w - b->r; avail < n)
        {
            n = avail;
            err = rec::readErr(gocpp::recv(b));
            if(err == nullptr)
            {
                err = ErrBufferFull;
            }
        }
        return {b->buf.make_slice(b->r, b->r + n), err};
    }

    std::tuple<int, struct gocpp::error> rec::Discard(struct Reader* b, int n)
    {
        int discarded;
        struct gocpp::error err;
        if(n < 0)
        {
            return {0, ErrNegativeCount};
        }
        if(n == 0)
        {
            return {discarded, err};
        }
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        auto remain = n;
        for(; ; )
        {
            auto skip = rec::Buffered(gocpp::recv(b));
            if(skip == 0)
            {
                rec::fill(gocpp::recv(b));
                skip = rec::Buffered(gocpp::recv(b));
            }
            if(skip > remain)
            {
                skip = remain;
            }
            b->r += skip;
            remain -= skip;
            if(remain == 0)
            {
                return {n, nullptr};
            }
            if(b->err != nullptr)
            {
                return {n - remain, rec::readErr(gocpp::recv(b))};
            }
        }
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct Reader* b, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        n = len(p);
        if(n == 0)
        {
            if(rec::Buffered(gocpp::recv(b)) > 0)
            {
                return {0, nullptr};
            }
            return {0, rec::readErr(gocpp::recv(b))};
        }
        if(b->r == b->w)
        {
            if(b->err != nullptr)
            {
                return {0, rec::readErr(gocpp::recv(b))};
            }
            if(len(p) >= len(b->buf))
            {
                std::tie(n, b->err) = rec::Read(gocpp::recv(b->rd), p);
                if(n < 0)
                {
                    gocpp::panic(errNegativeRead);
                }
                if(n > 0)
                {
                    b->lastByte = int(p[n - 1]);
                    b->lastRuneSize = - 1;
                }
                return {n, rec::readErr(gocpp::recv(b))};
            }
            b->r = 0;
            b->w = 0;
            std::tie(n, b->err) = rec::Read(gocpp::recv(b->rd), b->buf);
            if(n < 0)
            {
                gocpp::panic(errNegativeRead);
            }
            if(n == 0)
            {
                return {0, rec::readErr(gocpp::recv(b))};
            }
            b->w += n;
        }
        n = copy(p, b->buf.make_slice(b->r, b->w));
        b->r += n;
        b->lastByte = int(b->buf[b->r - 1]);
        b->lastRuneSize = - 1;
        return {n, nullptr};
    }

    std::tuple<unsigned char, struct gocpp::error> rec::ReadByte(struct Reader* b)
    {
        b->lastRuneSize = - 1;
        for(; b->r == b->w; )
        {
            if(b->err != nullptr)
            {
                return {0, rec::readErr(gocpp::recv(b))};
            }
            rec::fill(gocpp::recv(b));
        }
        auto c = b->buf[b->r];
        b->r++;
        b->lastByte = int(c);
        return {c, nullptr};
    }

    struct gocpp::error rec::UnreadByte(struct Reader* b)
    {
        if(b->lastByte < 0 || b->r == 0 && b->w > 0)
        {
            return ErrInvalidUnreadByte;
        }
        if(b->r > 0)
        {
            b->r--;
        }
        else
        {
            b->w = 1;
        }
        b->buf[b->r] = (unsigned char)(b->lastByte);
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        return nullptr;
    }

    std::tuple<gocpp::rune, int, struct gocpp::error> rec::ReadRune(struct Reader* b)
    {
        gocpp::rune r;
        int size;
        struct gocpp::error err;
        for(; b->r + utf8::UTFMax > b->w && ! utf8::FullRune(b->buf.make_slice(b->r, b->w)) && b->err == nullptr && b->w - b->r < len(b->buf); )
        {
            rec::fill(gocpp::recv(b));
        }
        b->lastRuneSize = - 1;
        if(b->r == b->w)
        {
            return {0, 0, rec::readErr(gocpp::recv(b))};
        }
        std::tie(r, size) = std::tuple{gocpp::rune(b->buf[b->r]), 1};
        if(r >= utf8::RuneSelf)
        {
            std::tie(r, size) = utf8::DecodeRune(b->buf.make_slice(b->r, b->w));
        }
        b->r += size;
        b->lastByte = int(b->buf[b->r - 1]);
        b->lastRuneSize = size;
        return {r, size, nullptr};
    }

    struct gocpp::error rec::UnreadRune(struct Reader* b)
    {
        if(b->lastRuneSize < 0 || b->r < b->lastRuneSize)
        {
            return ErrInvalidUnreadRune;
        }
        b->r -= b->lastRuneSize;
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        return nullptr;
    }

    int rec::Buffered(struct Reader* b)
    {
        return b->w - b->r;
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadSlice(struct Reader* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        struct gocpp::error err;
        auto s = 0;
        for(; ; )
        {
            if(auto i = bytes::IndexByte(b->buf.make_slice(b->r + s, b->w), delim); i >= 0)
            {
                i += s;
                line = b->buf.make_slice(b->r, b->r + i + 1);
                b->r += i + 1;
                break;
            }
            if(b->err != nullptr)
            {
                line = b->buf.make_slice(b->r, b->w);
                b->r = b->w;
                err = rec::readErr(gocpp::recv(b));
                break;
            }
            if(rec::Buffered(gocpp::recv(b)) >= len(b->buf))
            {
                b->r = b->w;
                line = b->buf;
                err = ErrBufferFull;
                break;
            }
            s = b->w - b->r;
            rec::fill(gocpp::recv(b));
        }
        if(auto i = len(line) - 1; i >= 0)
        {
            b->lastByte = int(line[i]);
            b->lastRuneSize = - 1;
        }
        return {line, err};
    }

    std::tuple<gocpp::slice<unsigned char>, bool, struct gocpp::error> rec::ReadLine(struct Reader* b)
    {
        gocpp::slice<unsigned char> line;
        bool isPrefix;
        struct gocpp::error err;
        std::tie(line, err) = rec::ReadSlice(gocpp::recv(b), '\n');
        if(err == ErrBufferFull)
        {
            if(len(line) > 0 && line[len(line) - 1] == '\r')
            {
                if(b->r == 0)
                {
                    gocpp::panic("bufio: tried to rewind past start of buffer"s);
                }
                b->r--;
                line = line.make_slice(0, len(line) - 1);
            }
            return {line, true, nullptr};
        }
        if(len(line) == 0)
        {
            if(err != nullptr)
            {
                line = nullptr;
            }
            return {line, isPrefix, err};
        }
        err = nullptr;
        if(line[len(line) - 1] == '\n')
        {
            auto drop = 1;
            if(len(line) > 1 && line[len(line) - 2] == '\r')
            {
                drop = 2;
            }
            line = line.make_slice(0, len(line) - drop);
        }
        return {line, isPrefix, err};
    }

    std::tuple<gocpp::slice<gocpp::slice<unsigned char>>, gocpp::slice<unsigned char>, int, struct gocpp::error> rec::collectFragments(struct Reader* b, unsigned char delim)
    {
        gocpp::slice<gocpp::slice<unsigned char>> fullBuffers;
        gocpp::slice<unsigned char> finalFragment;
        int totalLen;
        struct gocpp::error err;
        gocpp::slice<unsigned char> frag = {};
        for(; ; )
        {
            gocpp::error e = {};
            std::tie(frag, e) = rec::ReadSlice(gocpp::recv(b), delim);
            if(e == nullptr)
            {
                break;
            }
            if(e != ErrBufferFull)
            {
                err = e;
                break;
            }
            auto buf = bytes::Clone(frag);
            fullBuffers = append(fullBuffers, buf);
            totalLen += len(buf);
        }
        totalLen += len(frag);
        return {fullBuffers, frag, totalLen, err};
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadBytes(struct Reader* b, unsigned char delim)
    {
        auto [full, frag, n, err] = rec::collectFragments(gocpp::recv(b), delim);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
        n = 0;
        for(auto [i, gocpp_ignored] : full)
        {
            n += copy(buf.make_slice(n), full[i]);
        }
        copy(buf.make_slice(n), frag);
        return {buf, err};
    }

    std::tuple<std::string, struct gocpp::error> rec::ReadString(struct Reader* b, unsigned char delim)
    {
        auto [full, frag, n, err] = rec::collectFragments(gocpp::recv(b), delim);
        strings::Builder buf = {};
        rec::Grow(gocpp::recv(buf), n);
        for(auto [gocpp_ignored, fb] : full)
        {
            rec::Write(gocpp::recv(buf), fb);
        }
        rec::Write(gocpp::recv(buf), frag);
        return {rec::String(gocpp::recv(buf)), err};
    }

    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct Reader* b, io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        b->lastByte = - 1;
        b->lastRuneSize = - 1;
        std::tie(n, err) = rec::writeBuf(gocpp::recv(b), w);
        if(err != nullptr)
        {
            return {n, err};
        }
        if(auto [r, ok] = gocpp::getValue<io::WriterTo>(b->rd); ok)
        {
            auto [m, err] = rec::WriteTo(gocpp::recv(r), w);
            n += m;
            return {n, err};
        }
        if(auto [w, ok] = gocpp::getValue<io::ReaderFrom>(w); ok)
        {
            auto [m, err] = rec::ReadFrom(gocpp::recv(w), b->rd);
            n += m;
            return {n, err};
        }
        if(b->w - b->r < len(b->buf))
        {
            rec::fill(gocpp::recv(b));
        }
        for(; b->r < b->w; )
        {
            auto [m, err] = rec::writeBuf(gocpp::recv(b), w);
            n += m;
            if(err != nullptr)
            {
                return {n, err};
            }
            rec::fill(gocpp::recv(b));
        }
        if(b->err == io::go_EOF)
        {
            b->err = nullptr;
        }
        return {n, rec::readErr(gocpp::recv(b))};
    }

    gocpp::error errNegativeWrite = errors::New("bufio: writer returned negative count from Write"s);
    std::tuple<int64_t, struct gocpp::error> rec::writeBuf(struct Reader* b, io::Writer w)
    {
        auto [n, err] = rec::Write(gocpp::recv(w), b->buf.make_slice(b->r, b->w));
        if(n < 0)
        {
            gocpp::panic(errNegativeWrite);
        }
        b->r += n;
        return {int64_t(n), err};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Writer::operator T()
    {
        T result;
        result.err = this->err;
        result.buf = this->buf;
        result.n = this->n;
        result.wr = this->wr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Writer::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (buf != ref.buf) return false;
        if (n != ref.n) return false;
        if (wr != ref.wr) return false;
        return true;
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << buf;
        os << " " << n;
        os << " " << wr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    struct Writer* NewWriterSize(io::Writer w, int size)
    {
        auto [b, ok] = gocpp::getValue<Writer*>(w);
        if(ok && len(b->buf) >= size)
        {
            return b;
        }
        if(size <= 0)
        {
            size = defaultBufSize;
        }
        return gocpp::InitPtr<Writer>([=](auto& x) {
            x.buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
            x.wr = w;
        });
    }

    struct Writer* NewWriter(io::Writer w)
    {
        return NewWriterSize(w, defaultBufSize);
    }

    int rec::Size(struct Writer* b)
    {
        return len(b->buf);
    }

    void rec::Reset(struct Writer* b, io::Writer w)
    {
        if(b == w)
        {
            return;
        }
        if(b->buf == nullptr)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), defaultBufSize);
        }
        b->err = nullptr;
        b->n = 0;
        b->wr = w;
    }

    struct gocpp::error rec::Flush(struct Writer* b)
    {
        if(b->err != nullptr)
        {
            return b->err;
        }
        if(b->n == 0)
        {
            return nullptr;
        }
        auto [n, err] = rec::Write(gocpp::recv(b->wr), b->buf.make_slice(0, b->n));
        if(n < b->n && err == nullptr)
        {
            err = io::ErrShortWrite;
        }
        if(err != nullptr)
        {
            if(n > 0 && n < b->n)
            {
                copy(b->buf.make_slice(0, b->n - n), b->buf.make_slice(n, b->n));
            }
            b->n -= n;
            b->err = err;
            return err;
        }
        b->n = 0;
        return nullptr;
    }

    int rec::Available(struct Writer* b)
    {
        return len(b->buf) - b->n;
    }

    gocpp::slice<unsigned char> rec::AvailableBuffer(struct Writer* b)
    {
        return b->buf.make_slice(b->n).make_slice(0, 0);
    }

    int rec::Buffered(struct Writer* b)
    {
        return b->n;
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct Writer* b, gocpp::slice<unsigned char> p)
    {
        int nn;
        struct gocpp::error err;
        for(; len(p) > rec::Available(gocpp::recv(b)) && b->err == nullptr; )
        {
            int n = {};
            if(rec::Buffered(gocpp::recv(b)) == 0)
            {
                std::tie(n, b->err) = rec::Write(gocpp::recv(b->wr), p);
            }
            else
            {
                n = copy(b->buf.make_slice(b->n), p);
                b->n += n;
                rec::Flush(gocpp::recv(b));
            }
            nn += n;
            p = p.make_slice(n);
        }
        if(b->err != nullptr)
        {
            return {nn, b->err};
        }
        auto n = copy(b->buf.make_slice(b->n), p);
        b->n += n;
        nn += n;
        return {nn, nullptr};
    }

    struct gocpp::error rec::WriteByte(struct Writer* b, unsigned char c)
    {
        if(b->err != nullptr)
        {
            return b->err;
        }
        if(rec::Available(gocpp::recv(b)) <= 0 && rec::Flush(gocpp::recv(b)) != nullptr)
        {
            return b->err;
        }
        b->buf[b->n] = c;
        b->n++;
        return nullptr;
    }

    std::tuple<int, struct gocpp::error> rec::WriteRune(struct Writer* b, gocpp::rune r)
    {
        int size;
        struct gocpp::error err;
        if(uint32_t(r) < utf8::RuneSelf)
        {
            err = rec::WriteByte(gocpp::recv(b), (unsigned char)(r));
            if(err != nullptr)
            {
                return {0, err};
            }
            return {1, nullptr};
        }
        if(b->err != nullptr)
        {
            return {0, b->err};
        }
        auto n = rec::Available(gocpp::recv(b));
        if(n < utf8::UTFMax)
        {
            if(rec::Flush(gocpp::recv(b)); b->err != nullptr)
            {
                return {0, b->err};
            }
            n = rec::Available(gocpp::recv(b));
            if(n < utf8::UTFMax)
            {
                return rec::WriteString(gocpp::recv(b), std::string(r));
            }
        }
        size = utf8::EncodeRune(b->buf.make_slice(b->n), r);
        b->n += size;
        return {size, nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::WriteString(struct Writer* b, std::string s)
    {
        io::StringWriter sw = {};
        auto tryStringWriter = true;
        auto nn = 0;
        for(; len(s) > rec::Available(gocpp::recv(b)) && b->err == nullptr; )
        {
            int n = {};
            if(rec::Buffered(gocpp::recv(b)) == 0 && sw == nullptr && tryStringWriter)
            {
                std::tie(sw, tryStringWriter) = gocpp::getValue<io::StringWriter>(b->wr);
            }
            if(rec::Buffered(gocpp::recv(b)) == 0 && tryStringWriter)
            {
                std::tie(n, b->err) = rec::WriteString(gocpp::recv(sw), s);
            }
            else
            {
                n = copy(b->buf.make_slice(b->n), s);
                b->n += n;
                rec::Flush(gocpp::recv(b));
            }
            nn += n;
            s = s.make_slice(n);
        }
        if(b->err != nullptr)
        {
            return {nn, b->err};
        }
        auto n = copy(b->buf.make_slice(b->n), s);
        b->n += n;
        nn += n;
        return {nn, nullptr};
    }

    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(struct Writer* b, io::Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        if(b->err != nullptr)
        {
            return {0, b->err};
        }
        auto [readerFrom, readerFromOK] = gocpp::getValue<io::ReaderFrom>(b->wr);
        int m = {};
        for(; ; )
        {
            if(rec::Available(gocpp::recv(b)) == 0)
            {
                if(auto err1 = rec::Flush(gocpp::recv(b)); err1 != nullptr)
                {
                    return {n, err1};
                }
            }
            if(readerFromOK && rec::Buffered(gocpp::recv(b)) == 0)
            {
                auto [nn, err] = rec::ReadFrom(gocpp::recv(readerFrom), r);
                b->err = err;
                n += nn;
                return {n, err};
            }
            auto nr = 0;
            for(; nr < maxConsecutiveEmptyReads; )
            {
                std::tie(m, err) = rec::Read(gocpp::recv(r), b->buf.make_slice(b->n));
                if(m != 0 || err != nullptr)
                {
                    break;
                }
                nr++;
            }
            if(nr == maxConsecutiveEmptyReads)
            {
                return {n, io::ErrNoProgress};
            }
            b->n += m;
            n += int64_t(m);
            if(err != nullptr)
            {
                break;
            }
        }
        if(err == io::go_EOF)
        {
            if(rec::Available(gocpp::recv(b)) == 0)
            {
                err = rec::Flush(gocpp::recv(b));
            }
            else
            {
                err = nullptr;
            }
        }
        return {n, err};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ReadWriter::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ReadWriter::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& ReadWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ReadWriter& value)
    {
        return value.PrintTo(os);
    }

    struct ReadWriter* NewReadWriter(struct Reader* r, struct Writer* w)
    {
        return new ReadWriter {r, w};
    }

}

