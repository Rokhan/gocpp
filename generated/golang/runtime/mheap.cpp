// generated by GoCpp from file '$(ImportDir)/runtime/mheap.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mheap.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
#include "golang/internal/cpu/cpu_x86.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/runtime/asan0.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcmark.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
#include "golang/runtime/mgcstack.h"
// #include "golang/runtime/mgcsweep.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    /* bool physPageAlignedStacks = GOOS == "openbsd" [known mising deps] */;
    
    template<typename T> requires gocpp::GoStruct<T>
    mheap::operator T()
    {
        T result;
        result._ = this->_;
        result.lock = this->lock;
        result.pages = this->pages;
        result.sweepgen = this->sweepgen;
        result.allspans = this->allspans;
        result.pagesInUse = this->pagesInUse;
        result.pagesSwept = this->pagesSwept;
        result.pagesSweptBasis = this->pagesSweptBasis;
        result.sweepHeapLiveBasis = this->sweepHeapLiveBasis;
        result.sweepPagesPerByte = this->sweepPagesPerByte;
        result.reclaimIndex = this->reclaimIndex;
        result.reclaimCredit = this->reclaimCredit;
        result._ = this->_;
        result.arenas = this->arenas;
        result.arenasHugePages = this->arenasHugePages;
        result.heapArenaAlloc = this->heapArenaAlloc;
        result.arenaHints = this->arenaHints;
        result.arena = this->arena;
        result.allArenas = this->allArenas;
        result.sweepArenas = this->sweepArenas;
        result.markArenas = this->markArenas;
        result.curArena = this->curArena;
        result.central = this->central;
        result.spanalloc = this->spanalloc;
        result.cachealloc = this->cachealloc;
        result.specialfinalizeralloc = this->specialfinalizeralloc;
        result.specialprofilealloc = this->specialprofilealloc;
        result.specialReachableAlloc = this->specialReachableAlloc;
        result.specialPinCounterAlloc = this->specialPinCounterAlloc;
        result.speciallock = this->speciallock;
        result.arenaHintAlloc = this->arenaHintAlloc;
        result.userArena = this->userArena;
        result.unused = this->unused;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mheap::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (lock != ref.lock) return false;
        if (pages != ref.pages) return false;
        if (sweepgen != ref.sweepgen) return false;
        if (allspans != ref.allspans) return false;
        if (pagesInUse != ref.pagesInUse) return false;
        if (pagesSwept != ref.pagesSwept) return false;
        if (pagesSweptBasis != ref.pagesSweptBasis) return false;
        if (sweepHeapLiveBasis != ref.sweepHeapLiveBasis) return false;
        if (sweepPagesPerByte != ref.sweepPagesPerByte) return false;
        if (reclaimIndex != ref.reclaimIndex) return false;
        if (reclaimCredit != ref.reclaimCredit) return false;
        if (_ != ref._) return false;
        if (arenas != ref.arenas) return false;
        if (arenasHugePages != ref.arenasHugePages) return false;
        if (heapArenaAlloc != ref.heapArenaAlloc) return false;
        if (arenaHints != ref.arenaHints) return false;
        if (arena != ref.arena) return false;
        if (allArenas != ref.allArenas) return false;
        if (sweepArenas != ref.sweepArenas) return false;
        if (markArenas != ref.markArenas) return false;
        if (curArena != ref.curArena) return false;
        if (central != ref.central) return false;
        if (spanalloc != ref.spanalloc) return false;
        if (cachealloc != ref.cachealloc) return false;
        if (specialfinalizeralloc != ref.specialfinalizeralloc) return false;
        if (specialprofilealloc != ref.specialprofilealloc) return false;
        if (specialReachableAlloc != ref.specialReachableAlloc) return false;
        if (specialPinCounterAlloc != ref.specialPinCounterAlloc) return false;
        if (speciallock != ref.speciallock) return false;
        if (arenaHintAlloc != ref.arenaHintAlloc) return false;
        if (userArena != ref.userArena) return false;
        if (unused != ref.unused) return false;
        return true;
    }

    std::ostream& mheap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << lock;
        os << " " << pages;
        os << " " << sweepgen;
        os << " " << allspans;
        os << " " << pagesInUse;
        os << " " << pagesSwept;
        os << " " << pagesSweptBasis;
        os << " " << sweepHeapLiveBasis;
        os << " " << sweepPagesPerByte;
        os << " " << reclaimIndex;
        os << " " << reclaimCredit;
        os << " " << _;
        os << " " << arenas;
        os << " " << arenasHugePages;
        os << " " << heapArenaAlloc;
        os << " " << arenaHints;
        os << " " << arena;
        os << " " << allArenas;
        os << " " << sweepArenas;
        os << " " << markArenas;
        os << " " << curArena;
        os << " " << central;
        os << " " << spanalloc;
        os << " " << cachealloc;
        os << " " << specialfinalizeralloc;
        os << " " << specialprofilealloc;
        os << " " << specialReachableAlloc;
        os << " " << specialPinCounterAlloc;
        os << " " << speciallock;
        os << " " << arenaHintAlloc;
        os << " " << userArena;
        os << " " << unused;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mheap& value)
    {
        return value.PrintTo(os);
    }

    mheap mheap_;
    
    template<typename T> requires gocpp::GoStruct<T>
    heapArena::operator T()
    {
        T result;
        result._ = this->_;
        result.spans = this->spans;
        result.pageInUse = this->pageInUse;
        result.pageMarks = this->pageMarks;
        result.pageSpecials = this->pageSpecials;
        result.checkmarks = this->checkmarks;
        result.zeroedBase = this->zeroedBase;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heapArena::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (spans != ref.spans) return false;
        if (pageInUse != ref.pageInUse) return false;
        if (pageMarks != ref.pageMarks) return false;
        if (pageSpecials != ref.pageSpecials) return false;
        if (checkmarks != ref.checkmarks) return false;
        if (zeroedBase != ref.zeroedBase) return false;
        return true;
    }

    std::ostream& heapArena::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << spans;
        os << " " << pageInUse;
        os << " " << pageMarks;
        os << " " << pageSpecials;
        os << " " << checkmarks;
        os << " " << zeroedBase;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapArena& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    arenaHint::operator T()
    {
        T result;
        result._ = this->_;
        result.addr = this->addr;
        result.down = this->down;
        result.next = this->next;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool arenaHint::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (addr != ref.addr) return false;
        if (down != ref.down) return false;
        if (next != ref.next) return false;
        return true;
    }

    std::ostream& arenaHint::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << addr;
        os << " " << down;
        os << " " << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct arenaHint& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<std::string> mSpanStateNames = gocpp::slice<std::string> {"mSpanDead", "mSpanInUse", "mSpanManual"};
    
    template<typename T> requires gocpp::GoStruct<T>
    mSpanStateBox::operator T()
    {
        T result;
        result.s = this->s;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mSpanStateBox::operator==(const T& ref) const
    {
        if (s != ref.s) return false;
        return true;
    }

    std::ostream& mSpanStateBox::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << s;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mSpanStateBox& value)
    {
        return value.PrintTo(os);
    }

    void set(struct mSpanStateBox* b, mSpanState s)
    {
        Store(gocpp::recv(b->s), uint8_t(s));
    }

    mSpanState get(struct mSpanStateBox* b)
    {
        return mSpanState(Load(gocpp::recv(b->s)));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mSpanList::operator T()
    {
        T result;
        result._ = this->_;
        result.first = this->first;
        result.last = this->last;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mSpanList::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (first != ref.first) return false;
        if (last != ref.last) return false;
        return true;
    }

    std::ostream& mSpanList::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << first;
        os << " " << last;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mSpanList& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mspan::operator T()
    {
        T result;
        result._ = this->_;
        result.next = this->next;
        result.prev = this->prev;
        result.list = this->list;
        result.startAddr = this->startAddr;
        result.npages = this->npages;
        result.manualFreeList = this->manualFreeList;
        result.freeindex = this->freeindex;
        result.nelems = this->nelems;
        result.freeIndexForScan = this->freeIndexForScan;
        result.allocCache = this->allocCache;
        result.allocBits = this->allocBits;
        result.gcmarkBits = this->gcmarkBits;
        result.pinnerBits = this->pinnerBits;
        result.sweepgen = this->sweepgen;
        result.divMul = this->divMul;
        result.allocCount = this->allocCount;
        result.spanclass = this->spanclass;
        result.state = this->state;
        result.needzero = this->needzero;
        result.isUserArenaChunk = this->isUserArenaChunk;
        result.allocCountBeforeCache = this->allocCountBeforeCache;
        result.elemsize = this->elemsize;
        result.limit = this->limit;
        result.speciallock = this->speciallock;
        result.specials = this->specials;
        result.userArenaChunkFree = this->userArenaChunkFree;
        result.largeType = this->largeType;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mspan::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (next != ref.next) return false;
        if (prev != ref.prev) return false;
        if (list != ref.list) return false;
        if (startAddr != ref.startAddr) return false;
        if (npages != ref.npages) return false;
        if (manualFreeList != ref.manualFreeList) return false;
        if (freeindex != ref.freeindex) return false;
        if (nelems != ref.nelems) return false;
        if (freeIndexForScan != ref.freeIndexForScan) return false;
        if (allocCache != ref.allocCache) return false;
        if (allocBits != ref.allocBits) return false;
        if (gcmarkBits != ref.gcmarkBits) return false;
        if (pinnerBits != ref.pinnerBits) return false;
        if (sweepgen != ref.sweepgen) return false;
        if (divMul != ref.divMul) return false;
        if (allocCount != ref.allocCount) return false;
        if (spanclass != ref.spanclass) return false;
        if (state != ref.state) return false;
        if (needzero != ref.needzero) return false;
        if (isUserArenaChunk != ref.isUserArenaChunk) return false;
        if (allocCountBeforeCache != ref.allocCountBeforeCache) return false;
        if (elemsize != ref.elemsize) return false;
        if (limit != ref.limit) return false;
        if (speciallock != ref.speciallock) return false;
        if (specials != ref.specials) return false;
        if (userArenaChunkFree != ref.userArenaChunkFree) return false;
        if (largeType != ref.largeType) return false;
        return true;
    }

    std::ostream& mspan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << next;
        os << " " << prev;
        os << " " << list;
        os << " " << startAddr;
        os << " " << npages;
        os << " " << manualFreeList;
        os << " " << freeindex;
        os << " " << nelems;
        os << " " << freeIndexForScan;
        os << " " << allocCache;
        os << " " << allocBits;
        os << " " << gcmarkBits;
        os << " " << pinnerBits;
        os << " " << sweepgen;
        os << " " << divMul;
        os << " " << allocCount;
        os << " " << spanclass;
        os << " " << state;
        os << " " << needzero;
        os << " " << isUserArenaChunk;
        os << " " << allocCountBeforeCache;
        os << " " << elemsize;
        os << " " << limit;
        os << " " << speciallock;
        os << " " << specials;
        os << " " << userArenaChunkFree;
        os << " " << largeType;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mspan& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t base(struct mspan* s)
    {
        return s->startAddr;
    }

    std::tuple<uintptr_t, uintptr_t, uintptr_t> layout(struct mspan* s)
    {
        uintptr_t size;
        uintptr_t n;
        uintptr_t total;
        total = s->npages << _PageShift;
        size = s->elemsize;
        if(size > 0)
        {
            uintptr_t size;
            uintptr_t n;
            uintptr_t total;
            n = total / size;
        }
        return {size, n, total};
    }

    void recordspan(unsafe::Pointer vh, unsafe::Pointer p)
    {
        auto h = (mheap*)(vh);
        auto s = (mspan*)(p);
        assertLockHeld(& h->lock);
        if(len(h->allspans) >= cap(h->allspans))
        {
            auto n = 64 * 1024 / goarch::PtrSize;
            if(n < cap(h->allspans) * 3 / 2)
            {
                n = cap(h->allspans) * 3 / 2;
            }
            gocpp::slice<mspan*> go_new = {};
            auto sp = (slice*)(unsafe::Pointer(& go_new));
            sp->array = sysAlloc(uintptr_t(n) * goarch::PtrSize, & memstats.other_sys);
            if(sp->array == nullptr)
            {
                go_throw("runtime: cannot allocate memory");
            }
            sp->len = len(h->allspans);
            sp->cap = n;
            if(len(h->allspans) > 0)
            {
                copy(go_new, h->allspans);
            }
            auto oldAllspans = h->allspans;
            *(notInHeapSlice*)(unsafe::Pointer(& h->allspans)) = *(notInHeapSlice*)(unsafe::Pointer(& go_new));
            if(len(oldAllspans) != 0)
            {
                sysFree(unsafe::Pointer(& oldAllspans[0]), uintptr_t(cap(oldAllspans)) * gocpp::Sizeof<mspan*>(), & memstats.other_sys);
            }
        }
        h->allspans = h->allspans.make_slice(0, len(h->allspans) + 1);
        h->allspans[len(h->allspans) - 1] = s;
    }

    spanClass makeSpanClass(uint8_t sizeclass, bool noscan)
    {
        return spanClass(sizeclass << 1) | spanClass(bool2int(noscan));
    }

    int8_t sizeclass(spanClass sc)
    {
        return int8_t(sc >> 1);
    }

    bool noscan(spanClass sc)
    {
        return sc & 1 != 0;
    }

    arenaIdx arenaIndex(uintptr_t p)
    {
        return arenaIdx((p - arenaBaseOffset) / heapArenaBytes);
    }

    uintptr_t arenaBase(arenaIdx i)
    {
        return uintptr_t(i) * heapArenaBytes + arenaBaseOffset;
    }

    unsigned int l1(arenaIdx i)
    {
        if(arenaL1Bits == 0)
        {
            return 0;
        }
        else
        {
            return (unsigned int)(i) >> arenaL1Shift;
        }
    }

    unsigned int l2(arenaIdx i)
    {
        if(arenaL1Bits == 0)
        {
            return (unsigned int)(i);
        }
        else
        {
            return (unsigned int)(i) & ((1 << arenaL2Bits) - 1);
        }
    }

    bool inheap(uintptr_t b)
    {
        return spanOfHeap(b) != nullptr;
    }

    bool inHeapOrStack(uintptr_t b)
    {
        auto s = spanOf(b);
        if(s == nullptr || b < base(gocpp::recv(s)))
        {
            return false;
        }
        //Go switch emulation
        {
            auto condition = get(gocpp::recv(s->state));
            int conditionId = -1;
            if(condition == mSpanInUse) { conditionId = 0; }
            if(condition == mSpanManual) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    return b < s->limit;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    struct mspan* spanOf(uintptr_t p)
    {
        auto ri = arenaIndex(p);
        if(arenaL1Bits == 0)
        {
            if(l2(gocpp::recv(ri)) >= (unsigned int)(len(mheap_.arenas[0])))
            {
                return nullptr;
            }
        }
        else
        {
            if(l1(gocpp::recv(ri)) >= (unsigned int)(len(mheap_.arenas)))
            {
                return nullptr;
            }
        }
        auto l2 = mheap_.arenas[l1(gocpp::recv(ri))];
        if(arenaL1Bits != 0 && l2 == nullptr)
        {
            return nullptr;
        }
        auto ha = l2[l2(gocpp::recv(ri))];
        if(ha == nullptr)
        {
            return nullptr;
        }
        return ha->spans[(p / pageSize) % pagesPerArena];
    }

    struct mspan* spanOfUnchecked(uintptr_t p)
    {
        auto ai = arenaIndex(p);
        return mheap_.arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))]->spans[(p / pageSize) % pagesPerArena];
    }

    struct mspan* spanOfHeap(uintptr_t p)
    {
        auto s = spanOf(p);
        if(s == nullptr || get(gocpp::recv(s->state)) != mSpanInUse || p < base(gocpp::recv(s)) || p >= s->limit)
        {
            return nullptr;
        }
        return s;
    }

    std::tuple<struct heapArena*, uintptr_t, uint8_t> pageIndexOf(uintptr_t p)
    {
        struct heapArena* arena;
        uintptr_t pageIdx;
        uint8_t pageMask;
        auto ai = arenaIndex(p);
        arena = mheap_.arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
        pageIdx = ((p / pageSize) / 8) % uintptr_t(len(arena->pageInUse));
        pageMask = unsigned char(1 << ((p / pageSize) % 8));
        return {arena, pageIdx, pageMask};
    }

    void init(struct mheap* h)
    {
        lockInit(& h->lock, lockRankMheap);
        lockInit(& h->speciallock, lockRankMheapSpecial);
        init(gocpp::recv(h->spanalloc), gocpp::Sizeof<mspan>(), recordspan, unsafe::Pointer(h), & memstats.mspan_sys);
        init(gocpp::recv(h->cachealloc), gocpp::Sizeof<mcache>(), nullptr, nullptr, & memstats.mcache_sys);
        init(gocpp::recv(h->specialfinalizeralloc), gocpp::Sizeof<specialfinalizer>(), nullptr, nullptr, & memstats.other_sys);
        init(gocpp::recv(h->specialprofilealloc), gocpp::Sizeof<specialprofile>(), nullptr, nullptr, & memstats.other_sys);
        init(gocpp::recv(h->specialReachableAlloc), gocpp::Sizeof<specialReachable>(), nullptr, nullptr, & memstats.other_sys);
        init(gocpp::recv(h->specialPinCounterAlloc), gocpp::Sizeof<specialPinCounter>(), nullptr, nullptr, & memstats.other_sys);
        init(gocpp::recv(h->arenaHintAlloc), gocpp::Sizeof<arenaHint>(), nullptr, nullptr, & memstats.other_sys);
        h->spanalloc.zero = false;
        for(auto [i, gocpp_ignored] : h->central)
        {
            init(gocpp::recv(h->central[i].mcentral), spanClass(i));
        }
        init(gocpp::recv(h->pages), & h->lock, & memstats.gcMiscSys, false);
    }

    void reclaim(struct mheap* h, uintptr_t npage)
    {
        if(Load(gocpp::recv(h->reclaimIndex)) >= (1 << 63))
        {
            return;
        }
        auto mp = acquirem();
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepStart(gocpp::recv(trace));
            traceRelease(trace);
        }
        auto arenas = h->sweepArenas;
        auto locked = false;
        for(; npage > 0; )
        {
            if(auto credit = Load(gocpp::recv(h->reclaimCredit)); credit > 0)
            {
                auto take = credit;
                if(take > npage)
                {
                    take = npage;
                }
                if(CompareAndSwap(gocpp::recv(h->reclaimCredit), credit, credit - take))
                {
                    npage -= take;
                }
                continue;
            }
            auto idx = uintptr_t(Add(gocpp::recv(h->reclaimIndex), pagesPerReclaimerChunk) - pagesPerReclaimerChunk);
            if(idx / pagesPerArena >= uintptr_t(len(arenas)))
            {
                Store(gocpp::recv(h->reclaimIndex), 1 << 63);
                break;
            }
            if(! locked)
            {
                lock(& h->lock);
                locked = true;
            }
            auto nfound = reclaimChunk(gocpp::recv(h), arenas, idx, pagesPerReclaimerChunk);
            if(nfound <= npage)
            {
                npage -= nfound;
            }
            else
            {
                Add(gocpp::recv(h->reclaimCredit), nfound - npage);
                npage = 0;
            }
        }
        if(locked)
        {
            unlock(& h->lock);
        }
        trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            GCSweepDone(gocpp::recv(trace));
            traceRelease(trace);
        }
        releasem(mp);
    }

    uintptr_t reclaimChunk(struct mheap* h, gocpp::slice<arenaIdx> arenas, uintptr_t pageIdx, uintptr_t n)
    {
        assertLockHeld(& h->lock);
        auto n0 = n;
        uintptr_t nFreed = {};
        auto sl = begin(gocpp::recv(sweep.active));
        if(! sl.valid)
        {
            return 0;
        }
        for(; n > 0; )
        {
            auto ai = arenas[pageIdx / pagesPerArena];
            auto ha = h->arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
            auto arenaPage = (unsigned int)(pageIdx % pagesPerArena);
            auto inUse = ha->pageInUse.make_slice(arenaPage / 8);
            auto marked = ha->pageMarks.make_slice(arenaPage / 8);
            if(uintptr_t(len(inUse)) > n / 8)
            {
                inUse = inUse.make_slice(0, n / 8);
                marked = marked.make_slice(0, n / 8);
            }
            for(auto [i, gocpp_ignored] : inUse)
            {
                auto inUseUnmarked = atomic::Load8(& inUse[i]) &^ marked[i];
                if(inUseUnmarked == 0)
                {
                    continue;
                }
                for(auto j = (unsigned int)(0); j < 8; j++)
                {
                    if(inUseUnmarked & (1 << j) != 0)
                    {
                        auto s = ha->spans[arenaPage + (unsigned int)(i) * 8 + j];
                        if(auto [s, ok] = tryAcquire(gocpp::recv(sl), s); ok)
                        {
                            auto npages = s->npages;
                            unlock(& h->lock);
                            if(sweep(gocpp::recv(s), false))
                            {
                                nFreed += npages;
                            }
                            lock(& h->lock);
                            inUseUnmarked = atomic::Load8(& inUse[i]) &^ marked[i];
                        }
                    }
                }
            }
            pageIdx += uintptr_t(len(inUse) * 8);
            n -= uintptr_t(len(inUse) * 8);
        }
        end(gocpp::recv(sweep.active), sl);
        auto trace = traceAcquire();
        if(ok(gocpp::recv(trace)))
        {
            unlock(& h->lock);
            GCSweepSpan(gocpp::recv(trace), (n0 - nFreed) * pageSize);
            traceRelease(trace);
            lock(& h->lock);
        }
        assertLockHeld(& h->lock);
        return nFreed;
    }

    bool manual(spanAllocType s)
    {
        return s != spanAllocHeap;
    }

    struct mspan* alloc(struct mheap* h, uintptr_t npages, spanClass spanclass)
    {
        mspan* s = {};
        systemstack([=]() mutable -> void
        {
            if(! isSweepDone())
            {
                reclaim(gocpp::recv(h), npages);
            }
            s = allocSpan(gocpp::recv(h), npages, spanAllocHeap, spanclass);
        });
        return s;
    }

    struct mspan* allocManual(struct mheap* h, uintptr_t npages, spanAllocType typ)
    {
        if(! manual(gocpp::recv(typ)))
        {
            go_throw("manual span allocation called with non-manually-managed type");
        }
        return allocSpan(gocpp::recv(h), npages, typ, 0);
    }

    void setSpans(struct mheap* h, uintptr_t base, uintptr_t npage, struct mspan* s)
    {
        auto p = base / pageSize;
        auto ai = arenaIndex(base);
        auto ha = h->arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
        for(auto n = uintptr_t(0); n < npage; n++)
        {
            auto i = (p + n) % pagesPerArena;
            if(i == 0)
            {
                ai = arenaIndex(base + n * pageSize);
                ha = h->arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
            }
            ha->spans[i] = s;
        }
    }

    bool allocNeedsZero(struct mheap* h, uintptr_t base, uintptr_t npage)
    {
        bool needZero;
        for(; npage > 0; )
        {
            bool needZero;
            auto ai = arenaIndex(base);
            auto ha = h->arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
            auto zeroedBase = atomic::Loaduintptr(& ha->zeroedBase);
            auto arenaBase = base % heapArenaBytes;
            if(arenaBase < zeroedBase)
            {
                bool needZero;
                needZero = true;
            }
            auto arenaLimit = arenaBase + npage * pageSize;
            if(arenaLimit > heapArenaBytes)
            {
                bool needZero;
                arenaLimit = heapArenaBytes;
            }
            for(; arenaLimit > zeroedBase; )
            {
                bool needZero;
                if(atomic::Casuintptr(& ha->zeroedBase, zeroedBase, arenaLimit))
                {
                    bool needZero;
                    break;
                }
                zeroedBase = atomic::Loaduintptr(& ha->zeroedBase);
                if(zeroedBase <= arenaLimit && zeroedBase > arenaBase)
                {
                    bool needZero;
                    go_throw("potentially overlapping in-use allocations detected");
                }
            }
            base += arenaLimit - arenaBase;
            npage -= (arenaLimit - arenaBase) / pageSize;
        }
        return needZero;
    }

    struct mspan* tryAllocMSpan(struct mheap* h)
    {
        auto pp = ptr(gocpp::recv(getg()->m->p));
        if(pp == nullptr || pp->mspancache.len == 0)
        {
            return nullptr;
        }
        auto s = pp->mspancache.buf[pp->mspancache.len - 1];
        pp->mspancache.len--;
        return s;
    }

    struct mspan* allocMSpanLocked(struct mheap* h)
    {
        assertLockHeld(& h->lock);
        auto pp = ptr(gocpp::recv(getg()->m->p));
        if(pp == nullptr)
        {
            return (mspan*)(alloc(gocpp::recv(h->spanalloc)));
        }
        if(pp->mspancache.len == 0)
        {
            auto refillCount = len(pp->mspancache.buf) / 2;
            for(auto i = 0; i < refillCount; i++)
            {
                pp->mspancache.buf[i] = (mspan*)(alloc(gocpp::recv(h->spanalloc)));
            }
            pp->mspancache.len = refillCount;
        }
        auto s = pp->mspancache.buf[pp->mspancache.len - 1];
        pp->mspancache.len--;
        return s;
    }

    void freeMSpanLocked(struct mheap* h, struct mspan* s)
    {
        assertLockHeld(& h->lock);
        auto pp = ptr(gocpp::recv(getg()->m->p));
        if(pp != nullptr && pp->mspancache.len < len(pp->mspancache.buf))
        {
            pp->mspancache.buf[pp->mspancache.len] = s;
            pp->mspancache.len++;
            return;
        }
        free(gocpp::recv(h->spanalloc), unsafe::Pointer(s));
    }

    struct mspan* allocSpan(struct mheap* h, uintptr_t npages, spanAllocType typ, spanClass spanclass)
    {
        struct mspan* s;
        auto gp = getg();
        auto [base, scav] = std::tuple{uintptr_t(0), uintptr_t(0)};
        auto growth = uintptr_t(0);
        auto needPhysPageAlign = physPageAlignedStacks && typ == spanAllocStack && pageSize < physPageSize;
        auto pp = ptr(gocpp::recv(gp->m->p));
        if(! needPhysPageAlign && pp != nullptr && npages < pageCachePages / 4)
        {
            struct mspan* s;
            auto c = & pp->pcache;
            if(empty(gocpp::recv(c)))
            {
                struct mspan* s;
                lock(& h->lock);
                *c = allocToCache(gocpp::recv(h->pages));
                unlock(& h->lock);
            }
            std::tie(base, scav) = alloc(gocpp::recv(c), npages);
            if(base != 0)
            {
                struct mspan* s;
                s = tryAllocMSpan(gocpp::recv(h));
                if(s != nullptr)
                {
                    struct mspan* s;
                    goto HaveSpan;
                }
            }
        }
        lock(& h->lock);
        if(needPhysPageAlign)
        {
            struct mspan* s;
            auto extraPages = physPageSize / pageSize;
            std::tie(base, gocpp_id_3) = find(gocpp::recv(h->pages), npages + extraPages);
            if(base == 0)
            {
                struct mspan* s;
                bool ok = {};
                std::tie(growth, ok) = grow(gocpp::recv(h), npages + extraPages);
                if(! ok)
                {
                    struct mspan* s;
                    unlock(& h->lock);
                    return nullptr;
                }
                std::tie(base, gocpp_id_4) = find(gocpp::recv(h->pages), npages + extraPages);
                if(base == 0)
                {
                    struct mspan* s;
                    go_throw("grew heap, but no adequate free space found");
                }
            }
            base = alignUp(base, physPageSize);
            scav = allocRange(gocpp::recv(h->pages), base, npages);
        }
        if(base == 0)
        {
            struct mspan* s;
            std::tie(base, scav) = alloc(gocpp::recv(h->pages), npages);
            if(base == 0)
            {
                struct mspan* s;
                bool ok = {};
                std::tie(growth, ok) = grow(gocpp::recv(h), npages);
                if(! ok)
                {
                    struct mspan* s;
                    unlock(& h->lock);
                    return nullptr;
                }
                std::tie(base, scav) = alloc(gocpp::recv(h->pages), npages);
                if(base == 0)
                {
                    struct mspan* s;
                    go_throw("grew heap, but no adequate free space found");
                }
            }
        }
        if(s == nullptr)
        {
            struct mspan* s;
            s = allocMSpanLocked(gocpp::recv(h));
        }
        unlock(& h->lock);
        HaveSpan:
        auto bytesToScavenge = uintptr_t(0);
        auto forceScavenge = false;
        if(auto limit = Load(gocpp::recv(gcController.memoryLimit)); ! limiting(gocpp::recv(gcCPULimiter)))
        {
            struct mspan* s;
            auto inuse = Load(gocpp::recv(gcController.mappedReady));
            if(uint64_t(scav) + inuse > uint64_t(limit))
            {
                struct mspan* s;
                bytesToScavenge = uintptr_t(uint64_t(scav) + inuse - uint64_t(limit));
                forceScavenge = true;
            }
        }
        if(auto goal = Load(gocpp::recv(scavenge.gcPercentGoal)); goal != ~ uint64_t(0) && growth > 0)
        {
            struct mspan* s;
            if(auto retained = heapRetained(); retained + uint64_t(growth) > goal)
            {
                struct mspan* s;
                auto todo = growth;
                if(auto overage = uintptr_t(retained + uint64_t(growth) - goal); todo > overage)
                {
                    struct mspan* s;
                    todo = overage;
                }
                if(todo > bytesToScavenge)
                {
                    struct mspan* s;
                    bytesToScavenge = todo;
                }
            }
        }
        int64_t now = {};
        if(pp != nullptr && bytesToScavenge > 0)
        {
            struct mspan* s;
            auto start = nanotime();
            auto track = start(gocpp::recv(pp->limiterEvent), limiterEventScavengeAssist, start);
            auto released = scavenge(gocpp::recv(h->pages), bytesToScavenge, [=]() mutable -> bool
            {
                return limiting(gocpp::recv(gcCPULimiter));
            }, forceScavenge);
            Add(gocpp::recv(mheap_.pages.scav.releasedEager), released);
            now = nanotime();
            if(track)
            {
                struct mspan* s;
                stop(gocpp::recv(pp->limiterEvent), limiterEventScavengeAssist, now);
            }
            Add(gocpp::recv(scavenge.assistTime), now - start);
        }
        initSpan(gocpp::recv(h), s, typ, spanclass, base, npages);
        auto nbytes = npages * pageSize;
        if(scav != 0)
        {
            struct mspan* s;
            sysUsed(unsafe::Pointer(base), nbytes, scav);
            add(gocpp::recv(gcController.heapReleased), - int64_t(scav));
        }
        add(gocpp::recv(gcController.heapFree), - int64_t(nbytes - scav));
        if(typ == spanAllocHeap)
        {
            struct mspan* s;
            add(gocpp::recv(gcController.heapInUse), int64_t(nbytes));
        }
        auto stats = acquire(gocpp::recv(memstats.heapStats));
        atomic::Xaddint64(& stats->committed, int64_t(scav));
        atomic::Xaddint64(& stats->released, - int64_t(scav));
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == spanAllocHeap) { conditionId = 0; }
            else if(condition == spanAllocStack) { conditionId = 1; }
            else if(condition == spanAllocPtrScalarBits) { conditionId = 2; }
            else if(condition == spanAllocWorkBuf) { conditionId = 3; }
            switch(conditionId)
            {
                struct mspan* s;
                case 0:
                    atomic::Xaddint64(& stats->inHeap, int64_t(nbytes));
                    break;
                case 1:
                    atomic::Xaddint64(& stats->inStacks, int64_t(nbytes));
                    break;
                case 2:
                    atomic::Xaddint64(& stats->inPtrScalarBits, int64_t(nbytes));
                    break;
                case 3:
                    atomic::Xaddint64(& stats->inWorkBufs, int64_t(nbytes));
                    break;
            }
        }
        release(gocpp::recv(memstats.heapStats));
        pageTraceAlloc(pp, now, base, npages);
        return s;
    }

    void initSpan(struct mheap* h, struct mspan* s, spanAllocType typ, spanClass spanclass, uintptr_t base, uintptr_t npages)
    {
        init(gocpp::recv(s), base, npages);
        if(allocNeedsZero(gocpp::recv(h), base, npages))
        {
            s->needzero = 1;
        }
        auto nbytes = npages * pageSize;
        if(manual(gocpp::recv(typ)))
        {
            s->manualFreeList = 0;
            s->nelems = 0;
            s->limit = base(gocpp::recv(s)) + s->npages * pageSize;
            set(gocpp::recv(s->state), mSpanManual);
        }
        else
        {
            s->spanclass = spanclass;
            if(auto sizeclass = sizeclass(gocpp::recv(spanclass)); sizeclass == 0)
            {
                s->elemsize = nbytes;
                s->nelems = 1;
                s->divMul = 0;
            }
            else
            {
                s->elemsize = uintptr_t(class_to_size[sizeclass]);
                if(goexperiment::AllocHeaders && ! noscan(gocpp::recv(s->spanclass)) && heapBitsInSpan(s->elemsize))
                {
                    s->nelems = uint16_t((nbytes - (nbytes / goarch::PtrSize / 8)) / s->elemsize);
                }
                else
                {
                    s->nelems = uint16_t(nbytes / s->elemsize);
                }
                s->divMul = class_to_divmagic[sizeclass];
            }
            s->freeindex = 0;
            s->freeIndexForScan = 0;
            s->allocCache = ~ uint64_t(0);
            s->gcmarkBits = newMarkBits(uintptr_t(s->nelems));
            s->allocBits = newAllocBits(uintptr_t(s->nelems));
            atomic::Store(& s->sweepgen, h->sweepgen);
            set(gocpp::recv(s->state), mSpanInUse);
        }
        setSpans(gocpp::recv(h), base(gocpp::recv(s)), npages, s);
        if(! manual(gocpp::recv(typ)))
        {
            auto [arena, pageIdx, pageMask] = pageIndexOf(base(gocpp::recv(s)));
            atomic::Or8(& arena->pageInUse[pageIdx], pageMask);
            Add(gocpp::recv(h->pagesInUse), npages);
        }
        publicationBarrier();
    }

    std::tuple<uintptr_t, bool> grow(struct mheap* h, uintptr_t npage)
    {
        assertLockHeld(& h->lock);
        auto ask = alignUp(npage, pallocChunkPages) * pageSize;
        auto totalGrowth = uintptr_t(0);
        auto end = h->curArena.base + ask;
        auto nBase = alignUp(end, physPageSize);
        if(nBase > h->curArena.end || end < h->curArena.base)
        {
            auto [av, asize] = sysAlloc(gocpp::recv(h), ask, & h->arenaHints, true);
            if(av == nullptr)
            {
                auto inUse = load(gocpp::recv(gcController.heapFree)) + load(gocpp::recv(gcController.heapReleased)) + load(gocpp::recv(gcController.heapInUse));
                print("runtime: out of memory: cannot allocate ", ask, "-byte block (", inUse, " in use)\n");
                return {0, false};
            }
            if(uintptr_t(av) == h->curArena.end)
            {
                h->curArena.end = uintptr_t(av) + asize;
            }
            else
            {
                if(auto size = h->curArena.end - h->curArena.base; size != 0)
                {
                    sysMap(unsafe::Pointer(h->curArena.base), size, & gcController.heapReleased);
                    auto stats = acquire(gocpp::recv(memstats.heapStats));
                    atomic::Xaddint64(& stats->released, int64_t(size));
                    release(gocpp::recv(memstats.heapStats));
                    grow(gocpp::recv(h->pages), h->curArena.base, size);
                    totalGrowth += size;
                }
                h->curArena.base = uintptr_t(av);
                h->curArena.end = uintptr_t(av) + asize;
            }
            nBase = alignUp(h->curArena.base + ask, physPageSize);
        }
        auto v = h->curArena.base;
        h->curArena.base = nBase;
        sysMap(unsafe::Pointer(v), nBase - v, & gcController.heapReleased);
        auto stats = acquire(gocpp::recv(memstats.heapStats));
        atomic::Xaddint64(& stats->released, int64_t(nBase - v));
        release(gocpp::recv(memstats.heapStats));
        grow(gocpp::recv(h->pages), v, nBase - v);
        totalGrowth += nBase - v;
        return {totalGrowth, true};
    }

    void freeSpan(struct mheap* h, struct mspan* s)
    {
        systemstack([=]() mutable -> void
        {
            pageTraceFree(ptr(gocpp::recv(getg()->m->p)), 0, base(gocpp::recv(s)), s->npages);
            lock(& h->lock);
            if(msanenabled)
            {
                auto base = unsafe::Pointer(base(gocpp::recv(s)));
                auto bytes = s->npages << _PageShift;
                msanfree(base, bytes);
            }
            if(asanenabled)
            {
                auto base = unsafe::Pointer(base(gocpp::recv(s)));
                auto bytes = s->npages << _PageShift;
                asanpoison(base, bytes);
            }
            freeSpanLocked(gocpp::recv(h), s, spanAllocHeap);
            unlock(& h->lock);
        });
    }

    void freeManual(struct mheap* h, struct mspan* s, spanAllocType typ)
    {
        pageTraceFree(ptr(gocpp::recv(getg()->m->p)), 0, base(gocpp::recv(s)), s->npages);
        s->needzero = 1;
        lock(& h->lock);
        freeSpanLocked(gocpp::recv(h), s, typ);
        unlock(& h->lock);
    }

    void freeSpanLocked(struct mheap* h, struct mspan* s, spanAllocType typ)
    {
        assertLockHeld(& h->lock);
        //Go switch emulation
        {
            auto condition = get(gocpp::recv(s->state));
            int conditionId = -1;
            if(condition == mSpanManual) { conditionId = 0; }
            else if(condition == mSpanInUse) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(s->allocCount != 0)
                    {
                        go_throw("mheap.freeSpanLocked - invalid stack free");
                    }
                    break;
                case 1:
                    if(s->isUserArenaChunk)
                    {
                        go_throw("mheap.freeSpanLocked - invalid free of user arena chunk");
                    }
                    if(s->allocCount != 0 || s->sweepgen != h->sweepgen)
                    {
                        print("mheap.freeSpanLocked - span ", s, " ptr ", hex(base(gocpp::recv(s))), " allocCount ", s->allocCount, " sweepgen ", s->sweepgen, "/", h->sweepgen, "\n");
                        go_throw("mheap.freeSpanLocked - invalid free");
                    }
                    Add(gocpp::recv(h->pagesInUse), - s->npages);
                    auto [arena, pageIdx, pageMask] = pageIndexOf(base(gocpp::recv(s)));
                    atomic::And8(& arena->pageInUse[pageIdx], ~ pageMask);
                    break;
                default:
                    go_throw("mheap.freeSpanLocked - invalid span state");
                    break;
            }
        }
        auto nbytes = s->npages * pageSize;
        add(gocpp::recv(gcController.heapFree), int64_t(nbytes));
        if(typ == spanAllocHeap)
        {
            add(gocpp::recv(gcController.heapInUse), - int64_t(nbytes));
        }
        auto stats = acquire(gocpp::recv(memstats.heapStats));
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == spanAllocHeap) { conditionId = 0; }
            else if(condition == spanAllocStack) { conditionId = 1; }
            else if(condition == spanAllocPtrScalarBits) { conditionId = 2; }
            else if(condition == spanAllocWorkBuf) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    atomic::Xaddint64(& stats->inHeap, - int64_t(nbytes));
                    break;
                case 1:
                    atomic::Xaddint64(& stats->inStacks, - int64_t(nbytes));
                    break;
                case 2:
                    atomic::Xaddint64(& stats->inPtrScalarBits, - int64_t(nbytes));
                    break;
                case 3:
                    atomic::Xaddint64(& stats->inWorkBufs, - int64_t(nbytes));
                    break;
            }
        }
        release(gocpp::recv(memstats.heapStats));
        free(gocpp::recv(h->pages), base(gocpp::recv(s)), s->npages);
        set(gocpp::recv(s->state), mSpanDead);
        freeMSpanLocked(gocpp::recv(h), s);
    }

    void scavengeAll(struct mheap* h)
    {
        auto gp = getg();
        gp->m->mallocing++;
        auto released = scavenge(gocpp::recv(h->pages), ~ uintptr_t(0), nullptr, true);
        gp->m->mallocing--;
        if(debug.scavtrace > 0)
        {
            printScavTrace(0, released, true);
        }
    }

    void runtime_debug_freeOSMemory()
    {
        GC();
        systemstack([=]() mutable -> void
        {
            scavengeAll(gocpp::recv(mheap_));
        });
    }

    void init(struct mspan* span, uintptr_t base, uintptr_t npages)
    {
        span->next = nullptr;
        span->prev = nullptr;
        span->list = nullptr;
        span->startAddr = base;
        span->npages = npages;
        span->allocCount = 0;
        span->spanclass = 0;
        span->elemsize = 0;
        span->speciallock.key = 0;
        span->specials = nullptr;
        span->needzero = 0;
        span->freeindex = 0;
        span->freeIndexForScan = 0;
        span->allocBits = nullptr;
        span->gcmarkBits = nullptr;
        span->pinnerBits = nullptr;
        set(gocpp::recv(span->state), mSpanDead);
        lockInit(& span->speciallock, lockRankMspanSpecial);
    }

    bool inList(struct mspan* span)
    {
        return span->list != nullptr;
    }

    void init(struct mSpanList* list)
    {
        list->first = nullptr;
        list->last = nullptr;
    }

    void remove(struct mSpanList* list, struct mspan* span)
    {
        if(span->list != list)
        {
            print("runtime: failed mSpanList.remove span.npages=", span->npages, " span=", span, " prev=", span->prev, " span.list=", span->list, " list=", list, "\n");
            go_throw("mSpanList.remove");
        }
        if(list->first == span)
        {
            list->first = span->next;
        }
        else
        {
            span->prev->next = span->next;
        }
        if(list->last == span)
        {
            list->last = span->prev;
        }
        else
        {
            span->next->prev = span->prev;
        }
        span->next = nullptr;
        span->prev = nullptr;
        span->list = nullptr;
    }

    bool isEmpty(struct mSpanList* list)
    {
        return list->first == nullptr;
    }

    void insert(struct mSpanList* list, struct mspan* span)
    {
        if(span->next != nullptr || span->prev != nullptr || span->list != nullptr)
        {
            println("runtime: failed mSpanList.insert", span, span->next, span->prev, span->list);
            go_throw("mSpanList.insert");
        }
        span->next = list->first;
        if(list->first != nullptr)
        {
            list->first->prev = span;
        }
        else
        {
            list->last = span;
        }
        list->first = span;
        span->list = list;
    }

    void insertBack(struct mSpanList* list, struct mspan* span)
    {
        if(span->next != nullptr || span->prev != nullptr || span->list != nullptr)
        {
            println("runtime: failed mSpanList.insertBack", span, span->next, span->prev, span->list);
            go_throw("mSpanList.insertBack");
        }
        span->prev = list->last;
        if(list->last != nullptr)
        {
            list->last->next = span;
        }
        else
        {
            list->first = span;
        }
        list->last = span;
        span->list = list;
    }

    void takeAll(struct mSpanList* list, struct mSpanList* other)
    {
        if(isEmpty(gocpp::recv(other)))
        {
            return;
        }
        for(auto s = other->first; s != nullptr; s = s->next)
        {
            s->list = list;
        }
        if(isEmpty(gocpp::recv(list)))
        {
            *list = *other;
        }
        else
        {
            other->last->next = list->first;
            list->first->prev = other->last;
            list->first = other->first;
        }
        std::tie(other->first, other->last) = std::tuple{nullptr, nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    special::operator T()
    {
        T result;
        result._ = this->_;
        result.next = this->next;
        result.offset = this->offset;
        result.kind = this->kind;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool special::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (next != ref.next) return false;
        if (offset != ref.offset) return false;
        if (kind != ref.kind) return false;
        return true;
    }

    std::ostream& special::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << next;
        os << " " << offset;
        os << " " << kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct special& value)
    {
        return value.PrintTo(os);
    }

    void spanHasSpecials(struct mspan* s)
    {
        auto arenaPage = (base(gocpp::recv(s)) / pageSize) % pagesPerArena;
        auto ai = arenaIndex(base(gocpp::recv(s)));
        auto ha = mheap_.arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
        atomic::Or8(& ha->pageSpecials[arenaPage / 8], uint8_t(1) << (arenaPage % 8));
    }

    void spanHasNoSpecials(struct mspan* s)
    {
        auto arenaPage = (base(gocpp::recv(s)) / pageSize) % pagesPerArena;
        auto ai = arenaIndex(base(gocpp::recv(s)));
        auto ha = mheap_.arenas[l1(gocpp::recv(ai))][l2(gocpp::recv(ai))];
        atomic::And8(& ha->pageSpecials[arenaPage / 8], ~ (uint8_t(1) << (arenaPage % 8)));
    }

    bool addspecial(unsafe::Pointer p, struct special* s)
    {
        auto span = spanOfHeap(uintptr_t(p));
        if(span == nullptr)
        {
            go_throw("addspecial on invalid pointer");
        }
        auto mp = acquirem();
        ensureSwept(gocpp::recv(span));
        auto offset = uintptr_t(p) - base(gocpp::recv(span));
        auto kind = s->kind;
        lock(& span->speciallock);
        auto [iter, exists] = specialFindSplicePoint(gocpp::recv(span), offset, kind);
        if(! exists)
        {
            s->offset = uint16_t(offset);
            s->next = *iter;
            *iter = s;
            spanHasSpecials(span);
        }
        unlock(& span->speciallock);
        releasem(mp);
        return ! exists;
    }

    struct special* removespecial(unsafe::Pointer p, uint8_t kind)
    {
        auto span = spanOfHeap(uintptr_t(p));
        if(span == nullptr)
        {
            go_throw("removespecial on invalid pointer");
        }
        auto mp = acquirem();
        ensureSwept(gocpp::recv(span));
        auto offset = uintptr_t(p) - base(gocpp::recv(span));
        special* result = {};
        lock(& span->speciallock);
        auto [iter, exists] = specialFindSplicePoint(gocpp::recv(span), offset, kind);
        if(exists)
        {
            auto s = *iter;
            *iter = s->next;
            result = s;
        }
        if(span->specials == nullptr)
        {
            spanHasNoSpecials(span);
        }
        unlock(& span->speciallock);
        releasem(mp);
        return result;
    }

    std::tuple<struct special**, bool> specialFindSplicePoint(struct mspan* span, uintptr_t offset, unsigned char kind)
    {
        auto iter = & span->specials;
        auto found = false;
        for(; ; )
        {
            auto s = *iter;
            if(s == nullptr)
            {
                break;
            }
            if(offset == uintptr_t(s->offset) && kind == s->kind)
            {
                found = true;
                break;
            }
            if(offset < uintptr_t(s->offset) || (offset == uintptr_t(s->offset) && kind < s->kind))
            {
                break;
            }
            iter = & s->next;
        }
        return {iter, found};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    specialfinalizer::operator T()
    {
        T result;
        result._ = this->_;
        result.special = this->special;
        result.fn = this->fn;
        result.nret = this->nret;
        result.fint = this->fint;
        result.ot = this->ot;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool specialfinalizer::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (special != ref.special) return false;
        if (fn != ref.fn) return false;
        if (nret != ref.nret) return false;
        if (fint != ref.fint) return false;
        if (ot != ref.ot) return false;
        return true;
    }

    std::ostream& specialfinalizer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << special;
        os << " " << fn;
        os << " " << nret;
        os << " " << fint;
        os << " " << ot;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct specialfinalizer& value)
    {
        return value.PrintTo(os);
    }

    bool addfinalizer(unsafe::Pointer p, struct funcval* f, uintptr_t nret, struct _type* fint, struct ptrtype* ot)
    {
        lock(& mheap_.speciallock);
        auto s = (specialfinalizer*)(alloc(gocpp::recv(mheap_.specialfinalizeralloc)));
        unlock(& mheap_.speciallock);
        s->special.kind = _KindSpecialFinalizer;
        s->fn = f;
        s->nret = nret;
        s->fint = fint;
        s->ot = ot;
        if(addspecial(p, & s->special))
        {
            if(gcphase != _GCoff)
            {
                auto [base, span, gocpp_id_6] = findObject(uintptr_t(p), 0, 0);
                auto mp = acquirem();
                auto gcw = & ptr(gocpp::recv(mp->p))->gcw;
                if(! noscan(gocpp::recv(span->spanclass)))
                {
                    scanobject(base, gcw);
                }
                scanblock(uintptr_t(unsafe::Pointer(& s->fn)), goarch::PtrSize, & oneptrmask[0], gcw, nullptr);
                releasem(mp);
            }
            return true;
        }
        lock(& mheap_.speciallock);
        free(gocpp::recv(mheap_.specialfinalizeralloc), unsafe::Pointer(s));
        unlock(& mheap_.speciallock);
        return false;
    }

    void removefinalizer(unsafe::Pointer p)
    {
        auto s = (specialfinalizer*)(unsafe::Pointer(removespecial(p, _KindSpecialFinalizer)));
        if(s == nullptr)
        {
            return;
        }
        lock(& mheap_.speciallock);
        free(gocpp::recv(mheap_.specialfinalizeralloc), unsafe::Pointer(s));
        unlock(& mheap_.speciallock);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    specialprofile::operator T()
    {
        T result;
        result._ = this->_;
        result.special = this->special;
        result.b = this->b;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool specialprofile::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (special != ref.special) return false;
        if (b != ref.b) return false;
        return true;
    }

    std::ostream& specialprofile::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << special;
        os << " " << b;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct specialprofile& value)
    {
        return value.PrintTo(os);
    }

    void setprofilebucket(unsafe::Pointer p, struct bucket* b)
    {
        lock(& mheap_.speciallock);
        auto s = (specialprofile*)(alloc(gocpp::recv(mheap_.specialprofilealloc)));
        unlock(& mheap_.speciallock);
        s->special.kind = _KindSpecialProfile;
        s->b = b;
        if(! addspecial(p, & s->special))
        {
            go_throw("setprofilebucket: profile already set");
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    specialReachable::operator T()
    {
        T result;
        result.special = this->special;
        result.done = this->done;
        result.reachable = this->reachable;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool specialReachable::operator==(const T& ref) const
    {
        if (special != ref.special) return false;
        if (done != ref.done) return false;
        if (reachable != ref.reachable) return false;
        return true;
    }

    std::ostream& specialReachable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << special;
        os << " " << done;
        os << " " << reachable;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct specialReachable& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    specialPinCounter::operator T()
    {
        T result;
        result.special = this->special;
        result.counter = this->counter;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool specialPinCounter::operator==(const T& ref) const
    {
        if (special != ref.special) return false;
        if (counter != ref.counter) return false;
        return true;
    }

    std::ostream& specialPinCounter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << special;
        os << " " << counter;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct specialPinCounter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    specialsIter::operator T()
    {
        T result;
        result.pprev = this->pprev;
        result.s = this->s;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool specialsIter::operator==(const T& ref) const
    {
        if (pprev != ref.pprev) return false;
        if (s != ref.s) return false;
        return true;
    }

    std::ostream& specialsIter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pprev;
        os << " " << s;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct specialsIter& value)
    {
        return value.PrintTo(os);
    }

    struct specialsIter newSpecialsIter(struct mspan* span)
    {
        return specialsIter {& span->specials, span->specials};
    }

    bool valid(struct specialsIter* i)
    {
        return i->s != nullptr;
    }

    void next(struct specialsIter* i)
    {
        i->pprev = & i->s->next;
        i->s = *i->pprev;
    }

    struct special* unlinkAndNext(struct specialsIter* i)
    {
        auto cur = i->s;
        i->s = cur->next;
        *i->pprev = i->s;
        return cur;
    }

    void freeSpecial(struct special* s, unsafe::Pointer p, uintptr_t size)
    {
        //Go switch emulation
        {
            auto condition = s->kind;
            int conditionId = -1;
            if(condition == _KindSpecialFinalizer) { conditionId = 0; }
            else if(condition == _KindSpecialProfile) { conditionId = 1; }
            else if(condition == _KindSpecialReachable) { conditionId = 2; }
            else if(condition == _KindSpecialPinCounter) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    auto sf = (specialfinalizer*)(unsafe::Pointer(s));
                    queuefinalizer(p, sf->fn, sf->nret, sf->fint, sf->ot);
                    lock(& mheap_.speciallock);
                    free(gocpp::recv(mheap_.specialfinalizeralloc), unsafe::Pointer(sf));
                    unlock(& mheap_.speciallock);
                    break;
                case 1:
                    auto sp = (specialprofile*)(unsafe::Pointer(s));
                    mProf_Free(sp->b, size);
                    lock(& mheap_.speciallock);
                    free(gocpp::recv(mheap_.specialprofilealloc), unsafe::Pointer(sp));
                    unlock(& mheap_.speciallock);
                    break;
                case 2:
                    auto sp = (specialReachable*)(unsafe::Pointer(s));
                    sp->done = true;
                    break;
                case 3:
                    lock(& mheap_.speciallock);
                    free(gocpp::recv(mheap_.specialPinCounterAlloc), unsafe::Pointer(s));
                    unlock(& mheap_.speciallock);
                    break;
                default:
                    go_throw("bad special kind");
                    gocpp::panic("not reached");
                    break;
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gcBits::operator T()
    {
        T result;
        result._ = this->_;
        result.x = this->x;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcBits::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (x != ref.x) return false;
        return true;
    }

    std::ostream& gcBits::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << x;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcBits& value)
    {
        return value.PrintTo(os);
    }

    uint8_t* bytep(struct gcBits* b, uintptr_t n)
    {
        return addb(& b->x, n);
    }

    std::tuple<uint8_t*, uint8_t> bitp(struct gcBits* b, uintptr_t n)
    {
        uint8_t* bytep;
        uint8_t mask;
        return {bytep(gocpp::recv(b), n / 8), 1 << (n % 8)};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gcBitsHeader::operator T()
    {
        T result;
        result.free = this->free;
        result.next = this->next;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcBitsHeader::operator==(const T& ref) const
    {
        if (free != ref.free) return false;
        if (next != ref.next) return false;
        return true;
    }

    std::ostream& gcBitsHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << free;
        os << " " << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcBitsHeader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gcBitsArena::operator T()
    {
        T result;
        result._ = this->_;
        result.free = this->free;
        result.next = this->next;
        result.bits = this->bits;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcBitsArena::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (free != ref.free) return false;
        if (next != ref.next) return false;
        if (bits != ref.bits) return false;
        return true;
    }

    std::ostream& gcBitsArena::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << free;
        os << " " << next;
        os << " " << bits;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcBitsArena& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_7
    {
        mutex lock;
        gcBitsArena* free;
        gcBitsArena* next;
        gcBitsArena* current;
        gcBitsArena* previous;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.lock = this->lock;
            result.free = this->free;
            result.next = this->next;
            result.current = this->current;
            result.previous = this->previous;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (lock != ref.lock) return false;
            if (free != ref.free) return false;
            if (next != ref.next) return false;
            if (current != ref.current) return false;
            if (previous != ref.previous) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << free;
            os << " " << next;
            os << " " << current;
            os << " " << previous;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_7 gcBitsArenas;
    struct gcBits* tryAlloc(struct gcBitsArena* b, uintptr_t bytes)
    {
        if(b == nullptr || atomic::Loaduintptr(& b->free) + bytes > uintptr_t(len(b->bits)))
        {
            return nullptr;
        }
        auto end = atomic::Xadduintptr(& b->free, bytes);
        if(end > uintptr_t(len(b->bits)))
        {
            return nullptr;
        }
        auto start = end - bytes;
        return & b->bits[start];
    }

    struct gcBits* newMarkBits(uintptr_t nelems)
    {
        auto blocksNeeded = (nelems + 63) / 64;
        auto bytesNeeded = blocksNeeded * 8;
        auto head = (gcBitsArena*)(atomic::Loadp(unsafe::Pointer(& gcBitsArenas.next)));
        if(auto p = tryAlloc(gocpp::recv(head), bytesNeeded); p != nullptr)
        {
            return p;
        }
        lock(& gcBitsArenas.lock);
        if(auto p = tryAlloc(gocpp::recv(gcBitsArenas.next), bytesNeeded); p != nullptr)
        {
            unlock(& gcBitsArenas.lock);
            return p;
        }
        auto fresh = newArenaMayUnlock();
        if(auto p = tryAlloc(gocpp::recv(gcBitsArenas.next), bytesNeeded); p != nullptr)
        {
            fresh->next = gcBitsArenas.free;
            gcBitsArenas.free = fresh;
            unlock(& gcBitsArenas.lock);
            return p;
        }
        auto p = tryAlloc(gocpp::recv(fresh), bytesNeeded);
        if(p == nullptr)
        {
            go_throw("markBits overflow");
        }
        fresh->next = gcBitsArenas.next;
        atomic::StorepNoWB(unsafe::Pointer(& gcBitsArenas.next), unsafe::Pointer(fresh));
        unlock(& gcBitsArenas.lock);
        return p;
    }

    struct gcBits* newAllocBits(uintptr_t nelems)
    {
        return newMarkBits(nelems);
    }

    void nextMarkBitArenaEpoch()
    {
        lock(& gcBitsArenas.lock);
        if(gcBitsArenas.previous != nullptr)
        {
            if(gcBitsArenas.free == nullptr)
            {
                gcBitsArenas.free = gcBitsArenas.previous;
            }
            else
            {
                auto last = gcBitsArenas.previous;
                for(last = gcBitsArenas.previous; last->next != nullptr; last = last->next)
                {
                }
                last->next = gcBitsArenas.free;
                gcBitsArenas.free = gcBitsArenas.previous;
            }
        }
        gcBitsArenas.previous = gcBitsArenas.current;
        gcBitsArenas.current = gcBitsArenas.next;
        atomic::StorepNoWB(unsafe::Pointer(& gcBitsArenas.next), nullptr);
        unlock(& gcBitsArenas.lock);
    }

    struct gcBitsArena* newArenaMayUnlock()
    {
        gcBitsArena* result = {};
        if(gcBitsArenas.free == nullptr)
        {
            unlock(& gcBitsArenas.lock);
            result = (gcBitsArena*)(sysAlloc(gcBitsChunkBytes, & memstats.gcMiscSys));
            if(result == nullptr)
            {
                go_throw("runtime: cannot allocate memory");
            }
            lock(& gcBitsArenas.lock);
        }
        else
        {
            result = gcBitsArenas.free;
            gcBitsArenas.free = gcBitsArenas.free->next;
            memclrNoHeapPointers(unsafe::Pointer(result), gcBitsChunkBytes);
        }
        result->next = nullptr;
        if(unsafe::Offsetof(gcBitsArena {}.bits) & 7 == 0)
        {
            result->free = 0;
        }
        else
        {
            result->free = 8 - (uintptr_t(unsafe::Pointer(& result->bits[0])) & 7);
        }
        return result;
    }

}

