// generated by GoCpp from file '$(ImportDir)/os/stat_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/stat_windows.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir_windows.h"
#include "golang/os/error.h"
#include "golang/os/file_windows.h"
#include "golang/os/path_windows.h"
#include "golang/os/types.h"
#include "golang/os/types_windows.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/unsafe/unsafe.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Stat returns the FileInfo structure describing file.
    // If there is an error, it will be of type *PathError.
    std::tuple<os::FileInfo, struct gocpp::error> rec::Stat(struct File* file)
    {
        if(file == nullptr)
        {
            return {nullptr, ErrInvalid};
        }
        return statHandle(file->name, file->pfd.Sysfd);
    }

    // stat implements both Stat and Lstat of a file.
    std::tuple<os::FileInfo, struct gocpp::error> stat(gocpp::string funcname, gocpp::string name, bool followSurrogates)
    {
        gocpp::Defer defer;
        try
        {
            if(len(name) == 0)
            {
                return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                    x.Op = funcname;
                    x.Path = name;
                    x.Err = syscall::Errno(syscall::ERROR_PATH_NOT_FOUND);
                })};
            }
            auto [namep, err] = syscall::UTF16PtrFromString(fixLongPath(name));
            if(err != nullptr)
            {
                return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                    x.Op = funcname;
                    x.Path = name;
                    x.Err = err;
                })};
            }
            // Try GetFileAttributesEx first, because it is faster than CreateFile.
            // See https://golang.org/issues/19922#issuecomment-300031421 for details.
            syscall::Win32FileAttributeData fa = {};
            err = syscall::GetFileAttributesEx(namep, syscall::GetFileExInfoStandard, (unsigned char*)(unsafe::Pointer(& fa)));
            if(err == windows::ERROR_SHARING_VIOLATION)
            {
                syscall::Win32finddata fd = {};
                auto [sh, err] = syscall::FindFirstFile(namep, & fd);
                if(err != nullptr)
                {
                    return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                        x.Op = "FindFirstFile"_s;
                        x.Path = name;
                        x.Err = err;
                    })};
                }
                syscall::FindClose(sh);
                if(fd.FileAttributes & syscall::FILE_ATTRIBUTE_REPARSE_POINT == 0)
                {
                    auto fs = newFileStatFromWin32finddata(& fd);
                    if(auto err = rec::saveInfoFromPath(gocpp::recv(fs), name); err != nullptr)
                    {
                        return {nullptr, err};
                    }
                    return {fs, nullptr};
                }
            }
            if(err == nullptr && fa.FileAttributes & syscall::FILE_ATTRIBUTE_REPARSE_POINT == 0)
            {
                auto fs = gocpp::InitPtr<fileStat>([=](auto& x) {
                    x.FileAttributes = fa.FileAttributes;
                    x.CreationTime = fa.CreationTime;
                    x.LastAccessTime = fa.LastAccessTime;
                    x.LastWriteTime = fa.LastWriteTime;
                    x.FileSizeHigh = fa.FileSizeHigh;
                    x.FileSizeLow = fa.FileSizeLow;
                });
                if(auto err = rec::saveInfoFromPath(gocpp::recv(fs), name); err != nullptr)
                {
                    return {nullptr, err};
                }
                return {fs, nullptr};
            }
            syscall::Handle h;
            std::tie(h, err) = syscall::CreateFile(namep, 0, 0, nullptr, syscall::OPEN_EXISTING, syscall::FILE_FLAG_BACKUP_SEMANTICS | syscall::FILE_FLAG_OPEN_REPARSE_POINT, 0);
            if(err != nullptr)
            {
                return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                    x.Op = "CreateFile"_s;
                    x.Path = name;
                    x.Err = err;
                })};
            }
            fs::FileInfo fi;
            std::tie(fi, err) = statHandle(name, h);
            syscall::CloseHandle(h);
            if(err == nullptr && followSurrogates && rec::isReparseTagNameSurrogate(gocpp::recv(gocpp::getValue<fileStat*>(fi))))
            {
                std::tie(h, err) = syscall::CreateFile(namep, 0, 0, nullptr, syscall::OPEN_EXISTING, syscall::FILE_FLAG_BACKUP_SEMANTICS, 0);
                if(err != nullptr)
                {
                    return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                        x.Op = "CreateFile"_s;
                        x.Path = name;
                        x.Err = err;
                    })};
                }
                defer.push_back([=]{ syscall::CloseHandle(h); });
                return statHandle(name, h);
            }
            return {fi, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    std::tuple<os::FileInfo, struct gocpp::error> statHandle(gocpp::string name, syscall::Handle h)
    {
        auto [ft, err] = syscall::GetFileType(h);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([=](auto& x) {
                x.Op = "GetFileType"_s;
                x.Path = name;
                x.Err = err;
            })};
        }
        //Go switch emulation
        {
            auto condition = ft;
            int conditionId = -1;
            if(condition == syscall::FILE_TYPE_PIPE) { conditionId = 0; }
            else if(condition == syscall::FILE_TYPE_CHAR) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    return {gocpp::InitPtr<fileStat>([=](auto& x) {
                        x.name = basename(name);
                        x.filetype = ft;
                    }), nullptr};
                    break;
            }
        }
        fileStat* fs;
        std::tie(fs, err) = newFileStatFromGetFileInformationByHandle(name, h);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        fs->filetype = ft;
        return {fs, err};
    }

    // statNolog implements Stat for Windows.
    std::tuple<os::FileInfo, struct gocpp::error> statNolog(gocpp::string name)
    {
        return stat("Stat"_s, name, true);
    }

    // lstatNolog implements Lstat for Windows.
    std::tuple<os::FileInfo, struct gocpp::error> lstatNolog(gocpp::string name)
    {
        auto followSurrogates = false;
        if(name != ""_s && IsPathSeparator(name[len(name) - 1]))
        {
            followSurrogates = true;
        }
        return stat("Lstat"_s, name, followSurrogates);
    }

}

