// generated by GoCpp from file '$(ImportDir)/image/image.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/image.fwd.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/image/color/ycbcr.h"
#include "golang/image/geom.h"

namespace golang::image
{
    struct Config
    {
        color::Model ColorModel;
        int Width;
        int Height;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Config& value);
    struct Image : gocpp::Interface
    {
        Image(){}
        Image(Image& i) = default;
        Image(const Image& i) = default;
        Image& operator=(Image& i) = default;
        Image& operator=(const Image& i) = default;

        template<typename T>
        Image(T& ref);

        template<typename T>
        Image(const T& ref);

        template<typename T>
        Image(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IImage
        {
            virtual color::Model vColorModel() = 0;
            virtual Rectangle vBounds() = 0;
            virtual color::Color vAt(int x, int y) = 0;
        };

        template<typename T, typename StoreT>
        struct ImageImpl : IImage
        {
            explicit ImageImpl(T* ptr)
            {
                value.reset(ptr);
            }

            color::Model vColorModel() override;

            Rectangle vBounds() override;

            color::Color vAt(int x, int y) override;

            StoreT value;
        };

        std::shared_ptr<IImage> value;
    };

    color::Model ColorModel(const gocpp::PtrRecv<Image, false>& self);
    color::Model ColorModel(const gocpp::ObjRecv<Image>& self);

    Rectangle Bounds(const gocpp::PtrRecv<Image, false>& self);
    Rectangle Bounds(const gocpp::ObjRecv<Image>& self);

    color::Color At(const gocpp::PtrRecv<Image, false>& self, int x, int y);
    color::Color At(const gocpp::ObjRecv<Image>& self, int x, int y);

    std::ostream& operator<<(std::ostream& os, const struct Image& value);
    struct RGBA64Image : gocpp::Interface
    {
        RGBA64Image(){}
        RGBA64Image(RGBA64Image& i) = default;
        RGBA64Image(const RGBA64Image& i) = default;
        RGBA64Image& operator=(RGBA64Image& i) = default;
        RGBA64Image& operator=(const RGBA64Image& i) = default;

        template<typename T>
        RGBA64Image(T& ref);

        template<typename T>
        RGBA64Image(const T& ref);

        template<typename T>
        RGBA64Image(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IRGBA64Image
        {
            virtual color::RGBA64 vRGBA64At(int x, int y) = 0;
        };

        template<typename T, typename StoreT>
        struct RGBA64ImageImpl : IRGBA64Image
        {
            explicit RGBA64ImageImpl(T* ptr)
            {
                value.reset(ptr);
            }

            color::RGBA64 vRGBA64At(int x, int y) override;

            StoreT value;
        };

        std::shared_ptr<IRGBA64Image> value;
    };

    color::RGBA64 RGBA64At(const gocpp::PtrRecv<RGBA64Image, false>& self, int x, int y);
    color::RGBA64 RGBA64At(const gocpp::ObjRecv<RGBA64Image>& self, int x, int y);

    std::ostream& operator<<(std::ostream& os, const struct RGBA64Image& value);
    struct PalettedImage : gocpp::Interface
    {
        PalettedImage(){}
        PalettedImage(PalettedImage& i) = default;
        PalettedImage(const PalettedImage& i) = default;
        PalettedImage& operator=(PalettedImage& i) = default;
        PalettedImage& operator=(const PalettedImage& i) = default;

        template<typename T>
        PalettedImage(T& ref);

        template<typename T>
        PalettedImage(const T& ref);

        template<typename T>
        PalettedImage(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IPalettedImage
        {
            virtual uint8_t vColorIndexAt(int x, int y) = 0;
        };

        template<typename T, typename StoreT>
        struct PalettedImageImpl : IPalettedImage
        {
            explicit PalettedImageImpl(T* ptr)
            {
                value.reset(ptr);
            }

            uint8_t vColorIndexAt(int x, int y) override;

            StoreT value;
        };

        std::shared_ptr<IPalettedImage> value;
    };

    uint8_t ColorIndexAt(const gocpp::PtrRecv<PalettedImage, false>& self, int x, int y);
    uint8_t ColorIndexAt(const gocpp::ObjRecv<PalettedImage>& self, int x, int y);

    std::ostream& operator<<(std::ostream& os, const struct PalettedImage& value);
    int pixelBufferLength(int bytesPerPixel, Rectangle r, std::string imageTypeName);
    struct RGBA
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value);
    color::Model ColorModel(struct RGBA* p);
    Rectangle Bounds(struct RGBA* p);
    color::Color At(struct RGBA* p, int x, int y);
    color::RGBA64 RGBA64At(struct RGBA* p, int x, int y);
    color::RGBA RGBAAt(struct RGBA* p, int x, int y);
    int PixOffset(struct RGBA* p, int x, int y);
    void Set(struct RGBA* p, int x, int y, color::Color c);
    void SetRGBA64(struct RGBA* p, int x, int y, color::RGBA64 c);
    void SetRGBA(struct RGBA* p, int x, int y, color::RGBA c);
    Image SubImage(struct RGBA* p, Rectangle r);
    bool Opaque(struct RGBA* p);
    RGBA* NewRGBA(Rectangle r);
    struct RGBA64
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value);
    color::Model ColorModel(struct RGBA64* p);
    Rectangle Bounds(struct RGBA64* p);
    color::Color At(struct RGBA64* p, int x, int y);
    color::RGBA64 RGBA64At(struct RGBA64* p, int x, int y);
    int PixOffset(struct RGBA64* p, int x, int y);
    void Set(struct RGBA64* p, int x, int y, color::Color c);
    void SetRGBA64(struct RGBA64* p, int x, int y, color::RGBA64 c);
    Image SubImage(struct RGBA64* p, Rectangle r);
    bool Opaque(struct RGBA64* p);
    RGBA64* NewRGBA64(Rectangle r);
    struct NRGBA
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value);
    color::Model ColorModel(struct NRGBA* p);
    Rectangle Bounds(struct NRGBA* p);
    color::Color At(struct NRGBA* p, int x, int y);
    color::RGBA64 RGBA64At(struct NRGBA* p, int x, int y);
    color::NRGBA NRGBAAt(struct NRGBA* p, int x, int y);
    int PixOffset(struct NRGBA* p, int x, int y);
    void Set(struct NRGBA* p, int x, int y, color::Color c);
    void SetRGBA64(struct NRGBA* p, int x, int y, color::RGBA64 c);
    void SetNRGBA(struct NRGBA* p, int x, int y, color::NRGBA c);
    Image SubImage(struct NRGBA* p, Rectangle r);
    bool Opaque(struct NRGBA* p);
    NRGBA* NewNRGBA(Rectangle r);
    struct NRGBA64
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value);
    color::Model ColorModel(struct NRGBA64* p);
    Rectangle Bounds(struct NRGBA64* p);
    color::Color At(struct NRGBA64* p, int x, int y);
    color::RGBA64 RGBA64At(struct NRGBA64* p, int x, int y);
    color::NRGBA64 NRGBA64At(struct NRGBA64* p, int x, int y);
    int PixOffset(struct NRGBA64* p, int x, int y);
    void Set(struct NRGBA64* p, int x, int y, color::Color c);
    void SetRGBA64(struct NRGBA64* p, int x, int y, color::RGBA64 c);
    void SetNRGBA64(struct NRGBA64* p, int x, int y, color::NRGBA64 c);
    Image SubImage(struct NRGBA64* p, Rectangle r);
    bool Opaque(struct NRGBA64* p);
    NRGBA64* NewNRGBA64(Rectangle r);
    struct Alpha
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value);
    color::Model ColorModel(struct Alpha* p);
    Rectangle Bounds(struct Alpha* p);
    color::Color At(struct Alpha* p, int x, int y);
    color::RGBA64 RGBA64At(struct Alpha* p, int x, int y);
    color::Alpha AlphaAt(struct Alpha* p, int x, int y);
    int PixOffset(struct Alpha* p, int x, int y);
    void Set(struct Alpha* p, int x, int y, color::Color c);
    void SetRGBA64(struct Alpha* p, int x, int y, color::RGBA64 c);
    void SetAlpha(struct Alpha* p, int x, int y, color::Alpha c);
    Image SubImage(struct Alpha* p, Rectangle r);
    bool Opaque(struct Alpha* p);
    Alpha* NewAlpha(Rectangle r);
    struct Alpha16
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value);
    color::Model ColorModel(struct Alpha16* p);
    Rectangle Bounds(struct Alpha16* p);
    color::Color At(struct Alpha16* p, int x, int y);
    color::RGBA64 RGBA64At(struct Alpha16* p, int x, int y);
    color::Alpha16 Alpha16At(struct Alpha16* p, int x, int y);
    int PixOffset(struct Alpha16* p, int x, int y);
    void Set(struct Alpha16* p, int x, int y, color::Color c);
    void SetRGBA64(struct Alpha16* p, int x, int y, color::RGBA64 c);
    void SetAlpha16(struct Alpha16* p, int x, int y, color::Alpha16 c);
    Image SubImage(struct Alpha16* p, Rectangle r);
    bool Opaque(struct Alpha16* p);
    Alpha16* NewAlpha16(Rectangle r);
    struct Gray
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Gray& value);
    color::Model ColorModel(struct Gray* p);
    Rectangle Bounds(struct Gray* p);
    color::Color At(struct Gray* p, int x, int y);
    color::RGBA64 RGBA64At(struct Gray* p, int x, int y);
    color::Gray GrayAt(struct Gray* p, int x, int y);
    int PixOffset(struct Gray* p, int x, int y);
    void Set(struct Gray* p, int x, int y, color::Color c);
    void SetRGBA64(struct Gray* p, int x, int y, color::RGBA64 c);
    void SetGray(struct Gray* p, int x, int y, color::Gray c);
    Image SubImage(struct Gray* p, Rectangle r);
    bool Opaque(struct Gray* p);
    Gray* NewGray(Rectangle r);
    struct Gray16
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value);
    color::Model ColorModel(struct Gray16* p);
    Rectangle Bounds(struct Gray16* p);
    color::Color At(struct Gray16* p, int x, int y);
    color::RGBA64 RGBA64At(struct Gray16* p, int x, int y);
    color::Gray16 Gray16At(struct Gray16* p, int x, int y);
    int PixOffset(struct Gray16* p, int x, int y);
    void Set(struct Gray16* p, int x, int y, color::Color c);
    void SetRGBA64(struct Gray16* p, int x, int y, color::RGBA64 c);
    void SetGray16(struct Gray16* p, int x, int y, color::Gray16 c);
    Image SubImage(struct Gray16* p, Rectangle r);
    bool Opaque(struct Gray16* p);
    Gray16* NewGray16(Rectangle r);
    struct CMYK
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value);
    color::Model ColorModel(struct CMYK* p);
    Rectangle Bounds(struct CMYK* p);
    color::Color At(struct CMYK* p, int x, int y);
    color::RGBA64 RGBA64At(struct CMYK* p, int x, int y);
    color::CMYK CMYKAt(struct CMYK* p, int x, int y);
    int PixOffset(struct CMYK* p, int x, int y);
    void Set(struct CMYK* p, int x, int y, color::Color c);
    void SetRGBA64(struct CMYK* p, int x, int y, color::RGBA64 c);
    void SetCMYK(struct CMYK* p, int x, int y, color::CMYK c);
    Image SubImage(struct CMYK* p, Rectangle r);
    bool Opaque(struct CMYK* p);
    CMYK* NewCMYK(Rectangle r);
    struct Paletted
    {
        gocpp::slice<uint8_t> Pix;
        int Stride;
        Rectangle Rect;
        color::Palette Palette;

        using isGoStruct = void;

        template<typename T>
        operator T();

        template<typename T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Paletted& value);
    color::Model ColorModel(struct Paletted* p);
    Rectangle Bounds(struct Paletted* p);
    color::Color At(struct Paletted* p, int x, int y);
    color::RGBA64 RGBA64At(struct Paletted* p, int x, int y);
    int PixOffset(struct Paletted* p, int x, int y);
    void Set(struct Paletted* p, int x, int y, color::Color c);
    void SetRGBA64(struct Paletted* p, int x, int y, color::RGBA64 c);
    uint8_t ColorIndexAt(struct Paletted* p, int x, int y);
    void SetColorIndex(struct Paletted* p, int x, int y, uint8_t index);
    Image SubImage(struct Paletted* p, Rectangle r);
    bool Opaque(struct Paletted* p);
    Paletted* NewPaletted(Rectangle r, color::Palette p);
}

