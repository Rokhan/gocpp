// generated by GoCpp from file '$(ImportDir)/runtime/mfinal.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mfinal.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/runtime/arena.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/iface.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mgc.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    template<typename T> requires gocpp::GoStruct<T>
    finblock::operator T()
    {
        T result;
        result._ = this->_;
        result.alllink = this->alllink;
        result.next = this->next;
        result.cnt = this->cnt;
        result._ = this->_;
        result.fin = this->fin;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool finblock::operator==(const T& ref) const
    {
        if (_ != ref._) return false;
        if (alllink != ref.alllink) return false;
        if (next != ref.next) return false;
        if (cnt != ref.cnt) return false;
        if (_ != ref._) return false;
        if (fin != ref.fin) return false;
        return true;
    }

    std::ostream& finblock::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << alllink;
        os << " " << next;
        os << " " << cnt;
        os << " " << _;
        os << " " << fin;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct finblock& value)
    {
        return value.PrintTo(os);
    }

    atomic::Uint32 fingStatus;
    mutex finlock;
    g* fing;
    finblock* finq;
    finblock* finc;
    gocpp::array<unsigned char, _FinBlockSize / goarch::PtrSize / 8> finptrmask;
    finblock* allfin;
    
    template<typename T> requires gocpp::GoStruct<T>
    finalizer::operator T()
    {
        T result;
        result.fn = this->fn;
        result.arg = this->arg;
        result.nret = this->nret;
        result.fint = this->fint;
        result.ot = this->ot;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool finalizer::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (arg != ref.arg) return false;
        if (nret != ref.nret) return false;
        if (fint != ref.fint) return false;
        if (ot != ref.ot) return false;
        return true;
    }

    std::ostream& finalizer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << arg;
        os << " " << nret;
        os << " " << fint;
        os << " " << ot;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct finalizer& value)
    {
        return value.PrintTo(os);
    }

    gocpp::array_base<unsigned char> finalizer1 = gocpp::array_base<unsigned char> {(1 << 0) | (1 << 1) | (0 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (0 << 7), (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (0 << 4) | (1 << 5) | (1 << 6) | (1 << 7), (1 << 0) | (0 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (0 << 6) | (1 << 7), (1 << 0) | (1 << 1) | (1 << 2) | (0 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7), (0 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (0 << 5) | (1 << 6) | (1 << 7)};
    void lockRankMayQueueFinalizer()
    {
        lockWithRankMayAcquire(& finlock, getLockRank(& finlock));
    }

    void queuefinalizer(unsafe::Pointer p, struct funcval* fn, uintptr_t nret, struct _type* fint, struct ptrtype* ot)
    {
        if(gcphase != _GCoff)
        {
            go_throw("queuefinalizer during GC");
        }
        lock(& finlock);
        if(finq == nullptr || finq->cnt == uint32_t(len(finq->fin)))
        {
            if(finc == nullptr)
            {
                finc = (finblock*)(persistentalloc(_FinBlockSize, 0, & memstats.gcMiscSys));
                finc->alllink = allfin;
                allfin = finc;
                if(finptrmask[0] == 0)
                {
                    if((gocpp::Sizeof<finalizer>() != 5 * goarch::PtrSize || unsafe::Offsetof(finalizer {}.fn) != 0 || unsafe::Offsetof(finalizer {}.arg) != goarch::PtrSize || unsafe::Offsetof(finalizer {}.nret) != 2 * goarch::PtrSize || unsafe::Offsetof(finalizer {}.fint) != 3 * goarch::PtrSize || unsafe::Offsetof(finalizer {}.ot) != 4 * goarch::PtrSize))
                    {
                        go_throw("finalizer out of sync");
                    }
                    for(auto [i, gocpp_ignored] : finptrmask)
                    {
                        finptrmask[i] = finalizer1[i % len(finalizer1)];
                    }
                }
            }
            auto block = finc;
            finc = block->next;
            block->next = finq;
            finq = block;
        }
        auto f = & finq->fin[finq->cnt];
        atomic::Xadd(& finq->cnt, + 1);
        f->fn = fn;
        f->nret = nret;
        f->fint = fint;
        f->ot = ot;
        f->arg = p;
        unlock(& finlock);
        Or(gocpp::recv(fingStatus), fingWake);
    }

    void iterate_finq(std::function<void (funcval*, unsafe::Pointer, uintptr_t, _type*, ptrtype*)> callback)
    {
        for(auto fb = allfin; fb != nullptr; fb = fb->alllink)
        {
            for(auto i = uint32_t(0); i < fb->cnt; i++)
            {
                auto f = & fb->fin[i];
                callback(f->fn, f->arg, f->nret, f->fint, f->ot);
            }
        }
    }

    struct g* wakefing()
    {
        if(auto ok = CompareAndSwap(gocpp::recv(fingStatus), fingCreated | fingWait | fingWake, fingCreated); ok)
        {
            return fing;
        }
        return nullptr;
    }

    void createfing()
    {
        if(Load(gocpp::recv(fingStatus)) == fingUninitialized && CompareAndSwap(gocpp::recv(fingStatus), fingUninitialized, fingCreated))
        {
            gocpp::go([&]{ runfinq(); });
        }
    }

    bool finalizercommit(struct g* gp, unsafe::Pointer lock)
    {
        unlock((mutex*)(lock));
        Or(gocpp::recv(fingStatus), fingWait);
        return true;
    }

    void runfinq()
    {
        unsafe::Pointer frame = {};
        uintptr_t framecap = {};
        int argRegs = {};
        auto gp = getg();
        lock(& finlock);
        fing = gp;
        unlock(& finlock);
        for(; ; )
        {
            lock(& finlock);
            auto fb = finq;
            finq = nullptr;
            if(fb == nullptr)
            {
                gopark(finalizercommit, unsafe::Pointer(& finlock), waitReasonFinalizerWait, traceBlockSystemGoroutine, 1);
                continue;
            }
            argRegs = intArgRegs;
            unlock(& finlock);
            if(raceenabled)
            {
                racefingo();
            }
            for(; fb != nullptr; )
            {
                for(auto i = fb->cnt; i > 0; i--)
                {
                    auto f = & fb->fin[i - 1];
                    abi::RegArgs regs = {};
                    auto framesz = gocpp::Sizeof<go_any>() + f->nret;
                    if(framecap < framesz)
                    {
                        frame = mallocgc(framesz, nullptr, true);
                        framecap = framesz;
                    }
                    if(f->fint == nullptr)
                    {
                        go_throw("missing type in runfinq");
                    }
                    auto r = frame;
                    if(argRegs > 0)
                    {
                        r = unsafe::Pointer(& regs.Ints);
                    }
                    else
                    {
                        *(gocpp::array<uintptr_t, 2>*)(frame) = gocpp::array<uintptr_t, 2> {};
                    }
                    //Go switch emulation
                    {
                        auto condition = f->fint->Kind_ & kindMask;
                        int conditionId = -1;
                        if(condition == kindPtr) { conditionId = 0; }
                        else if(condition == kindInterface) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                *(unsafe::Pointer*)(r) = f->arg;
                                break;
                            case 1:
                                auto ityp = (interfacetype*)(unsafe::Pointer(f->fint));
                                (eface*)(r)->_type = & f->ot->Type;
                                (eface*)(r)->data = f->arg;
                                if(len(ityp->Methods) != 0)
                                {
                                    (iface*)(r)->tab = assertE2I(ityp, (eface*)(r)->_type);
                                }
                                break;
                            default:
                                go_throw("bad kind in runfinq");
                                break;
                        }
                    }
                    Or(gocpp::recv(fingStatus), fingRunningFinalizer);
                    reflectcall(nullptr, unsafe::Pointer(f->fn), frame, uint32_t(framesz), uint32_t(framesz), uint32_t(framesz), & regs);
                    And(gocpp::recv(fingStatus), ~ fingRunningFinalizer);
                    f->fn = nullptr;
                    f->arg = nullptr;
                    f->ot = nullptr;
                    atomic::Store(& fb->cnt, i - 1);
                }
                auto next = fb->next;
                lock(& finlock);
                fb->next = finc;
                finc = fb;
                unlock(& finlock);
                fb = next;
            }
        }
    }

    bool isGoPointerWithoutSpan(unsafe::Pointer p)
    {
        if(p == unsafe::Pointer(& zerobase))
        {
            return true;
        }
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(datap->noptrdata <= uintptr_t(p) && uintptr_t(p) < datap->enoptrdata || datap->data <= uintptr_t(p) && uintptr_t(p) < datap->edata || datap->bss <= uintptr_t(p) && uintptr_t(p) < datap->ebss || datap->noptrbss <= uintptr_t(p) && uintptr_t(p) < datap->enoptrbss)
            {
                return true;
            }
        }
        return false;
    }

    bool blockUntilEmptyFinalizerQueue(int64_t timeout)
    {
        auto start = nanotime();
        for(; nanotime() - start < timeout; )
        {
            lock(& finlock);
            auto empty = finq == nullptr;
            empty = empty && readgstatus(fing) == _Gwaiting && fing->waitreason == waitReasonFinalizerWait;
            unlock(& finlock);
            if(empty)
            {
                return true;
            }
            Gosched();
        }
        return false;
    }

    void SetFinalizer(go_any obj, go_any finalizer)
    {
        if(debug.sbrk != 0)
        {
            return;
        }
        auto e = efaceOf(& obj);
        auto etyp = e->_type;
        if(etyp == nullptr)
        {
            go_throw("runtime.SetFinalizer: first argument is nil");
        }
        if(etyp->Kind_ & kindMask != kindPtr)
        {
            go_throw("runtime.SetFinalizer: first argument is " + string(gocpp::recv(toRType(etyp))) + ", not pointer");
        }
        auto ot = (ptrtype*)(unsafe::Pointer(etyp));
        if(ot->Elem == nullptr)
        {
            go_throw("nil elem type!");
        }
        if(inUserArenaChunk(uintptr_t(e->data)))
        {
            go_throw("runtime.SetFinalizer: first argument was allocated into an arena");
        }
        auto [base, span, gocpp_id_1] = findObject(uintptr_t(e->data), 0, 0);
        if(base == 0)
        {
            if(isGoPointerWithoutSpan(e->data))
            {
                return;
            }
            go_throw("runtime.SetFinalizer: pointer not in allocated block");
        }
        if(goexperiment::AllocHeaders && ! noscan(gocpp::recv(span->spanclass)) && ! heapBitsInSpan(span->elemsize) && sizeclass(gocpp::recv(span->spanclass)) != 0)
        {
            base += mallocHeaderSize;
        }
        if(uintptr_t(e->data) != base)
        {
            if(ot->Elem == nullptr || ot->Elem->PtrBytes != 0 || ot->Elem->Size_ >= maxTinySize)
            {
                go_throw("runtime.SetFinalizer: pointer not at beginning of allocated block");
            }
        }
        auto f = efaceOf(& finalizer);
        auto ftyp = f->_type;
        if(ftyp == nullptr)
        {
            systemstack([=]() mutable -> void
            {
                removefinalizer(e->data);
            });
            return;
        }
        if(ftyp->Kind_ & kindMask != kindFunc)
        {
            go_throw("runtime.SetFinalizer: second argument is " + string(gocpp::recv(toRType(ftyp))) + ", not a function");
        }
        auto ft = (functype*)(unsafe::Pointer(ftyp));
        if(IsVariadic(gocpp::recv(ft)))
        {
            go_throw("runtime.SetFinalizer: cannot pass " + string(gocpp::recv(toRType(etyp))) + " to finalizer " + string(gocpp::recv(toRType(ftyp))) + " because dotdotdot");
        }
        if(ft->InCount != 1)
        {
            go_throw("runtime.SetFinalizer: cannot pass " + string(gocpp::recv(toRType(etyp))) + " to finalizer " + string(gocpp::recv(toRType(ftyp))));
        }
        auto fint = InSlice(gocpp::recv(ft))[0];
        //Go switch emulation
        {
            int conditionId = -1;
            if(fint == etyp) { conditionId = 0; }
            else if(fint->Kind_ & kindMask == kindPtr) { conditionId = 1; }
            else if(fint->Kind_ & kindMask == kindInterface) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    goto okarg;
                    break;
                case 1:
                    if((Uncommon(gocpp::recv(fint)) == nullptr || Uncommon(gocpp::recv(etyp)) == nullptr) && (ptrtype*)(unsafe::Pointer(fint))->Elem == ot->Elem)
                    {
                        goto okarg;
                    }
                    break;
                case 2:
                    auto ityp = (interfacetype*)(unsafe::Pointer(fint));
                    if(len(ityp->Methods) == 0)
                    {
                        goto okarg;
                    }
                    if(auto itab = assertE2I2(ityp, efaceOf(& obj)->_type); itab != nullptr)
                    {
                        goto okarg;
                    }
                    break;
            }
        }
        go_throw("runtime.SetFinalizer: cannot pass " + string(gocpp::recv(toRType(etyp))) + " to finalizer " + string(gocpp::recv(toRType(ftyp))));
        okarg:
        auto nret = uintptr_t(0);
        for(auto [gocpp_ignored, t] : OutSlice(gocpp::recv(ft)))
        {
            nret = alignUp(nret, uintptr_t(t->Align_)) + t->Size_;
        }
        nret = alignUp(nret, goarch::PtrSize);
        createfing();
        systemstack([=]() mutable -> void
        {
            if(! addfinalizer(e->data, (funcval*)(f->data), nret, fint, ot))
            {
                go_throw("runtime.SetFinalizer: finalizer already set");
            }
        });
    }

    void KeepAlive(go_any x)
    {
        if(cgoAlwaysFalse)
        {
            println(x);
        }
    }

}

