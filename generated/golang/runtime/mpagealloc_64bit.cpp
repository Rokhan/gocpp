// generated by GoCpp from file '$(ImportDir)/runtime/mpagealloc_64bit.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mpagealloc_64bit.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mpagealloc.h"
// #include "golang/runtime/mranges.h"  [Ignored, known errors]
// #include "golang/runtime/mstats.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
// #include "golang/runtime/slice.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    int summaryLevels = 5;
    int pageAlloc32Bit = 0;
    int pageAlloc64Bit = 1;
    int pallocChunksL1Bits = 13;
    gocpp::array<unsigned int, summaryLevels> levelBits = gocpp::array<unsigned int, summaryLevels> {summaryL0Bits, summaryLevelBits, summaryLevelBits, summaryLevelBits, summaryLevelBits};
    gocpp::array<unsigned int, summaryLevels> levelShift = gocpp::array<unsigned int, summaryLevels> {heapAddrBits - summaryL0Bits, heapAddrBits - summaryL0Bits - 1 * summaryLevelBits, heapAddrBits - summaryL0Bits - 2 * summaryLevelBits, heapAddrBits - summaryL0Bits - 3 * summaryLevelBits, heapAddrBits - summaryL0Bits - 4 * summaryLevelBits};
    gocpp::array<unsigned int, summaryLevels> levelLogPages = gocpp::array<unsigned int, summaryLevels> {logPallocChunkPages + 4 * summaryLevelBits, logPallocChunkPages + 3 * summaryLevelBits, logPallocChunkPages + 2 * summaryLevelBits, logPallocChunkPages + 1 * summaryLevelBits, logPallocChunkPages};
    void sysInit(pageAlloc* p, bool test)
    {
        for(auto [l, shift] : levelShift)
        {
            auto entries = 1 << (heapAddrBits - shift);
            auto b = alignUp(uintptr(entries) * pallocSumBytes, physPageSize);
            auto r = sysReserve(nullptr, b);
            if(r == nullptr)
            {
                go_throw("failed to reserve page summary memory");
            }
            auto sl = notInHeapSlice {(*notInHeap)(r), 0, entries};
            p->summary[l] = *(*gocpp::Tag<gocpp::slice<pallocSum>>())(Pointer(gocpp::recv(unsafe), & sl));
        }
    }

    void sysGrow(pageAlloc* p, uintptr_t base, uintptr_t limit)
    {
        if(base % pallocChunkBytes != 0 || limit % pallocChunkBytes != 0)
        {
            print("runtime: base = ", hex(base), ", limit = ", hex(limit), "\n");
            go_throw("sysGrow bounds not aligned to pallocChunkBytes");
        }
        auto addrRangeToSummaryRange = [=](int level, addrRange r) mutable -> std::tuple<int, int>
        {
            auto [sumIdxBase, sumIdxLimit] = addrsToSummaryRange(level, addr(gocpp::recv(r.base)), addr(gocpp::recv(r.limit)));
            return blockAlignSummaryRange(level, sumIdxBase, sumIdxLimit);
        }
;
        auto summaryRangeToSumAddrRange = [=](int level, int sumIdxBase, int sumIdxLimit) mutable -> addrRange
        {
            auto baseOffset = alignDown(uintptr(sumIdxBase) * pallocSumBytes, physPageSize);
            auto limitOffset = alignUp(uintptr(sumIdxLimit) * pallocSumBytes, physPageSize);
            auto base = Pointer(gocpp::recv(unsafe), & p->summary[level][0]);
            return addrRange {offAddr {uintptr(add(base, baseOffset))}, offAddr {uintptr(add(base, limitOffset))}};
        }
;
        auto addrRangeToSumAddrRange = [=](int level, addrRange r) mutable -> addrRange
        {
            auto [sumIdxBase, sumIdxLimit] = addrRangeToSummaryRange(level, r);
            return summaryRangeToSumAddrRange(level, sumIdxBase, sumIdxLimit);
        }
;
        auto inUseIndex = findSucc(gocpp::recv(p->inUse), base);
        for(auto [l, gocpp_ignored] : p->summary)
        {
            auto [needIdxBase, needIdxLimit] = addrRangeToSummaryRange(l, makeAddrRange(base, limit));
            if(needIdxLimit > len(p->summary[l]))
            {
                p->summary[l] = p->summary[l].make_slice(0, needIdxLimit);
            }
            auto need = summaryRangeToSumAddrRange(l, needIdxBase, needIdxLimit);
            if(inUseIndex > 0)
            {
                need = subtract(gocpp::recv(need), addrRangeToSumAddrRange(l, p->inUse.ranges[inUseIndex - 1]));
            }
            if(inUseIndex < len(p->inUse.ranges))
            {
                need = subtract(gocpp::recv(need), addrRangeToSumAddrRange(l, p->inUse.ranges[inUseIndex]));
            }
            if(size(gocpp::recv(need)) == 0)
            {
                continue;
            }
            sysMap(Pointer(gocpp::recv(unsafe), addr(gocpp::recv(need.base))), size(gocpp::recv(need)), p->sysStat);
            sysUsed(Pointer(gocpp::recv(unsafe), addr(gocpp::recv(need.base))), size(gocpp::recv(need)), size(gocpp::recv(need)));
            p->summaryMappedReady += size(gocpp::recv(need));
        }
        p->summaryMappedReady += sysGrow(gocpp::recv(p->scav.index), base, limit, p->sysStat);
    }

    uintptr_t sysGrow(scavengeIndex* s, uintptr_t base, uintptr_t limit, sysMemStat* sysStat)
    {
        if(base % pallocChunkBytes != 0 || limit % pallocChunkBytes != 0)
        {
            print("runtime: base = ", hex(base), ", limit = ", hex(limit), "\n");
            go_throw("sysGrow bounds not aligned to pallocChunkBytes");
        }
        auto scSize = Sizeof(gocpp::recv(unsafe), atomicScavChunkData {});
        auto haveMin = Load(gocpp::recv(s->min));
        auto haveMax = Load(gocpp::recv(s->max));
        auto needMin = alignDown(uintptr(chunkIndex(base)), physPageSize / scSize);
        auto needMax = alignUp(uintptr(chunkIndex(limit)), physPageSize / scSize);
        if(needMax < haveMin)
        {
            needMax = haveMin;
        }
        if(haveMax != 0 && needMin > haveMax)
        {
            needMin = haveMax;
        }
        auto chunksBase = uintptr(Pointer(gocpp::recv(unsafe), & s->chunks[0]));
        auto have = makeAddrRange(chunksBase + haveMin * scSize, chunksBase + haveMax * scSize);
        auto need = makeAddrRange(chunksBase + needMin * scSize, chunksBase + needMax * scSize);
        need = subtract(gocpp::recv(need), have);
        if(size(gocpp::recv(need)) != 0)
        {
            sysMap(Pointer(gocpp::recv(unsafe), addr(gocpp::recv(need.base))), size(gocpp::recv(need)), sysStat);
            sysUsed(Pointer(gocpp::recv(unsafe), addr(gocpp::recv(need.base))), size(gocpp::recv(need)), size(gocpp::recv(need)));
            if(haveMax == 0 || needMin < haveMin)
            {
                Store(gocpp::recv(s->min), needMin);
            }
            if(needMax > haveMax)
            {
                Store(gocpp::recv(s->max), needMax);
            }
        }
        return size(gocpp::recv(need));
    }

    uintptr_t sysInit(scavengeIndex* s, bool test, sysMemStat* sysStat)
    {
        auto n = uintptr(1 << heapAddrBits) / pallocChunkBytes;
        auto nbytes = n * Sizeof(gocpp::recv(unsafe), atomicScavChunkData {});
        auto r = sysReserve(nullptr, nbytes);
        auto sl = notInHeapSlice {(*notInHeap)(r), int(n), int(n)};
        s->chunks = *(*gocpp::Tag<gocpp::slice<atomicScavChunkData>>())(Pointer(gocpp::recv(unsafe), & sl));
        return 0;
    }

}

