// generated by GoCpp from file '$(ImportDir)/runtime/exithook.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/exithook.h"
#include "gocpp/support.h"

#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // addExitHook registers the specified function 'f' to be run at
    // program termination (e.g. when someone invokes os.Exit(), or when
    // main.main returns). Hooks are run in reverse order of registration:
    // first hook added is the last one run.
    //
    // CAREFUL: the expectation is that addExitHook should only be called
    // from a safe context (e.g. not an error/panic path or signal
    // handler, preemption enabled, allocation allowed, write barriers
    // allowed, etc), and that the exit function 'f' will be invoked under
    // similar circumstances. That is the say, we are expecting that 'f'
    // uses normal / high-level Go code as opposed to one of the more
    // restricted dialects used for the trickier parts of the runtime.
    void addExitHook(std::function<void ()> f, bool runOnNonZeroExit)
    {
        exitHooks.hooks = append(exitHooks.hooks, gocpp::Init<exitHook>([=](auto& x) {
            x.f = f;
            x.runOnNonZeroExit = runOnNonZeroExit;
        }));
    }

    // exitHook stores a function to be run on program exit, registered
    // by the utility runtime.addExitHook.
    
    template<typename T> requires gocpp::GoStruct<T>
    exitHook::operator T()
    {
        T result;
        result.f = this->f;
        result.runOnNonZeroExit = this->runOnNonZeroExit;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool exitHook::operator==(const T& ref) const
    {
        if (f != ref.f) return false;
        if (runOnNonZeroExit != ref.runOnNonZeroExit) return false;
        return true;
    }

    std::ostream& exitHook::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << f;
        os << " " << runOnNonZeroExit;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct exitHook& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {
        gocpp::slice<exitHook> hooks;
        bool runningExitHooks;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.hooks = this->hooks;
            result.runningExitHooks = this->runningExitHooks;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (hooks != ref.hooks) return false;
            if (runningExitHooks != ref.runningExitHooks) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << hooks;
            os << " " << runningExitHooks;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // exitHooks stores state related to hook functions registered to
    // run when program execution terminates.
    gocpp_id_0 exitHooks;
    // runExitHooks runs any registered exit hook functions (funcs
    // previously registered using runtime.addExitHook). Here 'exitCode'
    // is the status code being passed to os.Exit, or zero if the program
    // is terminating normally without calling os.Exit.
    void runExitHooks(int exitCode)
    {
        if(exitHooks.runningExitHooks)
        {
            go_throw("internal error: exit hook invoked exit"_s);
        }
        exitHooks.runningExitHooks = true;
        auto runExitHook = [=](std::function<void ()> f) mutable -> bool
        {
            gocpp::Defer defer;
            try
            {
                bool caughtPanic;
                defer.push_back([=]{ [=]() mutable -> void
                {
                    if(auto x = gocpp::recover(); x != nullptr)
                    {
                        caughtPanic = true;
                    }
                }(); });
                f();
                return caughtPanic;
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        };
        finishPageTrace();
        for(auto [i, gocpp_ignored] : exitHooks.hooks)
        {
            auto h = exitHooks.hooks[len(exitHooks.hooks) - i - 1];
            if(exitCode != 0 && ! h.runOnNonZeroExit)
            {
                continue;
            }
            if(auto caughtPanic = runExitHook(h.f); caughtPanic)
            {
                go_throw("internal error: exit hook invoked panic"_s);
            }
        }
        exitHooks.hooks = nullptr;
        exitHooks.runningExitHooks = false;
    }

}

