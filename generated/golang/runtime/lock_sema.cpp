// generated by GoCpp from file '$(ImportDir)/runtime/lock_sema.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/lock_sema.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    bool mutexContended(struct mutex* l)
    {
        return atomic::Loaduintptr(& l->key) > locked;
    }

    void lock(struct mutex* l)
    {
        lockWithRank(l, getLockRank(l));
    }

    void lock2(struct mutex* l)
    {
        auto gp = getg();
        if(gp->m->locks < 0)
        {
            go_throw("runtime·lock: lock count");
        }
        gp->m->locks++;
        if(atomic::Casuintptr(& l->key, 0, locked))
        {
            return;
        }
        semacreate(gp->m);
        auto timer = gocpp::InitPtr<lockTimer>([](lockTimer& x) { x.lock = l; });
        rec::begin(gocpp::recv(timer));
        auto spin = 0;
        if(ncpu > 1)
        {
            spin = active_spin;
        }
        Loop:
        for(auto i = 0; ; i++)
        {
            auto v = atomic::Loaduintptr(& l->key);
            if(v & locked == 0)
            {
                if(atomic::Casuintptr(& l->key, v, v | locked))
                {
                    rec::end(gocpp::recv(timer));
                    return;
                }
                i = 0;
            }
            if(i < spin)
            {
                procyield(active_spin_cnt);
            }
            else
            if(i < spin + passive_spin)
            {
                osyield();
            }
            else
            {
                for(; ; )
                {
                    gp->m->nextwaitm = muintptr(v &^ locked);
                    if(atomic::Casuintptr(& l->key, v, uintptr_t(unsafe::Pointer(gp->m)) | locked))
                    {
                        break;
                    }
                    v = atomic::Loaduintptr(& l->key);
                    if(v & locked == 0)
                    {
                        goto Loop_continue;
                    }
                }
                if(v & locked != 0)
                {
                    semasleep(- 1);
                    i = 0;
                }
            }
            if(false) {
            Loop_continue:
                continue;
            Loop_break:
                break;
            }
        }
    }

    void unlock(struct mutex* l)
    {
        unlockWithRank(l);
    }

    void unlock2(struct mutex* l)
    {
        auto gp = getg();
        m* mp = {};
        for(; ; )
        {
            auto v = atomic::Loaduintptr(& l->key);
            if(v == locked)
            {
                if(atomic::Casuintptr(& l->key, locked, 0))
                {
                    break;
                }
            }
            else
            {
                mp = rec::ptr(gocpp::recv(muintptr(v &^ locked)));
                if(atomic::Casuintptr(& l->key, v, uintptr_t(mp->nextwaitm)))
                {
                    semawakeup(mp);
                    break;
                }
            }
        }
        rec::recordUnlock(gocpp::recv(gp->m->mLockProfile), l);
        gp->m->locks--;
        if(gp->m->locks < 0)
        {
            go_throw("runtime·unlock: lock count");
        }
        if(gp->m->locks == 0 && gp->preempt)
        {
            gp->stackguard0 = stackPreempt;
        }
    }

    void noteclear(struct note* n)
    {
        n->key = 0;
    }

    void notewakeup(struct note* n)
    {
        uintptr_t v = {};
        for(; ; )
        {
            v = atomic::Loaduintptr(& n->key);
            if(atomic::Casuintptr(& n->key, v, locked))
            {
                break;
            }
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(v == 0) { conditionId = 0; }
            else if(v == locked) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    break;
                case 1:
                    go_throw("notewakeup - double wakeup");
                    break;
                default:
                    semawakeup((m*)(unsafe::Pointer(v)));
                    break;
            }
        }
    }

    void notesleep(struct note* n)
    {
        auto gp = getg();
        if(gp != gp->m->g0)
        {
            go_throw("notesleep not on g0");
        }
        semacreate(gp->m);
        if(! atomic::Casuintptr(& n->key, 0, uintptr_t(unsafe::Pointer(gp->m))))
        {
            if(n->key != locked)
            {
                go_throw("notesleep - waitm out of sync");
            }
            return;
        }
        gp->m->blocked = true;
        if(*cgo_yield == nullptr)
        {
            semasleep(- 1);
        }
        else
        {
            auto ns = 10e6;
            for(; atomic::Loaduintptr(& n->key) == 0; )
            {
                semasleep(ns);
                asmcgocall(*cgo_yield, nullptr);
            }
        }
        gp->m->blocked = false;
    }

    bool notetsleep_internal(struct note* n, int64_t ns, struct g* gp, int64_t deadline)
    {
        gp = getg();
        if(! atomic::Casuintptr(& n->key, 0, uintptr_t(unsafe::Pointer(gp->m))))
        {
            if(n->key != locked)
            {
                go_throw("notetsleep - waitm out of sync");
            }
            return true;
        }
        if(ns < 0)
        {
            gp->m->blocked = true;
            if(*cgo_yield == nullptr)
            {
                semasleep(- 1);
            }
            else
            {
                auto ns = 10e6;
                for(; semasleep(ns) < 0; )
                {
                    asmcgocall(*cgo_yield, nullptr);
                }
            }
            gp->m->blocked = false;
            return true;
        }
        deadline = nanotime() + ns;
        for(; ; )
        {
            gp->m->blocked = true;
            if(*cgo_yield != nullptr && ns > 10e6)
            {
                ns = 10e6;
            }
            if(semasleep(ns) >= 0)
            {
                gp->m->blocked = false;
                return true;
            }
            if(*cgo_yield != nullptr)
            {
                asmcgocall(*cgo_yield, nullptr);
            }
            gp->m->blocked = false;
            ns = deadline - nanotime();
            if(ns <= 0)
            {
                break;
            }
        }
        for(; ; )
        {
            auto v = atomic::Loaduintptr(& n->key);
            //Go switch emulation
            {
                auto condition = v;
                int conditionId = -1;
                if(condition == uintptr_t(unsafe::Pointer(gp->m))) { conditionId = 0; }
                else if(condition == locked) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        if(atomic::Casuintptr(& n->key, v, 0))
                        {
                            return false;
                        }
                        break;
                    case 1:
                        gp->m->blocked = true;
                        if(semasleep(- 1) < 0)
                        {
                            go_throw("runtime: unable to acquire - semaphore out of sync");
                        }
                        gp->m->blocked = false;
                        return true;
                        break;
                    default:
                        go_throw("runtime: unexpected waitm - semaphore out of sync");
                        break;
                }
            }
        }
    }

    bool notetsleep(struct note* n, int64_t ns)
    {
        auto gp = getg();
        if(gp != gp->m->g0)
        {
            go_throw("notetsleep not on g0");
        }
        semacreate(gp->m);
        return notetsleep_internal(n, ns, nullptr, 0);
    }

    bool notetsleepg(struct note* n, int64_t ns)
    {
        auto gp = getg();
        if(gp == gp->m->g0)
        {
            go_throw("notetsleepg on g0");
        }
        semacreate(gp->m);
        entersyscallblock();
        auto ok = notetsleep_internal(n, ns, nullptr, 0);
        exitsyscall();
        return ok;
    }

    std::tuple<struct g*, bool> beforeIdle(int64_t, int64_t)
    {
        return {nullptr, false};
    }

    void checkTimeouts()
    {
    }

}

