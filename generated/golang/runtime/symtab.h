// generated by GoCpp from file '$(ImportDir)/runtime/symtab.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/symtab.fwd.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtabinl.h"  [Ignored, known errors]
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    struct Frames
    {
        gocpp::slice<uintptr_t> callers;
        gocpp::slice<Frame> frames;
        gocpp::array<Frame, 2> frameStore;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Frames& value);
    struct Frame
    {
        uintptr_t PC;
        Func* Func;
        std::string Function;
        std::string File;
        int Line;
        int startLine;
        uintptr_t Entry;
        funcInfo funcInfo;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Frame& value);
    Frames* CallersFrames(gocpp::slice<uintptr_t> callers);
    std::tuple<Frame, bool> Next(struct Frames* ci);
    int runtime_FrameStartLine(Frame* f);
    std::string runtime_FrameSymbolName(Frame* f);
    gocpp::slice<uintptr_t> runtime_expandFinalInlineFrame(gocpp::slice<uintptr_t> stk);
    gocpp::slice<Frame> expandCgoFrames(uintptr_t pc);
    struct Func
    {
        gocpp_id_0 opaque;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Func& value);
    _func* raw(struct Func* f);
    funcInfo funcInfo(struct Func* f);
    funcInfo funcInfo(struct _func* f);
    struct pcHeader
    {
        uint32_t magic;
        uint8_t pad1;
        uint8_t pad2;
        uint8_t minLC;
        uint8_t ptrSize;
        int nfunc;
        unsigned int nfiles;
        uintptr_t textStart;
        uintptr_t funcnameOffset;
        uintptr_t cuOffset;
        uintptr_t filetabOffset;
        uintptr_t pctabOffset;
        uintptr_t pclnOffset;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pcHeader& value);
    struct moduledata
    {
        pcHeader* pcHeader;
        gocpp::slice<unsigned char> funcnametab;
        gocpp::slice<uint32_t> cutab;
        gocpp::slice<unsigned char> filetab;
        gocpp::slice<unsigned char> pctab;
        gocpp::slice<unsigned char> pclntable;
        gocpp::slice<functab> ftab;
        uintptr_t findfunctab;
        uintptr_t minpc;
        uintptr_t maxpc;
        uintptr_t text;
        uintptr_t etext;
        uintptr_t noptrdata;
        uintptr_t enoptrdata;
        uintptr_t data;
        uintptr_t edata;
        uintptr_t bss;
        uintptr_t ebss;
        uintptr_t noptrbss;
        uintptr_t enoptrbss;
        uintptr_t covctrs;
        uintptr_t ecovctrs;
        uintptr_t end;
        uintptr_t gcdata;
        uintptr_t gcbss;
        uintptr_t types;
        uintptr_t etypes;
        uintptr_t rodata;
        uintptr_t gofunc;
        gocpp::slice<textsect> textsectmap;
        gocpp::slice<int32_t> typelinks;
        gocpp::slice<itab*> itablinks;
        gocpp::slice<ptabEntry> ptab;
        std::string pluginpath;
        gocpp::slice<modulehash> pkghashes;
        gocpp::slice<initTask*> inittasks;
        std::string modulename;
        gocpp::slice<modulehash> modulehashes;
        uint8_t hasmain;
        bitvector gcdatamask;
        bitvector gcbssmask;
        gocpp::map<typeOff, _type*> typemap;
        bool bad;
        moduledata* next;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct moduledata& value);
    struct modulehash
    {
        std::string modulename;
        std::string linktimehash;
        std::string* runtimehash;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct modulehash& value);
    gocpp::slice<moduledata*> activeModules();
    void modulesinit();
    struct functab
    {
        uint32_t entryoff;
        uint32_t funcoff;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct functab& value);
    struct textsect
    {
        uintptr_t vaddr;
        uintptr_t end;
        uintptr_t baseaddr;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct textsect& value);
    struct findfuncbucket
    {
        uint32_t idx;
        gocpp::array<unsigned char, 16> subbuckets;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct findfuncbucket& value);
    void moduledataverify();
    void moduledataverify1(moduledata* datap);
    uintptr_t textAddr(struct moduledata* md, uint32_t off32);
    std::tuple<uint32_t, bool> textOff(struct moduledata* md, uintptr_t pc);
    std::string funcName(struct moduledata* md, int32_t nameOff);
    Func* FuncForPC(uintptr_t pc);
    std::string Name(struct Func* f);
    uintptr_t Entry(struct Func* f);
    std::tuple<std::string, int> FileLine(struct Func* f, uintptr_t pc);
    int32_t startLine(struct Func* f);
    moduledata* findmoduledatap(uintptr_t pc);
    struct funcInfo
    {
        moduledata* datap;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct funcInfo& value);
    bool valid(struct funcInfo f);
    Func* _Func(struct funcInfo f);
    bool isInlined(struct _func* f);
    uintptr_t entry(struct funcInfo f);
    funcInfo findfunc(uintptr_t pc);
    struct srcFunc
    {
        moduledata* datap;
        int32_t nameOff;
        int32_t startLine;
        abi::FuncID funcID;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct srcFunc& value);
    srcFunc srcFunc(struct funcInfo f);
    std::string name(struct srcFunc s);
    struct pcvalueCache
    {
        gocpp::array<gocpp::array<pcvalueCacheEnt, 8>, 2> entries;
        int inUse;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCache& value);
    struct pcvalueCacheEnt
    {
        uintptr_t targetpc;
        uint32_t off;
        int32_t val;
        uintptr_t valPC;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCacheEnt& value);
    uintptr_t pcvalueCacheKey(uintptr_t targetpc);
    std::tuple<int32_t, uintptr_t> pcvalue(funcInfo f, uint32_t off, uintptr_t targetpc, bool strict);
    std::string funcname(funcInfo f);
    std::string funcpkgpath(funcInfo f);
    std::string funcfile(funcInfo f, int32_t fileno);
    std::tuple<std::string, int32_t> funcline1(funcInfo f, uintptr_t targetpc, bool strict);
    std::tuple<std::string, int32_t> funcline(funcInfo f, uintptr_t targetpc);
    int32_t funcspdelta(funcInfo f, uintptr_t targetpc);
    int32_t funcMaxSPDelta(funcInfo f);
    uint32_t pcdatastart(funcInfo f, uint32_t table);
    int32_t pcdatavalue(funcInfo f, uint32_t table, uintptr_t targetpc);
    int32_t pcdatavalue1(funcInfo f, uint32_t table, uintptr_t targetpc, bool strict);
    std::tuple<int32_t, uintptr_t> pcdatavalue2(funcInfo f, uint32_t table, uintptr_t targetpc);
    unsafe::Pointer funcdata(funcInfo f, uint8_t i);
    std::tuple<gocpp::slice<unsigned char>, bool> step(gocpp::slice<unsigned char> p, uintptr_t* pc, int32_t* val, bool first);
    std::tuple<uint32_t, uint32_t> readvarint(gocpp::slice<unsigned char> p);
    struct stackmap
    {
        int32_t n;
        int32_t nbit;
        gocpp::array<unsigned char, 1> bytedata;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackmap& value);
    bitvector stackmapdata(stackmap* stkmap, int32_t n);
}

