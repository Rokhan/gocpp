// generated by GoCpp from file '$(ImportDir)/time/format.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/format.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/time/format_rfc3339.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    std::string Layout = "01/02 03:04:05PM '06 -0700"s;
    std::string ANSIC = "Mon Jan _2 15:04:05 2006"s;
    std::string UnixDate = "Mon Jan _2 15:04:05 MST 2006"s;
    std::string RubyDate = "Mon Jan 02 15:04:05 -0700 2006"s;
    std::string RFC822 = "02 Jan 06 15:04 MST"s;
    std::string RFC822Z = "02 Jan 06 15:04 -0700"s;
    std::string RFC850 = "Monday, 02-Jan-06 15:04:05 MST"s;
    std::string RFC1123 = "Mon, 02 Jan 2006 15:04:05 MST"s;
    std::string RFC1123Z = "Mon, 02 Jan 2006 15:04:05 -0700"s;
    std::string RFC3339 = "2006-01-02T15:04:05Z07:00"s;
    std::string RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"s;
    std::string Kitchen = "3:04PM"s;
    std::string Stamp = "Jan _2 15:04:05"s;
    std::string StampMilli = "Jan _2 15:04:05.000"s;
    std::string StampMicro = "Jan _2 15:04:05.000000"s;
    std::string StampNano = "Jan _2 15:04:05.000000000"s;
    std::string DateTime = "2006-01-02 15:04:05"s;
    std::string DateOnly = "2006-01-02"s;
    std::string TimeOnly = "15:04:05"s;
    int gocpp_id_0 = 0;
    gocpp::array<int, 6> std0x = gocpp::array<int, 6> {stdZeroMonth, stdZeroDay, stdZeroHour12, stdZeroMinute, stdZeroSecond, stdYear};
    bool startsWithLowerCase(std::string str)
    {
        if(len(str) == 0)
        {
            return false;
        }
        auto c = str[0];
        return 'a' <= c && c <= 'z';
    }

    std::tuple<std::string, int, std::string> nextStdChunk(std::string layout)
    {
        std::string prefix;
        int std;
        std::string suffix;
        for(auto i = 0; i < len(layout); i++)
        {
            //Go switch emulation
            {
                auto c = int(layout[i]);
                auto condition = c;
                int conditionId = -1;
                if(condition == 'J') { conditionId = 0; }
                else if(condition == 'M') { conditionId = 1; }
                else if(condition == '0') { conditionId = 2; }
                else if(condition == '1') { conditionId = 3; }
                else if(condition == '2') { conditionId = 4; }
                else if(condition == '_') { conditionId = 5; }
                else if(condition == '3') { conditionId = 6; }
                else if(condition == '4') { conditionId = 7; }
                else if(condition == '5') { conditionId = 8; }
                else if(condition == 'P') { conditionId = 9; }
                else if(condition == 'p') { conditionId = 10; }
                else if(condition == '-') { conditionId = 11; }
                else if(condition == 'Z') { conditionId = 12; }
                else if(condition == '.') { conditionId = 13; }
                else if(condition == ',') { conditionId = 14; }
                switch(conditionId)
                {
                    case 0:
                        if(len(layout) >= i + 3 && layout.make_slice(i, i + 3) == "Jan"s)
                        {
                            if(len(layout) >= i + 7 && layout.make_slice(i, i + 7) == "January"s)
                            {
                                return {layout.make_slice(0, i), stdLongMonth, layout.make_slice(i + 7)};
                            }
                            if(! startsWithLowerCase(layout.make_slice(i + 3)))
                            {
                                return {layout.make_slice(0, i), stdMonth, layout.make_slice(i + 3)};
                            }
                        }
                        break;
                    case 1:
                        if(len(layout) >= i + 3)
                        {
                            if(layout.make_slice(i, i + 3) == "Mon"s)
                            {
                                if(len(layout) >= i + 6 && layout.make_slice(i, i + 6) == "Monday"s)
                                {
                                    return {layout.make_slice(0, i), stdLongWeekDay, layout.make_slice(i + 6)};
                                }
                                if(! startsWithLowerCase(layout.make_slice(i + 3)))
                                {
                                    return {layout.make_slice(0, i), stdWeekDay, layout.make_slice(i + 3)};
                                }
                            }
                            if(layout.make_slice(i, i + 3) == "MST"s)
                            {
                                return {layout.make_slice(0, i), stdTZ, layout.make_slice(i + 3)};
                            }
                        }
                        break;
                    case 2:
                        if(len(layout) >= i + 2 && '1' <= layout[i + 1] && layout[i + 1] <= '6')
                        {
                            return {layout.make_slice(0, i), std0x[layout[i + 1] - '1'], layout.make_slice(i + 2)};
                        }
                        if(len(layout) >= i + 3 && layout[i + 1] == '0' && layout[i + 2] == '2')
                        {
                            return {layout.make_slice(0, i), stdZeroYearDay, layout.make_slice(i + 3)};
                        }
                        break;
                    case 3:
                        if(len(layout) >= i + 2 && layout[i + 1] == '5')
                        {
                            return {layout.make_slice(0, i), stdHour, layout.make_slice(i + 2)};
                        }
                        return {layout.make_slice(0, i), stdNumMonth, layout.make_slice(i + 1)};
                        break;
                    case 4:
                        if(len(layout) >= i + 4 && layout.make_slice(i, i + 4) == "2006"s)
                        {
                            return {layout.make_slice(0, i), stdLongYear, layout.make_slice(i + 4)};
                        }
                        return {layout.make_slice(0, i), stdDay, layout.make_slice(i + 1)};
                        break;
                    case 5:
                        if(len(layout) >= i + 2 && layout[i + 1] == '2')
                        {
                            if(len(layout) >= i + 5 && layout.make_slice(i + 1, i + 5) == "2006"s)
                            {
                                return {layout.make_slice(0, i + 1), stdLongYear, layout.make_slice(i + 5)};
                            }
                            return {layout.make_slice(0, i), stdUnderDay, layout.make_slice(i + 2)};
                        }
                        if(len(layout) >= i + 3 && layout[i + 1] == '_' && layout[i + 2] == '2')
                        {
                            return {layout.make_slice(0, i), stdUnderYearDay, layout.make_slice(i + 3)};
                        }
                        break;
                    case 6:
                        return {layout.make_slice(0, i), stdHour12, layout.make_slice(i + 1)};
                        break;
                    case 7:
                        return {layout.make_slice(0, i), stdMinute, layout.make_slice(i + 1)};
                        break;
                    case 8:
                        return {layout.make_slice(0, i), stdSecond, layout.make_slice(i + 1)};
                        break;
                    case 9:
                        if(len(layout) >= i + 2 && layout[i + 1] == 'M')
                        {
                            return {layout.make_slice(0, i), stdPM, layout.make_slice(i + 2)};
                        }
                        break;
                    case 10:
                        if(len(layout) >= i + 2 && layout[i + 1] == 'm')
                        {
                            return {layout.make_slice(0, i), stdpm, layout.make_slice(i + 2)};
                        }
                        break;
                    case 11:
                        if(len(layout) >= i + 7 && layout.make_slice(i, i + 7) == "-070000"s)
                        {
                            return {layout.make_slice(0, i), stdNumSecondsTz, layout.make_slice(i + 7)};
                        }
                        if(len(layout) >= i + 9 && layout.make_slice(i, i + 9) == "-07:00:00"s)
                        {
                            return {layout.make_slice(0, i), stdNumColonSecondsTZ, layout.make_slice(i + 9)};
                        }
                        if(len(layout) >= i + 5 && layout.make_slice(i, i + 5) == "-0700"s)
                        {
                            return {layout.make_slice(0, i), stdNumTZ, layout.make_slice(i + 5)};
                        }
                        if(len(layout) >= i + 6 && layout.make_slice(i, i + 6) == "-07:00"s)
                        {
                            return {layout.make_slice(0, i), stdNumColonTZ, layout.make_slice(i + 6)};
                        }
                        if(len(layout) >= i + 3 && layout.make_slice(i, i + 3) == "-07"s)
                        {
                            return {layout.make_slice(0, i), stdNumShortTZ, layout.make_slice(i + 3)};
                        }
                        break;
                    case 12:
                        if(len(layout) >= i + 7 && layout.make_slice(i, i + 7) == "Z070000"s)
                        {
                            return {layout.make_slice(0, i), stdISO8601SecondsTZ, layout.make_slice(i + 7)};
                        }
                        if(len(layout) >= i + 9 && layout.make_slice(i, i + 9) == "Z07:00:00"s)
                        {
                            return {layout.make_slice(0, i), stdISO8601ColonSecondsTZ, layout.make_slice(i + 9)};
                        }
                        if(len(layout) >= i + 5 && layout.make_slice(i, i + 5) == "Z0700"s)
                        {
                            return {layout.make_slice(0, i), stdISO8601TZ, layout.make_slice(i + 5)};
                        }
                        if(len(layout) >= i + 6 && layout.make_slice(i, i + 6) == "Z07:00"s)
                        {
                            return {layout.make_slice(0, i), stdISO8601ColonTZ, layout.make_slice(i + 6)};
                        }
                        if(len(layout) >= i + 3 && layout.make_slice(i, i + 3) == "Z07"s)
                        {
                            return {layout.make_slice(0, i), stdISO8601ShortTZ, layout.make_slice(i + 3)};
                        }
                        break;
                    case 13:
                    case 14:
                        if(i + 1 < len(layout) && (layout[i + 1] == '0' || layout[i + 1] == '9'))
                        {
                            auto ch = layout[i + 1];
                            auto j = i + 1;
                            for(; j < len(layout) && layout[j] == ch; )
                            {
                                j++;
                            }
                            if(! isDigit(layout, j))
                            {
                                auto code = stdFracSecond0;
                                if(layout[i + 1] == '9')
                                {
                                    code = stdFracSecond9;
                                }
                                auto std = stdFracSecond(code, j - (i + 1), c);
                                return {layout.make_slice(0, i), std, layout.make_slice(j)};
                            }
                        }
                        break;
                }
            }
        }
        return {layout, 0, ""s};
    }

    gocpp::slice<std::string> longDayNames = gocpp::slice<std::string> {"Sunday"s, "Monday"s, "Tuesday"s, "Wednesday"s, "Thursday"s, "Friday"s, "Saturday"s};
    gocpp::slice<std::string> shortDayNames = gocpp::slice<std::string> {"Sun"s, "Mon"s, "Tue"s, "Wed"s, "Thu"s, "Fri"s, "Sat"s};
    gocpp::slice<std::string> shortMonthNames = gocpp::slice<std::string> {"Jan"s, "Feb"s, "Mar"s, "Apr"s, "May"s, "Jun"s, "Jul"s, "Aug"s, "Sep"s, "Oct"s, "Nov"s, "Dec"s};
    gocpp::slice<std::string> longMonthNames = gocpp::slice<std::string> {"January"s, "February"s, "March"s, "April"s, "May"s, "June"s, "July"s, "August"s, "September"s, "October"s, "November"s, "December"s};
    bool match(std::string s1, std::string s2)
    {
        for(auto i = 0; i < len(s1); i++)
        {
            auto c1 = s1[i];
            auto c2 = s2[i];
            if(c1 != c2)
            {
                c1 |= 'a' - 'A';
                c2 |= 'a' - 'A';
                if(c1 != c2 || c1 < 'a' || c1 > 'z')
                {
                    return false;
                }
            }
        }
        return true;
    }

    std::tuple<int, std::string, struct gocpp::error> lookup(gocpp::slice<std::string> tab, std::string val)
    {
        for(auto [i, v] : tab)
        {
            if(len(val) >= len(v) && match(val.make_slice(0, len(v)), v))
            {
                return {i, val.make_slice(len(v)), nullptr};
            }
        }
        return {- 1, val, errBad};
    }

    gocpp::slice<unsigned char> appendInt(gocpp::slice<unsigned char> b, int x, int width)
    {
        auto u = (unsigned int)(x);
        if(x < 0)
        {
            b = append(b, '-');
            u = (unsigned int)(- x);
        }
        auto utod = [=](unsigned int u) mutable -> unsigned char
        {
            return '0' + (unsigned char)(u);
        };
        //Go switch emulation
        {
            int conditionId = -1;
            if(width == 2 && u < 1e2) { conditionId = 0; }
            else if(width == 4 && u < 1e4) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return append(b, utod(u / 1e1), utod(u % 1e1));
                    break;
                case 1:
                    return append(b, utod(u / 1e3), utod(u / 1e2 % 1e1), utod(u / 1e1 % 1e1), utod(u % 1e1));
                    break;
            }
        }
        int n = {};
        if(u == 0)
        {
            n = 1;
        }
        for(auto u2 = u; u2 > 0; u2 /= 10)
        {
            n++;
        }
        for(auto pad = width - n; pad > 0; pad--)
        {
            b = append(b, '0');
        }
        if(len(b) + n <= cap(b))
        {
            b = b.make_slice(0, len(b) + n);
        }
        else
        {
            b = append(b, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n));
        }
        auto i = len(b) - 1;
        for(; u >= 10 && i > 0; )
        {
            auto q = u / 10;
            b[i] = utod(u - q * 10);
            u = q;
            i--;
        }
        b[i] = utod(u);
        return b;
    }

    gocpp::error errAtoi = errors::New("time: invalid number"s);

    template<typename bytes>
    std::tuple<int, struct gocpp::error> atoi(bytes s)
    {
        int x;
        struct gocpp::error err;
        auto neg = false;
        if(len(s) > 0 && (s[0] == '-' || s[0] == '+'))
        {
            neg = s[0] == '-';
            s = s.make_slice(1);
        }
        auto [q, rem, err] = leadingInt(s);
        x = int(q);
        if(err != nullptr || len(rem) > 0)
        {
            return {0, errAtoi};
        }
        if(neg)
        {
            x = - x;
        }
        return {x, nullptr};
    }

    int stdFracSecond(int code, int n, int c)
    {
        if(c == '.')
        {
            return code | ((n & 0xfff) << stdArgShift);
        }
        return code | ((n & 0xfff) << stdArgShift) | (1 << stdSeparatorShift);
    }

    int digitsLen(int std)
    {
        return (std >> stdArgShift) & 0xfff;
    }

    unsigned char separator(int std)
    {
        if((std >> stdSeparatorShift) == 0)
        {
            return '.';
        }
        return ',';
    }

    gocpp::slice<unsigned char> appendNano(gocpp::slice<unsigned char> b, int nanosec, int std)
    {
        auto trim = std & stdMask == stdFracSecond9;
        auto n = digitsLen(std);
        if(trim && (n == 0 || nanosec == 0))
        {
            return b;
        }
        auto dot = separator(std);
        b = append(b, dot);
        b = appendInt(b, nanosec, 9);
        if(n < 9)
        {
            b = b.make_slice(0, len(b) - 9 + n);
        }
        if(trim)
        {
            for(; len(b) > 0 && b[len(b) - 1] == '0'; )
            {
                b = b.make_slice(0, len(b) - 1);
            }
            if(len(b) > 0 && b[len(b) - 1] == dot)
            {
                b = b.make_slice(0, len(b) - 1);
            }
        }
        return b;
    }

    std::string rec::String(struct Time t)
    {
        auto s = rec::Format(gocpp::recv(t), "2006-01-02 15:04:05.999999999 -0700 MST"s);
        if(t.wall & hasMonotonic != 0)
        {
            auto m2 = uint64_t(t.ext);
            auto sign = (unsigned char)('+');
            if(t.ext < 0)
            {
                sign = '-';
                m2 = - m2;
            }
            uint64_t m1;
            std::tie(m1, m2) = std::tuple{m2 / 1e9, m2 % 1e9};
            uint64_t m0;
            std::tie(m0, m1) = std::tuple{m1 / 1e9, m1 % 1e9};
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 24);
            buf = append(buf, " m="s);
            buf = append(buf, sign);
            auto wid = 0;
            if(m0 != 0)
            {
                buf = appendInt(buf, int(m0), 0);
                wid = 9;
            }
            buf = appendInt(buf, int(m1), wid);
            buf = append(buf, '.');
            buf = appendInt(buf, int(m2), 9);
            s += std::string(buf);
        }
        return s;
    }

    std::string rec::GoString(struct Time t)
    {
        auto abs = rec::abs(gocpp::recv(t));
        auto [year, month, day, gocpp_id_2] = absDate(abs, true);
        auto [hour, minute, second] = absClock(abs);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len("time.Date(9999, time.September, 31, 23, 59, 59, 999999999, time.Local)"s));
        buf = append(buf, "time.Date("s);
        buf = appendInt(buf, year, 0);
        if(January <= month && month <= December)
        {
            buf = append(buf, ", time."s);
            buf = append(buf, longMonthNames[month - 1]);
        }
        else
        {
            buf = appendInt(buf, int(month), 0);
        }
        buf = append(buf, ", "s);
        buf = appendInt(buf, day, 0);
        buf = append(buf, ", "s);
        buf = appendInt(buf, hour, 0);
        buf = append(buf, ", "s);
        buf = appendInt(buf, minute, 0);
        buf = append(buf, ", "s);
        buf = appendInt(buf, second, 0);
        buf = append(buf, ", "s);
        buf = appendInt(buf, rec::Nanosecond(gocpp::recv(t)), 0);
        buf = append(buf, ", "s);
        //Go switch emulation
        {
            auto loc = rec::Location(gocpp::recv(t));
            auto condition = loc;
            int conditionId = -1;
            if(condition == UTC) { conditionId = 0; }
            else if(condition == nullptr) { conditionId = 1; }
            else if(condition == Local) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    buf = append(buf, "time.UTC"s);
                    break;
                case 2:
                    buf = append(buf, "time.Local"s);
                    break;
                default:
                    buf = append(buf, "time.Location("s);
                    buf = append(buf, quote(loc->name));
                    buf = append(buf, ')');
                    break;
            }
        }
        buf = append(buf, ')');
        return std::string(buf);
    }

    std::string rec::Format(struct Time t, std::string layout)
    {
        auto bufSize = 64;
        gocpp::slice<unsigned char> b = {};
        auto max = len(layout) + 10;
        if(max < bufSize)
        {
            gocpp::array<unsigned char, bufSize> buf = {};
            b = buf.make_slice(0, 0);
        }
        else
        {
            b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, max);
        }
        b = rec::AppendFormat(gocpp::recv(t), b, layout);
        return std::string(b);
    }

    gocpp::slice<unsigned char> rec::AppendFormat(struct Time t, gocpp::slice<unsigned char> b, std::string layout)
    {
        //Go switch emulation
        {
            auto condition = layout;
            int conditionId = -1;
            if(condition == RFC3339) { conditionId = 0; }
            else if(condition == RFC3339Nano) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return rec::appendFormatRFC3339(gocpp::recv(t), b, false);
                    break;
                case 1:
                    return rec::appendFormatRFC3339(gocpp::recv(t), b, true);
                    break;
                default:
                    return rec::appendFormat(gocpp::recv(t), b, layout);
                    break;
            }
        }
    }

    gocpp::slice<unsigned char> rec::appendFormat(struct Time t, gocpp::slice<unsigned char> b, std::string layout)
    {
        auto [name, offset, abs] = rec::locabs(gocpp::recv(t));
        int year = - 1;
        time::Month month = - 1;
        int day = - 1;
        int yday = - 1;
        int hour = - 1;
        int min = - 1;
        int sec = - 1;
        for(; layout != ""s; )
        {
            auto [prefix, std, suffix] = nextStdChunk(layout);
            if(prefix != ""s)
            {
                b = append(b, prefix);
            }
            if(std == 0)
            {
                break;
            }
            layout = suffix;
            if(year < 0 && std & stdNeedDate != 0)
            {
                std::tie(year, month, day, yday) = absDate(abs, true);
                yday++;
            }
            if(hour < 0 && std & stdNeedClock != 0)
            {
                std::tie(hour, min, sec) = absClock(abs);
            }
            //Go switch emulation
            {
                auto condition = std & stdMask;
                int conditionId = -1;
                if(condition == stdYear) { conditionId = 0; }
                else if(condition == stdLongYear) { conditionId = 1; }
                else if(condition == stdMonth) { conditionId = 2; }
                else if(condition == stdLongMonth) { conditionId = 3; }
                else if(condition == stdNumMonth) { conditionId = 4; }
                else if(condition == stdZeroMonth) { conditionId = 5; }
                else if(condition == stdWeekDay) { conditionId = 6; }
                else if(condition == stdLongWeekDay) { conditionId = 7; }
                else if(condition == stdDay) { conditionId = 8; }
                else if(condition == stdUnderDay) { conditionId = 9; }
                else if(condition == stdZeroDay) { conditionId = 10; }
                else if(condition == stdUnderYearDay) { conditionId = 11; }
                else if(condition == stdZeroYearDay) { conditionId = 12; }
                else if(condition == stdHour) { conditionId = 13; }
                else if(condition == stdHour12) { conditionId = 14; }
                else if(condition == stdZeroHour12) { conditionId = 15; }
                else if(condition == stdMinute) { conditionId = 16; }
                else if(condition == stdZeroMinute) { conditionId = 17; }
                else if(condition == stdSecond) { conditionId = 18; }
                else if(condition == stdZeroSecond) { conditionId = 19; }
                else if(condition == stdPM) { conditionId = 20; }
                else if(condition == stdpm) { conditionId = 21; }
                else if(condition == stdISO8601TZ) { conditionId = 22; }
                else if(condition == stdISO8601ColonTZ) { conditionId = 23; }
                else if(condition == stdISO8601SecondsTZ) { conditionId = 24; }
                else if(condition == stdISO8601ShortTZ) { conditionId = 25; }
                else if(condition == stdISO8601ColonSecondsTZ) { conditionId = 26; }
                else if(condition == stdNumTZ) { conditionId = 27; }
                else if(condition == stdNumColonTZ) { conditionId = 28; }
                else if(condition == stdNumSecondsTz) { conditionId = 29; }
                else if(condition == stdNumShortTZ) { conditionId = 30; }
                else if(condition == stdNumColonSecondsTZ) { conditionId = 31; }
                else if(condition == stdTZ) { conditionId = 32; }
                else if(condition == stdFracSecond0) { conditionId = 33; }
                else if(condition == stdFracSecond9) { conditionId = 34; }
                switch(conditionId)
                {
                    case 0:
                        auto y = year;
                        if(y < 0)
                        {
                            y = - y;
                        }
                        b = appendInt(b, y % 100, 2);
                        break;
                    case 1:
                        b = appendInt(b, year, 4);
                        break;
                    case 2:
                        b = append(b, rec::String(gocpp::recv(month)).make_slice(0, 3));
                        break;
                    case 3:
                        auto m = rec::String(gocpp::recv(month));
                        b = append(b, m);
                        break;
                    case 4:
                        b = appendInt(b, int(month), 0);
                        break;
                    case 5:
                        b = appendInt(b, int(month), 2);
                        break;
                    case 6:
                        b = append(b, rec::String(gocpp::recv(absWeekday(abs))).make_slice(0, 3));
                        break;
                    case 7:
                        auto s = rec::String(gocpp::recv(absWeekday(abs)));
                        b = append(b, s);
                        break;
                    case 8:
                        b = appendInt(b, day, 0);
                        break;
                    case 9:
                        if(day < 10)
                        {
                            b = append(b, ' ');
                        }
                        b = appendInt(b, day, 0);
                        break;
                    case 10:
                        b = appendInt(b, day, 2);
                        break;
                    case 11:
                        if(yday < 100)
                        {
                            b = append(b, ' ');
                            if(yday < 10)
                            {
                                b = append(b, ' ');
                            }
                        }
                        b = appendInt(b, yday, 0);
                        break;
                    case 12:
                        b = appendInt(b, yday, 3);
                        break;
                    case 13:
                        b = appendInt(b, hour, 2);
                        break;
                    case 14:
                        auto hr = hour % 12;
                        if(hr == 0)
                        {
                            hr = 12;
                        }
                        b = appendInt(b, hr, 0);
                        break;
                    case 15:
                        auto hr = hour % 12;
                        if(hr == 0)
                        {
                            hr = 12;
                        }
                        b = appendInt(b, hr, 2);
                        break;
                    case 16:
                        b = appendInt(b, min, 0);
                        break;
                    case 17:
                        b = appendInt(b, min, 2);
                        break;
                    case 18:
                        b = appendInt(b, sec, 0);
                        break;
                    case 19:
                        b = appendInt(b, sec, 2);
                        break;
                    case 20:
                        if(hour >= 12)
                        {
                            b = append(b, "PM"s);
                        }
                        else
                        {
                            b = append(b, "AM"s);
                        }
                        break;
                    case 21:
                        if(hour >= 12)
                        {
                            b = append(b, "pm"s);
                        }
                        else
                        {
                            b = append(b, "am"s);
                        }
                        break;
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        if(offset == 0 && (std == stdISO8601TZ || std == stdISO8601ColonTZ || std == stdISO8601SecondsTZ || std == stdISO8601ShortTZ || std == stdISO8601ColonSecondsTZ))
                        {
                            b = append(b, 'Z');
                            break;
                        }
                        auto zone = offset / 60;
                        auto absoffset = offset;
                        if(zone < 0)
                        {
                            b = append(b, '-');
                            zone = - zone;
                            absoffset = - absoffset;
                        }
                        else
                        {
                            b = append(b, '+');
                        }
                        b = appendInt(b, zone / 60, 2);
                        if(std == stdISO8601ColonTZ || std == stdNumColonTZ || std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ)
                        {
                            b = append(b, ':');
                        }
                        if(std != stdNumShortTZ && std != stdISO8601ShortTZ)
                        {
                            b = appendInt(b, zone % 60, 2);
                        }
                        if(std == stdISO8601SecondsTZ || std == stdNumSecondsTz || std == stdNumColonSecondsTZ || std == stdISO8601ColonSecondsTZ)
                        {
                            if(std == stdNumColonSecondsTZ || std == stdISO8601ColonSecondsTZ)
                            {
                                b = append(b, ':');
                            }
                            b = appendInt(b, absoffset % 60, 2);
                        }
                        break;
                    case 32:
                        if(name != ""s)
                        {
                            b = append(b, name);
                            break;
                        }
                        auto zone = offset / 60;
                        if(zone < 0)
                        {
                            b = append(b, '-');
                            zone = - zone;
                        }
                        else
                        {
                            b = append(b, '+');
                        }
                        b = appendInt(b, zone / 60, 2);
                        b = appendInt(b, zone % 60, 2);
                        break;
                    case 33:
                    case 34:
                        b = appendNano(b, rec::Nanosecond(gocpp::recv(t)), std);
                        break;
                }
            }
        }
        return b;
    }

    gocpp::error errBad = errors::New("bad value for field"s);
    
    template<typename T> requires gocpp::GoStruct<T>
    ParseError::operator T()
    {
        T result;
        result.Layout = this->Layout;
        result.Value = this->Value;
        result.LayoutElem = this->LayoutElem;
        result.ValueElem = this->ValueElem;
        result.Message = this->Message;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ParseError::operator==(const T& ref) const
    {
        if (Layout != ref.Layout) return false;
        if (Value != ref.Value) return false;
        if (LayoutElem != ref.LayoutElem) return false;
        if (ValueElem != ref.ValueElem) return false;
        if (Message != ref.Message) return false;
        return true;
    }

    std::ostream& ParseError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Layout;
        os << " " << Value;
        os << " " << LayoutElem;
        os << " " << ValueElem;
        os << " " << Message;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ParseError& value)
    {
        return value.PrintTo(os);
    }

    struct ParseError* newParseError(std::string layout, std::string value, std::string layoutElem, std::string valueElem, std::string message)
    {
        auto valueCopy = cloneString(value);
        auto valueElemCopy = cloneString(valueElem);
        return new ParseError {layout, valueCopy, layoutElem, valueElemCopy, message};
    }

    std::string cloneString(std::string s)
    {
        return std::string(gocpp::slice<unsigned char>(s));
    }

    std::string lowerhex = "0123456789abcdef"s;
    std::string quote(std::string s)
    {
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 1, len(s) + 2);
        buf[0] = '"';
        for(auto [i, c] : s)
        {
            if(c >= runeSelf || c < ' ')
            {
                int width = {};
                if(c == runeError)
                {
                    width = 1;
                    if(i + 2 < len(s) && s.make_slice(i, i + 3) == std::string(runeError))
                    {
                        width = 3;
                    }
                }
                else
                {
                    width = len(std::string(c));
                }
                for(auto j = 0; j < width; j++)
                {
                    buf = append(buf, "\\x"s);
                    buf = append(buf, lowerhex[s[i + j] >> 4]);
                    buf = append(buf, lowerhex[s[i + j] & 0xF]);
                }
            }
            else
            {
                if(c == '"' || c == '\\')
                {
                    buf = append(buf, '\\');
                }
                buf = append(buf, std::string(c));
            }
        }
        buf = append(buf, '"');
        return std::string(buf);
    }

    std::string rec::Error(struct ParseError* e)
    {
        if(e->Message == ""s)
        {
            return "parsing time "s + quote(e->Value) + " as "s + quote(e->Layout) + ": cannot parse "s + quote(e->ValueElem) + " as "s + quote(e->LayoutElem);
        }
        return "parsing time "s + quote(e->Value) + e->Message;
    }


    template<typename bytes>
    bool isDigit(bytes s, int i)
    {
        if(len(s) <= i)
        {
            return false;
        }
        auto c = s[i];
        return '0' <= c && c <= '9';
    }

    std::tuple<int, std::string, struct gocpp::error> getnum(std::string s, bool fixed)
    {
        if(! isDigit(s, 0))
        {
            return {0, s, errBad};
        }
        if(! isDigit(s, 1))
        {
            if(fixed)
            {
                return {0, s, errBad};
            }
            return {int(s[0] - '0'), s.make_slice(1), nullptr};
        }
        return {int(s[0] - '0') * 10 + int(s[1] - '0'), s.make_slice(2), nullptr};
    }

    std::tuple<int, std::string, struct gocpp::error> getnum3(std::string s, bool fixed)
    {
        int n = {};
        int i = {};
        for(i = 0; i < 3 && isDigit(s, i); i++)
        {
            n = n * 10 + int(s[i] - '0');
        }
        if(i == 0 || fixed && i != 3)
        {
            return {0, s, errBad};
        }
        return {n, s.make_slice(i), nullptr};
    }

    std::string cutspace(std::string s)
    {
        for(; len(s) > 0 && s[0] == ' '; )
        {
            s = s.make_slice(1);
        }
        return s;
    }

    std::tuple<std::string, struct gocpp::error> skip(std::string value, std::string prefix)
    {
        for(; len(prefix) > 0; )
        {
            if(prefix[0] == ' ')
            {
                if(len(value) > 0 && value[0] != ' ')
                {
                    return {value, errBad};
                }
                prefix = cutspace(prefix);
                value = cutspace(value);
                continue;
            }
            if(len(value) == 0 || value[0] != prefix[0])
            {
                return {value, errBad};
            }
            prefix = prefix.make_slice(1);
            value = value.make_slice(1);
        }
        return {value, nullptr};
    }

    std::tuple<struct Time, struct gocpp::error> Parse(std::string layout, std::string value)
    {
        if(layout == RFC3339 || layout == RFC3339Nano)
        {
            if(auto [t, ok] = parseRFC3339(value, Local); ok)
            {
                return {t, nullptr};
            }
        }
        return parse(layout, value, UTC, Local);
    }

    std::tuple<struct Time, struct gocpp::error> ParseInLocation(std::string layout, std::string value, struct Location* loc)
    {
        if(layout == RFC3339 || layout == RFC3339Nano)
        {
            if(auto [t, ok] = parseRFC3339(value, loc); ok)
            {
                return {t, nullptr};
            }
        }
        return parse(layout, value, loc, loc);
    }

    std::tuple<struct Time, struct gocpp::error> parse(std::string layout, std::string value, struct Location* defaultLocation, struct Location* local)
    {
        auto [alayout, avalue] = std::tuple{layout, value};
        auto rangeErrString = ""s;
        auto amSet = false;
        auto pmSet = false;
        int year = {};
        int month = - 1;
        int day = - 1;
        int yday = - 1;
        int hour = - 1;
        int min = - 1;
        int sec = - 1;
        int nsec = - 1;
        Location* z = - 1;
        int zoneOffset = - 1;
        std::string zoneName = - 1;
        for(; ; )
        {
            gocpp::error err = {};
            auto [prefix, std, suffix] = nextStdChunk(layout);
            auto stdstr = layout.make_slice(len(prefix), len(layout) - len(suffix));
            std::tie(value, err) = skip(value, prefix);
            if(err != nullptr)
            {
                return {Time {}, newParseError(alayout, avalue, prefix, value, ""s)};
            }
            if(std == 0)
            {
                if(len(value) != 0)
                {
                    return {Time {}, newParseError(alayout, avalue, ""s, value, ": extra text: "s + quote(value))};
                }
                break;
            }
            layout = suffix;
            std::string p = {};
            auto hold = value;
            //Go switch emulation
            {
                auto condition = std & stdMask;
                int conditionId = -1;
                if(condition == stdYear) { conditionId = 0; }
                else if(condition == stdLongYear) { conditionId = 1; }
                else if(condition == stdMonth) { conditionId = 2; }
                else if(condition == stdLongMonth) { conditionId = 3; }
                else if(condition == stdNumMonth) { conditionId = 4; }
                else if(condition == stdZeroMonth) { conditionId = 5; }
                else if(condition == stdWeekDay) { conditionId = 6; }
                else if(condition == stdLongWeekDay) { conditionId = 7; }
                else if(condition == stdDay) { conditionId = 8; }
                else if(condition == stdUnderDay) { conditionId = 9; }
                else if(condition == stdZeroDay) { conditionId = 10; }
                else if(condition == stdUnderYearDay) { conditionId = 11; }
                else if(condition == stdZeroYearDay) { conditionId = 12; }
                else if(condition == stdHour) { conditionId = 13; }
                else if(condition == stdHour12) { conditionId = 14; }
                else if(condition == stdZeroHour12) { conditionId = 15; }
                else if(condition == stdMinute) { conditionId = 16; }
                else if(condition == stdZeroMinute) { conditionId = 17; }
                else if(condition == stdSecond) { conditionId = 18; }
                else if(condition == stdZeroSecond) { conditionId = 19; }
                else if(condition == stdPM) { conditionId = 20; }
                else if(condition == stdpm) { conditionId = 21; }
                else if(condition == stdISO8601TZ) { conditionId = 22; }
                else if(condition == stdISO8601ColonTZ) { conditionId = 23; }
                else if(condition == stdISO8601SecondsTZ) { conditionId = 24; }
                else if(condition == stdISO8601ShortTZ) { conditionId = 25; }
                else if(condition == stdISO8601ColonSecondsTZ) { conditionId = 26; }
                else if(condition == stdNumTZ) { conditionId = 27; }
                else if(condition == stdNumShortTZ) { conditionId = 28; }
                else if(condition == stdNumColonTZ) { conditionId = 29; }
                else if(condition == stdNumSecondsTz) { conditionId = 30; }
                else if(condition == stdNumColonSecondsTZ) { conditionId = 31; }
                else if(condition == stdTZ) { conditionId = 32; }
                else if(condition == stdFracSecond0) { conditionId = 33; }
                else if(condition == stdFracSecond9) { conditionId = 34; }
                switch(conditionId)
                {
                    case 0:
                        if(len(value) < 2)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 2), value.make_slice(2)};
                        std::tie(year, err) = atoi(p);
                        if(err != nullptr)
                        {
                            break;
                        }
                        if(year >= 69)
                        {
                            year += 1900;
                        }
                        else
                        {
                            year += 2000;
                        }
                        break;
                    case 1:
                        if(len(value) < 4 || ! isDigit(value, 0))
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 4), value.make_slice(4)};
                        std::tie(year, err) = atoi(p);
                        break;
                    case 2:
                        std::tie(month, value, err) = lookup(shortMonthNames, value);
                        month++;
                        break;
                    case 3:
                        std::tie(month, value, err) = lookup(longMonthNames, value);
                        month++;
                        break;
                    case 4:
                    case 5:
                        std::tie(month, value, err) = getnum(value, std == stdZeroMonth);
                        if(err == nullptr && (month <= 0 || 12 < month))
                        {
                            rangeErrString = "month"s;
                        }
                        break;
                    case 6:
                        std::tie(gocpp_id_3, value, err) = lookup(shortDayNames, value);
                        break;
                    case 7:
                        std::tie(gocpp_id_4, value, err) = lookup(longDayNames, value);
                        break;
                    case 8:
                    case 9:
                    case 10:
                        if(std == stdUnderDay && len(value) > 0 && value[0] == ' ')
                        {
                            value = value.make_slice(1);
                        }
                        std::tie(day, value, err) = getnum(value, std == stdZeroDay);
                        break;
                    case 11:
                    case 12:
                        for(auto i = 0; i < 2; i++)
                        {
                            if(std == stdUnderYearDay && len(value) > 0 && value[0] == ' ')
                            {
                                value = value.make_slice(1);
                            }
                        }
                        std::tie(yday, value, err) = getnum3(value, std == stdZeroYearDay);
                        break;
                    case 13:
                        std::tie(hour, value, err) = getnum(value, false);
                        if(hour < 0 || 24 <= hour)
                        {
                            rangeErrString = "hour"s;
                        }
                        break;
                    case 14:
                    case 15:
                        std::tie(hour, value, err) = getnum(value, std == stdZeroHour12);
                        if(hour < 0 || 12 < hour)
                        {
                            rangeErrString = "hour"s;
                        }
                        break;
                    case 16:
                    case 17:
                        std::tie(min, value, err) = getnum(value, std == stdZeroMinute);
                        if(min < 0 || 60 <= min)
                        {
                            rangeErrString = "minute"s;
                        }
                        break;
                    case 18:
                    case 19:
                        std::tie(sec, value, err) = getnum(value, std == stdZeroSecond);
                        if(err != nullptr)
                        {
                            break;
                        }
                        if(sec < 0 || 60 <= sec)
                        {
                            rangeErrString = "second"s;
                            break;
                        }
                        if(len(value) >= 2 && commaOrPeriod(value[0]) && isDigit(value, 1))
                        {
                            std::tie(gocpp_id_5, std, gocpp_id_6) = nextStdChunk(layout);
                            std &= stdMask;
                            if(std == stdFracSecond0 || std == stdFracSecond9)
                            {
                                break;
                            }
                            auto n = 2;
                            for(; n < len(value) && isDigit(value, n); n++)
                            {
                            }
                            std::tie(nsec, rangeErrString, err) = parseNanoseconds(value, n);
                            value = value.make_slice(n);
                        }
                        break;
                    case 20:
                        if(len(value) < 2)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 2), value.make_slice(2)};
                        //Go switch emulation
                        {
                            auto condition = p;
                            int conditionId = -1;
                            if(condition == "PM"s) { conditionId = 0; }
                            else if(condition == "AM"s) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    pmSet = true;
                                    break;
                                case 1:
                                    amSet = true;
                                    break;
                                default:
                                    err = errBad;
                                    break;
                            }
                        }
                        break;
                    case 21:
                        if(len(value) < 2)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 2), value.make_slice(2)};
                        //Go switch emulation
                        {
                            auto condition = p;
                            int conditionId = -1;
                            if(condition == "pm"s) { conditionId = 0; }
                            else if(condition == "am"s) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    pmSet = true;
                                    break;
                                case 1:
                                    amSet = true;
                                    break;
                                default:
                                    err = errBad;
                                    break;
                            }
                        }
                        break;
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        if((std == stdISO8601TZ || std == stdISO8601ShortTZ || std == stdISO8601ColonTZ) && len(value) >= 1 && value[0] == 'Z')
                        {
                            value = value.make_slice(1);
                            z = UTC;
                            break;
                        }
                        std::string sign = {};
                        std::string hour = {};
                        std::string min = {};
                        std::string seconds = {};
                        if(std == stdISO8601ColonTZ || std == stdNumColonTZ)
                        {
                            if(len(value) < 6)
                            {
                                err = errBad;
                                break;
                            }
                            if(value[3] != ':')
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(4, 6), "00"s, value.make_slice(6)};
                        }
                        else
                        if(std == stdNumShortTZ || std == stdISO8601ShortTZ)
                        {
                            if(len(value) < 3)
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), "00"s, "00"s, value.make_slice(3)};
                        }
                        else
                        if(std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ)
                        {
                            if(len(value) < 9)
                            {
                                err = errBad;
                                break;
                            }
                            if(value[3] != ':' || value[6] != ':')
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(4, 6), value.make_slice(7, 9), value.make_slice(9)};
                        }
                        else
                        if(std == stdISO8601SecondsTZ || std == stdNumSecondsTz)
                        {
                            if(len(value) < 7)
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(3, 5), value.make_slice(5, 7), value.make_slice(7)};
                        }
                        else
                        {
                            if(len(value) < 5)
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(3, 5), "00"s, value.make_slice(5)};
                        }
                        int hr = {};
                        int mm = {};
                        int ss = {};
                        std::tie(hr, gocpp_id_7, err) = getnum(hour, true);
                        if(err == nullptr)
                        {
                            std::tie(mm, gocpp_id_8, err) = getnum(min, true);
                        }
                        if(err == nullptr)
                        {
                            std::tie(ss, gocpp_id_9, err) = getnum(seconds, true);
                        }
                        zoneOffset = (hr * 60 + mm) * 60 + ss;
                        //Go switch emulation
                        {
                            auto condition = sign[0];
                            int conditionId = -1;
                            if(condition == '+') { conditionId = 0; }
                            else if(condition == '-') { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    break;
                                case 1:
                                    zoneOffset = - zoneOffset;
                                    break;
                                default:
                                    err = errBad;
                                    break;
                            }
                        }
                        break;
                    case 32:
                        if(len(value) >= 3 && value.make_slice(0, 3) == "UTC"s)
                        {
                            z = UTC;
                            value = value.make_slice(3);
                            break;
                        }
                        auto [n, ok] = parseTimeZone(value);
                        if(! ok)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(zoneName, value) = std::tuple{value.make_slice(0, n), value.make_slice(n)};
                        break;
                    case 33:
                        auto ndigit = 1 + digitsLen(std);
                        if(len(value) < ndigit)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(nsec, rangeErrString, err) = parseNanoseconds(value, ndigit);
                        value = value.make_slice(ndigit);
                        break;
                    case 34:
                        if(len(value) < 2 || ! commaOrPeriod(value[0]) || value[1] < '0' || '9' < value[1])
                        {
                            break;
                        }
                        auto i = 0;
                        for(; i + 1 < len(value) && '0' <= value[i + 1] && value[i + 1] <= '9'; )
                        {
                            i++;
                        }
                        std::tie(nsec, rangeErrString, err) = parseNanoseconds(value, 1 + i);
                        value = value.make_slice(1 + i);
                        break;
                }
            }
            if(rangeErrString != ""s)
            {
                return {Time {}, newParseError(alayout, avalue, stdstr, value, ": "s + rangeErrString + " out of range"s)};
            }
            if(err != nullptr)
            {
                return {Time {}, newParseError(alayout, avalue, stdstr, hold, ""s)};
            }
        }
        if(pmSet && hour < 12)
        {
            hour += 12;
        }
        else
        if(amSet && hour == 12)
        {
            hour = 0;
        }
        if(yday >= 0)
        {
            int d = {};
            int m = {};
            if(isLeap(year))
            {
                if(yday == 31 + 29)
                {
                    m = int(February);
                    d = 29;
                }
                else
                if(yday > 31 + 29)
                {
                    yday--;
                }
            }
            if(yday < 1 || yday > 365)
            {
                return {Time {}, newParseError(alayout, avalue, ""s, value, ": day-of-year out of range"s)};
            }
            if(m == 0)
            {
                m = (yday - 1) / 31 + 1;
                if(int(daysBefore[m]) < yday)
                {
                    m++;
                }
                d = yday - int(daysBefore[m - 1]);
            }
            if(month >= 0 && month != m)
            {
                return {Time {}, newParseError(alayout, avalue, ""s, value, ": day-of-year does not match month"s)};
            }
            month = m;
            if(day >= 0 && day != d)
            {
                return {Time {}, newParseError(alayout, avalue, ""s, value, ": day-of-year does not match day"s)};
            }
            day = d;
        }
        else
        {
            if(month < 0)
            {
                month = int(January);
            }
            if(day < 0)
            {
                day = 1;
            }
        }
        if(day < 1 || day > daysIn(Month(month), year))
        {
            return {Time {}, newParseError(alayout, avalue, ""s, value, ": day out of range"s)};
        }
        if(z != nullptr)
        {
            return {Date(year, Month(month), day, hour, min, sec, nsec, z), nullptr};
        }
        if(zoneOffset != - 1)
        {
            auto t = Date(year, Month(month), day, hour, min, sec, nsec, UTC);
            rec::addSec(gocpp::recv(t), - int64_t(zoneOffset));
            auto [name, offset, gocpp_id_13, gocpp_id_14, gocpp_id_15] = rec::lookup(gocpp::recv(local), rec::unixSec(gocpp::recv(t)));
            if(offset == zoneOffset && (zoneName == ""s || name == zoneName))
            {
                rec::setLoc(gocpp::recv(t), local);
                return {t, nullptr};
            }
            auto zoneNameCopy = cloneString(zoneName);
            rec::setLoc(gocpp::recv(t), FixedZone(zoneNameCopy, zoneOffset));
            return {t, nullptr};
        }
        if(zoneName != ""s)
        {
            auto t = Date(year, Month(month), day, hour, min, sec, nsec, UTC);
            auto [offset, ok] = rec::lookupName(gocpp::recv(local), zoneName, rec::unixSec(gocpp::recv(t)));
            if(ok)
            {
                rec::addSec(gocpp::recv(t), - int64_t(offset));
                rec::setLoc(gocpp::recv(t), local);
                return {t, nullptr};
            }
            if(len(zoneName) > 3 && zoneName.make_slice(0, 3) == "GMT"s)
            {
                std::tie(offset, gocpp_id_16) = atoi(zoneName.make_slice(3));
                offset *= 3600;
            }
            auto zoneNameCopy = cloneString(zoneName);
            rec::setLoc(gocpp::recv(t), FixedZone(zoneNameCopy, offset));
            return {t, nullptr};
        }
        return {Date(year, Month(month), day, hour, min, sec, nsec, defaultLocation), nullptr};
    }

    std::tuple<int, bool> parseTimeZone(std::string value)
    {
        int length;
        bool ok;
        if(len(value) < 3)
        {
            return {0, false};
        }
        if(len(value) >= 4 && (value.make_slice(0, 4) == "ChST"s || value.make_slice(0, 4) == "MeST"s))
        {
            return {4, true};
        }
        if(value.make_slice(0, 3) == "GMT"s)
        {
            length = parseGMT(value);
            return {length, true};
        }
        if(value[0] == '+' || value[0] == '-')
        {
            length = parseSignedOffset(value);
            auto ok = length > 0;
            return {length, ok};
        }
        int nUpper = {};
        for(nUpper = 0; nUpper < 6; nUpper++)
        {
            if(nUpper >= len(value))
            {
                break;
            }
            if(auto c = value[nUpper]; c < 'A' || 'Z' < c)
            {
                break;
            }
        }
        //Go switch emulation
        {
            auto condition = nUpper;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            else if(condition == 6) { conditionId = 3; }
            else if(condition == 5) { conditionId = 4; }
            else if(condition == 4) { conditionId = 5; }
            else if(condition == 3) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    return {0, false};
                    break;
                case 4:
                    if(value[4] == 'T')
                    {
                        return {5, true};
                    }
                    break;
                case 5:
                    if(value[3] == 'T' || value.make_slice(0, 4) == "WITA"s)
                    {
                        return {4, true};
                    }
                    break;
                case 6:
                    return {3, true};
                    break;
            }
        }
        return {0, false};
    }

    int parseGMT(std::string value)
    {
        value = value.make_slice(3);
        if(len(value) == 0)
        {
            return 3;
        }
        return 3 + parseSignedOffset(value);
    }

    int parseSignedOffset(std::string value)
    {
        auto sign = value[0];
        if(sign != '-' && sign != '+')
        {
            return 0;
        }
        auto [x, rem, err] = leadingInt(value.make_slice(1));
        if(err != nullptr || value.make_slice(1) == rem)
        {
            return 0;
        }
        if(x > 23)
        {
            return 0;
        }
        return len(value) - len(rem);
    }

    bool commaOrPeriod(unsigned char b)
    {
        return b == '.' || b == ',';
    }


    template<typename bytes>
    std::tuple<int, std::string, struct gocpp::error> parseNanoseconds(bytes value, int nbytes)
    {
        int ns;
        std::string rangeErrString;
        struct gocpp::error err;
        if(! commaOrPeriod(value[0]))
        {
            err = errBad;
            return {ns, rangeErrString, err};
        }
        if(nbytes > 10)
        {
            value = value.make_slice(0, 10);
            nbytes = 10;
        }
        if(std::tie(ns, err) = atoi(value.make_slice(1, nbytes)); err != nullptr)
        {
            return {ns, rangeErrString, err};
        }
        if(ns < 0)
        {
            rangeErrString = "fractional second"s;
            return {ns, rangeErrString, err};
        }
        auto scaleDigits = 10 - nbytes;
        for(auto i = 0; i < scaleDigits; i++)
        {
            ns *= 10;
        }
        return {ns, rangeErrString, err};
    }

    gocpp::error errLeadingInt = errors::New("time: bad [0-9]*"s);

    template<typename bytes>
    std::tuple<uint64_t, bytes, struct gocpp::error> leadingInt(bytes s)
    {
        uint64_t x;
        bytes rem;
        struct gocpp::error err;
        auto i = 0;
        for(; i < len(s); i++)
        {
            auto c = s[i];
            if(c < '0' || c > '9')
            {
                break;
            }
            if(x > (1 << 63) / 10)
            {
                return {0, rem, errLeadingInt};
            }
            x = x * 10 + uint64_t(c) - '0';
            if(x > (1 << 63))
            {
                return {0, rem, errLeadingInt};
            }
        }
        return {x, s.make_slice(i), nullptr};
    }

    std::tuple<uint64_t, double, std::string> leadingFraction(std::string s)
    {
        uint64_t x;
        double scale;
        std::string rem;
        auto i = 0;
        scale = 1;
        auto overflow = false;
        for(; i < len(s); i++)
        {
            auto c = s[i];
            if(c < '0' || c > '9')
            {
                break;
            }
            if(overflow)
            {
                continue;
            }
            if(x > ((1 << 63) - 1) / 10)
            {
                overflow = true;
                continue;
            }
            auto y = x * 10 + uint64_t(c) - '0';
            if(y > (1 << 63))
            {
                overflow = true;
                continue;
            }
            x = y;
            scale *= 10;
        }
        return {x, scale, s.make_slice(i)};
    }

    gocpp::map<std::string, uint64_t> unitMap = gocpp::map<std::string, uint64_t> {{ "ns"s, uint64_t(Nanosecond) }, { "us"s, uint64_t(Microsecond) }, { "s"s, uint64_t(Microsecond) }, { "s"s, uint64_t(Microsecond) }, { "ms"s, uint64_t(Millisecond) }, { "s"s, uint64_t(Second) }, { "m"s, uint64_t(Minute) }, { "h"s, uint64_t(Hour) }};
    std::tuple<time::Duration, struct gocpp::error> ParseDuration(std::string s)
    {
        auto orig = s;
        uint64_t d = {};
        auto neg = false;
        if(s != ""s)
        {
            auto c = s[0];
            if(c == '-' || c == '+')
            {
                neg = c == '-';
                s = s.make_slice(1);
            }
        }
        if(s == "0"s)
        {
            return {0, nullptr};
        }
        if(s == ""s)
        {
            return {0, errors::New("time: invalid duration "s + quote(orig))};
        }
        for(; s != ""s; )
        {
            uint64_t v = {};
            uint64_t f = {};
            double scale = 1;
            gocpp::error err = {};
            if(! (s[0] == '.' || '0' <= s[0] && s[0] <= '9'))
            {
                return {0, errors::New("time: invalid duration "s + quote(orig))};
            }
            auto pl = len(s);
            std::tie(v, s, err) = leadingInt(s);
            if(err != nullptr)
            {
                return {0, errors::New("time: invalid duration "s + quote(orig))};
            }
            auto pre = pl != len(s);
            auto post = false;
            if(s != ""s && s[0] == '.')
            {
                s = s.make_slice(1);
                auto pl = len(s);
                std::tie(f, scale, s) = leadingFraction(s);
                post = pl != len(s);
            }
            if(! pre && ! post)
            {
                return {0, errors::New("time: invalid duration "s + quote(orig))};
            }
            auto i = 0;
            for(; i < len(s); i++)
            {
                auto c = s[i];
                if(c == '.' || '0' <= c && c <= '9')
                {
                    break;
                }
            }
            if(i == 0)
            {
                return {0, errors::New("time: missing unit in duration "s + quote(orig))};
            }
            auto u = s.make_slice(0, i);
            s = s.make_slice(i);
            auto [unit, ok] = unitMap[u];
            if(! ok)
            {
                return {0, errors::New("time: unknown unit "s + quote(u) + " in duration "s + quote(orig))};
            }
            if(v > (1 << 63) / unit)
            {
                return {0, errors::New("time: invalid duration "s + quote(orig))};
            }
            v *= unit;
            if(f > 0)
            {
                v += uint64_t(double(f) * (double(unit) / scale));
                if(v > (1 << 63))
                {
                    return {0, errors::New("time: invalid duration "s + quote(orig))};
                }
            }
            d += v;
            if(d > (1 << 63))
            {
                return {0, errors::New("time: invalid duration "s + quote(orig))};
            }
        }
        if(neg)
        {
            return {- Duration(d), nullptr};
        }
        if(d > (1 << 63) - 1)
        {
            return {0, errors::New("time: invalid duration "s + quote(orig))};
        }
        return {Duration(d), nullptr};
    }

}

