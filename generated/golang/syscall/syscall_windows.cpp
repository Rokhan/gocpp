// generated by GoCpp from file '$(ImportDir)/syscall/syscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/syscall_windows.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/itoa/itoa.h"
#include "golang/internal/race/norace.h"
#include "golang/runtime/extern.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/syscall/asan0.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/msan0.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/wtf8_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
        using sync::rec::Do;
    }

    // StringToUTF16 returns the UTF-16 encoding of the UTF-8 string s,
    // with a terminating NUL added. If s contains a NUL byte this
    // function panics instead of returning an error.
    //
    // Deprecated: Use UTF16FromString instead.
    gocpp::slice<uint16_t> StringToUTF16(std::string s)
    {
        auto [a, err] = UTF16FromString(s);
        if(err != nullptr)
        {
            gocpp::panic("syscall: string with NUL passed to StringToUTF16"s);
        }
        return a;
    }

    // UTF16FromString returns the UTF-16 encoding of the UTF-8 string
    // s, with a terminating NUL added. If s contains a NUL byte at any
    // location, it returns (nil, EINVAL). Unpaired surrogates
    // are encoded using WTF-8.
    std::tuple<gocpp::slice<uint16_t>, struct gocpp::error> UTF16FromString(std::string s)
    {
        if(bytealg::IndexByteString(s, 0) != - 1)
        {
            return {nullptr, go_EINVAL};
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 0, len(s) + 1);
        buf = encodeWTF16(s, buf);
        return {append(buf, 0), nullptr};
    }

    // UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,
    // with a terminating NUL removed. Unpaired surrogates are decoded
    // using WTF-8 instead of UTF-8 encoding.
    std::string UTF16ToString(gocpp::slice<uint16_t> s)
    {
        auto maxLen = 0;
        for(auto [i, v] : s)
        {
            if(v == 0)
            {
                s = s.make_slice(0, i);
                break;
            }
            //Go switch emulation
            {
                int conditionId = -1;
                if(v <= rune1Max) { conditionId = 0; }
                else if(v <= rune2Max) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        maxLen += 1;
                        break;
                    case 1:
                        maxLen += 2;
                        break;
                    default:
                        maxLen += 3;
                        break;
                }
            }
        }
        auto buf = decodeWTF16(s, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, maxLen));
        return unsafe::String(unsafe::SliceData(buf), len(buf));
    }

    // utf16PtrToString is like UTF16ToString, but takes *uint16
    // as a parameter instead of []uint16.
    std::string utf16PtrToString(uint16_t* p)
    {
        if(p == nullptr)
        {
            return ""s;
        }
        auto end = unsafe::Pointer(p);
        auto n = 0;
        for(; *(uint16_t*)(end) != 0; )
        {
            end = unsafe::Pointer(uintptr_t(end) + gocpp::Sizeof<uint16_t>());
            n++;
        }
        return UTF16ToString(unsafe::Slice(p, n));
    }

    // StringToUTF16Ptr returns pointer to the UTF-16 encoding of
    // the UTF-8 string s, with a terminating NUL added. If s
    // contains a NUL byte this function panics instead of
    // returning an error.
    //
    // Deprecated: Use UTF16PtrFromString instead.
    uint16_t* StringToUTF16Ptr(std::string s)
    {
        return & StringToUTF16(s)[0];
    }

    // UTF16PtrFromString returns pointer to the UTF-16 encoding of
    // the UTF-8 string s, with a terminating NUL added. If s
    // contains a NUL byte at any location, it returns (nil, EINVAL).
    // Unpaired surrogates are encoded using WTF-8.
    std::tuple<uint16_t*, struct gocpp::error> UTF16PtrFromString(std::string s)
    {
        auto [a, err] = UTF16FromString(s);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {& a[0], nullptr};
    }

    // Errno is the Windows error number.
    //
    // Errno values can be tested against error values using errors.Is.
    // For example:
    //
    //	_, _, err := syscall.Syscall(...)
    //	if errors.Is(err, fs.ErrNotExist) ...
    uint32_t langid(uint16_t pri, uint16_t sub)
    {
        return (uint32_t(sub) << 10) | uint32_t(pri);
    }

    // FormatMessage is deprecated (msgsrc should be uintptr, not uint32, but can
    // not be changed due to the Go 1 compatibility guarantee).
    //
    // Deprecated: Use FormatMessage from golang.org/x/sys/windows instead.
    std::tuple<uint32_t, struct gocpp::error> FormatMessage(uint32_t flags, uint32_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args)
    {
        uint32_t n;
        struct gocpp::error err;
        return formatMessage(flags, uintptr_t(msgsrc), msgid, langid, buf, args);
    }

    std::string rec::Error(golang::syscall::Errno e)
    {
        auto idx = int(e - APPLICATION_ERROR);
        if(0 <= idx && idx < len(errors))
        {
            return errors[idx];
        }
        // ask windows for the remaining errors
        uint32_t flags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_IGNORE_INSERTS;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 300);
        auto [n, err] = formatMessage(flags, 0, uint32_t(e), langid(LANG_ENGLISH, SUBLANG_ENGLISH_US), b, nullptr);
        if(err != nullptr)
        {
            std::tie(n, err) = formatMessage(flags, 0, uint32_t(e), 0, b, nullptr);
            if(err != nullptr)
            {
                return "winapi error #"s + itoa::Itoa(int(e));
            }
        }
        for(; n > 0 && (b[n - 1] == '\n' || b[n - 1] == '\r'); n--)
        {
        }
        return UTF16ToString(b.make_slice(0, n));
    }

    bool rec::Is(golang::syscall::Errno e, struct gocpp::error target)
    {
        //Go switch emulation
        {
            auto condition = target;
            int conditionId = -1;
            if(condition == oserror::ErrPermission) { conditionId = 0; }
            else if(condition == oserror::ErrExist) { conditionId = 1; }
            else if(condition == oserror::ErrNotExist) { conditionId = 2; }
            else if(condition == errorspkg::ErrUnsupported) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return e == ERROR_ACCESS_DENIED || e == go_EACCES || e == go_EPERM;
                    break;
                case 1:
                    return e == ERROR_ALREADY_EXISTS || e == ERROR_DIR_NOT_EMPTY || e == ERROR_FILE_EXISTS || e == go_EEXIST || e == go_ENOTEMPTY;
                    break;
                case 2:
                    return e == ERROR_FILE_NOT_FOUND || e == _ERROR_BAD_NETPATH || e == ERROR_PATH_NOT_FOUND || e == go_ENOENT;
                    break;
                case 3:
                    return e == _ERROR_NOT_SUPPORTED || e == _ERROR_CALL_NOT_IMPLEMENTED || e == go_ENOSYS || e == go_ENOTSUP || e == go_EOPNOTSUPP || e == go_EWINDOWS;
                    break;
            }
        }
        return false;
    }

    bool rec::Temporary(golang::syscall::Errno e)
    {
        return e == go_EINTR || e == go_EMFILE || rec::Timeout(gocpp::recv(e));
    }

    bool rec::Timeout(golang::syscall::Errno e)
    {
        return e == go_EAGAIN || e == go_EWOULDBLOCK || e == go_ETIMEDOUT;
    }

    // Implemented in runtime/syscall_windows.go.
    uintptr_t compileCallback(go_any fn, bool cleanstack)
    /* convertBlockStmt, nil block */;

    // NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.
    // This is useful when interoperating with Windows code requiring callbacks.
    // The argument is expected to be a function with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
    // Only a limited number of callbacks may be created in a single Go process, and any memory allocated
    // for these callbacks is never released.
    // Between NewCallback and NewCallbackCDecl, at least 1024 callbacks can always be created.
    uintptr_t NewCallback(go_any fn)
    {
        return compileCallback(fn, true);
    }

    // NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.
    // This is useful when interoperating with Windows code requiring callbacks.
    // The argument is expected to be a function with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
    // Only a limited number of callbacks may be created in a single Go process, and any memory allocated
    // for these callbacks is never released.
    // Between NewCallback and NewCallbackCDecl, at least 1024 callbacks can always be created.
    uintptr_t NewCallbackCDecl(go_any fn)
    {
        return compileCallback(fn, false);
    }

    struct SecurityAttributes* makeInheritSa()
    {
        SecurityAttributes sa = {};
        sa.Length = uint32_t(gocpp::Sizeof<SecurityAttributes>());
        sa.InheritHandle = 1;
        return & sa;
    }

    std::tuple<syscall::Handle, struct gocpp::error> Open(std::string path, int mode, uint32_t perm)
    {
        syscall::Handle fd;
        struct gocpp::error err;
        if(len(path) == 0)
        {
            return {InvalidHandle, ERROR_FILE_NOT_FOUND};
        }
        uint16_t* pathp;
        std::tie(pathp, err) = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return {InvalidHandle, err};
        }
        uint32_t access = {};
        //Go switch emulation
        {
            auto condition = mode & (O_RDONLY | O_WRONLY | O_RDWR);
            int conditionId = -1;
            if(condition == O_RDONLY) { conditionId = 0; }
            else if(condition == O_WRONLY) { conditionId = 1; }
            else if(condition == O_RDWR) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    access = GENERIC_READ;
                    break;
                case 1:
                    access = GENERIC_WRITE;
                    break;
                case 2:
                    access = GENERIC_READ | GENERIC_WRITE;
                    break;
            }
        }
        if(mode & O_CREAT != 0)
        {
            access |= GENERIC_WRITE;
        }
        if(mode & O_APPEND != 0)
        {
            access &^= GENERIC_WRITE;
            access |= FILE_APPEND_DATA;
        }
        auto sharemode = uint32_t(FILE_SHARE_READ | FILE_SHARE_WRITE);
        SecurityAttributes* sa = {};
        if(mode & O_CLOEXEC == 0)
        {
            sa = makeInheritSa();
        }
        uint32_t createmode = {};
        //Go switch emulation
        {
            int conditionId = -1;
            if(mode & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL)) { conditionId = 0; }
            else if(mode & (O_CREAT | O_TRUNC) == (O_CREAT | O_TRUNC)) { conditionId = 1; }
            else if(mode & O_CREAT == O_CREAT) { conditionId = 2; }
            else if(mode & O_TRUNC == O_TRUNC) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    createmode = CREATE_NEW;
                    break;
                case 1:
                    createmode = CREATE_ALWAYS;
                    break;
                case 2:
                    createmode = OPEN_ALWAYS;
                    break;
                case 3:
                    createmode = TRUNCATE_EXISTING;
                    break;
                default:
                    createmode = OPEN_EXISTING;
                    break;
            }
        }
        uint32_t attrs = FILE_ATTRIBUTE_NORMAL;
        if(perm & S_IWRITE == 0)
        {
            attrs = FILE_ATTRIBUTE_READONLY;
            if(createmode == CREATE_ALWAYS)
            {
                auto [h, e] = CreateFile(pathp, access, sharemode, sa, TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                //Go switch emulation
                {
                    auto condition = e;
                    int conditionId = -1;
                    if(condition == ERROR_FILE_NOT_FOUND) { conditionId = 0; }
                    else if(condition == _ERROR_BAD_NETPATH) { conditionId = 1; }
                    else if(condition == ERROR_PATH_NOT_FOUND) { conditionId = 2; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                        case 2:
                            break;
                        default:
                            return {h, e};
                            break;
                    }
                }
            }
        }
        if(createmode == OPEN_EXISTING && access == GENERIC_READ)
        {
            attrs |= FILE_FLAG_BACKUP_SEMANTICS;
        }
        if(mode & O_SYNC != 0)
        {
            auto _FILE_FLAG_WRITE_THROUGH = 0x80000000;
            attrs |= _FILE_FLAG_WRITE_THROUGH;
        }
        return CreateFile(pathp, access, sharemode, sa, createmode, attrs, 0);
    }

    std::tuple<int, struct gocpp::error> Read(golang::syscall::Handle fd, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        uint32_t done = {};
        auto e = ReadFile(fd, p, & done, nullptr);
        if(e != nullptr)
        {
            if(e == ERROR_BROKEN_PIPE)
            {
                return {0, nullptr};
            }
            return {0, e};
        }
        return {int(done), nullptr};
    }

    std::tuple<int, struct gocpp::error> Write(golang::syscall::Handle fd, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        uint32_t done = {};
        auto e = WriteFile(fd, p, & done, nullptr);
        if(e != nullptr)
        {
            return {0, e};
        }
        return {int(done), nullptr};
    }

    struct gocpp::error ReadFile(golang::syscall::Handle fd, gocpp::slice<unsigned char> p, uint32_t* done, struct Overlapped* overlapped)
    {
        auto err = readFile(fd, p, done, overlapped);
        if(race::Enabled)
        {
            if(*done > 0)
            {
                race::WriteRange(unsafe::Pointer(& p[0]), int(*done));
            }
            race::Acquire(unsafe::Pointer(& ioSync));
        }
        if(msanenabled && *done > 0)
        {
            msanWrite(unsafe::Pointer(& p[0]), int(*done));
        }
        if(asanenabled && *done > 0)
        {
            asanWrite(unsafe::Pointer(& p[0]), int(*done));
        }
        return err;
    }

    struct gocpp::error WriteFile(golang::syscall::Handle fd, gocpp::slice<unsigned char> p, uint32_t* done, struct Overlapped* overlapped)
    {
        if(race::Enabled)
        {
            race::ReleaseMerge(unsafe::Pointer(& ioSync));
        }
        auto err = writeFile(fd, p, done, overlapped);
        if(race::Enabled && *done > 0)
        {
            race::ReadRange(unsafe::Pointer(& p[0]), int(*done));
        }
        if(msanenabled && *done > 0)
        {
            msanRead(unsafe::Pointer(& p[0]), int(*done));
        }
        if(asanenabled && *done > 0)
        {
            asanRead(unsafe::Pointer(& p[0]), int(*done));
        }
        return err;
    }

    int64_t ioSync;
    LazyProc* procSetFilePointerEx = rec::NewProc(gocpp::recv(modkernel32), "SetFilePointerEx"s);
    // setFilePointerEx calls SetFilePointerEx.
    // See https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex
    struct gocpp::error setFilePointerEx(golang::syscall::Handle handle, int64_t distToMove, int64_t* newFilePointer, uint32_t whence)
    {
        syscall::Errno e1 = {};
        if(gocpp::Sizeof<uintptr_t>() == 8)
        {
            std::tie(gocpp_id_0, gocpp_id_1, e1) = Syscall6(rec::Addr(gocpp::recv(procSetFilePointerEx)), 4, uintptr_t(handle), uintptr_t(distToMove), uintptr_t(unsafe::Pointer(newFilePointer)), uintptr_t(whence), 0, 0);
        }
        else
        {
            //Go switch emulation
            {
                auto condition = runtime::GOARCH;
                int conditionId = -1;
                if(condition == "386"s) { conditionId = 0; }
                else if(condition == "arm"s) { conditionId = 1; }
                switch(conditionId)
                {
                    default:
                        gocpp::panic("unsupported 32-bit architecture"s);
                        break;
                    case 0:
                        std::tie(gocpp_id_2, gocpp_id_3, e1) = Syscall6(rec::Addr(gocpp::recv(procSetFilePointerEx)), 5, uintptr_t(handle), uintptr_t(distToMove), uintptr_t(distToMove >> 32), uintptr_t(unsafe::Pointer(newFilePointer)), uintptr_t(whence), 0);
                        break;
                    case 1:
                        std::tie(gocpp_id_4, gocpp_id_5, e1) = Syscall6(rec::Addr(gocpp::recv(procSetFilePointerEx)), 6, uintptr_t(handle), 0, uintptr_t(distToMove), uintptr_t(distToMove >> 32), uintptr_t(unsafe::Pointer(newFilePointer)), uintptr_t(whence));
                        break;
                }
            }
        }
        if(e1 != 0)
        {
            return errnoErr(e1);
        }
        return nullptr;
    }

    std::tuple<int64_t, struct gocpp::error> Seek(golang::syscall::Handle fd, int64_t offset, int whence)
    {
        int64_t newoffset;
        struct gocpp::error err;
        uint32_t w = {};
        //Go switch emulation
        {
            auto condition = whence;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    w = FILE_BEGIN;
                    break;
                case 1:
                    w = FILE_CURRENT;
                    break;
                case 2:
                    w = FILE_END;
                    break;
            }
        }
        err = setFilePointerEx(fd, offset, & newoffset, w);
        return {newoffset, err};
    }

    struct gocpp::error Close(golang::syscall::Handle fd)
    {
        struct gocpp::error err;
        return CloseHandle(fd);
    }

    Handle Stdin = getStdHandle(STD_INPUT_HANDLE);
    Handle Stdout = getStdHandle(STD_OUTPUT_HANDLE);
    Handle Stderr = getStdHandle(STD_ERROR_HANDLE);
    syscall::Handle getStdHandle(int h)
    {
        syscall::Handle fd;
        auto [r, gocpp_id_7] = GetStdHandle(h);
        return r;
    }

    std::tuple<std::string, struct gocpp::error> Getwd()
    {
        std::string wd;
        struct gocpp::error err;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), 300);
        for(; ; )
        {
            auto [n, e] = GetCurrentDirectory(uint32_t(len(b)), & b[0]);
            if(e != nullptr)
            {
                return {""s, e};
            }
            if(int(n) <= len(b))
            {
                return {UTF16ToString(b.make_slice(0, n)), nullptr};
            }
            b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
        }
    }

    struct gocpp::error Chdir(std::string path)
    {
        struct gocpp::error err;
        uint16_t* pathp;
        std::tie(pathp, err) = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return err;
        }
        return SetCurrentDirectory(pathp);
    }

    struct gocpp::error Mkdir(std::string path, uint32_t mode)
    {
        struct gocpp::error err;
        uint16_t* pathp;
        std::tie(pathp, err) = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return err;
        }
        return CreateDirectory(pathp, nullptr);
    }

    struct gocpp::error Rmdir(std::string path)
    {
        struct gocpp::error err;
        uint16_t* pathp;
        std::tie(pathp, err) = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return err;
        }
        return RemoveDirectory(pathp);
    }

    struct gocpp::error Unlink(std::string path)
    {
        struct gocpp::error err;
        uint16_t* pathp;
        std::tie(pathp, err) = UTF16PtrFromString(path);
        if(err != nullptr)
        {
            return err;
        }
        return DeleteFile(pathp);
    }

    struct gocpp::error Rename(std::string oldpath, std::string newpath)
    {
        struct gocpp::error err;
        uint16_t* from;
        std::tie(from, err) = UTF16PtrFromString(oldpath);
        if(err != nullptr)
        {
            return err;
        }
        uint16_t* to;
        std::tie(to, err) = UTF16PtrFromString(newpath);
        if(err != nullptr)
        {
            return err;
        }
        return MoveFile(from, to);
    }

    std::tuple<std::string, struct gocpp::error> ComputerName()
    {
        std::string name;
        struct gocpp::error err;
        uint32_t n = MAX_COMPUTERNAME_LENGTH + 1;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n);
        auto e = GetComputerName(& b[0], & n);
        if(e != nullptr)
        {
            return {""s, e};
        }
        return {UTF16ToString(b.make_slice(0, n)), nullptr};
    }

    struct gocpp::error Ftruncate(golang::syscall::Handle fd, int64_t length)
    {
        gocpp::Defer defer;
        try
        {
            struct gocpp::error err;
            auto [curoffset, e] = Seek(fd, 0, 1);
            if(e != nullptr)
            {
                return e;
            }
            defer.push_back([=]{ Seek(fd, curoffset, 0); });
            std::tie(gocpp_id_8, e) = Seek(fd, length, 0);
            if(e != nullptr)
            {
                return e;
            }
            e = SetEndOfFile(fd);
            if(e != nullptr)
            {
                return e;
            }
            return nullptr;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error Gettimeofday(struct Timeval* tv)
    {
        struct gocpp::error err;
        Filetime ft = {};
        GetSystemTimeAsFileTime(& ft);
        *tv = NsecToTimeval(rec::Nanoseconds(gocpp::recv(ft)));
        return nullptr;
    }

    struct gocpp::error Pipe(gocpp::slice<golang::syscall::Handle> p)
    {
        struct gocpp::error err;
        if(len(p) != 2)
        {
            return go_EINVAL;
        }
        syscall::Handle r = {};
        syscall::Handle w = {};
        auto e = CreatePipe(& r, & w, makeInheritSa(), 0);
        if(e != nullptr)
        {
            return e;
        }
        p[0] = r;
        p[1] = w;
        return nullptr;
    }

    struct gocpp::error Utimes(std::string path, gocpp::slice<Timeval> tv)
    {
        gocpp::Defer defer;
        try
        {
            struct gocpp::error err;
            if(len(tv) != 2)
            {
                return go_EINVAL;
            }
            auto [pathp, e] = UTF16PtrFromString(path);
            if(e != nullptr)
            {
                return e;
            }
            Handle h;
            std::tie(h, e) = CreateFile(pathp, FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
            if(e != nullptr)
            {
                return e;
            }
            defer.push_back([=]{ Close(h); });
            auto a = Filetime {};
            auto w = Filetime {};
            if(rec::Nanoseconds(gocpp::recv(tv[0])) != 0)
            {
                a = NsecToFiletime(rec::Nanoseconds(gocpp::recv(tv[0])));
            }
            if(rec::Nanoseconds(gocpp::recv(tv[0])) != 0)
            {
                w = NsecToFiletime(rec::Nanoseconds(gocpp::recv(tv[1])));
            }
            return SetFileTime(h, nullptr, & a, & w);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // This matches the value in os/file_windows.go.
    struct gocpp::error UtimesNano(std::string path, gocpp::slice<Timespec> ts)
    {
        gocpp::Defer defer;
        try
        {
            struct gocpp::error err;
            if(len(ts) != 2)
            {
                return go_EINVAL;
            }
            auto [pathp, e] = UTF16PtrFromString(path);
            if(e != nullptr)
            {
                return e;
            }
            Handle h;
            std::tie(h, e) = CreateFile(pathp, FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
            if(e != nullptr)
            {
                return e;
            }
            defer.push_back([=]{ Close(h); });
            auto a = Filetime {};
            auto w = Filetime {};
            if(ts[0].Nsec != _UTIME_OMIT)
            {
                a = NsecToFiletime(TimespecToNsec(ts[0]));
            }
            if(ts[1].Nsec != _UTIME_OMIT)
            {
                w = NsecToFiletime(TimespecToNsec(ts[1]));
            }
            return SetFileTime(h, nullptr, & a, & w);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error Fsync(golang::syscall::Handle fd)
    {
        struct gocpp::error err;
        return FlushFileBuffers(fd);
    }

    struct gocpp::error Chmod(std::string path, uint32_t mode)
    {
        struct gocpp::error err;
        auto [p, e] = UTF16PtrFromString(path);
        if(e != nullptr)
        {
            return e;
        }
        uint32_t attrs;
        std::tie(attrs, e) = GetFileAttributes(p);
        if(e != nullptr)
        {
            return e;
        }
        if(mode & S_IWRITE != 0)
        {
            attrs &^= FILE_ATTRIBUTE_READONLY;
        }
        else
        {
            attrs |= FILE_ATTRIBUTE_READONLY;
        }
        return SetFileAttributes(p, attrs);
    }

    struct gocpp::error LoadCancelIoEx()
    {
        return rec::Find(gocpp::recv(procCancelIoEx));
    }

    struct gocpp::error LoadSetFileCompletionNotificationModes()
    {
        return rec::Find(gocpp::recv(procSetFileCompletionNotificationModes));
    }

    // For testing: clients can set this flag to force
    // creation of IPv6 sockets to return EAFNOSUPPORT.
    bool SocketDisableIPv6;
    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrInet4::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Port = this->Port;
        result.Addr = this->Addr;
        result.Zero = this->Zero;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrInet4::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Port != ref.Port) return false;
        if (Addr != ref.Addr) return false;
        if (Zero != ref.Zero) return false;
        return true;
    }

    std::ostream& RawSockaddrInet4::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Port;
        os << " " << Addr;
        os << " " << Zero;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrInet4& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrInet6::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Port = this->Port;
        result.Flowinfo = this->Flowinfo;
        result.Addr = this->Addr;
        result.Scope_id = this->Scope_id;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrInet6::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Port != ref.Port) return false;
        if (Flowinfo != ref.Flowinfo) return false;
        if (Addr != ref.Addr) return false;
        if (Scope_id != ref.Scope_id) return false;
        return true;
    }

    std::ostream& RawSockaddrInet6::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Port;
        os << " " << Flowinfo;
        os << " " << Addr;
        os << " " << Scope_id;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrInet6& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddr::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Data = this->Data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddr::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Data != ref.Data) return false;
        return true;
    }

    std::ostream& RawSockaddr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddr& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrAny::operator T()
    {
        T result;
        result.Addr = this->Addr;
        result.Pad = this->Pad;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrAny::operator==(const T& ref) const
    {
        if (Addr != ref.Addr) return false;
        if (Pad != ref.Pad) return false;
        return true;
    }

    std::ostream& RawSockaddrAny::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Addr;
        os << " " << Pad;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrAny& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Sockaddr::Sockaddr(T& ref)
    {
        value.reset(new SockaddrImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Sockaddr::Sockaddr(const T& ref)
    {
        value.reset(new SockaddrImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Sockaddr::Sockaddr(T* ptr)
    {
        value.reset(new SockaddrImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Sockaddr::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<unsafe::Pointer, int32_t, struct gocpp::error> Sockaddr::SockaddrImpl<T, StoreT>::vsockaddr()
    {
        return rec::sockaddr(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::tuple<unsafe::Pointer, int32_t, struct gocpp::error> sockaddr(const gocpp::PtrRecv<struct Sockaddr, false>& self)
        {
            return self.ptr->value->vsockaddr();
        }

        std::tuple<unsafe::Pointer, int32_t, struct gocpp::error> sockaddr(const gocpp::ObjRecv<struct Sockaddr>& self)
        {
            return self.obj.value->vsockaddr();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Sockaddr& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SockaddrInet4::operator T()
    {
        T result;
        result.Port = this->Port;
        result.Addr = this->Addr;
        result.raw = this->raw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SockaddrInet4::operator==(const T& ref) const
    {
        if (Port != ref.Port) return false;
        if (Addr != ref.Addr) return false;
        if (raw != ref.raw) return false;
        return true;
    }

    std::ostream& SockaddrInet4::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Port;
        os << " " << Addr;
        os << " " << raw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SockaddrInet4& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<unsafe::Pointer, int32_t, struct gocpp::error> rec::sockaddr(struct SockaddrInet4* sa)
    {
        if(sa->Port < 0 || sa->Port > 0xFFFF)
        {
            return {nullptr, 0, go_EINVAL};
        }
        sa->raw.Family = AF_INET;
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& sa->raw.Port));
        p[0] = (unsigned char)(sa->Port >> 8);
        p[1] = (unsigned char)(sa->Port);
        sa->raw.Addr = sa->Addr;
        return {unsafe::Pointer(& sa->raw), int32_t(gocpp::Sizeof<RawSockaddrInet4>()), nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SockaddrInet6::operator T()
    {
        T result;
        result.Port = this->Port;
        result.ZoneId = this->ZoneId;
        result.Addr = this->Addr;
        result.raw = this->raw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SockaddrInet6::operator==(const T& ref) const
    {
        if (Port != ref.Port) return false;
        if (ZoneId != ref.ZoneId) return false;
        if (Addr != ref.Addr) return false;
        if (raw != ref.raw) return false;
        return true;
    }

    std::ostream& SockaddrInet6::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Port;
        os << " " << ZoneId;
        os << " " << Addr;
        os << " " << raw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SockaddrInet6& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<unsafe::Pointer, int32_t, struct gocpp::error> rec::sockaddr(struct SockaddrInet6* sa)
    {
        if(sa->Port < 0 || sa->Port > 0xFFFF)
        {
            return {nullptr, 0, go_EINVAL};
        }
        sa->raw.Family = AF_INET6;
        auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& sa->raw.Port));
        p[0] = (unsigned char)(sa->Port >> 8);
        p[1] = (unsigned char)(sa->Port);
        sa->raw.Scope_id = sa->ZoneId;
        sa->raw.Addr = sa->Addr;
        return {unsafe::Pointer(& sa->raw), int32_t(gocpp::Sizeof<RawSockaddrInet6>()), nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RawSockaddrUnix::operator T()
    {
        T result;
        result.Family = this->Family;
        result.Path = this->Path;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RawSockaddrUnix::operator==(const T& ref) const
    {
        if (Family != ref.Family) return false;
        if (Path != ref.Path) return false;
        return true;
    }

    std::ostream& RawSockaddrUnix::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Family;
        os << " " << Path;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrUnix& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    SockaddrUnix::operator T()
    {
        T result;
        result.Name = this->Name;
        result.raw = this->raw;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SockaddrUnix::operator==(const T& ref) const
    {
        if (Name != ref.Name) return false;
        if (raw != ref.raw) return false;
        return true;
    }

    std::ostream& SockaddrUnix::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << raw;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SockaddrUnix& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<unsafe::Pointer, int32_t, struct gocpp::error> rec::sockaddr(struct SockaddrUnix* sa)
    {
        auto name = sa->Name;
        auto n = len(name);
        if(n > len(sa->raw.Path))
        {
            return {nullptr, 0, go_EINVAL};
        }
        if(n == len(sa->raw.Path) && name[0] != '@')
        {
            return {nullptr, 0, go_EINVAL};
        }
        sa->raw.Family = AF_UNIX;
        for(auto i = 0; i < n; i++)
        {
            sa->raw.Path[i] = int8_t(name[i]);
        }
        auto sl = int32_t(2);
        if(n > 0)
        {
            sl += int32_t(n) + 1;
        }
        if(sa->raw.Path[0] == '@' || (sa->raw.Path[0] == 0 && sl > 3))
        {
            sa->raw.Path[0] = 0;
            sl--;
        }
        return {unsafe::Pointer(& sa->raw), sl, nullptr};
    }

    std::tuple<struct Sockaddr, struct gocpp::error> rec::Sockaddr(struct RawSockaddrAny* rsa)
    {
        //Go switch emulation
        {
            auto condition = rsa->Addr.Family;
            int conditionId = -1;
            if(condition == AF_UNIX) { conditionId = 0; }
            else if(condition == AF_INET) { conditionId = 1; }
            else if(condition == AF_INET6) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    auto pp = (RawSockaddrUnix*)(unsafe::Pointer(rsa));
                    auto sa = new(SockaddrUnix);
                    if(pp->Path[0] == 0)
                    {
                        pp->Path[0] = '@';
                    }
                    auto n = 0;
                    for(; n < len(pp->Path) && pp->Path[n] != 0; )
                    {
                        n++;
                    }
                    sa->Name = std::string(unsafe::Slice((unsigned char*)(unsafe::Pointer(& pp->Path[0])), n));
                    return {sa, nullptr};
                    break;
                case 1:
                    auto pp = (RawSockaddrInet4*)(unsafe::Pointer(rsa));
                    auto sa = new(SockaddrInet4);
                    auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& pp->Port));
                    sa->Port = (int(p[0]) << 8) + int(p[1]);
                    sa->Addr = pp->Addr;
                    return {sa, nullptr};
                    break;
                case 2:
                    auto pp = (RawSockaddrInet6*)(unsafe::Pointer(rsa));
                    auto sa = new(SockaddrInet6);
                    auto p = (gocpp::array<unsigned char, 2>*)(unsafe::Pointer(& pp->Port));
                    sa->Port = (int(p[0]) << 8) + int(p[1]);
                    sa->ZoneId = pp->Scope_id;
                    sa->Addr = pp->Addr;
                    return {sa, nullptr};
                    break;
            }
        }
        return {nullptr, go_EAFNOSUPPORT};
    }

    std::tuple<syscall::Handle, struct gocpp::error> Socket(int domain, int typ, int proto)
    {
        syscall::Handle fd;
        struct gocpp::error err;
        if(domain == AF_INET6 && SocketDisableIPv6)
        {
            return {InvalidHandle, go_EAFNOSUPPORT};
        }
        return socket(int32_t(domain), int32_t(typ), int32_t(proto));
    }

    struct gocpp::error SetsockoptInt(golang::syscall::Handle fd, int level, int opt, int value)
    {
        struct gocpp::error err;
        auto v = int32_t(value);
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(& v)), int32_t(gocpp::Sizeof<int32_t>()));
    }

    struct gocpp::error Bind(golang::syscall::Handle fd, struct Sockaddr sa)
    {
        struct gocpp::error err;
        unsafe::Pointer ptr;
        int32_t n;
        std::tie(ptr, n, err) = rec::sockaddr(gocpp::recv(sa));
        if(err != nullptr)
        {
            return err;
        }
        return bind(fd, ptr, n);
    }

    struct gocpp::error Connect(golang::syscall::Handle fd, struct Sockaddr sa)
    {
        struct gocpp::error err;
        unsafe::Pointer ptr;
        int32_t n;
        std::tie(ptr, n, err) = rec::sockaddr(gocpp::recv(sa));
        if(err != nullptr)
        {
            return err;
        }
        return connect(fd, ptr, n);
    }

    std::tuple<struct Sockaddr, struct gocpp::error> Getsockname(golang::syscall::Handle fd)
    {
        struct Sockaddr sa;
        struct gocpp::error err;
        RawSockaddrAny rsa = {};
        auto l = int32_t(gocpp::Sizeof<RawSockaddrAny>());
        if(err = getsockname(fd, & rsa, & l); err != nullptr)
        {
            return {sa, err};
        }
        return rec::Sockaddr(gocpp::recv(rsa));
    }

    std::tuple<struct Sockaddr, struct gocpp::error> Getpeername(golang::syscall::Handle fd)
    {
        struct Sockaddr sa;
        struct gocpp::error err;
        RawSockaddrAny rsa = {};
        auto l = int32_t(gocpp::Sizeof<RawSockaddrAny>());
        if(err = getpeername(fd, & rsa, & l); err != nullptr)
        {
            return {sa, err};
        }
        return rec::Sockaddr(gocpp::recv(rsa));
    }

    struct gocpp::error Listen(golang::syscall::Handle s, int n)
    {
        struct gocpp::error err;
        return listen(s, int32_t(n));
    }

    struct gocpp::error Shutdown(golang::syscall::Handle fd, int how)
    {
        struct gocpp::error err;
        return shutdown(fd, int32_t(how));
    }

    struct gocpp::error WSASendto(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct Sockaddr to, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        unsafe::Pointer rsa = {};
        int32_t len = {};
        if(to != nullptr)
        {
            std::tie(rsa, len, err) = rec::sockaddr(gocpp::recv(to));
            if(err != nullptr)
            {
                return err;
            }
        }
        auto [r1, gocpp_id_10, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(len), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            if(e1 != 0)
            {
                err = errnoErr(e1);
            }
            else
            {
                err = go_EINVAL;
            }
        }
        return err;
    }

    struct gocpp::error wsaSendtoInet4(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct SockaddrInet4* to, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        unsafe::Pointer rsa;
        int32_t len;
        std::tie(rsa, len, err) = rec::sockaddr(gocpp::recv(to));
        if(err != nullptr)
        {
            return err;
        }
        auto [r1, gocpp_id_12, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(len), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            if(e1 != 0)
            {
                err = errnoErr(e1);
            }
            else
            {
                err = go_EINVAL;
            }
        }
        return err;
    }

    struct gocpp::error wsaSendtoInet6(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct SockaddrInet6* to, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        unsafe::Pointer rsa;
        int32_t len;
        std::tie(rsa, len, err) = rec::sockaddr(gocpp::recv(to));
        if(err != nullptr)
        {
            return err;
        }
        auto [r1, gocpp_id_14, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(unsafe::Pointer(bufs)), uintptr_t(bufcnt), uintptr_t(unsafe::Pointer(sent)), uintptr_t(flags), uintptr_t(unsafe::Pointer(rsa)), uintptr_t(len), uintptr_t(unsafe::Pointer(overlapped)), uintptr_t(unsafe::Pointer(croutine)));
        if(r1 == socket_error)
        {
            if(e1 != 0)
            {
                err = errnoErr(e1);
            }
            else
            {
                err = go_EINVAL;
            }
        }
        return err;
    }

    struct gocpp::error LoadGetAddrInfo()
    {
        return rec::Find(gocpp::recv(procGetAddrInfoW));
    }

    struct gocpp_id_15
    {
        sync::Once once;
        uintptr_t addr;
        gocpp::error err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.once = this->once;
            result.addr = this->addr;
            result.err = this->err;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (once != ref.once) return false;
            if (addr != ref.addr) return false;
            if (err != ref.err) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << once;
            os << " " << addr;
            os << " " << err;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_15& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_15 connectExFunc;
    struct gocpp::error LoadConnectEx()
    {
        rec::Do(gocpp::recv(connectExFunc.once), [=]() mutable -> void
        {
            gocpp::Defer defer;
            try
            {
                syscall::Handle s = {};
                std::tie(s, connectExFunc.err) = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if(connectExFunc.err != nullptr)
                {
                    return;
                }
                defer.push_back([=]{ CloseHandle(s); });
                uint32_t n = {};
                connectExFunc.err = WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, (unsigned char*)(unsafe::Pointer(& WSAID_CONNECTEX)), uint32_t(gocpp::Sizeof<GUID>()), (unsigned char*)(unsafe::Pointer(& connectExFunc.addr)), uint32_t(gocpp::Sizeof<uintptr_t>()), & n, nullptr, 0);
            }
            catch(gocpp::GoPanic& gp)
            {
                defer.handlePanic(gp);
            }
        });
        return connectExFunc.err;
    }

    struct gocpp::error connectEx(golang::syscall::Handle s, unsafe::Pointer name, int32_t namelen, unsigned char* sendBuf, uint32_t sendDataLen, uint32_t* bytesSent, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_17, e1] = Syscall9(connectExFunc.addr, 7, uintptr_t(s), uintptr_t(name), uintptr_t(namelen), uintptr_t(unsafe::Pointer(sendBuf)), uintptr_t(sendDataLen), uintptr_t(unsafe::Pointer(bytesSent)), uintptr_t(unsafe::Pointer(overlapped)), 0, 0);
        if(r1 == 0)
        {
            if(e1 != 0)
            {
                err = error(e1);
            }
            else
            {
                err = go_EINVAL;
            }
        }
        return err;
    }

    struct gocpp::error ConnectEx(golang::syscall::Handle fd, struct Sockaddr sa, unsigned char* sendBuf, uint32_t sendDataLen, uint32_t* bytesSent, struct Overlapped* overlapped)
    {
        auto err = LoadConnectEx();
        if(err != nullptr)
        {
            return errorspkg::New("failed to find ConnectEx: "s + rec::Error(gocpp::recv(err)));
        }
        unsafe::Pointer ptr;
        int32_t n;
        std::tie(ptr, n, err) = rec::sockaddr(gocpp::recv(sa));
        if(err != nullptr)
        {
            return err;
        }
        return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped);
    }

    // Invented structures to support what package os expects.
    
    template<typename T> requires gocpp::GoStruct<T>
    Rusage::operator T()
    {
        T result;
        result.CreationTime = this->CreationTime;
        result.ExitTime = this->ExitTime;
        result.KernelTime = this->KernelTime;
        result.UserTime = this->UserTime;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rusage::operator==(const T& ref) const
    {
        if (CreationTime != ref.CreationTime) return false;
        if (ExitTime != ref.ExitTime) return false;
        if (KernelTime != ref.KernelTime) return false;
        if (UserTime != ref.UserTime) return false;
        return true;
    }

    std::ostream& Rusage::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << CreationTime;
        os << " " << ExitTime;
        os << " " << KernelTime;
        os << " " << UserTime;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rusage& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    WaitStatus::operator T()
    {
        T result;
        result.ExitCode = this->ExitCode;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool WaitStatus::operator==(const T& ref) const
    {
        if (ExitCode != ref.ExitCode) return false;
        return true;
    }

    std::ostream& WaitStatus::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ExitCode;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct WaitStatus& value)
    {
        return value.PrintTo(os);
    }

    bool rec::Exited(struct WaitStatus w)
    {
        return true;
    }

    int rec::ExitStatus(struct WaitStatus w)
    {
        return int(w.ExitCode);
    }

    syscall::Signal rec::Signal(struct WaitStatus w)
    {
        return - 1;
    }

    bool rec::CoreDump(struct WaitStatus w)
    {
        return false;
    }

    bool rec::Stopped(struct WaitStatus w)
    {
        return false;
    }

    bool rec::Continued(struct WaitStatus w)
    {
        return false;
    }

    syscall::Signal rec::StopSignal(struct WaitStatus w)
    {
        return - 1;
    }

    bool rec::Signaled(struct WaitStatus w)
    {
        return false;
    }

    int rec::TrapCause(struct WaitStatus w)
    {
        return - 1;
    }

    // Timespec is an invented structure on Windows, but here for
    // consistency with the syscall package for other operating systems.
    
    template<typename T> requires gocpp::GoStruct<T>
    Timespec::operator T()
    {
        T result;
        result.Sec = this->Sec;
        result.Nsec = this->Nsec;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Timespec::operator==(const T& ref) const
    {
        if (Sec != ref.Sec) return false;
        if (Nsec != ref.Nsec) return false;
        return true;
    }

    std::ostream& Timespec::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Sec;
        os << " " << Nsec;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Timespec& value)
    {
        return value.PrintTo(os);
    }

    int64_t TimespecToNsec(struct Timespec ts)
    {
        return int64_t(ts.Sec) * 1e9 + int64_t(ts.Nsec);
    }

    struct Timespec NsecToTimespec(int64_t nsec)
    {
        struct Timespec ts;
        ts.Sec = nsec / 1e9;
        ts.Nsec = nsec % 1e9;
        return ts;
    }

    std::tuple<syscall::Handle, struct Sockaddr, struct gocpp::error> Accept(golang::syscall::Handle fd)
    {
        syscall::Handle nfd;
        struct Sockaddr sa;
        struct gocpp::error err;
        return {0, nullptr, go_EWINDOWS};
    }

    std::tuple<int, struct Sockaddr, struct gocpp::error> Recvfrom(golang::syscall::Handle fd, gocpp::slice<unsigned char> p, int flags)
    {
        int n;
        struct Sockaddr from;
        struct gocpp::error err;
        return {0, nullptr, go_EWINDOWS};
    }

    struct gocpp::error Sendto(golang::syscall::Handle fd, gocpp::slice<unsigned char> p, int flags, struct Sockaddr to)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    struct gocpp::error SetsockoptTimeval(golang::syscall::Handle fd, int level, int opt, struct Timeval* tv)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Linger::operator T()
    {
        T result;
        result.Onoff = this->Onoff;
        result.Linger = this->Linger;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Linger::operator==(const T& ref) const
    {
        if (Onoff != ref.Onoff) return false;
        if (Linger != ref.Linger) return false;
        return true;
    }

    std::ostream& Linger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Onoff;
        os << " " << Linger;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Linger& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    sysLinger::operator T()
    {
        T result;
        result.Onoff = this->Onoff;
        result.Linger = this->Linger;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sysLinger::operator==(const T& ref) const
    {
        if (Onoff != ref.Onoff) return false;
        if (Linger != ref.Linger) return false;
        return true;
    }

    std::ostream& sysLinger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Onoff;
        os << " " << Linger;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sysLinger& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IPMreq::operator T()
    {
        T result;
        result.Multiaddr = this->Multiaddr;
        result.Interface = this->Interface;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IPMreq::operator==(const T& ref) const
    {
        if (Multiaddr != ref.Multiaddr) return false;
        if (Interface != ref.Interface) return false;
        return true;
    }

    std::ostream& IPMreq::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Multiaddr;
        os << " " << Interface;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IPMreq& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    IPv6Mreq::operator T()
    {
        T result;
        result.Multiaddr = this->Multiaddr;
        result.Interface = this->Interface;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool IPv6Mreq::operator==(const T& ref) const
    {
        if (Multiaddr != ref.Multiaddr) return false;
        if (Interface != ref.Interface) return false;
        return true;
    }

    std::ostream& IPv6Mreq::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Multiaddr;
        os << " " << Interface;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct IPv6Mreq& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> GetsockoptInt(golang::syscall::Handle fd, int level, int opt)
    {
        return {- 1, go_EWINDOWS};
    }

    struct gocpp::error SetsockoptLinger(golang::syscall::Handle fd, int level, int opt, struct Linger* l)
    {
        struct gocpp::error err;
        auto sys = gocpp::Init<sysLinger>([=](auto& x) {
            x.Onoff = uint16_t(l->Onoff);
            x.Linger = uint16_t(l->Linger);
        });
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(& sys)), int32_t(gocpp::Sizeof<sysLinger>()));
    }

    struct gocpp::error SetsockoptInet4Addr(golang::syscall::Handle fd, int level, int opt, gocpp::array<unsigned char, 4> value)
    {
        struct gocpp::error err;
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(& value[0])), 4);
    }

    struct gocpp::error SetsockoptIPMreq(golang::syscall::Handle fd, int level, int opt, struct IPMreq* mreq)
    {
        struct gocpp::error err;
        return Setsockopt(fd, int32_t(level), int32_t(opt), (unsigned char*)(unsafe::Pointer(mreq)), int32_t(gocpp::Sizeof<IPMreq>()));
    }

    struct gocpp::error SetsockoptIPv6Mreq(golang::syscall::Handle fd, int level, int opt, struct IPv6Mreq* mreq)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    int Getpid()
    {
        int pid;
        return int(getCurrentProcessId());
    }

    std::tuple<syscall::Handle, struct gocpp::error> FindFirstFile(uint16_t* name, struct Win32finddata* data)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        // NOTE(rsc): The Win32finddata struct is wrong for the system call:
        // the two paths are each one uint16 short. Use the correct struct,
        // a win32finddata1, and then copy the results out.
        // There is no loss of expressivity here, because the final
        // uint16, if it is used, is supposed to be a NUL, and Go doesn't need that.
        // For Go 1.1, we might avoid the allocation of win32finddata1 here
        // by adding a final Bug [2]uint16 field to the struct and then
        // adjusting the fields in the result directly.
        win32finddata1 data1 = {};
        std::tie(handle, err) = findFirstFile1(name, & data1);
        if(err == nullptr)
        {
            copyFindData(data, & data1);
        }
        return {handle, err};
    }

    struct gocpp::error FindNextFile(golang::syscall::Handle handle, struct Win32finddata* data)
    {
        struct gocpp::error err;
        win32finddata1 data1 = {};
        err = findNextFile1(handle, & data1);
        if(err == nullptr)
        {
            copyFindData(data, & data1);
        }
        return err;
    }

    std::tuple<struct ProcessEntry32*, struct gocpp::error> getProcessEntry(int pid)
    {
        gocpp::Defer defer;
        try
        {
            auto [snapshot, err] = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ CloseHandle(snapshot); });
            ProcessEntry32 procEntry = {};
            procEntry.Size = uint32_t(gocpp::Sizeof<ProcessEntry32>());
            if(err = Process32First(snapshot, & procEntry); err != nullptr)
            {
                return {nullptr, err};
            }
            for(; ; )
            {
                if(procEntry.ProcessID == uint32_t(pid))
                {
                    return {& procEntry, nullptr};
                }
                err = Process32Next(snapshot, & procEntry);
                if(err != nullptr)
                {
                    return {nullptr, err};
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    int Getppid()
    {
        int ppid;
        auto [pe, err] = getProcessEntry(Getpid());
        if(err != nullptr)
        {
            return - 1;
        }
        return int(pe->ParentProcessID);
    }

    std::tuple<gocpp::slice<uint16_t>, struct gocpp::error> fdpath(golang::syscall::Handle fd, gocpp::slice<uint16_t> buf)
    {
        auto FILE_NAME_NORMALIZED = 0;
        auto VOLUME_NAME_DOS = 0;
        for(; ; )
        {
            auto [n, err] = getFinalPathNameByHandle(fd, & buf[0], uint32_t(len(buf)), FILE_NAME_NORMALIZED | VOLUME_NAME_DOS);
            if(err == nullptr)
            {
                buf = buf.make_slice(0, n);
                break;
            }
            if(err != _ERROR_NOT_ENOUGH_MEMORY)
            {
                return {nullptr, err};
            }
            buf = append(buf, gocpp::make(gocpp::Tag<gocpp::slice<uint16_t>>(), n - uint32_t(len(buf))));
        }
        return {buf, nullptr};
    }

    struct gocpp::error Fchdir(golang::syscall::Handle fd)
    {
        struct gocpp::error err;
        gocpp::array<uint16_t, MAX_PATH + 1> buf = {};
        gocpp::slice<uint16_t> path;
        std::tie(path, err) = fdpath(fd, buf.make_slice(0));
        if(err != nullptr)
        {
            return err;
        }
        if(len(path) >= 4 && path[0] == '\\' && path[1] == '\\' && path[2] == '?' && path[3] == '\\')
        {
            path = path.make_slice(4);
        }
        return SetCurrentDirectory(& path[0]);
    }

    // TODO(brainman): fix all needed for os
    struct gocpp::error Link(std::string oldpath, std::string newpath)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    struct gocpp::error Symlink(std::string path, std::string link)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    struct gocpp::error Fchmod(golang::syscall::Handle fd, uint32_t mode)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    struct gocpp::error Chown(std::string path, int uid, int gid)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    struct gocpp::error Lchown(std::string path, int uid, int gid)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    struct gocpp::error Fchown(golang::syscall::Handle fd, int uid, int gid)
    {
        struct gocpp::error err;
        return go_EWINDOWS;
    }

    int Getuid()
    {
        int uid;
        return - 1;
    }

    int Geteuid()
    {
        int euid;
        return - 1;
    }

    int Getgid()
    {
        int gid;
        return - 1;
    }

    int Getegid()
    {
        int egid;
        return - 1;
    }

    std::tuple<gocpp::slice<int>, struct gocpp::error> Getgroups()
    {
        gocpp::slice<int> gids;
        struct gocpp::error err;
        return {nullptr, go_EWINDOWS};
    }

    void rec::Signal(golang::syscall::Signal s)
    {
    }

    std::string rec::String(golang::syscall::Signal s)
    {
        if(0 <= s && int(s) < len(signals))
        {
            auto str = signals[s];
            if(str != ""s)
            {
                return str;
            }
        }
        return "signal "s + itoa::Itoa(int(s));
    }

    struct gocpp::error LoadCreateSymbolicLink()
    {
        return rec::Find(gocpp::recv(procCreateSymbolicLinkW));
    }

    // Readlink returns the destination of the named symbolic link.
    std::tuple<int, struct gocpp::error> Readlink(std::string path, gocpp::slice<unsigned char> buf)
    {
        gocpp::Defer defer;
        try
        {
            int n;
            struct gocpp::error err;
            Handle fd;
            std::tie(fd, err) = CreateFile(StringToUTF16Ptr(path), GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, 0);
            if(err != nullptr)
            {
                return {- 1, err};
            }
            defer.push_back([=]{ CloseHandle(fd); });
            auto rdbbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
            uint32_t bytesReturned = {};
            err = DeviceIoControl(fd, FSCTL_GET_REPARSE_POINT, nullptr, 0, & rdbbuf[0], uint32_t(len(rdbbuf)), & bytesReturned, nullptr);
            if(err != nullptr)
            {
                return {- 1, err};
            }
            auto rdb = (reparseDataBuffer*)(unsafe::Pointer(& rdbbuf[0]));
            std::string s = {};
            //Go switch emulation
            {
                auto condition = rdb->ReparseTag;
                int conditionId = -1;
                if(condition == IO_REPARSE_TAG_SYMLINK) { conditionId = 0; }
                else if(condition == _IO_REPARSE_TAG_MOUNT_POINT) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        auto data = (symbolicLinkReparseBuffer*)(unsafe::Pointer(& rdb->reparseBuffer));
                        auto p = (gocpp::array<uint16_t, 0xffff>*)(unsafe::Pointer(& data->PathBuffer[0]));
                        s = UTF16ToString(p.make_slice(data->SubstituteNameOffset / 2, (data->SubstituteNameOffset + data->SubstituteNameLength) / 2));
                        if(data->Flags & _SYMLINK_FLAG_RELATIVE == 0)
                        {
                            if(len(s) >= 4 && s.make_slice(0, 4) == "\\??\\"s)
                            {
                                s = s.make_slice(4);
                                //Go switch emulation
                                {
                                    int conditionId = -1;
                                    if(len(s) >= 2 && s[1] == ':') { conditionId = 0; }
                                    else if(len(s) >= 4 && s.make_slice(0, 4) == "UNC\\"s) { conditionId = 1; }
                                    switch(conditionId)
                                    {
                                        case 0:
                                            break;
                                        case 1:
                                            s = "\\\\"s + s.make_slice(4);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                            else
                            {
                            }
                        }
                        break;
                    case 1:
                        auto data = (mountPointReparseBuffer*)(unsafe::Pointer(& rdb->reparseBuffer));
                        auto p = (gocpp::array<uint16_t, 0xffff>*)(unsafe::Pointer(& data->PathBuffer[0]));
                        s = UTF16ToString(p.make_slice(data->SubstituteNameOffset / 2, (data->SubstituteNameOffset + data->SubstituteNameLength) / 2));
                        if(len(s) >= 4 && s.make_slice(0, 4) == "\\??\\"s)
                        {
                            s = s.make_slice(4);
                        }
                        else
                        {
                        }
                        break;
                    default:
                        return {- 1, go_ENOENT};
                        break;
                }
            }
            n = copy(buf, gocpp::slice<unsigned char>(s));
            return {n, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // Deprecated: CreateIoCompletionPort has the wrong function signature. Use x/sys/windows.CreateIoCompletionPort.
    std::tuple<syscall::Handle, struct gocpp::error> CreateIoCompletionPort(golang::syscall::Handle filehandle, golang::syscall::Handle cphandle, uint32_t key, uint32_t threadcnt)
    {
        return createIoCompletionPort(filehandle, cphandle, uintptr_t(key), threadcnt);
    }

    // Deprecated: GetQueuedCompletionStatus has the wrong function signature. Use x/sys/windows.GetQueuedCompletionStatus.
    struct gocpp::error GetQueuedCompletionStatus(golang::syscall::Handle cphandle, uint32_t* qty, uint32_t* key, struct Overlapped** overlapped, uint32_t timeout)
    {
        uintptr_t ukey = {};
        uintptr_t* pukey = {};
        if(key != nullptr)
        {
            ukey = uintptr_t(*key);
            pukey = & ukey;
        }
        auto err = getQueuedCompletionStatus(cphandle, qty, pukey, overlapped, timeout);
        if(key != nullptr)
        {
            *key = uint32_t(ukey);
            if(uintptr_t(*key) != ukey && err == nullptr)
            {
                err = errorspkg::New("GetQueuedCompletionStatus returned key overflow"s);
            }
        }
        return err;
    }

    // Deprecated: PostQueuedCompletionStatus has the wrong function signature. Use x/sys/windows.PostQueuedCompletionStatus.
    struct gocpp::error PostQueuedCompletionStatus(golang::syscall::Handle cphandle, uint32_t qty, uint32_t key, struct Overlapped* overlapped)
    {
        return postQueuedCompletionStatus(cphandle, qty, uintptr_t(key), overlapped);
    }

    // newProcThreadAttributeList allocates new PROC_THREAD_ATTRIBUTE_LIST, with
    // the requested maximum number of attributes, which must be cleaned up by
    // deleteProcThreadAttributeList.
    std::tuple<struct _PROC_THREAD_ATTRIBUTE_LIST*, struct gocpp::error> newProcThreadAttributeList(uint32_t maxAttrCount)
    {
        uintptr_t size = {};
        auto err = initializeProcThreadAttributeList(nullptr, maxAttrCount, 0, & size);
        if(err != ERROR_INSUFFICIENT_BUFFER)
        {
            if(err == nullptr)
            {
                return {nullptr, errorspkg::New("unable to query buffer size from InitializeProcThreadAttributeList"s)};
            }
            return {nullptr, err};
        }
        auto al = (_PROC_THREAD_ATTRIBUTE_LIST*)(unsafe::Pointer(& gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size)[0]));
        err = initializeProcThreadAttributeList(al, maxAttrCount, 0, & size);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {al, nullptr};
    }

    // RegEnumKeyEx enumerates the subkeys of an open registry key.
    // Each call retrieves information about one subkey. name is
    // a buffer that should be large enough to hold the name of the
    // subkey plus a null terminating character. nameLen is its
    // length. On return, nameLen will contain the actual length of the
    // subkey.
    //
    // Should name not be large enough to hold the subkey, this function
    // will return ERROR_MORE_DATA, and must be called again with an
    // appropriately sized buffer.
    //
    // reserved must be nil. class and classLen behave like name and nameLen
    // but for the class of the subkey, except that they are optional.
    // lastWriteTime, if not nil, will be populated with the time the subkey
    // was last written.
    //
    // The caller must enumerate all subkeys in order. That is
    // RegEnumKeyEx must be called with index starting at 0, incrementing
    // the index until the function returns ERROR_NO_MORE_ITEMS, or with
    // the index of the last subkey (obtainable from RegQueryInfoKey),
    // decrementing until index 0 is enumerated.
    //
    // Successive calls to this API must happen on the same OS thread,
    // so call runtime.LockOSThread before calling this function.
    struct gocpp::error RegEnumKeyEx(golang::syscall::Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        return regEnumKeyEx(key, index, name, nameLen, reserved, go_class, classLen, lastWriteTime);
    }

    struct gocpp::error GetStartupInfo(struct StartupInfo* startupInfo)
    {
        getStartupInfo(startupInfo);
        return nullptr;
    }

}

