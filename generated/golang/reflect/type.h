// generated by GoCpp from file '$(ImportDir)/reflect/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/type.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/reflect/abi.h"
// #include "golang/reflect/value.h"  [Ignored, known errors]
#include "golang/sync/atomic/type.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"

namespace golang::reflect
{
    struct Type : gocpp::Interface
    {
        Type(){}
        Type(Type& i) = default;
        Type(const Type& i) = default;
        Type& operator=(Type& i) = default;
        Type& operator=(const Type& i) = default;

        template<typename T>
        Type(T& ref);

        template<typename T>
        Type(const T& ref);

        template<typename T>
        Type(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IType
        {
            virtual int vAlign() = 0;
            virtual int vFieldAlign() = 0;
            virtual struct Method vMethod(int) = 0;
            virtual std::tuple<struct Method, bool> vMethodByName(std::string) = 0;
            virtual int vNumMethod() = 0;
            virtual std::string vName() = 0;
            virtual std::string vPkgPath() = 0;
            virtual uintptr_t vSize() = 0;
            virtual std::string vString() = 0;
            virtual Kind vKind() = 0;
            virtual bool vImplements(struct Type u) = 0;
            virtual bool vAssignableTo(struct Type u) = 0;
            virtual bool vConvertibleTo(struct Type u) = 0;
            virtual bool vComparable() = 0;
            virtual int vBits() = 0;
            virtual ChanDir vChanDir() = 0;
            virtual bool vIsVariadic() = 0;
            virtual struct Type vElem() = 0;
            virtual struct StructField vField(int i) = 0;
            virtual struct StructField vFieldByIndex(gocpp::slice<int> index) = 0;
            virtual std::tuple<struct StructField, bool> vFieldByName(std::string name) = 0;
            virtual std::tuple<struct StructField, bool> vFieldByNameFunc(std::function<bool (std::string)> match) = 0;
            virtual struct Type vIn(int i) = 0;
            virtual struct Type vKey() = 0;
            virtual int vLen() = 0;
            virtual int vNumField() = 0;
            virtual int vNumIn() = 0;
            virtual int vNumOut() = 0;
            virtual struct Type vOut(int i) = 0;
            virtual struct abi::Type* vcommon() = 0;
            virtual struct uncommonType* vuncommon() = 0;
        };

        template<typename T, typename StoreT>
        struct TypeImpl : IType
        {
            explicit TypeImpl(T* ptr)
            {
                value.reset(ptr);
            }

            int vAlign() override;

            int vFieldAlign() override;

            struct Method vMethod(int) override;

            std::tuple<struct Method, bool> vMethodByName(std::string) override;

            int vNumMethod() override;

            std::string vName() override;

            std::string vPkgPath() override;

            uintptr_t vSize() override;

            std::string vString() override;

            Kind vKind() override;

            bool vImplements(struct Type u) override;

            bool vAssignableTo(struct Type u) override;

            bool vConvertibleTo(struct Type u) override;

            bool vComparable() override;

            int vBits() override;

            ChanDir vChanDir() override;

            bool vIsVariadic() override;

            struct Type vElem() override;

            struct StructField vField(int i) override;

            struct StructField vFieldByIndex(gocpp::slice<int> index) override;

            std::tuple<struct StructField, bool> vFieldByName(std::string name) override;

            std::tuple<struct StructField, bool> vFieldByNameFunc(std::function<bool (std::string)> match) override;

            struct Type vIn(int i) override;

            struct Type vKey() override;

            int vLen() override;

            int vNumField() override;

            int vNumIn() override;

            int vNumOut() override;

            struct Type vOut(int i) override;

            struct abi::Type* vcommon() override;

            struct uncommonType* vuncommon() override;

            StoreT value;
        };

        std::shared_ptr<IType> value;
    };

    int Align(const gocpp::PtrRecv<Type, false>& self);
    int Align(const gocpp::ObjRecv<Type>& self);

    int FieldAlign(const gocpp::PtrRecv<Type, false>& self);
    int FieldAlign(const gocpp::ObjRecv<Type>& self);

    struct Method Method(const gocpp::PtrRecv<Type, false>& self, int);
    struct Method Method(const gocpp::ObjRecv<Type>& self, int);

    std::tuple<struct Method, bool> MethodByName(const gocpp::PtrRecv<Type, false>& self, std::string);
    std::tuple<struct Method, bool> MethodByName(const gocpp::ObjRecv<Type>& self, std::string);

    int NumMethod(const gocpp::PtrRecv<Type, false>& self);
    int NumMethod(const gocpp::ObjRecv<Type>& self);

    std::string Name(const gocpp::PtrRecv<Type, false>& self);
    std::string Name(const gocpp::ObjRecv<Type>& self);

    std::string PkgPath(const gocpp::PtrRecv<Type, false>& self);
    std::string PkgPath(const gocpp::ObjRecv<Type>& self);

    uintptr_t Size(const gocpp::PtrRecv<Type, false>& self);
    uintptr_t Size(const gocpp::ObjRecv<Type>& self);

    std::string String(const gocpp::PtrRecv<Type, false>& self);
    std::string String(const gocpp::ObjRecv<Type>& self);

    Kind Kind(const gocpp::PtrRecv<Type, false>& self);
    Kind Kind(const gocpp::ObjRecv<Type>& self);

    bool Implements(const gocpp::PtrRecv<Type, false>& self, struct Type u);
    bool Implements(const gocpp::ObjRecv<Type>& self, struct Type u);

    bool AssignableTo(const gocpp::PtrRecv<Type, false>& self, struct Type u);
    bool AssignableTo(const gocpp::ObjRecv<Type>& self, struct Type u);

    bool ConvertibleTo(const gocpp::PtrRecv<Type, false>& self, struct Type u);
    bool ConvertibleTo(const gocpp::ObjRecv<Type>& self, struct Type u);

    bool Comparable(const gocpp::PtrRecv<Type, false>& self);
    bool Comparable(const gocpp::ObjRecv<Type>& self);

    int Bits(const gocpp::PtrRecv<Type, false>& self);
    int Bits(const gocpp::ObjRecv<Type>& self);

    ChanDir ChanDir(const gocpp::PtrRecv<Type, false>& self);
    ChanDir ChanDir(const gocpp::ObjRecv<Type>& self);

    bool IsVariadic(const gocpp::PtrRecv<Type, false>& self);
    bool IsVariadic(const gocpp::ObjRecv<Type>& self);

    struct Type Elem(const gocpp::PtrRecv<Type, false>& self);
    struct Type Elem(const gocpp::ObjRecv<Type>& self);

    struct StructField Field(const gocpp::PtrRecv<Type, false>& self, int i);
    struct StructField Field(const gocpp::ObjRecv<Type>& self, int i);

    struct StructField FieldByIndex(const gocpp::PtrRecv<Type, false>& self, gocpp::slice<int> index);
    struct StructField FieldByIndex(const gocpp::ObjRecv<Type>& self, gocpp::slice<int> index);

    std::tuple<struct StructField, bool> FieldByName(const gocpp::PtrRecv<Type, false>& self, std::string name);
    std::tuple<struct StructField, bool> FieldByName(const gocpp::ObjRecv<Type>& self, std::string name);

    std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::PtrRecv<Type, false>& self, std::function<bool (std::string)> match);
    std::tuple<struct StructField, bool> FieldByNameFunc(const gocpp::ObjRecv<Type>& self, std::function<bool (std::string)> match);

    struct Type In(const gocpp::PtrRecv<Type, false>& self, int i);
    struct Type In(const gocpp::ObjRecv<Type>& self, int i);

    struct Type Key(const gocpp::PtrRecv<Type, false>& self);
    struct Type Key(const gocpp::ObjRecv<Type>& self);

    int Len(const gocpp::PtrRecv<Type, false>& self);
    int Len(const gocpp::ObjRecv<Type>& self);

    int NumField(const gocpp::PtrRecv<Type, false>& self);
    int NumField(const gocpp::ObjRecv<Type>& self);

    int NumIn(const gocpp::PtrRecv<Type, false>& self);
    int NumIn(const gocpp::ObjRecv<Type>& self);

    int NumOut(const gocpp::PtrRecv<Type, false>& self);
    int NumOut(const gocpp::ObjRecv<Type>& self);

    struct Type Out(const gocpp::PtrRecv<Type, false>& self, int i);
    struct Type Out(const gocpp::ObjRecv<Type>& self, int i);

    struct abi::Type* common(const gocpp::PtrRecv<Type, false>& self);
    struct abi::Type* common(const gocpp::ObjRecv<Type>& self);

    struct uncommonType* uncommon(const gocpp::PtrRecv<Type, false>& self);
    struct uncommonType* uncommon(const gocpp::ObjRecv<Type>& self);

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    struct common
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct common& value);
    struct rtype
    {
        abi::Type t;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct rtype& value);
    struct abi::Type* common(struct rtype* t);
    struct abi::UncommonType* uncommon(struct rtype* t);
    struct interfaceType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct interfaceType& value);
    struct abi::Name nameOff(struct interfaceType* t, aNameOff off);
    struct abi::Name nameOffFor(struct abi::Type* t, aNameOff off);
    struct abi::Type* typeOffFor(struct abi::Type* t, aTypeOff off);
    struct abi::Type* typeOff(struct interfaceType* t, aTypeOff off);
    struct abi::Type* common(struct interfaceType* t);
    struct abi::UncommonType* uncommon(struct interfaceType* t);
    struct mapType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapType& value);
    struct ptrType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ptrType& value);
    struct sliceType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sliceType& value);
    struct structType
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structType& value);
    std::string pkgPath(struct abi::Name n);
    struct abi::Name newName(std::string n, std::string tag, bool exported, bool embedded);
    struct Method
    {
        std::string Name;
        std::string PkgPath;
        Type Type;
        Value Func;
        int Index;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Method& value);
    bool IsExported(struct Method m);
    std::string String(Kind k);
    extern gocpp::slice<std::string> kindNames;
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off);
    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off);
    unsafe::Pointer resolveTextOff(unsafe::Pointer rtype, int32_t off);
    int32_t addReflectOff(unsafe::Pointer ptr);
    aNameOff resolveReflectName(struct abi::Name n);
    aTypeOff resolveReflectType(struct abi::Type* t);
    aTextOff resolveReflectText(unsafe::Pointer ptr);
    struct abi::Name nameOff(struct rtype* t, aNameOff off);
    struct abi::Type* typeOff(struct rtype* t, aTypeOff off);
    unsafe::Pointer textOff(struct rtype* t, aTextOff off);
    unsafe::Pointer textOffFor(struct abi::Type* t, aTextOff off);
    std::string String(struct rtype* t);
    uintptr_t Size(struct rtype* t);
    int Bits(struct rtype* t);
    int Align(struct rtype* t);
    int FieldAlign(struct rtype* t);
    Kind Kind(struct rtype* t);
    gocpp::slice<abi::Method> exportedMethods(struct rtype* t);
    int NumMethod(struct rtype* t);
    struct Method Method(struct rtype* t, int i);
    std::tuple<struct Method, bool> MethodByName(struct rtype* t, std::string name);
    std::string PkgPath(struct rtype* t);
    std::string pkgPathFor(struct abi::Type* t);
    std::string Name(struct rtype* t);
    std::string nameFor(struct abi::Type* t);
    ChanDir ChanDir(struct rtype* t);
    struct rtype* toRType(struct abi::Type* t);
    struct abi::Type* elem(struct abi::Type* t);
    struct Type Elem(struct rtype* t);
    struct StructField Field(struct rtype* t, int i);
    struct StructField FieldByIndex(struct rtype* t, gocpp::slice<int> index);
    std::tuple<struct StructField, bool> FieldByName(struct rtype* t, std::string name);
    std::tuple<struct StructField, bool> FieldByNameFunc(struct rtype* t, std::function<bool (std::string)> match);
    struct Type Key(struct rtype* t);
    int Len(struct rtype* t);
    int NumField(struct rtype* t);
    struct Type In(struct rtype* t, int i);
    int NumIn(struct rtype* t);
    int NumOut(struct rtype* t);
    struct Type Out(struct rtype* t, int i);
    bool IsVariadic(struct rtype* t);
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    std::string String(ChanDir d);
    struct Method Method(struct interfaceType* t, int i);
    int NumMethod(struct interfaceType* t);
    std::tuple<struct Method, bool> MethodByName(struct interfaceType* t, std::string name);
    struct StructField
    {
        std::string Name;
        std::string PkgPath;
        Type Type;
        StructTag Tag;
        uintptr_t Offset;
        gocpp::slice<int> Index;
        bool Anonymous;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructField& value);
    bool IsExported(struct StructField f);
    std::string Get(StructTag tag, std::string key);
    std::tuple<std::string, bool> Lookup(StructTag tag, std::string key);
    struct StructField Field(struct structType* t, int i);
    struct StructField FieldByIndex(struct structType* t, gocpp::slice<int> index);
    struct fieldScan
    {
        structType* typ;
        gocpp::slice<int> index;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct fieldScan& value);
    std::tuple<struct StructField, bool> FieldByNameFunc(struct structType* t, std::function<bool (std::string)> match);
    std::tuple<struct StructField, bool> FieldByName(struct structType* t, std::string name);
    struct Type TypeOf(go_any i);
    struct abi::Type* rtypeOf(go_any i);
    struct Type PtrTo(struct Type t);
    struct Type PointerTo(struct Type t);
    struct abi::Type* ptrTo(struct rtype* t);
    struct abi::Type* ptrTo(struct abi::Type* t);
    uint32_t fnv1(uint32_t x, gocpp::slice<unsigned char> list);

    template<typename... Args>
    uint32_t fnv1(uint32_t x, Args... list)
    {
        return fnv1(x, gocpp::ToSlice<unsigned char>(list...));
    }

    bool Implements(struct rtype* t, struct Type u);
    bool AssignableTo(struct rtype* t, struct Type u);
    bool ConvertibleTo(struct rtype* t, struct Type u);
    bool Comparable(struct rtype* t);
    bool implements(struct abi::Type* T, struct abi::Type* V);
    bool specialChannelAssignability(struct abi::Type* T, struct abi::Type* V);
    bool directlyAssignable(struct abi::Type* T, struct abi::Type* V);
    bool haveIdenticalType(struct abi::Type* T, struct abi::Type* V, bool cmpTags);
    bool haveIdenticalUnderlyingType(struct abi::Type* T, struct abi::Type* V, bool cmpTags);
    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> typelinks();
    struct abi::Type* rtypeOff(unsafe::Pointer section, int32_t off);
    gocpp::slice<abi::Type*> typesByString(std::string s);
    struct cacheKey
    {
        Kind kind;
        abi::Type* t1;
        abi::Type* t2;
        uintptr_t extra;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cacheKey& value);
    struct Type ChanOf(ChanDir dir, struct Type t);
    struct Type MapOf(struct Type key, struct Type elem);
    struct Type initFuncTypes(int n);
    struct Type FuncOf(gocpp::slice<Type> in, gocpp::slice<Type> out, bool variadic);
    std::string stringFor(struct abi::Type* t);
    std::string funcStr(struct funcType* ft);
    bool isReflexive(struct abi::Type* t);
    bool needKeyUpdate(struct abi::Type* t);
    bool hashMightPanic(struct abi::Type* t);
    struct abi::Type* bucketOf(struct abi::Type* ktyp, struct abi::Type* etyp);
    gocpp::slice<unsigned char> gcSlice(struct rtype* t, uintptr_t begin, uintptr_t end);
    void emitGCMask(gocpp::slice<unsigned char> out, uintptr_t base, struct abi::Type* typ, uintptr_t n);
    gocpp::slice<unsigned char> appendGCProg(gocpp::slice<unsigned char> dst, struct abi::Type* typ);
    struct Type SliceOf(struct Type t);
    struct structTypeUncommon
    {
        uncommonType u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value);
    bool isLetter(gocpp::rune ch);
    bool isValidFieldName(std::string fieldName);
    struct Type StructOf(gocpp::slice<StructField> fields);
    void embeddedIfaceMethStub();
    std::tuple<struct structField, std::string> runtimeStructField(struct StructField field);
    uintptr_t typeptrdata(struct abi::Type* t);
    struct Type ArrayOf(int length, struct Type elem);
    gocpp::slice<unsigned char> appendVarint(gocpp::slice<unsigned char> x, uintptr_t v);
    struct Type toType(struct abi::Type* t);
    struct layoutKey
    {
        funcType* ftyp;
        abi::Type* rcvr;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct layoutKey& value);
    struct layoutType
    {
        abi::Type* t;
        sync::Pool* framePool;
        abiDesc abid;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct layoutType& value);
    std::tuple<struct abi::Type*, struct sync::Pool*, struct abiDesc> funcLayout(struct funcType* t, struct abi::Type* rcvr);
    bool ifaceIndir(struct abi::Type* t);
    struct bitVector
    {
        uint32_t n;
        gocpp::slice<unsigned char> data;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bitVector& value);
    void append(struct bitVector* bv, uint8_t bit);
    void addTypeBits(struct bitVector* bv, uintptr_t offset, struct abi::Type* t);
    struct Type TypeFor();
}

