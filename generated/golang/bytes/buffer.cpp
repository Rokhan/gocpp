// generated by GoCpp from file '$(ImportDir)/bytes/buffer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bytes/buffer.h"
#include "gocpp/support.h"

#include "golang/bytes/bytes.h"
#include "golang/errors/errors.h"
#include "golang/io/io.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::bytes
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Read;
        using io::rec::Write;
    }

    // smallBufferSize is an initial allocation minimal capacity.
    // A Buffer is a variable-sized buffer of bytes with [Buffer.Read] and [Buffer.Write] methods.
    // The zero value for Buffer is an empty buffer ready to use.
    
    template<typename T> requires gocpp::GoStruct<T>
    Buffer::operator T()
    {
        T result;
        result.buf = this->buf;
        result.off = this->off;
        result.lastRead = this->lastRead;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Buffer::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (off != ref.off) return false;
        if (lastRead != ref.lastRead) return false;
        return true;
    }

    std::ostream& Buffer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << off;
        os << " " << lastRead;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Buffer& value)
    {
        return value.PrintTo(os);
    }

    // The readOp constants describe the last action performed on
    // the buffer, so that UnreadRune and UnreadByte can check for
    // invalid usage. opReadRuneX constants are chosen such that
    // converted to int they correspond to the rune size that was read.
    // Don't use iota for these, as the values need to correspond with the
    // names and comments, which is easier to see when being explicit.
    // ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.
    gocpp::error ErrTooLarge = errors::New("bytes.Buffer: too large"s);
    gocpp::error errNegativeRead = errors::New("bytes.Buffer: reader returned negative count from Read"s);
    // Bytes returns a slice of length b.Len() holding the unread portion of the buffer.
    // The slice is valid for use only until the next buffer modification (that is,
    // only until the next call to a method like [Buffer.Read], [Buffer.Write], [Buffer.Reset], or [Buffer.Truncate]).
    // The slice aliases the buffer content at least until the next buffer modification,
    // so immediate changes to the slice will affect the result of future reads.
    gocpp::slice<unsigned char> rec::Bytes(struct Buffer* b)
    {
        return b->buf.make_slice(b->off);
    }

    // AvailableBuffer returns an empty buffer with b.Available() capacity.
    // This buffer is intended to be appended to and
    // passed to an immediately succeeding [Buffer.Write] call.
    // The buffer is only valid until the next write operation on b.
    gocpp::slice<unsigned char> rec::AvailableBuffer(struct Buffer* b)
    {
        return b->buf.make_slice(len(b->buf));
    }

    // String returns the contents of the unread portion of the buffer
    // as a string. If the [Buffer] is a nil pointer, it returns "<nil>".
    //
    // To build strings more efficiently, see the strings.Builder type.
    std::string rec::String(struct Buffer* b)
    {
        if(b == nullptr)
        {
            return "<nil>"s;
        }
        return std::string(b->buf.make_slice(b->off));
    }

    // empty reports whether the unread portion of the buffer is empty.
    bool rec::empty(struct Buffer* b)
    {
        return len(b->buf) <= b->off;
    }

    // Len returns the number of bytes of the unread portion of the buffer;
    // b.Len() == len(b.Bytes()).
    int rec::Len(struct Buffer* b)
    {
        return len(b->buf) - b->off;
    }

    // Cap returns the capacity of the buffer's underlying byte slice, that is, the
    // total space allocated for the buffer's data.
    int rec::Cap(struct Buffer* b)
    {
        return cap(b->buf);
    }

    // Available returns how many bytes are unused in the buffer.
    int rec::Available(struct Buffer* b)
    {
        return cap(b->buf) - len(b->buf);
    }

    // Truncate discards all but the first n unread bytes from the buffer
    // but continues to use the same allocated storage.
    // It panics if n is negative or greater than the length of the buffer.
    void rec::Truncate(struct Buffer* b, int n)
    {
        if(n == 0)
        {
            rec::Reset(gocpp::recv(b));
            return;
        }
        b->lastRead = opInvalid;
        if(n < 0 || n > rec::Len(gocpp::recv(b)))
        {
            gocpp::panic("bytes.Buffer: truncation out of range"s);
        }
        b->buf = b->buf.make_slice(0, b->off + n);
    }

    // Reset resets the buffer to be empty,
    // but it retains the underlying storage for use by future writes.
    // Reset is the same as [Buffer.Truncate](0).
    void rec::Reset(struct Buffer* b)
    {
        b->buf = b->buf.make_slice(0, 0);
        b->off = 0;
        b->lastRead = opInvalid;
    }

    // tryGrowByReslice is an inlineable version of grow for the fast-case where the
    // internal buffer only needs to be resliced.
    // It returns the index where bytes should be written and whether it succeeded.
    std::tuple<int, bool> rec::tryGrowByReslice(struct Buffer* b, int n)
    {
        if(auto l = len(b->buf); n <= cap(b->buf) - l)
        {
            b->buf = b->buf.make_slice(0, l + n);
            return {l, true};
        }
        return {0, false};
    }

    // grow grows the buffer to guarantee space for n more bytes.
    // It returns the index where bytes should be written.
    // If the buffer can't grow it will panic with ErrTooLarge.
    int rec::grow(struct Buffer* b, int n)
    {
        auto m = rec::Len(gocpp::recv(b));
        if(m == 0 && b->off != 0)
        {
            rec::Reset(gocpp::recv(b));
        }
        if(auto [i, ok] = rec::tryGrowByReslice(gocpp::recv(b), n); ok)
        {
            return i;
        }
        if(b->buf == nullptr && n <= smallBufferSize)
        {
            b->buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n, smallBufferSize);
            return 0;
        }
        auto c = cap(b->buf);
        if(n <= c / 2 - m)
        {
            copy(b->buf, b->buf.make_slice(b->off));
        }
        else
        if(c > maxInt - c - n)
        {
            gocpp::panic(ErrTooLarge);
        }
        else
        {
            b->buf = growSlice(b->buf.make_slice(b->off), b->off + n);
        }
        b->off = 0;
        b->buf = b->buf.make_slice(0, m + n);
        return m;
    }

    // Grow grows the buffer's capacity, if necessary, to guarantee space for
    // another n bytes. After Grow(n), at least n bytes can be written to the
    // buffer without another allocation.
    // If n is negative, Grow will panic.
    // If the buffer can't grow it will panic with [ErrTooLarge].
    void rec::Grow(struct Buffer* b, int n)
    {
        if(n < 0)
        {
            gocpp::panic("bytes.Buffer.Grow: negative count"s);
        }
        auto m = rec::grow(gocpp::recv(b), n);
        b->buf = b->buf.make_slice(0, m);
    }

    // Write appends the contents of p to the buffer, growing the buffer as
    // needed. The return value n is the length of p; err is always nil. If the
    // buffer becomes too large, Write will panic with [ErrTooLarge].
    std::tuple<int, struct gocpp::error> rec::Write(struct Buffer* b, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        auto [m, ok] = rec::tryGrowByReslice(gocpp::recv(b), len(p));
        if(! ok)
        {
            m = rec::grow(gocpp::recv(b), len(p));
        }
        return {copy(b->buf.make_slice(m), p), nullptr};
    }

    // WriteString appends the contents of s to the buffer, growing the buffer as
    // needed. The return value n is the length of s; err is always nil. If the
    // buffer becomes too large, WriteString will panic with [ErrTooLarge].
    std::tuple<int, struct gocpp::error> rec::WriteString(struct Buffer* b, std::string s)
    {
        int n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        auto [m, ok] = rec::tryGrowByReslice(gocpp::recv(b), len(s));
        if(! ok)
        {
            m = rec::grow(gocpp::recv(b), len(s));
        }
        return {copy(b->buf.make_slice(m), s), nullptr};
    }

    // MinRead is the minimum slice size passed to a Read call by
    // [Buffer.ReadFrom]. As long as the [Buffer] has at least MinRead bytes beyond
    // what is required to hold the contents of r, ReadFrom will not grow the
    // underlying buffer.
    // ReadFrom reads data from r until EOF and appends it to the buffer, growing
    // the buffer as needed. The return value n is the number of bytes read. Any
    // error except io.EOF encountered during the read is also returned. If the
    // buffer becomes too large, ReadFrom will panic with [ErrTooLarge].
    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(struct Buffer* b, io::Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        for(; ; )
        {
            auto i = rec::grow(gocpp::recv(b), MinRead);
            b->buf = b->buf.make_slice(0, i);
            auto [m, e] = rec::Read(gocpp::recv(r), b->buf.make_slice(i, cap(b->buf)));
            if(m < 0)
            {
                gocpp::panic(errNegativeRead);
            }
            b->buf = b->buf.make_slice(0, i + m);
            n += int64_t(m);
            if(e == io::go_EOF)
            {
                return {n, nullptr};
            }
            if(e != nullptr)
            {
                return {n, e};
            }
        }
    }

    // growSlice grows b by n, preserving the original content of b.
    // If the allocation fails, it panics with ErrTooLarge.
    gocpp::slice<unsigned char> growSlice(gocpp::slice<unsigned char> b, int n)
    {
        gocpp::Defer defer;
        try
        {
            defer.push_back([=]{ [=]() mutable -> void
            {
                if(gocpp::recover() != nullptr)
                {
                    gocpp::panic(ErrTooLarge);
                }
            }(); });
            auto c = len(b) + n;
            if(c < 2 * cap(b))
            {
                c = 2 * cap(b);
            }
            auto b2 = append(gocpp::slice<unsigned char>(nullptr), gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), c));
            copy(b2, b);
            return b2.make_slice(0, len(b));
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // WriteTo writes data to w until the buffer is drained or an error occurs.
    // The return value n is the number of bytes written; it always fits into an
    // int, but it is int64 to match the io.WriterTo interface. Any error
    // encountered during the write is also returned.
    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct Buffer* b, io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        if(auto nBytes = rec::Len(gocpp::recv(b)); nBytes > 0)
        {
            auto [m, e] = rec::Write(gocpp::recv(w), b->buf.make_slice(b->off));
            if(m > nBytes)
            {
                gocpp::panic("bytes.Buffer.WriteTo: invalid Write count"s);
            }
            b->off += m;
            n = int64_t(m);
            if(e != nullptr)
            {
                return {n, e};
            }
            if(m != nBytes)
            {
                return {n, io::ErrShortWrite};
            }
        }
        rec::Reset(gocpp::recv(b));
        return {n, nullptr};
    }

    // WriteByte appends the byte c to the buffer, growing the buffer as needed.
    // The returned error is always nil, but is included to match [bufio.Writer]'s
    // WriteByte. If the buffer becomes too large, WriteByte will panic with
    // [ErrTooLarge].
    struct gocpp::error rec::WriteByte(struct Buffer* b, unsigned char c)
    {
        b->lastRead = opInvalid;
        auto [m, ok] = rec::tryGrowByReslice(gocpp::recv(b), 1);
        if(! ok)
        {
            m = rec::grow(gocpp::recv(b), 1);
        }
        b->buf[m] = c;
        return nullptr;
    }

    // WriteRune appends the UTF-8 encoding of Unicode code point r to the
    // buffer, returning its length and an error, which is always nil but is
    // included to match [bufio.Writer]'s WriteRune. The buffer is grown as needed;
    // if it becomes too large, WriteRune will panic with [ErrTooLarge].
    std::tuple<int, struct gocpp::error> rec::WriteRune(struct Buffer* b, gocpp::rune r)
    {
        int n;
        struct gocpp::error err;
        if(uint32_t(r) < utf8::RuneSelf)
        {
            rec::WriteByte(gocpp::recv(b), (unsigned char)(r));
            return {1, nullptr};
        }
        b->lastRead = opInvalid;
        auto [m, ok] = rec::tryGrowByReslice(gocpp::recv(b), utf8::UTFMax);
        if(! ok)
        {
            m = rec::grow(gocpp::recv(b), utf8::UTFMax);
        }
        b->buf = utf8::AppendRune(b->buf.make_slice(0, m), r);
        return {len(b->buf) - m, nullptr};
    }

    // Read reads the next len(p) bytes from the buffer or until the buffer
    // is drained. The return value n is the number of bytes read. If the
    // buffer has no data to return, err is io.EOF (unless len(p) is zero);
    // otherwise it is nil.
    std::tuple<int, struct gocpp::error> rec::Read(struct Buffer* b, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        b->lastRead = opInvalid;
        if(rec::empty(gocpp::recv(b)))
        {
            rec::Reset(gocpp::recv(b));
            if(len(p) == 0)
            {
                return {0, nullptr};
            }
            return {0, io::go_EOF};
        }
        n = copy(p, b->buf.make_slice(b->off));
        b->off += n;
        if(n > 0)
        {
            b->lastRead = opRead;
        }
        return {n, nullptr};
    }

    // Next returns a slice containing the next n bytes from the buffer,
    // advancing the buffer as if the bytes had been returned by [Buffer.Read].
    // If there are fewer than n bytes in the buffer, Next returns the entire buffer.
    // The slice is only valid until the next call to a read or write method.
    gocpp::slice<unsigned char> rec::Next(struct Buffer* b, int n)
    {
        b->lastRead = opInvalid;
        auto m = rec::Len(gocpp::recv(b));
        if(n > m)
        {
            n = m;
        }
        auto data = b->buf.make_slice(b->off, b->off + n);
        b->off += n;
        if(n > 0)
        {
            b->lastRead = opRead;
        }
        return data;
    }

    // ReadByte reads and returns the next byte from the buffer.
    // If no byte is available, it returns error io.EOF.
    std::tuple<unsigned char, struct gocpp::error> rec::ReadByte(struct Buffer* b)
    {
        if(rec::empty(gocpp::recv(b)))
        {
            rec::Reset(gocpp::recv(b));
            return {0, io::go_EOF};
        }
        auto c = b->buf[b->off];
        b->off++;
        b->lastRead = opRead;
        return {c, nullptr};
    }

    // ReadRune reads and returns the next UTF-8-encoded
    // Unicode code point from the buffer.
    // If no bytes are available, the error returned is io.EOF.
    // If the bytes are an erroneous UTF-8 encoding, it
    // consumes one byte and returns U+FFFD, 1.
    std::tuple<gocpp::rune, int, struct gocpp::error> rec::ReadRune(struct Buffer* b)
    {
        gocpp::rune r;
        int size;
        struct gocpp::error err;
        if(rec::empty(gocpp::recv(b)))
        {
            rec::Reset(gocpp::recv(b));
            return {0, 0, io::go_EOF};
        }
        auto c = b->buf[b->off];
        if(c < utf8::RuneSelf)
        {
            b->off++;
            b->lastRead = opReadRune1;
            return {gocpp::rune(c), 1, nullptr};
        }
        auto [r, n] = utf8::DecodeRune(b->buf.make_slice(b->off));
        b->off += n;
        b->lastRead = readOp(n);
        return {r, n, nullptr};
    }

    // UnreadRune unreads the last rune returned by [Buffer.ReadRune].
    // If the most recent read or write operation on the buffer was
    // not a successful [Buffer.ReadRune], UnreadRune returns an error.  (In this regard
    // it is stricter than [Buffer.UnreadByte], which will unread the last byte
    // from any read operation.)
    struct gocpp::error rec::UnreadRune(struct Buffer* b)
    {
        if(b->lastRead <= opInvalid)
        {
            return errors::New("bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"s);
        }
        if(b->off >= int(b->lastRead))
        {
            b->off -= int(b->lastRead);
        }
        b->lastRead = opInvalid;
        return nullptr;
    }

    gocpp::error errUnreadByte = errors::New("bytes.Buffer: UnreadByte: previous operation was not a successful read"s);
    // UnreadByte unreads the last byte returned by the most recent successful
    // read operation that read at least one byte. If a write has happened since
    // the last read, if the last read returned an error, or if the read read zero
    // bytes, UnreadByte returns an error.
    struct gocpp::error rec::UnreadByte(struct Buffer* b)
    {
        if(b->lastRead == opInvalid)
        {
            return errUnreadByte;
        }
        b->lastRead = opInvalid;
        if(b->off > 0)
        {
            b->off--;
        }
        return nullptr;
    }

    // ReadBytes reads until the first occurrence of delim in the input,
    // returning a slice containing the data up to and including the delimiter.
    // If ReadBytes encounters an error before finding a delimiter,
    // it returns the data read before the error and the error itself (often io.EOF).
    // ReadBytes returns err != nil if and only if the returned data does not end in
    // delim.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadBytes(struct Buffer* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        struct gocpp::error err;
        auto [slice, err] = rec::readSlice(gocpp::recv(b), delim);
        line = append(line, slice);
        return {line, err};
    }

    // readSlice is like ReadBytes but returns a reference to internal buffer data.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::readSlice(struct Buffer* b, unsigned char delim)
    {
        gocpp::slice<unsigned char> line;
        struct gocpp::error err;
        auto i = IndexByte(b->buf.make_slice(b->off), delim);
        auto end = b->off + i + 1;
        if(i < 0)
        {
            end = len(b->buf);
            err = io::go_EOF;
        }
        line = b->buf.make_slice(b->off, end);
        b->off = end;
        b->lastRead = opRead;
        return {line, err};
    }

    // ReadString reads until the first occurrence of delim in the input,
    // returning a string containing the data up to and including the delimiter.
    // If ReadString encounters an error before finding a delimiter,
    // it returns the data read before the error and the error itself (often io.EOF).
    // ReadString returns err != nil if and only if the returned data does not end
    // in delim.
    std::tuple<std::string, struct gocpp::error> rec::ReadString(struct Buffer* b, unsigned char delim)
    {
        std::string line;
        struct gocpp::error err;
        auto [slice, err] = rec::readSlice(gocpp::recv(b), delim);
        return {std::string(slice), err};
    }

    // NewBuffer creates and initializes a new [Buffer] using buf as its
    // initial contents. The new [Buffer] takes ownership of buf, and the
    // caller should not use buf after this call. NewBuffer is intended to
    // prepare a [Buffer] to read existing data. It can also be used to set
    // the initial size of the internal buffer for writing. To do that,
    // buf should have the desired capacity but a length of zero.
    //
    // In most cases, new([Buffer]) (or just declaring a [Buffer] variable) is
    // sufficient to initialize a [Buffer].
    struct Buffer* NewBuffer(gocpp::slice<unsigned char> buf)
    {
        return gocpp::InitPtr<Buffer>([=](auto& x) {
            x.buf = buf;
        });
    }

    // NewBufferString creates and initializes a new [Buffer] using string s as its
    // initial contents. It is intended to prepare a buffer to read an existing
    // string.
    //
    // In most cases, new([Buffer]) (or just declaring a [Buffer] variable) is
    // sufficient to initialize a [Buffer].
    struct Buffer* NewBufferString(std::string s)
    {
        return gocpp::InitPtr<Buffer>([=](auto& x) {
            x.buf = gocpp::slice<unsigned char>(s);
        });
    }

}

