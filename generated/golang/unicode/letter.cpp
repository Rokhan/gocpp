// generated by GoCpp from file '$(ImportDir)/unicode/letter.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/unicode/letter.h"
#include "gocpp/support.h"

#include "golang/unicode/graphic.h"

// Package unicode provides data and functions to test some properties of
// Unicode code points.
namespace golang::unicode
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // RangeTable defines a set of Unicode code points by listing the ranges of
    // code points within the set. The ranges are listed in two slices
    // to save space: a slice of 16-bit ranges and a slice of 32-bit ranges.
    // The two slices must be in sorted order and non-overlapping.
    // Also, R32 should contain only values >= 0x10000 (1<<16).
    
    template<typename T> requires gocpp::GoStruct<T>
    RangeTable::operator T()
    {
        T result;
        result.R16 = this->R16;
        result.R32 = this->R32;
        result.LatinOffset = this->LatinOffset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RangeTable::operator==(const T& ref) const
    {
        if (R16 != ref.R16) return false;
        if (R32 != ref.R32) return false;
        if (LatinOffset != ref.LatinOffset) return false;
        return true;
    }

    std::ostream& RangeTable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R16;
        os << " " << R32;
        os << " " << LatinOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RangeTable& value)
    {
        return value.PrintTo(os);
    }

    // Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi
    // inclusive and has the specified stride.
    
    template<typename T> requires gocpp::GoStruct<T>
    Range16::operator T()
    {
        T result;
        result.Lo = this->Lo;
        result.Hi = this->Hi;
        result.Stride = this->Stride;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Range16::operator==(const T& ref) const
    {
        if (Lo != ref.Lo) return false;
        if (Hi != ref.Hi) return false;
        if (Stride != ref.Stride) return false;
        return true;
    }

    std::ostream& Range16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Lo;
        os << " " << Hi;
        os << " " << Stride;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Range16& value)
    {
        return value.PrintTo(os);
    }

    // Range32 represents of a range of Unicode code points and is used when one or
    // more of the values will not fit in 16 bits. The range runs from Lo to Hi
    // inclusive and has the specified stride. Lo and Hi must always be >= 1<<16.
    
    template<typename T> requires gocpp::GoStruct<T>
    Range32::operator T()
    {
        T result;
        result.Lo = this->Lo;
        result.Hi = this->Hi;
        result.Stride = this->Stride;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Range32::operator==(const T& ref) const
    {
        if (Lo != ref.Lo) return false;
        if (Hi != ref.Hi) return false;
        if (Stride != ref.Stride) return false;
        return true;
    }

    std::ostream& Range32::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Lo;
        os << " " << Hi;
        os << " " << Stride;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Range32& value)
    {
        return value.PrintTo(os);
    }

    // CaseRange represents a range of Unicode code points for simple (one
    // code point to one code point) case conversion.
    // The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas
    // are the number to add to the code point to reach the code point for a
    // different case for that character. They may be negative. If zero, it
    // means the character is in the corresponding case. There is a special
    // case representing sequences of alternating corresponding Upper and Lower
    // pairs. It appears with a fixed Delta of
    //
    //	{UpperLower, UpperLower, UpperLower}
    //
    // The constant UpperLower has an otherwise impossible delta value.
    
    template<typename T> requires gocpp::GoStruct<T>
    CaseRange::operator T()
    {
        T result;
        result.Lo = this->Lo;
        result.Hi = this->Hi;
        result.Delta = this->Delta;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CaseRange::operator==(const T& ref) const
    {
        if (Lo != ref.Lo) return false;
        if (Hi != ref.Hi) return false;
        if (Delta != ref.Delta) return false;
        return true;
    }

    std::ostream& CaseRange::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Lo;
        os << " " << Hi;
        os << " " << Delta;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CaseRange& value)
    {
        return value.PrintTo(os);
    }

    // SpecialCase represents language-specific case mappings such as Turkish.
    // Methods of SpecialCase customize (by overriding) the standard mappings.
    // Indices into the Delta arrays inside CaseRanges for case mapping.
    // // to make the CaseRanges text shorter
    // If the Delta field of a [CaseRange] is UpperLower, it means
    // this CaseRange represents a sequence of the form (say)
    // [Upper] [Lower] [Upper] [Lower].
    // linearMax is the maximum size table for linear search for non-Latin1 rune.
    // Derived by running 'go test -calibrate'.
    // is16 reports whether r is in the sorted slice of 16-bit ranges.
    bool is16(gocpp::slice<Range16> ranges, uint16_t r)
    {
        if(len(ranges) <= linearMax || r <= MaxLatin1)
        {
            for(auto [i, gocpp_ignored] : ranges)
            {
                auto range_ = & ranges[i];
                if(r < range_->Lo)
                {
                    return false;
                }
                if(r <= range_->Hi)
                {
                    return range_->Stride == 1 || (r - range_->Lo) % range_->Stride == 0;
                }
            }
            return false;
        }
        auto lo = 0;
        auto hi = len(ranges);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto range_ = & ranges[m];
            if(range_->Lo <= r && r <= range_->Hi)
            {
                return range_->Stride == 1 || (r - range_->Lo) % range_->Stride == 0;
            }
            if(r < range_->Lo)
            {
                hi = m;
            }
            else
            {
                lo = m + 1;
            }
        }
        return false;
    }

    // is32 reports whether r is in the sorted slice of 32-bit ranges.
    bool is32(gocpp::slice<Range32> ranges, uint32_t r)
    {
        if(len(ranges) <= linearMax)
        {
            for(auto [i, gocpp_ignored] : ranges)
            {
                auto range_ = & ranges[i];
                if(r < range_->Lo)
                {
                    return false;
                }
                if(r <= range_->Hi)
                {
                    return range_->Stride == 1 || (r - range_->Lo) % range_->Stride == 0;
                }
            }
            return false;
        }
        auto lo = 0;
        auto hi = len(ranges);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto range_ = ranges[m];
            if(range_.Lo <= r && r <= range_.Hi)
            {
                return range_.Stride == 1 || (r - range_.Lo) % range_.Stride == 0;
            }
            if(r < range_.Lo)
            {
                hi = m;
            }
            else
            {
                lo = m + 1;
            }
        }
        return false;
    }

    // Is reports whether the rune is in the specified table of ranges.
    bool Is(struct RangeTable* rangeTab, gocpp::rune r)
    {
        auto r16 = rangeTab->R16;
        if(len(r16) > 0 && uint32_t(r) <= uint32_t(r16[len(r16) - 1].Hi))
        {
            return is16(r16, uint16_t(r));
        }
        auto r32 = rangeTab->R32;
        if(len(r32) > 0 && r >= gocpp::rune(r32[0].Lo))
        {
            return is32(r32, uint32_t(r));
        }
        return false;
    }

    bool isExcludingLatin(struct RangeTable* rangeTab, gocpp::rune r)
    {
        auto r16 = rangeTab->R16;
        if(auto off = rangeTab->LatinOffset; len(r16) > off && uint32_t(r) <= uint32_t(r16[len(r16) - 1].Hi))
        {
            return is16(r16.make_slice(off), uint16_t(r));
        }
        auto r32 = rangeTab->R32;
        if(len(r32) > 0 && r >= gocpp::rune(r32[0].Lo))
        {
            return is32(r32, uint32_t(r));
        }
        return false;
    }

    // IsUpper reports whether the rune is an upper case letter.
    bool IsUpper(gocpp::rune r)
    {
        if(uint32_t(r) <= MaxLatin1)
        {
            return properties[uint8_t(r)] & pLmask == pLu;
        }
        return isExcludingLatin(Upper, r);
    }

    // IsLower reports whether the rune is a lower case letter.
    bool IsLower(gocpp::rune r)
    {
        if(uint32_t(r) <= MaxLatin1)
        {
            return properties[uint8_t(r)] & pLmask == pLl;
        }
        return isExcludingLatin(Lower, r);
    }

    // IsTitle reports whether the rune is a title case letter.
    bool IsTitle(gocpp::rune r)
    {
        if(r <= MaxLatin1)
        {
            return false;
        }
        return isExcludingLatin(Title, r);
    }

    // to maps the rune using the specified case mapping.
    // It additionally reports whether caseRange contained a mapping for r.
    std::tuple<gocpp::rune, bool> to(int _case, gocpp::rune r, gocpp::slice<CaseRange> caseRange)
    {
        gocpp::rune mappedRune;
        bool foundMapping;
        if(_case < 0 || MaxCase <= _case)
        {
            return {ReplacementChar, false};
        }
        auto lo = 0;
        auto hi = len(caseRange);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            auto cr = caseRange[m];
            if(gocpp::rune(cr.Lo) <= r && r <= gocpp::rune(cr.Hi))
            {
                auto delta = cr.Delta[_case];
                if(delta > MaxRune)
                {
                    return {gocpp::rune(cr.Lo) + ((r - gocpp::rune(cr.Lo)) &^ 1 | gocpp::rune(_case & 1)), true};
                }
                return {r + delta, true};
            }
            if(r < gocpp::rune(cr.Lo))
            {
                hi = m;
            }
            else
            {
                lo = m + 1;
            }
        }
        return {r, false};
    }

    // To maps the rune to the specified case: [UpperCase], [LowerCase], or [TitleCase].
    gocpp::rune To(int _case, gocpp::rune r)
    {
        std::tie(r, gocpp_id_0) = to(_case, r, CaseRanges);
        return r;
    }

    // ToUpper maps the rune to upper case.
    gocpp::rune ToUpper(gocpp::rune r)
    {
        if(r <= MaxASCII)
        {
            if('a' <= r && r <= 'z')
            {
                r -= 'a' - 'A';
            }
            return r;
        }
        return To(UpperCase, r);
    }

    // ToLower maps the rune to lower case.
    gocpp::rune ToLower(gocpp::rune r)
    {
        if(r <= MaxASCII)
        {
            if('A' <= r && r <= 'Z')
            {
                r += 'a' - 'A';
            }
            return r;
        }
        return To(LowerCase, r);
    }

    // ToTitle maps the rune to title case.
    gocpp::rune ToTitle(gocpp::rune r)
    {
        if(r <= MaxASCII)
        {
            if('a' <= r && r <= 'z')
            {
                r -= 'a' - 'A';
            }
            return r;
        }
        return To(TitleCase, r);
    }

    // ToUpper maps the rune to upper case giving priority to the special mapping.
    gocpp::rune rec::ToUpper(golang::unicode::SpecialCase special, gocpp::rune r)
    {
        auto [r1, hadMapping] = to(UpperCase, r, gocpp::slice<CaseRange>(special));
        if(r1 == r && ! hadMapping)
        {
            r1 = ToUpper(r);
        }
        return r1;
    }

    // ToTitle maps the rune to title case giving priority to the special mapping.
    gocpp::rune rec::ToTitle(golang::unicode::SpecialCase special, gocpp::rune r)
    {
        auto [r1, hadMapping] = to(TitleCase, r, gocpp::slice<CaseRange>(special));
        if(r1 == r && ! hadMapping)
        {
            r1 = ToTitle(r);
        }
        return r1;
    }

    // ToLower maps the rune to lower case giving priority to the special mapping.
    gocpp::rune rec::ToLower(golang::unicode::SpecialCase special, gocpp::rune r)
    {
        auto [r1, hadMapping] = to(LowerCase, r, gocpp::slice<CaseRange>(special));
        if(r1 == r && ! hadMapping)
        {
            r1 = ToLower(r);
        }
        return r1;
    }

    // caseOrbit is defined in tables.go as []foldPair. Right now all the
    // entries fit in uint16, so use uint16. If that changes, compilation
    // will fail (the constants in the composite literal will not fit in uint16)
    // and the types here can change to uint32.
    
    template<typename T> requires gocpp::GoStruct<T>
    foldPair::operator T()
    {
        T result;
        result.From = this->From;
        result.To = this->To;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool foldPair::operator==(const T& ref) const
    {
        if (From != ref.From) return false;
        if (To != ref.To) return false;
        return true;
    }

    std::ostream& foldPair::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << From;
        os << " " << To;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct foldPair& value)
    {
        return value.PrintTo(os);
    }

    // SimpleFold iterates over Unicode code points equivalent under
    // the Unicode-defined simple case folding. Among the code points
    // equivalent to rune (including rune itself), SimpleFold returns the
    // smallest rune > r if one exists, or else the smallest rune >= 0.
    // If r is not a valid Unicode code point, SimpleFold(r) returns r.
    //
    // For example:
    //
    //	SimpleFold('A') = 'a'
    //	SimpleFold('a') = 'A'
    //
    //	SimpleFold('K') = 'k'
    //	SimpleFold('k') = '\u212A' (Kelvin symbol, K)
    //	SimpleFold('\u212A') = 'K'
    //
    //	SimpleFold('1') = '1'
    //
    //	SimpleFold(-2) = -2
    gocpp::rune SimpleFold(gocpp::rune r)
    {
        if(r < 0 || r > MaxRune)
        {
            return r;
        }
        if(int(r) < len(asciiFold))
        {
            return gocpp::rune(asciiFold[r]);
        }
        auto lo = 0;
        auto hi = len(caseOrbit);
        for(; lo < hi; )
        {
            auto m = int((unsigned int)(lo + hi) >> 1);
            if(gocpp::rune(caseOrbit[m].From) < r)
            {
                lo = m + 1;
            }
            else
            {
                hi = m;
            }
        }
        if(lo < len(caseOrbit) && gocpp::rune(caseOrbit[lo].From) == r)
        {
            return gocpp::rune(caseOrbit[lo].To);
        }
        if(auto l = ToLower(r); l != r)
        {
            return l;
        }
        return ToUpper(r);
    }

}

