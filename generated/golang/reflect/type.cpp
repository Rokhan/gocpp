// generated by GoCpp from file '$(ImportDir)/reflect/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/type.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/map.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/value.h"
#include "golang/strconv/itoa.h"
#include "golang/strconv/quote.h"
#include "golang/sync/atomic/type.h"
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/map.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/utf8/utf8.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    
    template<typename T>
    Type::Type(T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(const T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(T* ptr)
    {
        value.reset(new TypeImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Type::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vAlign()
    {
        return Align(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vFieldAlign()
    {
        return FieldAlign(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Method Type::TypeImpl<T, StoreT>::vMethod(int)
    {
        return Method(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<Method, bool> Type::TypeImpl<T, StoreT>::vMethodByName(std::string)
    {
        return MethodByName(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumMethod()
    {
        return NumMethod(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vName()
    {
        return Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vPkgPath()
    {
        return PkgPath(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uintptr_t Type::TypeImpl<T, StoreT>::vSize()
    {
        return Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vString()
    {
        return String(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Kind Type::TypeImpl<T, StoreT>::vKind()
    {
        return Kind(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vImplements(Type u)
    {
        return Implements(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vAssignableTo(Type u)
    {
        return AssignableTo(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vConvertibleTo(Type u)
    {
        return ConvertibleTo(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vComparable()
    {
        return Comparable(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vBits()
    {
        return Bits(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    ChanDir Type::TypeImpl<T, StoreT>::vChanDir()
    {
        return ChanDir(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vIsVariadic()
    {
        return IsVariadic(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Type Type::TypeImpl<T, StoreT>::vElem()
    {
        return Elem(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    StructField Type::TypeImpl<T, StoreT>::vField(int i)
    {
        return Field(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    StructField Type::TypeImpl<T, StoreT>::vFieldByIndex(gocpp::slice<int> index)
    {
        return FieldByIndex(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<StructField, bool> Type::TypeImpl<T, StoreT>::vFieldByName(std::string name)
    {
        return FieldByName(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<StructField, bool> Type::TypeImpl<T, StoreT>::vFieldByNameFunc(std::function<bool (std::string)> match)
    {
        return FieldByNameFunc(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Type Type::TypeImpl<T, StoreT>::vIn(int i)
    {
        return In(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Type Type::TypeImpl<T, StoreT>::vKey()
    {
        return Key(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vLen()
    {
        return Len(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumField()
    {
        return NumField(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumIn()
    {
        return NumIn(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Type::TypeImpl<T, StoreT>::vNumOut()
    {
        return NumOut(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Type Type::TypeImpl<T, StoreT>::vOut(int i)
    {
        return Out(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    abi::Type* Type::TypeImpl<T, StoreT>::vcommon()
    {
        return common(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uncommonType* Type::TypeImpl<T, StoreT>::vuncommon()
    {
        return uncommon(gocpp::PtrRecv<T, false>(value.get()));
    }

    int Align(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vAlign();
    }

    int Align(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vAlign();
    }

    int FieldAlign(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vFieldAlign();
    }

    int FieldAlign(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vFieldAlign();
    }

    Method Method(const gocpp::PtrRecv<Type, false>& self, int)
    {
        return self.ptr->value->vMethod(int);
    }

    Method Method(const gocpp::ObjRecv<Type>& self, int)
    {
        return self.obj.value->vMethod(int);
    }

    std::tuple<Method, bool> MethodByName(const gocpp::PtrRecv<Type, false>& self, std::string)
    {
        return self.ptr->value->vMethodByName(std::string);
    }

    std::tuple<Method, bool> MethodByName(const gocpp::ObjRecv<Type>& self, std::string)
    {
        return self.obj.value->vMethodByName(std::string);
    }

    int NumMethod(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vNumMethod();
    }

    int NumMethod(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vNumMethod();
    }

    std::string Name(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vName();
    }

    std::string Name(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vName();
    }

    std::string PkgPath(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vPkgPath();
    }

    std::string PkgPath(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vPkgPath();
    }

    uintptr_t Size(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vSize();
    }

    uintptr_t Size(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vSize();
    }

    std::string String(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vString();
    }

    std::string String(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vString();
    }

    Kind Kind(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vKind();
    }

    Kind Kind(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vKind();
    }

    bool Implements(const gocpp::PtrRecv<Type, false>& self, Type u)
    {
        return self.ptr->value->vImplements(Type u);
    }

    bool Implements(const gocpp::ObjRecv<Type>& self, Type u)
    {
        return self.obj.value->vImplements(Type u);
    }

    bool AssignableTo(const gocpp::PtrRecv<Type, false>& self, Type u)
    {
        return self.ptr->value->vAssignableTo(Type u);
    }

    bool AssignableTo(const gocpp::ObjRecv<Type>& self, Type u)
    {
        return self.obj.value->vAssignableTo(Type u);
    }

    bool ConvertibleTo(const gocpp::PtrRecv<Type, false>& self, Type u)
    {
        return self.ptr->value->vConvertibleTo(Type u);
    }

    bool ConvertibleTo(const gocpp::ObjRecv<Type>& self, Type u)
    {
        return self.obj.value->vConvertibleTo(Type u);
    }

    bool Comparable(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vComparable();
    }

    bool Comparable(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vComparable();
    }

    int Bits(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vBits();
    }

    int Bits(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vBits();
    }

    ChanDir ChanDir(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vChanDir();
    }

    ChanDir ChanDir(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vChanDir();
    }

    bool IsVariadic(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vIsVariadic();
    }

    bool IsVariadic(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vIsVariadic();
    }

    Type Elem(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vElem();
    }

    Type Elem(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vElem();
    }

    StructField Field(const gocpp::PtrRecv<Type, false>& self, int i)
    {
        return self.ptr->value->vField(int i);
    }

    StructField Field(const gocpp::ObjRecv<Type>& self, int i)
    {
        return self.obj.value->vField(int i);
    }

    StructField FieldByIndex(const gocpp::PtrRecv<Type, false>& self, gocpp::slice<int> index)
    {
        return self.ptr->value->vFieldByIndex(gocpp::slice<int> index);
    }

    StructField FieldByIndex(const gocpp::ObjRecv<Type>& self, gocpp::slice<int> index)
    {
        return self.obj.value->vFieldByIndex(gocpp::slice<int> index);
    }

    std::tuple<StructField, bool> FieldByName(const gocpp::PtrRecv<Type, false>& self, std::string name)
    {
        return self.ptr->value->vFieldByName(std::string name);
    }

    std::tuple<StructField, bool> FieldByName(const gocpp::ObjRecv<Type>& self, std::string name)
    {
        return self.obj.value->vFieldByName(std::string name);
    }

    std::tuple<StructField, bool> FieldByNameFunc(const gocpp::PtrRecv<Type, false>& self, std::function<bool (std::string)> match)
    {
        return self.ptr->value->vFieldByNameFunc(std::function<bool (std::string)> match);
    }

    std::tuple<StructField, bool> FieldByNameFunc(const gocpp::ObjRecv<Type>& self, std::function<bool (std::string)> match)
    {
        return self.obj.value->vFieldByNameFunc(std::function<bool (std::string)> match);
    }

    Type In(const gocpp::PtrRecv<Type, false>& self, int i)
    {
        return self.ptr->value->vIn(int i);
    }

    Type In(const gocpp::ObjRecv<Type>& self, int i)
    {
        return self.obj.value->vIn(int i);
    }

    Type Key(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vKey();
    }

    Type Key(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vKey();
    }

    int Len(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vLen();
    }

    int Len(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vLen();
    }

    int NumField(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vNumField();
    }

    int NumField(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vNumField();
    }

    int NumIn(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vNumIn();
    }

    int NumIn(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vNumIn();
    }

    int NumOut(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vNumOut();
    }

    int NumOut(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vNumOut();
    }

    Type Out(const gocpp::PtrRecv<Type, false>& self, int i)
    {
        return self.ptr->value->vOut(int i);
    }

    Type Out(const gocpp::ObjRecv<Type>& self, int i)
    {
        return self.obj.value->vOut(int i);
    }

    abi::Type* common(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vcommon();
    }

    abi::Type* common(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vcommon();
    }

    uncommonType* uncommon(const gocpp::PtrRecv<Type, false>& self)
    {
        return self.ptr->value->vuncommon();
    }

    uncommonType* uncommon(const gocpp::ObjRecv<Type>& self)
    {
        return self.obj.value->vuncommon();
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& common::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct common& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& rtype::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << t;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rtype& value)
    {
        return value.PrintTo(os);
    }

    abi::Type* common(struct rtype* t)
    {
        return & t->t;
    }

    abi::UncommonType* uncommon(struct rtype* t)
    {
        return Uncommon(gocpp::recv(t->t));
    }

    
    std::ostream& interfaceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct interfaceType& value)
    {
        return value.PrintTo(os);
    }

    abi::Name nameOff(struct interfaceType* t, aNameOff off)
    {
        return nameOff(gocpp::recv(toRType(& t->Type)), off);
    }

    abi::Name nameOffFor(abi::Type* t, aNameOff off)
    {
        return nameOff(gocpp::recv(toRType(t)), off);
    }

    abi::Type* typeOffFor(abi::Type* t, aTypeOff off)
    {
        return typeOff(gocpp::recv(toRType(t)), off);
    }

    abi::Type* typeOff(struct interfaceType* t, aTypeOff off)
    {
        return typeOff(gocpp::recv(toRType(& t->Type)), off);
    }

    abi::Type* common(struct interfaceType* t)
    {
        return & t->Type;
    }

    abi::UncommonType* uncommon(struct interfaceType* t)
    {
        return Uncommon(gocpp::recv(t));
    }

    
    std::ostream& mapType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mapType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& ptrType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ptrType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& sliceType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sliceType& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& structType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structType& value)
    {
        return value.PrintTo(os);
    }

    std::string pkgPath(abi::Name n)
    {
        if(n->Bytes == nullptr || *DataChecked(gocpp::recv(n), 0, "name flag field") & (1 << 2) == 0)
        {
            return "";
        }
        auto [i, l] = ReadVarint(gocpp::recv(n), 1);
        auto off = 1 + i + l;
        if(HasTag(gocpp::recv(n)))
        {
            auto [i2, l2] = ReadVarint(gocpp::recv(n), off);
            off += i2 + l2;
        }
        int32_t nameOff = {};
        copy((gocpp::array<unsigned char, 4>*)(unsafe::Pointer(& nameOff)).make_slice(0, ), (gocpp::array<unsigned char, 4>*)(unsafe::Pointer(DataChecked(gocpp::recv(n), off, "name offset field"))).make_slice(0, ));
        auto pkgPathName = gocpp::Init<abi::Name>([](abi::Name& x) { x.Bytes = (unsigned char*)(resolveTypeOff(unsafe::Pointer(n->Bytes), nameOff)); });
        return Name(gocpp::recv(pkgPathName));
    }

    abi::Name newName(std::string n, std::string tag, bool exported, bool embedded)
    {
        return abi::NewName(n, tag, exported, embedded);
    }

    
    std::ostream& Method::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << PkgPath;
        os << " " << Type;
        os << " " << Func;
        os << " " << Index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Method& value)
    {
        return value.PrintTo(os);
    }

    bool IsExported(struct Method m)
    {
        return m.PkgPath == "";
    }

    std::string String(Kind k)
    {
        if((unsigned int)(k) < (unsigned int)(len(kindNames)))
        {
            return kindNames[(unsigned int)(k)];
        }
        return "kind" + strconv::Itoa(int(k));
    }

    gocpp::slice<std::string> kindNames = gocpp::Init<gocpp::slice<std::string>>([](gocpp::slice<std::string>& x) { x.Invalid = "invalid"; x.Bool = "bool"; x.Int = "int"; x.Int8 = "int8"; x.Int16 = "int16"; x.Int32 = "int32"; x.Int64 = "int64"; x.Uint = "uint"; x.Uint8 = "uint8"; x.Uint16 = "uint16"; x.Uint32 = "uint32"; x.Uint64 = "uint64"; x.Uintptr = "uintptr"; x.Float32 = "float32"; x.Float64 = "float64"; x.Complex64 = "complex64"; x.Complex128 = "complex128"; x.Array = "array"; x.Chan = "chan"; x.Func = "func"; x.Interface = "interface"; x.Map = "map"; x.Pointer = "ptr"; x.Slice = "slice"; x.String = "string"; x.Struct = "struct"; x.UnsafePointer = "unsafe.Pointer"; });
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer resolveTextOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    int32_t addReflectOff(unsafe::Pointer ptr)
    /* convertBlockStmt, nil block */;

    aNameOff resolveReflectName(abi::Name n)
    {
        return aNameOff(addReflectOff(unsafe::Pointer(n->Bytes)));
    }

    aTypeOff resolveReflectType(abi::Type* t)
    {
        return aTypeOff(addReflectOff(unsafe::Pointer(t)));
    }

    aTextOff resolveReflectText(unsafe::Pointer ptr)
    {
        return aTextOff(addReflectOff(ptr));
    }

    abi::Name nameOff(struct rtype* t, aNameOff off)
    {
        return gocpp::Init<abi::Name>([](abi::Name& x) { x.Bytes = (unsigned char*)(resolveNameOff(unsafe::Pointer(t), int32_t(off))); });
    }

    abi::Type* typeOff(struct rtype* t, aTypeOff off)
    {
        return (abi::Type*)(resolveTypeOff(unsafe::Pointer(t), int32_t(off)));
    }

    unsafe::Pointer textOff(struct rtype* t, aTextOff off)
    {
        return resolveTextOff(unsafe::Pointer(t), int32_t(off));
    }

    unsafe::Pointer textOffFor(abi::Type* t, aTextOff off)
    {
        return textOff(gocpp::recv(toRType(t)), off);
    }

    std::string String(struct rtype* t)
    {
        auto s = Name(gocpp::recv(nameOff(gocpp::recv(t), t->t.Str)));
        if(t->t.TFlag & abi::TFlagExtraStar != 0)
        {
            return s.make_slice(1);
        }
        return s;
    }

    uintptr_t Size(struct rtype* t)
    {
        return Size(gocpp::recv(t->t));
    }

    int Bits(struct rtype* t)
    {
        if(t == nullptr)
        {
            gocpp::panic("reflect: Bits of nil Type");
        }
        auto k = Kind(gocpp::recv(t));
        if(k < Int || k > Complex128)
        {
            gocpp::panic("reflect: Bits of non-arithmetic Type " + String(gocpp::recv(t)));
        }
        return int(t->t.Size_) * 8;
    }

    int Align(struct rtype* t)
    {
        return Align(gocpp::recv(t->t));
    }

    int FieldAlign(struct rtype* t)
    {
        return FieldAlign(gocpp::recv(t->t));
    }

    Kind Kind(struct rtype* t)
    {
        return Kind(Kind(gocpp::recv(t->t)));
    }

    gocpp::slice<abi::Method> exportedMethods(struct rtype* t)
    {
        auto ut = uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return nullptr;
        }
        return ExportedMethods(gocpp::recv(ut));
    }

    int NumMethod(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) == Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return NumMethod(gocpp::recv(tt));
        }
        return len(exportedMethods(gocpp::recv(t)));
    }

    Method Method(struct rtype* t, int i)
    {
        Method m;
        if(Kind(gocpp::recv(t)) == Interface)
        {
            Method m;
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return Method(gocpp::recv(tt), i);
        }
        auto methods = exportedMethods(gocpp::recv(t));
        if(i < 0 || i >= len(methods))
        {
            Method m;
            gocpp::panic("reflect: Method index out of range");
        }
        auto p = methods[i];
        auto pname = nameOff(gocpp::recv(t), p.Name);
        m.Name = Name(gocpp::recv(pname));
        auto fl = flag(Func);
        auto mtyp = typeOff(gocpp::recv(t), p.Mtyp);
        auto ft = (funcType*)(unsafe::Pointer(mtyp));
        auto in = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), 0, 1 + NumIn(gocpp::recv(ft)));
        in = append(in, t);
        for(auto [_, arg] : InSlice(gocpp::recv(ft)))
        {
            Method m;
            in = append(in, toRType(arg));
        }
        auto out = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), 0, NumOut(gocpp::recv(ft)));
        for(auto [_, ret] : OutSlice(gocpp::recv(ft)))
        {
            Method m;
            out = append(out, toRType(ret));
        }
        auto mt = FuncOf(in, out, IsVariadic(gocpp::recv(ft)));
        m.Type = mt;
        auto tfn = textOff(gocpp::recv(t), p.Tfn);
        auto fn = unsafe::Pointer(& tfn);
        m.Func = Value {& gocpp::getValue<rtype*>(mt)->t, fn, fl};
        m.Index = i;
        return m;
    }

    std::tuple<Method, bool> MethodByName(struct rtype* t, std::string name)
    {
        Method m;
        bool ok;
        if(Kind(gocpp::recv(t)) == Interface)
        {
            Method m;
            bool ok;
            auto tt = (interfaceType*)(unsafe::Pointer(t));
            return MethodByName(gocpp::recv(tt), name);
        }
        auto ut = uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            Method m;
            bool ok;
            return {Method {}, false};
        }
        auto methods = ExportedMethods(gocpp::recv(ut));
        auto [i, j] = std::tuple{0, len(methods)};
        for(; i < j; )
        {
            Method m;
            bool ok;
            auto h = int((unsigned int)(i + j) >> 1);
            if(! (Name(gocpp::recv(nameOff(gocpp::recv(t), methods[h].Name))) >= name))
            {
                Method m;
                bool ok;
                i = h + 1;
            }
            else
            {
                Method m;
                bool ok;
                j = h;
            }
        }
        if(i < len(methods) && name == Name(gocpp::recv(nameOff(gocpp::recv(t), methods[i].Name))))
        {
            Method m;
            bool ok;
            return {Method(gocpp::recv(t), i), true};
        }
        return {Method {}, false};
    }

    std::string PkgPath(struct rtype* t)
    {
        if(t->t.TFlag & abi::TFlagNamed == 0)
        {
            return "";
        }
        auto ut = uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return "";
        }
        return Name(gocpp::recv(nameOff(gocpp::recv(t), ut->PkgPath)));
    }

    std::string pkgPathFor(abi::Type* t)
    {
        return PkgPath(gocpp::recv(toRType(t)));
    }

    std::string Name(struct rtype* t)
    {
        if(! HasName(gocpp::recv(t->t)))
        {
            return "";
        }
        auto s = String(gocpp::recv(t));
        auto i = len(s) - 1;
        auto sqBrackets = 0;
        for(; i >= 0 && (s[i] != '.' || sqBrackets != 0); )
        {
            //Go switch emulation
            {
                auto condition = s[i];
                int conditionId = -1;
                if(condition == ']') { conditionId = 0; }
                else if(condition == '[') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        sqBrackets++;
                        break;
                    case 1:
                        sqBrackets--;
                        break;
                }
            }
            i--;
        }
        return s.make_slice(i + 1);
    }

    std::string nameFor(abi::Type* t)
    {
        return Name(gocpp::recv(toRType(t)));
    }

    ChanDir ChanDir(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Chan)
        {
            gocpp::panic("reflect: ChanDir of non-chan type " + String(gocpp::recv(t)));
        }
        auto tt = (abi::ChanType*)(unsafe::Pointer(t));
        return ChanDir(tt->Dir);
    }

    rtype* toRType(abi::Type* t)
    {
        return (rtype*)(unsafe::Pointer(t));
    }

    abi::Type* elem(abi::Type* t)
    {
        auto et = Elem(gocpp::recv(t));
        if(et != nullptr)
        {
            return et;
        }
        gocpp::panic("reflect: Elem of invalid type " + stringFor(t));
    }

    Type Elem(struct rtype* t)
    {
        return toType(elem(common(gocpp::recv(t))));
    }

    StructField Field(struct rtype* t, int i)
    {
        if(Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: Field of non-struct type " + String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return Field(gocpp::recv(tt), i);
    }

    StructField FieldByIndex(struct rtype* t, gocpp::slice<int> index)
    {
        if(Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByIndex of non-struct type " + String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return FieldByIndex(gocpp::recv(tt), index);
    }

    std::tuple<StructField, bool> FieldByName(struct rtype* t, std::string name)
    {
        if(Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByName of non-struct type " + String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return FieldByName(gocpp::recv(tt), name);
    }

    std::tuple<StructField, bool> FieldByNameFunc(struct rtype* t, std::function<bool (std::string)> match)
    {
        if(Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: FieldByNameFunc of non-struct type " + String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return FieldByNameFunc(gocpp::recv(tt), match);
    }

    Type Key(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Map)
        {
            gocpp::panic("reflect: Key of non-map type " + String(gocpp::recv(t)));
        }
        auto tt = (mapType*)(unsafe::Pointer(t));
        return toType(tt->Key);
    }

    int Len(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Array)
        {
            gocpp::panic("reflect: Len of non-array type " + String(gocpp::recv(t)));
        }
        auto tt = (arrayType*)(unsafe::Pointer(t));
        return int(tt->Len);
    }

    int NumField(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Struct)
        {
            gocpp::panic("reflect: NumField of non-struct type " + String(gocpp::recv(t)));
        }
        auto tt = (structType*)(unsafe::Pointer(t));
        return len(tt->Fields);
    }

    Type In(struct rtype* t, int i)
    {
        if(Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: In of non-func type " + String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return toType(InSlice(gocpp::recv(tt))[i]);
    }

    int NumIn(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: NumIn of non-func type " + String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return NumIn(gocpp::recv(tt));
    }

    int NumOut(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: NumOut of non-func type " + String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return NumOut(gocpp::recv(tt));
    }

    Type Out(struct rtype* t, int i)
    {
        if(Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: Out of non-func type " + String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return toType(OutSlice(gocpp::recv(tt))[i]);
    }

    bool IsVariadic(struct rtype* t)
    {
        if(Kind(gocpp::recv(t)) != Func)
        {
            gocpp::panic("reflect: IsVariadic of non-func type " + String(gocpp::recv(t)));
        }
        auto tt = (abi::FuncType*)(unsafe::Pointer(t));
        return IsVariadic(gocpp::recv(tt));
    }

    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    std::string String(ChanDir d)
    {
        //Go switch emulation
        {
            auto condition = d;
            int conditionId = -1;
            if(condition == SendDir) { conditionId = 0; }
            else if(condition == RecvDir) { conditionId = 1; }
            else if(condition == BothDir) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return "chan<-";
                    break;
                case 1:
                    return "<-chan";
                    break;
                case 2:
                    return "chan";
                    break;
            }
        }
        return "ChanDir" + strconv::Itoa(int(d));
    }

    Method Method(struct interfaceType* t, int i)
    {
        Method m;
        if(i < 0 || i >= len(t->Methods))
        {
            Method m;
            return m;
        }
        auto p = & t->Methods[i];
        auto pname = nameOff(gocpp::recv(t), p->Name);
        m.Name = Name(gocpp::recv(pname));
        if(! IsExported(gocpp::recv(pname)))
        {
            Method m;
            m.PkgPath = pkgPath(pname);
            if(m.PkgPath == "")
            {
                Method m;
                m.PkgPath = Name(gocpp::recv(t->PkgPath));
            }
        }
        m.Type = toType(typeOff(gocpp::recv(t), p->Typ));
        m.Index = i;
        return m;
    }

    int NumMethod(struct interfaceType* t)
    {
        return len(t->Methods);
    }

    std::tuple<Method, bool> MethodByName(struct interfaceType* t, std::string name)
    {
        Method m;
        bool ok;
        if(t == nullptr)
        {
            Method m;
            bool ok;
            return {m, ok};
        }
        abi::Imethod* p = {};
        for(auto [i, gocpp_ignored] : t->Methods)
        {
            Method m;
            bool ok;
            p = & t->Methods[i];
            if(Name(gocpp::recv(nameOff(gocpp::recv(t), p->Name))) == name)
            {
                Method m;
                bool ok;
                return {Method(gocpp::recv(t), i), true};
            }
        }
        return {m, ok};
    }

    
    std::ostream& StructField::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << PkgPath;
        os << " " << Type;
        os << " " << Tag;
        os << " " << Offset;
        os << " " << Index;
        os << " " << Anonymous;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StructField& value)
    {
        return value.PrintTo(os);
    }

    bool IsExported(struct StructField f)
    {
        return f.PkgPath == "";
    }

    std::string Get(StructTag tag, std::string key)
    {
        auto [v, gocpp_id_1] = Lookup(gocpp::recv(tag), key);
        return v;
    }

    std::tuple<std::string, bool> Lookup(StructTag tag, std::string key)
    {
        std::string value;
        bool ok;
        for(; tag != ""; )
        {
            std::string value;
            bool ok;
            auto i = 0;
            for(; i < len(tag) && tag[i] == ' '; )
            {
                std::string value;
                bool ok;
                i++;
            }
            tag = tag.make_slice(i);
            if(tag == "")
            {
                std::string value;
                bool ok;
                break;
            }
            i = 0;
            for(; i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '"' && tag[i] != 0x7f; )
            {
                std::string value;
                bool ok;
                i++;
            }
            if(i == 0 || i + 1 >= len(tag) || tag[i] != ':' || tag[i + 1] != '"')
            {
                std::string value;
                bool ok;
                break;
            }
            auto name = string(tag.make_slice(0, i));
            tag = tag.make_slice(i + 1);
            i = 1;
            for(; i < len(tag) && tag[i] != '"'; )
            {
                std::string value;
                bool ok;
                if(tag[i] == '\\')
                {
                    std::string value;
                    bool ok;
                    i++;
                }
                i++;
            }
            if(i >= len(tag))
            {
                std::string value;
                bool ok;
                break;
            }
            auto qvalue = string(tag.make_slice(0, i + 1));
            tag = tag.make_slice(i + 1);
            if(key == name)
            {
                std::string value;
                bool ok;
                auto [value, err] = strconv::Unquote(qvalue);
                if(err != nullptr)
                {
                    std::string value;
                    bool ok;
                    break;
                }
                return {value, true};
            }
        }
        return {"", false};
    }

    StructField Field(struct structType* t, int i)
    {
        StructField f;
        if(i < 0 || i >= len(t->Fields))
        {
            StructField f;
            gocpp::panic("reflect: Field index out of bounds");
        }
        auto p = & t->Fields[i];
        f.Type = toType(p->Typ);
        f.Name = Name(gocpp::recv(p->Name));
        f.Anonymous = Embedded(gocpp::recv(p));
        if(! IsExported(gocpp::recv(p->Name)))
        {
            StructField f;
            f.PkgPath = Name(gocpp::recv(t->PkgPath));
        }
        if(auto tag = Tag(gocpp::recv(p->Name)); tag != "")
        {
            StructField f;
            f.Tag = StructTag(tag);
        }
        f.Offset = p->Offset;
        f.Index = gocpp::slice<int> {i};
        return f;
    }

    StructField FieldByIndex(struct structType* t, gocpp::slice<int> index)
    {
        StructField f;
        f.Type = toType(& t->Type);
        for(auto [i, x] : index)
        {
            StructField f;
            if(i > 0)
            {
                StructField f;
                auto ft = f.Type;
                if(Kind(gocpp::recv(ft)) == Pointer && Kind(gocpp::recv(Elem(gocpp::recv(ft)))) == Struct)
                {
                    StructField f;
                    ft = Elem(gocpp::recv(ft));
                }
                f.Type = ft;
            }
            f = Field(gocpp::recv(f.Type), x);
        }
        return f;
    }

    
    std::ostream& fieldScan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fieldScan& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<StructField, bool> FieldByNameFunc(struct structType* t, std::function<bool (std::string)> match)
    {
        StructField result;
        bool ok;
        auto current = gocpp::slice<fieldScan> {};
        auto next = gocpp::slice<fieldScan> {gocpp::Init<>([](& x) { x.typ = t; })};
        gocpp::map<structType*, int> nextCount = {};
        auto visited = gocpp::map<structType*, bool> {};
        for(; len(next) > 0; )
        {
            StructField result;
            bool ok;
            std::tie(current, next) = std::tuple{next, current.make_slice(0, 0)};
            auto count = nextCount;
            nextCount = nullptr;
            for(auto [_, scan] : current)
            {
                StructField result;
                bool ok;
                auto t = scan.typ;
                if(visited[t])
                {
                    StructField result;
                    bool ok;
                    continue;
                }
                visited[t] = true;
                for(auto [i, gocpp_ignored] : t->Fields)
                {
                    StructField result;
                    bool ok;
                    auto f = & t->Fields[i];
                    auto fname = Name(gocpp::recv(f->Name));
                    abi::Type* ntyp = {};
                    if(Embedded(gocpp::recv(f)))
                    {
                        StructField result;
                        bool ok;
                        ntyp = f->Typ;
                        if(Kind(gocpp::recv(ntyp)) == abi::Pointer)
                        {
                            StructField result;
                            bool ok;
                            ntyp = Elem(gocpp::recv(ntyp));
                        }
                    }
                    if(match(fname))
                    {
                        StructField result;
                        bool ok;
                        if(count[t] > 1 || ok)
                        {
                            StructField result;
                            bool ok;
                            return {StructField {}, false};
                        }
                        result = Field(gocpp::recv(t), i);
                        result.Index = nullptr;
                        result.Index = append(result.Index, scan.index);
                        result.Index = append(result.Index, i);
                        ok = true;
                        continue;
                    }
                    if(ok || ntyp == nullptr || Kind(gocpp::recv(ntyp)) != abi::Struct)
                    {
                        StructField result;
                        bool ok;
                        continue;
                    }
                    auto styp = (structType*)(unsafe::Pointer(ntyp));
                    if(nextCount[styp] > 0)
                    {
                        StructField result;
                        bool ok;
                        nextCount[styp] = 2;
                        continue;
                    }
                    if(nextCount == nullptr)
                    {
                        StructField result;
                        bool ok;
                        nextCount = gocpp::map<structType*, int> {};
                    }
                    nextCount[styp] = 1;
                    if(count[t] > 1)
                    {
                        StructField result;
                        bool ok;
                        nextCount[styp] = 2;
                    }
                    gocpp::slice<int> index = {};
                    index = append(index, scan.index);
                    index = append(index, i);
                    next = append(next, fieldScan {styp, index});
                }
            }
            if(ok)
            {
                StructField result;
                bool ok;
                break;
            }
        }
        return {result, ok};
    }

    std::tuple<StructField, bool> FieldByName(struct structType* t, std::string name)
    {
        StructField f;
        bool present;
        auto hasEmbeds = false;
        if(name != "")
        {
            StructField f;
            bool present;
            for(auto [i, gocpp_ignored] : t->Fields)
            {
                StructField f;
                bool present;
                auto tf = & t->Fields[i];
                if(Name(gocpp::recv(tf->Name)) == name)
                {
                    StructField f;
                    bool present;
                    return {Field(gocpp::recv(t), i), true};
                }
                if(Embedded(gocpp::recv(tf)))
                {
                    StructField f;
                    bool present;
                    hasEmbeds = true;
                }
            }
        }
        if(! hasEmbeds)
        {
            StructField f;
            bool present;
            return {f, present};
        }
        return FieldByNameFunc(gocpp::recv(t), [=](std::string s) mutable -> bool
        {
            return s == name;
        }
);
    }

    Type TypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return toType((abi::Type*)(noescape(unsafe::Pointer(eface.typ))));
    }

    abi::Type* rtypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return eface.typ;
    }

    sync::Map ptrMap;
    Type PtrTo(Type t)
    {
        return PointerTo(t);
    }

    Type PointerTo(Type t)
    {
        return toRType(ptrTo(gocpp::recv(gocpp::getValue<rtype*>(t))));
    }

    abi::Type* ptrTo(struct rtype* t)
    {
        auto at = & t->t;
        if(at->PtrToThis != 0)
        {
            return typeOff(gocpp::recv(t), at->PtrToThis);
        }
        if(auto [pi, ok] = Load(gocpp::recv(ptrMap), t); ok)
        {
            return & gocpp::getValue<ptrType*>(pi)->Type;
        }
        auto s = "*" + String(gocpp::recv(t));
        for(auto [_, tt] : typesByString(s))
        {
            auto p = (ptrType*)(unsafe::Pointer(tt));
            if(p->Elem != & t->t)
            {
                continue;
            }
            auto [pi, gocpp_id_3] = LoadOrStore(gocpp::recv(ptrMap), t, p);
            return & gocpp::getValue<ptrType*>(pi)->Type;
        }
        go_any iptr = (unsafe::Pointer*)(nullptr);
        auto prototype = *(ptrType**)(unsafe::Pointer(& iptr));
        auto pp = *prototype;
        pp.Str = resolveReflectName(newName(s, "", false, false));
        pp.PtrToThis = 0;
        pp.Hash = fnv1(t->t.Hash, '*');
        pp.Elem = at;
        auto [pi, gocpp_id_5] = LoadOrStore(gocpp::recv(ptrMap), t, & pp);
        return & gocpp::getValue<ptrType*>(pi)->Type;
    }

    abi::Type* ptrTo(abi::Type* t)
    {
        return ptrTo(gocpp::recv(toRType(t)));
    }

    uint32_t fnv1(uint32_t x, gocpp::slice<unsigned char> list)
    {
        for(auto [_, b] : list)
        {
            x = x * 16777619 ^ uint32_t(b);
        }
        return x;
    }

    bool Implements(struct rtype* t, Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.Implements");
        }
        if(Kind(gocpp::recv(u)) != Interface)
        {
            gocpp::panic("reflect: non-interface type passed to Type.Implements");
        }
        return implements(common(gocpp::recv(u)), common(gocpp::recv(t)));
    }

    bool AssignableTo(struct rtype* t, Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.AssignableTo");
        }
        auto uu = common(gocpp::recv(u));
        return directlyAssignable(uu, common(gocpp::recv(t))) || implements(uu, common(gocpp::recv(t)));
    }

    bool ConvertibleTo(struct rtype* t, Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.ConvertibleTo");
        }
        return convertOp(common(gocpp::recv(u)), common(gocpp::recv(t))) != nullptr;
    }

    bool Comparable(struct rtype* t)
    {
        return t->t.Equal != nullptr;
    }

    bool implements(abi::Type* T, abi::Type* V)
    {
        if(Kind(gocpp::recv(T)) != abi::Interface)
        {
            return false;
        }
        auto t = (interfaceType*)(unsafe::Pointer(T));
        if(len(t->Methods) == 0)
        {
            return true;
        }
        if(Kind(gocpp::recv(V)) == abi::Interface)
        {
            auto v = (interfaceType*)(unsafe::Pointer(V));
            auto i = 0;
            for(auto j = 0; j < len(v->Methods); j++)
            {
                auto tm = & t->Methods[i];
                auto tmName = nameOff(gocpp::recv(t), tm->Name);
                auto vm = & v->Methods[j];
                auto vmName = nameOffFor(V, vm->Name);
                if(Name(gocpp::recv(vmName)) == Name(gocpp::recv(tmName)) && typeOffFor(V, vm->Typ) == typeOff(gocpp::recv(t), tm->Typ))
                {
                    if(! IsExported(gocpp::recv(tmName)))
                    {
                        auto tmPkgPath = pkgPath(tmName);
                        if(tmPkgPath == "")
                        {
                            tmPkgPath = Name(gocpp::recv(t->PkgPath));
                        }
                        auto vmPkgPath = pkgPath(vmName);
                        if(vmPkgPath == "")
                        {
                            vmPkgPath = Name(gocpp::recv(v->PkgPath));
                        }
                        if(tmPkgPath != vmPkgPath)
                        {
                            continue;
                        }
                    }
                    if(i++; i >= len(t->Methods))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        auto v = Uncommon(gocpp::recv(V));
        if(v == nullptr)
        {
            return false;
        }
        auto i = 0;
        auto vmethods = Methods(gocpp::recv(v));
        for(auto j = 0; j < int(v->Mcount); j++)
        {
            auto tm = & t->Methods[i];
            auto tmName = nameOff(gocpp::recv(t), tm->Name);
            auto vm = vmethods[j];
            auto vmName = nameOffFor(V, vm.Name);
            if(Name(gocpp::recv(vmName)) == Name(gocpp::recv(tmName)) && typeOffFor(V, vm.Mtyp) == typeOff(gocpp::recv(t), tm->Typ))
            {
                if(! IsExported(gocpp::recv(tmName)))
                {
                    auto tmPkgPath = pkgPath(tmName);
                    if(tmPkgPath == "")
                    {
                        tmPkgPath = Name(gocpp::recv(t->PkgPath));
                    }
                    auto vmPkgPath = pkgPath(vmName);
                    if(vmPkgPath == "")
                    {
                        vmPkgPath = Name(gocpp::recv(nameOffFor(V, v->PkgPath)));
                    }
                    if(tmPkgPath != vmPkgPath)
                    {
                        continue;
                    }
                }
                if(i++; i >= len(t->Methods))
                {
                    return true;
                }
            }
        }
        return false;
    }

    bool specialChannelAssignability(abi::Type* T, abi::Type* V)
    {
        return ChanDir(gocpp::recv(V)) == abi::BothDir && (nameFor(T) == "" || nameFor(V) == "") && haveIdenticalType(Elem(gocpp::recv(T)), Elem(gocpp::recv(V)), true);
    }

    bool directlyAssignable(abi::Type* T, abi::Type* V)
    {
        if(T == V)
        {
            return true;
        }
        if(HasName(gocpp::recv(T)) && HasName(gocpp::recv(V)) || Kind(gocpp::recv(T)) != Kind(gocpp::recv(V)))
        {
            return false;
        }
        if(Kind(gocpp::recv(T)) == abi::Chan && specialChannelAssignability(T, V))
        {
            return true;
        }
        return haveIdenticalUnderlyingType(T, V, true);
    }

    bool haveIdenticalType(abi::Type* T, abi::Type* V, bool cmpTags)
    {
        if(cmpTags)
        {
            return T == V;
        }
        if(nameFor(T) != nameFor(V) || Kind(gocpp::recv(T)) != Kind(gocpp::recv(V)) || pkgPathFor(T) != pkgPathFor(V))
        {
            return false;
        }
        return haveIdenticalUnderlyingType(T, V, false);
    }

    bool haveIdenticalUnderlyingType(abi::Type* T, abi::Type* V, bool cmpTags)
    {
        if(T == V)
        {
            return true;
        }
        auto kind = Kind(Kind(gocpp::recv(T)));
        if(kind != Kind(Kind(gocpp::recv(V))))
        {
            return false;
        }
        if(Bool <= kind && kind <= Complex128 || kind == String || kind == UnsafePointer)
        {
            return true;
        }
        //Go switch emulation
        {
            auto condition = kind;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Func) { conditionId = 2; }
            else if(condition == Interface) { conditionId = 3; }
            else if(condition == Map) { conditionId = 4; }
            else if(condition == Pointer) { conditionId = 5; }
            else if(condition == Slice) { conditionId = 6; }
            else if(condition == Struct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return Len(gocpp::recv(T)) == Len(gocpp::recv(V)) && haveIdenticalType(Elem(gocpp::recv(T)), Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 1:
                    return ChanDir(gocpp::recv(V)) == ChanDir(gocpp::recv(T)) && haveIdenticalType(Elem(gocpp::recv(T)), Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 2:
                    auto t = (funcType*)(unsafe::Pointer(T));
                    auto v = (funcType*)(unsafe::Pointer(V));
                    if(t->OutCount != v->OutCount || t->InCount != v->InCount)
                    {
                        return false;
                    }
                    for(auto i = 0; i < NumIn(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(In(gocpp::recv(t), i), In(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    for(auto i = 0; i < NumOut(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(Out(gocpp::recv(t), i), Out(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 3:
                    auto t = (interfaceType*)(unsafe::Pointer(T));
                    auto v = (interfaceType*)(unsafe::Pointer(V));
                    if(len(t->Methods) == 0 && len(v->Methods) == 0)
                    {
                        return true;
                    }
                    return false;
                    break;
                case 4:
                    return haveIdenticalType(Key(gocpp::recv(T)), Key(gocpp::recv(V)), cmpTags) && haveIdenticalType(Elem(gocpp::recv(T)), Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 5:
                case 6:
                    return haveIdenticalType(Elem(gocpp::recv(T)), Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 7:
                    auto t = (structType*)(unsafe::Pointer(T));
                    auto v = (structType*)(unsafe::Pointer(V));
                    if(len(t->Fields) != len(v->Fields))
                    {
                        return false;
                    }
                    if(Name(gocpp::recv(t->PkgPath)) != Name(gocpp::recv(v->PkgPath)))
                    {
                        return false;
                    }
                    for(auto [i, gocpp_ignored] : t->Fields)
                    {
                        auto tf = & t->Fields[i];
                        auto vf = & v->Fields[i];
                        if(Name(gocpp::recv(tf->Name)) != Name(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(! haveIdenticalType(tf->Typ, vf->Typ, cmpTags))
                        {
                            return false;
                        }
                        if(cmpTags && Tag(gocpp::recv(tf->Name)) != Tag(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(tf->Offset != vf->Offset)
                        {
                            return false;
                        }
                        if(Embedded(gocpp::recv(tf)) != Embedded(gocpp::recv(vf)))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
            }
        }
        return false;
    }

    std::tuple<gocpp::slice<unsafe::Pointer>, gocpp::slice<gocpp::slice<int32_t>>> typelinks()
    /* convertBlockStmt, nil block */;

    abi::Type* rtypeOff(unsafe::Pointer section, int32_t off)
    {
        return (abi::Type*)(add(section, uintptr_t(off), "sizeof(rtype) > 0"));
    }

    gocpp::slice<abi::Type*> typesByString(std::string s)
    {
        auto [sections, offset] = typelinks();
        gocpp::slice<abi::Type*> ret = {};
        for(auto [offsI, offs] : offset)
        {
            auto section = sections[offsI];
            auto [i, j] = std::tuple{0, len(offs)};
            for(; i < j; )
            {
                auto h = int((unsigned int)(i + j) >> 1);
                if(! (stringFor(rtypeOff(section, offs[h])) >= s))
                {
                    i = h + 1;
                }
                else
                {
                    j = h;
                }
            }
            for(auto j = i; j < len(offs); j++)
            {
                auto typ = rtypeOff(section, offs[j]);
                if(stringFor(typ) != s)
                {
                    break;
                }
                ret = append(ret, typ);
            }
        }
        return ret;
    }

    sync::Map lookupCache;
    
    std::ostream& cacheKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << t1;
        os << " " << t2;
        os << " " << extra;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cacheKey& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_6
    {
        sync::Map m;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << m;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_6 funcLookupCache;
    Type ChanOf(ChanDir dir, Type t)
    {
        auto typ = common(gocpp::recv(t));
        auto ckey = cacheKey {Chan, typ, nullptr, uintptr_t(dir)};
        if(auto [ch, ok] = Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<rtype*>(ch);
        }
        if(typ->Size_ >= (1 << 16))
        {
            gocpp::panic("reflect.ChanOf: element size too large");
        }
        std::string s = {};
        //Go switch emulation
        {
            auto condition = dir;
            int conditionId = -1;
            else if(condition == SendDir) { conditionId = 0; }
            else if(condition == RecvDir) { conditionId = 1; }
            else if(condition == BothDir) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    gocpp::panic("reflect.ChanOf: invalid dir");
                    break;
                case 0:
                    s = "chan<- " + stringFor(typ);
                    break;
                case 1:
                    s = "<-chan " + stringFor(typ);
                    break;
                case 2:
                    auto typeStr = stringFor(typ);
                    if(typeStr[0] == '<')
                    {
                        s = "chan (" + typeStr + ")";
                    }
                    else
                    {
                        s = "chan " + typeStr;
                    }
                    break;
            }
        }
        for(auto [_, tt] : typesByString(s))
        {
            auto ch = (chanType*)(unsafe::Pointer(tt));
            if(ch->Elem == typ && ch->Dir == abi::ChanDir(dir))
            {
                auto [ti, gocpp_id_8] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any ichan = (gocpp::channel<&{unsafe Pointer}>)(nullptr);
        auto prototype = *(chanType**)(unsafe::Pointer(& ichan));
        auto ch = *prototype;
        ch.TFlag = abi::TFlagRegularMemory;
        ch.Dir = abi::ChanDir(dir);
        ch.Str = resolveReflectName(newName(s, "", false, false));
        ch.Hash = fnv1(typ->Hash, 'c', unsigned char(dir));
        ch.Elem = typ;
        auto [ti, gocpp_id_10] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& ch.Type));
        return gocpp::getValue<Type>(ti);
    }

    Type MapOf(Type key, Type elem)
    {
        auto ktyp = common(gocpp::recv(key));
        auto etyp = common(gocpp::recv(elem));
        if(ktyp->Equal == nullptr)
        {
            gocpp::panic("reflect.MapOf: invalid key type " + stringFor(ktyp));
        }
        auto ckey = cacheKey {Map, ktyp, etyp, 0};
        if(auto [mt, ok] = Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(mt);
        }
        auto s = "map[" + stringFor(ktyp) + "]" + stringFor(etyp);
        for(auto [_, tt] : typesByString(s))
        {
            auto mt = (mapType*)(unsafe::Pointer(tt));
            if(mt->Key == ktyp && mt->Elem == etyp)
            {
                auto [ti, gocpp_id_12] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any imap = (gocpp::map<unsafe::Pointer, unsafe::Pointer>)(nullptr);
        auto mt = **(mapType**)(unsafe::Pointer(& imap));
        mt.Str = resolveReflectName(newName(s, "", false, false));
        mt.TFlag = 0;
        mt.Hash = fnv1(etyp->Hash, 'm', unsigned char(ktyp->Hash >> 24), unsigned char(ktyp->Hash >> 16), unsigned char(ktyp->Hash >> 8), unsigned char(ktyp->Hash));
        mt.Key = ktyp;
        mt.Elem = etyp;
        mt.Bucket = bucketOf(ktyp, etyp);
        mt.Hasher = [=](unsafe::Pointer p, uintptr_t seed) mutable -> uintptr_t
        {
            return typehash(ktyp, p, seed);
        }
;
        mt.Flags = 0;
        if(ktyp->Size_ > maxKeySize)
        {
            mt.KeySize = uint8_t(goarch::PtrSize);
            mt.Flags |= 1;
        }
        else
        {
            mt.KeySize = uint8_t(ktyp->Size_);
        }
        if(etyp->Size_ > maxValSize)
        {
            mt.ValueSize = uint8_t(goarch::PtrSize);
            mt.Flags |= 2;
        }
        else
        {
            mt.MapType.ValueSize = uint8_t(etyp->Size_);
        }
        mt.MapType.BucketSize = uint16_t(mt.Bucket->Size_);
        if(isReflexive(ktyp))
        {
            mt.Flags |= 4;
        }
        if(needKeyUpdate(ktyp))
        {
            mt.Flags |= 8;
        }
        if(hashMightPanic(ktyp))
        {
            mt.Flags |= 16;
        }
        mt.PtrToThis = 0;
        auto [ti, gocpp_id_14] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& mt.Type));
        return gocpp::getValue<Type>(ti);
    }

    gocpp::slice<Type> funcTypes;
    mocklib::Mutex funcTypesMutex;
    Type initFuncTypes(int n)
    {
        gocpp::Defer defer;
        Lock(gocpp::recv(funcTypesMutex));
        defer.push_back([=]{ Unlock(gocpp::recv(funcTypesMutex)); });
        if(n >= len(funcTypes))
        {
            auto newFuncTypes = gocpp::make(gocpp::Tag<gocpp::slice<Type>>(), n + 1);
            copy(newFuncTypes, funcTypes);
            funcTypes = newFuncTypes;
        }
        if(funcTypes[n] != nullptr)
        {
            return funcTypes[n];
        }
        funcTypes[n] = StructOf(gocpp::slice<StructField> {gocpp::Init<>([](& x) { x.Name = "FuncType"; x.Type = TypeOf(funcType {}); }), gocpp::Init<>([](& x) { x.Name = "Args"; x.Type = ArrayOf(n, TypeOf(new rtype {})); })});
        return funcTypes[n];
    }

    Type FuncOf(gocpp::slice<Type> in, gocpp::slice<Type> out, bool variadic)
    {
        gocpp::Defer defer;
        if(variadic && (len(in) == 0 || Kind(gocpp::recv(in[len(in) - 1])) != Slice))
        {
            gocpp::panic("reflect.FuncOf: last arg of variadic func must be slice");
        }
        go_any ifunc = (std::function<void ()>)(nullptr);
        auto prototype = *(funcType**)(unsafe::Pointer(& ifunc));
        auto n = len(in) + len(out);
        if(n > 128)
        {
            gocpp::panic("reflect.FuncOf: too many arguments");
        }
        auto o = Elem(gocpp::recv(New(initFuncTypes(n))));
        auto ft = (funcType*)(unsafe::Pointer(Pointer(gocpp::recv(Addr(gocpp::recv(Field(gocpp::recv(o), 0)))))));
        auto args = unsafe::Slice((rtype**)(unsafe::Pointer(Pointer(gocpp::recv(Addr(gocpp::recv(Field(gocpp::recv(o), 1))))))), n).make_slice(0, 0, n);
        *ft = *prototype;
        uint32_t hash = {};
        for(auto [_, in] : in)
        {
            auto t = gocpp::getValue<rtype*>(in);
            args = append(args, t);
            hash = fnv1(hash, unsigned char(t->t.Hash >> 24), unsigned char(t->t.Hash >> 16), unsigned char(t->t.Hash >> 8), unsigned char(t->t.Hash));
        }
        if(variadic)
        {
            hash = fnv1(hash, 'v');
        }
        hash = fnv1(hash, '.');
        for(auto [_, out] : out)
        {
            auto t = gocpp::getValue<rtype*>(out);
            args = append(args, t);
            hash = fnv1(hash, unsigned char(t->t.Hash >> 24), unsigned char(t->t.Hash >> 16), unsigned char(t->t.Hash >> 8), unsigned char(t->t.Hash));
        }
        ft->TFlag = 0;
        ft->Hash = hash;
        ft->InCount = uint16_t(len(in));
        ft->OutCount = uint16_t(len(out));
        if(variadic)
        {
            ft->OutCount |= 1 << 15;
        }
        if(auto [ts, ok] = Load(gocpp::recv(funcLookupCache.m), hash); ok)
        {
            for(auto [_, t] : gocpp::getValue<abi::Type>>(ts))
            {
                if(haveIdenticalUnderlyingType(& ft->Type, t, true))
                {
                    return toRType(t);
                }
            }
        }
        Lock(gocpp::recv(funcLookupCache));
        defer.push_back([=]{ Unlock(gocpp::recv(funcLookupCache)); });
        if(auto [ts, ok] = Load(gocpp::recv(funcLookupCache.m), hash); ok)
        {
            for(auto [_, t] : gocpp::getValue<abi::Type>>(ts))
            {
                if(haveIdenticalUnderlyingType(& ft->Type, t, true))
                {
                    return toRType(t);
                }
            }
        }
        auto addToCache = [=](abi::Type* tt) mutable -> Type
        {
            gocpp::slice<abi::Type*> rts = {};
            if(auto [rti, ok] = Load(gocpp::recv(funcLookupCache.m), hash); ok)
            {
                rts = gocpp::getValue<abi::Type>>(rti);
            }
            Store(gocpp::recv(funcLookupCache.m), hash, append(rts, tt));
            return toType(tt);
        }
;
        auto str = funcStr(ft);
        for(auto [_, tt] : typesByString(str))
        {
            if(haveIdenticalUnderlyingType(& ft->Type, tt, true))
            {
                return addToCache(tt);
            }
        }
        ft->Str = resolveReflectName(newName(str, "", false, false));
        ft->PtrToThis = 0;
        return addToCache(& ft->Type);
    }

    std::string stringFor(abi::Type* t)
    {
        return String(gocpp::recv(toRType(t)));
    }

    std::string funcStr(funcType* ft)
    {
        auto repr = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 64);
        repr = append(repr, "func(");
        for(auto [i, t] : InSlice(gocpp::recv(ft)))
        {
            if(i > 0)
            {
                repr = append(repr, ", ");
            }
            if(IsVariadic(gocpp::recv(ft)) && i == int(ft->InCount) - 1)
            {
                repr = append(repr, "...");
                repr = append(repr, stringFor((sliceType*)(unsafe::Pointer(t))->Elem));
            }
            else
            {
                repr = append(repr, stringFor(t));
            }
        }
        repr = append(repr, ')');
        auto out = OutSlice(gocpp::recv(ft));
        if(len(out) == 1)
        {
            repr = append(repr, ' ');
        }
        else
        if(len(out) > 1)
        {
            repr = append(repr, " (");
        }
        for(auto [i, t] : out)
        {
            if(i > 0)
            {
                repr = append(repr, ", ");
            }
            repr = append(repr, stringFor(t));
        }
        if(len(out) > 1)
        {
            repr = append(repr, ')');
        }
        return string(repr);
    }

    bool isReflexive(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            if(condition == Int) { conditionId = 1; }
            if(condition == Int8) { conditionId = 2; }
            if(condition == Int16) { conditionId = 3; }
            if(condition == Int32) { conditionId = 4; }
            if(condition == Int64) { conditionId = 5; }
            if(condition == Uint) { conditionId = 6; }
            if(condition == Uint8) { conditionId = 7; }
            if(condition == Uint16) { conditionId = 8; }
            if(condition == Uint32) { conditionId = 9; }
            if(condition == Uint64) { conditionId = 10; }
            if(condition == Uintptr) { conditionId = 11; }
            if(condition == Chan) { conditionId = 12; }
            if(condition == Pointer) { conditionId = 13; }
            if(condition == String) { conditionId = 14; }
            if(condition == UnsafePointer) { conditionId = 15; }
            else if(condition == Float32) { conditionId = 16; }
            else if(condition == Float64) { conditionId = 17; }
            else if(condition == Complex64) { conditionId = 18; }
            else if(condition == Complex128) { conditionId = 19; }
            else if(condition == Interface) { conditionId = 20; }
            else if(condition == Array) { conditionId = 21; }
            else if(condition == Struct) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    return true;
                    break;
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    return false;
                    break;
                case 21:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    return isReflexive(tt->Elem);
                    break;
                case 22:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [_, f] : tt->Fields)
                    {
                        if(! isReflexive(f.Typ))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                default:
                    gocpp::panic("isReflexive called on non-key type " + stringFor(t));
                    break;
            }
        }
    }

    bool needKeyUpdate(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            if(condition == Int) { conditionId = 1; }
            if(condition == Int8) { conditionId = 2; }
            if(condition == Int16) { conditionId = 3; }
            if(condition == Int32) { conditionId = 4; }
            if(condition == Int64) { conditionId = 5; }
            if(condition == Uint) { conditionId = 6; }
            if(condition == Uint8) { conditionId = 7; }
            if(condition == Uint16) { conditionId = 8; }
            if(condition == Uint32) { conditionId = 9; }
            if(condition == Uint64) { conditionId = 10; }
            if(condition == Uintptr) { conditionId = 11; }
            if(condition == Chan) { conditionId = 12; }
            if(condition == Pointer) { conditionId = 13; }
            if(condition == UnsafePointer) { conditionId = 14; }
            else if(condition == Float32) { conditionId = 15; }
            else if(condition == Float64) { conditionId = 16; }
            else if(condition == Complex64) { conditionId = 17; }
            else if(condition == Complex128) { conditionId = 18; }
            else if(condition == Interface) { conditionId = 19; }
            else if(condition == String) { conditionId = 20; }
            else if(condition == Array) { conditionId = 21; }
            else if(condition == Struct) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    return false;
                    break;
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    return true;
                    break;
                case 21:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    return needKeyUpdate(tt->Elem);
                    break;
                case 22:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [_, f] : tt->Fields)
                    {
                        if(needKeyUpdate(f.Typ))
                        {
                            return true;
                        }
                    }
                    return false;
                    break;
                default:
                    gocpp::panic("needKeyUpdate called on non-key type " + stringFor(t));
                    break;
            }
        }
    }

    bool hashMightPanic(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(Kind(gocpp::recv(t)));
            int conditionId = -1;
            if(condition == Interface) { conditionId = 0; }
            else if(condition == Array) { conditionId = 1; }
            else if(condition == Struct) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return true;
                    break;
                case 1:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    return hashMightPanic(tt->Elem);
                    break;
                case 2:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [_, f] : tt->Fields)
                    {
                        if(hashMightPanic(f.Typ))
                        {
                            return true;
                        }
                    }
                    return false;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    abi::Type* bucketOf(abi::Type* ktyp, abi::Type* etyp)
    {
        if(ktyp->Size_ > maxKeySize)
        {
            ktyp = ptrTo(ktyp);
        }
        if(etyp->Size_ > maxValSize)
        {
            etyp = ptrTo(etyp);
        }
        unsigned char* gcdata = {};
        uintptr_t ptrdata = {};
        auto size = bucketSize * (1 + ktyp->Size_ + etyp->Size_) + goarch::PtrSize;
        if(size & uintptr_t(ktyp->Align_ - 1) != 0 || size & uintptr_t(etyp->Align_ - 1) != 0)
        {
            gocpp::panic("reflect: bad size computation in MapOf");
        }
        if(ktyp->PtrBytes != 0 || etyp->PtrBytes != 0)
        {
            auto nptr = (bucketSize * (1 + ktyp->Size_ + etyp->Size_) + goarch::PtrSize) / goarch::PtrSize;
            auto n = (nptr + 7) / 8;
            n = (n + goarch::PtrSize - 1) &^ (goarch::PtrSize - 1);
            auto mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
            auto base = bucketSize / goarch::PtrSize;
            if(ktyp->PtrBytes != 0)
            {
                emitGCMask(mask, base, ktyp, bucketSize);
            }
            base += bucketSize * ktyp->Size_ / goarch::PtrSize;
            if(etyp->PtrBytes != 0)
            {
                emitGCMask(mask, base, etyp, bucketSize);
            }
            base += bucketSize * etyp->Size_ / goarch::PtrSize;
            auto word = base;
            mask[word / 8] |= 1 << (word % 8);
            gcdata = & mask[0];
            ptrdata = (word + 1) * goarch::PtrSize;
            if(ptrdata != size)
            {
                gocpp::panic("reflect: bad layout computation in MapOf");
            }
        }
        auto b = gocpp::InitPtr<abi::Type>([](abi::Type& x) { x.Align_ = goarch::PtrSize; x.Size_ = size; x.Kind_ = uint8_t(Struct); x.PtrBytes = ptrdata; x.GCData = gcdata; });
        auto s = "bucket(" + stringFor(ktyp) + "," + stringFor(etyp) + ")";
        b->Str = resolveReflectName(newName(s, "", false, false));
        return b;
    }

    gocpp::slice<unsigned char> gcSlice(struct rtype* t, uintptr_t begin, uintptr_t end)
    {
        return (gocpp::array<unsigned char, 1 << 30>*)(unsafe::Pointer(t->t.GCData)).make_slice(begin, end, end);
    }

    void emitGCMask(gocpp::slice<unsigned char> out, uintptr_t base, abi::Type* typ, uintptr_t n)
    {
        if(typ->Kind_ & kindGCProg != 0)
        {
            gocpp::panic("reflect: unexpected GC program");
        }
        auto ptrs = typ->PtrBytes / goarch::PtrSize;
        auto words = typ->Size_ / goarch::PtrSize;
        auto mask = GcSlice(gocpp::recv(typ), 0, (ptrs + 7) / 8);
        for(auto j = uintptr_t(0); j < ptrs; j++)
        {
            if((mask[j / 8] >> (j % 8)) & 1 != 0)
            {
                for(auto i = uintptr_t(0); i < n; i++)
                {
                    auto k = base + i * words + j;
                    out[k / 8] |= 1 << (k % 8);
                }
            }
        }
    }

    gocpp::slice<unsigned char> appendGCProg(gocpp::slice<unsigned char> dst, abi::Type* typ)
    {
        if(typ->Kind_ & kindGCProg != 0)
        {
            auto n = uintptr_t(*(uint32_t*)(unsafe::Pointer(typ->GCData)));
            auto prog = GcSlice(gocpp::recv(typ), 4, 4 + n - 1);
            return append(dst, prog);
        }
        auto ptrs = typ->PtrBytes / goarch::PtrSize;
        auto mask = GcSlice(gocpp::recv(typ), 0, (ptrs + 7) / 8);
        for(; ptrs > 120; ptrs -= 120)
        {
            dst = append(dst, 120);
            dst = append(dst, mask.make_slice(0, 15));
            mask = mask.make_slice(15);
        }
        dst = append(dst, unsigned char(ptrs));
        dst = append(dst, mask);
        return dst;
    }

    Type SliceOf(Type t)
    {
        auto typ = common(gocpp::recv(t));
        auto ckey = cacheKey {Slice, typ, nullptr, 0};
        if(auto [slice, ok] = Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(slice);
        }
        auto s = "[]" + stringFor(typ);
        for(auto [_, tt] : typesByString(s))
        {
            auto slice = (sliceType*)(unsafe::Pointer(tt));
            if(slice->Elem == typ)
            {
                auto [ti, gocpp_id_16] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any islice = (gocpp::slice<unsafe::Pointer>)(nullptr);
        auto prototype = *(sliceType**)(unsafe::Pointer(& islice));
        auto slice = *prototype;
        slice.TFlag = 0;
        slice.Str = resolveReflectName(newName(s, "", false, false));
        slice.Hash = fnv1(typ->Hash, '[');
        slice.Elem = typ;
        slice.PtrToThis = 0;
        auto [ti, gocpp_id_18] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& slice.Type));
        return gocpp::getValue<Type>(ti);
    }

    struct gocpp_id_19
    {
        sync::Map m;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << m;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_19& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_19 structLookupCache;
    
    std::ostream& structTypeUncommon::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value)
    {
        return value.PrintTo(os);
    }

    bool isLetter(gocpp::rune ch)
    {
        return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= utf8::RuneSelf && unicode::IsLetter(ch);
    }

    bool isValidFieldName(std::string fieldName)
    {
        for(auto [i, c] : fieldName)
        {
            if(i == 0 && ! isLetter(c))
            {
                return false;
            }
            if(! (isLetter(c) || unicode::IsDigit(c)))
            {
                return false;
            }
        }
        return len(fieldName) > 0;
    }

    struct gocpp_id_20
        {

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_20& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_23
            {

                using isGoStruct = void;

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_23& value)
            {
                return value.PrintTo(os);
            }


    struct gocpp_id_24
        {

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_24& value)
        {
            return value.PrintTo(os);
        }


    Type StructOf(gocpp::slice<StructField> fields)
    {
        gocpp::Defer defer;
        auto hash = fnv1(0, gocpp::Tag<gocpp::slice<unsigned char>>()("struct {"));
        uintptr_t size = fnv1(0, gocpp::Tag<gocpp::slice<unsigned char>>()("struct {"));
        uint8_t typalign = fnv1(0, gocpp::Tag<gocpp::slice<unsigned char>>()("struct {"));
        auto comparable = true;
        gocpp::slice<abi::Method> methods = true;
        auto fs = gocpp::make(gocpp::Tag<gocpp::slice<structField>>(), len(fields));
        auto repr = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 64);
        auto fset = gocpp::map<std::string, gocpp_id_20> {};
        auto hasGCProg = false;
        auto lastzero = uintptr_t(0);
        repr = append(repr, "struct {");
        auto pkgpath = "";
        for(auto [i, field] : fields)
        {
            if(field.Name == "")
            {
                gocpp::panic("reflect.StructOf: field " + strconv::Itoa(i) + " has no name");
            }
            if(! isValidFieldName(field.Name))
            {
                gocpp::panic("reflect.StructOf: field " + strconv::Itoa(i) + " has invalid name");
            }
            if(field.Type == nullptr)
            {
                gocpp::panic("reflect.StructOf: field " + strconv::Itoa(i) + " has no type");
            }
            auto [f, fpkgpath] = runtimeStructField(field);
            auto ft = f.Typ;
            if(ft->Kind_ & kindGCProg != 0)
            {
                hasGCProg = true;
            }
            if(fpkgpath != "")
            {
                if(pkgpath == "")
                {
                    pkgpath = fpkgpath;
                }
                else
                if(pkgpath != fpkgpath)
                {
                    gocpp::panic("reflect.Struct: fields with different PkgPath " + pkgpath + " and " + fpkgpath);
                }
            }
            auto name = Name(gocpp::recv(f.Name));
            hash = fnv1(hash, gocpp::Tag<gocpp::slice<unsigned char>>()(name));
            repr = append(repr, (" " + name));
            if(Embedded(gocpp::recv(f)))
            {
                if(Kind(gocpp::recv(f.Typ)) == abi::Pointer)
                {
                    auto elem = Elem(gocpp::recv(ft));
                    if(auto k = Kind(gocpp::recv(elem)); k == abi::Pointer || k == abi::Interface)
                    {
                        gocpp::panic("reflect.StructOf: illegal embedded field type " + stringFor(ft));
                    }
                }
                //Go switch emulation
                {
                    auto condition = Kind(Kind(gocpp::recv(f.Typ)));
                    int conditionId = -1;
                    if(condition == Interface) { conditionId = 0; }
                    else if(condition == Pointer) { conditionId = 1; }
                    switch(conditionId)
                    {
                        case 0:
                            auto ift = (interfaceType*)(unsafe::Pointer(ft));
                            for(auto [_, m] : ift->Methods)
                            {
                                if(pkgPath(nameOff(gocpp::recv(ift), m.Name)) != "")
                                {
                                    gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                }
                                auto fnStub = resolveReflectText(unsafe::Pointer(abi::FuncPCABIInternal(embeddedIfaceMethStub)));
                                methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(nameOff(gocpp::recv(ift), m.Name)); x.Mtyp = resolveReflectType(typeOff(gocpp::recv(ift), m.Typ)); x.Ifn = fnStub; x.Tfn = fnStub; }));
                            }
                            break;
                        case 1:
                            auto ptr = (ptrType*)(unsafe::Pointer(ft));
                            if(auto unt = Uncommon(gocpp::recv(ptr)); unt != nullptr)
                            {
                                if(i > 0 && unt->Mcount > 0)
                                {
                                    gocpp::panic("reflect: embedded type with methods not implemented if type is not first field");
                                }
                                if(len(fields) > 1)
                                {
                                    gocpp::panic("reflect: embedded type with methods not implemented if there is more than one field");
                                }
                                for(auto [_, m] : Methods(gocpp::recv(unt)))
                                {
                                    auto mname = nameOffFor(ft, m.Name);
                                    if(pkgPath(mname) != "")
                                    {
                                        gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                    }
                                    methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(mname); x.Mtyp = resolveReflectType(typeOffFor(ft, m.Mtyp)); x.Ifn = resolveReflectText(textOffFor(ft, m.Ifn)); x.Tfn = resolveReflectText(textOffFor(ft, m.Tfn)); }));
                                }
                            }
                            if(auto unt = Uncommon(gocpp::recv(ptr->Elem)); unt != nullptr)
                            {
                                for(auto [_, m] : Methods(gocpp::recv(unt)))
                                {
                                    auto mname = nameOffFor(ft, m.Name);
                                    if(pkgPath(mname) != "")
                                    {
                                        gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                    }
                                    methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(mname); x.Mtyp = resolveReflectType(typeOffFor(ptr->Elem, m.Mtyp)); x.Ifn = resolveReflectText(textOffFor(ptr->Elem, m.Ifn)); x.Tfn = resolveReflectText(textOffFor(ptr->Elem, m.Tfn)); }));
                                }
                            }
                            break;
                        default:
                            if(auto unt = Uncommon(gocpp::recv(ft)); unt != nullptr)
                            {
                                if(i > 0 && unt->Mcount > 0)
                                {
                                    gocpp::panic("reflect: embedded type with methods not implemented if type is not first field");
                                }
                                if(len(fields) > 1 && ft->Kind_ & kindDirectIface != 0)
                                {
                                    gocpp::panic("reflect: embedded type with methods not implemented for non-pointer type");
                                }
                                for(auto [_, m] : Methods(gocpp::recv(unt)))
                                {
                                    auto mname = nameOffFor(ft, m.Name);
                                    if(pkgPath(mname) != "")
                                    {
                                        gocpp::panic("reflect: embedded interface with unexported method(s) not implemented");
                                    }
                                    methods = append(methods, gocpp::Init<abi::Method>([](abi::Method& x) { x.Name = resolveReflectName(mname); x.Mtyp = resolveReflectType(typeOffFor(ft, m.Mtyp)); x.Ifn = resolveReflectText(textOffFor(ft, m.Ifn)); x.Tfn = resolveReflectText(textOffFor(ft, m.Tfn)); }));
                                }
                            }
                            break;
                    }
                }
            }
            if(auto [gocpp_id_22, dup] = fset[name]; dup && name != "_")
            {
                gocpp::panic("reflect.StructOf: duplicate field " + name);
            }
            fset[name] = gocpp_id_23 {};
            hash = fnv1(hash, unsigned char(ft->Hash >> 24), unsigned char(ft->Hash >> 16), unsigned char(ft->Hash >> 8), unsigned char(ft->Hash));
            repr = append(repr, (" " + stringFor(ft)));
            if(HasTag(gocpp::recv(f.Name)))
            {
                hash = fnv1(hash, gocpp::Tag<gocpp::slice<unsigned char>>()(Tag(gocpp::recv(f.Name))));
                repr = append(repr, (" " + strconv::Quote(Tag(gocpp::recv(f.Name)))));
            }
            if(i < len(fields) - 1)
            {
                repr = append(repr, ';');
            }
            comparable = comparable && (ft->Equal != nullptr);
            auto offset = align(size, uintptr_t(ft->Align_));
            if(offset < size)
            {
                gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
            }
            if(ft->Align_ > typalign)
            {
                typalign = ft->Align_;
            }
            size = offset + ft->Size_;
            if(size < offset)
            {
                gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
            }
            f.Offset = offset;
            if(ft->Size_ == 0)
            {
                lastzero = size;
            }
            fs[i] = f;
        }
        if(size > 0 && lastzero == size)
        {
            size++;
            if(size == 0)
            {
                gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
            }
        }
        structType* typ = {};
        uncommonType* ut = {};
        if(len(methods) == 0)
        {
            auto t = go_new(structTypeUncommon);
            typ = & t->structType;
            ut = & t->u;
        }
        else
        {
            auto tt = New(StructOf(gocpp::slice<StructField> {gocpp::Init<>([](& x) { x.Name = "S"; x.Type = TypeOf(structType {}); }), gocpp::Init<>([](& x) { x.Name = "U"; x.Type = TypeOf(uncommonType {}); }), gocpp::Init<>([](& x) { x.Name = "M"; x.Type = ArrayOf(len(methods), TypeOf(methods[0])); })}));
            typ = (structType*)(UnsafePointer(gocpp::recv(Addr(gocpp::recv(Field(gocpp::recv(Elem(gocpp::recv(tt))), 0))))));
            ut = (uncommonType*)(UnsafePointer(gocpp::recv(Addr(gocpp::recv(Field(gocpp::recv(Elem(gocpp::recv(tt))), 1))))));
            copy(gocpp::getValue<abi::Method>>(Interface(gocpp::recv(Slice(gocpp::recv(Field(gocpp::recv(Elem(gocpp::recv(tt))), 2)), 0, len(methods))))), methods);
        }
        ut->Mcount = uint16_t(len(methods));
        ut->Xcount = ut->Mcount;
        ut->Moff = uint32_t(gocpp::Sizeof<uncommonType>());
        if(len(fs) > 0)
        {
            repr = append(repr, ' ');
        }
        repr = append(repr, '}');
        hash = fnv1(hash, '}');
        auto str = string(repr);
        auto s = align(size, uintptr_t(typalign));
        if(s < size)
        {
            gocpp::panic("reflect.StructOf: struct size would exceed virtual address space");
        }
        size = s;
        go_any istruct = gocpp_id_24 {};
        auto prototype = *(structType**)(unsafe::Pointer(& istruct));
        *typ = *prototype;
        typ->Fields = fs;
        if(pkgpath != "")
        {
            typ->PkgPath = newName(pkgpath, "", false, false);
        }
        if(auto [ts, ok] = Load(gocpp::recv(structLookupCache.m), hash); ok)
        {
            for(auto [_, st] : gocpp::getValue<gocpp::slice<reflect::Type>>(ts))
            {
                auto t = common(gocpp::recv(st));
                if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                {
                    return toType(t);
                }
            }
        }
        Lock(gocpp::recv(structLookupCache));
        defer.push_back([=]{ Unlock(gocpp::recv(structLookupCache)); });
        if(auto [ts, ok] = Load(gocpp::recv(structLookupCache.m), hash); ok)
        {
            for(auto [_, st] : gocpp::getValue<gocpp::slice<reflect::Type>>(ts))
            {
                auto t = common(gocpp::recv(st));
                if(haveIdenticalUnderlyingType(& typ->Type, t, true))
                {
                    return toType(t);
                }
            }
        }
        auto addToCache = [=](Type t) mutable -> Type
        {
            gocpp::slice<Type> ts = {};
            if(auto [ti, ok] = Load(gocpp::recv(structLookupCache.m), hash); ok)
            {
                ts = gocpp::getValue<gocpp::slice<reflect::Type>>(ti);
            }
            Store(gocpp::recv(structLookupCache.m), hash, append(ts, t));
            return t;
        }
;
        for(auto [_, t] : typesByString(str))
        {
            if(haveIdenticalUnderlyingType(& typ->Type, t, true))
            {
                return addToCache(toType(t));
            }
        }
        typ->Str = resolveReflectName(newName(str, "", false, false));
        typ->TFlag = 0;
        typ->Hash = hash;
        typ->Size_ = size;
        typ->PtrBytes = typeptrdata(& typ->Type);
        typ->Align_ = typalign;
        typ->FieldAlign_ = typalign;
        typ->PtrToThis = 0;
        if(len(methods) > 0)
        {
            typ->TFlag |= abi::TFlagUncommon;
        }
        if(hasGCProg)
        {
            auto lastPtrField = 0;
            for(auto [i, ft] : fs)
            {
                if(Pointers(gocpp::recv(ft->Typ)))
                {
                    lastPtrField = i;
                }
            }
            auto prog = gocpp::slice<unsigned char> {0, 0, 0, 0};
            uintptr_t off = {};
            for(auto [i, ft] : fs)
            {
                if(i > lastPtrField)
                {
                    break;
                }
                if(! Pointers(gocpp::recv(ft->Typ)))
                {
                    continue;
                }
                if(ft->Offset > off)
                {
                    auto n = (ft->Offset - off) / goarch::PtrSize;
                    prog = append(prog, 0x01, 0x00);
                    if(n > 1)
                    {
                        prog = append(prog, 0x81);
                        prog = appendVarint(prog, n - 1);
                    }
                    off = ft->Offset;
                }
                prog = appendGCProg(prog, ft->Typ);
                off += ft->Typ->PtrBytes;
            }
            prog = append(prog, 0);
            *(uint32_t*)(unsafe::Pointer(& prog[0])) = uint32_t(len(prog) - 4);
            typ->Kind_ |= kindGCProg;
            typ->GCData = & prog[0];
        }
        else
        {
            typ->Kind_ &^= kindGCProg;
            auto bv = go_new(bitVector);
            addTypeBits(bv, 0, & typ->Type);
            if(len(bv->data) > 0)
            {
                typ->GCData = & bv->data[0];
            }
        }
        typ->Equal = nullptr;
        if(comparable)
        {
            typ->Equal = [=](unsafe::Pointer p, unsafe::Pointer q) mutable -> bool
            {
                for(auto [_, ft] : typ->Fields)
                {
                    auto pi = add(p, ft->Offset, "&x.field safe");
                    auto qi = add(q, ft->Offset, "&x.field safe");
                    if(! Equal(gocpp::recv(ft->Typ), pi, qi))
                    {
                        return false;
                    }
                }
                return true;
            }
;
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(len(fs) == 1 && ! ifaceIndir(fs[0].Typ)) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    typ->Kind_ |= kindDirectIface;
                    break;
                default:
                    typ->Kind_ &^= kindDirectIface;
                    break;
            }
        }
        return addToCache(toType(& typ->Type));
    }

    void embeddedIfaceMethStub()
    {
        gocpp::panic("reflect: StructOf does not support methods of embedded interfaces");
    }

    std::tuple<structField, std::string> runtimeStructField(StructField field)
    {
        if(field.Anonymous && field.PkgPath != "")
        {
            gocpp::panic("reflect.StructOf: field \"" + field.Name + "\" is anonymous but has PkgPath set");
        }
        if(IsExported(gocpp::recv(field)))
        {
            auto c = field.Name[0];
            if('a' <= c && c <= 'z' || c == '_')
            {
                gocpp::panic("reflect.StructOf: field \"" + field.Name + "\" is unexported but missing PkgPath");
            }
        }
        resolveReflectType(common(gocpp::recv(field.Type)));
        auto f = gocpp::Init<structField>([](structField& x) { x.Name = newName(field.Name, string(field.Tag), IsExported(gocpp::recv(field)), field.Anonymous); x.Typ = common(gocpp::recv(field.Type)); x.Offset = 0; });
        return {f, field.PkgPath};
    }

    uintptr_t typeptrdata(abi::Type* t)
    {
        //Go switch emulation
        {
            auto condition = Kind(gocpp::recv(t));
            int conditionId = -1;
            if(condition == abi::Struct) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    auto st = (structType*)(unsafe::Pointer(t));
                    auto field = - 1;
                    for(auto [i, gocpp_ignored] : st->Fields)
                    {
                        auto ft = st->Fields[i].Typ;
                        if(Pointers(gocpp::recv(ft)))
                        {
                            field = i;
                        }
                    }
                    if(field == - 1)
                    {
                        return 0;
                    }
                    auto f = st->Fields[field];
                    return f.Offset + f.Typ->PtrBytes;
                    break;
                default:
                    gocpp::panic("reflect.typeptrdata: unexpected type, " + stringFor(t));
                    break;
            }
        }
    }

    Type ArrayOf(int length, Type elem)
    {
        if(length < 0)
        {
            gocpp::panic("reflect: negative length passed to ArrayOf");
        }
        auto typ = common(gocpp::recv(elem));
        auto ckey = cacheKey {Array, typ, nullptr, uintptr_t(length)};
        if(auto [array, ok] = Load(gocpp::recv(lookupCache), ckey); ok)
        {
            return gocpp::getValue<Type>(array);
        }
        auto s = "[" + strconv::Itoa(length) + "]" + stringFor(typ);
        for(auto [_, tt] : typesByString(s))
        {
            auto array = (arrayType*)(unsafe::Pointer(tt));
            if(array->Elem == typ)
            {
                auto [ti, gocpp_id_26] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(tt));
                return gocpp::getValue<Type>(ti);
            }
        }
        go_any iarray = gocpp::array<unsafe::Pointer, 1> {};
        auto prototype = *(arrayType**)(unsafe::Pointer(& iarray));
        auto array = *prototype;
        array.TFlag = typ->TFlag & abi::TFlagRegularMemory;
        array.Str = resolveReflectName(newName(s, "", false, false));
        array.Hash = fnv1(typ->Hash, '[');
        for(auto n = uint32_t(length); n > 0; n >>= 8)
        {
            array.Hash = fnv1(array.Hash, unsigned char(n));
        }
        array.Hash = fnv1(array.Hash, ']');
        array.Elem = typ;
        array.PtrToThis = 0;
        if(typ->Size_ > 0)
        {
            auto max = ~ uintptr_t(0) / typ->Size_;
            if(uintptr_t(length) > max)
            {
                gocpp::panic("reflect.ArrayOf: array size would exceed virtual address space");
            }
        }
        array.Size_ = typ->Size_ * uintptr_t(length);
        if(length > 0 && typ->PtrBytes != 0)
        {
            array.PtrBytes = typ->Size_ * uintptr_t(length - 1) + typ->PtrBytes;
        }
        array.Align_ = typ->Align_;
        array.FieldAlign_ = typ->FieldAlign_;
        array.Len = uintptr_t(length);
        array.Slice = & (gocpp::getValue<rtype*>(SliceOf(elem))->t);
        //Go switch emulation
        {
            int conditionId = -1;
            if(typ->PtrBytes == 0 || array.Size_ == 0) { conditionId = 0; }
            else if(length == 1) { conditionId = 1; }
            else if(typ->Kind_ & kindGCProg == 0 && array.Size_ <= maxPtrmaskBytes * 8 * goarch::PtrSize) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    array.GCData = nullptr;
                    array.PtrBytes = 0;
                    break;
                case 1:
                    array.Kind_ |= typ->Kind_ & kindGCProg;
                    array.GCData = typ->GCData;
                    array.PtrBytes = typ->PtrBytes;
                    break;
                case 2:
                    auto n = (array.PtrBytes / goarch::PtrSize + 7) / 8;
                    n = (n + goarch::PtrSize - 1) &^ (goarch::PtrSize - 1);
                    auto mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n);
                    emitGCMask(mask, 0, typ, array.Len);
                    array.GCData = & mask[0];
                    break;
                default:
                    auto prog = gocpp::slice<unsigned char> {0, 0, 0, 0};
                    prog = appendGCProg(prog, typ);
                    auto elemPtrs = typ->PtrBytes / goarch::PtrSize;
                    auto elemWords = typ->Size_ / goarch::PtrSize;
                    if(elemPtrs < elemWords)
                    {
                        prog = append(prog, 0x01, 0x00);
                        if(elemPtrs + 1 < elemWords)
                        {
                            prog = append(prog, 0x81);
                            prog = appendVarint(prog, elemWords - elemPtrs - 1);
                        }
                    }
                    if(elemWords < 0x80)
                    {
                        prog = append(prog, unsigned char(elemWords | 0x80));
                    }
                    else
                    {
                        prog = append(prog, 0x80);
                        prog = appendVarint(prog, elemWords);
                    }
                    prog = appendVarint(prog, uintptr_t(length) - 1);
                    prog = append(prog, 0);
                    *(uint32_t*)(unsafe::Pointer(& prog[0])) = uint32_t(len(prog) - 4);
                    array.Kind_ |= kindGCProg;
                    array.GCData = & prog[0];
                    array.PtrBytes = array.Size_;
                    break;
            }
        }
        auto etyp = typ;
        auto esize = Size(gocpp::recv(etyp));
        array.Equal = nullptr;
        if(auto eequal = etyp->Equal; eequal != nullptr)
        {
            array.Equal = [=](unsafe::Pointer p, unsafe::Pointer q) mutable -> bool
            {
                for(auto i = 0; i < length; i++)
                {
                    auto pi = arrayAt(p, i, esize, "i < length");
                    auto qi = arrayAt(q, i, esize, "i < length");
                    if(! eequal(pi, qi))
                    {
                        return false;
                    }
                }
                return true;
            }
;
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(length == 1 && ! ifaceIndir(typ)) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    array.Kind_ |= kindDirectIface;
                    break;
                default:
                    array.Kind_ &^= kindDirectIface;
                    break;
            }
        }
        auto [ti, gocpp_id_28] = LoadOrStore(gocpp::recv(lookupCache), ckey, toRType(& array.Type));
        return gocpp::getValue<Type>(ti);
    }

    gocpp::slice<unsigned char> appendVarint(gocpp::slice<unsigned char> x, uintptr_t v)
    {
        for(; v >= 0x80; v >>= 7)
        {
            x = append(x, unsigned char(v | 0x80));
        }
        x = append(x, unsigned char(v));
        return x;
    }

    Type toType(abi::Type* t)
    {
        if(t == nullptr)
        {
            return nullptr;
        }
        return toRType(t);
    }

    
    std::ostream& layoutKey::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ftyp;
        os << " " << rcvr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct layoutKey& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& layoutType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << t;
        os << " " << framePool;
        os << " " << abid;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct layoutType& value)
    {
        return value.PrintTo(os);
    }

    sync::Map layoutCache;
    std::tuple<abi::Type*, sync::Pool*, abiDesc> funcLayout(funcType* t, abi::Type* rcvr)
    {
        abi::Type* frametype;
        sync::Pool* framePool;
        abiDesc abid;
        if(Kind(gocpp::recv(t)) != abi::Func)
        {
            abi::Type* frametype;
            sync::Pool* framePool;
            abiDesc abid;
            gocpp::panic("reflect: funcLayout of non-func type " + stringFor(& t->Type));
        }
        if(rcvr != nullptr && Kind(gocpp::recv(rcvr)) == abi::Interface)
        {
            abi::Type* frametype;
            sync::Pool* framePool;
            abiDesc abid;
            gocpp::panic("reflect: funcLayout with interface receiver " + stringFor(rcvr));
        }
        auto k = layoutKey {t, rcvr};
        if(auto [lti, ok] = Load(gocpp::recv(layoutCache), k); ok)
        {
            abi::Type* frametype;
            sync::Pool* framePool;
            abiDesc abid;
            auto lt = gocpp::getValue<layoutType>(lti);
            return {lt.t, lt.framePool, lt.abid};
        }
        abid = newAbiDesc(t, rcvr);
        auto x = gocpp::InitPtr<abi::Type>([](abi::Type& x) { x.Align_ = goarch::PtrSize; x.Size_ = align(abid.retOffset + abid.ret.stackBytes, goarch::PtrSize); x.PtrBytes = uintptr_t(abid.stackPtrs->n) * goarch::PtrSize; });
        if(abid.stackPtrs->n > 0)
        {
            abi::Type* frametype;
            sync::Pool* framePool;
            abiDesc abid;
            x->GCData = & abid.stackPtrs->data[0];
        }
        std::string s = {};
        if(rcvr != nullptr)
        {
            abi::Type* frametype;
            sync::Pool* framePool;
            abiDesc abid;
            s = "methodargs(" + stringFor(rcvr) + ")(" + stringFor(& t->Type) + ")";
        }
        else
        {
            abi::Type* frametype;
            sync::Pool* framePool;
            abiDesc abid;
            s = "funcargs(" + stringFor(& t->Type) + ")";
        }
        x->Str = resolveReflectName(newName(s, "", false, false));
        framePool = gocpp::InitPtr<sync::Pool>([](sync::Pool& x) { x.New = [=]() mutable -> go_any
        {
            return unsafe_New(x);
        }
; });
        auto [lti, gocpp_id_30] = LoadOrStore(gocpp::recv(layoutCache), k, gocpp::Init<layoutType>([](layoutType& x) { x.t = x; x.framePool = framePool; x.abid = abid; }));
        auto lt = gocpp::getValue<layoutType>(lti);
        return {lt.t, lt.framePool, lt.abid};
    }

    bool ifaceIndir(abi::Type* t)
    {
        return t->Kind_ & kindDirectIface == 0;
    }

    
    std::ostream& bitVector::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << n;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct bitVector& value)
    {
        return value.PrintTo(os);
    }

    void append(struct bitVector* bv, uint8_t bit)
    {
        if(bv->n % (8 * goarch::PtrSize) == 0)
        {
            for(auto i = 0; i < goarch::PtrSize; i++)
            {
                bv->data = append(bv->data, 0);
            }
        }
        bv->data[bv->n / 8] |= bit << (bv->n % 8);
        bv->n++;
    }

    void addTypeBits(bitVector* bv, uintptr_t offset, abi::Type* t)
    {
        if(t->PtrBytes == 0)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = Kind(t->Kind_ & kindMask);
            int conditionId = -1;
            if(condition == Chan) { conditionId = 0; }
            if(condition == Func) { conditionId = 1; }
            if(condition == Map) { conditionId = 2; }
            if(condition == Pointer) { conditionId = 3; }
            if(condition == Slice) { conditionId = 4; }
            if(condition == String) { conditionId = 5; }
            if(condition == UnsafePointer) { conditionId = 6; }
            else if(condition == Interface) { conditionId = 7; }
            else if(condition == Array) { conditionId = 8; }
            else if(condition == Struct) { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    for(; bv->n < uint32_t(offset / uintptr_t(goarch::PtrSize)); )
                    {
                        append(gocpp::recv(bv), 0);
                    }
                    append(gocpp::recv(bv), 1);
                    break;
                case 7:
                    for(; bv->n < uint32_t(offset / uintptr_t(goarch::PtrSize)); )
                    {
                        append(gocpp::recv(bv), 0);
                    }
                    append(gocpp::recv(bv), 1);
                    append(gocpp::recv(bv), 1);
                    break;
                case 8:
                    auto tt = (arrayType*)(unsafe::Pointer(t));
                    for(auto i = 0; i < int(tt->Len); i++)
                    {
                        addTypeBits(bv, offset + uintptr_t(i) * tt->Elem->Size_, tt->Elem);
                    }
                    break;
                case 9:
                    auto tt = (structType*)(unsafe::Pointer(t));
                    for(auto [i, gocpp_ignored] : tt->Fields)
                    {
                        auto f = & tt->Fields[i];
                        addTypeBits(bv, offset + f->Offset, f->Typ);
                    }
                    break;
            }
        }
    }

    Type TypeFor()
    {
        return Elem(gocpp::recv(TypeOf((T*)(nullptr))));
    }

}

