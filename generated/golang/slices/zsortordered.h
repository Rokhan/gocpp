// generated by GoCpp from file '$(ImportDir)/slices/zsortordered.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/slices/zsortordered.fwd.h"
#include "gocpp/support.h"

// #include "golang/cmp/cmp.h"  [Ignored, known errors]
// #include "golang/slices/sort.h"  [Ignored, known errors]

namespace golang::slices
{
    void insertionSortOrdered(gocpp::slice<E> data, int a, int b);
    void siftDownOrdered(gocpp::slice<E> data, int lo, int hi, int first);
    void heapSortOrdered(gocpp::slice<E> data, int a, int b);
    void pdqsortOrdered(gocpp::slice<E> data, int a, int b, int limit);
    std::tuple<int, bool> partitionOrdered(gocpp::slice<E> data, int a, int b, int pivot);
    int partitionEqualOrdered(gocpp::slice<E> data, int a, int b, int pivot);
    bool partialInsertionSortOrdered(gocpp::slice<E> data, int a, int b);
    void breakPatternsOrdered(gocpp::slice<E> data, int a, int b);
    std::tuple<int, sortedHint> choosePivotOrdered(gocpp::slice<E> data, int a, int b);
    std::tuple<int, int> order2Ordered(gocpp::slice<E> data, int a, int b, int* swaps);
    int medianOrdered(gocpp::slice<E> data, int a, int b, int c, int* swaps);
    int medianAdjacentOrdered(gocpp::slice<E> data, int a, int* swaps);
    void reverseRangeOrdered(gocpp::slice<E> data, int a, int b);
    void swapRangeOrdered(gocpp::slice<E> data, int a, int b, int n);
    void stableOrdered(gocpp::slice<E> data, int n);
    void symMergeOrdered(gocpp::slice<E> data, int a, int m, int b);
    void rotateOrdered(gocpp::slice<E> data, int a, int m, int b);
}

