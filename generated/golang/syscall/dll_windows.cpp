// generated by GoCpp from file '$(ImportDir)/syscall/dll_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/dll_windows.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    
    std::ostream& DLLError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Err;
        os << " " << ObjName;
        os << " " << Msg;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DLLError& value)
    {
        return value.PrintTo(os);
    }

    std::string Error(struct DLLError* e)
    {
        return e->Msg;
    }

    std::string Unwrap(struct DLLError* e)
    {
        return e->Err;
    }

    std::tuple<uintptr_t, uintptr_t, Errno> Syscall(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, Errno> Syscall6(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, Errno> Syscall9(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, Errno> Syscall12(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, Errno> Syscall15(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, Errno> Syscall18(uintptr_t trap, uintptr_t nargs, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6, uintptr_t a7, uintptr_t a8, uintptr_t a9, uintptr_t a10, uintptr_t a11, uintptr_t a12, uintptr_t a13, uintptr_t a14, uintptr_t a15, uintptr_t a16, uintptr_t a17, uintptr_t a18)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, uintptr_t, Errno> SyscallN(uintptr_t trap, gocpp::slice<uintptr_t> args)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, Errno> loadlibrary(uint16_t* filename)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, Errno> loadsystemlibrary(uint16_t* filename)
    /* convertBlockStmt, nil block */;

    std::tuple<uintptr_t, Errno> getprocaddress(uintptr_t handle, uint8_t* procname)
    /* convertBlockStmt, nil block */;

    
    std::ostream& DLL::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Handle;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct DLL& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<DLL*, std::string> LoadDLL(std::string name)
    {
        auto [namep, err] = UTF16PtrFromString(name);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        uintptr_t h = {};
        Errno e = {};
        if(sysdll::IsSystemDLL[name])
        {
            std::tie(h, e) = loadsystemlibrary(namep);
        }
        else
        {
            std::tie(h, e) = loadlibrary(namep);
        }
        if(e != 0)
        {
            return {nullptr, gocpp::InitPtr<DLLError>([](DLLError& x) { x.Err = e; x.ObjName = name; x.Msg = "Failed to load " + name + ": " + Error(gocpp::recv(e)); })};
        }
        auto d = gocpp::InitPtr<DLL>([](DLL& x) { x.Name = name; x.Handle = Handle(h); });
        return {d, nullptr};
    }

    DLL* MustLoadDLL(std::string name)
    {
        auto [d, e] = LoadDLL(name);
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
        return d;
    }

    std::tuple<Proc*, std::string> FindProc(struct DLL* d, std::string name)
    {
        Proc* proc;
        std::string err;
        auto [namep, err] = BytePtrFromString(name);
        if(err != nullptr)
        {
            Proc* proc;
            std::string err;
            return {nullptr, err};
        }
        auto [a, e] = getprocaddress(uintptr_t(d->Handle), namep);
        if(e != 0)
        {
            Proc* proc;
            std::string err;
            return {nullptr, gocpp::InitPtr<DLLError>([](DLLError& x) { x.Err = e; x.ObjName = name; x.Msg = "Failed to find " + name + " procedure in " + d->Name + ": " + Error(gocpp::recv(e)); })};
        }
        auto p = gocpp::InitPtr<Proc>([](Proc& x) { x.Dll = d; x.Name = name; x.addr = a; });
        return {p, nullptr};
    }

    Proc* MustFindProc(struct DLL* d, std::string name)
    {
        auto [p, e] = FindProc(gocpp::recv(d), name);
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
        return p;
    }

    std::string Release(struct DLL* d)
    {
        std::string err;
        return FreeLibrary(d->Handle);
    }

    
    std::ostream& Proc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Dll;
        os << " " << Name;
        os << " " << addr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Proc& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t Addr(struct Proc* p)
    {
        return p->addr;
    }

    std::tuple<uintptr_t, uintptr_t, std::string> Call(struct Proc* p, gocpp::slice<uintptr_t> a)
    {
        return SyscallN(Addr(gocpp::recv(p)), a);
    }

    
    std::ostream& LazyDLL::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << " " << dll;
        os << " " << Name;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LazyDLL& value)
    {
        return value.PrintTo(os);
    }

    std::string Load(struct LazyDLL* d)
    {
        gocpp::Defer defer;
        if(atomic::LoadPointer((unsafe::Pointer*)(unsafe::Pointer(& d->dll))) == nullptr)
        {
            Lock(gocpp::recv(d->mu));
            defer.push_back([=]{ Unlock(gocpp::recv(d->mu)); });
            if(d->dll == nullptr)
            {
                auto [dll, e] = LoadDLL(d->Name);
                if(e != nullptr)
                {
                    return e;
                }
                atomic::StorePointer((unsafe::Pointer*)(unsafe::Pointer(& d->dll)), unsafe::Pointer(dll));
            }
        }
        return nullptr;
    }

    void mustLoad(struct LazyDLL* d)
    {
        auto e = Load(gocpp::recv(d));
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
    }

    uintptr_t Handle(struct LazyDLL* d)
    {
        mustLoad(gocpp::recv(d));
        return uintptr_t(d->dll->Handle);
    }

    LazyProc* NewProc(struct LazyDLL* d, std::string name)
    {
        return gocpp::InitPtr<LazyProc>([](LazyProc& x) { x.l = d; x.Name = name; });
    }

    LazyDLL* NewLazyDLL(std::string name)
    {
        return gocpp::InitPtr<LazyDLL>([](LazyDLL& x) { x.Name = name; });
    }

    
    std::ostream& LazyProc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << " " << Name;
        os << " " << l;
        os << " " << proc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LazyProc& value)
    {
        return value.PrintTo(os);
    }

    std::string Find(struct LazyProc* p)
    {
        gocpp::Defer defer;
        if(atomic::LoadPointer((unsafe::Pointer*)(unsafe::Pointer(& p->proc))) == nullptr)
        {
            Lock(gocpp::recv(p->mu));
            defer.push_back([=]{ Unlock(gocpp::recv(p->mu)); });
            if(p->proc == nullptr)
            {
                auto e = Load(gocpp::recv(p->l));
                if(e != nullptr)
                {
                    return e;
                }
                Proc* proc;
                std::tie(proc, e) = FindProc(gocpp::recv(p->l->dll), p->Name);
                if(e != nullptr)
                {
                    return e;
                }
                atomic::StorePointer((unsafe::Pointer*)(unsafe::Pointer(& p->proc)), unsafe::Pointer(proc));
            }
        }
        return nullptr;
    }

    void mustFind(struct LazyProc* p)
    {
        auto e = Find(gocpp::recv(p));
        if(e != nullptr)
        {
            gocpp::panic(e);
        }
    }

    uintptr_t Addr(struct LazyProc* p)
    {
        mustFind(gocpp::recv(p));
        return Addr(gocpp::recv(p->proc));
    }

    std::tuple<uintptr_t, uintptr_t, std::string> Call(struct LazyProc* p, gocpp::slice<uintptr_t> a)
    {
        uintptr_t r1;
        uintptr_t r2;
        std::string lastErr;
        mustFind(gocpp::recv(p));
        return Call(gocpp::recv(p->proc), a);
    }

}

