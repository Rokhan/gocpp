// generated by GoCpp from file '$(ImportDir)/strconv/quote.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/strconv/quote.h"
#include "gocpp/support.h"

#include "golang/strconv/bytealg.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::strconv
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    gocpp::string lowerhex = "0123456789abcdef"_s;
    gocpp::string upperhex = "0123456789ABCDEF"_s;
    // contains reports whether the string contains the byte c.
    bool contains(gocpp::string s, unsigned char c)
    {
        return index(s, c) != - 1;
    }

    gocpp::string quoteWith(gocpp::string s, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        return gocpp::string(appendQuotedWith(gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 3 * len(s) / 2), s, quote, ASCIIonly, graphicOnly));
    }

    gocpp::string quoteRuneWith(gocpp::rune r, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        return gocpp::string(appendQuotedRuneWith(nullptr, r, quote, ASCIIonly, graphicOnly));
    }

    gocpp::slice<unsigned char> appendQuotedWith(gocpp::slice<unsigned char> buf, gocpp::string s, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        if(cap(buf) - len(buf) < len(s))
        {
            auto nBuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(buf), len(buf) + 1 + len(s) + 1);
            copy(nBuf, buf);
            buf = nBuf;
        }
        buf = append(buf, quote);
        for(auto width = 0; len(s) > 0; s = s.make_slice(width))
        {
            auto r = gocpp::rune(s[0]);
            width = 1;
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, width) = utf8::DecodeRuneInString(s);
            }
            if(width == 1 && r == utf8::RuneError)
            {
                buf = append(buf, "\\x"_s);
                buf = append(buf, lowerhex[s[0] >> 4]);
                buf = append(buf, lowerhex[s[0] & 0xF]);
                continue;
            }
            buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
        }
        buf = append(buf, quote);
        return buf;
    }

    gocpp::slice<unsigned char> appendQuotedRuneWith(gocpp::slice<unsigned char> buf, gocpp::rune r, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        buf = append(buf, quote);
        if(! utf8::ValidRune(r))
        {
            r = utf8::RuneError;
        }
        buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
        buf = append(buf, quote);
        return buf;
    }

    gocpp::slice<unsigned char> appendEscapedRune(gocpp::slice<unsigned char> buf, gocpp::rune r, unsigned char quote, bool ASCIIonly, bool graphicOnly)
    {
        if(r == gocpp::rune(quote) || r == '\\')
        {
            buf = append(buf, '\\');
            buf = append(buf, (unsigned char)(r));
            return buf;
        }
        if(ASCIIonly)
        {
            if(r < utf8::RuneSelf && IsPrint(r))
            {
                buf = append(buf, (unsigned char)(r));
                return buf;
            }
        }
        else
        if(IsPrint(r) || graphicOnly && isInGraphicList(r))
        {
            return utf8::AppendRune(buf, r);
        }
        //Go switch emulation
        {
            auto condition = r;
            int conditionId = -1;
            if(condition == '\a') { conditionId = 0; }
            else if(condition == '\b') { conditionId = 1; }
            else if(condition == '\f') { conditionId = 2; }
            else if(condition == '\n') { conditionId = 3; }
            else if(condition == '\r') { conditionId = 4; }
            else if(condition == '\t') { conditionId = 5; }
            else if(condition == '\v') { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    buf = append(buf, "\\a"_s);
                    break;
                case 1:
                    buf = append(buf, "\\b"_s);
                    break;
                case 2:
                    buf = append(buf, "\\f"_s);
                    break;
                case 3:
                    buf = append(buf, "\\n"_s);
                    break;
                case 4:
                    buf = append(buf, "\\r"_s);
                    break;
                case 5:
                    buf = append(buf, "\\t"_s);
                    break;
                case 6:
                    buf = append(buf, "\\v"_s);
                    break;
                default:
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(r < ' ' || r == 0x7f) { conditionId = 0; }
                        else if(! utf8::ValidRune(r)) { conditionId = 1; }
                        else if(r < 0x10000) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                buf = append(buf, "\\x"_s);
                                buf = append(buf, lowerhex[(unsigned char)(r) >> 4]);
                                buf = append(buf, lowerhex[(unsigned char)(r) & 0xF]);
                                break;
                            case 1:
                                r = 0xFFFD;
                            case 2:
                                buf = append(buf, "\\u"_s);
                                for(auto s = 12; s >= 0; s -= 4)
                                {
                                    buf = append(buf, lowerhex[(r >> (unsigned int)(s)) & 0xF]);
                                }
                                break;
                            default:
                                buf = append(buf, "\\U"_s);
                                for(auto s = 28; s >= 0; s -= 4)
                                {
                                    buf = append(buf, lowerhex[(r >> (unsigned int)(s)) & 0xF]);
                                }
                                break;
                        }
                    }
                    break;
            }
        }
        return buf;
    }

    // Quote returns a double-quoted Go string literal representing s. The
    // returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
    // control characters and non-printable characters as defined by
    // IsPrint.
    gocpp::string Quote(gocpp::string s)
    {
        return quoteWith(s, '"', false, false);
    }

    // AppendQuote appends a double-quoted Go string literal representing s,
    // as generated by Quote, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendQuote(gocpp::slice<unsigned char> dst, gocpp::string s)
    {
        return appendQuotedWith(dst, s, '"', false, false);
    }

    // QuoteToASCII returns a double-quoted Go string literal representing s.
    // The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
    // non-ASCII characters and non-printable characters as defined by IsPrint.
    gocpp::string QuoteToASCII(gocpp::string s)
    {
        return quoteWith(s, '"', true, false);
    }

    // AppendQuoteToASCII appends a double-quoted Go string literal representing s,
    // as generated by QuoteToASCII, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendQuoteToASCII(gocpp::slice<unsigned char> dst, gocpp::string s)
    {
        return appendQuotedWith(dst, s, '"', true, false);
    }

    // QuoteToGraphic returns a double-quoted Go string literal representing s.
    // The returned string leaves Unicode graphic characters, as defined by
    // IsGraphic, unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100)
    // for non-graphic characters.
    gocpp::string QuoteToGraphic(gocpp::string s)
    {
        return quoteWith(s, '"', false, true);
    }

    // AppendQuoteToGraphic appends a double-quoted Go string literal representing s,
    // as generated by QuoteToGraphic, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendQuoteToGraphic(gocpp::slice<unsigned char> dst, gocpp::string s)
    {
        return appendQuotedWith(dst, s, '"', false, true);
    }

    // QuoteRune returns a single-quoted Go character literal representing the
    // rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
    // for control characters and non-printable characters as defined by IsPrint.
    // If r is not a valid Unicode code point, it is interpreted as the Unicode
    // replacement character U+FFFD.
    gocpp::string QuoteRune(gocpp::rune r)
    {
        return quoteRuneWith(r, '\'', false, false);
    }

    // AppendQuoteRune appends a single-quoted Go character literal representing the rune,
    // as generated by QuoteRune, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendQuoteRune(gocpp::slice<unsigned char> dst, gocpp::rune r)
    {
        return appendQuotedRuneWith(dst, r, '\'', false, false);
    }

    // QuoteRuneToASCII returns a single-quoted Go character literal representing
    // the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
    // \u0100) for non-ASCII characters and non-printable characters as defined
    // by IsPrint.
    // If r is not a valid Unicode code point, it is interpreted as the Unicode
    // replacement character U+FFFD.
    gocpp::string QuoteRuneToASCII(gocpp::rune r)
    {
        return quoteRuneWith(r, '\'', true, false);
    }

    // AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,
    // as generated by QuoteRuneToASCII, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendQuoteRuneToASCII(gocpp::slice<unsigned char> dst, gocpp::rune r)
    {
        return appendQuotedRuneWith(dst, r, '\'', true, false);
    }

    // QuoteRuneToGraphic returns a single-quoted Go character literal representing
    // the rune. If the rune is not a Unicode graphic character,
    // as defined by IsGraphic, the returned string will use a Go escape sequence
    // (\t, \n, \xFF, \u0100).
    // If r is not a valid Unicode code point, it is interpreted as the Unicode
    // replacement character U+FFFD.
    gocpp::string QuoteRuneToGraphic(gocpp::rune r)
    {
        return quoteRuneWith(r, '\'', false, true);
    }

    // AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,
    // as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.
    gocpp::slice<unsigned char> AppendQuoteRuneToGraphic(gocpp::slice<unsigned char> dst, gocpp::rune r)
    {
        return appendQuotedRuneWith(dst, r, '\'', false, true);
    }

    // CanBackquote reports whether the string s can be represented
    // unchanged as a single-line backquoted string without control
    // characters other than tab.
    bool CanBackquote(gocpp::string s)
    {
        for(; len(s) > 0; )
        {
            auto [r, wid] = utf8::DecodeRuneInString(s);
            s = s.make_slice(wid);
            if(wid > 1)
            {
                if(r == '\ufeff')
                {
                    return false;
                }
                continue;
            }
            if(r == utf8::RuneError)
            {
                return false;
            }
            if((r < ' ' && r != '\t') || r == '`' || r == '\u007F')
            {
                return false;
            }
        }
        return true;
    }

    std::tuple<gocpp::rune, bool> unhex(unsigned char b)
    {
        gocpp::rune v;
        bool ok;
        auto c = gocpp::rune(b);
        //Go switch emulation
        {
            int conditionId = -1;
            if('0' <= c && c <= '9') { conditionId = 0; }
            else if('a' <= c && c <= 'f') { conditionId = 1; }
            else if('A' <= c && c <= 'F') { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return {c - '0', true};
                    break;
                case 1:
                    return {c - 'a' + 10, true};
                    break;
                case 2:
                    return {c - 'A' + 10, true};
                    break;
            }
        }
        return {v, ok};
    }

    // UnquoteChar decodes the first character or byte in the escaped string
    // or character literal represented by the string s.
    // It returns four values:
    //
    //  1. value, the decoded Unicode code point or byte value;
    //  2. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
    //  3. tail, the remainder of the string after the character; and
    //  4. an error that will be nil if the character is syntactically valid.
    //
    // The second argument, quote, specifies the type of literal being parsed
    // and therefore which escaped quote character is permitted.
    // If set to a single quote, it permits the sequence \' and disallows unescaped '.
    // If set to a double quote, it permits \" and disallows unescaped ".
    // If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.
    std::tuple<gocpp::rune, bool, gocpp::string, struct gocpp::error> UnquoteChar(gocpp::string s, unsigned char quote)
    {
        gocpp::rune value;
        bool multibyte;
        gocpp::string tail;
        struct gocpp::error err;
        if(len(s) == 0)
        {
            err = ErrSyntax;
            return {value, multibyte, tail, err};
        }
        //Go switch emulation
        {
            auto c = s[0];
            int conditionId = -1;
            if(c == quote && (quote == '\'' || quote == '"')) { conditionId = 0; }
            else if(c >= utf8::RuneSelf) { conditionId = 1; }
            else if(c != '\\') { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    err = ErrSyntax;
                    return {value, multibyte, tail, err};
                    break;
                case 1:
                    auto [r, size] = utf8::DecodeRuneInString(s);
                    return {r, true, s.make_slice(size), nullptr};
                    break;
                case 2:
                    return {gocpp::rune(s[0]), false, s.make_slice(1), nullptr};
                    break;
            }
        }
        if(len(s) <= 1)
        {
            err = ErrSyntax;
            return {value, multibyte, tail, err};
        }
        auto c = s[1];
        s = s.make_slice(2);
        //Go switch emulation
        {
            auto condition = c;
            int conditionId = -1;
            if(condition == 'a') { conditionId = 0; }
            else if(condition == 'b') { conditionId = 1; }
            else if(condition == 'f') { conditionId = 2; }
            else if(condition == 'n') { conditionId = 3; }
            else if(condition == 'r') { conditionId = 4; }
            else if(condition == 't') { conditionId = 5; }
            else if(condition == 'v') { conditionId = 6; }
            else if(condition == 'x') { conditionId = 7; }
            else if(condition == 'u') { conditionId = 8; }
            else if(condition == 'U') { conditionId = 9; }
            else if(condition == '0') { conditionId = 10; }
            else if(condition == '1') { conditionId = 11; }
            else if(condition == '2') { conditionId = 12; }
            else if(condition == '3') { conditionId = 13; }
            else if(condition == '4') { conditionId = 14; }
            else if(condition == '5') { conditionId = 15; }
            else if(condition == '6') { conditionId = 16; }
            else if(condition == '7') { conditionId = 17; }
            else if(condition == '\\') { conditionId = 18; }
            else if(condition == '\'') { conditionId = 19; }
            else if(condition == '"') { conditionId = 20; }
            switch(conditionId)
            {
                case 0:
                    value = '\a';
                    break;
                case 1:
                    value = '\b';
                    break;
                case 2:
                    value = '\f';
                    break;
                case 3:
                    value = '\n';
                    break;
                case 4:
                    value = '\r';
                    break;
                case 5:
                    value = '\t';
                    break;
                case 6:
                    value = '\v';
                    break;
                case 7:
                case 8:
                case 9:
                    auto n = 0;
                    //Go switch emulation
                    {
                        auto condition = c;
                        int conditionId = -1;
                        if(condition == 'x') { conditionId = 0; }
                        else if(condition == 'u') { conditionId = 1; }
                        else if(condition == 'U') { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                n = 2;
                                break;
                            case 1:
                                n = 4;
                                break;
                            case 2:
                                n = 8;
                                break;
                        }
                    }
                    gocpp::rune v = {};
                    if(len(s) < n)
                    {
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    for(auto j = 0; j < n; j++)
                    {
                        auto [x, ok] = unhex(s[j]);
                        if(! ok)
                        {
                            err = ErrSyntax;
                            return {value, multibyte, tail, err};
                        }
                        v = (v << 4) | x;
                    }
                    s = s.make_slice(n);
                    if(c == 'x')
                    {
                        value = v;
                        break;
                    }
                    if(! utf8::ValidRune(v))
                    {
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    value = v;
                    multibyte = true;
                    break;
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                    auto v = gocpp::rune(c) - '0';
                    if(len(s) < 2)
                    {
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    for(auto j = 0; j < 2; j++)
                    {
                        auto x = gocpp::rune(s[j]) - '0';
                        if(x < 0 || x > 7)
                        {
                            err = ErrSyntax;
                            return {value, multibyte, tail, err};
                        }
                        v = (v << 3) | x;
                    }
                    s = s.make_slice(2);
                    if(v > 255)
                    {
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    value = v;
                    break;
                case 18:
                    value = '\\';
                    break;
                case 19:
                case 20:
                    if(c != quote)
                    {
                        err = ErrSyntax;
                        return {value, multibyte, tail, err};
                    }
                    value = gocpp::rune(c);
                    break;
                default:
                    err = ErrSyntax;
                    return {value, multibyte, tail, err};
                    break;
            }
        }
        tail = s;
        return {value, multibyte, tail, err};
    }

    // QuotedPrefix returns the quoted string (as understood by Unquote) at the prefix of s.
    // If s does not start with a valid quoted string, QuotedPrefix returns an error.
    std::tuple<gocpp::string, struct gocpp::error> QuotedPrefix(gocpp::string s)
    {
        auto [out, gocpp_id_0, err] = unquote(s, false);
        return {out, err};
    }

    // Unquote interprets s as a single-quoted, double-quoted,
    // or backquoted Go string literal, returning the string value
    // that s quotes.  (If s is single-quoted, it would be a Go
    // character literal; Unquote returns the corresponding
    // one-character string.)
    std::tuple<gocpp::string, struct gocpp::error> Unquote(gocpp::string s)
    {
        auto [out, rem, err] = unquote(s, true);
        if(len(rem) > 0)
        {
            return {""_s, ErrSyntax};
        }
        return {out, err};
    }

    // unquote parses a quoted string at the start of the input,
    // returning the parsed prefix, the remaining suffix, and any parse errors.
    // If unescape is true, the parsed prefix is unescaped,
    // otherwise the input prefix is provided verbatim.
    std::tuple<gocpp::string, gocpp::string, struct gocpp::error> unquote(gocpp::string in, bool unescape)
    {
        gocpp::string out;
        gocpp::string rem;
        struct gocpp::error err;
        if(len(in) < 2)
        {
            return {""_s, in, ErrSyntax};
        }
        auto quote = in[0];
        auto end = index(in.make_slice(1), quote);
        if(end < 0)
        {
            return {""_s, in, ErrSyntax};
        }
        end += 2;
        //Go switch emulation
        {
            auto condition = quote;
            int conditionId = -1;
            if(condition == '`') { conditionId = 0; }
            else if(condition == '"') { conditionId = 1; }
            else if(condition == '\'') { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(! unescape) { conditionId = 0; }
                        else if(! contains(in.make_slice(0, end), '\r')) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                out = in.make_slice(0, end);
                                break;
                            case 1:
                                out = in.make_slice(len("`"_s), end - len("`"_s));
                                break;
                            default:
                                auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, end - len("`"_s) - len("\r"_s) - len("`"_s));
                                for(auto i = len("`"_s); i < end - len("`"_s); i++)
                                {
                                    if(in[i] != '\r')
                                    {
                                        buf = append(buf, in[i]);
                                    }
                                }
                                out = gocpp::string(buf);
                                break;
                        }
                    }
                    return {out, in.make_slice(end), nullptr};
                    break;
                case 1:
                case 2:
                    if(! contains(in.make_slice(0, end), '\\') && ! contains(in.make_slice(0, end), '\n'))
                    {
                        bool valid = {};
                        //Go switch emulation
                        {
                            auto condition = quote;
                            int conditionId = -1;
                            if(condition == '"') { conditionId = 0; }
                            else if(condition == '\'') { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    valid = utf8::ValidString(in.make_slice(len("""_s), end - len("""_s)));
                                    break;
                                case 1:
                                    auto [r, n] = utf8::DecodeRuneInString(in.make_slice(len("'"_s), end - len("'"_s)));
                                    valid = len("'"_s) + n + len("'"_s) == end && (r != utf8::RuneError || n != 1);
                                    break;
                            }
                        }
                        if(valid)
                        {
                            out = in.make_slice(0, end);
                            if(unescape)
                            {
                                out = out.make_slice(1, end - 1);
                            }
                            return {out, in.make_slice(end), nullptr};
                        }
                    }
                    // Handle quoted strings with escape sequences.
                    gocpp::slice<unsigned char> buf = {};
                    auto in0 = in;
                    in = in.make_slice(1);
                    if(unescape)
                    {
                        buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 3 * end / 2);
                    }
                    for(; len(in) > 0 && in[0] != quote; )
                    {
                        auto [r, multibyte, rem, err] = UnquoteChar(in, quote);
                        if(in[0] == '\n' || err != nullptr)
                        {
                            return {""_s, in0, ErrSyntax};
                        }
                        in = rem;
                        if(unescape)
                        {
                            if(r < utf8::RuneSelf || ! multibyte)
                            {
                                buf = append(buf, (unsigned char)(r));
                            }
                            else
                            {
                                buf = utf8::AppendRune(buf, r);
                            }
                        }
                        if(quote == '\'')
                        {
                            break;
                        }
                    }
                    if(! (len(in) > 0 && in[0] == quote))
                    {
                        return {""_s, in0, ErrSyntax};
                    }
                    in = in.make_slice(1);
                    if(unescape)
                    {
                        return {gocpp::string(buf), in, nullptr};
                    }
                    return {in0.make_slice(0, len(in0) - len(in)), in, nullptr};
                    break;
                default:
                    return {""_s, in, ErrSyntax};
                    break;
            }
        }
    }

    // bsearch16 returns the smallest i such that a[i] >= x.
    // If there is no such i, bsearch16 returns len(a).
    int bsearch16(gocpp::slice<uint16_t> a, uint16_t x)
    {
        auto [i, j] = std::tuple{0, len(a)};
        for(; i < j; )
        {
            auto h = i + ((j - i) >> 1);
            if(a[h] < x)
            {
                i = h + 1;
            }
            else
            {
                j = h;
            }
        }
        return i;
    }

    // bsearch32 returns the smallest i such that a[i] >= x.
    // If there is no such i, bsearch32 returns len(a).
    int bsearch32(gocpp::slice<uint32_t> a, uint32_t x)
    {
        auto [i, j] = std::tuple{0, len(a)};
        for(; i < j; )
        {
            auto h = i + ((j - i) >> 1);
            if(a[h] < x)
            {
                i = h + 1;
            }
            else
            {
                j = h;
            }
        }
        return i;
    }

    // IsPrint reports whether the rune is defined as printable by Go, with
    // the same definition as unicode.IsPrint: letters, numbers, punctuation,
    // symbols and ASCII space.
    bool IsPrint(gocpp::rune r)
    {
        if(r <= 0xFF)
        {
            if(0x20 <= r && r <= 0x7E)
            {
                return true;
            }
            if(0xA1 <= r && r <= 0xFF)
            {
                return r != 0xAD;
            }
            return false;
        }
        if(0 <= r && r < (1 << 16))
        {
            auto [rr, isPrint, isNotPrint] = std::tuple{uint16_t(r), isPrint16, isNotPrint16};
            auto i = bsearch16(isPrint, rr);
            if(i >= len(isPrint) || rr < isPrint[i &^ 1] || isPrint[i | 1] < rr)
            {
                return false;
            }
            auto j = bsearch16(isNotPrint, rr);
            return j >= len(isNotPrint) || isNotPrint[j] != rr;
        }
        auto [rr, isPrint, isNotPrint] = std::tuple{uint32_t(r), isPrint32, isNotPrint32};
        auto i = bsearch32(isPrint, rr);
        if(i >= len(isPrint) || rr < isPrint[i &^ 1] || isPrint[i | 1] < rr)
        {
            return false;
        }
        if(r >= 0x20000)
        {
            return true;
        }
        r -= 0x10000;
        auto j = bsearch16(isNotPrint, uint16_t(r));
        return j >= len(isNotPrint) || isNotPrint[j] != uint16_t(r);
    }

    // IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such
    // characters include letters, marks, numbers, punctuation, symbols, and
    // spaces, from categories L, M, N, P, S, and Zs.
    bool IsGraphic(gocpp::rune r)
    {
        if(IsPrint(r))
        {
            return true;
        }
        return isInGraphicList(r);
    }

    // isInGraphicList reports whether the rune is in the isGraphic list. This separation
    // from IsGraphic allows quoteWith to avoid two calls to IsPrint.
    // Should be called only if IsPrint fails.
    bool isInGraphicList(gocpp::rune r)
    {
        if(r > 0xFFFF)
        {
            return false;
        }
        auto rr = uint16_t(r);
        auto i = bsearch16(isGraphic, rr);
        return i < len(isGraphic) && rr == isGraphic[i];
    }

}

