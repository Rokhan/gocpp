// generated by GoCpp from file '$(ImportDir)/time/sleep.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/sleep.h"
#include "gocpp/support.h"

#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace time::rec;
    }

    void Sleep(time::Duration d)
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeTimer::operator T()
    {
        T result;
        result.pp = this->pp;
        result.when = this->when;
        result.period = this->period;
        result.f = this->f;
        result.arg = this->arg;
        result.seq = this->seq;
        result.nextwhen = this->nextwhen;
        result.status = this->status;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeTimer::operator==(const T& ref) const
    {
        if (pp != ref.pp) return false;
        if (when != ref.when) return false;
        if (period != ref.period) return false;
        if (f != ref.f) return false;
        if (arg != ref.arg) return false;
        if (seq != ref.seq) return false;
        if (nextwhen != ref.nextwhen) return false;
        if (status != ref.status) return false;
        return true;
    }

    std::ostream& runtimeTimer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pp;
        os << " " << when;
        os << " " << period;
        os << " " << f;
        os << " " << arg;
        os << " " << seq;
        os << " " << nextwhen;
        os << " " << status;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeTimer& value)
    {
        return value.PrintTo(os);
    }

    int64_t when(time::Duration d)
    {
        if(d <= 0)
        {
            return runtimeNano();
        }
        auto t = runtimeNano() + int64_t(d);
        if(t < 0)
        {
            t = (1 << 63) - 1;
        }
        return t;
    }

    void startTimer(runtimeTimer*)
    /* convertBlockStmt, nil block */;

    bool stopTimer(runtimeTimer*)
    /* convertBlockStmt, nil block */;

    bool resetTimer(runtimeTimer*, int64_t)
    /* convertBlockStmt, nil block */;

    void modTimer(struct runtimeTimer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq)
    /* convertBlockStmt, nil block */;

    
    template<typename T> requires gocpp::GoStruct<T>
    Timer::operator T()
    {
        T result;
        result.C = this->C;
        result.r = this->r;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Timer::operator==(const T& ref) const
    {
        if (C != ref.C) return false;
        if (r != ref.r) return false;
        return true;
    }

    std::ostream& Timer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << C;
        os << " " << r;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Timer& value)
    {
        return value.PrintTo(os);
    }

    bool rec::Stop(struct Timer* t)
    {
        if(t->r.f == nullptr)
        {
            gocpp::panic("time: Stop called on uninitialized Timer");
        }
        return stopTimer(& t->r);
    }

    struct Timer* NewTimer(time::Duration d)
    {
        auto c = gocpp::make(gocpp::Tag<gocpp::channel<Time>>(), 1);
        auto t = gocpp::InitPtr<Timer>([](Timer& x) { x.C = c; x.r = gocpp::Init<runtimeTimer>([](runtimeTimer& x) { x.when = when(d); x.f = sendTime; x.arg = c; }); });
        startTimer(& t->r);
        return t;
    }

    bool rec::Reset(struct Timer* t, time::Duration d)
    {
        if(t->r.f == nullptr)
        {
            gocpp::panic("time: Reset called on uninitialized Timer");
        }
        auto w = when(d);
        return resetTimer(& t->r, w);
    }

    void sendTime(go_any c, uintptr_t seq)
    {
        //Go select emulation
        {
            int conditionId = -1;
            if(gocpp::getValue<gocpp::channel<time::Time>>(c).trySend(Now())) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    break;
                default:
                    break;
            }
        }
        std::this_thread::yield();
    }

    gocpp::channel<Time> After(time::Duration d)
    {
        return NewTimer(d)->C;
    }

    struct Timer* AfterFunc(time::Duration d, std::function<void ()> f)
    {
        auto t = gocpp::InitPtr<Timer>([](Timer& x) { x.r = gocpp::Init<runtimeTimer>([](runtimeTimer& x) { x.when = when(d); x.f = goFunc; x.arg = f; }); });
        startTimer(& t->r);
        return t;
    }

    void goFunc(go_any arg, uintptr_t seq)
    {
        gocpp::go([&]{ gocpp::getValue<std::function<void (void)>>(arg)(); });
    }

}

