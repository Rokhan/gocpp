// generated by GoCpp from file '$(ImportDir)/runtime/trace2map.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2map.h"
#include "gocpp/support.h"

#include "golang/runtime/alg.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/trace2region.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using atomic::rec::StoreNoWB;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceMap::operator T()
    {
        T result;
        result.lock = this->lock;
        result.seq = this->seq;
        result.mem = this->mem;
        result.tab = this->tab;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceMap::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (seq != ref.seq) return false;
        if (mem != ref.mem) return false;
        if (tab != ref.tab) return false;
        return true;
    }

    std::ostream& traceMap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << seq;
        os << " " << mem;
        os << " " << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceMap& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceMapNode::operator T()
    {
        T result;
        result._1 = this->_1;
        result.link = this->link;
        result.hash = this->hash;
        result.id = this->id;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceMapNode::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (link != ref.link) return false;
        if (hash != ref.hash) return false;
        if (id != ref.id) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& traceMapNode::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << link;
        os << " " << hash;
        os << " " << id;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceMapNode& value)
    {
        return value.PrintTo(os);
    }

    // next is a type-safe wrapper around link.
    struct traceMapNode* rec::next(golang::runtime::traceMapNode* n)
    {
        return (traceMapNode*)(rec::Load(gocpp::recv(n->link)));
    }

    // stealID steals an ID from the table, ensuring that it will not
    // appear in the table anymore.
    uint64_t rec::stealID(golang::runtime::traceMap* tab)
    {
        return rec::Add(gocpp::recv(tab->seq), 1);
    }

    // put inserts the data into the table.
    //
    // It's always safe to noescape data because its bytes are always copied.
    //
    // Returns a unique ID for the data and whether this is the first time
    // the data has been added to the map.
    std::tuple<uint64_t, bool> rec::put(golang::runtime::traceMap* tab, unsafe::Pointer data, uintptr_t size)
    {
        if(size == 0)
        {
            return {0, false};
        }
        auto hash = memhash(data, 0, size);
        if(auto id = rec::find(gocpp::recv(tab), data, size, hash); id != 0)
        {
            return {id, false};
        }
        // Now, double check under the mutex.
        // Switch to the system stack so we can acquire tab.lock
        uint64_t id = {};
        bool added = {};
        systemstack([=]() mutable -> void
        {
            lock(& tab->lock);
            if(id = rec::find(gocpp::recv(tab), data, size, hash); id != 0)
            {
                unlock(& tab->lock);
                return;
            }
            id = rec::Add(gocpp::recv(tab->seq), 1);
            auto vd = rec::newTraceMapNode(gocpp::recv(tab), data, size, hash, id);
            auto part = int(hash % uintptr_t(len(tab->tab)));
            rec::StoreNoWB(gocpp::recv(vd->link), rec::Load(gocpp::recv(tab->tab[part])));
            rec::StoreNoWB(gocpp::recv(tab->tab[part]), unsafe::Pointer(vd));
            unlock(& tab->lock);
            added = true;
        });
        return {id, added};
    }

    // find looks up data in the table, assuming hash is a hash of data.
    //
    // Returns 0 if the data is not found, and the unique ID for it if it is.
    uint64_t rec::find(golang::runtime::traceMap* tab, unsafe::Pointer data, uintptr_t size, uintptr_t hash)
    {
        auto part = int(hash % uintptr_t(len(tab->tab)));
        for(auto vd = rec::bucket(gocpp::recv(tab), part); vd != nullptr; vd = rec::next(gocpp::recv(vd)))
        {
            if(vd->hash == hash && uintptr_t(len(vd->data)) == size)
            {
                if(memequal(unsafe::Pointer(& vd->data[0]), data, size))
                {
                    return vd->id;
                }
            }
        }
        return 0;
    }

    // bucket is a type-safe wrapper for looking up a value in tab.tab.
    struct traceMapNode* rec::bucket(golang::runtime::traceMap* tab, int part)
    {
        return (traceMapNode*)(rec::Load(gocpp::recv(tab->tab[part])));
    }

    struct traceMapNode* rec::newTraceMapNode(golang::runtime::traceMap* tab, unsafe::Pointer data, uintptr_t size, uintptr_t hash, uint64_t id)
    {
        auto sl = gocpp::Init<notInHeapSlice>([=](auto& x) {
            x.array = rec::alloc(gocpp::recv(tab->mem), size);
            x.len = int(size);
            x.cap = int(size);
        });
        memmove(unsafe::Pointer(sl.array), data, size);
        auto meta = (traceMapNode*)(unsafe::Pointer(rec::alloc(gocpp::recv(tab->mem), gocpp::Sizeof<traceMapNode>())));
        *(notInHeapSlice*)(unsafe::Pointer(& meta->data)) = sl;
        meta->id = id;
        meta->hash = hash;
        return meta;
    }

    // reset drops all allocated memory from the table and resets it.
    //
    // tab.lock must be held. Must run on the system stack because of this.
    //
    //go:systemstack
    void rec::reset(golang::runtime::traceMap* tab)
    {
        assertLockHeld(& tab->lock);
        rec::drop(gocpp::recv(tab->mem));
        rec::Store(gocpp::recv(tab->seq), 0);
        memclrNoHeapPointers(unsafe::Pointer(& tab->tab), gocpp::Sizeof<atomic::UnsafePointer, 8192>>());
    }

}

