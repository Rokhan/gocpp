// generated by GoCpp from file '$(ImportDir)/runtime/mfinal.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mfinal.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/runtime/arena.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/iface.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using abi::rec::InSlice;
        using abi::rec::IsVariadic;
        using abi::rec::OutSlice;
        using abi::rec::Uncommon;
        using atomic::rec::And;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Or;
    }

    // finblock is an array of finalizers to be executed. finblocks are
    // arranged in a linked list for the finalizer queue.
    //
    // finblock is allocated from non-GC'd memory, so any heap pointers
    // must be specially handled. GC currently assumes that the finalizer
    // queue does not grow during marking (but it can shrink).
    
    template<typename T> requires gocpp::GoStruct<T>
    finblock::operator T()
    {
        T result;
        result._1 = this->_1;
        result.alllink = this->alllink;
        result.next = this->next;
        result.cnt = this->cnt;
        result._2 = this->_2;
        result.fin = this->fin;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool finblock::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (alllink != ref.alllink) return false;
        if (next != ref.next) return false;
        if (cnt != ref.cnt) return false;
        if (_2 != ref._2) return false;
        if (fin != ref.fin) return false;
        return true;
    }

    std::ostream& finblock::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << alllink;
        os << " " << next;
        os << " " << cnt;
        os << " " << _2;
        os << " " << fin;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct finblock& value)
    {
        return value.PrintTo(os);
    }

    atomic::Uint32 fingStatus;
    // finalizer goroutine status.
    mutex finlock;
    g* fing;
    finblock* finq;
    finblock* finc;
    gocpp::array<unsigned char, _FinBlockSize / goarch::PtrSize / 8> finptrmask;
    finblock* allfin;
    // NOTE: Layout known to queuefinalizer.
    
    template<typename T> requires gocpp::GoStruct<T>
    finalizer::operator T()
    {
        T result;
        result.fn = this->fn;
        result.arg = this->arg;
        result.nret = this->nret;
        result.fint = this->fint;
        result.ot = this->ot;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool finalizer::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (arg != ref.arg) return false;
        if (nret != ref.nret) return false;
        if (fint != ref.fint) return false;
        if (ot != ref.ot) return false;
        return true;
    }

    std::ostream& finalizer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << arg;
        os << " " << nret;
        os << " " << fint;
        os << " " << ot;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct finalizer& value)
    {
        return value.PrintTo(os);
    }

    gocpp::array<unsigned char, 5> finalizer1 = gocpp::array<unsigned char, 5> {(1 << 0) | (1 << 1) | (0 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (0 << 7), (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (0 << 4) | (1 << 5) | (1 << 6) | (1 << 7), (1 << 0) | (0 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (0 << 6) | (1 << 7), (1 << 0) | (1 << 1) | (1 << 2) | (0 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7), (0 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (0 << 5) | (1 << 6) | (1 << 7)};
    // lockRankMayQueueFinalizer records the lock ranking effects of a
    // function that may call queuefinalizer.
    void lockRankMayQueueFinalizer()
    {
        lockWithRankMayAcquire(& finlock, getLockRank(& finlock));
    }

    void queuefinalizer(gocpp::unsafe_pointer p, struct funcval* fn, uintptr_t nret, golang::runtime::_type* fint, golang::runtime::ptrtype* ot)
    {
        if(gcphase != _GCoff)
        {
            go_throw("queuefinalizer during GC"_s);
        }
        lock(& finlock);
        if(finq == nullptr || finq->cnt == uint32_t(len(finq->fin)))
        {
            if(finc == nullptr)
            {
                finc = (finblock*)(persistentalloc(_FinBlockSize, 0, & memstats.gcMiscSys));
                finc->alllink = allfin;
                allfin = finc;
                if(finptrmask[0] == 0)
                {
                    if((gocpp::Sizeof<finalizer>() != 5 * goarch::PtrSize || unsafe::Offsetof(finalizer {}.fn) != 0 || unsafe::Offsetof(finalizer {}.arg) != goarch::PtrSize || unsafe::Offsetof(finalizer {}.nret) != 2 * goarch::PtrSize || unsafe::Offsetof(finalizer {}.fint) != 3 * goarch::PtrSize || unsafe::Offsetof(finalizer {}.ot) != 4 * goarch::PtrSize))
                    {
                        go_throw("finalizer out of sync"_s);
                    }
                    for(auto [i, gocpp_ignored] : finptrmask)
                    {
                        finptrmask[i] = finalizer1[i % len(finalizer1)];
                    }
                }
            }
            auto block = finc;
            finc = block->next;
            block->next = finq;
            finq = block;
        }
        auto f = & finq->fin[finq->cnt];
        atomic::Xadd(& finq->cnt, + 1);
        f->fn = fn;
        f->nret = nret;
        f->fint = fint;
        f->ot = ot;
        f->arg = p;
        unlock(& finlock);
        rec::Or(gocpp::recv(fingStatus), fingWake);
    }

    //go:nowritebarrier
    void iterate_finq(std::function<void (struct funcval* _1, gocpp::unsafe_pointer _2, uintptr_t _3, golang::runtime::_type* _4, golang::runtime::ptrtype* _5)> callback)
    {
        for(auto fb = allfin; fb != nullptr; fb = fb->alllink)
        {
            for(auto i = uint32_t(0); i < fb->cnt; i++)
            {
                auto f = & fb->fin[i];
                callback(f->fn, f->arg, f->nret, f->fint, f->ot);
            }
        }
    }

    struct g* wakefing()
    {
        if(auto ok = rec::CompareAndSwap(gocpp::recv(fingStatus), fingCreated | fingWait | fingWake, fingCreated); ok)
        {
            return fing;
        }
        return nullptr;
    }

    void createfing()
    {
        if(rec::Load(gocpp::recv(fingStatus)) == fingUninitialized && rec::CompareAndSwap(gocpp::recv(fingStatus), fingUninitialized, fingCreated))
        {
            gocpp::go([&]{ runfinq(); });
        }
    }

    bool finalizercommit(struct g* gp, gocpp::unsafe_pointer lock)
    {
        unlock((mutex*)(lock));
        rec::Or(gocpp::recv(fingStatus), fingWait);
        return true;
    }

    // This is the goroutine that runs all of the finalizers.
    void runfinq()
    {
        gocpp::unsafe_pointer frame = {};
        uintptr_t framecap = {};
        int argRegs = {};
        auto gp = getg();
        lock(& finlock);
        fing = gp;
        unlock(& finlock);
        for(; ; )
        {
            lock(& finlock);
            auto fb = finq;
            finq = nullptr;
            if(fb == nullptr)
            {
                gopark(finalizercommit, gocpp::unsafe_pointer(& finlock), waitReasonFinalizerWait, traceBlockSystemGoroutine, 1);
                continue;
            }
            argRegs = intArgRegs;
            unlock(& finlock);
            if(raceenabled)
            {
                racefingo();
            }
            for(; fb != nullptr; )
            {
                for(auto i = fb->cnt; i > 0; i--)
                {
                    auto f = & fb->fin[i - 1];
                    abi::RegArgs regs = {};
                    auto framesz = gocpp::Sizeof<go_any>() + f->nret;
                    if(framecap < framesz)
                    {
                        frame = mallocgc(framesz, nullptr, true);
                        framecap = framesz;
                    }
                    if(f->fint == nullptr)
                    {
                        go_throw("missing type in runfinq"_s);
                    }
                    auto r = frame;
                    if(argRegs > 0)
                    {
                        r = gocpp::unsafe_pointer(& regs.Ints);
                    }
                    else
                    {
                        *(gocpp::array_ptr<gocpp::array<uintptr_t, 2>>)(frame) = gocpp::array<uintptr_t, 2> {};
                    }
                    //Go switch emulation
                    {
                        auto condition = f->fint->Kind_ & kindMask;
                        int conditionId = -1;
                        if(condition == kindPtr) { conditionId = 0; }
                        else if(condition == kindInterface) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                *(gocpp::unsafe_pointer*)(r) = f->arg;
                                break;
                            case 1:
                                auto ityp = (runtime::interfacetype*)(gocpp::unsafe_pointer(f->fint));
                                (eface*)(r)->_type = & f->ot->Type;
                                (eface*)(r)->data = f->arg;
                                if(len(ityp->Methods) != 0)
                                {
                                    (iface*)(r)->tab = assertE2I(ityp, (eface*)(r)->_type);
                                }
                                break;
                            default:
                                go_throw("bad kind in runfinq"_s);
                                break;
                        }
                    }
                    rec::Or(gocpp::recv(fingStatus), fingRunningFinalizer);
                    reflectcall(nullptr, gocpp::unsafe_pointer(f->fn), frame, uint32_t(framesz), uint32_t(framesz), uint32_t(framesz), & regs);
                    rec::And(gocpp::recv(fingStatus), ~ fingRunningFinalizer);
                    f->fn = nullptr;
                    f->arg = nullptr;
                    f->ot = nullptr;
                    atomic::Store(& fb->cnt, i - 1);
                }
                auto next = fb->next;
                lock(& finlock);
                fb->next = finc;
                finc = fb;
                unlock(& finlock);
                fb = next;
            }
        }
    }

    bool isGoPointerWithoutSpan(gocpp::unsafe_pointer p)
    {
        if(p == gocpp::unsafe_pointer(& zerobase))
        {
            return true;
        }
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(datap->noptrdata <= uintptr_t(p) && uintptr_t(p) < datap->enoptrdata || datap->data <= uintptr_t(p) && uintptr_t(p) < datap->edata || datap->bss <= uintptr_t(p) && uintptr_t(p) < datap->ebss || datap->noptrbss <= uintptr_t(p) && uintptr_t(p) < datap->enoptrbss)
            {
                return true;
            }
        }
        return false;
    }

    // blockUntilEmptyFinalizerQueue blocks until either the finalizer
    // queue is emptied (and the finalizers have executed) or the timeout
    // is reached. Returns true if the finalizer queue was emptied.
    // This is used by the runtime and sync tests.
    bool blockUntilEmptyFinalizerQueue(int64_t timeout)
    {
        auto start = nanotime();
        for(; nanotime() - start < timeout; )
        {
            lock(& finlock);
            auto empty = finq == nullptr;
            empty = empty && readgstatus(fing) == _Gwaiting && fing->waitreason == waitReasonFinalizerWait;
            unlock(& finlock);
            if(empty)
            {
                return true;
            }
            Gosched();
        }
        return false;
    }

    // SetFinalizer sets the finalizer associated with obj to the provided
    // finalizer function. When the garbage collector finds an unreachable block
    // with an associated finalizer, it clears the association and runs
    // finalizer(obj) in a separate goroutine. This makes obj reachable again,
    // but now without an associated finalizer. Assuming that SetFinalizer
    // is not called again, the next time the garbage collector sees
    // that obj is unreachable, it will free obj.
    //
    // SetFinalizer(obj, nil) clears any finalizer associated with obj.
    //
    // The argument obj must be a pointer to an object allocated by calling
    // new, by taking the address of a composite literal, or by taking the
    // address of a local variable.
    // The argument finalizer must be a function that takes a single argument
    // to which obj's type can be assigned, and can have arbitrary ignored return
    // values. If either of these is not true, SetFinalizer may abort the
    // program.
    //
    // Finalizers are run in dependency order: if A points at B, both have
    // finalizers, and they are otherwise unreachable, only the finalizer
    // for A runs; once A is freed, the finalizer for B can run.
    // If a cyclic structure includes a block with a finalizer, that
    // cycle is not guaranteed to be garbage collected and the finalizer
    // is not guaranteed to run, because there is no ordering that
    // respects the dependencies.
    //
    // The finalizer is scheduled to run at some arbitrary time after the
    // program can no longer reach the object to which obj points.
    // There is no guarantee that finalizers will run before a program exits,
    // so typically they are useful only for releasing non-memory resources
    // associated with an object during a long-running program.
    // For example, an [os.File] object could use a finalizer to close the
    // associated operating system file descriptor when a program discards
    // an os.File without calling Close, but it would be a mistake
    // to depend on a finalizer to flush an in-memory I/O buffer such as a
    // [bufio.Writer], because the buffer would not be flushed at program exit.
    //
    // It is not guaranteed that a finalizer will run if the size of *obj is
    // zero bytes, because it may share same address with other zero-size
    // objects in memory. See https://go.dev/ref/spec#Size_and_alignment_guarantees.
    //
    // It is not guaranteed that a finalizer will run for objects allocated
    // in initializers for package-level variables. Such objects may be
    // linker-allocated, not heap-allocated.
    //
    // Note that because finalizers may execute arbitrarily far into the future
    // after an object is no longer referenced, the runtime is allowed to perform
    // a space-saving optimization that batches objects together in a single
    // allocation slot. The finalizer for an unreferenced object in such an
    // allocation may never run if it always exists in the same batch as a
    // referenced object. Typically, this batching only happens for tiny
    // (on the order of 16 bytes or less) and pointer-free objects.
    //
    // A finalizer may run as soon as an object becomes unreachable.
    // In order to use finalizers correctly, the program must ensure that
    // the object is reachable until it is no longer required.
    // Objects stored in global variables, or that can be found by tracing
    // pointers from a global variable, are reachable. For other objects,
    // pass the object to a call of the [KeepAlive] function to mark the
    // last point in the function where the object must be reachable.
    //
    // For example, if p points to a struct, such as os.File, that contains
    // a file descriptor d, and p has a finalizer that closes that file
    // descriptor, and if the last use of p in a function is a call to
    // syscall.Write(p.d, buf, size), then p may be unreachable as soon as
    // the program enters [syscall.Write]. The finalizer may run at that moment,
    // closing p.d, causing syscall.Write to fail because it is writing to
    // a closed file descriptor (or, worse, to an entirely different
    // file descriptor opened by a different goroutine). To avoid this problem,
    // call KeepAlive(p) after the call to syscall.Write.
    //
    // A single goroutine runs all finalizers for a program, sequentially.
    // If a finalizer must run for a long time, it should do so by starting
    // a new goroutine.
    //
    // In the terminology of the Go memory model, a call
    // SetFinalizer(x, f) “synchronizes before” the finalization call f(x).
    // However, there is no guarantee that KeepAlive(x) or any other use of x
    // “synchronizes before” f(x), so in general a finalizer should use a mutex
    // or other synchronization mechanism if it needs to access mutable state in x.
    // For example, consider a finalizer that inspects a mutable field in x
    // that is modified from time to time in the main program before x
    // becomes unreachable and the finalizer is invoked.
    // The modifications in the main program and the inspection in the finalizer
    // need to use appropriate synchronization, such as mutexes or atomic updates,
    // to avoid read-write races.
    void SetFinalizer(go_any obj, go_any finalizer)
    {
        if(debug.sbrk != 0)
        {
            return;
        }
        auto e = efaceOf(& obj);
        auto etyp = e->_type;
        if(etyp == nullptr)
        {
            go_throw("runtime.SetFinalizer: first argument is nil"_s);
        }
        if(etyp->Kind_ & kindMask != kindPtr)
        {
            go_throw("runtime.SetFinalizer: first argument is "_s + rec::string(gocpp::recv(toRType(etyp))) + ", not pointer"_s);
        }
        auto ot = (runtime::ptrtype*)(gocpp::unsafe_pointer(etyp));
        if(ot->Elem == nullptr)
        {
            go_throw("nil elem type!"_s);
        }
        if(inUserArenaChunk(uintptr_t(e->data)))
        {
            go_throw("runtime.SetFinalizer: first argument was allocated into an arena"_s);
        }
        auto [base, span, gocpp_id_0] = findObject(uintptr_t(e->data), 0, 0);
        if(base == 0)
        {
            if(isGoPointerWithoutSpan(e->data))
            {
                return;
            }
            go_throw("runtime.SetFinalizer: pointer not in allocated block"_s);
        }
        if(goexperiment::AllocHeaders && ! rec::noscan(gocpp::recv(span->spanclass)) && ! heapBitsInSpan(span->elemsize) && rec::sizeclass(gocpp::recv(span->spanclass)) != 0)
        {
            base += mallocHeaderSize;
        }
        if(uintptr_t(e->data) != base)
        {
            if(ot->Elem == nullptr || ot->Elem->PtrBytes != 0 || ot->Elem->Size_ >= maxTinySize)
            {
                go_throw("runtime.SetFinalizer: pointer not at beginning of allocated block"_s);
            }
        }
        auto f = efaceOf(& finalizer);
        auto ftyp = f->_type;
        if(ftyp == nullptr)
        {
            systemstack([=]() mutable -> void
            {
                removefinalizer(e->data);
            });
            return;
        }
        if(ftyp->Kind_ & kindMask != kindFunc)
        {
            go_throw("runtime.SetFinalizer: second argument is "_s + rec::string(gocpp::recv(toRType(ftyp))) + ", not a function"_s);
        }
        auto ft = (runtime::functype*)(gocpp::unsafe_pointer(ftyp));
        if(rec::IsVariadic(gocpp::recv(ft)))
        {
            go_throw("runtime.SetFinalizer: cannot pass "_s + rec::string(gocpp::recv(toRType(etyp))) + " to finalizer "_s + rec::string(gocpp::recv(toRType(ftyp))) + " because dotdotdot"_s);
        }
        if(ft->InCount != 1)
        {
            go_throw("runtime.SetFinalizer: cannot pass "_s + rec::string(gocpp::recv(toRType(etyp))) + " to finalizer "_s + rec::string(gocpp::recv(toRType(ftyp))));
        }
        auto fint = rec::InSlice(gocpp::recv(ft))[0];
        //Go switch emulation
        {
            int conditionId = -1;
            if(fint == etyp) { conditionId = 0; }
            else if(fint->Kind_ & kindMask == kindPtr) { conditionId = 1; }
            else if(fint->Kind_ & kindMask == kindInterface) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    goto okarg;
                    break;
                case 1:
                    if((rec::Uncommon(gocpp::recv(fint)) == nullptr || rec::Uncommon(gocpp::recv(etyp)) == nullptr) && (runtime::ptrtype*)(gocpp::unsafe_pointer(fint))->Elem == ot->Elem)
                    {
                        goto okarg;
                    }
                    break;
                case 2:
                    auto ityp = (runtime::interfacetype*)(gocpp::unsafe_pointer(fint));
                    if(len(ityp->Methods) == 0)
                    {
                        goto okarg;
                    }
                    if(auto itab = assertE2I2(ityp, efaceOf(& obj)->_type); itab != nullptr)
                    {
                        goto okarg;
                    }
                    break;
            }
        }
        go_throw("runtime.SetFinalizer: cannot pass "_s + rec::string(gocpp::recv(toRType(etyp))) + " to finalizer "_s + rec::string(gocpp::recv(toRType(ftyp))));
        okarg:
        auto nret = uintptr_t(0);
        for(auto [gocpp_ignored, t] : rec::OutSlice(gocpp::recv(ft)))
        {
            nret = alignUp(nret, uintptr_t(t->Align_)) + t->Size_;
        }
        nret = alignUp(nret, goarch::PtrSize);
        createfing();
        systemstack([=]() mutable -> void
        {
            if(! addfinalizer(e->data, (funcval*)(f->data), nret, fint, ot))
            {
                go_throw("runtime.SetFinalizer: finalizer already set"_s);
            }
        });
    }

    // KeepAlive marks its argument as currently reachable.
    // This ensures that the object is not freed, and its finalizer is not run,
    // before the point in the program where KeepAlive is called.
    //
    // A very simplified example showing where KeepAlive is required:
    //
    //	type File struct { d int }
    //	d, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)
    //	// ... do something if err != nil ...
    //	p := &File{d}
    //	runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })
    //	var buf [10]byte
    //	n, err := syscall.Read(p.d, buf[:])
    //	// Ensure p is not finalized until Read returns.
    //	runtime.KeepAlive(p)
    //	// No more uses of p after this point.
    //
    // Without the KeepAlive call, the finalizer could run at the start of
    // [syscall.Read], closing the file descriptor before syscall.Read makes
    // the actual system call.
    //
    // Note: KeepAlive should only be used to prevent finalizers from
    // running prematurely. In particular, when used with [unsafe.Pointer],
    // the rules for valid uses of unsafe.Pointer still apply.
    void KeepAlive(go_any x)
    {
        if(cgoAlwaysFalse)
        {
            println(x);
        }
    }

}

