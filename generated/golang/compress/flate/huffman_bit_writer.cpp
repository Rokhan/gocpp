// generated by GoCpp from file '$(ImportDir)/compress/flate/huffman_bit_writer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/huffman_bit_writer.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/inflate.h"
#include "golang/compress/flate/token.h"
#include "golang/io/io.h"

namespace golang::flate
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Write;
    }

    // The largest offset code.
    // The special code used to mark the end of a block.
    // The first length code.
    // The number of codegen codes.
    // bufferFlushSize indicates the buffer size
    // after which bytes are flushed to the writer.
    // Should preferably be a multiple of 6, since
    // we accumulate 6 bytes between writes to the buffer.
    // bufferSize is the actual output byte buffer size.
    // It must have additional headroom for a flush
    // which can contain up to 8 bytes.
    // The number of extra bits needed by length code X - LENGTH_CODES_START.
    gocpp::slice<int8_t> lengthExtraBits = gocpp::slice<int8_t> {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
    // The length indicated by length code X - LENGTH_CODES_START.
    gocpp::slice<uint32_t> lengthBase = gocpp::slice<uint32_t> {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 255};
    // offset code word extra bits.
    gocpp::slice<int8_t> offsetExtraBits = gocpp::slice<int8_t> {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
    gocpp::slice<uint32_t> offsetBase = gocpp::slice<uint32_t> {0x000000, 0x000001, 0x000002, 0x000003, 0x000004, 0x000006, 0x000008, 0x00000c, 0x000010, 0x000018, 0x000020, 0x000030, 0x000040, 0x000060, 0x000080, 0x0000c0, 0x000100, 0x000180, 0x000200, 0x000300, 0x000400, 0x000600, 0x000800, 0x000c00, 0x001000, 0x001800, 0x002000, 0x003000, 0x004000, 0x006000};
    // The odd order in which the codegen code sizes are written.
    gocpp::slice<uint32_t> codegenOrder = gocpp::slice<uint32_t> {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
    
    template<typename T> requires gocpp::GoStruct<T>
    huffmanBitWriter::operator T()
    {
        T result;
        result.writer = this->writer;
        result.bits = this->bits;
        result.nbits = this->nbits;
        result.bytes = this->bytes;
        result.codegenFreq = this->codegenFreq;
        result.nbytes = this->nbytes;
        result.literalFreq = this->literalFreq;
        result.offsetFreq = this->offsetFreq;
        result.codegen = this->codegen;
        result.literalEncoding = this->literalEncoding;
        result.offsetEncoding = this->offsetEncoding;
        result.codegenEncoding = this->codegenEncoding;
        result.err = this->err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool huffmanBitWriter::operator==(const T& ref) const
    {
        if (writer != ref.writer) return false;
        if (bits != ref.bits) return false;
        if (nbits != ref.nbits) return false;
        if (bytes != ref.bytes) return false;
        if (codegenFreq != ref.codegenFreq) return false;
        if (nbytes != ref.nbytes) return false;
        if (literalFreq != ref.literalFreq) return false;
        if (offsetFreq != ref.offsetFreq) return false;
        if (codegen != ref.codegen) return false;
        if (literalEncoding != ref.literalEncoding) return false;
        if (offsetEncoding != ref.offsetEncoding) return false;
        if (codegenEncoding != ref.codegenEncoding) return false;
        if (err != ref.err) return false;
        return true;
    }

    std::ostream& huffmanBitWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << writer;
        os << " " << bits;
        os << " " << nbits;
        os << " " << bytes;
        os << " " << codegenFreq;
        os << " " << nbytes;
        os << " " << literalFreq;
        os << " " << offsetFreq;
        os << " " << codegen;
        os << " " << literalEncoding;
        os << " " << offsetEncoding;
        os << " " << codegenEncoding;
        os << " " << err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct huffmanBitWriter& value)
    {
        return value.PrintTo(os);
    }

    struct huffmanBitWriter* newHuffmanBitWriter(io::Writer w)
    {
        return gocpp::InitPtr<huffmanBitWriter>([=](auto& x) {
            x.writer = w;
            x.literalFreq = gocpp::make(gocpp::Tag<gocpp::slice<int32_t>>(), maxNumLit);
            x.offsetFreq = gocpp::make(gocpp::Tag<gocpp::slice<int32_t>>(), offsetCodeCount);
            x.codegen = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), maxNumLit + offsetCodeCount + 1);
            x.literalEncoding = newHuffmanEncoder(maxNumLit);
            x.codegenEncoding = newHuffmanEncoder(codegenCodeCount);
            x.offsetEncoding = newHuffmanEncoder(offsetCodeCount);
        });
    }

    void rec::reset(struct huffmanBitWriter* w, io::Writer writer)
    {
        w->writer = writer;
        std::tie(w->bits, w->nbits, w->nbytes, w->err) = std::tuple{0, 0, 0, nullptr};
    }

    void rec::flush(struct huffmanBitWriter* w)
    {
        if(w->err != nullptr)
        {
            w->nbits = 0;
            return;
        }
        auto n = w->nbytes;
        for(; w->nbits != 0; )
        {
            w->bytes[n] = (unsigned char)(w->bits);
            w->bits >>= 8;
            if(w->nbits > 8)
            {
                w->nbits -= 8;
            }
            else
            {
                w->nbits = 0;
            }
            n++;
        }
        w->bits = 0;
        rec::write(gocpp::recv(w), w->bytes.make_slice(0, n));
        w->nbytes = 0;
    }

    void rec::write(struct huffmanBitWriter* w, gocpp::slice<unsigned char> b)
    {
        if(w->err != nullptr)
        {
            return;
        }
        std::tie(gocpp_id_0, w->err) = rec::Write(gocpp::recv(w->writer), b);
    }

    void rec::writeBits(struct huffmanBitWriter* w, int32_t b, unsigned int nb)
    {
        if(w->err != nullptr)
        {
            return;
        }
        w->bits |= uint64_t(b) << w->nbits;
        w->nbits += nb;
        if(w->nbits >= 48)
        {
            auto bits = w->bits;
            w->bits >>= 48;
            w->nbits -= 48;
            auto n = w->nbytes;
            auto bytes = w->bytes.make_slice(n, n + 6);
            bytes[0] = (unsigned char)(bits);
            bytes[1] = (unsigned char)(bits >> 8);
            bytes[2] = (unsigned char)(bits >> 16);
            bytes[3] = (unsigned char)(bits >> 24);
            bytes[4] = (unsigned char)(bits >> 32);
            bytes[5] = (unsigned char)(bits >> 40);
            n += 6;
            if(n >= bufferFlushSize)
            {
                rec::write(gocpp::recv(w), w->bytes.make_slice(0, n));
                n = 0;
            }
            w->nbytes = n;
        }
    }

    void rec::writeBytes(struct huffmanBitWriter* w, gocpp::slice<unsigned char> bytes)
    {
        if(w->err != nullptr)
        {
            return;
        }
        auto n = w->nbytes;
        if(w->nbits & 7 != 0)
        {
            w->err = InternalError("writeBytes with unfinished bits"s);
            return;
        }
        for(; w->nbits != 0; )
        {
            w->bytes[n] = (unsigned char)(w->bits);
            w->bits >>= 8;
            w->nbits -= 8;
            n++;
        }
        if(n != 0)
        {
            rec::write(gocpp::recv(w), w->bytes.make_slice(0, n));
        }
        w->nbytes = 0;
        rec::write(gocpp::recv(w), bytes);
    }

    // RFC 1951 3.2.7 specifies a special run-length encoding for specifying
    // the literal and offset lengths arrays (which are concatenated into a single
    // array).  This method generates that run-length encoding.
    //
    // The result is written into the codegen array, and the frequencies
    // of each code is written into the codegenFreq array.
    // Codes 0-15 are single byte codes. Codes 16-18 are followed by additional
    // information. Code badCode is an end marker
    //
    //	numLiterals      The number of literals in literalEncoding
    //	numOffsets       The number of offsets in offsetEncoding
    //	litenc, offenc   The literal and offset encoder to use
    void rec::generateCodegen(struct huffmanBitWriter* w, int numLiterals, int numOffsets, struct huffmanEncoder* litEnc, struct huffmanEncoder* offEnc)
    {
        for(auto [i, gocpp_ignored] : w->codegenFreq)
        {
            w->codegenFreq[i] = 0;
        }
        auto codegen = w->codegen;
        auto cgnl = codegen.make_slice(0, numLiterals);
        for(auto [i, gocpp_ignored] : cgnl)
        {
            cgnl[i] = uint8_t(litEnc->codes[i].len);
        }
        cgnl = codegen.make_slice(numLiterals, numLiterals + numOffsets);
        for(auto [i, gocpp_ignored] : cgnl)
        {
            cgnl[i] = uint8_t(offEnc->codes[i].len);
        }
        codegen[numLiterals + numOffsets] = badCode;
        auto size = codegen[0];
        auto count = 1;
        auto outIndex = 0;
        for(auto inIndex = 1; size != badCode; inIndex++)
        {
            auto nextSize = codegen[inIndex];
            if(nextSize == size)
            {
                count++;
                continue;
            }
            if(size != 0)
            {
                codegen[outIndex] = size;
                outIndex++;
                w->codegenFreq[size]++;
                count--;
                for(; count >= 3; )
                {
                    auto n = 6;
                    if(n > count)
                    {
                        n = count;
                    }
                    codegen[outIndex] = 16;
                    outIndex++;
                    codegen[outIndex] = uint8_t(n - 3);
                    outIndex++;
                    w->codegenFreq[16]++;
                    count -= n;
                }
            }
            else
            {
                for(; count >= 11; )
                {
                    auto n = 138;
                    if(n > count)
                    {
                        n = count;
                    }
                    codegen[outIndex] = 18;
                    outIndex++;
                    codegen[outIndex] = uint8_t(n - 11);
                    outIndex++;
                    w->codegenFreq[18]++;
                    count -= n;
                }
                if(count >= 3)
                {
                    codegen[outIndex] = 17;
                    outIndex++;
                    codegen[outIndex] = uint8_t(count - 3);
                    outIndex++;
                    w->codegenFreq[17]++;
                    count = 0;
                }
            }
            count--;
            for(; count >= 0; count--)
            {
                codegen[outIndex] = size;
                outIndex++;
                w->codegenFreq[size]++;
            }
            size = nextSize;
            count = 1;
        }
        codegen[outIndex] = badCode;
    }

    // dynamicSize returns the size of dynamically encoded data in bits.
    std::tuple<int, int> rec::dynamicSize(struct huffmanBitWriter* w, struct huffmanEncoder* litEnc, struct huffmanEncoder* offEnc, int extraBits)
    {
        int size;
        int numCodegens;
        numCodegens = len(w->codegenFreq);
        for(; numCodegens > 4 && w->codegenFreq[codegenOrder[numCodegens - 1]] == 0; )
        {
            numCodegens--;
        }
        auto header = 3 + 5 + 5 + 4 + (3 * numCodegens) + rec::bitLength(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0)) + int(w->codegenFreq[16]) * 2 + int(w->codegenFreq[17]) * 3 + int(w->codegenFreq[18]) * 7;
        size = header + rec::bitLength(gocpp::recv(litEnc), w->literalFreq) + rec::bitLength(gocpp::recv(offEnc), w->offsetFreq) + extraBits;
        return {size, numCodegens};
    }

    // fixedSize returns the size of dynamically encoded data in bits.
    int rec::fixedSize(struct huffmanBitWriter* w, int extraBits)
    {
        return 3 + rec::bitLength(gocpp::recv(fixedLiteralEncoding), w->literalFreq) + rec::bitLength(gocpp::recv(fixedOffsetEncoding), w->offsetFreq) + extraBits;
    }

    // storedSize calculates the stored size, including header.
    // The function returns the size in bits and whether the block
    // fits inside a single block.
    std::tuple<int, bool> rec::storedSize(struct huffmanBitWriter* w, gocpp::slice<unsigned char> in)
    {
        if(in == nullptr)
        {
            return {0, false};
        }
        if(len(in) <= maxStoreBlockSize)
        {
            return {(len(in) + 5) * 8, true};
        }
        return {0, false};
    }

    void rec::writeCode(struct huffmanBitWriter* w, struct hcode c)
    {
        if(w->err != nullptr)
        {
            return;
        }
        w->bits |= uint64_t(c.code) << w->nbits;
        w->nbits += (unsigned int)(c.len);
        if(w->nbits >= 48)
        {
            auto bits = w->bits;
            w->bits >>= 48;
            w->nbits -= 48;
            auto n = w->nbytes;
            auto bytes = w->bytes.make_slice(n, n + 6);
            bytes[0] = (unsigned char)(bits);
            bytes[1] = (unsigned char)(bits >> 8);
            bytes[2] = (unsigned char)(bits >> 16);
            bytes[3] = (unsigned char)(bits >> 24);
            bytes[4] = (unsigned char)(bits >> 32);
            bytes[5] = (unsigned char)(bits >> 40);
            n += 6;
            if(n >= bufferFlushSize)
            {
                rec::write(gocpp::recv(w), w->bytes.make_slice(0, n));
                n = 0;
            }
            w->nbytes = n;
        }
    }

    // Write the header of a dynamic Huffman block to the output stream.
    //
    //	numLiterals  The number of literals specified in codegen
    //	numOffsets   The number of offsets specified in codegen
    //	numCodegens  The number of codegens used in codegen
    void rec::writeDynamicHeader(struct huffmanBitWriter* w, int numLiterals, int numOffsets, int numCodegens, bool isEof)
    {
        if(w->err != nullptr)
        {
            return;
        }
        int32_t firstBits = 4;
        if(isEof)
        {
            firstBits = 5;
        }
        rec::writeBits(gocpp::recv(w), firstBits, 3);
        rec::writeBits(gocpp::recv(w), int32_t(numLiterals - 257), 5);
        rec::writeBits(gocpp::recv(w), int32_t(numOffsets - 1), 5);
        rec::writeBits(gocpp::recv(w), int32_t(numCodegens - 4), 4);
        for(auto i = 0; i < numCodegens; i++)
        {
            auto value = (unsigned int)(w->codegenEncoding->codes[codegenOrder[i]].len);
            rec::writeBits(gocpp::recv(w), int32_t(value), 3);
        }
        auto i = 0;
        for(; ; )
        {
            int codeWord = int(w->codegen[i]);
            i++;
            if(codeWord == badCode)
            {
                break;
            }
            rec::writeCode(gocpp::recv(w), w->codegenEncoding->codes[uint32_t(codeWord)]);
            //Go switch emulation
            {
                auto condition = codeWord;
                int conditionId = -1;
                if(condition == 16) { conditionId = 0; }
                else if(condition == 17) { conditionId = 1; }
                else if(condition == 18) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        rec::writeBits(gocpp::recv(w), int32_t(w->codegen[i]), 2);
                        i++;
                        break;
                    case 1:
                        rec::writeBits(gocpp::recv(w), int32_t(w->codegen[i]), 3);
                        i++;
                        break;
                    case 2:
                        rec::writeBits(gocpp::recv(w), int32_t(w->codegen[i]), 7);
                        i++;
                        break;
                }
            }
        }
    }

    void rec::writeStoredHeader(struct huffmanBitWriter* w, int length, bool isEof)
    {
        if(w->err != nullptr)
        {
            return;
        }
        int32_t flag = {};
        if(isEof)
        {
            flag = 1;
        }
        rec::writeBits(gocpp::recv(w), flag, 3);
        rec::flush(gocpp::recv(w));
        rec::writeBits(gocpp::recv(w), int32_t(length), 16);
        rec::writeBits(gocpp::recv(w), int32_t(~ uint16_t(length)), 16);
    }

    void rec::writeFixedHeader(struct huffmanBitWriter* w, bool isEof)
    {
        if(w->err != nullptr)
        {
            return;
        }
        // Indicate that we are a fixed Huffman block
        int32_t value = 2;
        if(isEof)
        {
            value = 3;
        }
        rec::writeBits(gocpp::recv(w), value, 3);
    }

    // writeBlock will write a block of tokens with the smallest encoding.
    // The original input can be supplied, and if the huffman encoded data
    // is larger than the original bytes, the data will be written as a
    // stored block.
    // If the input is nil, the tokens will always be Huffman encoded.
    void rec::writeBlock(struct huffmanBitWriter* w, gocpp::slice<golang::flate::token> tokens, bool eof, gocpp::slice<unsigned char> input)
    {
        if(w->err != nullptr)
        {
            return;
        }
        tokens = append(tokens, endBlockMarker);
        auto [numLiterals, numOffsets] = rec::indexTokens(gocpp::recv(w), tokens);
        int extraBits = {};
        auto [storedSize, storable] = rec::storedSize(gocpp::recv(w), input);
        if(storable)
        {
            for(auto lengthCode = lengthCodesStart + 8; lengthCode < numLiterals; lengthCode++)
            {
                extraBits += int(w->literalFreq[lengthCode]) * int(lengthExtraBits[lengthCode - lengthCodesStart]);
            }
            for(auto offsetCode = 4; offsetCode < numOffsets; offsetCode++)
            {
                extraBits += int(w->offsetFreq[offsetCode]) * int(offsetExtraBits[offsetCode]);
            }
        }
        // Figure out smallest code.
        // Fixed Huffman baseline.
        auto literalEncoding = fixedLiteralEncoding;
        auto offsetEncoding = fixedOffsetEncoding;
        auto size = rec::fixedSize(gocpp::recv(w), extraBits);
        // Dynamic Huffman?
        int numCodegens = {};
        rec::generateCodegen(gocpp::recv(w), numLiterals, numOffsets, w->literalEncoding, w->offsetEncoding);
        rec::generate(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0), 7);
        auto [dynamicSize, numCodegens] = rec::dynamicSize(gocpp::recv(w), w->literalEncoding, w->offsetEncoding, extraBits);
        if(dynamicSize < size)
        {
            size = dynamicSize;
            literalEncoding = w->literalEncoding;
            offsetEncoding = w->offsetEncoding;
        }
        if(storable && storedSize < size)
        {
            rec::writeStoredHeader(gocpp::recv(w), len(input), eof);
            rec::writeBytes(gocpp::recv(w), input);
            return;
        }
        if(literalEncoding == fixedLiteralEncoding)
        {
            rec::writeFixedHeader(gocpp::recv(w), eof);
        }
        else
        {
            rec::writeDynamicHeader(gocpp::recv(w), numLiterals, numOffsets, numCodegens, eof);
        }
        rec::writeTokens(gocpp::recv(w), tokens, literalEncoding->codes, offsetEncoding->codes);
    }

    // writeBlockDynamic encodes a block using a dynamic Huffman table.
    // This should be used if the symbols used have a disproportionate
    // histogram distribution.
    // If input is supplied and the compression savings are below 1/16th of the
    // input size the block is stored.
    void rec::writeBlockDynamic(struct huffmanBitWriter* w, gocpp::slice<golang::flate::token> tokens, bool eof, gocpp::slice<unsigned char> input)
    {
        if(w->err != nullptr)
        {
            return;
        }
        tokens = append(tokens, endBlockMarker);
        auto [numLiterals, numOffsets] = rec::indexTokens(gocpp::recv(w), tokens);
        rec::generateCodegen(gocpp::recv(w), numLiterals, numOffsets, w->literalEncoding, w->offsetEncoding);
        rec::generate(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0), 7);
        auto [size, numCodegens] = rec::dynamicSize(gocpp::recv(w), w->literalEncoding, w->offsetEncoding, 0);
        if(auto [ssize, storable] = rec::storedSize(gocpp::recv(w), input); storable && ssize < (size + (size >> 4)))
        {
            rec::writeStoredHeader(gocpp::recv(w), len(input), eof);
            rec::writeBytes(gocpp::recv(w), input);
            return;
        }
        rec::writeDynamicHeader(gocpp::recv(w), numLiterals, numOffsets, numCodegens, eof);
        rec::writeTokens(gocpp::recv(w), tokens, w->literalEncoding->codes, w->offsetEncoding->codes);
    }

    // indexTokens indexes a slice of tokens, and updates
    // literalFreq and offsetFreq, and generates literalEncoding
    // and offsetEncoding.
    // The number of literal and offset tokens is returned.
    std::tuple<int, int> rec::indexTokens(struct huffmanBitWriter* w, gocpp::slice<golang::flate::token> tokens)
    {
        int numLiterals;
        int numOffsets;
        for(auto [i, gocpp_ignored] : w->literalFreq)
        {
            w->literalFreq[i] = 0;
        }
        for(auto [i, gocpp_ignored] : w->offsetFreq)
        {
            w->offsetFreq[i] = 0;
        }
        for(auto [gocpp_ignored, t] : tokens)
        {
            if(t < matchType)
            {
                w->literalFreq[rec::literal(gocpp::recv(t))]++;
                continue;
            }
            auto length = rec::length(gocpp::recv(t));
            auto offset = rec::offset(gocpp::recv(t));
            w->literalFreq[lengthCodesStart + lengthCode(length)]++;
            w->offsetFreq[offsetCode(offset)]++;
        }
        numLiterals = len(w->literalFreq);
        for(; w->literalFreq[numLiterals - 1] == 0; )
        {
            numLiterals--;
        }
        numOffsets = len(w->offsetFreq);
        for(; numOffsets > 0 && w->offsetFreq[numOffsets - 1] == 0; )
        {
            numOffsets--;
        }
        if(numOffsets == 0)
        {
            w->offsetFreq[0] = 1;
            numOffsets = 1;
        }
        rec::generate(gocpp::recv(w->literalEncoding), w->literalFreq, 15);
        rec::generate(gocpp::recv(w->offsetEncoding), w->offsetFreq, 15);
        return {numLiterals, numOffsets};
    }

    // writeTokens writes a slice of tokens to the output.
    // codes for literal and offset encoding must be supplied.
    void rec::writeTokens(struct huffmanBitWriter* w, gocpp::slice<golang::flate::token> tokens, gocpp::slice<hcode> leCodes, gocpp::slice<hcode> oeCodes)
    {
        if(w->err != nullptr)
        {
            return;
        }
        for(auto [gocpp_ignored, t] : tokens)
        {
            if(t < matchType)
            {
                rec::writeCode(gocpp::recv(w), leCodes[rec::literal(gocpp::recv(t))]);
                continue;
            }
            auto length = rec::length(gocpp::recv(t));
            auto lengthCode_tmp = lengthCode(length);
            auto& lengthCode = lengthCode_tmp;
            rec::writeCode(gocpp::recv(w), leCodes[lengthCode + lengthCodesStart]);
            auto extraLengthBits = (unsigned int)(lengthExtraBits[lengthCode]);
            if(extraLengthBits > 0)
            {
                auto extraLength = int32_t(length - lengthBase[lengthCode]);
                rec::writeBits(gocpp::recv(w), extraLength, extraLengthBits);
            }
            auto offset = rec::offset(gocpp::recv(t));
            auto offsetCode_tmp = offsetCode(offset);
            auto& offsetCode = offsetCode_tmp;
            rec::writeCode(gocpp::recv(w), oeCodes[offsetCode]);
            auto extraOffsetBits = (unsigned int)(offsetExtraBits[offsetCode]);
            if(extraOffsetBits > 0)
            {
                auto extraOffset = int32_t(offset - offsetBase[offsetCode]);
                rec::writeBits(gocpp::recv(w), extraOffset, extraOffsetBits);
            }
        }
    }

    // huffOffset is a static offset encoder used for huffman only encoding.
    // It can be reused since we will not be encoding offset values.
    huffmanEncoder* huffOffset;
    void init()
    {
        auto offsetFreq = gocpp::make(gocpp::Tag<gocpp::slice<int32_t>>(), offsetCodeCount);
        offsetFreq[0] = 1;
        huffOffset = newHuffmanEncoder(offsetCodeCount);
        rec::generate(gocpp::recv(huffOffset), offsetFreq, 15);
    }

    // writeBlockHuff encodes a block of bytes as either
    // Huffman encoded literals or uncompressed bytes if the
    // results only gains very little from compression.
    void rec::writeBlockHuff(struct huffmanBitWriter* w, bool eof, gocpp::slice<unsigned char> input)
    {
        if(w->err != nullptr)
        {
            return;
        }
        for(auto [i, gocpp_ignored] : w->literalFreq)
        {
            w->literalFreq[i] = 0;
        }
        histogram(input, w->literalFreq);
        w->literalFreq[endBlockMarker] = 1;
        auto numLiterals = endBlockMarker + 1;
        w->offsetFreq[0] = 1;
        auto numOffsets = 1;
        rec::generate(gocpp::recv(w->literalEncoding), w->literalFreq, 15);
        // Figure out smallest code.
        // Always use dynamic Huffman or Store
        int numCodegens = {};
        rec::generateCodegen(gocpp::recv(w), numLiterals, numOffsets, w->literalEncoding, huffOffset);
        rec::generate(gocpp::recv(w->codegenEncoding), w->codegenFreq.make_slice(0), 7);
        auto [size, numCodegens] = rec::dynamicSize(gocpp::recv(w), w->literalEncoding, huffOffset, 0);
        if(auto [ssize, storable] = rec::storedSize(gocpp::recv(w), input); storable && ssize < (size + (size >> 4)))
        {
            rec::writeStoredHeader(gocpp::recv(w), len(input), eof);
            rec::writeBytes(gocpp::recv(w), input);
            return;
        }
        rec::writeDynamicHeader(gocpp::recv(w), numLiterals, numOffsets, numCodegens, eof);
        auto encoding = w->literalEncoding->codes.make_slice(0, 257);
        auto n = w->nbytes;
        for(auto [gocpp_ignored, t] : input)
        {
            auto c = encoding[t];
            w->bits |= uint64_t(c.code) << w->nbits;
            w->nbits += (unsigned int)(c.len);
            if(w->nbits < 48)
            {
                continue;
            }
            auto bits = w->bits;
            w->bits >>= 48;
            w->nbits -= 48;
            auto bytes = w->bytes.make_slice(n, n + 6);
            bytes[0] = (unsigned char)(bits);
            bytes[1] = (unsigned char)(bits >> 8);
            bytes[2] = (unsigned char)(bits >> 16);
            bytes[3] = (unsigned char)(bits >> 24);
            bytes[4] = (unsigned char)(bits >> 32);
            bytes[5] = (unsigned char)(bits >> 40);
            n += 6;
            if(n < bufferFlushSize)
            {
                continue;
            }
            rec::write(gocpp::recv(w), w->bytes.make_slice(0, n));
            if(w->err != nullptr)
            {
                return;
            }
            n = 0;
        }
        w->nbytes = n;
        rec::writeCode(gocpp::recv(w), encoding[endBlockMarker]);
    }

    // histogram accumulates a histogram of b in h.
    //
    // len(h) must be >= 256, and h's elements must be all zeroes.
    void histogram(gocpp::slice<unsigned char> b, gocpp::slice<int32_t> h)
    {
        h = h.make_slice(0, 256);
        for(auto [gocpp_ignored, t] : b)
        {
            h[t]++;
        }
    }

}

