// generated by GoCpp from file '$(ImportDir)/runtime/mbitmap.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mbitmap.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"

namespace golang::runtime
{
    unsigned char* addb(unsigned char* p, uintptr_t n);
    unsigned char* subtractb(unsigned char* p, uintptr_t n);
    unsigned char* add1(unsigned char* p);
    unsigned char* subtract1(unsigned char* p);
    struct markBits
    {
        uint8_t* bytep;
        uint8_t mask;
        uintptr_t index;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct markBits& value);
    struct markBits allocBitsForIndex(struct mspan* s, uintptr_t allocBitIndex);
    void refillAllocCache(struct mspan* s, uint16_t whichByte);
    uint16_t nextFreeIndex(struct mspan* s);
    bool isFree(struct mspan* s, uintptr_t index);
    uintptr_t divideByElemSize(struct mspan* s, uintptr_t n);
    uintptr_t objIndex(struct mspan* s, uintptr_t p);
    struct markBits markBitsForAddr(uintptr_t p);
    struct markBits markBitsForIndex(struct mspan* s, uintptr_t objIndex);
    struct markBits markBitsForBase(struct mspan* s);
    bool isMarked(struct markBits m);
    void setMarked(struct markBits m);
    void setMarkedNonAtomic(struct markBits m);
    void clearMarked(struct markBits m);
    struct markBits markBitsForSpan(uintptr_t base);
    void advance(struct markBits* m);
    void badPointer(struct mspan* s, uintptr_t p, uintptr_t refBase, uintptr_t refOff);
    std::tuple<uintptr_t, struct mspan*, uintptr_t> findObject(uintptr_t p, uintptr_t refBase, uintptr_t refOff);
    bool reflect_verifyNotInHeapPtr(uintptr_t p);
    void bulkBarrierBitmap(uintptr_t dst, uintptr_t src, uintptr_t size, uintptr_t maskOffset, uint8_t* bits);
    void typeBitsBulkBarrier(struct _type* typ, uintptr_t dst, uintptr_t src, uintptr_t size);
    int countAlloc(struct mspan* s);
    uintptr_t readUintptr(unsigned char* p);
    struct bitvector progToPointerMask(unsigned char* prog, uintptr_t size);
    uintptr_t runGCProg(unsigned char* prog, unsigned char* dst);
    struct mspan* materializeGCProg(uintptr_t ptrdata, unsigned char* prog);
    void dematerializeGCProg(struct mspan* s);
    void dumpGCProg(unsigned char* p);
    gocpp::slice<unsigned char> reflect_gcbits(go_any x);
}

