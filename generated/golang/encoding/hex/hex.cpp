// generated by GoCpp from file '$(ImportDir)/encoding/hex/hex.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/encoding/hex/hex.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/fmt/print.h"
#include "golang/io/io.h"
#include "golang/slices/slices.h"
#include "golang/strings/builder.h"

// Package hex implements hexadecimal encoding and decoding.
namespace golang::hex
{
    namespace rec
    {
        using namespace mocklib::rec;
        using io::rec::Close;
        using io::rec::Read;
        using io::rec::Write;
        using strings::rec::Grow;
        using strings::rec::String;
    }

    std::string hextable = "0123456789abcdef"s;
    std::string reverseHexTable = ""s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\xff\xff\xff\xff\xff\xff"s + "\xff\x0a\x0b\x0c\x0d\x0e\x0f\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\x0a\x0b\x0c\x0d\x0e\x0f\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s;
    // EncodedLen returns the length of an encoding of n source bytes.
    // Specifically, it returns n * 2.
    int EncodedLen(int n)
    {
        return n * 2;
    }

    // Encode encodes src into [EncodedLen](len(src))
    // bytes of dst. As a convenience, it returns the number
    // of bytes written to dst, but this value is always [EncodedLen](len(src)).
    // Encode implements hexadecimal encoding.
    int Encode(gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto j = 0;
        for(auto [gocpp_ignored, v] : src)
        {
            dst[j] = hextable[v >> 4];
            dst[j + 1] = hextable[v & 0x0f];
            j += 2;
        }
        return len(src) * 2;
    }

    // AppendEncode appends the hexadecimally encoded src to dst
    // and returns the extended buffer.
    gocpp::slice<unsigned char> AppendEncode(gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto n = EncodedLen(len(src));
        dst = slices::Grow(dst, n);
        Encode(dst.make_slice(len(dst)).make_slice(0, n), src);
        return dst.make_slice(0, len(dst) + n);
    }

    // ErrLength reports an attempt to decode an odd-length input
    // using [Decode] or [DecodeString].
    // The stream-based Decoder returns [io.ErrUnexpectedEOF] instead of ErrLength.
    gocpp::error ErrLength = errors::New("encoding/hex: odd length hex string"s);
    // InvalidByteError values describe errors resulting from an invalid byte in a hex string.
    std::string rec::Error(golang::hex::InvalidByteError e)
    {
        return mocklib::Sprintf("encoding/hex: invalid byte: %#U"s, gocpp::rune(e));
    }

    // DecodedLen returns the length of a decoding of x source bytes.
    // Specifically, it returns x / 2.
    int DecodedLen(int x)
    {
        return x / 2;
    }

    // Decode decodes src into [DecodedLen](len(src)) bytes,
    // returning the actual number of bytes written to dst.
    //
    // Decode expects that src contains only hexadecimal
    // characters and that src has even length.
    // If the input is malformed, Decode returns the number
    // of bytes decoded before the error.
    std::tuple<int, struct gocpp::error> Decode(gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto [i, j] = std::tuple{0, 1};
        for(; j < len(src); j += 2)
        {
            auto p = src[j - 1];
            auto q = src[j];
            auto a = reverseHexTable[p];
            auto b = reverseHexTable[q];
            if(a > 0x0f)
            {
                return {i, InvalidByteError(p)};
            }
            if(b > 0x0f)
            {
                return {i, InvalidByteError(q)};
            }
            dst[i] = (a << 4) | b;
            i++;
        }
        if(len(src) % 2 == 1)
        {
            if(reverseHexTable[src[j - 1]] > 0x0f)
            {
                return {i, InvalidByteError(src[j - 1])};
            }
            return {i, ErrLength};
        }
        return {i, nullptr};
    }

    // AppendDecode appends the hexadecimally decoded src to dst
    // and returns the extended buffer.
    // If the input is malformed, it returns the partially decoded src and an error.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> AppendDecode(gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto n = DecodedLen(len(src));
        dst = slices::Grow(dst, n);
        gocpp::error err;
        std::tie(n, err) = Decode(dst.make_slice(len(dst)).make_slice(0, n), src);
        return {dst.make_slice(0, len(dst) + n), err};
    }

    // EncodeToString returns the hexadecimal encoding of src.
    std::string EncodeToString(gocpp::slice<unsigned char> src)
    {
        auto dst = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), EncodedLen(len(src)));
        Encode(dst, src);
        return std::string(dst);
    }

    // DecodeString returns the bytes represented by the hexadecimal string s.
    //
    // DecodeString expects that src contains only hexadecimal
    // characters and that src has even length.
    // If the input is malformed, DecodeString returns
    // the bytes decoded before the error.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> DecodeString(std::string s)
    {
        auto src = gocpp::slice<unsigned char>(s);
        auto [n, err] = Decode(src, src);
        return {src.make_slice(0, n), err};
    }

    // Dump returns a string that contains a hex dump of the given data. The format
    // of the hex dump matches the output of `hexdump -C` on the command line.
    std::string Dump(gocpp::slice<unsigned char> data)
    {
        if(len(data) == 0)
        {
            return ""s;
        }
        strings::Builder buf = {};
        rec::Grow(gocpp::recv(buf), (1 + ((len(data) - 1) / 16)) * 79);
        auto dumper = Dumper(& buf);
        rec::Write(gocpp::recv(dumper), data);
        rec::Close(gocpp::recv(dumper));
        return rec::String(gocpp::recv(buf));
    }

    // bufferSize is the number of hexadecimal characters to buffer in encoder and decoder.
    
    template<typename T> requires gocpp::GoStruct<T>
    encoder::operator T()
    {
        T result;
        result.w = this->w;
        result.err = this->err;
        result.out = this->out;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool encoder::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (err != ref.err) return false;
        if (out != ref.out) return false;
        return true;
    }

    std::ostream& encoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << err;
        os << " " << out;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct encoder& value)
    {
        return value.PrintTo(os);
    }

    // NewEncoder returns an [io.Writer] that writes lowercase hexadecimal characters to w.
    io::Writer NewEncoder(io::Writer w)
    {
        return gocpp::InitPtr<encoder>([=](auto& x) {
            x.w = w;
        });
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct encoder* e, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        for(; len(p) > 0 && e->err == nullptr; )
        {
            auto chunkSize = bufferSize / 2;
            if(len(p) < chunkSize)
            {
                chunkSize = len(p);
            }
            int written = {};
            auto encoded = Encode(e->out.make_slice(0), p.make_slice(0, chunkSize));
            std::tie(written, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, encoded));
            n += written / 2;
            p = p.make_slice(chunkSize);
        }
        return {n, e->err};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    decoder::operator T()
    {
        T result;
        result.r = this->r;
        result.err = this->err;
        result.in = this->in;
        result.arr = this->arr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decoder::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (err != ref.err) return false;
        if (in != ref.in) return false;
        if (arr != ref.arr) return false;
        return true;
    }

    std::ostream& decoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << err;
        os << " " << in;
        os << " " << arr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decoder& value)
    {
        return value.PrintTo(os);
    }

    // NewDecoder returns an [io.Reader] that decodes hexadecimal characters from r.
    // NewDecoder expects that r contain only an even number of hexadecimal characters.
    io::Reader NewDecoder(io::Reader r)
    {
        return gocpp::InitPtr<decoder>([=](auto& x) {
            x.r = r;
        });
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct decoder* d, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(len(d->in) < 2 && d->err == nullptr)
        {
            int numCopy = {};
            int numRead = {};
            numCopy = copy(d->arr.make_slice(0), d->in);
            std::tie(numRead, d->err) = rec::Read(gocpp::recv(d->r), d->arr.make_slice(numCopy));
            d->in = d->arr.make_slice(0, numCopy + numRead);
            if(d->err == io::go_EOF && len(d->in) % 2 != 0)
            {
                if(auto a = reverseHexTable[d->in[len(d->in) - 1]]; a > 0x0f)
                {
                    d->err = InvalidByteError(d->in[len(d->in) - 1]);
                }
                else
                {
                    d->err = io::ErrUnexpectedEOF;
                }
            }
        }
        if(auto numAvail = len(d->in) / 2; len(p) > numAvail)
        {
            p = p.make_slice(0, numAvail);
        }
        int numDec;
        std::tie(numDec, err) = Decode(p, d->in.make_slice(0, len(p) * 2));
        d->in = d->in.make_slice(2 * numDec);
        if(err != nullptr)
        {
            std::tie(d->in, d->err) = std::tuple{nullptr, err};
        }
        if(len(d->in) < 2)
        {
            return {numDec, d->err};
        }
        return {numDec, nullptr};
    }

    // Dumper returns a [io.WriteCloser] that writes a hex dump of all written data to
    // w. The format of the dump matches the output of `hexdump -C` on the command
    // line.
    io::WriteCloser Dumper(io::Writer w)
    {
        return gocpp::InitPtr<dumper>([=](auto& x) {
            x.w = w;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dumper::operator T()
    {
        T result;
        result.w = this->w;
        result.rightChars = this->rightChars;
        result.buf = this->buf;
        result.used = this->used;
        result.n = this->n;
        result.closed = this->closed;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dumper::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (rightChars != ref.rightChars) return false;
        if (buf != ref.buf) return false;
        if (used != ref.used) return false;
        if (n != ref.n) return false;
        if (closed != ref.closed) return false;
        return true;
    }

    std::ostream& dumper::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << rightChars;
        os << " " << buf;
        os << " " << used;
        os << " " << n;
        os << " " << closed;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dumper& value)
    {
        return value.PrintTo(os);
    }

    unsigned char toChar(unsigned char b)
    {
        if(b < 32 || b > 126)
        {
            return '.';
        }
        return b;
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct dumper* h, gocpp::slice<unsigned char> data)
    {
        int n;
        struct gocpp::error err;
        if(h->closed)
        {
            return {0, errors::New("encoding/hex: dumper closed"s)};
        }
        for(auto [i, gocpp_ignored] : data)
        {
            if(h->used == 0)
            {
                h->buf[0] = (unsigned char)(h->n >> 24);
                h->buf[1] = (unsigned char)(h->n >> 16);
                h->buf[2] = (unsigned char)(h->n >> 8);
                h->buf[3] = (unsigned char)(h->n);
                Encode(h->buf.make_slice(4), h->buf.make_slice(0, 4));
                h->buf[12] = ' ';
                h->buf[13] = ' ';
                std::tie(gocpp_id_0, err) = rec::Write(gocpp::recv(h->w), h->buf.make_slice(4));
                if(err != nullptr)
                {
                    return {n, err};
                }
            }
            Encode(h->buf.make_slice(0), data.make_slice(i, i + 1));
            h->buf[2] = ' ';
            auto l = 3;
            if(h->used == 7)
            {
                h->buf[3] = ' ';
                l = 4;
            }
            else
            if(h->used == 15)
            {
                h->buf[3] = ' ';
                h->buf[4] = '|';
                l = 5;
            }
            std::tie(gocpp_id_1, err) = rec::Write(gocpp::recv(h->w), h->buf.make_slice(0, l));
            if(err != nullptr)
            {
                return {n, err};
            }
            n++;
            h->rightChars[h->used] = toChar(data[i]);
            h->used++;
            h->n++;
            if(h->used == 16)
            {
                h->rightChars[16] = '|';
                h->rightChars[17] = '\n';
                std::tie(gocpp_id_2, err) = rec::Write(gocpp::recv(h->w), h->rightChars.make_slice(0));
                if(err != nullptr)
                {
                    return {n, err};
                }
                h->used = 0;
            }
        }
        return {n, err};
    }

    struct gocpp::error rec::Close(struct dumper* h)
    {
        struct gocpp::error err;
        if(h->closed)
        {
            return err;
        }
        h->closed = true;
        if(h->used == 0)
        {
            return err;
        }
        h->buf[0] = ' ';
        h->buf[1] = ' ';
        h->buf[2] = ' ';
        h->buf[3] = ' ';
        h->buf[4] = '|';
        auto nBytes = h->used;
        for(; h->used < 16; )
        {
            auto l = 3;
            if(h->used == 7)
            {
                l = 4;
            }
            else
            if(h->used == 15)
            {
                l = 5;
            }
            std::tie(gocpp_id_3, err) = rec::Write(gocpp::recv(h->w), h->buf.make_slice(0, l));
            if(err != nullptr)
            {
                return err;
            }
            h->used++;
        }
        h->rightChars[nBytes] = '|';
        h->rightChars[nBytes + 1] = '\n';
        std::tie(gocpp_id_4, err) = rec::Write(gocpp::recv(h->w), h->rightChars.make_slice(0, nBytes + 2));
        return err;
    }

}

