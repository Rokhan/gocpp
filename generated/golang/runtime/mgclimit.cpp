// generated by GoCpp from file '$(ImportDir)/runtime/mgclimit.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgclimit.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]

namespace golang::runtime
{
    gcCPULimiterState gcCPULimiter;
    
    std::ostream& gcCPULimiterState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << enabled;
        os << " " << bucket;
        os << " " << overflow;
        os << " " << gcEnabled;
        os << " " << transitioning;
        os << " " << assistTimePool;
        os << " " << idleMarkTimePool;
        os << " " << idleTimePool;
        os << " " << lastUpdate;
        os << " " << lastEnabledCycle;
        os << " " << nprocs;
        os << " " << test;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const gcCPULimiterState& value)
    {
        return value.PrintTo(os);
    }

    bool limiting(gcCPULimiterState* l)
    {
        return Load(gocpp::recv(l->enabled));
    }

    void startGCTransition(gcCPULimiterState* l, bool enableGC, int64_t now)
    {
        if(! tryLock(gocpp::recv(l)))
        {
            go_throw("failed to acquire lock to start a GC transition");
        }
        if(l->gcEnabled == enableGC)
        {
            go_throw("transitioning GC to the same state as before?");
        }
        updateLocked(gocpp::recv(l), now);
        l->gcEnabled = enableGC;
        l->transitioning = true;
    }

    void finishGCTransition(gcCPULimiterState* l, int64_t now)
    {
        if(! l->transitioning)
        {
            go_throw("finishGCTransition called without starting one?");
        }
        if(auto lastUpdate = Load(gocpp::recv(l->lastUpdate)); now >= lastUpdate)
        {
            accumulate(gocpp::recv(l), 0, (now - lastUpdate) * int64(l->nprocs));
        }
        Store(gocpp::recv(l->lastUpdate), now);
        l->transitioning = false;
        unlock(gocpp::recv(l));
    }

    double gcCPULimiterUpdatePeriod = 10e6;
    bool needUpdate(gcCPULimiterState* l, int64_t now)
    {
        return now - Load(gocpp::recv(l->lastUpdate)) > gcCPULimiterUpdatePeriod;
    }

    void addAssistTime(gcCPULimiterState* l, int64_t t)
    {
        Add(gocpp::recv(l->assistTimePool), t);
    }

    void addIdleTime(gcCPULimiterState* l, int64_t t)
    {
        Add(gocpp::recv(l->idleTimePool), t);
    }

    void update(gcCPULimiterState* l, int64_t now)
    {
        if(! tryLock(gocpp::recv(l)))
        {
            return;
        }
        if(l->transitioning)
        {
            go_throw("update during transition");
        }
        updateLocked(gocpp::recv(l), now);
        unlock(gocpp::recv(l));
    }

    void updateLocked(gcCPULimiterState* l, int64_t now)
    {
        auto lastUpdate = Load(gocpp::recv(l->lastUpdate));
        if(now < lastUpdate)
        {
            return;
        }
        auto windowTotalTime = (now - lastUpdate) * int64(l->nprocs);
        Store(gocpp::recv(l->lastUpdate), now);
        auto assistTime = Load(gocpp::recv(l->assistTimePool));
        if(assistTime != 0)
        {
            Add(gocpp::recv(l->assistTimePool), - assistTime);
        }
        auto idleTime = Load(gocpp::recv(l->idleTimePool));
        if(idleTime != 0)
        {
            Add(gocpp::recv(l->idleTimePool), - idleTime);
        }
        if(! l->test)
        {
            auto mp = acquirem();
            for(auto [_, pp] : allp)
            {
                auto [typ, duration] = consume(gocpp::recv(pp->limiterEvent), now);
                //Go switch emulation
                {
                    auto condition = typ;
                    int conditionId = -1;
                    if(condition == limiterEventIdleMarkWork) { conditionId = 0; }
                    else if(condition == limiterEventIdle) { conditionId = 1; }
                    else if(condition == limiterEventMarkAssist) { conditionId = 2; }
                    else if(condition == limiterEventScavengeAssist) { conditionId = 3; }
                    else if(condition == limiterEventNone) { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                            idleTime += duration;
                            Add(gocpp::recv(sched.idleTime), duration);
                            break;
                        case 2:
                        case 3:
                            assistTime += duration;
                            break;
                        case 4:
                            break;
                            break;
                        default:
                            go_throw("invalid limiter event type found");
                            break;
                    }
                }
            }
            releasem(mp);
        }
        auto windowGCTime = assistTime;
        if(l->gcEnabled)
        {
            windowGCTime += int64(double(windowTotalTime) * gcBackgroundUtilization);
        }
        windowTotalTime -= idleTime;
        accumulate(gocpp::recv(l), windowTotalTime - windowGCTime, windowGCTime);
    }

    void accumulate(gcCPULimiterState* l, int64_t mutatorTime, int64_t gcTime)
    {
        auto headroom = l->bucket.capacity - l->bucket.fill;
        auto enabled = headroom == 0;
        auto change = gcTime - mutatorTime;
        if(change > 0 && headroom <= uint64_t(change))
        {
            l->overflow += uint64_t(change) - headroom;
            l->bucket.fill = l->bucket.capacity;
            if(! enabled)
            {
                Store(gocpp::recv(l->enabled), true);
                Store(gocpp::recv(l->lastEnabledCycle), memstats.numgc + 1);
            }
            return;
        }
        if(change < 0 && l->bucket.fill <= uint64_t(- change))
        {
            l->bucket.fill = 0;
        }
        else
        {
            l->bucket.fill -= uint64_t(- change);
        }
        if(change != 0 && enabled)
        {
            Store(gocpp::recv(l->enabled), false);
        }
    }

    bool tryLock(gcCPULimiterState* l)
    {
        return CompareAndSwap(gocpp::recv(l->lock), 0, 1);
    }

    void unlock(gcCPULimiterState* l)
    {
        auto old = Swap(gocpp::recv(l->lock), 0);
        if(old != 1)
        {
            go_throw("double unlock");
        }
    }

    double capacityPerProc = 1e9;
    void resetCapacity(gcCPULimiterState* l, int64_t now, int32_t nprocs)
    {
        if(! tryLock(gocpp::recv(l)))
        {
            go_throw("failed to acquire lock to reset capacity");
        }
        updateLocked(gocpp::recv(l), now);
        l->nprocs = nprocs;
        l->bucket.capacity = uint64_t(nprocs) * capacityPerProc;
        if(l->bucket.fill > l->bucket.capacity)
        {
            l->bucket.fill = l->bucket.capacity;
            Store(gocpp::recv(l->enabled), true);
            Store(gocpp::recv(l->lastEnabledCycle), memstats.numgc + 1);
        }
        else
        if(l->bucket.fill < l->bucket.capacity)
        {
            Store(gocpp::recv(l->enabled), false);
        }
        unlock(gocpp::recv(l));
    }

    limiterEventType limiterEventNone = 0;
    runtime.limiterEventType limiterEventIdleMarkWork = 1;
    runtime.limiterEventType limiterEventMarkAssist = 2;
    runtime.limiterEventType limiterEventScavengeAssist = 3;
    runtime.limiterEventType limiterEventIdle = 4;
    int limiterEventBits = 3;
    uint64_t limiterEventTypeMask = uint64_t((1 << limiterEventBits) - 1) << (64 - limiterEventBits);
    runtime.limiterEventStamp limiterEventStampNone = limiterEventStamp(0);
    limiterEventStamp makeLimiterEventStamp(limiterEventType typ, int64_t now)
    {
        return limiterEventStamp((uint64_t(typ) << (64 - limiterEventBits)) | (uint64_t(now) &^ limiterEventTypeMask));
    }

    int64_t duration(limiterEventStamp s, int64_t now)
    {
        auto start = int64((uint64_t(now) & limiterEventTypeMask) | (uint64_t(s) &^ limiterEventTypeMask));
        if(now < start)
        {
            return 0;
        }
        return now - start;
    }

    limiterEventType typ(limiterEventStamp s)
    {
        return limiterEventType(s >> (64 - limiterEventBits));
    }

    
    std::ostream& limiterEvent::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stamp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const limiterEvent& value)
    {
        return value.PrintTo(os);
    }

    bool start(limiterEvent* e, limiterEventType typ, int64_t now)
    {
        if(typ(gocpp::recv(limiterEventStamp(Load(gocpp::recv(e->stamp))))) != limiterEventNone)
        {
            return false;
        }
        Store(gocpp::recv(e->stamp), uint64_t(makeLimiterEventStamp(typ, now)));
        return true;
    }

    std::tuple<limiterEventType, int64_t> consume(limiterEvent* e, int64_t now)
    {
        limiterEventType typ;
        int64_t duration;
        for(; ; )
        {
            limiterEventType typ;
            int64_t duration;
            auto old = limiterEventStamp(Load(gocpp::recv(e->stamp)));
            typ = typ(gocpp::recv(old));
            if(typ == limiterEventNone)
            {
                limiterEventType typ;
                int64_t duration;
                return {typ, duration};
            }
            duration = duration(gocpp::recv(old), now);
            if(duration == 0)
            {
                limiterEventType typ;
                int64_t duration;
                return {limiterEventNone, 0};
            }
            auto go_new = makeLimiterEventStamp(typ, now);
            if(CompareAndSwap(gocpp::recv(e->stamp), uint64_t(old), uint64_t(go_new)))
            {
                limiterEventType typ;
                int64_t duration;
                break;
            }
        }
        return {typ, duration};
    }

    void stop(limiterEvent* e, limiterEventType typ, int64_t now)
    {
        limiterEventStamp stamp = {};
        for(; ; )
        {
            stamp = limiterEventStamp(Load(gocpp::recv(e->stamp)));
            if(typ(gocpp::recv(stamp)) != typ)
            {
                print("runtime: want=", typ, " got=", typ(gocpp::recv(stamp)), "\n");
                go_throw("limiterEvent.stop: found wrong event in p's limiter event slot");
            }
            if(CompareAndSwap(gocpp::recv(e->stamp), uint64_t(stamp), uint64_t(limiterEventStampNone)))
            {
                break;
            }
        }
        auto duration = duration(gocpp::recv(stamp), now);
        if(duration == 0)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == limiterEventIdleMarkWork) { conditionId = 0; }
            else if(condition == limiterEventIdle) { conditionId = 1; }
            else if(condition == limiterEventMarkAssist) { conditionId = 2; }
            else if(condition == limiterEventScavengeAssist) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    addIdleTime(gocpp::recv(gcCPULimiter), duration);
                    break;
                case 1:
                    addIdleTime(gocpp::recv(gcCPULimiter), duration);
                    Add(gocpp::recv(sched.idleTime), duration);
                    break;
                case 2:
                case 3:
                    addAssistTime(gocpp::recv(gcCPULimiter), duration);
                    break;
                default:
                    go_throw("limiterEvent.stop: invalid limiter event type found");
                    break;
            }
        }
    }

}

