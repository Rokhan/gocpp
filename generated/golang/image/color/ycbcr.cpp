// generated by GoCpp from file '$(ImportDir)/image/color/ycbcr.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/color/ycbcr.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"

namespace golang::color
{
    std::tuple<uint8_t, uint8_t, uint8_t> RGBToYCbCr(uint8_t r, uint8_t g, uint8_t b)
    {
        auto r1 = int32(r);
        auto g1 = int32(g);
        auto b1 = int32(b);
        auto yy = (19595 * r1 + 38470 * g1 + 7471 * b1 + (1 << 15)) >> 16;
        auto cb = - 11056 * r1 - 21712 * g1 + 32768 * b1 + (257 << 15);
        if(uint32_t(cb) & 0xff000000 == 0)
        {
            cb >>= 16;
        }
        else
        {
            cb = ^ (cb >> 31);
        }
        auto cr = 32768 * r1 - 27440 * g1 - 5328 * b1 + (257 << 15);
        if(uint32_t(cr) & 0xff000000 == 0)
        {
            cr >>= 16;
        }
        else
        {
            cr = ^ (cr >> 31);
        }
        return {uint8_t(yy), uint8_t(cb), uint8_t(cr)};
    }

    std::tuple<uint8_t, uint8_t, uint8_t> YCbCrToRGB(uint8_t y, uint8_t cb, uint8_t cr)
    {
        auto yy1 = int32(y) * 0x10101;
        auto cb1 = int32(cb) - 128;
        auto cr1 = int32(cr) - 128;
        auto r = yy1 + 91881 * cr1;
        if(uint32_t(r) & 0xff000000 == 0)
        {
            r >>= 16;
        }
        else
        {
            r = ^ (r >> 31);
        }
        auto g = yy1 - 22554 * cb1 - 46802 * cr1;
        if(uint32_t(g) & 0xff000000 == 0)
        {
            g >>= 16;
        }
        else
        {
            g = ^ (g >> 31);
        }
        auto b = yy1 + 116130 * cb1;
        if(uint32_t(b) & 0xff000000 == 0)
        {
            b >>= 16;
        }
        else
        {
            b = ^ (b >> 31);
        }
        return {uint8_t(r), uint8_t(g), uint8_t(b)};
    }

    
    std::ostream& YCbCr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Y;
        os << " " << Cb;
        os << " " << Cr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct YCbCr& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct YCbCr c)
    {
        auto yy1 = int32(c.Y) * 0x10101;
        auto cb1 = int32(c.Cb) - 128;
        auto cr1 = int32(c.Cr) - 128;
        auto r = yy1 + 91881 * cr1;
        if(uint32_t(r) & 0xff000000 == 0)
        {
            r >>= 8;
        }
        else
        {
            r = ^ (r >> 31) & 0xffff;
        }
        auto g = yy1 - 22554 * cb1 - 46802 * cr1;
        if(uint32_t(g) & 0xff000000 == 0)
        {
            g >>= 8;
        }
        else
        {
            g = ^ (g >> 31) & 0xffff;
        }
        auto b = yy1 + 116130 * cb1;
        if(uint32_t(b) & 0xff000000 == 0)
        {
            b >>= 8;
        }
        else
        {
            b = ^ (b >> 31) & 0xffff;
        }
        return {uint32_t(r), uint32_t(g), uint32_t(b), 0xffff};
    }

    Model YCbCrModel = ModelFunc(yCbCrModel);
    Color yCbCrModel(Color c)
    {
        if(auto [_, ok] = gocpp::getValue<color.YCbCr>(c); ok)
        {
            return c;
        }
        auto [r, g, b, _] = RGBA(gocpp::recv(c));
        auto [y, u, v] = RGBToYCbCr(uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8));
        return YCbCr {y, u, v};
    }

    
    std::ostream& NYCbCrA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NYCbCrA& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct NYCbCrA c)
    {
        auto yy1 = int32(c.Y) * 0x10101;
        auto cb1 = int32(c.Cb) - 128;
        auto cr1 = int32(c.Cr) - 128;
        auto r = yy1 + 91881 * cr1;
        if(uint32_t(r) & 0xff000000 == 0)
        {
            r >>= 8;
        }
        else
        {
            r = ^ (r >> 31) & 0xffff;
        }
        auto g = yy1 - 22554 * cb1 - 46802 * cr1;
        if(uint32_t(g) & 0xff000000 == 0)
        {
            g >>= 8;
        }
        else
        {
            g = ^ (g >> 31) & 0xffff;
        }
        auto b = yy1 + 116130 * cb1;
        if(uint32_t(b) & 0xff000000 == 0)
        {
            b >>= 8;
        }
        else
        {
            b = ^ (b >> 31) & 0xffff;
        }
        auto a = uint32_t(c.A) * 0x101;
        return {uint32_t(r) * a / 0xffff, uint32_t(g) * a / 0xffff, uint32_t(b) * a / 0xffff, a};
    }

    Model NYCbCrAModel = ModelFunc(nYCbCrAModel);
    Color nYCbCrAModel(Color c)
    {
        //Go type switch emulation
        {
            const auto& gocpp_id_0 = gocpp::type_info(c);
            int conditionId = -1;
            if(gocpp_id_0 == typeid(color.NYCbCrA)) { conditionId = 0; }
            else if(gocpp_id_0 == typeid(color.YCbCr)) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                {
                    color.NYCbCrA c = gocpp::any_cast<color.NYCbCrA>(c);
                    return c;
                    break;
                }
                case 1:
                {
                    color.YCbCr c = gocpp::any_cast<color.YCbCr>(c);
                    return NYCbCrA {c, 0xff};
                    break;
                }
            }
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        if(a != 0)
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto [y, u, v] = RGBToYCbCr(uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8));
        return NYCbCrA {gocpp::Init<YCbCr>([](YCbCr& x) { x.Y = y; x.Cb = u; x.Cr = v; }), uint8_t(a >> 8)};
    }

    std::tuple<uint8_t, uint8_t, uint8_t, uint8_t> RGBToCMYK(uint8_t r, uint8_t g, uint8_t b)
    {
        auto rr = uint32_t(r);
        auto gg = uint32_t(g);
        auto bb = uint32_t(b);
        auto w = rr;
        if(w < gg)
        {
            w = gg;
        }
        if(w < bb)
        {
            w = bb;
        }
        if(w == 0)
        {
            return {0, 0, 0, 0xff};
        }
        auto c = (w - rr) * 0xff / w;
        auto m = (w - gg) * 0xff / w;
        auto y = (w - bb) * 0xff / w;
        return {uint8_t(c), uint8_t(m), uint8_t(y), uint8_t(0xff - w)};
    }

    std::tuple<uint8_t, uint8_t, uint8_t> CMYKToRGB(uint8_t c, uint8_t m, uint8_t y, uint8_t k)
    {
        auto w = 0xffff - uint32_t(k) * 0x101;
        auto r = (0xffff - uint32_t(c) * 0x101) * w / 0xffff;
        auto g = (0xffff - uint32_t(m) * 0x101) * w / 0xffff;
        auto b = (0xffff - uint32_t(y) * 0x101) * w / 0xffff;
        return {uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8)};
    }

    
    std::ostream& CMYK::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << C;
        os << " " << M;
        os << " " << Y;
        os << " " << K;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct CMYK c)
    {
        auto w = 0xffff - uint32_t(c.K) * 0x101;
        auto r = (0xffff - uint32_t(c.C) * 0x101) * w / 0xffff;
        auto g = (0xffff - uint32_t(c.M) * 0x101) * w / 0xffff;
        auto b = (0xffff - uint32_t(c.Y) * 0x101) * w / 0xffff;
        return {r, g, b, 0xffff};
    }

    Model CMYKModel = ModelFunc(cmykModel);
    Color cmykModel(Color c)
    {
        if(auto [_, ok] = gocpp::getValue<color.CMYK>(c); ok)
        {
            return c;
        }
        auto [r, g, b, _] = RGBA(gocpp::recv(c));
        auto [cc, mm, yy, kk] = RGBToCMYK(uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8));
        return CMYK {cc, mm, yy, kk};
    }

}

