// generated by GoCpp from file '$(ImportDir)/sync/map.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/map.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"

namespace golang::sync
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Map::operator T()
    {
        T result;
        result.mu = this->mu;
        result.read = this->read;
        result.dirty = this->dirty;
        result.misses = this->misses;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Map::operator==(const T& ref) const
    {
        if (mu != ref.mu) return false;
        if (read != ref.read) return false;
        if (dirty != ref.dirty) return false;
        if (misses != ref.misses) return false;
        return true;
    }

    std::ostream& Map::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << " " << read;
        os << " " << dirty;
        os << " " << misses;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Map& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    readOnly::operator T()
    {
        T result;
        result.m = this->m;
        result.amended = this->amended;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool readOnly::operator==(const T& ref) const
    {
        if (m != ref.m) return false;
        if (amended != ref.amended) return false;
        return true;
    }

    std::ostream& readOnly::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << m;
        os << " " << amended;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct readOnly& value)
    {
        return value.PrintTo(os);
    }

    go_any* expunged = go_new(go_any);
    
    template<typename T> requires gocpp::GoStruct<T>
    entry::operator T()
    {
        T result;
        result.p = this->p;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool entry::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        return true;
    }

    std::ostream& entry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct entry& value)
    {
        return value.PrintTo(os);
    }

    struct entry* newEntry(go_any i)
    {
        auto e = new entry {};
        Store(gocpp::recv(e->p), & i);
        return e;
    }

    struct readOnly loadReadOnly(struct Map* m)
    {
        if(auto p = Load(gocpp::recv(m->read)); p != nullptr)
        {
            return *p;
        }
        return readOnly {};
    }

    std::tuple<go_any, bool> Load(struct Map* m, go_any key)
    {
        go_any value;
        bool ok;
        auto read = loadReadOnly(gocpp::recv(m));
        auto [e, ok] = read.m[key];
        if(! ok && read.amended)
        {
            go_any value;
            bool ok;
            Lock(gocpp::recv(m->mu));
            read = loadReadOnly(gocpp::recv(m));
            std::tie(e, ok) = read.m[key];
            if(! ok && read.amended)
            {
                go_any value;
                bool ok;
                std::tie(e, ok) = m->dirty[key];
                missLocked(gocpp::recv(m));
            }
            Unlock(gocpp::recv(m->mu));
        }
        if(! ok)
        {
            go_any value;
            bool ok;
            return {nullptr, false};
        }
        return load(gocpp::recv(e));
    }

    std::tuple<go_any, bool> load(struct entry* e)
    {
        go_any value;
        bool ok;
        auto p = Load(gocpp::recv(e->p));
        if(p == nullptr || p == expunged)
        {
            go_any value;
            bool ok;
            return {nullptr, false};
        }
        return {*p, true};
    }

    void Store(struct Map* m, go_any key, go_any value)
    {
        std::tie(gocpp_id_0, gocpp_id_1) = Swap(gocpp::recv(m), key, value);
    }

    bool tryCompareAndSwap(struct entry* e, go_any old, go_any go_new)
    {
        auto p = Load(gocpp::recv(e->p));
        if(p == nullptr || p == expunged || *p != old)
        {
            return false;
        }
        auto nc = go_new;
        for(; ; )
        {
            if(CompareAndSwap(gocpp::recv(e->p), p, & nc))
            {
                return true;
            }
            p = Load(gocpp::recv(e->p));
            if(p == nullptr || p == expunged || *p != old)
            {
                return false;
            }
        }
    }

    bool unexpungeLocked(struct entry* e)
    {
        bool wasExpunged;
        return CompareAndSwap(gocpp::recv(e->p), expunged, nullptr);
    }

    go_any* swapLocked(struct entry* e, go_any* i)
    {
        return Swap(gocpp::recv(e->p), i);
    }

    std::tuple<go_any, bool> LoadOrStore(struct Map* m, go_any key, go_any value)
    {
        go_any actual;
        bool loaded;
        auto read = loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            go_any actual;
            bool loaded;
            auto [actual, loaded, ok] = tryLoadOrStore(gocpp::recv(e), value);
            if(ok)
            {
                go_any actual;
                bool loaded;
                return {actual, loaded};
            }
        }
        Lock(gocpp::recv(m->mu));
        read = loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            go_any actual;
            bool loaded;
            if(unexpungeLocked(gocpp::recv(e)))
            {
                go_any actual;
                bool loaded;
                m->dirty[key] = e;
            }
            std::tie(actual, loaded, gocpp_id_2) = tryLoadOrStore(gocpp::recv(e), value);
        }
        else
        if(auto [e, ok] = m->dirty[key]; ok)
        {
            go_any actual;
            bool loaded;
            std::tie(actual, loaded, gocpp_id_3) = tryLoadOrStore(gocpp::recv(e), value);
            missLocked(gocpp::recv(m));
        }
        else
        {
            go_any actual;
            bool loaded;
            if(! read.amended)
            {
                go_any actual;
                bool loaded;
                dirtyLocked(gocpp::recv(m));
                Store(gocpp::recv(m->read), gocpp::InitPtr<readOnly>([](readOnly& x) { x.m = read.m; x.amended = true; }));
            }
            m->dirty[key] = newEntry(value);
            std::tie(actual, loaded) = std::tuple{value, false};
        }
        Unlock(gocpp::recv(m->mu));
        return {actual, loaded};
    }

    std::tuple<go_any, bool, bool> tryLoadOrStore(struct entry* e, go_any i)
    {
        go_any actual;
        bool loaded;
        bool ok;
        auto p = Load(gocpp::recv(e->p));
        if(p == expunged)
        {
            go_any actual;
            bool loaded;
            bool ok;
            return {nullptr, false, false};
        }
        if(p != nullptr)
        {
            go_any actual;
            bool loaded;
            bool ok;
            return {*p, true, true};
        }
        auto ic = i;
        for(; ; )
        {
            go_any actual;
            bool loaded;
            bool ok;
            if(CompareAndSwap(gocpp::recv(e->p), nullptr, & ic))
            {
                go_any actual;
                bool loaded;
                bool ok;
                return {i, false, true};
            }
            p = Load(gocpp::recv(e->p));
            if(p == expunged)
            {
                go_any actual;
                bool loaded;
                bool ok;
                return {nullptr, false, false};
            }
            if(p != nullptr)
            {
                go_any actual;
                bool loaded;
                bool ok;
                return {*p, true, true};
            }
        }
    }

    std::tuple<go_any, bool> LoadAndDelete(struct Map* m, go_any key)
    {
        go_any value;
        bool loaded;
        auto read = loadReadOnly(gocpp::recv(m));
        auto [e, ok] = read.m[key];
        if(! ok && read.amended)
        {
            go_any value;
            bool loaded;
            Lock(gocpp::recv(m->mu));
            read = loadReadOnly(gocpp::recv(m));
            std::tie(e, ok) = read.m[key];
            if(! ok && read.amended)
            {
                go_any value;
                bool loaded;
                std::tie(e, ok) = m->dirty[key];
                remove(m->dirty, key);
                missLocked(gocpp::recv(m));
            }
            Unlock(gocpp::recv(m->mu));
        }
        if(ok)
        {
            go_any value;
            bool loaded;
            return remove(gocpp::recv(e));
        }
        return {nullptr, false};
    }

    void Delete(struct Map* m, go_any key)
    {
        LoadAndDelete(gocpp::recv(m), key);
    }

    std::tuple<go_any, bool> go_delete(struct entry* e)
    {
        go_any value;
        bool ok;
        for(; ; )
        {
            go_any value;
            bool ok;
            auto p = Load(gocpp::recv(e->p));
            if(p == nullptr || p == expunged)
            {
                go_any value;
                bool ok;
                return {nullptr, false};
            }
            if(CompareAndSwap(gocpp::recv(e->p), p, nullptr))
            {
                go_any value;
                bool ok;
                return {*p, true};
            }
        }
    }

    std::tuple<go_any*, bool> trySwap(struct entry* e, go_any* i)
    {
        for(; ; )
        {
            auto p = Load(gocpp::recv(e->p));
            if(p == expunged)
            {
                return {nullptr, false};
            }
            if(CompareAndSwap(gocpp::recv(e->p), p, i))
            {
                return {p, true};
            }
        }
    }

    std::tuple<go_any, bool> Swap(struct Map* m, go_any key, go_any value)
    {
        go_any previous;
        bool loaded;
        auto read = loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            go_any previous;
            bool loaded;
            if(auto [v, ok] = trySwap(gocpp::recv(e), & value); ok)
            {
                go_any previous;
                bool loaded;
                if(v == nullptr)
                {
                    go_any previous;
                    bool loaded;
                    return {nullptr, false};
                }
                return {*v, true};
            }
        }
        Lock(gocpp::recv(m->mu));
        read = loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            go_any previous;
            bool loaded;
            if(unexpungeLocked(gocpp::recv(e)))
            {
                go_any previous;
                bool loaded;
                m->dirty[key] = e;
            }
            if(auto v = swapLocked(gocpp::recv(e), & value); v != nullptr)
            {
                go_any previous;
                bool loaded;
                loaded = true;
                previous = *v;
            }
        }
        else
        if(auto [e, ok] = m->dirty[key]; ok)
        {
            go_any previous;
            bool loaded;
            if(auto v = swapLocked(gocpp::recv(e), & value); v != nullptr)
            {
                go_any previous;
                bool loaded;
                loaded = true;
                previous = *v;
            }
        }
        else
        {
            go_any previous;
            bool loaded;
            if(! read.amended)
            {
                go_any previous;
                bool loaded;
                dirtyLocked(gocpp::recv(m));
                Store(gocpp::recv(m->read), gocpp::InitPtr<readOnly>([](readOnly& x) { x.m = read.m; x.amended = true; }));
            }
            m->dirty[key] = newEntry(value);
        }
        Unlock(gocpp::recv(m->mu));
        return {previous, loaded};
    }

    bool CompareAndSwap(struct Map* m, go_any key, go_any old, go_any go_new)
    {
        gocpp::Defer defer;
        try
        {
            auto read = loadReadOnly(gocpp::recv(m));
            if(auto [e, ok] = read.m[key]; ok)
            {
                return tryCompareAndSwap(gocpp::recv(e), old, go_new);
            }
            else
            if(! read.amended)
            {
                return false;
            }
            Lock(gocpp::recv(m->mu));
            defer.push_back([=]{ Unlock(gocpp::recv(m->mu)); });
            read = loadReadOnly(gocpp::recv(m));
            auto swapped = false;
            if(auto [e, ok] = read.m[key]; ok)
            {
                swapped = tryCompareAndSwap(gocpp::recv(e), old, go_new);
            }
            else
            if(auto [e, ok] = m->dirty[key]; ok)
            {
                swapped = tryCompareAndSwap(gocpp::recv(e), old, go_new);
                missLocked(gocpp::recv(m));
            }
            return swapped;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    bool CompareAndDelete(struct Map* m, go_any key, go_any old)
    {
        bool deleted;
        auto read = loadReadOnly(gocpp::recv(m));
        auto [e, ok] = read.m[key];
        if(! ok && read.amended)
        {
            bool deleted;
            Lock(gocpp::recv(m->mu));
            read = loadReadOnly(gocpp::recv(m));
            std::tie(e, ok) = read.m[key];
            if(! ok && read.amended)
            {
                bool deleted;
                std::tie(e, ok) = m->dirty[key];
                missLocked(gocpp::recv(m));
            }
            Unlock(gocpp::recv(m->mu));
        }
        for(; ok; )
        {
            bool deleted;
            auto p = Load(gocpp::recv(e->p));
            if(p == nullptr || p == expunged || *p != old)
            {
                bool deleted;
                return false;
            }
            if(CompareAndSwap(gocpp::recv(e->p), p, nullptr))
            {
                bool deleted;
                return true;
            }
        }
        return false;
    }

    void Range(struct Map* m, std::function<bool (go_any key, go_any value)> f)
    {
        auto read = loadReadOnly(gocpp::recv(m));
        if(read.amended)
        {
            Lock(gocpp::recv(m->mu));
            read = loadReadOnly(gocpp::recv(m));
            if(read.amended)
            {
                read = gocpp::Init<readOnly>([](readOnly& x) { x.m = m->dirty; });
                auto copyRead = read;
                Store(gocpp::recv(m->read), & copyRead);
                m->dirty = nullptr;
                m->misses = 0;
            }
            Unlock(gocpp::recv(m->mu));
        }
        for(auto [k, e] : read.m)
        {
            auto [v, ok] = load(gocpp::recv(e));
            if(! ok)
            {
                continue;
            }
            if(! f(k, v))
            {
                break;
            }
        }
    }

    void missLocked(struct Map* m)
    {
        m->misses++;
        if(m->misses < len(m->dirty))
        {
            return;
        }
        Store(gocpp::recv(m->read), gocpp::InitPtr<readOnly>([](readOnly& x) { x.m = m->dirty; }));
        m->dirty = nullptr;
        m->misses = 0;
    }

    void dirtyLocked(struct Map* m)
    {
        if(m->dirty != nullptr)
        {
            return;
        }
        auto read = loadReadOnly(gocpp::recv(m));
        m->dirty = gocpp::make(gocpp::Tag<gocpp::map<go_any, entry*>>(), len(read.m));
        for(auto [k, e] : read.m)
        {
            if(! tryExpungeLocked(gocpp::recv(e)))
            {
                m->dirty[k] = e;
            }
        }
    }

    bool tryExpungeLocked(struct entry* e)
    {
        bool isExpunged;
        auto p = Load(gocpp::recv(e->p));
        for(; p == nullptr; )
        {
            bool isExpunged;
            if(CompareAndSwap(gocpp::recv(e->p), nullptr, expunged))
            {
                bool isExpunged;
                return true;
            }
            p = Load(gocpp::recv(e->p));
        }
        return p == expunged;
    }

}

