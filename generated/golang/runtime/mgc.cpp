// generated by GoCpp from file '$(ImportDir)/runtime/mgc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgc.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
#include "golang/runtime/arena.h"
#include "golang/runtime/atomic_pointer.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
#include "golang/runtime/mgcmark.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
// #include "golang/runtime/mgcsweep.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/sema.h"  [Ignored, known errors]
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/timeasm.h"
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    bool heapObjectsCanMove()
    {
        return false;
    }

    void gcinit()
    {
        if(gocpp::Sizeof<workbuf>() != _WorkbufSize)
        {
            go_throw("size of Workbuf is suboptimal");
        }
        rec::Store(gocpp::recv(sweep.active.state), sweepDrainedMask);
        rec::init(gocpp::recv(gcController), readGOGC(), readGOMEMLIMIT());
        work.startSema = 1;
        work.markDoneSema = 1;
        lockInit(& work.sweepWaiters.lock, lockRankSweepWaiters);
        lockInit(& work.assistQueue.lock, lockRankAssistQueue);
        lockInit(& work.wbufSpans.lock, lockRankWbufSpans);
    }

    void gcenable()
    {
        auto c = gocpp::make(gocpp::Tag<gocpp::channel<int>>(), 2);
        gocpp::go([&]{ bgsweep(c); });
        gocpp::go([&]{ bgscavenge(c); });
        c.recv();
        c.recv();
        memstats.enablegc = true;
    }

    uint32_t gcphase;
    struct gocpp_id_0
    {
        bool enabled;
        gocpp::array<unsigned char, 3> pad;
        uint64_t alignme;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.enabled = this->enabled;
            result.pad = this->pad;
            result.alignme = this->alignme;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (enabled != ref.enabled) return false;
            if (pad != ref.pad) return false;
            if (alignme != ref.alignme) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << enabled;
            os << " " << pad;
            os << " " << alignme;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_0 writeBarrier;
    uint32_t gcBlackenEnabled;
    void setGCPhase(uint32_t x)
    {
        atomic::Store(& gcphase, x);
        writeBarrier.enabled = gcphase == _GCmark || gcphase == _GCmarktermination;
    }

    gocpp::array_base<std::string> gcMarkWorkerModeStrings = gocpp::array_base<std::string> {"Not worker", "GC (dedicated)", "GC (fractional)", "GC (idle)"};
    bool pollFractionalWorkerExit()
    {
        auto now = nanotime();
        auto delta = now - gcController.markStartTime;
        if(delta <= 0)
        {
            return true;
        }
        auto p = rec::ptr(gocpp::recv(getg()->m->p));
        auto selfTime = p->gcFractionalMarkTime + (now - p->gcMarkWorkerStartTime);
        return double(selfTime) / double(delta) > 1.2 * gcController.fractionalUtilizationGoal;
    }

    workType work;
    
    template<typename T> requires gocpp::GoStruct<T>
    workType::operator T()
    {
        T result;
        result.full = this->full;
        result._ = this->_;
        result.empty = this->empty;
        result._ = this->_;
        result.wbufSpans = this->wbufSpans;
        result._ = this->_;
        result.bytesMarked = this->bytesMarked;
        result.markrootNext = this->markrootNext;
        result.markrootJobs = this->markrootJobs;
        result.nproc = this->nproc;
        result.tstart = this->tstart;
        result.nwait = this->nwait;
        result.nDataRoots = this->nDataRoots;
        result.nBSSRoots = this->nBSSRoots;
        result.nSpanRoots = this->nSpanRoots;
        result.nStackRoots = this->nStackRoots;
        result.baseData = this->baseData;
        result.baseBSS = this->baseBSS;
        result.baseSpans = this->baseSpans;
        result.baseStacks = this->baseStacks;
        result.baseEnd = this->baseEnd;
        result.stackRoots = this->stackRoots;
        result.startSema = this->startSema;
        result.markDoneSema = this->markDoneSema;
        result.bgMarkReady = this->bgMarkReady;
        result.bgMarkDone = this->bgMarkDone;
        result.mode = this->mode;
        result.userForced = this->userForced;
        result.initialHeapLive = this->initialHeapLive;
        result.assistQueue = this->assistQueue;
        result.sweepWaiters = this->sweepWaiters;
        result.cycles = this->cycles;
        result.stwprocs = this->stwprocs;
        result.maxprocs = this->maxprocs;
        result.tSweepTerm = this->tSweepTerm;
        result.tMark = this->tMark;
        result.tMarkTerm = this->tMarkTerm;
        result.tEnd = this->tEnd;
        result.pauseNS = this->pauseNS;
        result.heap0 = this->heap0;
        result.heap1 = this->heap1;
        result.heap2 = this->heap2;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool workType::operator==(const T& ref) const
    {
        if (full != ref.full) return false;
        if (_ != ref._) return false;
        if (empty != ref.empty) return false;
        if (_ != ref._) return false;
        if (wbufSpans != ref.wbufSpans) return false;
        if (_ != ref._) return false;
        if (bytesMarked != ref.bytesMarked) return false;
        if (markrootNext != ref.markrootNext) return false;
        if (markrootJobs != ref.markrootJobs) return false;
        if (nproc != ref.nproc) return false;
        if (tstart != ref.tstart) return false;
        if (nwait != ref.nwait) return false;
        if (nDataRoots != ref.nDataRoots) return false;
        if (nBSSRoots != ref.nBSSRoots) return false;
        if (nSpanRoots != ref.nSpanRoots) return false;
        if (nStackRoots != ref.nStackRoots) return false;
        if (baseData != ref.baseData) return false;
        if (baseBSS != ref.baseBSS) return false;
        if (baseSpans != ref.baseSpans) return false;
        if (baseStacks != ref.baseStacks) return false;
        if (baseEnd != ref.baseEnd) return false;
        if (stackRoots != ref.stackRoots) return false;
        if (startSema != ref.startSema) return false;
        if (markDoneSema != ref.markDoneSema) return false;
        if (bgMarkReady != ref.bgMarkReady) return false;
        if (bgMarkDone != ref.bgMarkDone) return false;
        if (mode != ref.mode) return false;
        if (userForced != ref.userForced) return false;
        if (initialHeapLive != ref.initialHeapLive) return false;
        if (assistQueue != ref.assistQueue) return false;
        if (sweepWaiters != ref.sweepWaiters) return false;
        if (cycles != ref.cycles) return false;
        if (stwprocs != ref.stwprocs) return false;
        if (maxprocs != ref.maxprocs) return false;
        if (tSweepTerm != ref.tSweepTerm) return false;
        if (tMark != ref.tMark) return false;
        if (tMarkTerm != ref.tMarkTerm) return false;
        if (tEnd != ref.tEnd) return false;
        if (pauseNS != ref.pauseNS) return false;
        if (heap0 != ref.heap0) return false;
        if (heap1 != ref.heap1) return false;
        if (heap2 != ref.heap2) return false;
        return true;
    }

    std::ostream& workType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << full;
        os << " " << _;
        os << " " << empty;
        os << " " << _;
        os << " " << wbufSpans;
        os << " " << _;
        os << " " << bytesMarked;
        os << " " << markrootNext;
        os << " " << markrootJobs;
        os << " " << nproc;
        os << " " << tstart;
        os << " " << nwait;
        os << " " << nDataRoots;
        os << " " << nBSSRoots;
        os << " " << nSpanRoots;
        os << " " << nStackRoots;
        os << " " << baseData;
        os << " " << baseBSS;
        os << " " << baseSpans;
        os << " " << baseStacks;
        os << " " << baseEnd;
        os << " " << stackRoots;
        os << " " << startSema;
        os << " " << markDoneSema;
        os << " " << bgMarkReady;
        os << " " << bgMarkDone;
        os << " " << mode;
        os << " " << userForced;
        os << " " << initialHeapLive;
        os << " " << assistQueue;
        os << " " << sweepWaiters;
        os << " " << cycles;
        os << " " << stwprocs;
        os << " " << maxprocs;
        os << " " << tSweepTerm;
        os << " " << tMark;
        os << " " << tMarkTerm;
        os << " " << tEnd;
        os << " " << pauseNS;
        os << " " << heap0;
        os << " " << heap1;
        os << " " << heap2;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct workType& value)
    {
        return value.PrintTo(os);
    }

    void GC()
    {
        auto n = rec::Load(gocpp::recv(work.cycles));
        gcWaitOnMark(n);
        gcStart(gocpp::Init<gcTrigger>([](gcTrigger& x) { x.kind = gcTriggerCycle; x.n = n + 1; }));
        gcWaitOnMark(n + 1);
        for(; rec::Load(gocpp::recv(work.cycles)) == n + 1 && sweepone() != ~ uintptr_t(0); )
        {
            Gosched();
        }
        for(; rec::Load(gocpp::recv(work.cycles)) == n + 1 && ! isSweepDone(); )
        {
            Gosched();
        }
        auto mp = acquirem();
        auto cycle = rec::Load(gocpp::recv(work.cycles));
        if(cycle == n + 1 || (gcphase == _GCmark && cycle == n + 2))
        {
            mProf_PostSweep();
        }
        releasem(mp);
    }

    void gcWaitOnMark(uint32_t n)
    {
        for(; ; )
        {
            lock(& work.sweepWaiters.lock);
            auto nMarks = rec::Load(gocpp::recv(work.cycles));
            if(gcphase != _GCmark)
            {
                nMarks++;
            }
            if(nMarks > n)
            {
                unlock(& work.sweepWaiters.lock);
                return;
            }
            rec::push(gocpp::recv(work.sweepWaiters.list), getg());
            goparkunlock(& work.sweepWaiters.lock, waitReasonWaitForGCCycle, traceBlockUntilGCEnds, 1);
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gcTrigger::operator T()
    {
        T result;
        result.kind = this->kind;
        result.now = this->now;
        result.n = this->n;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcTrigger::operator==(const T& ref) const
    {
        if (kind != ref.kind) return false;
        if (now != ref.now) return false;
        if (n != ref.n) return false;
        return true;
    }

    std::ostream& gcTrigger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << now;
        os << " " << n;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcTrigger& value)
    {
        return value.PrintTo(os);
    }

    bool rec::test(struct gcTrigger t)
    {
        if(! memstats.enablegc || rec::Load(gocpp::recv(panicking)) != 0 || gcphase != _GCoff)
        {
            return false;
        }
        //Go switch emulation
        {
            auto condition = t.kind;
            int conditionId = -1;
            if(condition == gcTriggerHeap) { conditionId = 0; }
            else if(condition == gcTriggerTime) { conditionId = 1; }
            else if(condition == gcTriggerCycle) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    auto [trigger, gocpp_id_5] = rec::trigger(gocpp::recv(gcController));
                    return rec::Load(gocpp::recv(gcController.heapLive)) >= trigger;
                    break;
                case 1:
                    if(rec::Load(gocpp::recv(gcController.gcPercent)) < 0)
                    {
                        return false;
                    }
                    auto lastgc = int64_t(atomic::Load64(& memstats.last_gc_nanotime));
                    return lastgc != 0 && t.now - lastgc > forcegcperiod;
                    break;
                case 2:
                    return int32_t(t.n - rec::Load(gocpp::recv(work.cycles))) > 0;
                    break;
            }
        }
        return true;
    }

    void gcStart(struct gcTrigger trigger)
    {
        auto mp = acquirem();
        if(auto gp = getg(); gp == mp->g0 || mp->locks > 1 || mp->preemptoff != "")
        {
            releasem(mp);
            return;
        }
        releasem(mp);
        mp = nullptr;
        for(; rec::test(gocpp::recv(trigger)) && sweepone() != ~ uintptr_t(0); )
        {
        }
        semacquire(& work.startSema);
        if(! rec::test(gocpp::recv(trigger)))
        {
            semrelease(& work.startSema);
            return;
        }
        auto mode = gcBackgroundMode;
        if(debug.gcstoptheworld == 1)
        {
            mode = gcForceMode;
        }
        else
        if(debug.gcstoptheworld == 2)
        {
            mode = gcForceBlockMode;
        }
        semacquire(& gcsema);
        semacquire(& worldsema);
        work.userForced = trigger.kind == gcTriggerCycle;
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GCStart(gocpp::recv(trace));
            traceRelease(trace);
        }
        for(auto [gocpp_ignored, p] : allp)
        {
            if(auto fg = rec::Load(gocpp::recv(p->mcache->flushGen)); fg != mheap_.sweepgen)
            {
                println("runtime: p", p->id, "flushGen", fg, "!= sweepgen", mheap_.sweepgen);
                go_throw("p mcache not flushed");
            }
        }
        gcBgMarkStartWorkers();
        systemstack(gcResetMarkState);
        std::tie(work.stwprocs, work.maxprocs) = std::tuple{gomaxprocs, gomaxprocs};
        if(work.stwprocs > ncpu)
        {
            work.stwprocs = ncpu;
        }
        work.heap0 = rec::Load(gocpp::recv(gcController.heapLive));
        work.pauseNS = 0;
        work.mode = mode;
        auto now = nanotime();
        work.tSweepTerm = now;
        worldStop stw = {};
        systemstack([=]() mutable -> void
        {
            stw = stopTheWorldWithSema(stwGCSweepTerm);
        });
        systemstack([=]() mutable -> void
        {
            finishsweep_m();
        });
        clearpools();
        rec::Add(gocpp::recv(work.cycles), 1);
        rec::startCycle(gocpp::recv(gcController), now, int(gomaxprocs), trigger);
        rec::startGCTransition(gocpp::recv(gcCPULimiter), true, now);
        if(mode != gcBackgroundMode)
        {
            schedEnableUser(false);
        }
        setGCPhase(_GCmark);
        gcBgMarkPrepare();
        gcMarkRootPrepare();
        gcMarkTinyAllocs();
        atomic::Store(& gcBlackenEnabled, 1);
        mp = acquirem();
        systemstack([=]() mutable -> void
        {
            now = startTheWorldWithSema(0, stw);
            work.pauseNS += now - stw.start;
            work.tMark = now;
            auto sweepTermCpu = int64_t(work.stwprocs) * (work.tMark - work.tSweepTerm);
            work.cpuStats.gcPauseTime += sweepTermCpu;
            work.cpuStats.gcTotalTime += sweepTermCpu;
            rec::finishGCTransition(gocpp::recv(gcCPULimiter), now);
        });
        semrelease(& worldsema);
        releasem(mp);
        if(mode != gcBackgroundMode)
        {
            Gosched();
        }
        semrelease(& work.startSema);
    }

    uint32_t gcMarkDoneFlushed;
    void gcMarkDone()
    {
        semacquire(& work.markDoneSema);
        top:
        if(! (gcphase == _GCmark && work.nwait == work.nproc && ! gcMarkWorkAvailable(nullptr)))
        {
            semrelease(& work.markDoneSema);
            return;
        }
        semacquire(& worldsema);
        gcMarkDoneFlushed = 0;
        forEachP(waitReasonGCMarkTermination, [=](struct p* pp) mutable -> void
        {
            wbBufFlush1(pp);
            rec::dispose(gocpp::recv(pp->gcw));
            if(pp->gcw.flushedWork)
            {
                atomic::Xadd(& gcMarkDoneFlushed, 1);
                pp->gcw.flushedWork = false;
            }
        });
        if(gcMarkDoneFlushed != 0)
        {
            semrelease(& worldsema);
            goto top;
        }
        auto now = nanotime();
        work.tMarkTerm = now;
        getg()->m->preemptoff = "gcing";
        worldStop stw = {};
        systemstack([=]() mutable -> void
        {
            stw = stopTheWorldWithSema(stwGCMarkTerm);
        });
        auto restart = false;
        systemstack([=]() mutable -> void
        {
            for(auto [gocpp_ignored, p] : allp)
            {
                wbBufFlush1(p);
                if(! rec::empty(gocpp::recv(p->gcw)))
                {
                    restart = true;
                    break;
                }
            }
        });
        if(restart)
        {
            getg()->m->preemptoff = "";
            systemstack([=]() mutable -> void
            {
                auto now = startTheWorldWithSema(0, stw);
                work.pauseNS += now - stw.start;
            });
            semrelease(& worldsema);
            goto top;
        }
        gcComputeStartingStackSize();
        atomic::Store(& gcBlackenEnabled, 0);
        rec::startGCTransition(gocpp::recv(gcCPULimiter), false, now);
        gcWakeAllAssists();
        semrelease(& work.markDoneSema);
        schedEnableUser(true);
        rec::endCycle(gocpp::recv(gcController), now, int(gomaxprocs), work.userForced);
        gcMarkTermination(stw);
    }

    void gcMarkTermination(struct worldStop stw)
    {
        setGCPhase(_GCmarktermination);
        work.heap1 = rec::Load(gocpp::recv(gcController.heapLive));
        auto startTime = nanotime();
        auto mp = acquirem();
        mp->preemptoff = "gcing";
        mp->traceback = 2;
        auto curgp = mp->curg;
        casGToWaiting(curgp, _Grunning, waitReasonGarbageCollection);
        systemstack([=]() mutable -> void
        {
            gcMark(startTime);
        });
        bool stwSwept = {};
        systemstack([=]() mutable -> void
        {
            work.heap2 = work.bytesMarked;
            if(debug.gccheckmark > 0)
            {
                startCheckmarks();
                gcResetMarkState();
                auto gcw = & rec::ptr(gocpp::recv(getg()->m->p))->gcw;
                gcDrain(gcw, 0);
                wbBufFlush1(rec::ptr(gocpp::recv(getg()->m->p)));
                rec::dispose(gocpp::recv(gcw));
                endCheckmarks();
            }
            setGCPhase(_GCoff);
            stwSwept = gcSweep(work.mode);
        });
        mp->traceback = 0;
        casgstatus(curgp, _Gwaiting, _Grunning);
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GCDone(gocpp::recv(trace));
            traceRelease(trace);
        }
        mp->preemptoff = "";
        if(gcphase != _GCoff)
        {
            go_throw("gc done but gcphase != _GCoff");
        }
        memstats.lastHeapInUse = rec::load(gocpp::recv(gcController.heapInUse));
        systemstack(gcControllerCommit);
        auto now = nanotime();
        auto [sec, nsec, gocpp_id_7] = time_now();
        auto unixNow = sec * 1e9 + int64_t(nsec);
        work.pauseNS += now - stw.start;
        work.tEnd = now;
        atomic::Store64(& memstats.last_gc_unix, uint64_t(unixNow));
        atomic::Store64(& memstats.last_gc_nanotime, uint64_t(now));
        memstats.pause_ns[memstats.numgc % uint32_t(len(memstats.pause_ns))] = uint64_t(work.pauseNS);
        memstats.pause_end[memstats.numgc % uint32_t(len(memstats.pause_end))] = uint64_t(unixNow);
        memstats.pause_total_ns += uint64_t(work.pauseNS);
        auto markTermCpu = int64_t(work.stwprocs) * (work.tEnd - work.tMarkTerm);
        work.cpuStats.gcPauseTime += markTermCpu;
        work.cpuStats.gcTotalTime += markTermCpu;
        rec::accumulate(gocpp::recv(work.cpuStats), now, true);
        memstats.gc_cpu_fraction = double(work.cpuStats.gcTotalTime - work.cpuStats.gcIdleTime) / double(work.cpuStats.totalTime);
        rec::Store(gocpp::recv(scavenge.assistTime), 0);
        rec::Store(gocpp::recv(scavenge.backgroundTime), 0);
        rec::Store(gocpp::recv(sched.idleTime), 0);
        if(work.userForced)
        {
            memstats.numforcedgc++;
        }
        lock(& work.sweepWaiters.lock);
        memstats.numgc++;
        injectglist(& work.sweepWaiters.list);
        unlock(& work.sweepWaiters.lock);
        rec::nextGen(gocpp::recv(mheap_.pages.scav.index));
        rec::finishGCTransition(gocpp::recv(gcCPULimiter), now);
        mProf_NextCycle();
        auto sl = rec::begin(gocpp::recv(sweep.active));
        if(! stwSwept && ! sl.valid)
        {
            go_throw("failed to set sweep barrier");
        }
        else
        if(stwSwept && sl.valid)
        {
            go_throw("non-concurrent sweep failed to drain all sweep queues");
        }
        systemstack([=]() mutable -> void
        {
            startTheWorldWithSema(now, stw);
        });
        mProf_Flush();
        prepareFreeWorkbufs();
        systemstack(freeStackSpans);
        forEachP(waitReasonFlushProcCaches, [=](struct p* pp) mutable -> void
        {
            rec::prepareForSweep(gocpp::recv(pp->mcache));
            if(pp->status == _Pidle)
            {
                systemstack([=]() mutable -> void
                {
                    lock(& mheap_.lock);
                    rec::flush(gocpp::recv(pp->pcache), & mheap_.pages);
                    unlock(& mheap_.lock);
                });
            }
            pp->pinnerCache = nullptr;
        });
        if(sl.valid)
        {
            rec::end(gocpp::recv(sweep.active), sl);
        }
        if(debug.gctrace > 0)
        {
            auto util = int(memstats.gc_cpu_fraction * 100);
            gocpp::array<unsigned char, 24> sbuf = {};
            printlock();
            print("gc ", memstats.numgc, " @", string(itoaDiv(sbuf.make_slice(0, ), uint64_t(work.tSweepTerm - runtimeInitTime) / 1e6, 3)), "s ", util, "%: ");
            auto prev = work.tSweepTerm;
            for(auto [i, ns] : gocpp::slice<int64_t> {work.tMark, work.tMarkTerm, work.tEnd})
            {
                if(i != 0)
                {
                    print("+");
                }
                print(string(fmtNSAsMS(sbuf.make_slice(0, ), uint64_t(ns - prev))));
                prev = ns;
            }
            print(" ms clock, ");
            for(auto [i, ns] : gocpp::slice<int64_t> {int64_t(work.stwprocs) * (work.tMark - work.tSweepTerm), rec::Load(gocpp::recv(gcController.assistTime)), rec::Load(gocpp::recv(gcController.dedicatedMarkTime)) + rec::Load(gocpp::recv(gcController.fractionalMarkTime)), rec::Load(gocpp::recv(gcController.idleMarkTime)), markTermCpu})
            {
                if(i == 2 || i == 3)
                {
                    print("/");
                }
                else
                if(i != 0)
                {
                    print("+");
                }
                print(string(fmtNSAsMS(sbuf.make_slice(0, ), uint64_t(ns))));
            }
            print(" ms cpu, ", work.heap0 >> 20, "->", work.heap1 >> 20, "->", work.heap2 >> 20, " MB, ", gcController.lastHeapGoal >> 20, " MB goal, ", rec::Load(gocpp::recv(gcController.lastStackScan)) >> 20, " MB stacks, ", rec::Load(gocpp::recv(gcController.globalsScan)) >> 20, " MB globals, ", work.maxprocs, " P");
            if(work.userForced)
            {
                print(" (forced)");
            }
            print("\n");
            printunlock();
        }
        lock(& userArenaState.lock);
        auto faultList = userArenaState.fault;
        userArenaState.fault = nullptr;
        unlock(& userArenaState.lock);
        for(auto [gocpp_ignored, lc] : faultList)
        {
            rec::setUserArenaChunkToFault(gocpp::recv(lc.mspan));
        }
        if(rec::heapGoal(gocpp::recv(gcController)) > minHeapForMetadataHugePages)
        {
            systemstack([=]() mutable -> void
            {
                rec::enableMetadataHugePages(gocpp::recv(mheap_));
            });
        }
        semrelease(& worldsema);
        semrelease(& gcsema);
        releasem(mp);
        mp = nullptr;
        if(! concurrentSweep)
        {
            Gosched();
        }
    }

    void gcBgMarkStartWorkers()
    {
        for(; gcBgMarkWorkerCount < gomaxprocs; )
        {
            gocpp::go([&]{ gcBgMarkWorker(); });
            notetsleepg(& work.bgMarkReady, - 1);
            noteclear(& work.bgMarkReady);
            gcBgMarkWorkerCount++;
        }
    }

    void gcBgMarkPrepare()
    {
        work.nproc = ~ uint32_t(0);
        work.nwait = ~ uint32_t(0);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gcBgMarkWorkerNode::operator T()
    {
        T result;
        result.node = this->node;
        result.gp = this->gp;
        result.m = this->m;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcBgMarkWorkerNode::operator==(const T& ref) const
    {
        if (node != ref.node) return false;
        if (gp != ref.gp) return false;
        if (m != ref.m) return false;
        return true;
    }

    std::ostream& gcBgMarkWorkerNode::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << node;
        os << " " << gp;
        os << " " << m;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcBgMarkWorkerNode& value)
    {
        return value.PrintTo(os);
    }

    void gcBgMarkWorker()
    {
        auto gp = getg();
        gp->m->preemptoff = "GC worker init";
        auto node = go_new(gcBgMarkWorkerNode);
        gp->m->preemptoff = "";
        rec::set(gocpp::recv(node->gp), gp);
        rec::set(gocpp::recv(node->m), acquirem());
        notewakeup(& work.bgMarkReady);
        for(; ; )
        {
            gopark([=](struct g* g, unsafe::Pointer nodep) mutable -> bool
            {
                auto node = (gcBgMarkWorkerNode*)(nodep);
                if(auto mp = rec::ptr(gocpp::recv(node->m)); mp != nullptr)
                {
                    releasem(mp);
                }
                rec::push(gocpp::recv(gcBgMarkWorkerPool), & node->node);
                return true;
            }, unsafe::Pointer(node), waitReasonGCWorkerIdle, traceBlockSystemGoroutine, 0);
            rec::set(gocpp::recv(node->m), acquirem());
            auto pp = rec::ptr(gocpp::recv(gp->m->p));
            if(gcBlackenEnabled == 0)
            {
                println("worker mode", pp->gcMarkWorkerMode);
                go_throw("gcBgMarkWorker: blackening not enabled");
            }
            if(pp->gcMarkWorkerMode == gcMarkWorkerNotWorker)
            {
                go_throw("gcBgMarkWorker: mode not set");
            }
            auto startTime = nanotime();
            pp->gcMarkWorkerStartTime = startTime;
            bool trackLimiterEvent = {};
            if(pp->gcMarkWorkerMode == gcMarkWorkerIdleMode)
            {
                trackLimiterEvent = rec::start(gocpp::recv(pp->limiterEvent), limiterEventIdleMarkWork, startTime);
            }
            auto decnwait = atomic::Xadd(& work.nwait, - 1);
            if(decnwait == work.nproc)
            {
                println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc);
                go_throw("work.nwait was > work.nproc");
            }
            systemstack([=]() mutable -> void
            {
                casGToWaiting(gp, _Grunning, waitReasonGCWorkerActive);
                //Go switch emulation
                {
                    auto condition = pp->gcMarkWorkerMode;
                    int conditionId = -1;
                    else if(condition == gcMarkWorkerDedicatedMode) { conditionId = 0; }
                    else if(condition == gcMarkWorkerFractionalMode) { conditionId = 1; }
                    else if(condition == gcMarkWorkerIdleMode) { conditionId = 2; }
                    switch(conditionId)
                    {
                        default:
                            go_throw("gcBgMarkWorker: unexpected gcMarkWorkerMode");
                            break;
                        case 0:
                            gcDrainMarkWorkerDedicated(& pp->gcw, true);
                            if(gp->preempt)
                            {
                                if(auto [drainQ, n] = runqdrain(pp); n > 0)
                                {
                                    lock(& sched.lock);
                                    globrunqputbatch(& drainQ, int32_t(n));
                                    unlock(& sched.lock);
                                }
                            }
                            gcDrainMarkWorkerDedicated(& pp->gcw, false);
                            break;
                        case 1:
                            gcDrainMarkWorkerFractional(& pp->gcw);
                            break;
                        case 2:
                            gcDrainMarkWorkerIdle(& pp->gcw);
                            break;
                    }
                }
                casgstatus(gp, _Gwaiting, _Grunning);
            });
            auto now = nanotime();
            auto duration = now - startTime;
            rec::markWorkerStop(gocpp::recv(gcController), pp->gcMarkWorkerMode, duration);
            if(trackLimiterEvent)
            {
                rec::stop(gocpp::recv(pp->limiterEvent), limiterEventIdleMarkWork, now);
            }
            if(pp->gcMarkWorkerMode == gcMarkWorkerFractionalMode)
            {
                atomic::Xaddint64(& pp->gcFractionalMarkTime, duration);
            }
            auto incnwait = atomic::Xadd(& work.nwait, + 1);
            if(incnwait > work.nproc)
            {
                println("runtime: p.gcMarkWorkerMode=", pp->gcMarkWorkerMode, "work.nwait=", incnwait, "work.nproc=", work.nproc);
                go_throw("work.nwait > work.nproc");
            }
            pp->gcMarkWorkerMode = gcMarkWorkerNotWorker;
            if(incnwait == work.nproc && ! gcMarkWorkAvailable(nullptr))
            {
                releasem(rec::ptr(gocpp::recv(node->m)));
                rec::set(gocpp::recv(node->m), nullptr);
                gcMarkDone();
            }
        }
    }

    bool gcMarkWorkAvailable(struct p* p)
    {
        if(p != nullptr && ! rec::empty(gocpp::recv(p->gcw)))
        {
            return true;
        }
        if(! rec::empty(gocpp::recv(work.full)))
        {
            return true;
        }
        if(work.markrootNext < work.markrootJobs)
        {
            return true;
        }
        return false;
    }

    void gcMark(int64_t startTime)
    {
        if(debug.allocfreetrace > 0)
        {
            tracegc();
        }
        if(gcphase != _GCmarktermination)
        {
            go_throw("in gcMark expecting to see gcphase as _GCmarktermination");
        }
        work.tstart = startTime;
        if(work.full != 0 || work.markrootNext < work.markrootJobs)
        {
            print("runtime: full=", hex(work.full), " next=", work.markrootNext, " jobs=", work.markrootJobs, " nDataRoots=", work.nDataRoots, " nBSSRoots=", work.nBSSRoots, " nSpanRoots=", work.nSpanRoots, " nStackRoots=", work.nStackRoots, "\n");
            gocpp::panic("non-empty mark queue after concurrent mark");
        }
        if(debug.gccheckmark > 0)
        {
            gcMarkRootCheck();
        }
        work.stackRoots = nullptr;
        for(auto [gocpp_ignored, p] : allp)
        {
            if(debug.gccheckmark > 0)
            {
                wbBufFlush1(p);
            }
            else
            {
                rec::reset(gocpp::recv(p->wbBuf));
            }
            auto gcw = & p->gcw;
            if(! rec::empty(gocpp::recv(gcw)))
            {
                printlock();
                print("runtime: P ", p->id, " flushedWork ", gcw->flushedWork);
                if(gcw->wbuf1 == nullptr)
                {
                    print(" wbuf1=<nil>");
                }
                else
                {
                    print(" wbuf1.n=", gcw->wbuf1->nobj);
                }
                if(gcw->wbuf2 == nullptr)
                {
                    print(" wbuf2=<nil>");
                }
                else
                {
                    print(" wbuf2.n=", gcw->wbuf2->nobj);
                }
                print("\n");
                go_throw("P has cached GC work at end of mark termination");
            }
            rec::dispose(gocpp::recv(gcw));
        }
        for(auto [gocpp_ignored, p] : allp)
        {
            auto c = p->mcache;
            if(c == nullptr)
            {
                continue;
            }
            c->scanAlloc = 0;
        }
        rec::resetLive(gocpp::recv(gcController), work.bytesMarked);
    }

    bool gcSweep(runtime::gcMode mode)
    {
        assertWorldStopped();
        if(gcphase != _GCoff)
        {
            go_throw("gcSweep being done but phase is not GCoff");
        }
        lock(& mheap_.lock);
        mheap_.sweepgen += 2;
        rec::reset(gocpp::recv(sweep.active));
        rec::Store(gocpp::recv(mheap_.pagesSwept), 0);
        mheap_.sweepArenas = mheap_.allArenas;
        rec::Store(gocpp::recv(mheap_.reclaimIndex), 0);
        rec::Store(gocpp::recv(mheap_.reclaimCredit), 0);
        unlock(& mheap_.lock);
        rec::clear(gocpp::recv(sweep.centralIndex));
        if(! concurrentSweep || mode == gcForceBlockMode)
        {
            lock(& mheap_.lock);
            mheap_.sweepPagesPerByte = 0;
            unlock(& mheap_.lock);
            for(auto [gocpp_ignored, pp] : allp)
            {
                rec::prepareForSweep(gocpp::recv(pp->mcache));
            }
            for(; sweepone() != ~ uintptr_t(0); )
            {
            }
            prepareFreeWorkbufs();
            for(; freeSomeWbufs(false); )
            {
            }
            mProf_NextCycle();
            mProf_Flush();
            return true;
        }
        lock(& sweep.lock);
        if(sweep.parked)
        {
            sweep.parked = false;
            ready(sweep.g, 0, true);
        }
        unlock(& sweep.lock);
        return false;
    }

    void gcResetMarkState()
    {
        forEachG([=](struct g* gp) mutable -> void
        {
            gp->gcscandone = false;
            gp->gcAssistBytes = 0;
        });
        lock(& mheap_.lock);
        auto arenas = mheap_.allArenas;
        unlock(& mheap_.lock);
        for(auto [gocpp_ignored, ai] : arenas)
        {
            auto ha = mheap_.arenas[rec::l1(gocpp::recv(ai))][rec::l2(gocpp::recv(ai))];
            for(auto [i, gocpp_ignored] : ha->pageMarks)
            {
                ha->pageMarks[i] = 0;
            }
        }
        work.bytesMarked = 0;
        work.initialHeapLive = rec::Load(gocpp::recv(gcController.heapLive));
    }

    std::function<void ()> poolcleanup;
    gocpp::slice<unsafe::Pointer> boringCaches;
    void sync_runtime_registerPoolCleanup(std::function<void ()> f)
    {
        poolcleanup = f;
    }

    void boring_registerCache(unsafe::Pointer p)
    {
        boringCaches = append(boringCaches, p);
    }

    void clearpools()
    {
        if(poolcleanup != nullptr)
        {
            poolcleanup();
        }
        for(auto [gocpp_ignored, p] : boringCaches)
        {
            atomicstorep(p, nullptr);
        }
        lock(& sched.sudoglock);
        sudog* sg = {};
        sudog* sgnext = {};
        for(sg = sched.sudogcache; sg != nullptr; sg = sgnext)
        {
            sgnext = sg->next;
            sg->next = nullptr;
        }
        sched.sudogcache = nullptr;
        unlock(& sched.sudoglock);
        lock(& sched.deferlock);
        _defer* d = {};
        _defer* dlink = {};
        for(d = sched.deferpool; d != nullptr; d = dlink)
        {
            dlink = d->link;
            d->link = nullptr;
        }
        sched.deferpool = nullptr;
        unlock(& sched.deferlock);
    }

    gocpp::slice<unsigned char> itoaDiv(gocpp::slice<unsigned char> buf, uint64_t val, int dec)
    {
        auto i = len(buf) - 1;
        auto idec = i - dec;
        for(; val >= 10 || i >= idec; )
        {
            buf[i] = unsigned char(val % 10 + '0');
            i--;
            if(i == idec)
            {
                buf[i] = '.';
                i--;
            }
            val /= 10;
        }
        buf[i] = unsigned char(val + '0');
        return buf.make_slice(i);
    }

    gocpp::slice<unsigned char> fmtNSAsMS(gocpp::slice<unsigned char> buf, uint64_t ns)
    {
        if(ns >= 10e6)
        {
            return itoaDiv(buf, ns / 1e6, 0);
        }
        auto x = ns / 1e3;
        if(x == 0)
        {
            buf[0] = '0';
            return buf.make_slice(0, 1);
        }
        auto dec = 3;
        for(; x >= 100; )
        {
            x /= 10;
            dec--;
        }
        return itoaDiv(buf, x, dec);
    }

    void gcTestMoveStackOnNextCall()
    {
        auto gp = getg();
        gp->stackguard0 = stackForceMove;
    }

    uint64_t gcTestIsReachable(gocpp::slice<unsafe::Pointer> ptrs)
    {
        uint64_t mask;
        if(len(ptrs) > 64)
        {
            uint64_t mask;
            gocpp::panic("too many pointers for uint64 mask");
        }
        semacquire(& gcsema);
        auto specials = gocpp::make(gocpp::Tag<gocpp::slice<specialReachable*>>(), len(ptrs));
        for(auto [i, p] : ptrs)
        {
            uint64_t mask;
            lock(& mheap_.speciallock);
            auto s = (specialReachable*)(rec::alloc(gocpp::recv(mheap_.specialReachableAlloc)));
            unlock(& mheap_.speciallock);
            s->special.kind = _KindSpecialReachable;
            if(! addspecial(p, & s->special))
            {
                uint64_t mask;
                go_throw("already have a reachable special (duplicate pointer?)");
            }
            specials[i] = s;
            ptrs[i] = nullptr;
        }
        semrelease(& gcsema);
        GC();
        for(auto [i, s] : specials)
        {
            uint64_t mask;
            if(! s->done)
            {
                uint64_t mask;
                printlock();
                println("runtime: object", i, "was not swept");
                go_throw("IsReachable failed");
            }
            if(s->reachable)
            {
                uint64_t mask;
                mask |= 1 << i;
            }
            lock(& mheap_.speciallock);
            rec::free(gocpp::recv(mheap_.specialReachableAlloc), unsafe::Pointer(s));
            unlock(& mheap_.speciallock);
        }
        return mask;
    }

    std::string gcTestPointerClass(unsafe::Pointer p)
    {
        auto p2 = uintptr_t(noescape(p));
        auto gp = getg();
        if(gp->stack.lo <= p2 && p2 < gp->stack.hi)
        {
            return "stack";
        }
        if(auto [base, gocpp_id_10, gocpp_id_11] = findObject(p2, 0, 0); base != 0)
        {
            return "heap";
        }
        for(auto [gocpp_ignored, datap] : activeModules())
        {
            if(datap->data <= p2 && p2 < datap->edata || datap->noptrdata <= p2 && p2 < datap->enoptrdata)
            {
                return "data";
            }
            if(datap->bss <= p2 && p2 < datap->ebss || datap->noptrbss <= p2 && p2 <= datap->enoptrbss)
            {
                return "bss";
            }
        }
        KeepAlive(p);
        return "other";
    }

}

