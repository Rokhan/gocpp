// generated by GoCpp from file '$(ImportDir)/runtime/mfixalloc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mfixalloc.h"
#include "gocpp/support.h"

#include "golang/runtime/malloc.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/unsafe/unsafe.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/internal/sys/nih.h"

namespace golang::runtime
{
    
    std::ostream& fixalloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << size;
        os << " " << first;
        os << " " << arg;
        os << " " << list;
        os << " " << chunk;
        os << " " << nchunk;
        os << " " << nalloc;
        os << " " << inuse;
        os << " " << stat;
        os << " " << zero;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const fixalloc& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& mlink::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const mlink& value)
    {
        return value.PrintTo(os);
    }

    void init(fixalloc* f, uintptr_t size, std::function<void (unsafe::Pointer arg, unsafe::Pointer p)> first, unsafe::Pointer arg, sysMemStat* stat)
    {
        if(size > _FixAllocChunk)
        {
            go_throw("runtime: fixalloc size too large");
        }
        size = max(size, Sizeof(gocpp::recv(unsafe), mlink {}));
        f->size = size;
        f->first = first;
        f->arg = arg;
        f->list = nullptr;
        f->chunk = 0;
        f->nchunk = 0;
        f->nalloc = uint32_t(_FixAllocChunk / size * size);
        f->inuse = 0;
        f->stat = stat;
        f->zero = true;
    }

    unsafe::Pointer alloc(fixalloc* f)
    {
        if(f->size == 0)
        {
            print("runtime: use of FixAlloc_Alloc before FixAlloc_Init\n");
            go_throw("runtime: internal error");
        }
        if(f->list != nullptr)
        {
            auto v = Pointer(gocpp::recv(unsafe), f->list);
            f->list = f->list->next;
            f->inuse += f->size;
            if(f->zero)
            {
                memclrNoHeapPointers(v, f->size);
            }
            return v;
        }
        if(uintptr(f->nchunk) < f->size)
        {
            f->chunk = uintptr(persistentalloc(uintptr(f->nalloc), 0, f->stat));
            f->nchunk = f->nalloc;
        }
        auto v = Pointer(gocpp::recv(unsafe), f->chunk);
        if(f->first != nullptr)
        {
            first(gocpp::recv(f), f->arg, v);
        }
        f->chunk = f->chunk + f->size;
        f->nchunk -= uint32_t(f->size);
        f->inuse += f->size;
        return v;
    }

    void free(fixalloc* f, unsafe::Pointer p)
    {
        f->inuse -= f->size;
        auto v = (*mlink)(p);
        v->next = f->list;
        f->list = v;
    }

}

