// generated by GoCpp from file '$(ImportDir)/runtime/trace2stack.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2stack.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mprof.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/stubs_amd64.h"
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/symtabinl.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
// #include "golang/runtime/trace2map.h"  [Ignored, known errors]
// #include "golang/runtime/trace2region.h"  [Ignored, known errors]
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    uint64_t traceStack(int skip, m* mp, uintptr_t gen)
    {
        gocpp::array<uintptr_t, traceStackSize> pcBuf = {};
        auto gp = getg();
        auto curgp = gp->m->curg;
        auto nstk = 1;
        if(tracefpunwindoff() || hasCgoOnStack(gocpp::recv(mp)))
        {
            pcBuf[0] = logicalStackSentinel;
            if(curgp == gp)
            {
                nstk += callers(skip + 1, pcBuf.make_slice(1));
            }
            else
            if(curgp != nullptr)
            {
                nstk += gcallers(curgp, skip, pcBuf.make_slice(1));
            }
        }
        else
        {
            pcBuf[0] = uintptr_t(skip);
            if(curgp == gp)
            {
                nstk += fpTracebackPCs(unsafe::Pointer(getfp()), pcBuf.make_slice(1));
            }
            else
            if(curgp != nullptr)
            {
                pcBuf[1] = curgp->sched.pc;
                nstk += 1 + fpTracebackPCs(unsafe::Pointer(curgp->sched.bp), pcBuf.make_slice(2));
            }
        }
        if(nstk > 0)
        {
            nstk--;
        }
        if(nstk > 0 && curgp->goid == 1)
        {
            nstk--;
        }
        auto id = put(gocpp::recv(trace.stackTab[gen % 2]), pcBuf.make_slice(0, nstk));
        return id;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceStackTable::operator T()
    {
        T result;
        result.tab = this->tab;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceStackTable::operator==(const T& ref) const
    {
        if (tab != ref.tab) return false;
        return true;
    }

    std::ostream& traceStackTable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceStackTable& value)
    {
        return value.PrintTo(os);
    }

    uint64_t put(struct traceStackTable* t, gocpp::slice<uintptr_t> pcs)
    {
        if(len(pcs) == 0)
        {
            return 0;
        }
        auto [id, gocpp_id_1] = put(gocpp::recv(t->tab), noescape(unsafe::Pointer(& pcs[0])), uintptr_t(len(pcs)) * gocpp::Sizeof<uintptr_t>());
        return id;
    }

    void dump(struct traceStackTable* t, uintptr_t gen)
    {
        auto w = unsafeTraceWriter(gen, nullptr);
        for(auto [i, gocpp_ignored] : t->tab.tab)
        {
            auto stk = bucket(gocpp::recv(t->tab), i);
            for(; stk != nullptr; stk = next(gocpp::recv(stk)))
            {
                auto stack = unsafe::Slice((uintptr_t*)(unsafe::Pointer(& stk->data[0])), uintptr_t(len(stk->data)) / gocpp::Sizeof<uintptr_t>());
                auto frames = makeTraceFrames(gen, fpunwindExpand(stack));
                auto maxBytes = 1 + (2 + 4 * len(frames)) * traceBytesPerNumber;
                bool flushed = {};
                std::tie(w, flushed) = ensure(gocpp::recv(w), 1 + maxBytes);
                if(flushed)
                {
                    unsigned char(gocpp::recv(w), unsigned char(traceEvStacks));
                }
                unsigned char(gocpp::recv(w), unsigned char(traceEvStack));
                varint(gocpp::recv(w), uint64_t(stk->id));
                varint(gocpp::recv(w), uint64_t(len(frames)));
                for(auto [_, frame] : frames)
                {
                    varint(gocpp::recv(w), uint64_t(frame.PC));
                    varint(gocpp::recv(w), frame.funcID);
                    varint(gocpp::recv(w), frame.fileID);
                    varint(gocpp::recv(w), frame.line);
                }
            }
        }
        lock(& t->tab.lock);
        reset(gocpp::recv(t->tab));
        unlock(& t->tab.lock);
        end(gocpp::recv(flush(gocpp::recv(w))));
    }

    gocpp::slice<traceFrame> makeTraceFrames(uintptr_t gen, gocpp::slice<uintptr_t> pcs)
    {
        auto frames = gocpp::make(gocpp::Tag<gocpp::slice<traceFrame>>(), 0, len(pcs));
        auto ci = CallersFrames(pcs);
        for(; ; )
        {
            auto [f, more] = Next(gocpp::recv(ci));
            frames = append(frames, makeTraceFrame(gen, f));
            if(! more)
            {
                return frames;
            }
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceFrame::operator T()
    {
        T result;
        result.PC = this->PC;
        result.funcID = this->funcID;
        result.fileID = this->fileID;
        result.line = this->line;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceFrame::operator==(const T& ref) const
    {
        if (PC != ref.PC) return false;
        if (funcID != ref.funcID) return false;
        if (fileID != ref.fileID) return false;
        if (line != ref.line) return false;
        return true;
    }

    std::ostream& traceFrame::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PC;
        os << " " << funcID;
        os << " " << fileID;
        os << " " << line;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceFrame& value)
    {
        return value.PrintTo(os);
    }

    traceFrame makeTraceFrame(uintptr_t gen, Frame f)
    {
        traceFrame frame = {};
        frame.PC = f.PC;
        auto fn = f.Function;
        auto maxLen = 1 << 10;
        if(len(fn) > maxLen)
        {
            fn = fn.make_slice(len(fn) - maxLen);
        }
        frame.funcID = put(gocpp::recv(trace.stringTab[gen % 2]), gen, fn);
        frame.line = uint64_t(f.Line);
        auto file = f.File;
        if(len(file) > maxLen)
        {
            file = file.make_slice(len(file) - maxLen);
        }
        frame.fileID = put(gocpp::recv(trace.stringTab[gen % 2]), gen, file);
        return frame;
    }

    bool tracefpunwindoff()
    {
        return debug.tracefpunwindoff != 0 || (goarch::ArchFamily != goarch::AMD64 && goarch::ArchFamily != goarch::ARM64);
    }

    int fpTracebackPCs(unsafe::Pointer fp, gocpp::slice<uintptr_t> pcBuf)
    {
        int i;
        for(i = 0; i < len(pcBuf) && fp != nullptr; i++)
        {
            int i;
            pcBuf[i] = *(uintptr_t*)(unsafe::Pointer(uintptr_t(fp) + goarch::PtrSize));
            fp = unsafe::Pointer(*(uintptr_t*)(fp));
        }
        return i;
    }

    gocpp::slice<uintptr_t> fpunwindExpand(gocpp::slice<uintptr_t> pcBuf)
    {
        if(len(pcBuf) > 0 && pcBuf[0] == logicalStackSentinel)
        {
            return pcBuf.make_slice(1);
        }
        auto lastFuncID = abi::FuncIDNormal;
        auto newPCBuf = gocpp::make(gocpp::Tag<gocpp::slice<uintptr_t>>(), 0, traceStackSize);
        auto skip = pcBuf[0];
        auto skipOrAdd = [=](uintptr_t retPC) mutable -> bool
        {
            if(skip > 0)
            {
                skip--;
            }
            else
            {
                newPCBuf = append(newPCBuf, retPC);
            }
            return len(newPCBuf) < cap(newPCBuf);
        };
        outer:
        for(auto [_, retPC] : pcBuf.make_slice(1))
        {
            auto callPC = retPC - 1;
            auto fi = findfunc(callPC);
            if(! valid(gocpp::recv(fi)))
            {
                if(auto more = skipOrAdd(retPC); ! more)
                {
                    goto outer_break;
                }
                continue;
            }
            auto [u, uf] = newInlineUnwinder(fi, callPC);
            for(; valid(gocpp::recv(uf)); uf = next(gocpp::recv(u), uf))
            {
                auto sf = srcFunc(gocpp::recv(u), uf);
                if(sf.funcID == abi::FuncIDWrapper && elideWrapperCalling(lastFuncID))
                {
                }
                else
                if(auto more = skipOrAdd(uf.pc + 1); ! more)
                {
                    goto outer_break;
                }
                lastFuncID = sf.funcID;
            }
            if(false) {
            outer_continue:
                continue;
            outer_break:
                break;
            }
        }
        return newPCBuf;
    }

    uintptr_t startPCForTrace(uintptr_t pc)
    {
        auto f = findfunc(pc);
        if(! valid(gocpp::recv(f)))
        {
            return pc;
        }
        auto w = funcdata(f, abi::FUNCDATA_WrapInfo);
        if(w == nullptr)
        {
            return pc;
        }
        return textAddr(gocpp::recv(f.datap), *(uint32_t*)(w));
    }

}

