// generated by GoCpp from file '$(ImportDir)/compress/zlib/writer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/zlib/writer.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/encoding/binary/binary.h"
#include "golang/fmt/errors.h"
#include "golang/hash/adler32/adler32.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"

namespace golang::zlib
{
    namespace rec
    {
        using namespace mocklib::rec;
        using binary::rec::PutUint32;
        using binary::rec::Uint16;
        using flate::rec::Close;
        using flate::rec::Flush;
        using flate::rec::Reset;
        using flate::rec::Write;
        using hash::rec::Reset;
        using hash::rec::Sum32;
        using io::rec::Write;
    }

    // These constants are copied from the flate package, so that code that imports
    // "compress/zlib" does not also have to import "compress/flate".
    // A Writer takes data written to it and writes the compressed
    // form of that data to an underlying writer (see NewWriter).
    
    template<typename T> requires gocpp::GoStruct<T>
    Writer::operator T()
    {
        T result;
        result.w = this->w;
        result.level = this->level;
        result.dict = this->dict;
        result.compressor = this->compressor;
        result.digest = this->digest;
        result.err = this->err;
        result.scratch = this->scratch;
        result.wroteHeader = this->wroteHeader;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Writer::operator==(const T& ref) const
    {
        if (w != ref.w) return false;
        if (level != ref.level) return false;
        if (dict != ref.dict) return false;
        if (compressor != ref.compressor) return false;
        if (digest != ref.digest) return false;
        if (err != ref.err) return false;
        if (scratch != ref.scratch) return false;
        if (wroteHeader != ref.wroteHeader) return false;
        return true;
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << w;
        os << " " << level;
        os << " " << dict;
        os << " " << compressor;
        os << " " << digest;
        os << " " << err;
        os << " " << scratch;
        os << " " << wroteHeader;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    // NewWriter creates a new Writer.
    // Writes to the returned Writer are compressed and written to w.
    //
    // It is the caller's responsibility to call Close on the Writer when done.
    // Writes may be buffered and not flushed until Close.
    struct Writer* NewWriter(io::Writer w)
    {
        auto [z, gocpp_id_0] = NewWriterLevelDict(w, DefaultCompression, nullptr);
        return z;
    }

    // NewWriterLevel is like NewWriter but specifies the compression level instead
    // of assuming DefaultCompression.
    //
    // The compression level can be DefaultCompression, NoCompression, HuffmanOnly
    // or any integer value between BestSpeed and BestCompression inclusive.
    // The error returned will be nil if the level is valid.
    std::tuple<struct Writer*, struct gocpp::error> NewWriterLevel(io::Writer w, int level)
    {
        return NewWriterLevelDict(w, level, nullptr);
    }

    // NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to
    // compress with.
    //
    // The dictionary may be nil. If not, its contents should not be modified until
    // the Writer is closed.
    std::tuple<struct Writer*, struct gocpp::error> NewWriterLevelDict(io::Writer w, int level, gocpp::slice<unsigned char> dict)
    {
        if(level < HuffmanOnly || level > BestCompression)
        {
            return {nullptr, mocklib::Errorf("zlib: invalid compression level: %d"s, level)};
        }
        return {gocpp::InitPtr<Writer>([=](auto& x) {
            x.w = w;
            x.level = level;
            x.dict = dict;
        }), nullptr};
    }

    // Reset clears the state of the Writer z such that it is equivalent to its
    // initial state from NewWriterLevel or NewWriterLevelDict, but instead writing
    // to w.
    void rec::Reset(struct Writer* z, io::Writer w)
    {
        z->w = w;
        if(z->compressor != nullptr)
        {
            rec::Reset(gocpp::recv(z->compressor), w);
        }
        if(z->digest != nullptr)
        {
            rec::Reset(gocpp::recv(z->digest));
        }
        z->err = nullptr;
        z->scratch = gocpp::array<unsigned char, 4> {};
        z->wroteHeader = false;
    }

    // writeHeader writes the ZLIB header.
    struct gocpp::error rec::writeHeader(struct Writer* z)
    {
        struct gocpp::error err;
        z->wroteHeader = true;
        z->scratch[0] = 0x78;
        //Go switch emulation
        {
            auto condition = z->level;
            int conditionId = -1;
            if(condition == - 2) { conditionId = 0; }
            else if(condition == 0) { conditionId = 1; }
            else if(condition == 1) { conditionId = 2; }
            else if(condition == 2) { conditionId = 3; }
            else if(condition == 3) { conditionId = 4; }
            else if(condition == 4) { conditionId = 5; }
            else if(condition == 5) { conditionId = 6; }
            else if(condition == 6) { conditionId = 7; }
            else if(condition == - 1) { conditionId = 8; }
            else if(condition == 7) { conditionId = 9; }
            else if(condition == 8) { conditionId = 10; }
            else if(condition == 9) { conditionId = 11; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                    z->scratch[1] = 0 << 6;
                    break;
                case 3:
                case 4:
                case 5:
                case 6:
                    z->scratch[1] = 1 << 6;
                    break;
                case 7:
                case 8:
                    z->scratch[1] = 2 << 6;
                    break;
                case 9:
                case 10:
                case 11:
                    z->scratch[1] = 3 << 6;
                    break;
                default:
                    gocpp::panic("unreachable"s);
                    break;
            }
        }
        if(z->dict != nullptr)
        {
            z->scratch[1] |= 1 << 5;
        }
        z->scratch[1] += uint8_t(31 - rec::Uint16(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 2)) % 31);
        if(std::tie(gocpp_id_1, err) = rec::Write(gocpp::recv(z->w), z->scratch.make_slice(0, 2)); err != nullptr)
        {
            return err;
        }
        if(z->dict != nullptr)
        {
            rec::PutUint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0), adler32::Checksum(z->dict));
            if(std::tie(gocpp_id_2, err) = rec::Write(gocpp::recv(z->w), z->scratch.make_slice(0, 4)); err != nullptr)
            {
                return err;
            }
        }
        if(z->compressor == nullptr)
        {
            std::tie(z->compressor, err) = flate::NewWriterDict(z->w, z->level, z->dict);
            if(err != nullptr)
            {
                return err;
            }
            z->digest = adler32::New();
        }
        return nullptr;
    }

    // Write writes a compressed form of p to the underlying io.Writer. The
    // compressed bytes are not necessarily flushed until the Writer is closed or
    // explicitly flushed.
    std::tuple<int, struct gocpp::error> rec::Write(struct Writer* z, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(! z->wroteHeader)
        {
            z->err = rec::writeHeader(gocpp::recv(z));
        }
        if(z->err != nullptr)
        {
            return {0, z->err};
        }
        if(len(p) == 0)
        {
            return {0, nullptr};
        }
        std::tie(n, err) = rec::Write(gocpp::recv(z->compressor), p);
        if(err != nullptr)
        {
            z->err = err;
            return {n, err};
        }
        rec::Write(gocpp::recv(z->digest), p);
        return {n, err};
    }

    // Flush flushes the Writer to its underlying io.Writer.
    struct gocpp::error rec::Flush(struct Writer* z)
    {
        if(! z->wroteHeader)
        {
            z->err = rec::writeHeader(gocpp::recv(z));
        }
        if(z->err != nullptr)
        {
            return z->err;
        }
        z->err = rec::Flush(gocpp::recv(z->compressor));
        return z->err;
    }

    // Close closes the Writer, flushing any unwritten data to the underlying
    // io.Writer, but does not close the underlying io.Writer.
    struct gocpp::error rec::Close(struct Writer* z)
    {
        if(! z->wroteHeader)
        {
            z->err = rec::writeHeader(gocpp::recv(z));
        }
        if(z->err != nullptr)
        {
            return z->err;
        }
        z->err = rec::Close(gocpp::recv(z->compressor));
        if(z->err != nullptr)
        {
            return z->err;
        }
        auto checksum = rec::Sum32(gocpp::recv(z->digest));
        rec::PutUint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0), checksum);
        std::tie(gocpp_id_3, z->err) = rec::Write(gocpp::recv(z->w), z->scratch.make_slice(0, 4));
        return z->err;
    }

}

