// generated by GoCpp from file '$(ImportDir)/runtime/mgcscavenge.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcscavenge.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/goos/zgoos_windows.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/float.h"
#include "golang/runtime/lock_sema.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
// #include "golang/runtime/mpagealloc_64bit.h"  [Ignored, known errors]
#include "golang/runtime/mpallocbits.h"
// #include "golang/runtime/mranges.h"  [Ignored, known errors]
// #include "golang/runtime/mstats.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    extern int scavengePercent;
    extern int retainExtraPercent;
    extern int reduceExtraPercent;
    extern int maxPagesPerPhysPage;
    extern double scavengeCostRatio;
    extern double scavChunkHiOccFrac;
    extern uint16_t scavChunkHiOccPages;
    uint64_t heapRetained();
    void gcPaceScavenger(int64_t memoryLimit, uint64_t heapGoal, uint64_t lastHeapGoal);
    extern double startingScavSleepRatio;
    extern double minScavWorkTime;
    struct scavengerState
    {
        mutex lock;
        g* g;
        bool parked;
        timer* timer;
        atomic::Uint32 sysmonWake;
        double targetCPUFraction;
        double sleepRatio;
        piController sleepController;
        int64_t controllerCooldown;
        bool printControllerReset;
        std::function<int64_t (int64_t n)> sleepStub;
        std::function<std::tuple<uintptr_t, int64_t> (uintptr_t n)> scavenge;
        std::function<bool ()> shouldStop;
        std::function<int32_t ()> gomaxprocs;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const scavengerState& value);
    void init(scavengerState* s);
    void park(scavengerState* s);
    void ready(scavengerState* s);
    void wake(scavengerState* s);
    void sleep(scavengerState* s, double worked);
    void controllerFailed(scavengerState* s);
    std::tuple<uintptr_t, double> run(scavengerState* s);
    void bgscavenge(gocpp::channel<int> c);
    uintptr_t scavenge(pageAlloc* p, uintptr_t nbytes, std::function<bool ()> shouldStop, bool force);
    void printScavTrace(uintptr_t releasedBg, uintptr_t releasedEager, bool forced);
    uintptr_t scavengeOne(pageAlloc* p, chunkIdx ci, unsigned int searchIdx, uintptr_t max);
    uint64_t fillAligned(uint64_t x, unsigned int m);
    std::tuple<unsigned int, unsigned int> findScavengeCandidate(pallocData* m, unsigned int searchIdx, uintptr_t minimum, uintptr_t max);
    struct scavengeIndex
    {
        gocpp::slice<atomicScavChunkData> chunks;
        atomic::Uintptr min;
        atomic::Uintptr max;
        atomic::Uintptr minHeapIdx;
        atomicOffAddr searchAddrBg;
        atomicOffAddr searchAddrForce;
        offAddr freeHWM;
        uint32_t gen;
        bool test;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const scavengeIndex& value);
    uintptr_t init(scavengeIndex* s, bool test, sysMemStat* sysStat);
    uintptr_t grow(scavengeIndex* s, uintptr_t base, uintptr_t limit, sysMemStat* sysStat);
    std::tuple<chunkIdx, unsigned int> find(scavengeIndex* s, bool force);
    void alloc(scavengeIndex* s, chunkIdx ci, unsigned int npages);
    void free(scavengeIndex* s, chunkIdx ci, unsigned int page, unsigned int npages);
    void nextGen(scavengeIndex* s);
    void setEmpty(scavengeIndex* s, chunkIdx ci);
    struct atomicScavChunkData
    {
        atomic::Uint64 value;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const atomicScavChunkData& value);
    scavChunkData load(atomicScavChunkData* sc);
    void store(atomicScavChunkData* sc, scavChunkData ssc);
    struct scavChunkData
    {
        uint16_t inUse;
        uint16_t lastInUse;
        uint32_t gen;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const scavChunkData& value);
    scavChunkData unpackScavChunkData(uint64_t sc);
    uint64_t pack(scavChunkData sc);
    extern int scavChunkMaxFlags;
    extern int scavChunkFlagsMask;
    extern int logScavChunkInUseMax;
    extern int scavChunkInUseMask;
    using scavChunkFlags = uint8_t;
    bool isEmpty(scavChunkFlags* sc);
    void setEmpty(scavChunkFlags* sc);
    void setNonEmpty(scavChunkFlags* sc);
    bool shouldScavenge(scavChunkData sc, uint32_t currGen, bool force);
    void alloc(scavChunkData* sc, unsigned int npages, uint32_t newGen);
    void free(scavChunkData* sc, unsigned int npages, uint32_t newGen);
    struct piController
    {
        double kp;
        double ti;
        double tt;
        double min;
        double max;
        double errIntegral;
        bool errOverflow;
        bool inputOverflow;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const piController& value);
    std::tuple<double, bool> next(piController* c, double input, double setpoint, double period);
    void reset(piController* c);
}

