// generated by GoCpp from file '$(ImportDir)/image/image.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/image.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/image/color/ycbcr.h"
#include "golang/image/geom.h"

namespace golang::image
{
    
    std::ostream& Config::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ColorModel;
        os << " " << Width;
        os << " " << Height;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Config& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Image::Image(T& ref)
    {
        value.reset(new ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Image::Image(const T& ref)
    {
        value.reset(new ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Image::Image(T* ptr)
    {
        value.reset(new ImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Image::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    color::Model Image::ImageImpl<T, StoreT>::vColorModel()
    {
        return ColorModel(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    Rectangle Image::ImageImpl<T, StoreT>::vBounds()
    {
        return Bounds(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    color::Color Image::ImageImpl<T, StoreT>::vAt(int x, int y)
    {
        return At(gocpp::PtrRecv<T, false>(value.get()));
    }

    color::Model ColorModel(const gocpp::PtrRecv<Image, false>& self)
    {
        return self.ptr->value->vColorModel();
    }

    color::Model ColorModel(const gocpp::ObjRecv<Image>& self)
    {
        return self.obj.value->vColorModel();
    }

    Rectangle Bounds(const gocpp::PtrRecv<Image, false>& self)
    {
        return self.ptr->value->vBounds();
    }

    Rectangle Bounds(const gocpp::ObjRecv<Image>& self)
    {
        return self.obj.value->vBounds();
    }

    color::Color At(const gocpp::PtrRecv<Image, false>& self, int x, int y)
    {
        return self.ptr->value->vAt(int x, int y);
    }

    color::Color At(const gocpp::ObjRecv<Image>& self, int x, int y)
    {
        return self.obj.value->vAt(int x, int y);
    }

    std::ostream& operator<<(std::ostream& os, const struct Image& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    RGBA64Image::RGBA64Image(T& ref)
    {
        value.reset(new RGBA64ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RGBA64Image::RGBA64Image(const T& ref)
    {
        value.reset(new RGBA64ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RGBA64Image::RGBA64Image(T* ptr)
    {
        value.reset(new RGBA64ImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RGBA64Image::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    color::RGBA64 RGBA64Image::RGBA64ImageImpl<T, StoreT>::vRGBA64At(int x, int y)
    {
        return RGBA64At(gocpp::PtrRecv<T, false>(value.get()));
    }

    color::RGBA64 RGBA64At(const gocpp::PtrRecv<RGBA64Image, false>& self, int x, int y)
    {
        return self.ptr->value->vRGBA64At(int x, int y);
    }

    color::RGBA64 RGBA64At(const gocpp::ObjRecv<RGBA64Image>& self, int x, int y)
    {
        return self.obj.value->vRGBA64At(int x, int y);
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64Image& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    PalettedImage::PalettedImage(T& ref)
    {
        value.reset(new PalettedImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    PalettedImage::PalettedImage(const T& ref)
    {
        value.reset(new PalettedImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    PalettedImage::PalettedImage(T* ptr)
    {
        value.reset(new PalettedImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& PalettedImage::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint8_t PalettedImage::PalettedImageImpl<T, StoreT>::vColorIndexAt(int x, int y)
    {
        return ColorIndexAt(gocpp::PtrRecv<T, false>(value.get()));
    }

    uint8_t ColorIndexAt(const gocpp::PtrRecv<PalettedImage, false>& self, int x, int y)
    {
        return self.ptr->value->vColorIndexAt(int x, int y);
    }

    uint8_t ColorIndexAt(const gocpp::ObjRecv<PalettedImage>& self, int x, int y)
    {
        return self.obj.value->vColorIndexAt(int x, int y);
    }

    std::ostream& operator<<(std::ostream& os, const struct PalettedImage& value)
    {
        return value.PrintTo(os);
    }

    int pixelBufferLength(int bytesPerPixel, Rectangle r, std::string imageTypeName)
    {
        auto totalLength = mul3NonNeg(bytesPerPixel, Dx(gocpp::recv(r)), Dy(gocpp::recv(r)));
        if(totalLength < 0)
        {
            gocpp::panic("image: New" + imageTypeName + " Rectangle has huge or negative dimensions");
        }
        return totalLength;
    }

    
    std::ostream& RGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct RGBA* p)
    {
        return color::RGBAModel;
    }

    Rectangle Bounds(struct RGBA* p)
    {
        return p->Rect;
    }

    color::Color At(struct RGBA* p, int x, int y)
    {
        return RGBAAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct RGBA* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA64 {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        auto r = uint16_t(s[0]);
        auto g = uint16_t(s[1]);
        auto b = uint16_t(s[2]);
        auto a = uint16_t(s[3]);
        return color::RGBA64 {(r << 8) | r, (g << 8) | g, (b << 8) | b, (a << 8) | a};
    }

    color::RGBA RGBAAt(struct RGBA* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::RGBA {s[0], s[1], s[2], s[3]};
    }

    int PixOffset(struct RGBA* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void Set(struct RGBA* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::RGBA>(Convert(gocpp::recv(color::RGBAModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.R;
        s[1] = c1.G;
        s[2] = c1.B;
        s[3] = c1.A;
    }

    void SetRGBA64(struct RGBA* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = uint8_t(c->R >> 8);
        s[1] = uint8_t(c->G >> 8);
        s[2] = uint8_t(c->B >> 8);
        s[3] = uint8_t(c->A >> 8);
    }

    void SetRGBA(struct RGBA* p, int x, int y, color::RGBA c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c->R;
        s[1] = c->G;
        s[2] = c->B;
        s[3] = c->A;
    }

    Image SubImage(struct RGBA* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new RGBA {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<RGBA>([](RGBA& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct RGBA* p)
    {
        if(Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{3, Dx(gocpp::recv(p->Rect)) * 4};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 4)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    RGBA* NewRGBA(Rectangle r)
    {
        return gocpp::InitPtr<RGBA>([](RGBA& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "RGBA")); x.Stride = 4 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& RGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct RGBA64* p)
    {
        return color::RGBA64Model;
    }

    Rectangle Bounds(struct RGBA64* p)
    {
        return p->Rect;
    }

    color::Color At(struct RGBA64* p, int x, int y)
    {
        return RGBA64At(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct RGBA64* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA64 {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        return color::RGBA64 {(uint16_t(s[0]) << 8) | uint16_t(s[1]), (uint16_t(s[2]) << 8) | uint16_t(s[3]), (uint16_t(s[4]) << 8) | uint16_t(s[5]), (uint16_t(s[6]) << 8) | uint16_t(s[7])};
    }

    int PixOffset(struct RGBA64* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 8;
    }

    void Set(struct RGBA64* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::RGBA64>(Convert(gocpp::recv(color::RGBA64Model), c));
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c1.R >> 8);
        s[1] = uint8_t(c1.R);
        s[2] = uint8_t(c1.G >> 8);
        s[3] = uint8_t(c1.G);
        s[4] = uint8_t(c1.B >> 8);
        s[5] = uint8_t(c1.B);
        s[6] = uint8_t(c1.A >> 8);
        s[7] = uint8_t(c1.A);
    }

    void SetRGBA64(struct RGBA64* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c->R >> 8);
        s[1] = uint8_t(c->R);
        s[2] = uint8_t(c->G >> 8);
        s[3] = uint8_t(c->G);
        s[4] = uint8_t(c->B >> 8);
        s[5] = uint8_t(c->B);
        s[6] = uint8_t(c->A >> 8);
        s[7] = uint8_t(c->A);
    }

    Image SubImage(struct RGBA64* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new RGBA64 {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<RGBA64>([](RGBA64& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct RGBA64* p)
    {
        if(Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{6, Dx(gocpp::recv(p->Rect)) * 8};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 8)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    RGBA64* NewRGBA64(Rectangle r)
    {
        return gocpp::InitPtr<RGBA64>([](RGBA64& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(8, r, "RGBA64")); x.Stride = 8 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& NRGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct NRGBA* p)
    {
        return color::NRGBAModel;
    }

    Rectangle Bounds(struct NRGBA* p)
    {
        return p->Rect;
    }

    color::Color At(struct NRGBA* p, int x, int y)
    {
        return NRGBAAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct NRGBA* p, int x, int y)
    {
        auto [r, g, b, a] = RGBA(gocpp::recv(NRGBAAt(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::NRGBA NRGBAAt(struct NRGBA* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::NRGBA {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::NRGBA {s[0], s[1], s[2], s[3]};
    }

    int PixOffset(struct NRGBA* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void Set(struct NRGBA* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::NRGBA>(Convert(gocpp::recv(color::NRGBAModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.R;
        s[1] = c1.G;
        s[2] = c1.B;
        s[3] = c1.A;
    }

    void SetRGBA64(struct NRGBA* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [r, g, b, a] = std::tuple{uint32_t(c->R), uint32_t(c->G), uint32_t(c->B), uint32_t(c->A)};
        if((a != 0) && (a != 0xffff))
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = uint8_t(r >> 8);
        s[1] = uint8_t(g >> 8);
        s[2] = uint8_t(b >> 8);
        s[3] = uint8_t(a >> 8);
    }

    void SetNRGBA(struct NRGBA* p, int x, int y, color::NRGBA c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c->R;
        s[1] = c->G;
        s[2] = c->B;
        s[3] = c->A;
    }

    Image SubImage(struct NRGBA* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new NRGBA {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<NRGBA>([](NRGBA& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct NRGBA* p)
    {
        if(Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{3, Dx(gocpp::recv(p->Rect)) * 4};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 4)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    NRGBA* NewNRGBA(Rectangle r)
    {
        return gocpp::InitPtr<NRGBA>([](NRGBA& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "NRGBA")); x.Stride = 4 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& NRGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct NRGBA64* p)
    {
        return color::NRGBA64Model;
    }

    Rectangle Bounds(struct NRGBA64* p)
    {
        return p->Rect;
    }

    color::Color At(struct NRGBA64* p, int x, int y)
    {
        return NRGBA64At(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct NRGBA64* p, int x, int y)
    {
        auto [r, g, b, a] = RGBA(gocpp::recv(NRGBA64At(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::NRGBA64 NRGBA64At(struct NRGBA64* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::NRGBA64 {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        return color::NRGBA64 {(uint16_t(s[0]) << 8) | uint16_t(s[1]), (uint16_t(s[2]) << 8) | uint16_t(s[3]), (uint16_t(s[4]) << 8) | uint16_t(s[5]), (uint16_t(s[6]) << 8) | uint16_t(s[7])};
    }

    int PixOffset(struct NRGBA64* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 8;
    }

    void Set(struct NRGBA64* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::NRGBA64>(Convert(gocpp::recv(color::NRGBA64Model), c));
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c1.R >> 8);
        s[1] = uint8_t(c1.R);
        s[2] = uint8_t(c1.G >> 8);
        s[3] = uint8_t(c1.G);
        s[4] = uint8_t(c1.B >> 8);
        s[5] = uint8_t(c1.B);
        s[6] = uint8_t(c1.A >> 8);
        s[7] = uint8_t(c1.A);
    }

    void SetRGBA64(struct NRGBA64* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [r, g, b, a] = std::tuple{uint32_t(c->R), uint32_t(c->G), uint32_t(c->B), uint32_t(c->A)};
        if((a != 0) && (a != 0xffff))
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(r >> 8);
        s[1] = uint8_t(r);
        s[2] = uint8_t(g >> 8);
        s[3] = uint8_t(g);
        s[4] = uint8_t(b >> 8);
        s[5] = uint8_t(b);
        s[6] = uint8_t(a >> 8);
        s[7] = uint8_t(a);
    }

    void SetNRGBA64(struct NRGBA64* p, int x, int y, color::NRGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c->R >> 8);
        s[1] = uint8_t(c->R);
        s[2] = uint8_t(c->G >> 8);
        s[3] = uint8_t(c->G);
        s[4] = uint8_t(c->B >> 8);
        s[5] = uint8_t(c->B);
        s[6] = uint8_t(c->A >> 8);
        s[7] = uint8_t(c->A);
    }

    Image SubImage(struct NRGBA64* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new NRGBA64 {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<NRGBA64>([](NRGBA64& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct NRGBA64* p)
    {
        if(Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{6, Dx(gocpp::recv(p->Rect)) * 8};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 8)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    NRGBA64* NewNRGBA64(Rectangle r)
    {
        return gocpp::InitPtr<NRGBA64>([](NRGBA64& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(8, r, "NRGBA64")); x.Stride = 8 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& Alpha::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct Alpha* p)
    {
        return color::AlphaModel;
    }

    Rectangle Bounds(struct Alpha* p)
    {
        return p->Rect;
    }

    color::Color At(struct Alpha* p, int x, int y)
    {
        return AlphaAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct Alpha* p, int x, int y)
    {
        auto a = uint16_t(AlphaAt(gocpp::recv(p), x, y).A);
        a |= a << 8;
        return color::RGBA64 {a, a, a, a};
    }

    color::Alpha AlphaAt(struct Alpha* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Alpha {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        return color::Alpha {p->Pix[i]};
    }

    int PixOffset(struct Alpha* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void Set(struct Alpha* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = gocpp::getValue<color::Alpha>(Convert(gocpp::recv(color::AlphaModel), c)).A;
    }

    void SetRGBA64(struct Alpha* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(c->A >> 8);
    }

    void SetAlpha(struct Alpha* p, int x, int y, color::Alpha c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = c->A;
    }

    Image SubImage(struct Alpha* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new Alpha {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Alpha>([](Alpha& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct Alpha* p)
    {
        if(Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{0, Dx(gocpp::recv(p->Rect))};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i++)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    Alpha* NewAlpha(Rectangle r)
    {
        return gocpp::InitPtr<Alpha>([](Alpha& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Alpha")); x.Stride = 1 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& Alpha16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct Alpha16* p)
    {
        return color::Alpha16Model;
    }

    Rectangle Bounds(struct Alpha16* p)
    {
        return p->Rect;
    }

    color::Color At(struct Alpha16* p, int x, int y)
    {
        return Alpha16At(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct Alpha16* p, int x, int y)
    {
        auto a = Alpha16At(gocpp::recv(p), x, y).A;
        return color::RGBA64 {a, a, a, a};
    }

    color::Alpha16 Alpha16At(struct Alpha16* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Alpha16 {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        return color::Alpha16 {(uint16_t(p->Pix[i + 0]) << 8) | uint16_t(p->Pix[i + 1])};
    }

    int PixOffset(struct Alpha16* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 2;
    }

    void Set(struct Alpha16* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::Alpha16>(Convert(gocpp::recv(color::Alpha16Model), c));
        p->Pix[i + 0] = uint8_t(c1.A >> 8);
        p->Pix[i + 1] = uint8_t(c1.A);
    }

    void SetRGBA64(struct Alpha16* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c->A >> 8);
        p->Pix[i + 1] = uint8_t(c->A);
    }

    void SetAlpha16(struct Alpha16* p, int x, int y, color::Alpha16 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c->A >> 8);
        p->Pix[i + 1] = uint8_t(c->A);
    }

    Image SubImage(struct Alpha16* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new Alpha16 {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Alpha16>([](Alpha16& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct Alpha16* p)
    {
        if(Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{0, Dx(gocpp::recv(p->Rect)) * 2};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 2)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    Alpha16* NewAlpha16(Rectangle r)
    {
        return gocpp::InitPtr<Alpha16>([](Alpha16& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(2, r, "Alpha16")); x.Stride = 2 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& Gray::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct Gray* p)
    {
        return color::GrayModel;
    }

    Rectangle Bounds(struct Gray* p)
    {
        return p->Rect;
    }

    color::Color At(struct Gray* p, int x, int y)
    {
        return GrayAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct Gray* p, int x, int y)
    {
        auto gray = uint16_t(GrayAt(gocpp::recv(p), x, y).Y);
        gray |= gray << 8;
        return color::RGBA64 {gray, gray, gray, 0xffff};
    }

    color::Gray GrayAt(struct Gray* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Gray {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        return color::Gray {p->Pix[i]};
    }

    int PixOffset(struct Gray* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void Set(struct Gray* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = gocpp::getValue<color::Gray>(Convert(gocpp::recv(color::GrayModel), c)).Y;
    }

    void SetRGBA64(struct Gray* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto gray = (19595 * uint32_t(c->R) + 38470 * uint32_t(c->G) + 7471 * uint32_t(c->B) + (1 << 15)) >> 24;
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(gray);
    }

    void SetGray(struct Gray* p, int x, int y, color::Gray c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = c->Y;
    }

    Image SubImage(struct Gray* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new Gray {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Gray>([](Gray& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct Gray* p)
    {
        return true;
    }

    Gray* NewGray(Rectangle r)
    {
        return gocpp::InitPtr<Gray>([](Gray& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Gray")); x.Stride = 1 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& Gray16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct Gray16* p)
    {
        return color::Gray16Model;
    }

    Rectangle Bounds(struct Gray16* p)
    {
        return p->Rect;
    }

    color::Color At(struct Gray16* p, int x, int y)
    {
        return Gray16At(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct Gray16* p, int x, int y)
    {
        auto gray = Gray16At(gocpp::recv(p), x, y).Y;
        return color::RGBA64 {gray, gray, gray, 0xffff};
    }

    color::Gray16 Gray16At(struct Gray16* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Gray16 {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        return color::Gray16 {(uint16_t(p->Pix[i + 0]) << 8) | uint16_t(p->Pix[i + 1])};
    }

    int PixOffset(struct Gray16* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 2;
    }

    void Set(struct Gray16* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::Gray16>(Convert(gocpp::recv(color::Gray16Model), c));
        p->Pix[i + 0] = uint8_t(c1.Y >> 8);
        p->Pix[i + 1] = uint8_t(c1.Y);
    }

    void SetRGBA64(struct Gray16* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto gray = (19595 * uint32_t(c->R) + 38470 * uint32_t(c->G) + 7471 * uint32_t(c->B) + (1 << 15)) >> 16;
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(gray >> 8);
        p->Pix[i + 1] = uint8_t(gray);
    }

    void SetGray16(struct Gray16* p, int x, int y, color::Gray16 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c->Y >> 8);
        p->Pix[i + 1] = uint8_t(c->Y);
    }

    Image SubImage(struct Gray16* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new Gray16 {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Gray16>([](Gray16& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct Gray16* p)
    {
        return true;
    }

    Gray16* NewGray16(Rectangle r)
    {
        return gocpp::InitPtr<Gray16>([](Gray16& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(2, r, "Gray16")); x.Stride = 2 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& CMYK::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct CMYK* p)
    {
        return color::CMYKModel;
    }

    Rectangle Bounds(struct CMYK* p)
    {
        return p->Rect;
    }

    color::Color At(struct CMYK* p, int x, int y)
    {
        return CMYKAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 RGBA64At(struct CMYK* p, int x, int y)
    {
        auto [r, g, b, a] = RGBA(gocpp::recv(CMYKAt(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::CMYK CMYKAt(struct CMYK* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::CMYK {};
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::CMYK {s[0], s[1], s[2], s[3]};
    }

    int PixOffset(struct CMYK* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void Set(struct CMYK* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::CMYK>(Convert(gocpp::recv(color::CMYKModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.C;
        s[1] = c1.M;
        s[2] = c1.Y;
        s[3] = c1.K;
    }

    void SetRGBA64(struct CMYK* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [cc, mm, yy, kk] = color::RGBToCMYK(uint8_t(c->R >> 8), uint8_t(c->G >> 8), uint8_t(c->B >> 8));
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = cc;
        s[1] = mm;
        s[2] = yy;
        s[3] = kk;
    }

    void SetCMYK(struct CMYK* p, int x, int y, color::CMYK c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c->C;
        s[1] = c->M;
        s[2] = c->Y;
        s[3] = c->K;
    }

    Image SubImage(struct CMYK* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return new CMYK {};
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<CMYK>([](CMYK& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = r; });
    }

    bool Opaque(struct CMYK* p)
    {
        return true;
    }

    CMYK* NewCMYK(Rectangle r)
    {
        return gocpp::InitPtr<CMYK>([](CMYK& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "CMYK")); x.Stride = 4 * Dx(gocpp::recv(r)); x.Rect = r; });
    }

    
    std::ostream& Paletted::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << " " << Palette;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Paletted& value)
    {
        return value.PrintTo(os);
    }

    color::Model ColorModel(struct Paletted* p)
    {
        return p->Palette;
    }

    Rectangle Bounds(struct Paletted* p)
    {
        return p->Rect;
    }

    color::Color At(struct Paletted* p, int x, int y)
    {
        if(len(p->Palette) == 0)
        {
            return nullptr;
        }
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return p->Palette[0];
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        return p->Palette[p->Pix[i]];
    }

    color::RGBA64 RGBA64At(struct Paletted* p, int x, int y)
    {
        if(len(p->Palette) == 0)
        {
            return color::RGBA64 {};
        }
        auto c = color::Color(nullptr);
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            c = p->Palette[0];
        }
        else
        {
            auto i = PixOffset(gocpp::recv(p), x, y);
            c = p->Palette[p->Pix[i]];
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    int PixOffset(struct Paletted* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void Set(struct Paletted* p, int x, int y, color::Color c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(Index(gocpp::recv(p->Palette), c));
    }

    void SetRGBA64(struct Paletted* p, int x, int y, color::RGBA64 c)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(Index(gocpp::recv(p->Palette), c));
    }

    uint8_t ColorIndexAt(struct Paletted* p, int x, int y)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return 0;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        return p->Pix[i];
    }

    void SetColorIndex(struct Paletted* p, int x, int y, uint8_t index)
    {
        if(! (In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = index;
    }

    Image SubImage(struct Paletted* p, Rectangle r)
    {
        r = Intersect(gocpp::recv(r), p->Rect);
        if(Empty(gocpp::recv(r)))
        {
            return gocpp::InitPtr<Paletted>([](Paletted& x) { x.Palette = p->Palette; });
        }
        auto i = PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Paletted>([](Paletted& x) { x.Pix = p->Pix.make_slice(i); x.Stride = p->Stride; x.Rect = Intersect(gocpp::recv(p->Rect), r); x.Palette = p->Palette; });
    }

    bool Opaque(struct Paletted* p)
    {
        gocpp::array<bool, 256> present = {};
        auto [i0, i1] = std::tuple{0, Dx(gocpp::recv(p->Rect))};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto [_, c] : p->Pix.make_slice(i0, i1))
            {
                present[c] = true;
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        for(auto [i, c] : p->Palette)
        {
            if(! present[i])
            {
                continue;
            }
            uint32_t _;
            uint32_t _;
            uint32_t _;
            uint32_t a;
            std::tie(_, _, _, a) = RGBA(gocpp::recv(c));
            if(a != 0xffff)
            {
                return false;
            }
        }
        return true;
    }

    Paletted* NewPaletted(Rectangle r, color::Palette p)
    {
        return gocpp::InitPtr<Paletted>([](Paletted& x) { x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Paletted")); x.Stride = 1 * Dx(gocpp::recv(r)); x.Rect = r; x.Palette = p; });
    }

}

