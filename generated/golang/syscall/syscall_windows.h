// generated by GoCpp from file '$(ImportDir)/syscall/syscall_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/syscall_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/types_windows.h"

namespace golang::syscall
{
    gocpp::slice<uint16_t> StringToUTF16(std::string s);
    std::tuple<gocpp::slice<uint16_t>, gocpp::error> UTF16FromString(std::string s);
    std::string UTF16ToString(gocpp::slice<uint16_t> s);
    std::string utf16PtrToString(uint16_t* p);
    uint16_t* StringToUTF16Ptr(std::string s);
    std::tuple<uint16_t*, gocpp::error> UTF16PtrFromString(std::string s);
    uint32_t langid(uint16_t pri, uint16_t sub);
    std::tuple<uint32_t, gocpp::error> FormatMessage(uint32_t flags, uint32_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args);
    std::string Error(Errno e);
    bool Is(Errno e, gocpp::error target);
    bool Temporary(Errno e);
    bool Timeout(Errno e);
    uintptr_t compileCallback(go_any fn, bool cleanstack);
    uintptr_t NewCallback(go_any fn);
    uintptr_t NewCallbackCDecl(go_any fn);
    SecurityAttributes* makeInheritSa();
    std::tuple<Handle, gocpp::error> Open(std::string path, int mode, uint32_t perm);
    std::tuple<int, gocpp::error> Read(Handle fd, gocpp::slice<unsigned char> p);
    std::tuple<int, gocpp::error> Write(Handle fd, gocpp::slice<unsigned char> p);
    gocpp::error ReadFile(Handle fd, gocpp::slice<unsigned char> p, uint32_t* done, Overlapped* overlapped);
    gocpp::error WriteFile(Handle fd, gocpp::slice<unsigned char> p, uint32_t* done, Overlapped* overlapped);
    extern LazyProc* procSetFilePointerEx;
    gocpp::error setFilePointerEx(Handle handle, int64_t distToMove, int64_t* newFilePointer, uint32_t whence);
    std::tuple<int64_t, gocpp::error> Seek(Handle fd, int64_t offset, int whence);
    gocpp::error Close(Handle fd);
    extern Handle Stdin;
    extern Handle Stdout;
    extern Handle Stderr;
    Handle getStdHandle(int h);
    std::tuple<std::string, gocpp::error> Getwd();
    gocpp::error Chdir(std::string path);
    gocpp::error Mkdir(std::string path, uint32_t mode);
    gocpp::error Rmdir(std::string path);
    gocpp::error Unlink(std::string path);
    gocpp::error Rename(std::string oldpath, std::string newpath);
    std::tuple<std::string, gocpp::error> ComputerName();
    gocpp::error Ftruncate(Handle fd, int64_t length);
    gocpp::error Gettimeofday(Timeval* tv);
    gocpp::error Pipe(gocpp::slice<Handle> p);
    gocpp::error Utimes(std::string path, gocpp::slice<Timeval> tv);
    gocpp::error UtimesNano(std::string path, gocpp::slice<Timespec> ts);
    gocpp::error Fsync(Handle fd);
    gocpp::error Chmod(std::string path, uint32_t mode);
    gocpp::error LoadCancelIoEx();
    gocpp::error LoadSetFileCompletionNotificationModes();
    struct RawSockaddrInet4
    {
        uint16_t Family;
        uint16_t Port;
        gocpp::array<unsigned char, 4> Addr;
        gocpp::array<uint8_t, 8> Zero;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrInet4& value);
    struct RawSockaddrInet6
    {
        uint16_t Family;
        uint16_t Port;
        uint32_t Flowinfo;
        gocpp::array<unsigned char, 16> Addr;
        uint32_t Scope_id;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrInet6& value);
    struct RawSockaddr
    {
        uint16_t Family;
        gocpp::array<int8_t, 14> Data;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddr& value);
    struct RawSockaddrAny
    {
        RawSockaddr Addr;
        gocpp::array<int8_t, 100> Pad;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrAny& value);
    struct Sockaddr : gocpp::Interface
    {
        Sockaddr(){}
        Sockaddr(Sockaddr& i) = default;
        Sockaddr(const Sockaddr& i) = default;
        Sockaddr& operator=(Sockaddr& i) = default;
        Sockaddr& operator=(const Sockaddr& i) = default;

        template<typename T>
        Sockaddr(T& ref);

        template<typename T>
        Sockaddr(const T& ref);

        template<typename T>
        Sockaddr(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct ISockaddr
        {
            virtual std::tuple<unsafe::Pointer, int32_t, gocpp::error> vsockaddr() = 0;
        };

        template<typename T, typename StoreT>
        struct SockaddrImpl : ISockaddr
        {
            explicit SockaddrImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<unsafe::Pointer, int32_t, gocpp::error> vsockaddr() override;

            StoreT value;
        };

        std::shared_ptr<ISockaddr> value;
    };

    std::tuple<unsafe::Pointer, int32_t, gocpp::error> sockaddr(const gocpp::PtrRecv<Sockaddr, false>& self);
    std::tuple<unsafe::Pointer, int32_t, gocpp::error> sockaddr(const gocpp::ObjRecv<Sockaddr>& self);

    std::ostream& operator<<(std::ostream& os, const struct Sockaddr& value);
    struct SockaddrInet4
    {
        int Port;
        gocpp::array<unsigned char, 4> Addr;
        RawSockaddrInet4 raw;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SockaddrInet4& value);
    std::tuple<unsafe::Pointer, int32_t, gocpp::error> sockaddr(struct SockaddrInet4* sa);
    struct SockaddrInet6
    {
        int Port;
        uint32_t ZoneId;
        gocpp::array<unsigned char, 16> Addr;
        RawSockaddrInet6 raw;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SockaddrInet6& value);
    std::tuple<unsafe::Pointer, int32_t, gocpp::error> sockaddr(struct SockaddrInet6* sa);
    struct RawSockaddrUnix
    {
        uint16_t Family;
        gocpp::array<int8_t, UNIX_PATH_MAX> Path;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct RawSockaddrUnix& value);
    struct SockaddrUnix
    {
        std::string Name;
        RawSockaddrUnix raw;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SockaddrUnix& value);
    std::tuple<unsafe::Pointer, int32_t, gocpp::error> sockaddr(struct SockaddrUnix* sa);
    std::tuple<Sockaddr, gocpp::error> Sockaddr(struct RawSockaddrAny* rsa);
    std::tuple<Handle, gocpp::error> Socket(int domain, int typ, int proto);
    gocpp::error SetsockoptInt(Handle fd, int level, int opt, int value);
    gocpp::error Bind(Handle fd, Sockaddr sa);
    gocpp::error Connect(Handle fd, Sockaddr sa);
    std::tuple<Sockaddr, gocpp::error> Getsockname(Handle fd);
    std::tuple<Sockaddr, gocpp::error> Getpeername(Handle fd);
    gocpp::error Listen(Handle s, int n);
    gocpp::error Shutdown(Handle fd, int how);
    gocpp::error WSASendto(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, Sockaddr to, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error wsaSendtoInet4(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, SockaddrInet4* to, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error wsaSendtoInet6(Handle s, WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, SockaddrInet6* to, Overlapped* overlapped, unsigned char* croutine);
    gocpp::error LoadGetAddrInfo();
    gocpp::error LoadConnectEx();
    gocpp::error connectEx(Handle s, unsafe::Pointer name, int32_t namelen, unsigned char* sendBuf, uint32_t sendDataLen, uint32_t* bytesSent, Overlapped* overlapped);
    gocpp::error ConnectEx(Handle fd, Sockaddr sa, unsigned char* sendBuf, uint32_t sendDataLen, uint32_t* bytesSent, Overlapped* overlapped);
    struct Rusage
    {
        Filetime CreationTime;
        Filetime ExitTime;
        Filetime KernelTime;
        Filetime UserTime;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Rusage& value);
    struct WaitStatus
    {
        uint32_t ExitCode;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct WaitStatus& value);
    bool Exited(struct WaitStatus w);
    int ExitStatus(struct WaitStatus w);
    Signal Signal(struct WaitStatus w);
    bool CoreDump(struct WaitStatus w);
    bool Stopped(struct WaitStatus w);
    bool Continued(struct WaitStatus w);
    Signal StopSignal(struct WaitStatus w);
    bool Signaled(struct WaitStatus w);
    int TrapCause(struct WaitStatus w);
    struct Timespec
    {
        int64_t Sec;
        int64_t Nsec;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Timespec& value);
    int64_t TimespecToNsec(Timespec ts);
    Timespec NsecToTimespec(int64_t nsec);
    std::tuple<Handle, Sockaddr, gocpp::error> Accept(Handle fd);
    std::tuple<int, Sockaddr, gocpp::error> Recvfrom(Handle fd, gocpp::slice<unsigned char> p, int flags);
    gocpp::error Sendto(Handle fd, gocpp::slice<unsigned char> p, int flags, Sockaddr to);
    gocpp::error SetsockoptTimeval(Handle fd, int level, int opt, Timeval* tv);
    struct Linger
    {
        int32_t Onoff;
        int32_t Linger;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Linger& value);
    struct sysLinger
    {
        uint16_t Onoff;
        uint16_t Linger;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sysLinger& value);
    struct IPMreq
    {
        gocpp::array<unsigned char, 4> Multiaddr;
        gocpp::array<unsigned char, 4> Interface;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct IPMreq& value);
    struct IPv6Mreq
    {
        gocpp::array<unsigned char, 16> Multiaddr;
        uint32_t Interface;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct IPv6Mreq& value);
    std::tuple<int, gocpp::error> GetsockoptInt(Handle fd, int level, int opt);
    gocpp::error SetsockoptLinger(Handle fd, int level, int opt, Linger* l);
    gocpp::error SetsockoptInet4Addr(Handle fd, int level, int opt, gocpp::array<unsigned char, 4> value);
    gocpp::error SetsockoptIPMreq(Handle fd, int level, int opt, IPMreq* mreq);
    gocpp::error SetsockoptIPv6Mreq(Handle fd, int level, int opt, IPv6Mreq* mreq);
    int Getpid();
    std::tuple<Handle, gocpp::error> FindFirstFile(uint16_t* name, Win32finddata* data);
    gocpp::error FindNextFile(Handle handle, Win32finddata* data);
    std::tuple<ProcessEntry32*, gocpp::error> getProcessEntry(int pid);
    int Getppid();
    std::tuple<gocpp::slice<uint16_t>, gocpp::error> fdpath(Handle fd, gocpp::slice<uint16_t> buf);
    gocpp::error Fchdir(Handle fd);
    gocpp::error Link(std::string oldpath, std::string newpath);
    gocpp::error Symlink(std::string path, std::string link);
    gocpp::error Fchmod(Handle fd, uint32_t mode);
    gocpp::error Chown(std::string path, int uid, int gid);
    gocpp::error Lchown(std::string path, int uid, int gid);
    gocpp::error Fchown(Handle fd, int uid, int gid);
    int Getuid();
    int Geteuid();
    int Getgid();
    int Getegid();
    std::tuple<gocpp::slice<int>, gocpp::error> Getgroups();
    void Signal(Signal s);
    std::string String(Signal s);
    gocpp::error LoadCreateSymbolicLink();
    std::tuple<int, gocpp::error> Readlink(std::string path, gocpp::slice<unsigned char> buf);
    std::tuple<Handle, gocpp::error> CreateIoCompletionPort(Handle filehandle, Handle cphandle, uint32_t key, uint32_t threadcnt);
    gocpp::error GetQueuedCompletionStatus(Handle cphandle, uint32_t* qty, uint32_t* key, Overlapped** overlapped, uint32_t timeout);
    gocpp::error PostQueuedCompletionStatus(Handle cphandle, uint32_t qty, uint32_t key, Overlapped* overlapped);
    std::tuple<_PROC_THREAD_ATTRIBUTE_LIST*, gocpp::error> newProcThreadAttributeList(uint32_t maxAttrCount);
    gocpp::error RegEnumKeyEx(Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, Filetime* lastWriteTime);
    gocpp::error GetStartupInfo(StartupInfo* startupInfo);
}

