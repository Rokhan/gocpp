// generated by GoCpp from file '$(ImportDir)/compress/flate/deflatefast.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/deflatefast.h"
#include "gocpp/support.h"

#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/token.h"
#include "golang/math/const.h"

namespace golang::flate
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Reset the buffer offset when reaching this.
    // Offsets are stored between blocks as int32 values.
    // Since the offset we are checking against is at the beginning
    // of the buffer, we need to subtract the current and input
    // buffer to not risk overflowing the int32.
    uint32_t load32(gocpp::slice<unsigned char> b, int32_t i)
    {
        b = b.make_slice(i, i + 4, len(b));
        return uint32_t(b[0]) | (uint32_t(b[1]) << 8) | (uint32_t(b[2]) << 16) | (uint32_t(b[3]) << 24);
    }

    uint64_t load64(gocpp::slice<unsigned char> b, int32_t i)
    {
        b = b.make_slice(i, i + 8, len(b));
        return uint64_t(b[0]) | (uint64_t(b[1]) << 8) | (uint64_t(b[2]) << 16) | (uint64_t(b[3]) << 24) | (uint64_t(b[4]) << 32) | (uint64_t(b[5]) << 40) | (uint64_t(b[6]) << 48) | (uint64_t(b[7]) << 56);
    }

    uint32_t hash(uint32_t u)
    {
        return (u * 0x1e35a7bd) >> tableShift;
    }

    // These constants are defined by the Snappy implementation so that its
    // assembly implementation can fast-path some 16-bytes-at-a-time copies. They
    // aren't necessary in the pure Go implementation, as we don't use those same
    // optimizations, but using the same thresholds doesn't really hurt.
    
    template<typename T> requires gocpp::GoStruct<T>
    tableEntry::operator T()
    {
        T result;
        result.val = this->val;
        result.offset = this->offset;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool tableEntry::operator==(const T& ref) const
    {
        if (val != ref.val) return false;
        if (offset != ref.offset) return false;
        return true;
    }

    std::ostream& tableEntry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << val;
        os << " " << offset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct tableEntry& value)
    {
        return value.PrintTo(os);
    }

    // deflateFast maintains the table for matches,
    // and the previous byte block for cross block matching.
    
    template<typename T> requires gocpp::GoStruct<T>
    deflateFast::operator T()
    {
        T result;
        result.table = this->table;
        result.prev = this->prev;
        result.cur = this->cur;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool deflateFast::operator==(const T& ref) const
    {
        if (table != ref.table) return false;
        if (prev != ref.prev) return false;
        if (cur != ref.cur) return false;
        return true;
    }

    std::ostream& deflateFast::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << table;
        os << " " << prev;
        os << " " << cur;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct deflateFast& value)
    {
        return value.PrintTo(os);
    }

    struct deflateFast* newDeflateFast()
    {
        return gocpp::InitPtr<deflateFast>([=](auto& x) {
            x.cur = maxStoreBlockSize;
            x.prev = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, maxStoreBlockSize);
        });
    }

    // encode encodes a block given in src and appends tokens
    // to dst and returns the result.
    gocpp::slice<flate::token> rec::encode(struct deflateFast* e, gocpp::slice<golang::flate::token> dst, gocpp::slice<unsigned char> src)
    {
        if(e->cur >= bufferReset)
        {
            rec::shiftOffsets(gocpp::recv(e));
        }
        if(len(src) < minNonLiteralBlockSize)
        {
            e->cur += maxStoreBlockSize;
            e->prev = e->prev.make_slice(0, 0);
            return emitLiteral(dst, src);
        }
        auto sLimit = int32_t(len(src) - inputMargin);
        auto nextEmit = int32_t(0);
        auto s = int32_t(0);
        auto cv = load32(src, s);
        auto nextHash = hash(cv);
        for(; ; )
        {
            auto skip = int32_t(32);
            auto nextS = s;
            tableEntry candidate = {};
            for(; ; )
            {
                s = nextS;
                auto bytesBetweenHashLookups = skip >> 5;
                nextS = s + bytesBetweenHashLookups;
                skip += bytesBetweenHashLookups;
                if(nextS > sLimit)
                {
                    goto emitRemainder;
                }
                candidate = e->table[nextHash & tableMask];
                auto now = load32(src, nextS);
                e->table[nextHash & tableMask] = gocpp::Init<tableEntry>([=](auto& x) {
                    x.offset = s + e->cur;
                    x.val = cv;
                });
                nextHash = hash(now);
                auto offset = s - (candidate.offset - e->cur);
                if(offset > maxMatchOffset || cv != candidate.val)
                {
                    cv = now;
                    continue;
                }
                break;
            }
            dst = emitLiteral(dst, src.make_slice(nextEmit, s));
            for(; ; )
            {
                s += 4;
                auto t = candidate.offset - e->cur + 4;
                auto l = rec::matchLen(gocpp::recv(e), s, t, src);
                dst = append(dst, matchToken(uint32_t(l + 4 - baseMatchLength), uint32_t(s - t - baseMatchOffset)));
                s += l;
                nextEmit = s;
                if(s >= sLimit)
                {
                    goto emitRemainder;
                }
                auto x = load64(src, s - 1);
                auto prevHash = hash(uint32_t(x));
                e->table[prevHash & tableMask] = gocpp::Init<tableEntry>([=](auto& x) {
                    x.offset = e->cur + s - 1;
                    x.val = uint32_t(x);
                });
                x >>= 8;
                auto currHash = hash(uint32_t(x));
                candidate = e->table[currHash & tableMask];
                e->table[currHash & tableMask] = gocpp::Init<tableEntry>([=](auto& x) {
                    x.offset = e->cur + s;
                    x.val = uint32_t(x);
                });
                auto offset = s - (candidate.offset - e->cur);
                if(offset > maxMatchOffset || uint32_t(x) != candidate.val)
                {
                    cv = uint32_t(x >> 8);
                    nextHash = hash(cv);
                    s++;
                    break;
                }
            }
        }
        emitRemainder:
        if(int(nextEmit) < len(src))
        {
            dst = emitLiteral(dst, src.make_slice(nextEmit));
        }
        e->cur += int32_t(len(src));
        e->prev = e->prev.make_slice(0, len(src));
        copy(e->prev, src);
        return dst;
    }

    gocpp::slice<flate::token> emitLiteral(gocpp::slice<golang::flate::token> dst, gocpp::slice<unsigned char> lit)
    {
        for(auto [gocpp_ignored, v] : lit)
        {
            dst = append(dst, literalToken(uint32_t(v)));
        }
        return dst;
    }

    // matchLen returns the match length between src[s:] and src[t:].
    // t can be negative to indicate the match is starting in e.prev.
    // We assume that src[s-4:s] and src[t-4:t] already match.
    int32_t rec::matchLen(struct deflateFast* e, int32_t s, int32_t t, gocpp::slice<unsigned char> src)
    {
        auto s1 = int(s) + maxMatchLength - 4;
        if(s1 > len(src))
        {
            s1 = len(src);
        }
        if(t >= 0)
        {
            auto b = src.make_slice(t);
            auto a = src.make_slice(s, s1);
            b = b.make_slice(0, len(a));
            for(auto [i, gocpp_ignored] : a)
            {
                if(a[i] != b[i])
                {
                    return int32_t(i);
                }
            }
            return int32_t(len(a));
        }
        auto tp = int32_t(len(e->prev)) + t;
        if(tp < 0)
        {
            return 0;
        }
        auto a = src.make_slice(s, s1);
        auto b = e->prev.make_slice(tp);
        if(len(b) > len(a))
        {
            b = b.make_slice(0, len(a));
        }
        a = a.make_slice(0, len(b));
        for(auto [i, gocpp_ignored] : b)
        {
            if(a[i] != b[i])
            {
                return int32_t(i);
            }
        }
        auto n = int32_t(len(b));
        if(int(s + n) == s1)
        {
            return n;
        }
        a = src.make_slice(s + n, s1);
        b = src.make_slice(0, len(a));
        for(auto [i, gocpp_ignored] : a)
        {
            if(a[i] != b[i])
            {
                return int32_t(i) + n;
            }
        }
        return int32_t(len(a)) + n;
    }

    // Reset resets the encoding history.
    // This ensures that no matches are made to the previous block.
    void rec::reset(struct deflateFast* e)
    {
        e->prev = e->prev.make_slice(0, 0);
        e->cur += maxMatchOffset;
        if(e->cur >= bufferReset)
        {
            rec::shiftOffsets(gocpp::recv(e));
        }
    }

    // shiftOffsets will shift down all match offset.
    // This is only called in rare situations to prevent integer overflow.
    //
    // See https://golang.org/issue/18636 and https://github.com/golang/go/issues/34121.
    void rec::shiftOffsets(struct deflateFast* e)
    {
        if(len(e->prev) == 0)
        {
            for(auto [i, gocpp_ignored] : e->table.make_slice(0))
            {
                e->table[i] = tableEntry {};
            }
            e->cur = maxMatchOffset + 1;
            return;
        }
        for(auto [i, gocpp_ignored] : e->table.make_slice(0))
        {
            auto v = e->table[i].offset - e->cur + maxMatchOffset + 1;
            if(v < 0)
            {
                v = 0;
            }
            e->table[i].offset = v;
        }
        e->cur = maxMatchOffset + 1;
    }

}

