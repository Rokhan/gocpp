// generated by GoCpp from file '$(ImportDir)/compress/flate/dict_decoder.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/dict_decoder.h"
#include "gocpp/support.h"

namespace golang::flate
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // dictDecoder implements the LZ77 sliding dictionary as used in decompression.
    // LZ77 decompresses data through sequences of two forms of commands:
    //
    //   - Literal insertions: Runs of one or more symbols are inserted into the data
    //     stream as is. This is accomplished through the writeByte method for a
    //     single symbol, or combinations of writeSlice/writeMark for multiple symbols.
    //     Any valid stream must start with a literal insertion if no preset dictionary
    //     is used.
    //
    //   - Backward copies: Runs of one or more symbols are copied from previously
    //     emitted data. Backward copies come as the tuple (dist, length) where dist
    //     determines how far back in the stream to copy from and length determines how
    //     many bytes to copy. Note that it is valid for the length to be greater than
    //     the distance. Since LZ77 uses forward copies, that situation is used to
    //     perform a form of run-length encoding on repeated runs of symbols.
    //     The writeCopy and tryWriteCopy are used to implement this command.
    //
    // For performance reasons, this implementation performs little to no sanity
    // checks about the arguments. As such, the invariants documented for each
    // method call must be respected.
    
    template<typename T> requires gocpp::GoStruct<T>
    dictDecoder::operator T()
    {
        T result;
        result.hist = this->hist;
        result.wrPos = this->wrPos;
        result.rdPos = this->rdPos;
        result.full = this->full;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dictDecoder::operator==(const T& ref) const
    {
        if (hist != ref.hist) return false;
        if (wrPos != ref.wrPos) return false;
        if (rdPos != ref.rdPos) return false;
        if (full != ref.full) return false;
        return true;
    }

    std::ostream& dictDecoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << hist;
        os << " " << wrPos;
        os << " " << rdPos;
        os << " " << full;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dictDecoder& value)
    {
        return value.PrintTo(os);
    }

    // init initializes dictDecoder to have a sliding window dictionary of the given
    // size. If a preset dict is provided, it will initialize the dictionary with
    // the contents of dict.
    void rec::init(struct dictDecoder* dd, int size, gocpp::slice<unsigned char> dict)
    {
        *dd = gocpp::Init<dictDecoder>([=](auto& x) {
            x.hist = dd->hist;
        });
        if(cap(dd->hist) < size)
        {
            dd->hist = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        }
        dd->hist = dd->hist.make_slice(0, size);
        if(len(dict) > len(dd->hist))
        {
            dict = dict.make_slice(len(dict) - len(dd->hist));
        }
        dd->wrPos = copy(dd->hist, dict);
        if(dd->wrPos == len(dd->hist))
        {
            dd->wrPos = 0;
            dd->full = true;
        }
        dd->rdPos = dd->wrPos;
    }

    // histSize reports the total amount of historical data in the dictionary.
    int rec::histSize(struct dictDecoder* dd)
    {
        if(dd->full)
        {
            return len(dd->hist);
        }
        return dd->wrPos;
    }

    // availRead reports the number of bytes that can be flushed by readFlush.
    int rec::availRead(struct dictDecoder* dd)
    {
        return dd->wrPos - dd->rdPos;
    }

    // availWrite reports the available amount of output buffer space.
    int rec::availWrite(struct dictDecoder* dd)
    {
        return len(dd->hist) - dd->wrPos;
    }

    // writeSlice returns a slice of the available buffer to write data to.
    //
    // This invariant will be kept: len(s) <= availWrite()
    gocpp::slice<unsigned char> rec::writeSlice(struct dictDecoder* dd)
    {
        return dd->hist.make_slice(dd->wrPos);
    }

    // writeMark advances the writer pointer by cnt.
    //
    // This invariant must be kept: 0 <= cnt <= availWrite()
    void rec::writeMark(struct dictDecoder* dd, int cnt)
    {
        dd->wrPos += cnt;
    }

    // writeByte writes a single byte to the dictionary.
    //
    // This invariant must be kept: 0 < availWrite()
    void rec::writeByte(struct dictDecoder* dd, unsigned char c)
    {
        dd->hist[dd->wrPos] = c;
        dd->wrPos++;
    }

    // writeCopy copies a string at a given (dist, length) to the output.
    // This returns the number of bytes copied and may be less than the requested
    // length if the available space in the output buffer is too small.
    //
    // This invariant must be kept: 0 < dist <= histSize()
    int rec::writeCopy(struct dictDecoder* dd, int dist, int length)
    {
        auto dstBase = dd->wrPos;
        auto dstPos = dstBase;
        auto srcPos = dstPos - dist;
        auto endPos = dstPos + length;
        if(endPos > len(dd->hist))
        {
            endPos = len(dd->hist);
        }
        if(srcPos < 0)
        {
            srcPos += len(dd->hist);
            dstPos += copy(dd->hist.make_slice(dstPos, endPos), dd->hist.make_slice(srcPos));
            srcPos = 0;
        }
        for(; dstPos < endPos; )
        {
            dstPos += copy(dd->hist.make_slice(dstPos, endPos), dd->hist.make_slice(srcPos, dstPos));
        }
        dd->wrPos = dstPos;
        return dstPos - dstBase;
    }

    // tryWriteCopy tries to copy a string at a given (distance, length) to the
    // output. This specialized version is optimized for short distances.
    //
    // This method is designed to be inlined for performance reasons.
    //
    // This invariant must be kept: 0 < dist <= histSize()
    int rec::tryWriteCopy(struct dictDecoder* dd, int dist, int length)
    {
        auto dstPos = dd->wrPos;
        auto endPos = dstPos + length;
        if(dstPos < dist || endPos > len(dd->hist))
        {
            return 0;
        }
        auto dstBase = dstPos;
        auto srcPos = dstPos - dist;
        for(; dstPos < endPos; )
        {
            dstPos += copy(dd->hist.make_slice(dstPos, endPos), dd->hist.make_slice(srcPos, dstPos));
        }
        dd->wrPos = dstPos;
        return dstPos - dstBase;
    }

    // readFlush returns a slice of the historical buffer that is ready to be
    // emitted to the user. The data returned by readFlush must be fully consumed
    // before calling any other dictDecoder methods.
    gocpp::slice<unsigned char> rec::readFlush(struct dictDecoder* dd)
    {
        auto toRead = dd->hist.make_slice(dd->rdPos, dd->wrPos);
        dd->rdPos = dd->wrPos;
        if(dd->wrPos == len(dd->hist))
        {
            std::tie(dd->wrPos, dd->rdPos) = std::tuple{0, 0};
            dd->full = true;
        }
        return toRead;
    }

}

