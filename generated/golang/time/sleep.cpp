// generated by GoCpp from file '$(ImportDir)/time/sleep.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/sleep.h"
#include "gocpp/support.h"

#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Sleep pauses the current goroutine for at least the duration d.
    // A negative or zero duration causes Sleep to return immediately.
    void Sleep(golang::time::Duration d)
    /* convertBlockStmt, nil block */;

    // Interface to timers implemented in package runtime.
    // Must be in sync with ../runtime/time.go:/^type timer
    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeTimer::operator T()
    {
        T result;
        result.pp = this->pp;
        result.when = this->when;
        result.period = this->period;
        result.f = this->f;
        result.arg = this->arg;
        result.seq = this->seq;
        result.nextwhen = this->nextwhen;
        result.status = this->status;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeTimer::operator==(const T& ref) const
    {
        if (pp != ref.pp) return false;
        if (when != ref.when) return false;
        if (period != ref.period) return false;
        if (f != ref.f) return false;
        if (arg != ref.arg) return false;
        if (seq != ref.seq) return false;
        if (nextwhen != ref.nextwhen) return false;
        if (status != ref.status) return false;
        return true;
    }

    std::ostream& runtimeTimer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pp;
        os << " " << when;
        os << " " << period;
        os << " " << f;
        os << " " << arg;
        os << " " << seq;
        os << " " << nextwhen;
        os << " " << status;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeTimer& value)
    {
        return value.PrintTo(os);
    }

    // when is a helper function for setting the 'when' field of a runtimeTimer.
    // It returns what the time will be, in nanoseconds, Duration d in the future.
    // If d is negative, it is ignored. If the returned value would be less than
    // zero because of an overflow, MaxInt64 is returned.
    int64_t when(golang::time::Duration d)
    {
        if(d <= 0)
        {
            return runtimeNano();
        }
        auto t = runtimeNano() + int64_t(d);
        if(t < 0)
        {
            t = (1 << 63) - 1;
        }
        return t;
    }

    void startTimer(runtimeTimer*)
    /* convertBlockStmt, nil block */;

    bool stopTimer(runtimeTimer*)
    /* convertBlockStmt, nil block */;

    bool resetTimer(runtimeTimer*, int64_t)
    /* convertBlockStmt, nil block */;

    void modTimer(struct runtimeTimer* t, int64_t when, int64_t period, std::function<void (go_any _1, uintptr_t _2)> f, go_any arg, uintptr_t seq)
    /* convertBlockStmt, nil block */;

    // The Timer type represents a single event.
    // When the Timer expires, the current time will be sent on C,
    // unless the Timer was created by AfterFunc.
    // A Timer must be created with NewTimer or AfterFunc.
    
    template<typename T> requires gocpp::GoStruct<T>
    Timer::operator T()
    {
        T result;
        result.C = this->C;
        result.r = this->r;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Timer::operator==(const T& ref) const
    {
        if (C != ref.C) return false;
        if (r != ref.r) return false;
        return true;
    }

    std::ostream& Timer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << C;
        os << " " << r;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Timer& value)
    {
        return value.PrintTo(os);
    }

    // Stop prevents the Timer from firing.
    // It returns true if the call stops the timer, false if the timer has already
    // expired or been stopped.
    // Stop does not close the channel, to prevent a read from the channel succeeding
    // incorrectly.
    //
    // To ensure the channel is empty after a call to Stop, check the
    // return value and drain the channel.
    // For example, assuming the program has not received from t.C already:
    //
    //	if !t.Stop() {
    //		<-t.C
    //	}
    //
    // This cannot be done concurrent to other receives from the Timer's
    // channel or other calls to the Timer's Stop method.
    //
    // For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer
    // has already expired and the function f has been started in its own goroutine;
    // Stop does not wait for f to complete before returning.
    // If the caller needs to know whether f is completed, it must coordinate
    // with f explicitly.
    bool rec::Stop(struct Timer* t)
    {
        if(t->r.f == nullptr)
        {
            gocpp::panic("time: Stop called on uninitialized Timer"_s);
        }
        return stopTimer(& t->r);
    }

    // NewTimer creates a new Timer that will send
    // the current time on its channel after at least duration d.
    struct Timer* NewTimer(golang::time::Duration d)
    {
        auto c = gocpp::make(gocpp::Tag<gocpp::channel<Time>>(), 1);
        auto t = gocpp::InitPtr<Timer>([=](auto& x) {
            x.C = c;
            x.r = gocpp::Init<runtimeTimer>([=](auto& x) {
                x.when = when(d);
                x.f = sendTime;
                x.arg = c;
            });
        });
        startTimer(& t->r);
        return t;
    }

    // Reset changes the timer to expire after duration d.
    // It returns true if the timer had been active, false if the timer had
    // expired or been stopped.
    //
    // For a Timer created with NewTimer, Reset should be invoked only on
    // stopped or expired timers with drained channels.
    //
    // If a program has already received a value from t.C, the timer is known
    // to have expired and the channel drained, so t.Reset can be used directly.
    // If a program has not yet received a value from t.C, however,
    // the timer must be stopped and—if Stop reports that the timer expired
    // before being stopped—the channel explicitly drained:
    //
    //	if !t.Stop() {
    //		<-t.C
    //	}
    //	t.Reset(d)
    //
    // This should not be done concurrent to other receives from the Timer's
    // channel.
    //
    // Note that it is not possible to use Reset's return value correctly, as there
    // is a race condition between draining the channel and the new timer expiring.
    // Reset should always be invoked on stopped or expired channels, as described above.
    // The return value exists to preserve compatibility with existing programs.
    //
    // For a Timer created with AfterFunc(d, f), Reset either reschedules
    // when f will run, in which case Reset returns true, or schedules f
    // to run again, in which case it returns false.
    // When Reset returns false, Reset neither waits for the prior f to
    // complete before returning nor does it guarantee that the subsequent
    // goroutine running f does not run concurrently with the prior
    // one. If the caller needs to know whether the prior execution of
    // f is completed, it must coordinate with f explicitly.
    bool rec::Reset(struct Timer* t, golang::time::Duration d)
    {
        if(t->r.f == nullptr)
        {
            gocpp::panic("time: Reset called on uninitialized Timer"_s);
        }
        auto w = when(d);
        return resetTimer(& t->r, w);
    }

    // sendTime does a non-blocking send of the current time on c.
    void sendTime(go_any c, uintptr_t seq)
    {
        //Go select emulation
        {
            int conditionId = -1;
            if(gocpp::getValue<gocpp::channel<Time>>(c).trySend(Now())) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    break;
                default:
                    break;
            }
        }
        std::this_thread::yield();
    }

    // After waits for the duration to elapse and then sends the current time
    // on the returned channel.
    // It is equivalent to NewTimer(d).C.
    // The underlying Timer is not recovered by the garbage collector
    // until the timer fires. If efficiency is a concern, use NewTimer
    // instead and call Timer.Stop if the timer is no longer needed.
    gocpp::channel<Time> After(golang::time::Duration d)
    {
        return NewTimer(d)->C;
    }

    // AfterFunc waits for the duration to elapse and then calls f
    // in its own goroutine. It returns a Timer that can
    // be used to cancel the call using its Stop method.
    // The returned Timer's C field is not used and will be nil.
    struct Timer* AfterFunc(golang::time::Duration d, std::function<void ()> f)
    {
        auto t = gocpp::InitPtr<Timer>([=](auto& x) {
            x.r = gocpp::Init<runtimeTimer>([=](auto& x) {
                x.when = when(d);
                x.f = goFunc;
                x.arg = f;
            });
        });
        startTimer(& t->r);
        return t;
    }

    void goFunc(go_any arg, uintptr_t seq)
    {
        gocpp::go([&]{ gocpp::getValue<std::function<void ()>>(arg)(); });
    }

}

