// generated by GoCpp from file '$(ImportDir)/sync/atomic/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/atomic/value.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::atomic
{
    
    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const Value& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& efaceWords::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const efaceWords& value)
    {
        return value.PrintTo(os);
    }

    go_any Load(Value* v)
    {
        go_any val;
        auto vp = (*efaceWords)(Pointer(gocpp::recv(unsafe), v));
        auto typ = LoadPointer(& vp->typ);
        if(typ == nullptr || typ == Pointer(gocpp::recv(unsafe), & firstStoreInProgress))
        {
            go_any val;
            return nullptr;
        }
        auto data = LoadPointer(& vp->data);
        auto vlp = (*efaceWords)(Pointer(gocpp::recv(unsafe), & val));
        vlp->typ = typ;
        vlp->data = data;
        return val;
    }

    unsigned char firstStoreInProgress;
    void Store(Value* v, go_any val)
    {
        if(val == nullptr)
        {
            gocpp::panic("sync/atomic: store of nil value into Value");
        }
        auto vp = (*efaceWords)(Pointer(gocpp::recv(unsafe), v));
        auto vlp = (*efaceWords)(Pointer(gocpp::recv(unsafe), & val));
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, Pointer(gocpp::recv(unsafe), & firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, vlp->data);
                StorePointer(& vp->typ, vlp->typ);
                runtime_procUnpin();
                return;
            }
            if(typ == Pointer(gocpp::recv(unsafe), & firstStoreInProgress))
            {
                continue;
            }
            if(typ != vlp->typ)
            {
                gocpp::panic("sync/atomic: store of inconsistently typed value into Value");
            }
            StorePointer(& vp->data, vlp->data);
            return;
        }
    }

    go_any Swap(Value* v, go_any go_new)
    {
        go_any old;
        if(go_new == nullptr)
        {
            go_any old;
            gocpp::panic("sync/atomic: swap of nil value into Value");
        }
        auto vp = (*efaceWords)(Pointer(gocpp::recv(unsafe), v));
        auto np = (*efaceWords)(Pointer(gocpp::recv(unsafe), & go_new));
        for(; ; )
        {
            go_any old;
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                go_any old;
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, Pointer(gocpp::recv(unsafe), & firstStoreInProgress)))
                {
                    go_any old;
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, np->data);
                StorePointer(& vp->typ, np->typ);
                runtime_procUnpin();
                return nullptr;
            }
            if(typ == Pointer(gocpp::recv(unsafe), & firstStoreInProgress))
            {
                go_any old;
                continue;
            }
            if(typ != np->typ)
            {
                go_any old;
                gocpp::panic("sync/atomic: swap of inconsistently typed value into Value");
            }
            auto op = (*efaceWords)(Pointer(gocpp::recv(unsafe), & old));
            std::tie(op->typ, op->data) = std::tuple{np->typ, SwapPointer(& vp->data, np->data)};
            return old;
        }
    }

    bool CompareAndSwap(Value* v, go_any old, go_any go_new)
    {
        bool swapped;
        if(go_new == nullptr)
        {
            bool swapped;
            gocpp::panic("sync/atomic: compare and swap of nil value into Value");
        }
        auto vp = (*efaceWords)(Pointer(gocpp::recv(unsafe), v));
        auto np = (*efaceWords)(Pointer(gocpp::recv(unsafe), & go_new));
        auto op = (*efaceWords)(Pointer(gocpp::recv(unsafe), & old));
        if(op->typ != nullptr && np->typ != op->typ)
        {
            bool swapped;
            gocpp::panic("sync/atomic: compare and swap of inconsistently typed values");
        }
        for(; ; )
        {
            bool swapped;
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                bool swapped;
                if(old != nullptr)
                {
                    bool swapped;
                    return false;
                }
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, Pointer(gocpp::recv(unsafe), & firstStoreInProgress)))
                {
                    bool swapped;
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, np->data);
                StorePointer(& vp->typ, np->typ);
                runtime_procUnpin();
                return true;
            }
            if(typ == Pointer(gocpp::recv(unsafe), & firstStoreInProgress))
            {
                bool swapped;
                continue;
            }
            if(typ != np->typ)
            {
                bool swapped;
                gocpp::panic("sync/atomic: compare and swap of inconsistently typed value into Value");
            }
            auto data = LoadPointer(& vp->data);
            go_any i = {};
            (*efaceWords)(Pointer(gocpp::recv(unsafe), & i))->typ = typ;
            (*efaceWords)(Pointer(gocpp::recv(unsafe), & i))->data = data;
            if(i != old)
            {
                bool swapped;
                return false;
            }
            return CompareAndSwapPointer(& vp->data, data, np->data);
        }
    }

    int runtime_procPin()
    /* convertBlockStmt, nil block */;

    void runtime_procUnpin()
    /* convertBlockStmt, nil block */;

}

