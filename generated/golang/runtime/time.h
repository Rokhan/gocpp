// generated by GoCpp from file '$(ImportDir)/runtime/time.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/time.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
#include "golang/runtime/netpoll.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    struct timer
    {
        puintptr pp;
        int64_t when;
        int64_t period;
        std::function<void (go_any, uintptr_t)> f;
        go_any arg;
        uintptr_t seq;
        int64_t nextwhen;
        atomic::Uint32 status;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct timer& value);
    extern int timerNoStatus;
    extern int timerWaiting;
    extern int timerRunning;
    extern int timerDeleted;
    extern int timerRemoving;
    extern int timerRemoved;
    extern int timerModifying;
    extern int timerModifiedEarlier;
    extern int timerModifiedLater;
    extern int timerMoving;
    extern int maxWhen;
    extern bool verifyTimers;
    void timeSleep(int64_t ns);
    bool resetForSleep(g* gp, unsafe::Pointer ut);
    void startTimer(timer* t);
    bool stopTimer(timer* t);
    bool resetTimer(timer* t, int64_t when);
    void modTimer(timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq);
    void goroutineReady(go_any arg, uintptr_t seq);
    void addtimer(timer* t);
    void doaddtimer(p* pp, timer* t);
    bool deltimer(timer* t);
    int dodeltimer(p* pp, int i);
    void dodeltimer0(p* pp);
    bool modtimer(timer* t, int64_t when, int64_t period, std::function<void (go_any, uintptr_t)> f, go_any arg, uintptr_t seq);
    bool resettimer(timer* t, int64_t when);
    void cleantimers(p* pp);
    void moveTimers(p* pp, gocpp::slice<timer*> timers);
    void adjusttimers(p* pp, int64_t now);
    void addAdjustedTimers(p* pp, gocpp::slice<timer*> moved);
    int64_t nobarrierWakeTime(p* pp);
    int64_t runtimer(p* pp, int64_t now);
    void runOneTimer(p* pp, timer* t, int64_t now);
    void clearDeletedTimers(p* pp);
    void verifyTimerHeap(p* pp);
    void updateTimer0When(p* pp);
    void updateTimerModifiedEarliest(p* pp, int64_t nextwhen);
    int64_t timeSleepUntil();
    int siftupTimer(gocpp::slice<timer*> t, int i);
    void siftdownTimer(gocpp::slice<timer*> t, int i);
    void badTimer();
}

