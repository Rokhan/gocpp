// generated by GoCpp from file '$(ImportDir)/sync/map.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/map.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"

namespace golang::sync
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using atomic::rec::Swap;
    }

    // Map is like a Go map[any]any but is safe for concurrent use
    // by multiple goroutines without additional locking or coordination.
    // Loads, stores, and deletes run in amortized constant time.
    //
    // The Map type is specialized. Most code should use a plain Go map instead,
    // with separate locking or coordination, for better type safety and to make it
    // easier to maintain other invariants along with the map content.
    //
    // The Map type is optimized for two common use cases: (1) when the entry for a given
    // key is only ever written once but read many times, as in caches that only grow,
    // or (2) when multiple goroutines read, write, and overwrite entries for disjoint
    // sets of keys. In these two cases, use of a Map may significantly reduce lock
    // contention compared to a Go map paired with a separate Mutex or RWMutex.
    //
    // The zero Map is empty and ready for use. A Map must not be copied after first use.
    //
    // In the terminology of the Go memory model, Map arranges that a write operation
    // “synchronizes before” any read operation that observes the effect of the write, where
    // read and write operations are defined as follows.
    // Load, LoadAndDelete, LoadOrStore, Swap, CompareAndSwap, and CompareAndDelete
    // are read operations; Delete, LoadAndDelete, Store, and Swap are write operations;
    // LoadOrStore is a write operation when it returns loaded set to false;
    // CompareAndSwap is a write operation when it returns swapped set to true;
    // and CompareAndDelete is a write operation when it returns deleted set to true.
    
    template<typename T> requires gocpp::GoStruct<T>
    Map::operator T()
    {
        T result;
        result.mu = this->mu;
        result.read = this->read;
        result.dirty = this->dirty;
        result.misses = this->misses;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Map::operator==(const T& ref) const
    {
        if (mu != ref.mu) return false;
        if (read != ref.read) return false;
        if (dirty != ref.dirty) return false;
        if (misses != ref.misses) return false;
        return true;
    }

    std::ostream& Map::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << " " << read;
        os << " " << dirty;
        os << " " << misses;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Map& value)
    {
        return value.PrintTo(os);
    }

    // readOnly is an immutable struct stored atomically in the Map.read field.
    
    template<typename T> requires gocpp::GoStruct<T>
    readOnly::operator T()
    {
        T result;
        result.m = this->m;
        result.amended = this->amended;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool readOnly::operator==(const T& ref) const
    {
        if (m != ref.m) return false;
        if (amended != ref.amended) return false;
        return true;
    }

    std::ostream& readOnly::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << m;
        os << " " << amended;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct readOnly& value)
    {
        return value.PrintTo(os);
    }

    // expunged is an arbitrary pointer that marks entries which have been deleted
    // from the dirty map.
    go_any* expunged = new(go_any);
    // An entry is a slot in the map corresponding to a particular key.
    
    template<typename T> requires gocpp::GoStruct<T>
    entry::operator T()
    {
        T result;
        result.p = this->p;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool entry::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        return true;
    }

    std::ostream& entry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct entry& value)
    {
        return value.PrintTo(os);
    }

    struct entry* newEntry(go_any i)
    {
        auto e = new entry {};
        rec::Store(gocpp::recv(e->p), & i);
        return e;
    }

    struct readOnly rec::loadReadOnly(struct Map* m)
    {
        if(auto p = rec::Load(gocpp::recv(m->read)); p != nullptr)
        {
            return *p;
        }
        return readOnly {};
    }

    // Load returns the value stored in the map for a key, or nil if no
    // value is present.
    // The ok result indicates whether value was found in the map.
    std::tuple<go_any, bool> rec::Load(struct Map* m, go_any key)
    {
        go_any value;
        bool ok;
        auto read = rec::loadReadOnly(gocpp::recv(m));
        auto [e, ok] = read.m[key];
        if(! ok && read.amended)
        {
            rec::Lock(gocpp::recv(m->mu));
            read = rec::loadReadOnly(gocpp::recv(m));
            std::tie(e, ok) = read.m[key];
            if(! ok && read.amended)
            {
                std::tie(e, ok) = m->dirty[key];
                rec::missLocked(gocpp::recv(m));
            }
            rec::Unlock(gocpp::recv(m->mu));
        }
        if(! ok)
        {
            return {nullptr, false};
        }
        return rec::load(gocpp::recv(e));
    }

    std::tuple<go_any, bool> rec::load(struct entry* e)
    {
        go_any value;
        bool ok;
        auto p = rec::Load(gocpp::recv(e->p));
        if(p == nullptr || p == expunged)
        {
            return {nullptr, false};
        }
        return {*p, true};
    }

    // Store sets the value for a key.
    void rec::Store(struct Map* m, go_any key, go_any value)
    {
        std::tie(gocpp_id_0, gocpp_id_1) = rec::Swap(gocpp::recv(m), key, value);
    }

    // tryCompareAndSwap compare the entry with the given old value and swaps
    // it with a new value if the entry is equal to the old value, and the entry
    // has not been expunged.
    //
    // If the entry is expunged, tryCompareAndSwap returns false and leaves
    // the entry unchanged.
    bool rec::tryCompareAndSwap(struct entry* e, go_any old, go_any go_new)
    {
        auto p = rec::Load(gocpp::recv(e->p));
        if(p == nullptr || p == expunged || *p != old)
        {
            return false;
        }
        auto nc = go_new;
        for(; ; )
        {
            if(rec::CompareAndSwap(gocpp::recv(e->p), p, & nc))
            {
                return true;
            }
            p = rec::Load(gocpp::recv(e->p));
            if(p == nullptr || p == expunged || *p != old)
            {
                return false;
            }
        }
    }

    // unexpungeLocked ensures that the entry is not marked as expunged.
    //
    // If the entry was previously expunged, it must be added to the dirty map
    // before m.mu is unlocked.
    bool rec::unexpungeLocked(struct entry* e)
    {
        bool wasExpunged;
        return rec::CompareAndSwap(gocpp::recv(e->p), expunged, nullptr);
    }

    // swapLocked unconditionally swaps a value into the entry.
    //
    // The entry must be known not to be expunged.
    go_any* rec::swapLocked(struct entry* e, go_any* i)
    {
        return rec::Swap(gocpp::recv(e->p), i);
    }

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    std::tuple<go_any, bool> rec::LoadOrStore(struct Map* m, go_any key, go_any value)
    {
        go_any actual;
        bool loaded;
        auto read = rec::loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            auto [actual, loaded, ok] = rec::tryLoadOrStore(gocpp::recv(e), value);
            if(ok)
            {
                return {actual, loaded};
            }
        }
        rec::Lock(gocpp::recv(m->mu));
        read = rec::loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            if(rec::unexpungeLocked(gocpp::recv(e)))
            {
                m->dirty[key] = e;
            }
            std::tie(actual, loaded, gocpp_id_2) = rec::tryLoadOrStore(gocpp::recv(e), value);
        }
        else
        if(auto [e, ok] = m->dirty[key]; ok)
        {
            std::tie(actual, loaded, gocpp_id_3) = rec::tryLoadOrStore(gocpp::recv(e), value);
            rec::missLocked(gocpp::recv(m));
        }
        else
        {
            if(! read.amended)
            {
                rec::dirtyLocked(gocpp::recv(m));
                rec::Store(gocpp::recv(m->read), gocpp::InitPtr<readOnly>([=](auto& x) {
                    x.m = read.m;
                    x.amended = true;
                }));
            }
            m->dirty[key] = newEntry(value);
            std::tie(actual, loaded) = std::tuple{value, false};
        }
        rec::Unlock(gocpp::recv(m->mu));
        return {actual, loaded};
    }

    // tryLoadOrStore atomically loads or stores a value if the entry is not
    // expunged.
    //
    // If the entry is expunged, tryLoadOrStore leaves the entry unchanged and
    // returns with ok==false.
    std::tuple<go_any, bool, bool> rec::tryLoadOrStore(struct entry* e, go_any i)
    {
        go_any actual;
        bool loaded;
        bool ok;
        auto p = rec::Load(gocpp::recv(e->p));
        if(p == expunged)
        {
            return {nullptr, false, false};
        }
        if(p != nullptr)
        {
            return {*p, true, true};
        }
        auto ic = i;
        for(; ; )
        {
            if(rec::CompareAndSwap(gocpp::recv(e->p), nullptr, & ic))
            {
                return {i, false, true};
            }
            p = rec::Load(gocpp::recv(e->p));
            if(p == expunged)
            {
                return {nullptr, false, false};
            }
            if(p != nullptr)
            {
                return {*p, true, true};
            }
        }
    }

    // LoadAndDelete deletes the value for a key, returning the previous value if any.
    // The loaded result reports whether the key was present.
    std::tuple<go_any, bool> rec::LoadAndDelete(struct Map* m, go_any key)
    {
        go_any value;
        bool loaded;
        auto read = rec::loadReadOnly(gocpp::recv(m));
        auto [e, ok] = read.m[key];
        if(! ok && read.amended)
        {
            rec::Lock(gocpp::recv(m->mu));
            read = rec::loadReadOnly(gocpp::recv(m));
            std::tie(e, ok) = read.m[key];
            if(! ok && read.amended)
            {
                std::tie(e, ok) = m->dirty[key];
                remove(m->dirty, key);
                rec::missLocked(gocpp::recv(m));
            }
            rec::Unlock(gocpp::recv(m->mu));
        }
        if(ok)
        {
            return rec::go_delete(gocpp::recv(e));
        }
        return {nullptr, false};
    }

    // Delete deletes the value for a key.
    void rec::Delete(struct Map* m, go_any key)
    {
        rec::LoadAndDelete(gocpp::recv(m), key);
    }

    std::tuple<go_any, bool> rec::go_delete(struct entry* e)
    {
        go_any value;
        bool ok;
        for(; ; )
        {
            auto p = rec::Load(gocpp::recv(e->p));
            if(p == nullptr || p == expunged)
            {
                return {nullptr, false};
            }
            if(rec::CompareAndSwap(gocpp::recv(e->p), p, nullptr))
            {
                return {*p, true};
            }
        }
    }

    // trySwap swaps a value if the entry has not been expunged.
    //
    // If the entry is expunged, trySwap returns false and leaves the entry
    // unchanged.
    std::tuple<go_any*, bool> rec::trySwap(struct entry* e, go_any* i)
    {
        for(; ; )
        {
            auto p = rec::Load(gocpp::recv(e->p));
            if(p == expunged)
            {
                return {nullptr, false};
            }
            if(rec::CompareAndSwap(gocpp::recv(e->p), p, i))
            {
                return {p, true};
            }
        }
    }

    // Swap swaps the value for a key and returns the previous value if any.
    // The loaded result reports whether the key was present.
    std::tuple<go_any, bool> rec::Swap(struct Map* m, go_any key, go_any value)
    {
        go_any previous;
        bool loaded;
        auto read = rec::loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            if(auto [v, ok] = rec::trySwap(gocpp::recv(e), & value); ok)
            {
                if(v == nullptr)
                {
                    return {nullptr, false};
                }
                return {*v, true};
            }
        }
        rec::Lock(gocpp::recv(m->mu));
        read = rec::loadReadOnly(gocpp::recv(m));
        if(auto [e, ok] = read.m[key]; ok)
        {
            if(rec::unexpungeLocked(gocpp::recv(e)))
            {
                m->dirty[key] = e;
            }
            if(auto v = rec::swapLocked(gocpp::recv(e), & value); v != nullptr)
            {
                loaded = true;
                previous = *v;
            }
        }
        else
        if(auto [e, ok] = m->dirty[key]; ok)
        {
            if(auto v = rec::swapLocked(gocpp::recv(e), & value); v != nullptr)
            {
                loaded = true;
                previous = *v;
            }
        }
        else
        {
            if(! read.amended)
            {
                rec::dirtyLocked(gocpp::recv(m));
                rec::Store(gocpp::recv(m->read), gocpp::InitPtr<readOnly>([=](auto& x) {
                    x.m = read.m;
                    x.amended = true;
                }));
            }
            m->dirty[key] = newEntry(value);
        }
        rec::Unlock(gocpp::recv(m->mu));
        return {previous, loaded};
    }

    // CompareAndSwap swaps the old and new values for key
    // if the value stored in the map is equal to old.
    // The old value must be of a comparable type.
    bool rec::CompareAndSwap(struct Map* m, go_any key, go_any old, go_any go_new)
    {
        gocpp::Defer defer;
        try
        {
            auto read = rec::loadReadOnly(gocpp::recv(m));
            if(auto [e, ok] = read.m[key]; ok)
            {
                return rec::tryCompareAndSwap(gocpp::recv(e), old, go_new);
            }
            else
            if(! read.amended)
            {
                return false;
            }
            rec::Lock(gocpp::recv(m->mu));
            defer.push_back([=]{ rec::Unlock(gocpp::recv(m->mu)); });
            read = rec::loadReadOnly(gocpp::recv(m));
            auto swapped = false;
            if(auto [e, ok] = read.m[key]; ok)
            {
                swapped = rec::tryCompareAndSwap(gocpp::recv(e), old, go_new);
            }
            else
            if(auto [e, ok] = m->dirty[key]; ok)
            {
                swapped = rec::tryCompareAndSwap(gocpp::recv(e), old, go_new);
                rec::missLocked(gocpp::recv(m));
            }
            return swapped;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // CompareAndDelete deletes the entry for key if its value is equal to old.
    // The old value must be of a comparable type.
    //
    // If there is no current value for key in the map, CompareAndDelete
    // returns false (even if the old value is the nil interface value).
    bool rec::CompareAndDelete(struct Map* m, go_any key, go_any old)
    {
        bool deleted;
        auto read = rec::loadReadOnly(gocpp::recv(m));
        auto [e, ok] = read.m[key];
        if(! ok && read.amended)
        {
            rec::Lock(gocpp::recv(m->mu));
            read = rec::loadReadOnly(gocpp::recv(m));
            std::tie(e, ok) = read.m[key];
            if(! ok && read.amended)
            {
                std::tie(e, ok) = m->dirty[key];
                rec::missLocked(gocpp::recv(m));
            }
            rec::Unlock(gocpp::recv(m->mu));
        }
        for(; ok; )
        {
            auto p = rec::Load(gocpp::recv(e->p));
            if(p == nullptr || p == expunged || *p != old)
            {
                return false;
            }
            if(rec::CompareAndSwap(gocpp::recv(e->p), p, nullptr))
            {
                return true;
            }
        }
        return false;
    }

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    //
    // Range does not necessarily correspond to any consistent snapshot of the Map's
    // contents: no key will be visited more than once, but if the value for any key
    // is stored or deleted concurrently (including by f), Range may reflect any
    // mapping for that key from any point during the Range call. Range does not
    // block other methods on the receiver; even f itself may call any method on m.
    //
    // Range may be O(N) with the number of elements in the map even if f returns
    // false after a constant number of calls.
    void rec::Range(struct Map* m, std::function<bool (go_any key, go_any value)> f)
    {
        auto read = rec::loadReadOnly(gocpp::recv(m));
        if(read.amended)
        {
            rec::Lock(gocpp::recv(m->mu));
            read = rec::loadReadOnly(gocpp::recv(m));
            if(read.amended)
            {
                read = gocpp::Init<readOnly>([=](auto& x) {
                    x.m = m->dirty;
                });
                auto copyRead = read;
                rec::Store(gocpp::recv(m->read), & copyRead);
                m->dirty = nullptr;
                m->misses = 0;
            }
            rec::Unlock(gocpp::recv(m->mu));
        }
        for(auto [k, e] : read.m)
        {
            auto [v, ok] = rec::load(gocpp::recv(e));
            if(! ok)
            {
                continue;
            }
            if(! f(k, v))
            {
                break;
            }
        }
    }

    void rec::missLocked(struct Map* m)
    {
        m->misses++;
        if(m->misses < len(m->dirty))
        {
            return;
        }
        rec::Store(gocpp::recv(m->read), gocpp::InitPtr<readOnly>([=](auto& x) {
            x.m = m->dirty;
        }));
        m->dirty = nullptr;
        m->misses = 0;
    }

    void rec::dirtyLocked(struct Map* m)
    {
        if(m->dirty != nullptr)
        {
            return;
        }
        auto read = rec::loadReadOnly(gocpp::recv(m));
        m->dirty = gocpp::make(gocpp::Tag<gocpp::map<go_any, entry*>>(), len(read.m));
        for(auto [k, e] : read.m)
        {
            if(! rec::tryExpungeLocked(gocpp::recv(e)))
            {
                m->dirty[k] = e;
            }
        }
    }

    bool rec::tryExpungeLocked(struct entry* e)
    {
        bool isExpunged;
        auto p = rec::Load(gocpp::recv(e->p));
        for(; p == nullptr; )
        {
            if(rec::CompareAndSwap(gocpp::recv(e->p), nullptr, expunged))
            {
                return true;
            }
            p = rec::Load(gocpp::recv(e->p));
        }
        return p == expunged;
    }

}

