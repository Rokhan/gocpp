// generated by GoCpp from file '$(ImportDir)/runtime/mstats.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mstats.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    struct mstats
    {
        /* consistentHeapStats heapStats; [Known incomplete type] */
        runtime::sysMemStat stacks_sys;
        runtime::sysMemStat mspan_sys;
        runtime::sysMemStat mcache_sys;
        runtime::sysMemStat buckhash_sys;
        runtime::sysMemStat gcMiscSys;
        runtime::sysMemStat other_sys;
        uint64_t last_gc_unix;
        uint64_t pause_total_ns;
        gocpp::array<uint64_t, 256> pause_ns;
        gocpp::array<uint64_t, 256> pause_end;
        uint32_t numgc;
        uint32_t numforcedgc;
        double gc_cpu_fraction;
        uint64_t last_gc_nanotime;
        uint64_t lastHeapInUse;
        bool enablegc;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mstats& value);
    struct MemStats
    {
        uint64_t Alloc;
        uint64_t TotalAlloc;
        uint64_t Sys;
        uint64_t Lookups;
        uint64_t Mallocs;
        uint64_t Frees;
        uint64_t HeapAlloc;
        uint64_t HeapSys;
        uint64_t HeapIdle;
        uint64_t HeapInuse;
        uint64_t HeapReleased;
        uint64_t HeapObjects;
        uint64_t StackInuse;
        uint64_t StackSys;
        uint64_t MSpanInuse;
        uint64_t MSpanSys;
        uint64_t MCacheInuse;
        uint64_t MCacheSys;
        uint64_t BuckHashSys;
        uint64_t GCSys;
        uint64_t OtherSys;
        uint64_t NextGC;
        uint64_t LastGC;
        uint64_t PauseTotalNs;
        gocpp::array<uint64_t, 256> PauseNs;
        gocpp::array<uint64_t, 256> PauseEnd;
        uint32_t NumGC;
        uint32_t NumForcedGC;
        double GCCPUFraction;
        bool EnableGC;
        bool DebugGC;
        gocpp::array<gocpp_id_0, 61> BySize;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MemStats& value);
    void init();
    void ReadMemStats(struct MemStats* m);
    extern bool doubleCheckReadMemStats;
    void readmemstats_m(struct MemStats* stats);
    void readGCStats(gocpp::slice<uint64_t>* pauses);
    void readGCStats_m(gocpp::slice<uint64_t>* pauses);
    void flushmcache(int i);
    void flushallmcaches();
    struct heapStatsDelta
    {
        int64_t committed;
        int64_t released;
        int64_t inHeap;
        int64_t inStacks;
        int64_t inWorkBufs;
        int64_t inPtrScalarBits;
        uint64_t tinyAllocCount;
        uint64_t largeAlloc;
        uint64_t largeAllocCount;
        gocpp::array<uint64_t, _NumSizeClasses> smallAllocCount;
        uint64_t largeFree;
        uint64_t largeFreeCount;
        gocpp::array<uint64_t, _NumSizeClasses> smallFreeCount;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heapStatsDelta& value);
    struct consistentHeapStats
    {
        gocpp::array<heapStatsDelta, 3> stats;
        atomic::Uint32 gen;
        mutex noPLock;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct consistentHeapStats& value);
    struct cpuStats
    {
        int64_t gcAssistTime;
        int64_t gcDedicatedTime;
        int64_t gcIdleTime;
        int64_t gcPauseTime;
        int64_t gcTotalTime;
        int64_t scavengeAssistTime;
        int64_t scavengeBgTime;
        int64_t scavengeTotalTime;
        int64_t idleTime;
        int64_t userTime;
        int64_t totalTime;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cpuStats& value);

    namespace rec
    {
        uint64_t load(runtime::sysMemStat* s);
        void add(runtime::sysMemStat* s, int64_t n);
        void merge(struct heapStatsDelta* a, struct heapStatsDelta* b);
        struct heapStatsDelta* acquire(struct consistentHeapStats* m);
        void release(struct consistentHeapStats* m);
        void unsafeRead(struct consistentHeapStats* m, struct heapStatsDelta* out);
        void unsafeClear(struct consistentHeapStats* m);
        void read(struct consistentHeapStats* m, struct heapStatsDelta* out);
        void accumulate(struct cpuStats* s, int64_t now, bool gcMarkPhase);
    }
}

