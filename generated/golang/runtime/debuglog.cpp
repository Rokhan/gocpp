// generated by GoCpp from file '$(ImportDir)/runtime/debuglog.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/debuglog.h"
#include "gocpp/support.h"

#include "golang/runtime/cputicks.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/mem_windows.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/time_nofake.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    dlogger* dlog()
    {
        if(! dlogEnabled)
        {
            return nullptr;
        }
        auto [tick, nano] = std::tuple{uint64_t(cputicks()), uint64_t(nanotime())};
        auto l = getCachedDlogger();
        if(l == nullptr)
        {
            auto allp = (uintptr_t*)(unsafe::Pointer(& allDloggers));
            auto all = (dlogger*)(unsafe::Pointer(atomic::Loaduintptr(allp)));
            for(auto l1 = all; l1 != nullptr; l1 = l1->allLink)
            {
                if(Load(gocpp::recv(l1->owned)) == 0 && CompareAndSwap(gocpp::recv(l1->owned), 0, 1))
                {
                    l = l1;
                    break;
                }
            }
        }
        if(l == nullptr)
        {
            l = (dlogger*)(sysAllocOS(unsafe::Sizeof(dlogger {})));
            if(l == nullptr)
            {
                go_throw("failed to allocate debug log");
            }
            l->w.r.data = & l->w.data;
            Store(gocpp::recv(l->owned), 1);
            auto headp = (uintptr_t*)(unsafe::Pointer(& allDloggers));
            for(; ; )
            {
                auto head = atomic::Loaduintptr(headp);
                l->allLink = (dlogger*)(unsafe::Pointer(head));
                if(atomic::Casuintptr(headp, head, uintptr_t(unsafe::Pointer(l))))
                {
                    break;
                }
            }
        }
        auto deltaLimit = (1 << (3 * 7)) - 1;
        if(tick - l->w.tick > deltaLimit || nano - l->w.nano > deltaLimit)
        {
            writeSync(gocpp::recv(l->w), tick, nano);
        }
        ensure(gocpp::recv(l->w), debugLogHeaderSize);
        l->w.write += debugLogHeaderSize;
        uvarint(gocpp::recv(l->w), tick - l->w.tick);
        uvarint(gocpp::recv(l->w), nano - l->w.nano);
        auto gp = getg();
        if(gp != nullptr && gp->m != nullptr && gp->m->p != 0)
        {
            varint(gocpp::recv(l->w), int64_t(ptr(gocpp::recv(gp->m->p))->id));
        }
        else
        {
            varint(gocpp::recv(l->w), - 1);
        }
        return l;
    }

    
    std::ostream& dlogger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << w;
        os << " " << allLink;
        os << " " << owned;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dlogger& value)
    {
        return value.PrintTo(os);
    }

    dlogger* allDloggers;
    void end(struct dlogger* l)
    {
        if(! dlogEnabled)
        {
            return;
        }
        auto size = l->w.write - l->w.r.end;
        if(! writeFrameAt(gocpp::recv(l->w), l->w.r.end, size))
        {
            go_throw("record too large");
        }
        l->w.r.end = l->w.write;
        if(putCachedDlogger(l))
        {
            return;
        }
        Store(gocpp::recv(l->owned), 0);
    }

    dlogger* b(struct dlogger* l, bool x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        if(x)
        {
            unsigned char(gocpp::recv(l->w), debugLogBoolTrue);
        }
        else
        {
            unsigned char(gocpp::recv(l->w), debugLogBoolFalse);
        }
        return l;
    }

    dlogger* i(struct dlogger* l, int x)
    {
        return i64(gocpp::recv(l), int64_t(x));
    }

    dlogger* i8(struct dlogger* l, int8_t x)
    {
        return i64(gocpp::recv(l), int64_t(x));
    }

    dlogger* i16(struct dlogger* l, int16_t x)
    {
        return i64(gocpp::recv(l), int64_t(x));
    }

    dlogger* i32(struct dlogger* l, int32_t x)
    {
        return i64(gocpp::recv(l), int64_t(x));
    }

    dlogger* i64(struct dlogger* l, int64_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        unsigned char(gocpp::recv(l->w), debugLogInt);
        varint(gocpp::recv(l->w), x);
        return l;
    }

    dlogger* u(struct dlogger* l, unsigned int x)
    {
        return u64(gocpp::recv(l), uint64_t(x));
    }

    dlogger* uptr(struct dlogger* l, uintptr_t x)
    {
        return u64(gocpp::recv(l), uint64_t(x));
    }

    dlogger* u8(struct dlogger* l, uint8_t x)
    {
        return u64(gocpp::recv(l), uint64_t(x));
    }

    dlogger* u16(struct dlogger* l, uint16_t x)
    {
        return u64(gocpp::recv(l), uint64_t(x));
    }

    dlogger* u32(struct dlogger* l, uint32_t x)
    {
        return u64(gocpp::recv(l), uint64_t(x));
    }

    dlogger* u64(struct dlogger* l, uint64_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        unsigned char(gocpp::recv(l->w), debugLogUint);
        uvarint(gocpp::recv(l->w), x);
        return l;
    }

    dlogger* hex(struct dlogger* l, uint64_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        unsigned char(gocpp::recv(l->w), debugLogHex);
        uvarint(gocpp::recv(l->w), x);
        return l;
    }

    dlogger* p(struct dlogger* l, go_any x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        unsigned char(gocpp::recv(l->w), debugLogPtr);
        if(x == nullptr)
        {
            uvarint(gocpp::recv(l->w), 0);
        }
        else
        {
            auto v = efaceOf(& x);
            //Go switch emulation
            {
                auto condition = v->_type->Kind_ & kindMask;
                int conditionId = -1;
                if(condition == kindChan) { conditionId = 0; }
                if(condition == kindFunc) { conditionId = 1; }
                if(condition == kindMap) { conditionId = 2; }
                if(condition == kindPtr) { conditionId = 3; }
                if(condition == kindUnsafePointer) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        uvarint(gocpp::recv(l->w), uint64_t(uintptr_t(v->data)));
                        break;
                    default:
                        go_throw("not a pointer type");
                        break;
                }
            }
        }
        return l;
    }

    dlogger* s(struct dlogger* l, std::string x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        auto strData = unsafe::StringData(x);
        auto datap = & firstmoduledata;
        if(len(x) > 4 && datap->etext <= uintptr_t(unsafe::Pointer(strData)) && uintptr_t(unsafe::Pointer(strData)) < datap->end)
        {
            unsigned char(gocpp::recv(l->w), debugLogConstString);
            uvarint(gocpp::recv(l->w), uint64_t(len(x)));
            uvarint(gocpp::recv(l->w), uint64_t(uintptr_t(unsafe::Pointer(strData)) - datap->etext));
        }
        else
        {
            unsigned char(gocpp::recv(l->w), debugLogString);
            gocpp::slice<unsigned char> b = {};
            auto bb = (slice*)(unsafe::Pointer(& b));
            bb->array = unsafe::Pointer(strData);
            std::tie(bb->len, bb->cap) = std::tuple{len(x), len(x)};
            if(len(b) > debugLogStringLimit)
            {
                b = b.make_slice(0, debugLogStringLimit);
            }
            uvarint(gocpp::recv(l->w), uint64_t(len(b)));
            bytes(gocpp::recv(l->w), b);
            if(len(b) != len(x))
            {
                unsigned char(gocpp::recv(l->w), debugLogStringOverflow);
                uvarint(gocpp::recv(l->w), uint64_t(len(x) - len(b)));
            }
        }
        return l;
    }

    dlogger* pc(struct dlogger* l, uintptr_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        unsigned char(gocpp::recv(l->w), debugLogPC);
        uvarint(gocpp::recv(l->w), uint64_t(x));
        return l;
    }

    dlogger* traceback(struct dlogger* l, gocpp::slice<uintptr_t> x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        unsigned char(gocpp::recv(l->w), debugLogTraceback);
        uvarint(gocpp::recv(l->w), uint64_t(len(x)));
        for(auto [_, pc] : x)
        {
            uvarint(gocpp::recv(l->w), uint64_t(pc));
        }
        return l;
    }

    
    std::ostream& debugLogWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << write;
        os << " " << data;
        os << " " << tick;
        os << " " << nano;
        os << " " << r;
        os << " " << buf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct debugLogWriter& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& debugLogBuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << b;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct debugLogBuf& value)
    {
        return value.PrintTo(os);
    }

    void ensure(struct debugLogWriter* l, uint64_t n)
    {
        for(; l->write + n >= l->r.begin + uint64_t(len(l->data.b)); )
        {
            if(skip(gocpp::recv(l->r)) == ~ uint64_t(0))
            {
                go_throw("record wrapped around");
            }
        }
    }

    bool writeFrameAt(struct debugLogWriter* l, uint64_t pos, uint64_t size)
    {
        l->data.b[pos % uint64_t(len(l->data.b))] = uint8_t(size);
        l->data.b[(pos + 1) % uint64_t(len(l->data.b))] = uint8_t(size >> 8);
        return size <= 0xFFFF;
    }

    void writeSync(struct debugLogWriter* l, uint64_t tick, uint64_t nano)
    {
        std::tie(l->tick, l->nano) = std::tuple{tick, nano};
        ensure(gocpp::recv(l), debugLogHeaderSize);
        writeFrameAt(gocpp::recv(l), l->write, 0);
        l->write += debugLogHeaderSize;
        writeUint64LE(gocpp::recv(l), tick);
        writeUint64LE(gocpp::recv(l), nano);
        l->r.end = l->write;
    }

    void writeUint64LE(struct debugLogWriter* l, uint64_t x)
    {
        gocpp::array<unsigned char, 8> b = {};
        b[0] = unsigned char(x);
        b[1] = unsigned char(x >> 8);
        b[2] = unsigned char(x >> 16);
        b[3] = unsigned char(x >> 24);
        b[4] = unsigned char(x >> 32);
        b[5] = unsigned char(x >> 40);
        b[6] = unsigned char(x >> 48);
        b[7] = unsigned char(x >> 56);
        bytes(gocpp::recv(l), b.make_slice(0, ));
    }

    void byte(struct debugLogWriter* l, unsigned char x)
    {
        ensure(gocpp::recv(l), 1);
        auto pos = l->write;
        l->write++;
        l->data.b[pos % uint64_t(len(l->data.b))] = x;
    }

    void bytes(struct debugLogWriter* l, gocpp::slice<unsigned char> x)
    {
        ensure(gocpp::recv(l), uint64_t(len(x)));
        auto pos = l->write;
        l->write += uint64_t(len(x));
        for(; len(x) > 0; )
        {
            auto n = copy(l->data.b.make_slice(pos % uint64_t(len(l->data.b))), x);
            pos += uint64_t(n);
            x = x.make_slice(n);
        }
    }

    void varint(struct debugLogWriter* l, int64_t x)
    {
        uint64_t u = {};
        if(x < 0)
        {
            u = (~ uint64_t(x) << 1) | 1;
        }
        else
        {
            u = (uint64_t(x) << 1);
        }
        uvarint(gocpp::recv(l), u);
    }

    void uvarint(struct debugLogWriter* l, uint64_t u)
    {
        auto i = 0;
        for(; u >= 0x80; )
        {
            l->buf[i] = unsigned char(u) | 0x80;
            u >>= 7;
            i++;
        }
        l->buf[i] = unsigned char(u);
        i++;
        bytes(gocpp::recv(l), l->buf.make_slice(0, i));
    }

    
    std::ostream& debugLogReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << data;
        os << " " << begin;
        os << " " << end;
        os << " " << tick;
        os << " " << nano;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct debugLogReader& value)
    {
        return value.PrintTo(os);
    }

    uint64_t skip(struct debugLogReader* r)
    {
        if(r->begin + debugLogHeaderSize > r->end)
        {
            return ~ uint64_t(0);
        }
        auto size = uint64_t(readUint16LEAt(gocpp::recv(r), r->begin));
        if(size == 0)
        {
            r->tick = readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize);
            r->nano = readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize + 8);
            size = debugLogSyncSize;
        }
        if(r->begin + size > r->end)
        {
            return ~ uint64_t(0);
        }
        r->begin += size;
        return size;
    }

    uint16_t readUint16LEAt(struct debugLogReader* r, uint64_t pos)
    {
        return uint16_t(r->data->b[pos % uint64_t(len(r->data->b))]) | (uint16_t(r->data->b[(pos + 1) % uint64_t(len(r->data->b))]) << 8);
    }

    uint64_t readUint64LEAt(struct debugLogReader* r, uint64_t pos)
    {
        gocpp::array<unsigned char, 8> b = {};
        for(auto [i, gocpp_ignored] : b)
        {
            b[i] = r->data->b[pos % uint64_t(len(r->data->b))];
            pos++;
        }
        return uint64_t(b[0]) | (uint64_t(b[1]) << 8) | (uint64_t(b[2]) << 16) | (uint64_t(b[3]) << 24) | (uint64_t(b[4]) << 32) | (uint64_t(b[5]) << 40) | (uint64_t(b[6]) << 48) | (uint64_t(b[7]) << 56);
    }

    uint64_t peek(struct debugLogReader* r)
    {
        uint64_t tick;
        auto size = uint64_t(0);
        for(; size == 0; )
        {
            uint64_t tick;
            if(r->begin + debugLogHeaderSize > r->end)
            {
                uint64_t tick;
                return ~ uint64_t(0);
            }
            size = uint64_t(readUint16LEAt(gocpp::recv(r), r->begin));
            if(size != 0)
            {
                uint64_t tick;
                break;
            }
            if(r->begin + debugLogSyncSize > r->end)
            {
                uint64_t tick;
                return ~ uint64_t(0);
            }
            r->tick = readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize);
            r->nano = readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize + 8);
            r->begin += debugLogSyncSize;
        }
        if(r->begin + size > r->end)
        {
            uint64_t tick;
            return ~ uint64_t(0);
        }
        auto pos = r->begin + debugLogHeaderSize;
        uint64_t u = {};
        for(auto i = (unsigned int)(0); ; i += 7)
        {
            uint64_t tick;
            auto b = r->data->b[pos % uint64_t(len(r->data->b))];
            pos++;
            u |= uint64_t(b &^ 0x80) << i;
            if(b & 0x80 == 0)
            {
                uint64_t tick;
                break;
            }
        }
        if(pos > r->begin + size)
        {
            uint64_t tick;
            return ~ uint64_t(0);
        }
        return r->tick + u;
    }

    std::tuple<uint64_t, uint64_t, uint64_t, int> header(struct debugLogReader* r)
    {
        uint64_t end;
        uint64_t tick;
        uint64_t nano;
        int p;
        auto size = uint64_t(readUint16LEAt(gocpp::recv(r), r->begin));
        end = r->begin + size;
        r->begin += debugLogHeaderSize;
        tick = uvarint(gocpp::recv(r)) + r->tick;
        nano = uvarint(gocpp::recv(r)) + r->nano;
        p = int(varint(gocpp::recv(r)));
        return {end, tick, nano, p};
    }

    uint64_t uvarint(struct debugLogReader* r)
    {
        uint64_t u = {};
        for(auto i = (unsigned int)(0); ; i += 7)
        {
            auto b = r->data->b[r->begin % uint64_t(len(r->data->b))];
            r->begin++;
            u |= uint64_t(b &^ 0x80) << i;
            if(b & 0x80 == 0)
            {
                break;
            }
        }
        return u;
    }

    int64_t varint(struct debugLogReader* r)
    {
        auto u = uvarint(gocpp::recv(r));
        int64_t v = {};
        if(u & 1 == 0)
        {
            v = int64_t(u >> 1);
        }
        else
        {
            v = ~ int64_t(u >> 1);
        }
        return v;
    }

    bool printVal(struct debugLogReader* r)
    {
        auto typ = r->data->b[r->begin % uint64_t(len(r->data->b))];
        r->begin++;
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            else if(condition == debugLogUnknown) { conditionId = 0; }
            else if(condition == debugLogBoolTrue) { conditionId = 1; }
            else if(condition == debugLogBoolFalse) { conditionId = 2; }
            else if(condition == debugLogInt) { conditionId = 3; }
            else if(condition == debugLogUint) { conditionId = 4; }
            else if(condition == debugLogHex) { conditionId = 5; }
            else if(condition == debugLogPtr) { conditionId = 6; }
            else if(condition == debugLogString) { conditionId = 7; }
            else if(condition == debugLogConstString) { conditionId = 8; }
            else if(condition == debugLogStringOverflow) { conditionId = 9; }
            else if(condition == debugLogPC) { conditionId = 10; }
            else if(condition == debugLogTraceback) { conditionId = 11; }
            switch(conditionId)
            {
                default:
                    print("<unknown field type ", hex(typ), " pos ", r->begin - 1, " end ", r->end, ">\n");
                    return false;
                    break;
                case 0:
                    print("<unknown kind>");
                    break;
                case 1:
                    print(true);
                    break;
                case 2:
                    print(false);
                    break;
                case 3:
                    print(varint(gocpp::recv(r)));
                    break;
                case 4:
                    print(uvarint(gocpp::recv(r)));
                    break;
                case 5:
                case 6:
                    print(hex(uvarint(gocpp::recv(r))));
                    break;
                case 7:
                    auto sl = uvarint(gocpp::recv(r));
                    if(r->begin + sl > r->end)
                    {
                        r->begin = r->end;
                        print("<string length corrupted>");
                        break;
                    }
                    for(; sl > 0; )
                    {
                        auto b = r->data->b.make_slice(r->begin % uint64_t(len(r->data->b)));
                        if(uint64_t(len(b)) > sl)
                        {
                            b = b.make_slice(0, sl);
                        }
                        r->begin += uint64_t(len(b));
                        sl -= uint64_t(len(b));
                        gwrite(b);
                    }
                    break;
                case 8:
                    auto [len, ptr] = std::tuple{int(uvarint(gocpp::recv(r))), uintptr_t(uvarint(gocpp::recv(r)))};
                    ptr += firstmoduledata.etext;
                    auto str = gocpp::Init<stringStruct>([](stringStruct& x) { x.str = unsafe::Pointer(ptr); x.len = len; });
                    auto s = *(std::string*)(unsafe::Pointer(& str));
                    print(s);
                    break;
                case 9:
                    print("..(", uvarint(gocpp::recv(r)), " more bytes)..");
                    break;
                case 10:
                    printDebugLogPC(uintptr_t(uvarint(gocpp::recv(r))), false);
                    break;
                case 11:
                    auto n = int(uvarint(gocpp::recv(r)));
                    for(auto i = 0; i < n; i++)
                    {
                        print("\n\t");
                        printDebugLogPC(uintptr_t(uvarint(gocpp::recv(r))), true);
                    }
                    break;
            }
        }
        return true;
    }

    struct gocpp_id_0
            {
                uint64_t tick;
                int i;

                using isGoStruct = void;

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << "" << tick;
                    os << " " << i;
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
            {
                return value.PrintTo(os);
            }


    void printDebugLog()
    {
        if(! dlogEnabled)
        {
            return;
        }
        printlock();
        auto allp = (uintptr_t*)(unsafe::Pointer(& allDloggers));
        auto all = (dlogger*)(unsafe::Pointer(atomic::Loaduintptr(allp)));
        auto n = 0;
        for(auto l = all; l != nullptr; l = l->allLink)
        {
            n++;
        }
        if(n == 0)
        {
            printunlock();
            return;
        }
        
        std::ostream& readState::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << first;
            os << " " << lost;
            os << " " << nextTick;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct readState& value)
        {
            return value.PrintTo(os);
        }

        auto state1 = sysAllocOS(unsafe::Sizeof(readState {}) * uintptr_t(n));
        if(state1 == nullptr)
        {
            println("failed to allocate read state for", n, "logs");
            printunlock();
            return;
        }
        auto state = (gocpp::array<readState, 1 << 20>*)(state1).make_slice(0, n);
        {
            auto l = all;
            for(auto [i, gocpp_ignored] : state)
            {
                auto s = & state[i];
                s->debugLogReader = l->w.r;
                s->first = true;
                s->lost = l->w.r.begin;
                s->nextTick = peek(gocpp::recv(s));
                l = l->allLink;
            }
        }
        for(; ; )
        {
            gocpp_id_0 best = {};
            best.tick = ~ uint64_t(0);
            for(auto [i, gocpp_ignored] : state)
            {
                if(state[i].nextTick < best.tick)
                {
                    best.tick = state[i].nextTick;
                    best.i = i;
                }
            }
            if(best.tick == ~ uint64_t(0))
            {
                break;
            }
            auto s = & state[best.i];
            if(s->first)
            {
                print(">> begin log ", best.i);
                if(s->lost != 0)
                {
                    print("; lost first ", s->lost >> 10, "KB");
                }
                print(" <<\n");
                s->first = false;
            }
            auto [end, _, nano, p] = header(gocpp::recv(s));
            auto oldEnd = s->end;
            s->end = end;
            print("[");
            gocpp::array<unsigned char, 21> tmpbuf = {};
            auto pnano = int64_t(nano) - runtimeInitTime;
            if(pnano < 0)
            {
                pnano = 0;
            }
            auto pnanoBytes = itoaDiv(tmpbuf.make_slice(0, ), uint64_t(pnano), 9);
            print(slicebytetostringtmp((unsigned char*)(noescape(unsafe::Pointer(& pnanoBytes[0]))), len(pnanoBytes)));
            print(" P ", p, "] ");
            for(auto i = 0; s->begin < s->end; i++)
            {
                if(i > 0)
                {
                    print(" ");
                }
                if(! printVal(gocpp::recv(s)))
                {
                    print("<aborting P log>");
                    end = oldEnd;
                    break;
                }
            }
            println();
            s->begin = end;
            s->end = oldEnd;
            s->nextTick = peek(gocpp::recv(s));
        }
        printunlock();
    }

    void printDebugLogPC(uintptr_t pc, bool returnPC)
    {
        auto fn = findfunc(pc);
        if(returnPC && (! valid(gocpp::recv(fn)) || pc > entry(gocpp::recv(fn))))
        {
            pc--;
        }
        print(hex(pc));
        if(! valid(gocpp::recv(fn)))
        {
            print(" [unknown PC]");
        }
        else
        {
            auto name = funcname(fn);
            auto [file, line] = funcline(fn, pc);
            print(" [", name, "+", hex(pc - entry(gocpp::recv(fn))), " ", file, ":", line, "]");
        }
    }

}

