// generated by GoCpp from file '$(ImportDir)/runtime/mgclimit.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgclimit.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using atomic::rec::Swap;
    }

    gcCPULimiterState gcCPULimiter;
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.fill = this->fill;
        result.capacity = this->capacity;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (fill != ref.fill) return false;
        if (capacity != ref.capacity) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fill;
        os << " " << capacity;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    gcCPULimiterState::operator T()
    {
        T result;
        result.lock = this->lock;
        result.enabled = this->enabled;
        result.bucket = this->bucket;
        result.overflow = this->overflow;
        result.gcEnabled = this->gcEnabled;
        result.transitioning = this->transitioning;
        result.assistTimePool = this->assistTimePool;
        result.idleMarkTimePool = this->idleMarkTimePool;
        result.idleTimePool = this->idleTimePool;
        result.lastUpdate = this->lastUpdate;
        result.lastEnabledCycle = this->lastEnabledCycle;
        result.nprocs = this->nprocs;
        result.test = this->test;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcCPULimiterState::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (enabled != ref.enabled) return false;
        if (bucket != ref.bucket) return false;
        if (overflow != ref.overflow) return false;
        if (gcEnabled != ref.gcEnabled) return false;
        if (transitioning != ref.transitioning) return false;
        if (assistTimePool != ref.assistTimePool) return false;
        if (idleMarkTimePool != ref.idleMarkTimePool) return false;
        if (idleTimePool != ref.idleTimePool) return false;
        if (lastUpdate != ref.lastUpdate) return false;
        if (lastEnabledCycle != ref.lastEnabledCycle) return false;
        if (nprocs != ref.nprocs) return false;
        if (test != ref.test) return false;
        return true;
    }

    std::ostream& gcCPULimiterState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << enabled;
        os << " " << bucket;
        os << " " << overflow;
        os << " " << gcEnabled;
        os << " " << transitioning;
        os << " " << assistTimePool;
        os << " " << idleMarkTimePool;
        os << " " << idleTimePool;
        os << " " << lastUpdate;
        os << " " << lastEnabledCycle;
        os << " " << nprocs;
        os << " " << test;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcCPULimiterState& value)
    {
        return value.PrintTo(os);
    }

    bool rec::limiting(struct gcCPULimiterState* l)
    {
        return rec::Load(gocpp::recv(l->enabled));
    }

    void rec::startGCTransition(struct gcCPULimiterState* l, bool enableGC, int64_t now)
    {
        if(! rec::tryLock(gocpp::recv(l)))
        {
            go_throw("failed to acquire lock to start a GC transition");
        }
        if(l->gcEnabled == enableGC)
        {
            go_throw("transitioning GC to the same state as before?");
        }
        rec::updateLocked(gocpp::recv(l), now);
        l->gcEnabled = enableGC;
        l->transitioning = true;
    }

    void rec::finishGCTransition(struct gcCPULimiterState* l, int64_t now)
    {
        if(! l->transitioning)
        {
            go_throw("finishGCTransition called without starting one?");
        }
        if(auto lastUpdate = rec::Load(gocpp::recv(l->lastUpdate)); now >= lastUpdate)
        {
            rec::accumulate(gocpp::recv(l), 0, (now - lastUpdate) * int64_t(l->nprocs));
        }
        rec::Store(gocpp::recv(l->lastUpdate), now);
        l->transitioning = false;
        rec::unlock(gocpp::recv(l));
    }

    bool rec::needUpdate(struct gcCPULimiterState* l, int64_t now)
    {
        return now - rec::Load(gocpp::recv(l->lastUpdate)) > gcCPULimiterUpdatePeriod;
    }

    void rec::addAssistTime(struct gcCPULimiterState* l, int64_t t)
    {
        rec::Add(gocpp::recv(l->assistTimePool), t);
    }

    void rec::addIdleTime(struct gcCPULimiterState* l, int64_t t)
    {
        rec::Add(gocpp::recv(l->idleTimePool), t);
    }

    void rec::update(struct gcCPULimiterState* l, int64_t now)
    {
        if(! rec::tryLock(gocpp::recv(l)))
        {
            return;
        }
        if(l->transitioning)
        {
            go_throw("update during transition");
        }
        rec::updateLocked(gocpp::recv(l), now);
        rec::unlock(gocpp::recv(l));
    }

    void rec::updateLocked(struct gcCPULimiterState* l, int64_t now)
    {
        auto lastUpdate = rec::Load(gocpp::recv(l->lastUpdate));
        if(now < lastUpdate)
        {
            return;
        }
        auto windowTotalTime = (now - lastUpdate) * int64_t(l->nprocs);
        rec::Store(gocpp::recv(l->lastUpdate), now);
        auto assistTime = rec::Load(gocpp::recv(l->assistTimePool));
        if(assistTime != 0)
        {
            rec::Add(gocpp::recv(l->assistTimePool), - assistTime);
        }
        auto idleTime = rec::Load(gocpp::recv(l->idleTimePool));
        if(idleTime != 0)
        {
            rec::Add(gocpp::recv(l->idleTimePool), - idleTime);
        }
        if(! l->test)
        {
            auto mp = acquirem();
            for(auto [gocpp_ignored, pp] : allp)
            {
                auto [typ, duration] = rec::consume(gocpp::recv(pp->limiterEvent), now);
                //Go switch emulation
                {
                    auto condition = typ;
                    int conditionId = -1;
                    if(condition == limiterEventIdleMarkWork) { conditionId = 0; }
                    else if(condition == limiterEventIdle) { conditionId = 1; }
                    else if(condition == limiterEventMarkAssist) { conditionId = 2; }
                    else if(condition == limiterEventScavengeAssist) { conditionId = 3; }
                    else if(condition == limiterEventNone) { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                        case 1:
                            idleTime += duration;
                            rec::Add(gocpp::recv(sched.idleTime), duration);
                            break;
                        case 2:
                        case 3:
                            assistTime += duration;
                            break;
                        case 4:
                            break;
                            break;
                        default:
                            go_throw("invalid limiter event type found");
                            break;
                    }
                }
            }
            releasem(mp);
        }
        auto windowGCTime = assistTime;
        if(l->gcEnabled)
        {
            windowGCTime += int64_t(double(windowTotalTime) * gcBackgroundUtilization);
        }
        windowTotalTime -= idleTime;
        rec::accumulate(gocpp::recv(l), windowTotalTime - windowGCTime, windowGCTime);
    }

    void rec::accumulate(struct gcCPULimiterState* l, int64_t mutatorTime, int64_t gcTime)
    {
        auto headroom = l->bucket.capacity - l->bucket.fill;
        auto enabled = headroom == 0;
        auto change = gcTime - mutatorTime;
        if(change > 0 && headroom <= uint64_t(change))
        {
            l->overflow += uint64_t(change) - headroom;
            l->bucket.fill = l->bucket.capacity;
            if(! enabled)
            {
                rec::Store(gocpp::recv(l->enabled), true);
                rec::Store(gocpp::recv(l->lastEnabledCycle), memstats.numgc + 1);
            }
            return;
        }
        if(change < 0 && l->bucket.fill <= uint64_t(- change))
        {
            l->bucket.fill = 0;
        }
        else
        {
            l->bucket.fill -= uint64_t(- change);
        }
        if(change != 0 && enabled)
        {
            rec::Store(gocpp::recv(l->enabled), false);
        }
    }

    bool rec::tryLock(struct gcCPULimiterState* l)
    {
        return rec::CompareAndSwap(gocpp::recv(l->lock), 0, 1);
    }

    void rec::unlock(struct gcCPULimiterState* l)
    {
        auto old = rec::Swap(gocpp::recv(l->lock), 0);
        if(old != 1)
        {
            go_throw("double unlock");
        }
    }

    void rec::resetCapacity(struct gcCPULimiterState* l, int64_t now, int32_t nprocs)
    {
        if(! rec::tryLock(gocpp::recv(l)))
        {
            go_throw("failed to acquire lock to reset capacity");
        }
        rec::updateLocked(gocpp::recv(l), now);
        l->nprocs = nprocs;
        l->bucket.capacity = uint64_t(nprocs) * capacityPerProc;
        if(l->bucket.fill > l->bucket.capacity)
        {
            l->bucket.fill = l->bucket.capacity;
            rec::Store(gocpp::recv(l->enabled), true);
            rec::Store(gocpp::recv(l->lastEnabledCycle), memstats.numgc + 1);
        }
        else
        if(l->bucket.fill < l->bucket.capacity)
        {
            rec::Store(gocpp::recv(l->enabled), false);
        }
        rec::unlock(gocpp::recv(l));
    }

    runtime::limiterEventStamp makeLimiterEventStamp(golang::runtime::limiterEventType typ, int64_t now)
    {
        return limiterEventStamp((uint64_t(typ) << (64 - limiterEventBits)) | (uint64_t(now) &^ limiterEventTypeMask));
    }

    int64_t rec::duration(golang::runtime::limiterEventStamp s, int64_t now)
    {
        auto start = int64_t((uint64_t(now) & limiterEventTypeMask) | (uint64_t(s) &^ limiterEventTypeMask));
        if(now < start)
        {
            return 0;
        }
        return now - start;
    }

    runtime::limiterEventType rec::typ(golang::runtime::limiterEventStamp s)
    {
        return limiterEventType(s >> (64 - limiterEventBits));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    limiterEvent::operator T()
    {
        T result;
        result.stamp = this->stamp;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool limiterEvent::operator==(const T& ref) const
    {
        if (stamp != ref.stamp) return false;
        return true;
    }

    std::ostream& limiterEvent::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stamp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct limiterEvent& value)
    {
        return value.PrintTo(os);
    }

    bool rec::start(struct limiterEvent* e, golang::runtime::limiterEventType typ, int64_t now)
    {
        if(rec::typ(gocpp::recv(limiterEventStamp(rec::Load(gocpp::recv(e->stamp))))) != limiterEventNone)
        {
            return false;
        }
        rec::Store(gocpp::recv(e->stamp), uint64_t(makeLimiterEventStamp(typ, now)));
        return true;
    }

    std::tuple<runtime::limiterEventType, int64_t> rec::consume(struct limiterEvent* e, int64_t now)
    {
        runtime::limiterEventType typ;
        int64_t duration;
        for(; ; )
        {
            runtime::limiterEventType typ;
            int64_t duration;
            auto old = limiterEventStamp(rec::Load(gocpp::recv(e->stamp)));
            typ = rec::typ(gocpp::recv(old));
            if(typ == limiterEventNone)
            {
                runtime::limiterEventType typ;
                int64_t duration;
                return {typ, duration};
            }
            duration = rec::duration(gocpp::recv(old), now);
            if(duration == 0)
            {
                runtime::limiterEventType typ;
                int64_t duration;
                return {limiterEventNone, 0};
            }
            auto go_new = makeLimiterEventStamp(typ, now);
            if(rec::CompareAndSwap(gocpp::recv(e->stamp), uint64_t(old), uint64_t(go_new)))
            {
                runtime::limiterEventType typ;
                int64_t duration;
                break;
            }
        }
        return {typ, duration};
    }

    void rec::stop(struct limiterEvent* e, golang::runtime::limiterEventType typ, int64_t now)
    {
        runtime::limiterEventStamp stamp = {};
        for(; ; )
        {
            stamp = limiterEventStamp(rec::Load(gocpp::recv(e->stamp)));
            if(rec::typ(gocpp::recv(stamp)) != typ)
            {
                print("runtime: want=", typ, " got=", rec::typ(gocpp::recv(stamp)), "\n");
                go_throw("limiterEvent.stop: found wrong event in p's limiter event slot");
            }
            if(rec::CompareAndSwap(gocpp::recv(e->stamp), uint64_t(stamp), uint64_t(limiterEventStampNone)))
            {
                break;
            }
        }
        auto duration = rec::duration(gocpp::recv(stamp), now);
        if(duration == 0)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == limiterEventIdleMarkWork) { conditionId = 0; }
            else if(condition == limiterEventIdle) { conditionId = 1; }
            else if(condition == limiterEventMarkAssist) { conditionId = 2; }
            else if(condition == limiterEventScavengeAssist) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    rec::addIdleTime(gocpp::recv(gcCPULimiter), duration);
                    break;
                case 1:
                    rec::addIdleTime(gocpp::recv(gcCPULimiter), duration);
                    rec::Add(gocpp::recv(sched.idleTime), duration);
                    break;
                case 2:
                case 3:
                    rec::addAssistTime(gocpp::recv(gcCPULimiter), duration);
                    break;
                default:
                    go_throw("limiterEvent.stop: invalid limiter event type found");
                    break;
            }
        }
    }

}

