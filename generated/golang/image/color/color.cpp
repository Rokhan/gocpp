// generated by GoCpp from file '$(ImportDir)/image/color/color.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/color/color.h"
#include "gocpp/support.h"

namespace golang::color
{
    
    template<typename T>
    Color::Color(T& ref)
    {
        value.reset(new ColorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Color::Color(const T& ref)
    {
        value.reset(new ColorImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Color::Color(T* ptr)
    {
        value.reset(new ColorImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Color::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> Color::ColorImpl<T, StoreT>::vRGBA()
    {
        return RGBA(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(const gocpp::PtrRecv<Color, false>& self)
    {
        return self.ptr->value->vRGBA();
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(const gocpp::ObjRecv<Color>& self)
    {
        return self.obj.value->vRGBA();
    }

    std::ostream& operator<<(std::ostream& os, const struct Color& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RGBA::operator T()
    {
        T result;
        result.R = this->R;
        result.G = this->G;
        result.B = this->B;
        result.A = this->A;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RGBA::operator==(const T& ref) const
    {
        if (R != ref.R) return false;
        if (G != ref.G) return false;
        if (B != ref.B) return false;
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& RGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << G;
        os << " " << B;
        os << " " << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct RGBA c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        r = uint32_t(c.R);
        r |= r << 8;
        g = uint32_t(c.G);
        g |= g << 8;
        b = uint32_t(c.B);
        b |= b << 8;
        a = uint32_t(c.A);
        a |= a << 8;
        return {r, g, b, a};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RGBA64::operator T()
    {
        T result;
        result.R = this->R;
        result.G = this->G;
        result.B = this->B;
        result.A = this->A;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RGBA64::operator==(const T& ref) const
    {
        if (R != ref.R) return false;
        if (G != ref.G) return false;
        if (B != ref.B) return false;
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& RGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << G;
        os << " " << B;
        os << " " << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct RGBA64 c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        return {uint32_t(c.R), uint32_t(c.G), uint32_t(c.B), uint32_t(c.A)};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    NRGBA::operator T()
    {
        T result;
        result.R = this->R;
        result.G = this->G;
        result.B = this->B;
        result.A = this->A;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NRGBA::operator==(const T& ref) const
    {
        if (R != ref.R) return false;
        if (G != ref.G) return false;
        if (B != ref.B) return false;
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& NRGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << G;
        os << " " << B;
        os << " " << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct NRGBA c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        r = uint32_t(c.R);
        r |= r << 8;
        r *= uint32_t(c.A);
        r /= 0xff;
        g = uint32_t(c.G);
        g |= g << 8;
        g *= uint32_t(c.A);
        g /= 0xff;
        b = uint32_t(c.B);
        b |= b << 8;
        b *= uint32_t(c.A);
        b /= 0xff;
        a = uint32_t(c.A);
        a |= a << 8;
        return {r, g, b, a};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    NRGBA64::operator T()
    {
        T result;
        result.R = this->R;
        result.G = this->G;
        result.B = this->B;
        result.A = this->A;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NRGBA64::operator==(const T& ref) const
    {
        if (R != ref.R) return false;
        if (G != ref.G) return false;
        if (B != ref.B) return false;
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& NRGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << R;
        os << " " << G;
        os << " " << B;
        os << " " << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct NRGBA64 c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        r = uint32_t(c.R);
        r *= uint32_t(c.A);
        r /= 0xffff;
        g = uint32_t(c.G);
        g *= uint32_t(c.A);
        g /= 0xffff;
        b = uint32_t(c.B);
        b *= uint32_t(c.A);
        b /= 0xffff;
        a = uint32_t(c.A);
        return {r, g, b, a};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Alpha::operator T()
    {
        T result;
        result.A = this->A;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Alpha::operator==(const T& ref) const
    {
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& Alpha::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Alpha c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        a = uint32_t(c.A);
        a |= a << 8;
        return {a, a, a, a};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Alpha16::operator T()
    {
        T result;
        result.A = this->A;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Alpha16::operator==(const T& ref) const
    {
        if (A != ref.A) return false;
        return true;
    }

    std::ostream& Alpha16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << A;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Alpha16 c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        a = uint32_t(c.A);
        return {a, a, a, a};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Gray::operator T()
    {
        T result;
        result.Y = this->Y;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Gray::operator==(const T& ref) const
    {
        if (Y != ref.Y) return false;
        return true;
    }

    std::ostream& Gray::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Y;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Gray c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        auto y = uint32_t(c.Y);
        y |= y << 8;
        return {y, y, y, 0xffff};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Gray16::operator T()
    {
        T result;
        result.Y = this->Y;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Gray16::operator==(const T& ref) const
    {
        if (Y != ref.Y) return false;
        return true;
    }

    std::ostream& Gray16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Y;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(struct Gray16 c)
    {
        uint32_t r;
        uint32_t g;
        uint32_t b;
        uint32_t a;
        auto y = uint32_t(c.Y);
        return {y, y, y, 0xffff};
    }

    
    template<typename T>
    Model::Model(T& ref)
    {
        value.reset(new ModelImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Model::Model(const T& ref)
    {
        value.reset(new ModelImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Model::Model(T* ptr)
    {
        value.reset(new ModelImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Model::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    Color Model::ModelImpl<T, StoreT>::vConvert(Color c)
    {
        return Convert(gocpp::PtrRecv<T, false>(value.get()), c);
    }

    Color Convert(const gocpp::PtrRecv<Model, false>& self, Color c)
    {
        return self.ptr->value->vConvert(c);
    }

    Color Convert(const gocpp::ObjRecv<Model>& self, Color c)
    {
        return self.obj.value->vConvert(c);
    }

    std::ostream& operator<<(std::ostream& os, const struct Model& value)
    {
        return value.PrintTo(os);
    }

    Model ModelFunc(std::function<Color (Color)> f)
    {
        return new modelFunc {f};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    modelFunc::operator T()
    {
        T result;
        result.f = this->f;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool modelFunc::operator==(const T& ref) const
    {
        if (f != ref.f) return false;
        return true;
    }

    std::ostream& modelFunc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << f;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct modelFunc& value)
    {
        return value.PrintTo(os);
    }

    Color Convert(struct modelFunc* m, Color c)
    {
        return f(gocpp::recv(m), c);
    }

    Model RGBAModel = ModelFunc(rgbaModel);
    Model RGBA64Model = ModelFunc(rgba64Model);
    Model NRGBAModel = ModelFunc(nrgbaModel);
    Model NRGBA64Model = ModelFunc(nrgba64Model);
    Model AlphaModel = ModelFunc(alphaModel);
    Model Alpha16Model = ModelFunc(alpha16Model);
    Model GrayModel = ModelFunc(grayModel);
    Model Gray16Model = ModelFunc(gray16Model);
    Color rgbaModel(Color c)
    {
        if(auto [gocpp_id_1, ok] = gocpp::getValue<RGBA>(c); ok)
        {
            return c;
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        return RGBA {uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8), uint8_t(a >> 8)};
    }

    Color rgba64Model(Color c)
    {
        if(auto [gocpp_id_3, ok] = gocpp::getValue<RGBA64>(c); ok)
        {
            return c;
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        return RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    Color nrgbaModel(Color c)
    {
        if(auto [gocpp_id_5, ok] = gocpp::getValue<NRGBA>(c); ok)
        {
            return c;
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        if(a == 0xffff)
        {
            return NRGBA {uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8), 0xff};
        }
        if(a == 0)
        {
            return NRGBA {0, 0, 0, 0};
        }
        r = (r * 0xffff) / a;
        g = (g * 0xffff) / a;
        b = (b * 0xffff) / a;
        return NRGBA {uint8_t(r >> 8), uint8_t(g >> 8), uint8_t(b >> 8), uint8_t(a >> 8)};
    }

    Color nrgba64Model(Color c)
    {
        if(auto [gocpp_id_7, ok] = gocpp::getValue<NRGBA64>(c); ok)
        {
            return c;
        }
        auto [r, g, b, a] = RGBA(gocpp::recv(c));
        if(a == 0xffff)
        {
            return NRGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), 0xffff};
        }
        if(a == 0)
        {
            return NRGBA64 {0, 0, 0, 0};
        }
        r = (r * 0xffff) / a;
        g = (g * 0xffff) / a;
        b = (b * 0xffff) / a;
        return NRGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    Color alphaModel(Color c)
    {
        if(auto [gocpp_id_9, ok] = gocpp::getValue<Alpha>(c); ok)
        {
            return c;
        }
        auto [gocpp_id_13, gocpp_id_14, gocpp_id_15, a] = RGBA(gocpp::recv(c));
        return Alpha {uint8_t(a >> 8)};
    }

    Color alpha16Model(Color c)
    {
        if(auto [gocpp_id_17, ok] = gocpp::getValue<Alpha16>(c); ok)
        {
            return c;
        }
        auto [gocpp_id_21, gocpp_id_22, gocpp_id_23, a] = RGBA(gocpp::recv(c));
        return Alpha16 {uint16_t(a)};
    }

    Color grayModel(Color c)
    {
        if(auto [gocpp_id_25, ok] = gocpp::getValue<Gray>(c); ok)
        {
            return c;
        }
        auto [r, g, b, gocpp_id_27] = RGBA(gocpp::recv(c));
        auto y = (19595 * r + 38470 * g + 7471 * b + (1 << 15)) >> 24;
        return Gray {uint8_t(y)};
    }

    Color gray16Model(Color c)
    {
        if(auto [gocpp_id_29, ok] = gocpp::getValue<Gray16>(c); ok)
        {
            return c;
        }
        auto [r, g, b, gocpp_id_31] = RGBA(gocpp::recv(c));
        auto y = (19595 * r + 38470 * g + 7471 * b + (1 << 15)) >> 16;
        return Gray16 {uint16_t(y)};
    }

    Color Convert(Palette p, Color c)
    {
        if(len(p) == 0)
        {
            return nullptr;
        }
        return p[Index(gocpp::recv(p), c)];
    }

    int Index(Palette p, Color c)
    {
        auto [cr, cg, cb, ca] = RGBA(gocpp::recv(c));
        auto [ret, bestSum] = std::tuple{0, uint32_t((1 << 32) - 1)};
        for(auto [i, v] : p)
        {
            auto [vr, vg, vb, va] = RGBA(gocpp::recv(v));
            auto sum = sqDiff(cr, vr) + sqDiff(cg, vg) + sqDiff(cb, vb) + sqDiff(ca, va);
            if(sum < bestSum)
            {
                if(sum == 0)
                {
                    return i;
                }
                std::tie(ret, bestSum) = std::tuple{i, sum};
            }
        }
        return ret;
    }

    uint32_t sqDiff(uint32_t x, uint32_t y)
    {
        auto d = x - y;
        return (d * d) >> 2;
    }

    Gray16 Black = Gray16 {0};
    Gray16 White = Gray16 {0xffff};
    Alpha16 Transparent = Alpha16 {0};
    Alpha16 Opaque = Alpha16 {0xffff};
}

