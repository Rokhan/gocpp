// generated by GoCpp from file '$(ImportDir)/reflect/value.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/value.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/unsafeheader/unsafeheader.h"
#include "golang/reflect/makefunc.h"
#include "golang/reflect/type.h"
#include "golang/sync/cond.h"
#include "golang/sync/pool.h"

namespace golang::reflect
{
    struct Value
    {
        abi::Type* typ_;
        unsafe::Pointer ptr;
        golang::reflect::flag flag;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Value& value);
    go_any packEface(struct Value v);
    struct Value unpackEface(go_any i);
    struct ValueError
    {
        std::string Method;
        golang::reflect::Kind Kind;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value);
    std::string valueMethodName();
    struct emptyInterface
    {
        abi::Type* typ;
        unsafe::Pointer word;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value);
    struct gocpp_id_0
    {
        abi::Type* ityp;
        abi::Type* typ;
        uint32_t hash;
        gocpp::array<unsigned char, 4> _1;
        gocpp::array<unsafe::Pointer, 100000> fun;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value);
    struct nonEmptyInterface
    {
        gocpp_id_0* itab;
        unsafe::Pointer word;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct nonEmptyInterface& value);
    extern abi::Type* bytesType;
    extern bool callGC;
    void callReflect(struct makeFuncImpl* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs);
    std::tuple<abi::Type*, reflect::funcType*, unsafe::Pointer> methodReceiver(std::string op, struct Value v, int methodIndex);
    void storeRcvr(struct Value v, unsafe::Pointer p);
    uintptr_t align(uintptr_t x, uintptr_t n);
    void callMethod(struct methodValue* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs);
    std::string funcName(std::function<gocpp::slice<Value> (gocpp::slice<Value> _1)> f);
    struct gocpp_id_5 : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        gocpp_id_5(){}
        gocpp_id_5(gocpp_id_5& i) = default;
        gocpp_id_5(const gocpp_id_5& i) = default;
        gocpp_id_5& operator=(gocpp_id_5& i) = default;
        gocpp_id_5& operator=(const gocpp_id_5& i) = default;

        template<typename T>
        gocpp_id_5(T& ref);

        template<typename T>
        gocpp_id_5(const T& ref);

        template<typename T>
        gocpp_id_5(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_5
        {
            virtual void vM() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_5Impl : Igocpp_id_5
        {
            explicit gocpp_id_5Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_5> value;
    };

    namespace rec
    {
        void M(const gocpp::PtrRecv<struct gocpp_id_5, false>& self);
        void M(const gocpp::ObjRecv<struct gocpp_id_5>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_5& value);
    extern abi::Type* uint8Type;
    go_any valueInterface(struct Value v, bool safe);
    struct gocpp_id_6 : gocpp::Interface
    {
        using gocpp::Interface::operator==;
        using gocpp::Interface::operator!=;

        gocpp_id_6(){}
        gocpp_id_6(gocpp_id_6& i) = default;
        gocpp_id_6(const gocpp_id_6& i) = default;
        gocpp_id_6& operator=(gocpp_id_6& i) = default;
        gocpp_id_6& operator=(const gocpp_id_6& i) = default;

        template<typename T>
        gocpp_id_6(T& ref);

        template<typename T>
        gocpp_id_6(const T& ref);

        template<typename T>
        gocpp_id_6(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Igocpp_id_6
        {
            virtual void vM() = 0;
        };

        template<typename T, typename StoreT>
        struct gocpp_id_6Impl : Igocpp_id_6
        {
            explicit gocpp_id_6Impl(T* ptr)
            {
                value.reset(ptr);
            }

            void vM() override;

            StoreT value;
        };

        std::shared_ptr<Igocpp_id_6> value;
    };

    namespace rec
    {
        void M(const gocpp::PtrRecv<struct gocpp_id_6, false>& self);
        void M(const gocpp::ObjRecv<struct gocpp_id_6>& self);
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value);
    bool isZero(gocpp::slice<unsigned char> b);
    extern abi::Type* stringType;
    struct hiter
    {
        unsafe::Pointer key;
        unsafe::Pointer elem;
        unsafe::Pointer t;
        unsafe::Pointer h;
        unsafe::Pointer buckets;
        unsafe::Pointer bptr;
        gocpp::slice<unsafe::Pointer>* overflow;
        gocpp::slice<unsafe::Pointer>* oldoverflow;
        uintptr_t startBucket;
        uint8_t offset;
        bool wrapped;
        uint8_t B;
        uint8_t i;
        uintptr_t bucket;
        uintptr_t checkBucket;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct hiter& value);
    struct Value copyVal(abi::Type* typ, golang::reflect::flag fl, unsafe::Pointer ptr);
    bool overflowFloat32(double x);
    struct StringHeader
    {
        uintptr_t Data;
        int Len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StringHeader& value);
    struct SliceHeader
    {
        uintptr_t Data;
        int Len;
        int Cap;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SliceHeader& value);
    void typesMustMatch(std::string what, struct Type t1, struct Type t2);
    unsafe::Pointer arrayAt(unsafe::Pointer p, int i, uintptr_t eltSize, std::string whySafe);
    struct Value Append(struct Value s, gocpp::slice<Value> x);
    
    template<typename... Args>
    struct Value Append(struct Value s, Args... x)
    {
        return Append(s, gocpp::ToSlice<Value>(x...));
    }
    
    template<typename... Args>
    struct Value Append(struct Value s, Value value, Args... x)
    {
        return Append(s, gocpp::ToSlice<Value>(value, x...));
    }
    struct Value AppendSlice(struct Value s, struct Value t);
    int Copy(struct Value dst, struct Value src);
    struct runtimeSelect
    {
        golang::reflect::SelectDir dir;
        rtype* typ;
        unsafe::Pointer ch;
        unsafe::Pointer val;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct runtimeSelect& value);
    std::tuple<int, bool> rselect(gocpp::slice<runtimeSelect>);
    std::tuple<int, struct Value, bool> Select(gocpp::slice<SelectCase> cases);
    unsafe::Pointer unsafe_New(abi::Type*);
    unsafe::Pointer unsafe_NewArray(abi::Type*, int);
    struct Value MakeSlice(struct Type typ, int len, int cap);
    struct Value MakeChan(struct Type typ, int buffer);
    struct Value MakeMap(struct Type typ);
    struct Value MakeMapWithSize(struct Type typ, int n);
    struct Value Indirect(struct Value v);
    struct Value ValueOf(go_any i);
    struct Value Zero(struct Type typ);
    extern gocpp::array<unsigned char, abi::ZeroValSize> zeroVal;
    struct Value New(struct Type typ);
    struct Value NewAt(struct Type typ, unsafe::Pointer p);
    std::function<struct Value (struct Value _1, struct Type _2)> convertOp(abi::Type* dst, abi::Type* src);
    struct Value makeInt(golang::reflect::flag f, uint64_t bits, struct Type t);
    struct Value makeFloat(golang::reflect::flag f, double v, struct Type t);
    struct Value makeFloat32(golang::reflect::flag f, double v, struct Type t);
    struct Value makeComplex(golang::reflect::flag f, struct gocpp::complex128 v, struct Type t);
    struct Value makeString(golang::reflect::flag f, std::string v, struct Type t);
    struct Value makeBytes(golang::reflect::flag f, gocpp::slice<unsigned char> v, struct Type t);
    struct Value makeRunes(golang::reflect::flag f, gocpp::slice<gocpp::rune> v, struct Type t);
    struct Value cvtInt(struct Value v, struct Type t);
    struct Value cvtUint(struct Value v, struct Type t);
    struct Value cvtFloatInt(struct Value v, struct Type t);
    struct Value cvtFloatUint(struct Value v, struct Type t);
    struct Value cvtIntFloat(struct Value v, struct Type t);
    struct Value cvtUintFloat(struct Value v, struct Type t);
    struct Value cvtFloat(struct Value v, struct Type t);
    struct Value cvtComplex(struct Value v, struct Type t);
    struct Value cvtIntString(struct Value v, struct Type t);
    struct Value cvtUintString(struct Value v, struct Type t);
    struct Value cvtBytesString(struct Value v, struct Type t);
    struct Value cvtStringBytes(struct Value v, struct Type t);
    struct Value cvtRunesString(struct Value v, struct Type t);
    struct Value cvtStringRunes(struct Value v, struct Type t);
    struct Value cvtSliceArrayPtr(struct Value v, struct Type t);
    struct Value cvtSliceArray(struct Value v, struct Type t);
    struct Value cvtDirect(struct Value v, struct Type typ);
    struct Value cvtT2I(struct Value v, struct Type typ);
    struct Value cvtI2I(struct Value v, struct Type typ);
    int chancap(unsafe::Pointer ch);
    void chanclose(unsafe::Pointer ch);
    int chanlen(unsafe::Pointer ch);
    std::tuple<bool, bool> chanrecv(unsafe::Pointer ch, bool nb, unsafe::Pointer val);
    bool chansend0(unsafe::Pointer ch, unsafe::Pointer val, bool nb);
    bool chansend(unsafe::Pointer ch, unsafe::Pointer val, bool nb);
    unsafe::Pointer makechan(abi::Type* typ, int size);
    unsafe::Pointer makemap(abi::Type* t, int cap);
    unsafe::Pointer mapaccess(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key);
    unsafe::Pointer mapaccess_faststr(abi::Type* t, unsafe::Pointer m, std::string key);
    void mapassign0(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key, unsafe::Pointer val);
    void mapassign(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key, unsafe::Pointer val);
    void mapassign_faststr0(abi::Type* t, unsafe::Pointer m, std::string key, unsafe::Pointer val);
    void mapassign_faststr(abi::Type* t, unsafe::Pointer m, std::string key, unsafe::Pointer val);
    void mapdelete(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key);
    void mapdelete_faststr(abi::Type* t, unsafe::Pointer m, std::string key);
    void mapiterinit(abi::Type* t, unsafe::Pointer m, struct hiter* it);
    unsafe::Pointer mapiterkey(struct hiter* it);
    unsafe::Pointer mapiterelem(struct hiter* it);
    void mapiternext(struct hiter* it);
    int maplen(unsafe::Pointer m);
    void mapclear(abi::Type* t, unsafe::Pointer m);
    void call(abi::Type* stackArgsType, unsafe::Pointer f, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs);
    void ifaceE2I(abi::Type* t, go_any src, unsafe::Pointer dst);
    void memmove(unsafe::Pointer dst, unsafe::Pointer src, uintptr_t size);
    void typedmemmove(abi::Type* t, unsafe::Pointer dst, unsafe::Pointer src);
    void typedmemclr(abi::Type* t, unsafe::Pointer ptr);
    void typedmemclrpartial(abi::Type* t, unsafe::Pointer ptr, uintptr_t off, uintptr_t size);
    int typedslicecopy(abi::Type* t, unsafeheader::Slice dst, unsafeheader::Slice src);
    void typedarrayclear(abi::Type* elemType, unsafe::Pointer ptr, int len);
    uintptr_t typehash(abi::Type* t, unsafe::Pointer p, uintptr_t h);
    bool verifyNotInHeapPtr(uintptr_t p);
    unsafeheader::Slice growslice(abi::Type* t, unsafeheader::Slice old, int num);
    void escapes(go_any x);
    extern gocpp_id_7 dummy;
    void contentEscapes(unsafe::Pointer x);
    unsafe::Pointer noescape(unsafe::Pointer p);
    struct MapIter
    {
        Value m;
        hiter hiter;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MapIter& value);
    struct SelectCase
    {
        golang::reflect::SelectDir Dir;
        Value Chan;
        Value Send;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SelectCase& value);

    namespace rec
    {
        reflect::Kind kind(golang::reflect::flag f);
        reflect::flag ro(golang::reflect::flag f);
        abi::Type* typ(struct Value v);
        unsafe::Pointer pointer(struct Value v);
        std::string Error(struct ValueError* e);
        void mustBe(golang::reflect::flag f, golang::reflect::Kind expected);
        void mustBeExported(golang::reflect::flag f);
        void mustBeExportedSlow(golang::reflect::flag f);
        void mustBeAssignable(golang::reflect::flag f);
        void mustBeAssignableSlow(golang::reflect::flag f);
        struct Value Addr(struct Value v);
        bool Bool(struct Value v);
        void panicNotBool(struct Value v);
        gocpp::slice<unsigned char> Bytes(struct Value v);
        gocpp::slice<unsigned char> bytesSlow(struct Value v);
        gocpp::slice<gocpp::rune> runes(struct Value v);
        bool CanAddr(struct Value v);
        bool CanSet(struct Value v);
        gocpp::slice<Value> Call(struct Value v, gocpp::slice<Value> in);
        gocpp::slice<Value> CallSlice(struct Value v, gocpp::slice<Value> in);
        gocpp::slice<Value> call(struct Value v, std::string op, gocpp::slice<Value> in);
        int Cap(struct Value v);
        int capNonSlice(struct Value v);
        void Close(struct Value v);
        bool CanComplex(struct Value v);
        struct gocpp::complex128 Complex(struct Value v);
        struct Value Elem(struct Value v);
        struct Value Field(struct Value v, int i);
        struct Value FieldByIndex(struct Value v, gocpp::slice<int> index);
        std::tuple<struct Value, struct gocpp::error> FieldByIndexErr(struct Value v, gocpp::slice<int> index);
        struct Value FieldByName(struct Value v, std::string name);
        struct Value FieldByNameFunc(struct Value v, std::function<bool (std::string _1)> match);
        bool CanFloat(struct Value v);
        double Float(struct Value v);
        struct Value Index(struct Value v, int i);
        bool CanInt(struct Value v);
        int64_t Int(struct Value v);
        bool CanInterface(struct Value v);
        go_any Interface(struct Value v);
        gocpp::array<uintptr_t, 2> InterfaceData(struct Value v);
        bool IsNil(struct Value v);
        bool IsValid(struct Value v);
        bool IsZero(struct Value v);
        void SetZero(struct Value v);
        reflect::Kind Kind(struct Value v);
        int Len(struct Value v);
        int lenNonSlice(struct Value v);
        struct Value MapIndex(struct Value v, struct Value key);
        gocpp::slice<Value> MapKeys(struct Value v);
        bool initialized(struct hiter* h);
        struct Value Key(struct MapIter* iter);
        void SetIterKey(struct Value v, struct MapIter* iter);
        struct Value Value(struct MapIter* iter);
        void SetIterValue(struct Value v, struct MapIter* iter);
        bool Next(struct MapIter* iter);
        void Reset(struct MapIter* iter, struct Value v);
        struct MapIter* MapRange(struct Value v);
        void panicNotMap(golang::reflect::flag f);
        struct Value Method(struct Value v, int i);
        int NumMethod(struct Value v);
        struct Value MethodByName(struct Value v, std::string name);
        int NumField(struct Value v);
        bool OverflowComplex(struct Value v, struct gocpp::complex128 x);
        bool OverflowFloat(struct Value v, double x);
        bool OverflowInt(struct Value v, int64_t x);
        bool OverflowUint(struct Value v, uint64_t x);
        uintptr_t Pointer(struct Value v);
        std::tuple<struct Value, bool> Recv(struct Value v);
        std::tuple<struct Value, bool> recv(struct Value v, bool nb);
        void Send(struct Value v, struct Value x);
        bool send(struct Value v, struct Value x, bool nb);
        void Set(struct Value v, struct Value x);
        void SetBool(struct Value v, bool x);
        void SetBytes(struct Value v, gocpp::slice<unsigned char> x);
        void setRunes(struct Value v, gocpp::slice<gocpp::rune> x);
        void SetComplex(struct Value v, struct gocpp::complex128 x);
        void SetFloat(struct Value v, double x);
        void SetInt(struct Value v, int64_t x);
        void SetLen(struct Value v, int n);
        void SetCap(struct Value v, int n);
        void SetMapIndex(struct Value v, struct Value key, struct Value elem);
        void SetUint(struct Value v, uint64_t x);
        void SetPointer(struct Value v, unsafe::Pointer x);
        void SetString(struct Value v, std::string x);
        struct Value Slice(struct Value v, int i, int j);
        struct Value Slice3(struct Value v, int i, int j, int k);
        std::string String(struct Value v);
        std::string stringNonString(struct Value v);
        std::tuple<struct Value, bool> TryRecv(struct Value v);
        bool TrySend(struct Value v, struct Value x);
        struct Type Type(struct Value v);
        struct Type typeSlow(struct Value v);
        bool CanUint(struct Value v);
        uint64_t Uint(struct Value v);
        uintptr_t UnsafeAddr(struct Value v);
        unsafe::Pointer UnsafePointer(struct Value v);
        void Grow(struct Value v, int n);
        void grow(struct Value v, int n);
        struct Value extendSlice(struct Value v, int n);
        void Clear(struct Value v);
        struct Value assignTo(struct Value v, std::string context, abi::Type* dst, unsafe::Pointer target);
        struct Value Convert(struct Value v, struct Type t);
        bool CanConvert(struct Value v, struct Type t);
        bool Comparable(struct Value v);
        bool Equal(struct Value v, struct Value u);
    }
}

