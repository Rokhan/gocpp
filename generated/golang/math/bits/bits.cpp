// generated by GoCpp from file '$(ImportDir)/math/bits/bits.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/math/bits/bits.h"
#include "gocpp/support.h"

#include "golang/math/bits/bits_tables.h"

// Package bits implements bit counting and manipulation
// functions for the predeclared unsigned integer types.
//
// Functions in this package may be implemented directly by
// the compiler, for better performance. For those functions
// the code in this package will not be used. Which
// functions are implemented by the compiler depends on the
// architecture and the Go release.
namespace golang::bits
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // UintSize is the size of a uint in bits.
    // LeadingZeros returns the number of leading zero bits in x; the result is [UintSize] for x == 0.
    int LeadingZeros(unsigned int x)
    {
        return UintSize - Len(x);
    }

    // LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.
    int LeadingZeros8(uint8_t x)
    {
        return 8 - Len8(x);
    }

    // LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.
    int LeadingZeros16(uint16_t x)
    {
        return 16 - Len16(x);
    }

    // LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.
    int LeadingZeros32(uint32_t x)
    {
        return 32 - Len32(x);
    }

    // LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.
    int LeadingZeros64(uint64_t x)
    {
        return 64 - Len64(x);
    }

    // See http://supertech.csail.mit.edu/papers/debruijn.pdf
    gocpp::array<unsigned char, 32> deBruijn32tab = gocpp::array<unsigned char, 32> {0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
    gocpp::array<unsigned char, 64> deBruijn64tab = gocpp::array<unsigned char, 64> {0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6};
    // TrailingZeros returns the number of trailing zero bits in x; the result is [UintSize] for x == 0.
    int TrailingZeros(unsigned int x)
    {
        if(UintSize == 32)
        {
            return TrailingZeros32(uint32_t(x));
        }
        return TrailingZeros64(uint64_t(x));
    }

    // TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.
    int TrailingZeros8(uint8_t x)
    {
        return int(ntz8tab[x]);
    }

    // TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.
    int TrailingZeros16(uint16_t x)
    {
        if(x == 0)
        {
            return 16;
        }
        return int(deBruijn32tab[uint32_t(x & - x) * deBruijn32 >> (32 - 5)]);
    }

    // TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.
    int TrailingZeros32(uint32_t x)
    {
        if(x == 0)
        {
            return 32;
        }
        return int(deBruijn32tab[(x & - x) * deBruijn32 >> (32 - 5)]);
    }

    // TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.
    int TrailingZeros64(uint64_t x)
    {
        if(x == 0)
        {
            return 64;
        }
        return int(deBruijn64tab[(x & - x) * deBruijn64 >> (64 - 6)]);
    }

    // OnesCount returns the number of one bits ("population count") in x.
    int OnesCount(unsigned int x)
    {
        if(UintSize == 32)
        {
            return OnesCount32(uint32_t(x));
        }
        return OnesCount64(uint64_t(x));
    }

    // OnesCount8 returns the number of one bits ("population count") in x.
    int OnesCount8(uint8_t x)
    {
        return int(pop8tab[x]);
    }

    // OnesCount16 returns the number of one bits ("population count") in x.
    int OnesCount16(uint16_t x)
    {
        return int(pop8tab[x >> 8] + pop8tab[x & 0xff]);
    }

    // OnesCount32 returns the number of one bits ("population count") in x.
    int OnesCount32(uint32_t x)
    {
        return int(pop8tab[x >> 24] + pop8tab[(x >> 16) & 0xff] + pop8tab[(x >> 8) & 0xff] + pop8tab[x & 0xff]);
    }

    // OnesCount64 returns the number of one bits ("population count") in x.
    int OnesCount64(uint64_t x)
    {
        // Implementation: Parallel summing of adjacent bits.
        // See "Hacker's Delight", Chap. 5: Counting Bits.
        // The following pattern shows the general approach:
        //
        //   x = x>>1&(m0&m) + x&(m0&m)
        //   x = x>>2&(m1&m) + x&(m1&m)
        //   x = x>>4&(m2&m) + x&(m2&m)
        //   x = x>>8&(m3&m) + x&(m3&m)
        //   x = x>>16&(m4&m) + x&(m4&m)
        //   x = x>>32&(m5&m) + x&(m5&m)
        //   return int(x)
        //
        // Masking (& operations) can be left away when there's no
        // danger that a field's sum will carry over into the next
        // field: Since the result cannot be > 64, 8 bits is enough
        // and we can ignore the masks for the shifts by 8 and up.
        // Per "Hacker's Delight", the first line can be simplified
        // more, but it saves at best one instruction, so we leave
        // it alone for clarity.
        auto m = (1 << 64) - 1;
        x = (x >> 1) & (m0 & m) + x & (m0 & m);
        x = (x >> 2) & (m1 & m) + x & (m1 & m);
        x = ((x >> 4) + x) & (m2 & m);
        x += x >> 8;
        x += x >> 16;
        x += x >> 32;
        return int(x) & ((1 << 7) - 1);
    }

    // RotateLeft returns the value of x rotated left by (k mod [UintSize]) bits.
    // To rotate x right by k bits, call RotateLeft(x, -k).
    //
    // This function's execution time does not depend on the inputs.
    unsigned int RotateLeft(unsigned int x, int k)
    {
        if(UintSize == 32)
        {
            return (unsigned int)(RotateLeft32(uint32_t(x), k));
        }
        return (unsigned int)(RotateLeft64(uint64_t(x), k));
    }

    // RotateLeft8 returns the value of x rotated left by (k mod 8) bits.
    // To rotate x right by k bits, call RotateLeft8(x, -k).
    //
    // This function's execution time does not depend on the inputs.
    uint8_t RotateLeft8(uint8_t x, int k)
    {
        auto n = 8;
        auto s = (unsigned int)(k) & (n - 1);
        return (x << s) | (x >> (n - s));
    }

    // RotateLeft16 returns the value of x rotated left by (k mod 16) bits.
    // To rotate x right by k bits, call RotateLeft16(x, -k).
    //
    // This function's execution time does not depend on the inputs.
    uint16_t RotateLeft16(uint16_t x, int k)
    {
        auto n = 16;
        auto s = (unsigned int)(k) & (n - 1);
        return (x << s) | (x >> (n - s));
    }

    // RotateLeft32 returns the value of x rotated left by (k mod 32) bits.
    // To rotate x right by k bits, call RotateLeft32(x, -k).
    //
    // This function's execution time does not depend on the inputs.
    uint32_t RotateLeft32(uint32_t x, int k)
    {
        auto n = 32;
        auto s = (unsigned int)(k) & (n - 1);
        return (x << s) | (x >> (n - s));
    }

    // RotateLeft64 returns the value of x rotated left by (k mod 64) bits.
    // To rotate x right by k bits, call RotateLeft64(x, -k).
    //
    // This function's execution time does not depend on the inputs.
    uint64_t RotateLeft64(uint64_t x, int k)
    {
        auto n = 64;
        auto s = (unsigned int)(k) & (n - 1);
        return (x << s) | (x >> (n - s));
    }

    // Reverse returns the value of x with its bits in reversed order.
    unsigned int Reverse(unsigned int x)
    {
        if(UintSize == 32)
        {
            return (unsigned int)(Reverse32(uint32_t(x)));
        }
        return (unsigned int)(Reverse64(uint64_t(x)));
    }

    // Reverse8 returns the value of x with its bits in reversed order.
    uint8_t Reverse8(uint8_t x)
    {
        return rev8tab[x];
    }

    // Reverse16 returns the value of x with its bits in reversed order.
    uint16_t Reverse16(uint16_t x)
    {
        return uint16_t(rev8tab[x >> 8]) | (uint16_t(rev8tab[x & 0xff]) << 8);
    }

    // Reverse32 returns the value of x with its bits in reversed order.
    uint32_t Reverse32(uint32_t x)
    {
        auto m = (1 << 32) - 1;
        x = (x >> 1) & (m0 & m) | (x & (m0 & m) << 1);
        x = (x >> 2) & (m1 & m) | (x & (m1 & m) << 2);
        x = (x >> 4) & (m2 & m) | (x & (m2 & m) << 4);
        return ReverseBytes32(x);
    }

    // Reverse64 returns the value of x with its bits in reversed order.
    uint64_t Reverse64(uint64_t x)
    {
        auto m = (1 << 64) - 1;
        x = (x >> 1) & (m0 & m) | (x & (m0 & m) << 1);
        x = (x >> 2) & (m1 & m) | (x & (m1 & m) << 2);
        x = (x >> 4) & (m2 & m) | (x & (m2 & m) << 4);
        return ReverseBytes64(x);
    }

    // ReverseBytes returns the value of x with its bytes in reversed order.
    //
    // This function's execution time does not depend on the inputs.
    unsigned int ReverseBytes(unsigned int x)
    {
        if(UintSize == 32)
        {
            return (unsigned int)(ReverseBytes32(uint32_t(x)));
        }
        return (unsigned int)(ReverseBytes64(uint64_t(x)));
    }

    // ReverseBytes16 returns the value of x with its bytes in reversed order.
    //
    // This function's execution time does not depend on the inputs.
    uint16_t ReverseBytes16(uint16_t x)
    {
        return (x >> 8) | (x << 8);
    }

    // ReverseBytes32 returns the value of x with its bytes in reversed order.
    //
    // This function's execution time does not depend on the inputs.
    uint32_t ReverseBytes32(uint32_t x)
    {
        auto m = (1 << 32) - 1;
        x = (x >> 8) & (m3 & m) | (x & (m3 & m) << 8);
        return (x >> 16) | (x << 16);
    }

    // ReverseBytes64 returns the value of x with its bytes in reversed order.
    //
    // This function's execution time does not depend on the inputs.
    uint64_t ReverseBytes64(uint64_t x)
    {
        auto m = (1 << 64) - 1;
        x = (x >> 8) & (m3 & m) | (x & (m3 & m) << 8);
        x = (x >> 16) & (m4 & m) | (x & (m4 & m) << 16);
        return (x >> 32) | (x << 32);
    }

    // Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    int Len(unsigned int x)
    {
        if(UintSize == 32)
        {
            return Len32(uint32_t(x));
        }
        return Len64(uint64_t(x));
    }

    // Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    int Len8(uint8_t x)
    {
        return int(len8tab[x]);
    }

    // Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    int Len16(uint16_t x)
    {
        int n;
        if(x >= (1 << 8))
        {
            x >>= 8;
            n = 8;
        }
        return n + int(len8tab[x]);
    }

    // Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    int Len32(uint32_t x)
    {
        int n;
        if(x >= (1 << 16))
        {
            x >>= 16;
            n = 16;
        }
        if(x >= (1 << 8))
        {
            x >>= 8;
            n += 8;
        }
        return n + int(len8tab[x]);
    }

    // Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    int Len64(uint64_t x)
    {
        int n;
        if(x >= (1 << 32))
        {
            x >>= 32;
            n = 32;
        }
        if(x >= (1 << 16))
        {
            x >>= 16;
            n += 16;
        }
        if(x >= (1 << 8))
        {
            x >>= 8;
            n += 8;
        }
        return n + int(len8tab[x]);
    }

    // Add returns the sum with carry of x, y and carry: sum = x + y + carry.
    // The carry input must be 0 or 1; otherwise the behavior is undefined.
    // The carryOut output is guaranteed to be 0 or 1.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<unsigned int, unsigned int> Add(unsigned int x, unsigned int y, unsigned int carry)
    {
        unsigned int sum;
        unsigned int carryOut;
        if(UintSize == 32)
        {
            auto [s32, c32] = Add32(uint32_t(x), uint32_t(y), uint32_t(carry));
            return {(unsigned int)(s32), (unsigned int)(c32)};
        }
        auto [s64, c64] = Add64(uint64_t(x), uint64_t(y), uint64_t(carry));
        return {(unsigned int)(s64), (unsigned int)(c64)};
    }

    // Add32 returns the sum with carry of x, y and carry: sum = x + y + carry.
    // The carry input must be 0 or 1; otherwise the behavior is undefined.
    // The carryOut output is guaranteed to be 0 or 1.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<uint32_t, uint32_t> Add32(uint32_t x, uint32_t y, uint32_t carry)
    {
        uint32_t sum;
        uint32_t carryOut;
        auto sum64 = uint64_t(x) + uint64_t(y) + uint64_t(carry);
        sum = uint32_t(sum64);
        carryOut = uint32_t(sum64 >> 32);
        return {sum, carryOut};
    }

    // Add64 returns the sum with carry of x, y and carry: sum = x + y + carry.
    // The carry input must be 0 or 1; otherwise the behavior is undefined.
    // The carryOut output is guaranteed to be 0 or 1.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<uint64_t, uint64_t> Add64(uint64_t x, uint64_t y, uint64_t carry)
    {
        uint64_t sum;
        uint64_t carryOut;
        sum = x + y + carry;
        carryOut = ((x & y) | ((x | y) &^ sum)) >> 63;
        return {sum, carryOut};
    }

    // Sub returns the difference of x, y and borrow: diff = x - y - borrow.
    // The borrow input must be 0 or 1; otherwise the behavior is undefined.
    // The borrowOut output is guaranteed to be 0 or 1.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<unsigned int, unsigned int> Sub(unsigned int x, unsigned int y, unsigned int borrow)
    {
        unsigned int diff;
        unsigned int borrowOut;
        if(UintSize == 32)
        {
            auto [d32, b32] = Sub32(uint32_t(x), uint32_t(y), uint32_t(borrow));
            return {(unsigned int)(d32), (unsigned int)(b32)};
        }
        auto [d64, b64] = Sub64(uint64_t(x), uint64_t(y), uint64_t(borrow));
        return {(unsigned int)(d64), (unsigned int)(b64)};
    }

    // Sub32 returns the difference of x, y and borrow, diff = x - y - borrow.
    // The borrow input must be 0 or 1; otherwise the behavior is undefined.
    // The borrowOut output is guaranteed to be 0 or 1.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<uint32_t, uint32_t> Sub32(uint32_t x, uint32_t y, uint32_t borrow)
    {
        uint32_t diff;
        uint32_t borrowOut;
        diff = x - y - borrow;
        borrowOut = ((~ x & y) | (~ (x ^ y) & diff)) >> 31;
        return {diff, borrowOut};
    }

    // Sub64 returns the difference of x, y and borrow: diff = x - y - borrow.
    // The borrow input must be 0 or 1; otherwise the behavior is undefined.
    // The borrowOut output is guaranteed to be 0 or 1.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<uint64_t, uint64_t> Sub64(uint64_t x, uint64_t y, uint64_t borrow)
    {
        uint64_t diff;
        uint64_t borrowOut;
        diff = x - y - borrow;
        borrowOut = ((~ x & y) | (~ (x ^ y) & diff)) >> 63;
        return {diff, borrowOut};
    }

    // Mul returns the full-width product of x and y: (hi, lo) = x * y
    // with the product bits' upper half returned in hi and the lower
    // half returned in lo.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<unsigned int, unsigned int> Mul(unsigned int x, unsigned int y)
    {
        unsigned int hi;
        unsigned int lo;
        if(UintSize == 32)
        {
            auto [h, l] = Mul32(uint32_t(x), uint32_t(y));
            return {(unsigned int)(h), (unsigned int)(l)};
        }
        auto [h, l] = Mul64(uint64_t(x), uint64_t(y));
        return {(unsigned int)(h), (unsigned int)(l)};
    }

    // Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y
    // with the product bits' upper half returned in hi and the lower
    // half returned in lo.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<uint32_t, uint32_t> Mul32(uint32_t x, uint32_t y)
    {
        uint32_t hi;
        uint32_t lo;
        auto tmp = uint64_t(x) * uint64_t(y);
        std::tie(hi, lo) = std::tuple{uint32_t(tmp >> 32), uint32_t(tmp)};
        return {hi, lo};
    }

    // Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y
    // with the product bits' upper half returned in hi and the lower
    // half returned in lo.
    //
    // This function's execution time does not depend on the inputs.
    std::tuple<uint64_t, uint64_t> Mul64(uint64_t x, uint64_t y)
    {
        uint64_t hi;
        uint64_t lo;
        auto mask32 = (1 << 32) - 1;
        auto x0 = x & mask32;
        auto x1 = x >> 32;
        auto y0 = y & mask32;
        auto y1 = y >> 32;
        auto w0 = x0 * y0;
        auto t = x1 * y0 + (w0 >> 32);
        auto w1 = t & mask32;
        auto w2 = t >> 32;
        w1 += x0 * y1;
        hi = x1 * y1 + w2 + (w1 >> 32);
        lo = x * y;
        return {hi, lo};
    }

    // Div returns the quotient and remainder of (hi, lo) divided by y:
    // quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper
    // half in parameter hi and the lower half in parameter lo.
    // Div panics for y == 0 (division by zero) or y <= hi (quotient overflow).
    std::tuple<unsigned int, unsigned int> Div(unsigned int hi, unsigned int lo, unsigned int y)
    {
        unsigned int quo;
        unsigned int rem;
        if(UintSize == 32)
        {
            auto [q, r] = Div32(uint32_t(hi), uint32_t(lo), uint32_t(y));
            return {(unsigned int)(q), (unsigned int)(r)};
        }
        auto [q, r] = Div64(uint64_t(hi), uint64_t(lo), uint64_t(y));
        return {(unsigned int)(q), (unsigned int)(r)};
    }

    // Div32 returns the quotient and remainder of (hi, lo) divided by y:
    // quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper
    // half in parameter hi and the lower half in parameter lo.
    // Div32 panics for y == 0 (division by zero) or y <= hi (quotient overflow).
    std::tuple<uint32_t, uint32_t> Div32(uint32_t hi, uint32_t lo, uint32_t y)
    {
        uint32_t quo;
        uint32_t rem;
        if(y != 0 && y <= hi)
        {
            gocpp::panic(overflowError);
        }
        auto z = (uint64_t(hi) << 32) | uint64_t(lo);
        std::tie(quo, rem) = std::tuple{uint32_t(z / uint64_t(y)), uint32_t(z % uint64_t(y))};
        return {quo, rem};
    }

    // Div64 returns the quotient and remainder of (hi, lo) divided by y:
    // quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper
    // half in parameter hi and the lower half in parameter lo.
    // Div64 panics for y == 0 (division by zero) or y <= hi (quotient overflow).
    std::tuple<uint64_t, uint64_t> Div64(uint64_t hi, uint64_t lo, uint64_t y)
    {
        uint64_t quo;
        uint64_t rem;
        if(y == 0)
        {
            gocpp::panic(divideError);
        }
        if(y <= hi)
        {
            gocpp::panic(overflowError);
        }
        if(hi == 0)
        {
            return {lo / y, lo % y};
        }
        auto s = (unsigned int)(LeadingZeros64(y));
        y <<= s;
        auto two32 = 1 << 32;
        auto mask32 = two32 - 1;
        auto yn1 = y >> 32;
        auto yn0 = y & mask32;
        auto un32 = (hi << s) | (lo >> (64 - s));
        auto un10 = lo << s;
        auto un1 = un10 >> 32;
        auto un0 = un10 & mask32;
        auto q1 = un32 / yn1;
        auto rhat = un32 - q1 * yn1;
        for(; q1 >= two32 || q1 * yn0 > two32 * rhat + un1; )
        {
            q1--;
            rhat += yn1;
            if(rhat >= two32)
            {
                break;
            }
        }
        auto un21 = un32 * two32 + un1 - q1 * y;
        auto q0 = un21 / yn1;
        rhat = un21 - q0 * yn1;
        for(; q0 >= two32 || q0 * yn0 > two32 * rhat + un0; )
        {
            q0--;
            rhat += yn1;
            if(rhat >= two32)
            {
                break;
            }
        }
        return {q1 * two32 + q0, (un21 * two32 + un0 - q0 * y) >> s};
    }

    // Rem returns the remainder of (hi, lo) divided by y. Rem panics for
    // y == 0 (division by zero) but, unlike Div, it doesn't panic on a
    // quotient overflow.
    unsigned int Rem(unsigned int hi, unsigned int lo, unsigned int y)
    {
        if(UintSize == 32)
        {
            return (unsigned int)(Rem32(uint32_t(hi), uint32_t(lo), uint32_t(y)));
        }
        return (unsigned int)(Rem64(uint64_t(hi), uint64_t(lo), uint64_t(y)));
    }

    // Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics
    // for y == 0 (division by zero) but, unlike [Div32], it doesn't panic
    // on a quotient overflow.
    uint32_t Rem32(uint32_t hi, uint32_t lo, uint32_t y)
    {
        return uint32_t(((uint64_t(hi) << 32) | uint64_t(lo)) % uint64_t(y));
    }

    // Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics
    // for y == 0 (division by zero) but, unlike [Div64], it doesn't panic
    // on a quotient overflow.
    uint64_t Rem64(uint64_t hi, uint64_t lo, uint64_t y)
    {
        auto [gocpp_id_1, rem] = Div64(hi % y, lo, y);
        return rem;
    }

}

