// generated by GoCpp from file '$(ImportDir)/runtime/stack.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/stack.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/stack.h"
// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/cpu/cpu_x86.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goarch/zgoarch_amd64.h"
#include "golang/internal/goos/zgoos_windows.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mem.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/os_nonopenbsd.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/preempt.h"  [Ignored, known errors]
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/stkframe.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/runtime/sys_x86.h"
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    extern long stackPoisonCopy;
    struct stackpoolItem
    {
        sys::NotInHeap _;
        mutex mu;
        /* mSpanList span; [Known incomplete type] */

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackpoolItem& value);
    void stackinit();
    int stacklog2(uintptr_t n);
    gclinkptr stackpoolalloc(uint8_t order);
    void stackpoolfree(gclinkptr x, uint8_t order);
    void stackcacherefill(mcache* c, uint8_t order);
    void stackcacherelease(mcache* c, uint8_t order);
    void stackcache_clear(mcache* c);
    stack stackalloc(uint32_t n);
    void stackfree(stack stk);
    extern uintptr_t maxstacksize;
    extern uintptr_t maxstackceiling;
    extern gocpp::slice<std::string> ptrnames;
    struct adjustinfo
    {
        stack old;
        uintptr_t delta;
        uintptr_t sghi;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct adjustinfo& value);
    void adjustpointer(adjustinfo* adjinfo, unsafe::Pointer vpp);
    struct bitvector
    {
        int32_t n;
        uint8_t* bytedata;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct bitvector& value);
    uint8_t ptrbit(struct bitvector* bv, uintptr_t i);
    void adjustpointers(unsafe::Pointer scanp, bitvector* bv, adjustinfo* adjinfo, funcInfo f);
    void adjustframe(stkframe* frame, adjustinfo* adjinfo);
    void adjustctxt(g* gp, adjustinfo* adjinfo);
    void adjustdefers(g* gp, adjustinfo* adjinfo);
    void adjustpanics(g* gp, adjustinfo* adjinfo);
    void adjustsudogs(g* gp, adjustinfo* adjinfo);
    void fillstack(stack stk, unsigned char b);
    uintptr_t findsghi(g* gp, stack stk);
    uintptr_t syncadjustsudogs(g* gp, uintptr_t used, adjustinfo* adjinfo);
    void copystack(g* gp, uintptr_t newsize);
    int32_t round2(int32_t x);
    void newstack();
    void nilfunc();
    void gostartcallfn(gobuf* gobuf, funcval* fv);
    bool isShrinkStackSafe(g* gp);
    void shrinkstack(g* gp);
    void freeStackSpans();
    struct stackObjectRecord
    {
        int32_t off;
        int32_t size;
        int32_t _ptrdata;
        uint32_t gcdataoff;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct stackObjectRecord& value);
    bool useGCProg(struct stackObjectRecord* r);
    uintptr_t ptrdata(struct stackObjectRecord* r);
    unsigned char* gcdata(struct stackObjectRecord* r);
    void morestackc();
    extern uint32_t startingStackSize;
    void gcComputeStartingStackSize();
}

