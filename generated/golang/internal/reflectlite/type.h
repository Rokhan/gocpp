// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/type.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"

namespace golang::reflectlite
{
    struct Type : gocpp::Interface
    {
        Type(){}
        Type(Type& i) = default;
        Type(const Type& i) = default;
        Type& operator=(Type& i) = default;
        Type& operator=(const Type& i) = default;

        template<typename T>
        Type(T& ref);

        template<typename T>
        Type(const T& ref);

        template<typename T>
        Type(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IType
        {
            virtual std::string vName() = 0;
            virtual std::string vPkgPath() = 0;
            virtual uintptr_t vSize() = 0;
            virtual Kind vKind() = 0;
            virtual bool vImplements(struct Type u) = 0;
            virtual bool vAssignableTo(struct Type u) = 0;
            virtual bool vComparable() = 0;
            virtual std::string vString() = 0;
            virtual struct Type vElem() = 0;
            virtual struct abi::Type* vcommon() = 0;
            virtual struct uncommonType* vuncommon() = 0;
        };

        template<typename T, typename StoreT>
        struct TypeImpl : IType
        {
            explicit TypeImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vName() override;

            std::string vPkgPath() override;

            uintptr_t vSize() override;

            Kind vKind() override;

            bool vImplements(struct Type u) override;

            bool vAssignableTo(struct Type u) override;

            bool vComparable() override;

            std::string vString() override;

            struct Type vElem() override;

            struct abi::Type* vcommon() override;

            struct uncommonType* vuncommon() override;

            StoreT value;
        };

        std::shared_ptr<IType> value;
    };

    std::string Name(const gocpp::PtrRecv<Type, false>& self);
    std::string Name(const gocpp::ObjRecv<Type>& self);

    std::string PkgPath(const gocpp::PtrRecv<Type, false>& self);
    std::string PkgPath(const gocpp::ObjRecv<Type>& self);

    uintptr_t Size(const gocpp::PtrRecv<Type, false>& self);
    uintptr_t Size(const gocpp::ObjRecv<Type>& self);

    Kind Kind(const gocpp::PtrRecv<Type, false>& self);
    Kind Kind(const gocpp::ObjRecv<Type>& self);

    bool Implements(const gocpp::PtrRecv<Type, false>& self, struct Type u);
    bool Implements(const gocpp::ObjRecv<Type>& self, struct Type u);

    bool AssignableTo(const gocpp::PtrRecv<Type, false>& self, struct Type u);
    bool AssignableTo(const gocpp::ObjRecv<Type>& self, struct Type u);

    bool Comparable(const gocpp::PtrRecv<Type, false>& self);
    bool Comparable(const gocpp::ObjRecv<Type>& self);

    std::string String(const gocpp::PtrRecv<Type, false>& self);
    std::string String(const gocpp::ObjRecv<Type>& self);

    struct Type Elem(const gocpp::PtrRecv<Type, false>& self);
    struct Type Elem(const gocpp::ObjRecv<Type>& self);

    struct abi::Type* common(const gocpp::PtrRecv<Type, false>& self);
    struct abi::Type* common(const gocpp::ObjRecv<Type>& self);

    struct uncommonType* uncommon(const gocpp::PtrRecv<Type, false>& self);
    struct uncommonType* uncommon(const gocpp::ObjRecv<Type>& self);

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    struct rtype
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct rtype& value);
    struct mapType
    {
        abi::Type* Key;
        abi::Type* Elem;
        abi::Type* Bucket;
        std::function<uintptr_t (unsafe::Pointer, uintptr_t)> Hasher;
        uint8_t KeySize;
        uint8_t ValueSize;
        uint16_t BucketSize;
        uint32_t Flags;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mapType& value);
    struct name
    {
        unsigned char* bytes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct name& value);
    unsigned char* data(struct name n, int off, std::string whySafe);
    bool isExported(struct name n);
    bool hasTag(struct name n);
    bool embedded(struct name n);
    std::tuple<int, int> readVarint(struct name n, int off);
    std::string name(struct name n);
    std::string tag(struct name n);
    std::string pkgPath(struct abi::Name n);
    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off);
    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off);
    struct abi::Name nameOff(struct rtype t, nameOff off);
    struct abi::Type* typeOff(struct rtype t, typeOff off);
    struct uncommonType* uncommon(struct rtype t);
    std::string String(struct rtype t);
    struct abi::Type* common(struct rtype t);
    gocpp::slice<abi::Method> exportedMethods(struct rtype t);
    int NumMethod(struct rtype t);
    std::string PkgPath(struct rtype t);
    std::string Name(struct rtype t);
    struct rtype toRType(struct abi::Type* t);
    struct abi::Type* elem(struct abi::Type* t);
    struct Type Elem(struct rtype t);
    struct Type In(struct rtype t, int i);
    struct Type Key(struct rtype t);
    int Len(struct rtype t);
    int NumField(struct rtype t);
    int NumIn(struct rtype t);
    int NumOut(struct rtype t);
    struct Type Out(struct rtype t, int i);
    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    struct Type TypeOf(go_any i);
    bool Implements(struct rtype t, struct Type u);
    bool AssignableTo(struct rtype t, struct Type u);
    bool Comparable(struct rtype t);
    bool implements(struct abi::Type* T, struct abi::Type* V);
    bool directlyAssignable(struct abi::Type* T, struct abi::Type* V);
    bool haveIdenticalType(struct abi::Type* T, struct abi::Type* V, bool cmpTags);
    bool haveIdenticalUnderlyingType(struct abi::Type* T, struct abi::Type* V, bool cmpTags);
    struct Type toType(struct abi::Type* t);
    bool ifaceIndir(struct abi::Type* t);
}

