// generated by GoCpp from file '$(ImportDir)/os/file_posix.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file_posix.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_fsync_windows.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_posix.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir_windows.h"
#include "golang/os/error.h"
#include "golang/os/file.h"
#include "golang/os/file_windows.h"
#include "golang/os/path_windows.h"
#include "golang/os/types.h"
#include "golang/runtime/mfinal.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    struct gocpp::error Close(struct File* f)
    {
        if(f == nullptr)
        {
            return ErrInvalid;
        }
        return close(gocpp::recv(f->file));
    }

    std::tuple<int, struct gocpp::error> read(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = Read(gocpp::recv(f->pfd), b);
        runtime::KeepAlive(f);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> pread(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = Pread(gocpp::recv(f->pfd), b, off);
        runtime::KeepAlive(f);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> write(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = Write(gocpp::recv(f->pfd), b);
        runtime::KeepAlive(f);
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> pwrite(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        std::tie(n, err) = Pwrite(gocpp::recv(f->pfd), b, off);
        runtime::KeepAlive(f);
        return {n, err};
    }

    uint32_t syscallMode(FileMode i)
    {
        uint32_t o;
        o |= uint32_t(Perm(gocpp::recv(i)));
        if(i & ModeSetuid != 0)
        {
            uint32_t o;
            o |= syscall::S_ISUID;
        }
        if(i & ModeSetgid != 0)
        {
            uint32_t o;
            o |= syscall::S_ISGID;
        }
        if(i & ModeSticky != 0)
        {
            uint32_t o;
            o |= syscall::S_ISVTX;
        }
        return o;
    }

    struct gocpp::error chmod(std::string name, FileMode mode)
    {
        auto longName = fixLongPath(name);
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Chmod(longName, syscallMode(mode));
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<PathError>([](PathError& x) { x.Op = "chmod"; x.Path = name; x.Err = e; });
        }
        return nullptr;
    }

    struct gocpp::error chmod(struct File* f, FileMode mode)
    {
        if(auto err = checkValid(gocpp::recv(f), "chmod"); err != nullptr)
        {
            return err;
        }
        if(auto e = Fchmod(gocpp::recv(f->pfd), syscallMode(mode)); e != nullptr)
        {
            return wrapErr(gocpp::recv(f), "chmod", e);
        }
        return nullptr;
    }

    struct gocpp::error Chown(std::string name, int uid, int gid)
    {
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Chown(name, uid, gid);
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<PathError>([](PathError& x) { x.Op = "chown"; x.Path = name; x.Err = e; });
        }
        return nullptr;
    }

    struct gocpp::error Lchown(std::string name, int uid, int gid)
    {
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Lchown(name, uid, gid);
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<PathError>([](PathError& x) { x.Op = "lchown"; x.Path = name; x.Err = e; });
        }
        return nullptr;
    }

    struct gocpp::error Chown(struct File* f, int uid, int gid)
    {
        if(auto err = checkValid(gocpp::recv(f), "chown"); err != nullptr)
        {
            return err;
        }
        if(auto e = Fchown(gocpp::recv(f->pfd), uid, gid); e != nullptr)
        {
            return wrapErr(gocpp::recv(f), "chown", e);
        }
        return nullptr;
    }

    struct gocpp::error Truncate(struct File* f, int64_t size)
    {
        if(auto err = checkValid(gocpp::recv(f), "truncate"); err != nullptr)
        {
            return err;
        }
        if(auto e = Ftruncate(gocpp::recv(f->pfd), size); e != nullptr)
        {
            return wrapErr(gocpp::recv(f), "truncate", e);
        }
        return nullptr;
    }

    struct gocpp::error Sync(struct File* f)
    {
        if(auto err = checkValid(gocpp::recv(f), "sync"); err != nullptr)
        {
            return err;
        }
        if(auto e = Fsync(gocpp::recv(f->pfd)); e != nullptr)
        {
            return wrapErr(gocpp::recv(f), "sync", e);
        }
        return nullptr;
    }

    struct gocpp::error Chtimes(std::string name, struct mocklib::Date atime, struct mocklib::Date mtime)
    {
        gocpp::array<syscall::Timespec, 2> utimes = {};
        auto set = [=](int i, struct mocklib::Date t) mutable -> void
        {
            if(IsZero(gocpp::recv(t)))
            {
                utimes[i] = gocpp::Init<syscall::Timespec>([](syscall::Timespec& x) { x.Sec = _UTIME_OMIT; x.Nsec = _UTIME_OMIT; });
            }
            else
            {
                utimes[i] = syscall::NsecToTimespec(UnixNano(gocpp::recv(t)));
            }
        };
        set(0, atime);
        set(1, mtime);
        if(auto e = syscall::UtimesNano(fixLongPath(name), utimes.make_slice(0)); e != nullptr)
        {
            return gocpp::InitPtr<PathError>([](PathError& x) { x.Op = "chtimes"; x.Path = name; x.Err = e; });
        }
        return nullptr;
    }

    struct gocpp::error Chdir(struct File* f)
    {
        if(auto err = checkValid(gocpp::recv(f), "chdir"); err != nullptr)
        {
            return err;
        }
        if(auto e = Fchdir(gocpp::recv(f->pfd)); e != nullptr)
        {
            return wrapErr(gocpp::recv(f), "chdir", e);
        }
        return nullptr;
    }

    struct gocpp::error setDeadline(struct File* f, struct mocklib::Date t)
    {
        if(auto err = checkValid(gocpp::recv(f), "SetDeadline"); err != nullptr)
        {
            return err;
        }
        return SetDeadline(gocpp::recv(f->pfd), t);
    }

    struct gocpp::error setReadDeadline(struct File* f, struct mocklib::Date t)
    {
        if(auto err = checkValid(gocpp::recv(f), "SetReadDeadline"); err != nullptr)
        {
            return err;
        }
        return SetReadDeadline(gocpp::recv(f->pfd), t);
    }

    struct gocpp::error setWriteDeadline(struct File* f, struct mocklib::Date t)
    {
        if(auto err = checkValid(gocpp::recv(f), "SetWriteDeadline"); err != nullptr)
        {
            return err;
        }
        return SetWriteDeadline(gocpp::recv(f->pfd), t);
    }

    struct gocpp::error checkValid(struct File* f, std::string op)
    {
        if(f == nullptr)
        {
            return ErrInvalid;
        }
        return nullptr;
    }

    struct gocpp::error ignoringEINTR(std::function<struct gocpp::error ()> fn)
    {
        for(; ; )
        {
            auto err = fn();
            if(err != syscall::EINTR)
            {
                return err;
            }
        }
    }

}

