// generated by GoCpp from file '$(ImportDir)/fmt/format.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/fmt/format.h"
#include "gocpp/support.h"

// #include "golang/fmt/print.h"  [Ignored, known errors]
#include "golang/strconv/ftoa.h"
#include "golang/strconv/quote.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::fmt
{
    std::string ldigits = "0123456789abcdefx";
    std::string udigits = "0123456789ABCDEFX";
    bool go_signed = true;
    bool go_unsigned = false;
    
    std::ostream& fmtFlags::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << widPresent;
        os << " " << precPresent;
        os << " " << minus;
        os << " " << plus;
        os << " " << sharp;
        os << " " << space;
        os << " " << zero;
        os << " " << plusV;
        os << " " << sharpV;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fmtFlags& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& fmt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << wid;
        os << " " << prec;
        os << " " << intbuf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fmt& value)
    {
        return value.PrintTo(os);
    }

    void clearflags(struct fmt* f)
    {
        f->fmtFlags = fmtFlags {};
    }

    void init(struct fmt* f, buffer* buf)
    {
        f->buf = buf;
        clearflags(gocpp::recv(f));
    }

    void writePadding(struct fmt* f, int n)
    {
        if(n <= 0)
        {
            return;
        }
        auto buf = *f->buf;
        auto oldLen = len(buf);
        auto newLen = oldLen + n;
        if(newLen > cap(buf))
        {
            buf = gocpp::make(buffer, cap(buf) * 2 + n);
            copy(buf, *f->buf);
        }
        auto padByte = byte(' ');
        if(f->zero)
        {
            padByte = byte('0');
        }
        auto padding = buf.make_slice(oldLen, newLen);
        for(auto [i, gocpp_ignored] : padding)
        {
            padding[i] = padByte;
        }
        *f->buf = buf.make_slice(0, newLen);
    }

    void pad(struct fmt* f, gocpp::slice<unsigned char> b)
    {
        if(! f->widPresent || f->wid == 0)
        {
            write(gocpp::recv(f->buf), b);
            return;
        }
        auto width = f->wid - RuneCount(gocpp::recv(utf8), b);
        if(! f->minus)
        {
            writePadding(gocpp::recv(f), width);
            write(gocpp::recv(f->buf), b);
        }
        else
        {
            write(gocpp::recv(f->buf), b);
            writePadding(gocpp::recv(f), width);
        }
    }

    void padString(struct fmt* f, std::string s)
    {
        if(! f->widPresent || f->wid == 0)
        {
            writeString(gocpp::recv(f->buf), s);
            return;
        }
        auto width = f->wid - RuneCountInString(gocpp::recv(utf8), s);
        if(! f->minus)
        {
            writePadding(gocpp::recv(f), width);
            writeString(gocpp::recv(f->buf), s);
        }
        else
        {
            writeString(gocpp::recv(f->buf), s);
            writePadding(gocpp::recv(f), width);
        }
    }

    void fmtBoolean(struct fmt* f, bool v)
    {
        if(v)
        {
            padString(gocpp::recv(f), "true");
        }
        else
        {
            padString(gocpp::recv(f), "false");
        }
    }

    void fmtUnicode(struct fmt* f, uint64_t u)
    {
        auto buf = f->intbuf.make_slice(0);
        auto prec = 4;
        if(f->precPresent && f->prec > 4)
        {
            prec = f->prec;
            auto width = 2 + prec + 2 + utf8.UTFMax + 1;
            if(width > len(buf))
            {
                buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), width);
            }
        }
        auto i = len(buf);
        if(f->sharp && u <= utf8.MaxRune && IsPrint(gocpp::recv(strconv), rune(u)))
        {
            i--;
            buf[i] = '\'';
            i -= RuneLen(gocpp::recv(utf8), rune(u));
            EncodeRune(gocpp::recv(utf8), buf.make_slice(i), rune(u));
            i--;
            buf[i] = '\'';
            i--;
            buf[i] = ' ';
        }
        for(; u >= 16; )
        {
            i--;
            buf[i] = udigits[u & 0xF];
            prec--;
            u >>= 4;
        }
        i--;
        buf[i] = udigits[u];
        prec--;
        for(; prec > 0; )
        {
            i--;
            buf[i] = '0';
            prec--;
        }
        i--;
        buf[i] = '+';
        i--;
        buf[i] = 'U';
        auto oldZero = f->zero;
        f->zero = false;
        pad(gocpp::recv(f), buf.make_slice(i));
        f->zero = oldZero;
    }

    void fmtInteger(struct fmt* f, uint64_t u, int base, bool isSigned, gocpp::rune verb, std::string digits)
    {
        auto negative = isSigned && int64(u) < 0;
        if(negative)
        {
            u = - u;
        }
        auto buf = f->intbuf.make_slice(0);
        if(f->widPresent || f->precPresent)
        {
            auto width = 3 + f->wid + f->prec;
            if(width > len(buf))
            {
                buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), width);
            }
        }
        auto prec = 0;
        if(f->precPresent)
        {
            prec = f->prec;
            if(prec == 0 && u == 0)
            {
                auto oldZero = f->zero;
                f->zero = false;
                writePadding(gocpp::recv(f), f->wid);
                f->zero = oldZero;
                return;
            }
        }
        else
        if(f->zero && f->widPresent)
        {
            prec = f->wid;
            if(negative || f->plus || f->space)
            {
                prec--;
            }
        }
        auto i = len(buf);
        //Go switch emulation
        {
            auto condition = base;
            int conditionId = -1;
            if(condition == 10) { conditionId = 0; }
            else if(condition == 16) { conditionId = 1; }
            else if(condition == 8) { conditionId = 2; }
            else if(condition == 2) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    for(; u >= 10; )
                    {
                        i--;
                        auto next = u / 10;
                        buf[i] = byte('0' + u - next * 10);
                        u = next;
                    }
                    break;
                case 1:
                    for(; u >= 16; )
                    {
                        i--;
                        buf[i] = digits[u & 0xF];
                        u >>= 4;
                    }
                    break;
                case 2:
                    for(; u >= 8; )
                    {
                        i--;
                        buf[i] = byte('0' + u & 7);
                        u >>= 3;
                    }
                    break;
                case 3:
                    for(; u >= 2; )
                    {
                        i--;
                        buf[i] = byte('0' + u & 1);
                        u >>= 1;
                    }
                    break;
                default:
                    gocpp::panic("fmt: unknown base; can't happen");
                    break;
            }
        }
        i--;
        buf[i] = digits[u];
        for(; i > 0 && prec > len(buf) - i; )
        {
            i--;
            buf[i] = '0';
        }
        if(f->sharp)
        {
            //Go switch emulation
            {
                auto condition = base;
                int conditionId = -1;
                if(condition == 2) { conditionId = 0; }
                else if(condition == 8) { conditionId = 1; }
                else if(condition == 16) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        i--;
                        buf[i] = 'b';
                        i--;
                        buf[i] = '0';
                        break;
                    case 1:
                        if(buf[i] != '0')
                        {
                            i--;
                            buf[i] = '0';
                        }
                        break;
                    case 2:
                        i--;
                        buf[i] = digits[16];
                        i--;
                        buf[i] = '0';
                        break;
                }
            }
        }
        if(verb == 'O')
        {
            i--;
            buf[i] = 'o';
            i--;
            buf[i] = '0';
        }
        if(negative)
        {
            i--;
            buf[i] = '-';
        }
        else
        if(f->plus)
        {
            i--;
            buf[i] = '+';
        }
        else
        if(f->space)
        {
            i--;
            buf[i] = ' ';
        }
        auto oldZero = f->zero;
        f->zero = false;
        pad(gocpp::recv(f), buf.make_slice(i));
        f->zero = oldZero;
    }

    std::string truncateString(struct fmt* f, std::string s)
    {
        if(f->precPresent)
        {
            auto n = f->prec;
            for(auto [i, gocpp_ignored] : s)
            {
                n--;
                if(n < 0)
                {
                    return s.make_slice(0, i);
                }
            }
        }
        return s;
    }

    gocpp::slice<unsigned char> truncate(struct fmt* f, gocpp::slice<unsigned char> b)
    {
        if(f->precPresent)
        {
            auto n = f->prec;
            for(auto i = 0; i < len(b); )
            {
                n--;
                if(n < 0)
                {
                    return b.make_slice(0, i);
                }
                auto wid = 1;
                if(b[i] >= utf8.RuneSelf)
                {
                    std::tie(_, wid) = DecodeRune(gocpp::recv(utf8), b.make_slice(i));
                }
                i += wid;
            }
        }
        return b;
    }

    void fmtS(struct fmt* f, std::string s)
    {
        s = truncateString(gocpp::recv(f), s);
        padString(gocpp::recv(f), s);
    }

    void fmtBs(struct fmt* f, gocpp::slice<unsigned char> b)
    {
        b = truncate(gocpp::recv(f), b);
        pad(gocpp::recv(f), b);
    }

    void fmtSbx(struct fmt* f, std::string s, gocpp::slice<unsigned char> b, std::string digits)
    {
        auto length = len(b);
        if(b == nullptr)
        {
            length = len(s);
        }
        if(f->precPresent && f->prec < length)
        {
            length = f->prec;
        }
        auto width = 2 * length;
        if(width > 0)
        {
            if(f->space)
            {
                if(f->sharp)
                {
                    width *= 2;
                }
                width += length - 1;
            }
            else
            if(f->sharp)
            {
                width += 2;
            }
        }
        else
        {
            if(f->widPresent)
            {
                writePadding(gocpp::recv(f), f->wid);
            }
            return;
        }
        if(f->widPresent && f->wid > width && ! f->minus)
        {
            writePadding(gocpp::recv(f), f->wid - width);
        }
        auto buf = *f->buf;
        if(f->sharp)
        {
            buf = append(buf, '0', digits[16]);
        }
        unsigned char c = {};
        for(auto i = 0; i < length; i++)
        {
            if(f->space && i > 0)
            {
                buf = append(buf, ' ');
                if(f->sharp)
                {
                    buf = append(buf, '0', digits[16]);
                }
            }
            if(b != nullptr)
            {
                c = b[i];
            }
            else
            {
                c = s[i];
            }
            buf = append(buf, digits[c >> 4], digits[c & 0xF]);
        }
        *f->buf = buf;
        if(f->widPresent && f->wid > width && f->minus)
        {
            writePadding(gocpp::recv(f), f->wid - width);
        }
    }

    void fmtSx(struct fmt* f, std::string s, std::string digits)
    {
        fmtSbx(gocpp::recv(f), s, nullptr, digits);
    }

    void fmtBx(struct fmt* f, gocpp::slice<unsigned char> b, std::string digits)
    {
        fmtSbx(gocpp::recv(f), "", b, digits);
    }

    void fmtQ(struct fmt* f, std::string s)
    {
        s = truncateString(gocpp::recv(f), s);
        if(f->sharp && CanBackquote(gocpp::recv(strconv), s))
        {
            padString(gocpp::recv(f), "`" + s + "`");
            return;
        }
        auto buf = f->intbuf.make_slice(0, 0);
        if(f->plus)
        {
            pad(gocpp::recv(f), AppendQuoteToASCII(gocpp::recv(strconv), buf, s));
        }
        else
        {
            pad(gocpp::recv(f), AppendQuote(gocpp::recv(strconv), buf, s));
        }
    }

    void fmtC(struct fmt* f, uint64_t c)
    {
        auto r = rune(c);
        if(c > utf8.MaxRune)
        {
            r = utf8.RuneError;
        }
        auto buf = f->intbuf.make_slice(0, 0);
        pad(gocpp::recv(f), AppendRune(gocpp::recv(utf8), buf, r));
    }

    void fmtQc(struct fmt* f, uint64_t c)
    {
        auto r = rune(c);
        if(c > utf8.MaxRune)
        {
            r = utf8.RuneError;
        }
        auto buf = f->intbuf.make_slice(0, 0);
        if(f->plus)
        {
            pad(gocpp::recv(f), AppendQuoteRuneToASCII(gocpp::recv(strconv), buf, r));
        }
        else
        {
            pad(gocpp::recv(f), AppendQuoteRune(gocpp::recv(strconv), buf, r));
        }
    }

    void fmtFloat(struct fmt* f, double v, int size, gocpp::rune verb, int prec)
    {
        if(f->precPresent)
        {
            prec = f->prec;
        }
        auto num = AppendFloat(gocpp::recv(strconv), f->intbuf.make_slice(0, 1), v, byte(verb), prec, size);
        if(num[1] == '-' || num[1] == '+')
        {
            num = num.make_slice(1);
        }
        else
        {
            num[0] = '+';
        }
        if(f->space && num[0] == '+' && ! f->plus)
        {
            num[0] = ' ';
        }
        if(num[1] == 'I' || num[1] == 'N')
        {
            auto oldZero = f->zero;
            f->zero = false;
            if(num[1] == 'N' && ! f->space && ! f->plus)
            {
                num = num.make_slice(1);
            }
            pad(gocpp::recv(f), num);
            f->zero = oldZero;
            return;
        }
        if(f->sharp && verb != 'b')
        {
            auto digits = 0;
            //Go switch emulation
            {
                auto condition = verb;
                int conditionId = -1;
                if(condition == 'v') { conditionId = 0; }
                if(condition == 'g') { conditionId = 1; }
                if(condition == 'G') { conditionId = 2; }
                if(condition == 'x') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        digits = prec;
                        if(digits == - 1)
                        {
                            digits = 6;
                        }
                        break;
                }
            }
            gocpp::array<unsigned char, 6> tailBuf = {};
            auto tail = tailBuf.make_slice(0, 0);
            auto hasDecimalPoint = false;
            auto sawNonzeroDigit = false;
            for(auto i = 1; i < len(num); i++)
            {
                //Go switch emulation
                {
                    auto condition = num[i];
                    int conditionId = -1;
                    if(condition == '.') { conditionId = 0; }
                    else if(condition == 'p') { conditionId = 1; }
                    else if(condition == 'P') { conditionId = 2; }
                    else if(condition == 'e') { conditionId = 3; }
                    else if(condition == 'E') { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                            hasDecimalPoint = true;
                            break;
                        case 1:
                        case 2:
                            tail = append(tail, num.make_slice(i));
                            num = num.make_slice(0, i);
                            break;
                        case 3:
                        case 4:
                            if(verb != 'x' && verb != 'X')
                            {
                                tail = append(tail, num.make_slice(i));
                                num = num.make_slice(0, i);
                                break;
                            }
                        default:
                            if(num[i] != '0')
                            {
                                sawNonzeroDigit = true;
                            }
                            if(sawNonzeroDigit)
                            {
                                digits--;
                            }
                            break;
                    }
                }
            }
            if(! hasDecimalPoint)
            {
                if(len(num) == 2 && num[1] == '0')
                {
                    digits--;
                }
                num = append(num, '.');
            }
            for(; digits > 0; )
            {
                num = append(num, '0');
                digits--;
            }
            num = append(num, tail);
        }
        if(f->plus || num[0] != '+')
        {
            if(f->zero && f->widPresent && f->wid > len(num))
            {
                writeByte(gocpp::recv(f->buf), num[0]);
                writePadding(gocpp::recv(f), f->wid - len(num));
                write(gocpp::recv(f->buf), num.make_slice(1));
                return;
            }
            pad(gocpp::recv(f), num);
            return;
        }
        pad(gocpp::recv(f), num.make_slice(1));
    }

}

