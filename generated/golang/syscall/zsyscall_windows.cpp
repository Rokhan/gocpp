// generated by GoCpp from file '$(ImportDir)/syscall/zsyscall_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/syscall/zsyscall_windows.h"
#include "gocpp/support.h"

#include "golang/internal/syscall/windows/sysdll/sysdll.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/dll_windows.h"
#include "golang/syscall/security_windows.h"
#include "golang/syscall/syscall.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/types_windows_amd64.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/unsafe/unsafe.h"

namespace golang::syscall
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    gocpp::unsafe_pointer _;
    // Do the interface allocations only once for common
    // Errno values.
    gocpp::error errERROR_IO_PENDING = Errno(errnoERROR_IO_PENDING);
    gocpp::error errERROR_EINVAL = go_EINVAL;
    // errnoErr returns common boxed Errno values, to prevent
    // allocations at runtime.
    struct gocpp::error errnoErr(golang::syscall::Errno e)
    {
        //Go switch emulation
        {
            auto condition = e;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == errnoERROR_IO_PENDING) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return errERROR_EINVAL;
                    break;
                case 1:
                    return errERROR_IO_PENDING;
                    break;
            }
        }
        return e;
    }

    LazyDLL* modadvapi32 = NewLazyDLL(sysdll::Add("advapi32.dll"_s));
    LazyDLL* modcrypt32 = NewLazyDLL(sysdll::Add("crypt32.dll"_s));
    LazyDLL* moddnsapi = NewLazyDLL(sysdll::Add("dnsapi.dll"_s));
    LazyDLL* modiphlpapi = NewLazyDLL(sysdll::Add("iphlpapi.dll"_s));
    LazyDLL* modkernel32 = NewLazyDLL(sysdll::Add("kernel32.dll"_s));
    LazyDLL* modmswsock = NewLazyDLL(sysdll::Add("mswsock.dll"_s));
    LazyDLL* modnetapi32 = NewLazyDLL(sysdll::Add("netapi32.dll"_s));
    LazyDLL* modntdll = NewLazyDLL(sysdll::Add("ntdll.dll"_s));
    LazyDLL* modsecur32 = NewLazyDLL(sysdll::Add("secur32.dll"_s));
    LazyDLL* modshell32 = NewLazyDLL(sysdll::Add("shell32.dll"_s));
    LazyDLL* moduserenv = NewLazyDLL(sysdll::Add("userenv.dll"_s));
    LazyDLL* modws2_32 = NewLazyDLL(sysdll::Add("ws2_32.dll"_s));
    LazyProc* procConvertSidToStringSidW = rec::NewProc(gocpp::recv(modadvapi32), "ConvertSidToStringSidW"_s);
    LazyProc* procConvertStringSidToSidW = rec::NewProc(gocpp::recv(modadvapi32), "ConvertStringSidToSidW"_s);
    LazyProc* procCopySid = rec::NewProc(gocpp::recv(modadvapi32), "CopySid"_s);
    LazyProc* procCreateProcessAsUserW = rec::NewProc(gocpp::recv(modadvapi32), "CreateProcessAsUserW"_s);
    LazyProc* procCryptAcquireContextW = rec::NewProc(gocpp::recv(modadvapi32), "CryptAcquireContextW"_s);
    LazyProc* procCryptGenRandom = rec::NewProc(gocpp::recv(modadvapi32), "CryptGenRandom"_s);
    LazyProc* procCryptReleaseContext = rec::NewProc(gocpp::recv(modadvapi32), "CryptReleaseContext"_s);
    LazyProc* procGetLengthSid = rec::NewProc(gocpp::recv(modadvapi32), "GetLengthSid"_s);
    LazyProc* procGetTokenInformation = rec::NewProc(gocpp::recv(modadvapi32), "GetTokenInformation"_s);
    LazyProc* procLookupAccountNameW = rec::NewProc(gocpp::recv(modadvapi32), "LookupAccountNameW"_s);
    LazyProc* procLookupAccountSidW = rec::NewProc(gocpp::recv(modadvapi32), "LookupAccountSidW"_s);
    LazyProc* procOpenProcessToken = rec::NewProc(gocpp::recv(modadvapi32), "OpenProcessToken"_s);
    LazyProc* procRegCloseKey = rec::NewProc(gocpp::recv(modadvapi32), "RegCloseKey"_s);
    LazyProc* procRegEnumKeyExW = rec::NewProc(gocpp::recv(modadvapi32), "RegEnumKeyExW"_s);
    LazyProc* procRegOpenKeyExW = rec::NewProc(gocpp::recv(modadvapi32), "RegOpenKeyExW"_s);
    LazyProc* procRegQueryInfoKeyW = rec::NewProc(gocpp::recv(modadvapi32), "RegQueryInfoKeyW"_s);
    LazyProc* procRegQueryValueExW = rec::NewProc(gocpp::recv(modadvapi32), "RegQueryValueExW"_s);
    LazyProc* procCertAddCertificateContextToStore = rec::NewProc(gocpp::recv(modcrypt32), "CertAddCertificateContextToStore"_s);
    LazyProc* procCertCloseStore = rec::NewProc(gocpp::recv(modcrypt32), "CertCloseStore"_s);
    LazyProc* procCertCreateCertificateContext = rec::NewProc(gocpp::recv(modcrypt32), "CertCreateCertificateContext"_s);
    LazyProc* procCertEnumCertificatesInStore = rec::NewProc(gocpp::recv(modcrypt32), "CertEnumCertificatesInStore"_s);
    LazyProc* procCertFreeCertificateChain = rec::NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateChain"_s);
    LazyProc* procCertFreeCertificateContext = rec::NewProc(gocpp::recv(modcrypt32), "CertFreeCertificateContext"_s);
    LazyProc* procCertGetCertificateChain = rec::NewProc(gocpp::recv(modcrypt32), "CertGetCertificateChain"_s);
    LazyProc* procCertOpenStore = rec::NewProc(gocpp::recv(modcrypt32), "CertOpenStore"_s);
    LazyProc* procCertOpenSystemStoreW = rec::NewProc(gocpp::recv(modcrypt32), "CertOpenSystemStoreW"_s);
    LazyProc* procCertVerifyCertificateChainPolicy = rec::NewProc(gocpp::recv(modcrypt32), "CertVerifyCertificateChainPolicy"_s);
    LazyProc* procDnsNameCompare_W = rec::NewProc(gocpp::recv(moddnsapi), "DnsNameCompare_W"_s);
    LazyProc* procDnsQuery_W = rec::NewProc(gocpp::recv(moddnsapi), "DnsQuery_W"_s);
    LazyProc* procDnsRecordListFree = rec::NewProc(gocpp::recv(moddnsapi), "DnsRecordListFree"_s);
    LazyProc* procGetAdaptersInfo = rec::NewProc(gocpp::recv(modiphlpapi), "GetAdaptersInfo"_s);
    LazyProc* procGetIfEntry = rec::NewProc(gocpp::recv(modiphlpapi), "GetIfEntry"_s);
    LazyProc* procCancelIo = rec::NewProc(gocpp::recv(modkernel32), "CancelIo"_s);
    LazyProc* procCancelIoEx = rec::NewProc(gocpp::recv(modkernel32), "CancelIoEx"_s);
    LazyProc* procCloseHandle = rec::NewProc(gocpp::recv(modkernel32), "CloseHandle"_s);
    LazyProc* procCreateDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "CreateDirectoryW"_s);
    LazyProc* procCreateFileMappingW = rec::NewProc(gocpp::recv(modkernel32), "CreateFileMappingW"_s);
    LazyProc* procCreateFileW = rec::NewProc(gocpp::recv(modkernel32), "CreateFileW"_s);
    LazyProc* procCreateHardLinkW = rec::NewProc(gocpp::recv(modkernel32), "CreateHardLinkW"_s);
    LazyProc* procCreateIoCompletionPort = rec::NewProc(gocpp::recv(modkernel32), "CreateIoCompletionPort"_s);
    LazyProc* procCreatePipe = rec::NewProc(gocpp::recv(modkernel32), "CreatePipe"_s);
    LazyProc* procCreateProcessW = rec::NewProc(gocpp::recv(modkernel32), "CreateProcessW"_s);
    LazyProc* procCreateSymbolicLinkW = rec::NewProc(gocpp::recv(modkernel32), "CreateSymbolicLinkW"_s);
    LazyProc* procCreateToolhelp32Snapshot = rec::NewProc(gocpp::recv(modkernel32), "CreateToolhelp32Snapshot"_s);
    LazyProc* procDeleteFileW = rec::NewProc(gocpp::recv(modkernel32), "DeleteFileW"_s);
    LazyProc* procDeleteProcThreadAttributeList = rec::NewProc(gocpp::recv(modkernel32), "DeleteProcThreadAttributeList"_s);
    LazyProc* procDeviceIoControl = rec::NewProc(gocpp::recv(modkernel32), "DeviceIoControl"_s);
    LazyProc* procDuplicateHandle = rec::NewProc(gocpp::recv(modkernel32), "DuplicateHandle"_s);
    LazyProc* procExitProcess = rec::NewProc(gocpp::recv(modkernel32), "ExitProcess"_s);
    LazyProc* procFindClose = rec::NewProc(gocpp::recv(modkernel32), "FindClose"_s);
    LazyProc* procFindFirstFileW = rec::NewProc(gocpp::recv(modkernel32), "FindFirstFileW"_s);
    LazyProc* procFindNextFileW = rec::NewProc(gocpp::recv(modkernel32), "FindNextFileW"_s);
    LazyProc* procFlushFileBuffers = rec::NewProc(gocpp::recv(modkernel32), "FlushFileBuffers"_s);
    LazyProc* procFlushViewOfFile = rec::NewProc(gocpp::recv(modkernel32), "FlushViewOfFile"_s);
    LazyProc* procFormatMessageW = rec::NewProc(gocpp::recv(modkernel32), "FormatMessageW"_s);
    LazyProc* procFreeEnvironmentStringsW = rec::NewProc(gocpp::recv(modkernel32), "FreeEnvironmentStringsW"_s);
    LazyProc* procFreeLibrary = rec::NewProc(gocpp::recv(modkernel32), "FreeLibrary"_s);
    LazyProc* procGetCommandLineW = rec::NewProc(gocpp::recv(modkernel32), "GetCommandLineW"_s);
    LazyProc* procGetComputerNameW = rec::NewProc(gocpp::recv(modkernel32), "GetComputerNameW"_s);
    LazyProc* procGetConsoleMode = rec::NewProc(gocpp::recv(modkernel32), "GetConsoleMode"_s);
    LazyProc* procGetCurrentDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "GetCurrentDirectoryW"_s);
    LazyProc* procGetCurrentProcess = rec::NewProc(gocpp::recv(modkernel32), "GetCurrentProcess"_s);
    LazyProc* procGetCurrentProcessId = rec::NewProc(gocpp::recv(modkernel32), "GetCurrentProcessId"_s);
    LazyProc* procGetEnvironmentStringsW = rec::NewProc(gocpp::recv(modkernel32), "GetEnvironmentStringsW"_s);
    LazyProc* procGetEnvironmentVariableW = rec::NewProc(gocpp::recv(modkernel32), "GetEnvironmentVariableW"_s);
    LazyProc* procGetExitCodeProcess = rec::NewProc(gocpp::recv(modkernel32), "GetExitCodeProcess"_s);
    LazyProc* procGetFileAttributesExW = rec::NewProc(gocpp::recv(modkernel32), "GetFileAttributesExW"_s);
    LazyProc* procGetFileAttributesW = rec::NewProc(gocpp::recv(modkernel32), "GetFileAttributesW"_s);
    LazyProc* procGetFileInformationByHandle = rec::NewProc(gocpp::recv(modkernel32), "GetFileInformationByHandle"_s);
    LazyProc* procGetFileType = rec::NewProc(gocpp::recv(modkernel32), "GetFileType"_s);
    LazyProc* procGetFinalPathNameByHandleW = rec::NewProc(gocpp::recv(modkernel32), "GetFinalPathNameByHandleW"_s);
    LazyProc* procGetFullPathNameW = rec::NewProc(gocpp::recv(modkernel32), "GetFullPathNameW"_s);
    LazyProc* procGetLastError = rec::NewProc(gocpp::recv(modkernel32), "GetLastError"_s);
    LazyProc* procGetLongPathNameW = rec::NewProc(gocpp::recv(modkernel32), "GetLongPathNameW"_s);
    LazyProc* procGetProcAddress = rec::NewProc(gocpp::recv(modkernel32), "GetProcAddress"_s);
    LazyProc* procGetProcessTimes = rec::NewProc(gocpp::recv(modkernel32), "GetProcessTimes"_s);
    LazyProc* procGetQueuedCompletionStatus = rec::NewProc(gocpp::recv(modkernel32), "GetQueuedCompletionStatus"_s);
    LazyProc* procGetShortPathNameW = rec::NewProc(gocpp::recv(modkernel32), "GetShortPathNameW"_s);
    LazyProc* procGetStartupInfoW = rec::NewProc(gocpp::recv(modkernel32), "GetStartupInfoW"_s);
    LazyProc* procGetStdHandle = rec::NewProc(gocpp::recv(modkernel32), "GetStdHandle"_s);
    LazyProc* procGetSystemTimeAsFileTime = rec::NewProc(gocpp::recv(modkernel32), "GetSystemTimeAsFileTime"_s);
    LazyProc* procGetTempPathW = rec::NewProc(gocpp::recv(modkernel32), "GetTempPathW"_s);
    LazyProc* procGetTimeZoneInformation = rec::NewProc(gocpp::recv(modkernel32), "GetTimeZoneInformation"_s);
    LazyProc* procGetVersion = rec::NewProc(gocpp::recv(modkernel32), "GetVersion"_s);
    LazyProc* procInitializeProcThreadAttributeList = rec::NewProc(gocpp::recv(modkernel32), "InitializeProcThreadAttributeList"_s);
    LazyProc* procLoadLibraryW = rec::NewProc(gocpp::recv(modkernel32), "LoadLibraryW"_s);
    LazyProc* procLocalFree = rec::NewProc(gocpp::recv(modkernel32), "LocalFree"_s);
    LazyProc* procMapViewOfFile = rec::NewProc(gocpp::recv(modkernel32), "MapViewOfFile"_s);
    LazyProc* procMoveFileW = rec::NewProc(gocpp::recv(modkernel32), "MoveFileW"_s);
    LazyProc* procOpenProcess = rec::NewProc(gocpp::recv(modkernel32), "OpenProcess"_s);
    LazyProc* procPostQueuedCompletionStatus = rec::NewProc(gocpp::recv(modkernel32), "PostQueuedCompletionStatus"_s);
    LazyProc* procProcess32FirstW = rec::NewProc(gocpp::recv(modkernel32), "Process32FirstW"_s);
    LazyProc* procProcess32NextW = rec::NewProc(gocpp::recv(modkernel32), "Process32NextW"_s);
    LazyProc* procReadConsoleW = rec::NewProc(gocpp::recv(modkernel32), "ReadConsoleW"_s);
    LazyProc* procReadDirectoryChangesW = rec::NewProc(gocpp::recv(modkernel32), "ReadDirectoryChangesW"_s);
    LazyProc* procReadFile = rec::NewProc(gocpp::recv(modkernel32), "ReadFile"_s);
    LazyProc* procRemoveDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "RemoveDirectoryW"_s);
    LazyProc* procSetCurrentDirectoryW = rec::NewProc(gocpp::recv(modkernel32), "SetCurrentDirectoryW"_s);
    LazyProc* procSetEndOfFile = rec::NewProc(gocpp::recv(modkernel32), "SetEndOfFile"_s);
    LazyProc* procSetEnvironmentVariableW = rec::NewProc(gocpp::recv(modkernel32), "SetEnvironmentVariableW"_s);
    LazyProc* procSetFileAttributesW = rec::NewProc(gocpp::recv(modkernel32), "SetFileAttributesW"_s);
    LazyProc* procSetFileCompletionNotificationModes = rec::NewProc(gocpp::recv(modkernel32), "SetFileCompletionNotificationModes"_s);
    LazyProc* procSetFilePointer = rec::NewProc(gocpp::recv(modkernel32), "SetFilePointer"_s);
    LazyProc* procSetFileTime = rec::NewProc(gocpp::recv(modkernel32), "SetFileTime"_s);
    LazyProc* procSetHandleInformation = rec::NewProc(gocpp::recv(modkernel32), "SetHandleInformation"_s);
    LazyProc* procTerminateProcess = rec::NewProc(gocpp::recv(modkernel32), "TerminateProcess"_s);
    LazyProc* procUnmapViewOfFile = rec::NewProc(gocpp::recv(modkernel32), "UnmapViewOfFile"_s);
    LazyProc* procUpdateProcThreadAttribute = rec::NewProc(gocpp::recv(modkernel32), "UpdateProcThreadAttribute"_s);
    LazyProc* procVirtualLock = rec::NewProc(gocpp::recv(modkernel32), "VirtualLock"_s);
    LazyProc* procVirtualUnlock = rec::NewProc(gocpp::recv(modkernel32), "VirtualUnlock"_s);
    LazyProc* procWaitForSingleObject = rec::NewProc(gocpp::recv(modkernel32), "WaitForSingleObject"_s);
    LazyProc* procWriteConsoleW = rec::NewProc(gocpp::recv(modkernel32), "WriteConsoleW"_s);
    LazyProc* procWriteFile = rec::NewProc(gocpp::recv(modkernel32), "WriteFile"_s);
    LazyProc* procAcceptEx = rec::NewProc(gocpp::recv(modmswsock), "AcceptEx"_s);
    LazyProc* procGetAcceptExSockaddrs = rec::NewProc(gocpp::recv(modmswsock), "GetAcceptExSockaddrs"_s);
    LazyProc* procTransmitFile = rec::NewProc(gocpp::recv(modmswsock), "TransmitFile"_s);
    LazyProc* procNetApiBufferFree = rec::NewProc(gocpp::recv(modnetapi32), "NetApiBufferFree"_s);
    LazyProc* procNetGetJoinInformation = rec::NewProc(gocpp::recv(modnetapi32), "NetGetJoinInformation"_s);
    LazyProc* procNetUserGetInfo = rec::NewProc(gocpp::recv(modnetapi32), "NetUserGetInfo"_s);
    LazyProc* procRtlGetNtVersionNumbers = rec::NewProc(gocpp::recv(modntdll), "RtlGetNtVersionNumbers"_s);
    LazyProc* procGetUserNameExW = rec::NewProc(gocpp::recv(modsecur32), "GetUserNameExW"_s);
    LazyProc* procTranslateNameW = rec::NewProc(gocpp::recv(modsecur32), "TranslateNameW"_s);
    LazyProc* procCommandLineToArgvW = rec::NewProc(gocpp::recv(modshell32), "CommandLineToArgvW"_s);
    LazyProc* procGetUserProfileDirectoryW = rec::NewProc(gocpp::recv(moduserenv), "GetUserProfileDirectoryW"_s);
    LazyProc* procFreeAddrInfoW = rec::NewProc(gocpp::recv(modws2_32), "FreeAddrInfoW"_s);
    LazyProc* procGetAddrInfoW = rec::NewProc(gocpp::recv(modws2_32), "GetAddrInfoW"_s);
    LazyProc* procWSACleanup = rec::NewProc(gocpp::recv(modws2_32), "WSACleanup"_s);
    LazyProc* procWSAEnumProtocolsW = rec::NewProc(gocpp::recv(modws2_32), "WSAEnumProtocolsW"_s);
    LazyProc* procWSAIoctl = rec::NewProc(gocpp::recv(modws2_32), "WSAIoctl"_s);
    LazyProc* procWSARecv = rec::NewProc(gocpp::recv(modws2_32), "WSARecv"_s);
    LazyProc* procWSARecvFrom = rec::NewProc(gocpp::recv(modws2_32), "WSARecvFrom"_s);
    LazyProc* procWSASend = rec::NewProc(gocpp::recv(modws2_32), "WSASend"_s);
    LazyProc* procWSASendTo = rec::NewProc(gocpp::recv(modws2_32), "WSASendTo"_s);
    LazyProc* procWSAStartup = rec::NewProc(gocpp::recv(modws2_32), "WSAStartup"_s);
    LazyProc* procbind = rec::NewProc(gocpp::recv(modws2_32), "bind"_s);
    LazyProc* procclosesocket = rec::NewProc(gocpp::recv(modws2_32), "closesocket"_s);
    LazyProc* procconnect = rec::NewProc(gocpp::recv(modws2_32), "connect"_s);
    LazyProc* procgethostbyname = rec::NewProc(gocpp::recv(modws2_32), "gethostbyname"_s);
    LazyProc* procgetpeername = rec::NewProc(gocpp::recv(modws2_32), "getpeername"_s);
    LazyProc* procgetprotobyname = rec::NewProc(gocpp::recv(modws2_32), "getprotobyname"_s);
    LazyProc* procgetservbyname = rec::NewProc(gocpp::recv(modws2_32), "getservbyname"_s);
    LazyProc* procgetsockname = rec::NewProc(gocpp::recv(modws2_32), "getsockname"_s);
    LazyProc* procgetsockopt = rec::NewProc(gocpp::recv(modws2_32), "getsockopt"_s);
    LazyProc* proclisten = rec::NewProc(gocpp::recv(modws2_32), "listen"_s);
    LazyProc* procntohs = rec::NewProc(gocpp::recv(modws2_32), "ntohs"_s);
    LazyProc* procsetsockopt = rec::NewProc(gocpp::recv(modws2_32), "setsockopt"_s);
    LazyProc* procshutdown = rec::NewProc(gocpp::recv(modws2_32), "shutdown"_s);
    LazyProc* procsocket = rec::NewProc(gocpp::recv(modws2_32), "socket"_s);
    struct gocpp::error ConvertSidToStringSid(struct SID* sid, uint16_t** stringSid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_0, e1] = Syscall(rec::Addr(gocpp::recv(procConvertSidToStringSidW)), 2, uintptr_t(gocpp::unsafe_pointer(sid)), uintptr_t(gocpp::unsafe_pointer(stringSid)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ConvertStringSidToSid(uint16_t* stringSid, struct SID** sid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_1, e1] = Syscall(rec::Addr(gocpp::recv(procConvertStringSidToSidW)), 2, uintptr_t(gocpp::unsafe_pointer(stringSid)), uintptr_t(gocpp::unsafe_pointer(sid)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CopySid(uint32_t destSidLen, struct SID* destSid, struct SID* srcSid)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_2, e1] = Syscall(rec::Addr(gocpp::recv(procCopySid)), 3, uintptr_t(destSidLen), uintptr_t(gocpp::unsafe_pointer(destSid)), uintptr_t(gocpp::unsafe_pointer(srcSid)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateProcessAsUser(golang::syscall::Token token, uint16_t* appName, uint16_t* commandLine, struct SecurityAttributes* procSecurity, struct SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, struct StartupInfo* startupInfo, struct ProcessInformation* outProcInfo)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_3, e1] = Syscall12(rec::Addr(gocpp::recv(procCreateProcessAsUserW)), 11, uintptr_t(token), uintptr_t(gocpp::unsafe_pointer(appName)), uintptr_t(gocpp::unsafe_pointer(commandLine)), uintptr_t(gocpp::unsafe_pointer(procSecurity)), uintptr_t(gocpp::unsafe_pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(gocpp::unsafe_pointer(env)), uintptr_t(gocpp::unsafe_pointer(currentDir)), uintptr_t(gocpp::unsafe_pointer(startupInfo)), uintptr_t(gocpp::unsafe_pointer(outProcInfo)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptAcquireContext(golang::syscall::Handle* provhandle, uint16_t* container, uint16_t* provider, uint32_t provtype, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_4, e1] = Syscall6(rec::Addr(gocpp::recv(procCryptAcquireContextW)), 5, uintptr_t(gocpp::unsafe_pointer(provhandle)), uintptr_t(gocpp::unsafe_pointer(container)), uintptr_t(gocpp::unsafe_pointer(provider)), uintptr_t(provtype), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptGenRandom(golang::syscall::Handle provhandle, uint32_t buflen, unsigned char* buf)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_5, e1] = Syscall(rec::Addr(gocpp::recv(procCryptGenRandom)), 3, uintptr_t(provhandle), uintptr_t(buflen), uintptr_t(gocpp::unsafe_pointer(buf)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CryptReleaseContext(golang::syscall::Handle provhandle, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_6, e1] = Syscall(rec::Addr(gocpp::recv(procCryptReleaseContext)), 2, uintptr_t(provhandle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    uint32_t GetLengthSid(struct SID* sid)
    {
        uint32_t len;
        auto [r0, gocpp_id_7, gocpp_id_8] = Syscall(rec::Addr(gocpp::recv(procGetLengthSid)), 1, uintptr_t(gocpp::unsafe_pointer(sid)), 0, 0);
        len = uint32_t(r0);
        return len;
    }

    struct gocpp::error GetTokenInformation(golang::syscall::Token t, uint32_t infoClass, unsigned char* info, uint32_t infoLen, uint32_t* returnedLen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_9, e1] = Syscall6(rec::Addr(gocpp::recv(procGetTokenInformation)), 5, uintptr_t(t), uintptr_t(infoClass), uintptr_t(gocpp::unsafe_pointer(info)), uintptr_t(infoLen), uintptr_t(gocpp::unsafe_pointer(returnedLen)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error LookupAccountName(uint16_t* systemName, uint16_t* accountName, struct SID* sid, uint32_t* sidLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_10, e1] = Syscall9(rec::Addr(gocpp::recv(procLookupAccountNameW)), 7, uintptr_t(gocpp::unsafe_pointer(systemName)), uintptr_t(gocpp::unsafe_pointer(accountName)), uintptr_t(gocpp::unsafe_pointer(sid)), uintptr_t(gocpp::unsafe_pointer(sidLen)), uintptr_t(gocpp::unsafe_pointer(refdDomainName)), uintptr_t(gocpp::unsafe_pointer(refdDomainNameLen)), uintptr_t(gocpp::unsafe_pointer(use)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error LookupAccountSid(uint16_t* systemName, struct SID* sid, uint16_t* name, uint32_t* nameLen, uint16_t* refdDomainName, uint32_t* refdDomainNameLen, uint32_t* use)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_11, e1] = Syscall9(rec::Addr(gocpp::recv(procLookupAccountSidW)), 7, uintptr_t(gocpp::unsafe_pointer(systemName)), uintptr_t(gocpp::unsafe_pointer(sid)), uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(nameLen)), uintptr_t(gocpp::unsafe_pointer(refdDomainName)), uintptr_t(gocpp::unsafe_pointer(refdDomainNameLen)), uintptr_t(gocpp::unsafe_pointer(use)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error OpenProcessToken(golang::syscall::Handle h, uint32_t access, golang::syscall::Token* token)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_12, e1] = Syscall(rec::Addr(gocpp::recv(procOpenProcessToken)), 3, uintptr_t(h), uintptr_t(access), uintptr_t(gocpp::unsafe_pointer(token)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error RegCloseKey(golang::syscall::Handle key)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_13, gocpp_id_14] = Syscall(rec::Addr(gocpp::recv(procRegCloseKey)), 1, uintptr_t(key), 0, 0);
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error regEnumKeyEx(golang::syscall::Handle key, uint32_t index, uint16_t* name, uint32_t* nameLen, uint32_t* reserved, uint16_t* go_class, uint32_t* classLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_15, gocpp_id_16] = Syscall9(rec::Addr(gocpp::recv(procRegEnumKeyExW)), 8, uintptr_t(key), uintptr_t(index), uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(nameLen)), uintptr_t(gocpp::unsafe_pointer(reserved)), uintptr_t(gocpp::unsafe_pointer(go_class)), uintptr_t(gocpp::unsafe_pointer(classLen)), uintptr_t(gocpp::unsafe_pointer(lastWriteTime)), 0);
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegOpenKeyEx(golang::syscall::Handle key, uint16_t* subkey, uint32_t options, uint32_t desiredAccess, golang::syscall::Handle* result)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_17, gocpp_id_18] = Syscall6(rec::Addr(gocpp::recv(procRegOpenKeyExW)), 5, uintptr_t(key), uintptr_t(gocpp::unsafe_pointer(subkey)), uintptr_t(options), uintptr_t(desiredAccess), uintptr_t(gocpp::unsafe_pointer(result)), 0);
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegQueryInfoKey(golang::syscall::Handle key, uint16_t* go_class, uint32_t* classLen, uint32_t* reserved, uint32_t* subkeysLen, uint32_t* maxSubkeyLen, uint32_t* maxClassLen, uint32_t* valuesLen, uint32_t* maxValueNameLen, uint32_t* maxValueLen, uint32_t* saLen, struct Filetime* lastWriteTime)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_19, gocpp_id_20] = Syscall12(rec::Addr(gocpp::recv(procRegQueryInfoKeyW)), 12, uintptr_t(key), uintptr_t(gocpp::unsafe_pointer(go_class)), uintptr_t(gocpp::unsafe_pointer(classLen)), uintptr_t(gocpp::unsafe_pointer(reserved)), uintptr_t(gocpp::unsafe_pointer(subkeysLen)), uintptr_t(gocpp::unsafe_pointer(maxSubkeyLen)), uintptr_t(gocpp::unsafe_pointer(maxClassLen)), uintptr_t(gocpp::unsafe_pointer(valuesLen)), uintptr_t(gocpp::unsafe_pointer(maxValueNameLen)), uintptr_t(gocpp::unsafe_pointer(maxValueLen)), uintptr_t(gocpp::unsafe_pointer(saLen)), uintptr_t(gocpp::unsafe_pointer(lastWriteTime)));
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error RegQueryValueEx(golang::syscall::Handle key, uint16_t* name, uint32_t* reserved, uint32_t* valtype, unsigned char* buf, uint32_t* buflen)
    {
        struct gocpp::error regerrno;
        auto [r0, gocpp_id_21, gocpp_id_22] = Syscall6(rec::Addr(gocpp::recv(procRegQueryValueExW)), 6, uintptr_t(key), uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(reserved)), uintptr_t(gocpp::unsafe_pointer(valtype)), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(gocpp::unsafe_pointer(buflen)));
        if(r0 != 0)
        {
            regerrno = Errno(r0);
        }
        return regerrno;
    }

    struct gocpp::error CertAddCertificateContextToStore(golang::syscall::Handle store, struct CertContext* certContext, uint32_t addDisposition, struct CertContext** storeContext)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_23, e1] = Syscall6(rec::Addr(gocpp::recv(procCertAddCertificateContextToStore)), 4, uintptr_t(store), uintptr_t(gocpp::unsafe_pointer(certContext)), uintptr_t(addDisposition), uintptr_t(gocpp::unsafe_pointer(storeContext)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CertCloseStore(golang::syscall::Handle store, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_24, e1] = Syscall(rec::Addr(gocpp::recv(procCertCloseStore)), 2, uintptr_t(store), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct CertContext*, struct gocpp::error> CertCreateCertificateContext(uint32_t certEncodingType, unsigned char* certEncoded, uint32_t encodedLen)
    {
        struct CertContext* context;
        struct gocpp::error err;
        auto [r0, gocpp_id_25, e1] = Syscall(rec::Addr(gocpp::recv(procCertCreateCertificateContext)), 3, uintptr_t(certEncodingType), uintptr_t(gocpp::unsafe_pointer(certEncoded)), uintptr_t(encodedLen));
        context = (CertContext*)(gocpp::unsafe_pointer(r0));
        if(context == nullptr)
        {
            err = errnoErr(e1);
        }
        return {context, err};
    }

    std::tuple<struct CertContext*, struct gocpp::error> CertEnumCertificatesInStore(golang::syscall::Handle store, struct CertContext* prevContext)
    {
        struct CertContext* context;
        struct gocpp::error err;
        auto [r0, gocpp_id_26, e1] = Syscall(rec::Addr(gocpp::recv(procCertEnumCertificatesInStore)), 2, uintptr_t(store), uintptr_t(gocpp::unsafe_pointer(prevContext)), 0);
        context = (CertContext*)(gocpp::unsafe_pointer(r0));
        if(context == nullptr)
        {
            err = errnoErr(e1);
        }
        return {context, err};
    }

    void CertFreeCertificateChain(struct CertChainContext* ctx)
    {
        Syscall(rec::Addr(gocpp::recv(procCertFreeCertificateChain)), 1, uintptr_t(gocpp::unsafe_pointer(ctx)), 0, 0);
        return;
    }

    struct gocpp::error CertFreeCertificateContext(struct CertContext* ctx)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_27, e1] = Syscall(rec::Addr(gocpp::recv(procCertFreeCertificateContext)), 1, uintptr_t(gocpp::unsafe_pointer(ctx)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CertGetCertificateChain(golang::syscall::Handle engine, struct CertContext* leaf, struct Filetime* time, golang::syscall::Handle additionalStore, struct CertChainPara* para, uint32_t flags, uintptr_t reserved, struct CertChainContext** chainCtx)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_28, e1] = Syscall9(rec::Addr(gocpp::recv(procCertGetCertificateChain)), 8, uintptr_t(engine), uintptr_t(gocpp::unsafe_pointer(leaf)), uintptr_t(gocpp::unsafe_pointer(time)), uintptr_t(additionalStore), uintptr_t(gocpp::unsafe_pointer(para)), uintptr_t(flags), uintptr_t(reserved), uintptr_t(gocpp::unsafe_pointer(chainCtx)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> CertOpenStore(uintptr_t storeProvider, uint32_t msgAndCertEncodingType, uintptr_t cryptProv, uint32_t flags, uintptr_t para)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_29, e1] = Syscall6(rec::Addr(gocpp::recv(procCertOpenStore)), 5, uintptr_t(storeProvider), uintptr_t(msgAndCertEncodingType), uintptr_t(cryptProv), uintptr_t(flags), uintptr_t(para), 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> CertOpenSystemStore(golang::syscall::Handle hprov, uint16_t* name)
    {
        syscall::Handle store;
        struct gocpp::error err;
        auto [r0, gocpp_id_30, e1] = Syscall(rec::Addr(gocpp::recv(procCertOpenSystemStoreW)), 2, uintptr_t(hprov), uintptr_t(gocpp::unsafe_pointer(name)), 0);
        store = Handle(r0);
        if(store == 0)
        {
            err = errnoErr(e1);
        }
        return {store, err};
    }

    struct gocpp::error CertVerifyCertificateChainPolicy(uintptr_t policyOID, struct CertChainContext* chain, struct CertChainPolicyPara* para, struct CertChainPolicyStatus* status)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_31, e1] = Syscall6(rec::Addr(gocpp::recv(procCertVerifyCertificateChainPolicy)), 4, uintptr_t(policyOID), uintptr_t(gocpp::unsafe_pointer(chain)), uintptr_t(gocpp::unsafe_pointer(para)), uintptr_t(gocpp::unsafe_pointer(status)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    bool DnsNameCompare(uint16_t* name1, uint16_t* name2)
    {
        bool same;
        auto [r0, gocpp_id_32, gocpp_id_33] = Syscall(rec::Addr(gocpp::recv(procDnsNameCompare_W)), 2, uintptr_t(gocpp::unsafe_pointer(name1)), uintptr_t(gocpp::unsafe_pointer(name2)), 0);
        same = r0 != 0;
        return same;
    }

    struct gocpp::error DnsQuery(gocpp::string name, uint16_t qtype, uint32_t options, unsigned char* extra, struct DNSRecord** qrs, unsigned char* pr)
    {
        struct gocpp::error status;
        uint16_t* _p0 = {};
        std::tie(_p0, status) = UTF16PtrFromString(name);
        if(status != nullptr)
        {
            return status;
        }
        return _DnsQuery(_p0, qtype, options, extra, qrs, pr);
    }

    struct gocpp::error _DnsQuery(uint16_t* name, uint16_t qtype, uint32_t options, unsigned char* extra, struct DNSRecord** qrs, unsigned char* pr)
    {
        struct gocpp::error status;
        auto [r0, gocpp_id_34, gocpp_id_35] = Syscall6(rec::Addr(gocpp::recv(procDnsQuery_W)), 6, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(qtype), uintptr_t(options), uintptr_t(gocpp::unsafe_pointer(extra)), uintptr_t(gocpp::unsafe_pointer(qrs)), uintptr_t(gocpp::unsafe_pointer(pr)));
        if(r0 != 0)
        {
            status = Errno(r0);
        }
        return status;
    }

    void DnsRecordListFree(struct DNSRecord* rl, uint32_t freetype)
    {
        Syscall(rec::Addr(gocpp::recv(procDnsRecordListFree)), 2, uintptr_t(gocpp::unsafe_pointer(rl)), uintptr_t(freetype), 0);
        return;
    }

    struct gocpp::error GetAdaptersInfo(struct IpAdapterInfo* ai, uint32_t* ol)
    {
        struct gocpp::error errcode;
        auto [r0, gocpp_id_36, gocpp_id_37] = Syscall(rec::Addr(gocpp::recv(procGetAdaptersInfo)), 2, uintptr_t(gocpp::unsafe_pointer(ai)), uintptr_t(gocpp::unsafe_pointer(ol)), 0);
        if(r0 != 0)
        {
            errcode = Errno(r0);
        }
        return errcode;
    }

    struct gocpp::error GetIfEntry(struct MibIfRow* pIfRow)
    {
        struct gocpp::error errcode;
        auto [r0, gocpp_id_38, gocpp_id_39] = Syscall(rec::Addr(gocpp::recv(procGetIfEntry)), 1, uintptr_t(gocpp::unsafe_pointer(pIfRow)), 0, 0);
        if(r0 != 0)
        {
            errcode = Errno(r0);
        }
        return errcode;
    }

    struct gocpp::error CancelIo(golang::syscall::Handle s)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_40, e1] = Syscall(rec::Addr(gocpp::recv(procCancelIo)), 1, uintptr_t(s), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CancelIoEx(golang::syscall::Handle s, struct Overlapped* o)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_41, e1] = Syscall(rec::Addr(gocpp::recv(procCancelIoEx)), 2, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(o)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CloseHandle(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_42, e1] = Syscall(rec::Addr(gocpp::recv(procCloseHandle)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateDirectory(uint16_t* path, struct SecurityAttributes* sa)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_43, e1] = Syscall(rec::Addr(gocpp::recv(procCreateDirectoryW)), 2, uintptr_t(gocpp::unsafe_pointer(path)), uintptr_t(gocpp::unsafe_pointer(sa)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> CreateFileMapping(golang::syscall::Handle fhandle, struct SecurityAttributes* sa, uint32_t prot, uint32_t maxSizeHigh, uint32_t maxSizeLow, uint16_t* name)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_44, e1] = Syscall6(rec::Addr(gocpp::recv(procCreateFileMappingW)), 6, uintptr_t(fhandle), uintptr_t(gocpp::unsafe_pointer(sa)), uintptr_t(prot), uintptr_t(maxSizeHigh), uintptr_t(maxSizeLow), uintptr_t(gocpp::unsafe_pointer(name)));
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> CreateFile(uint16_t* name, uint32_t access, uint32_t mode, struct SecurityAttributes* sa, uint32_t createmode, uint32_t attrs, int32_t templatefile)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_45, e1] = Syscall9(rec::Addr(gocpp::recv(procCreateFileW)), 7, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(access), uintptr_t(mode), uintptr_t(gocpp::unsafe_pointer(sa)), uintptr_t(createmode), uintptr_t(attrs), uintptr_t(templatefile), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error CreateHardLink(uint16_t* filename, uint16_t* existingfilename, uintptr_t reserved)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_46, e1] = Syscall(rec::Addr(gocpp::recv(procCreateHardLinkW)), 3, uintptr_t(gocpp::unsafe_pointer(filename)), uintptr_t(gocpp::unsafe_pointer(existingfilename)), uintptr_t(reserved));
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> createIoCompletionPort(golang::syscall::Handle filehandle, golang::syscall::Handle cphandle, uintptr_t key, uint32_t threadcnt)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_47, e1] = Syscall6(rec::Addr(gocpp::recv(procCreateIoCompletionPort)), 4, uintptr_t(filehandle), uintptr_t(cphandle), uintptr_t(key), uintptr_t(threadcnt), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error CreatePipe(golang::syscall::Handle* readhandle, golang::syscall::Handle* writehandle, struct SecurityAttributes* sa, uint32_t size)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_48, e1] = Syscall6(rec::Addr(gocpp::recv(procCreatePipe)), 4, uintptr_t(gocpp::unsafe_pointer(readhandle)), uintptr_t(gocpp::unsafe_pointer(writehandle)), uintptr_t(gocpp::unsafe_pointer(sa)), uintptr_t(size), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateProcess(uint16_t* appName, uint16_t* commandLine, struct SecurityAttributes* procSecurity, struct SecurityAttributes* threadSecurity, bool inheritHandles, uint32_t creationFlags, uint16_t* env, uint16_t* currentDir, struct StartupInfo* startupInfo, struct ProcessInformation* outProcInfo)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandles)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_49, e1] = Syscall12(rec::Addr(gocpp::recv(procCreateProcessW)), 10, uintptr_t(gocpp::unsafe_pointer(appName)), uintptr_t(gocpp::unsafe_pointer(commandLine)), uintptr_t(gocpp::unsafe_pointer(procSecurity)), uintptr_t(gocpp::unsafe_pointer(threadSecurity)), uintptr_t(_p0), uintptr_t(creationFlags), uintptr_t(gocpp::unsafe_pointer(env)), uintptr_t(gocpp::unsafe_pointer(currentDir)), uintptr_t(gocpp::unsafe_pointer(startupInfo)), uintptr_t(gocpp::unsafe_pointer(outProcInfo)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error CreateSymbolicLink(uint16_t* symlinkfilename, uint16_t* targetfilename, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_50, e1] = Syscall(rec::Addr(gocpp::recv(procCreateSymbolicLinkW)), 3, uintptr_t(gocpp::unsafe_pointer(symlinkfilename)), uintptr_t(gocpp::unsafe_pointer(targetfilename)), uintptr_t(flags));
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> CreateToolhelp32Snapshot(uint32_t flags, uint32_t processId)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_51, e1] = Syscall(rec::Addr(gocpp::recv(procCreateToolhelp32Snapshot)), 2, uintptr_t(flags), uintptr_t(processId), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error DeleteFile(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_52, e1] = Syscall(rec::Addr(gocpp::recv(procDeleteFileW)), 1, uintptr_t(gocpp::unsafe_pointer(path)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void deleteProcThreadAttributeList(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist)
    {
        Syscall(rec::Addr(gocpp::recv(procDeleteProcThreadAttributeList)), 1, uintptr_t(gocpp::unsafe_pointer(attrlist)), 0, 0);
        return;
    }

    struct gocpp::error DeviceIoControl(golang::syscall::Handle handle, uint32_t ioControlCode, unsigned char* inBuffer, uint32_t inBufferSize, unsigned char* outBuffer, uint32_t outBufferSize, uint32_t* bytesReturned, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_53, e1] = Syscall9(rec::Addr(gocpp::recv(procDeviceIoControl)), 8, uintptr_t(handle), uintptr_t(ioControlCode), uintptr_t(gocpp::unsafe_pointer(inBuffer)), uintptr_t(inBufferSize), uintptr_t(gocpp::unsafe_pointer(outBuffer)), uintptr_t(outBufferSize), uintptr_t(gocpp::unsafe_pointer(bytesReturned)), uintptr_t(gocpp::unsafe_pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error DuplicateHandle(golang::syscall::Handle hSourceProcessHandle, golang::syscall::Handle hSourceHandle, golang::syscall::Handle hTargetProcessHandle, golang::syscall::Handle* lpTargetHandle, uint32_t dwDesiredAccess, bool bInheritHandle, uint32_t dwOptions)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(bInheritHandle)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_54, e1] = Syscall9(rec::Addr(gocpp::recv(procDuplicateHandle)), 7, uintptr_t(hSourceProcessHandle), uintptr_t(hSourceHandle), uintptr_t(hTargetProcessHandle), uintptr_t(gocpp::unsafe_pointer(lpTargetHandle)), uintptr_t(dwDesiredAccess), uintptr_t(_p0), uintptr_t(dwOptions), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void ExitProcess(uint32_t exitcode)
    {
        Syscall(rec::Addr(gocpp::recv(procExitProcess)), 1, uintptr_t(exitcode), 0, 0);
        return;
    }

    struct gocpp::error FindClose(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_55, e1] = Syscall(rec::Addr(gocpp::recv(procFindClose)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> findFirstFile1(uint16_t* name, struct win32finddata1* data)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_56, e1] = Syscall(rec::Addr(gocpp::recv(procFindFirstFileW)), 2, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(data)), 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error findNextFile1(golang::syscall::Handle handle, struct win32finddata1* data)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_57, e1] = Syscall(rec::Addr(gocpp::recv(procFindNextFileW)), 2, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(data)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FlushFileBuffers(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_58, e1] = Syscall(rec::Addr(gocpp::recv(procFlushFileBuffers)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FlushViewOfFile(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_59, e1] = Syscall(rec::Addr(gocpp::recv(procFlushViewOfFile)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> formatMessage(uint32_t flags, uintptr_t msgsrc, uint32_t msgid, uint32_t langid, gocpp::slice<uint16_t> buf, unsigned char* args)
    {
        uint32_t n;
        struct gocpp::error err;
        uint16_t* _p0 = {};
        if(len(buf) > 0)
        {
            _p0 = & buf[0];
        }
        auto [r0, gocpp_id_60, e1] = Syscall9(rec::Addr(gocpp::recv(procFormatMessageW)), 7, uintptr_t(flags), uintptr_t(msgsrc), uintptr_t(msgid), uintptr_t(langid), uintptr_t(gocpp::unsafe_pointer(_p0)), uintptr_t(len(buf)), uintptr_t(gocpp::unsafe_pointer(args)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error FreeEnvironmentStrings(uint16_t* envs)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_61, e1] = Syscall(rec::Addr(gocpp::recv(procFreeEnvironmentStringsW)), 1, uintptr_t(gocpp::unsafe_pointer(envs)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error FreeLibrary(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_62, e1] = Syscall(rec::Addr(gocpp::recv(procFreeLibrary)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t* GetCommandLine()
    {
        uint16_t* cmd;
        auto [r0, gocpp_id_63, gocpp_id_64] = Syscall(rec::Addr(gocpp::recv(procGetCommandLineW)), 0, 0, 0, 0);
        cmd = (uint16_t*)(gocpp::unsafe_pointer(r0));
        return cmd;
    }

    struct gocpp::error GetComputerName(uint16_t* buf, uint32_t* n)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_65, e1] = Syscall(rec::Addr(gocpp::recv(procGetComputerNameW)), 2, uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(gocpp::unsafe_pointer(n)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error GetConsoleMode(golang::syscall::Handle console, uint32_t* mode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_66, e1] = Syscall(rec::Addr(gocpp::recv(procGetConsoleMode)), 2, uintptr_t(console), uintptr_t(gocpp::unsafe_pointer(mode)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetCurrentDirectory(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_67, e1] = Syscall(rec::Addr(gocpp::recv(procGetCurrentDirectoryW)), 2, uintptr_t(buflen), uintptr_t(gocpp::unsafe_pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> GetCurrentProcess()
    {
        syscall::Handle pseudoHandle;
        struct gocpp::error err;
        auto [r0, gocpp_id_68, e1] = Syscall(rec::Addr(gocpp::recv(procGetCurrentProcess)), 0, 0, 0, 0);
        pseudoHandle = Handle(r0);
        if(pseudoHandle == 0)
        {
            err = errnoErr(e1);
        }
        return {pseudoHandle, err};
    }

    uint32_t getCurrentProcessId()
    {
        uint32_t pid;
        auto [r0, gocpp_id_69, gocpp_id_70] = Syscall(rec::Addr(gocpp::recv(procGetCurrentProcessId)), 0, 0, 0, 0);
        pid = uint32_t(r0);
        return pid;
    }

    std::tuple<uint16_t*, struct gocpp::error> GetEnvironmentStrings()
    {
        uint16_t* envs;
        struct gocpp::error err;
        auto [r0, gocpp_id_71, e1] = Syscall(rec::Addr(gocpp::recv(procGetEnvironmentStringsW)), 0, 0, 0, 0);
        envs = (uint16_t*)(gocpp::unsafe_pointer(r0));
        if(envs == nullptr)
        {
            err = errnoErr(e1);
        }
        return {envs, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetEnvironmentVariable(uint16_t* name, uint16_t* buffer, uint32_t size)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_72, e1] = Syscall(rec::Addr(gocpp::recv(procGetEnvironmentVariableW)), 3, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(buffer)), uintptr_t(size));
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error GetExitCodeProcess(golang::syscall::Handle handle, uint32_t* exitcode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_73, e1] = Syscall(rec::Addr(gocpp::recv(procGetExitCodeProcess)), 2, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(exitcode)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error GetFileAttributesEx(uint16_t* name, uint32_t level, unsigned char* info)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_74, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileAttributesExW)), 3, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(level), uintptr_t(gocpp::unsafe_pointer(info)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileAttributes(uint16_t* name)
    {
        uint32_t attrs;
        struct gocpp::error err;
        auto [r0, gocpp_id_75, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileAttributesW)), 1, uintptr_t(gocpp::unsafe_pointer(name)), 0, 0);
        attrs = uint32_t(r0);
        if(attrs == INVALID_FILE_ATTRIBUTES)
        {
            err = errnoErr(e1);
        }
        return {attrs, err};
    }

    struct gocpp::error GetFileInformationByHandle(golang::syscall::Handle handle, struct ByHandleFileInformation* data)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_76, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileInformationByHandle)), 2, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(data)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetFileType(golang::syscall::Handle filehandle)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_77, e1] = Syscall(rec::Addr(gocpp::recv(procGetFileType)), 1, uintptr_t(filehandle), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> getFinalPathNameByHandle(golang::syscall::Handle file, uint16_t* filePath, uint32_t filePathSize, uint32_t flags)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_78, e1] = Syscall6(rec::Addr(gocpp::recv(procGetFinalPathNameByHandleW)), 4, uintptr_t(file), uintptr_t(gocpp::unsafe_pointer(filePath)), uintptr_t(filePathSize), uintptr_t(flags), 0, 0);
        n = uint32_t(r0);
        if(n == 0 || n >= filePathSize)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetFullPathName(uint16_t* path, uint32_t buflen, uint16_t* buf, uint16_t** fname)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_79, e1] = Syscall6(rec::Addr(gocpp::recv(procGetFullPathNameW)), 4, uintptr_t(gocpp::unsafe_pointer(path)), uintptr_t(buflen), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(gocpp::unsafe_pointer(fname)), 0, 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error GetLastError()
    {
        struct gocpp::error lasterr;
        auto [r0, gocpp_id_80, gocpp_id_81] = Syscall(rec::Addr(gocpp::recv(procGetLastError)), 0, 0, 0, 0);
        if(r0 != 0)
        {
            lasterr = Errno(r0);
        }
        return lasterr;
    }

    std::tuple<uint32_t, struct gocpp::error> GetLongPathName(uint16_t* path, uint16_t* buf, uint32_t buflen)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_82, e1] = Syscall(rec::Addr(gocpp::recv(procGetLongPathNameW)), 3, uintptr_t(gocpp::unsafe_pointer(path)), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uintptr_t, struct gocpp::error> GetProcAddress(golang::syscall::Handle module, gocpp::string procname)
    {
        uintptr_t proc;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(procname);
        if(err != nullptr)
        {
            return {proc, err};
        }
        return _GetProcAddress(module, _p0);
    }

    std::tuple<uintptr_t, struct gocpp::error> _GetProcAddress(golang::syscall::Handle module, unsigned char* procname)
    {
        uintptr_t proc;
        struct gocpp::error err;
        auto [r0, gocpp_id_83, e1] = Syscall(rec::Addr(gocpp::recv(procGetProcAddress)), 2, uintptr_t(module), uintptr_t(gocpp::unsafe_pointer(procname)), 0);
        proc = uintptr_t(r0);
        if(proc == 0)
        {
            err = errnoErr(e1);
        }
        return {proc, err};
    }

    struct gocpp::error GetProcessTimes(golang::syscall::Handle handle, struct Filetime* creationTime, struct Filetime* exitTime, struct Filetime* kernelTime, struct Filetime* userTime)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_84, e1] = Syscall6(rec::Addr(gocpp::recv(procGetProcessTimes)), 5, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(creationTime)), uintptr_t(gocpp::unsafe_pointer(exitTime)), uintptr_t(gocpp::unsafe_pointer(kernelTime)), uintptr_t(gocpp::unsafe_pointer(userTime)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error getQueuedCompletionStatus(golang::syscall::Handle cphandle, uint32_t* qty, uintptr_t* key, struct Overlapped** overlapped, uint32_t timeout)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_85, e1] = Syscall6(rec::Addr(gocpp::recv(procGetQueuedCompletionStatus)), 5, uintptr_t(cphandle), uintptr_t(gocpp::unsafe_pointer(qty)), uintptr_t(gocpp::unsafe_pointer(key)), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(timeout), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> GetShortPathName(uint16_t* longpath, uint16_t* shortpath, uint32_t buflen)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_86, e1] = Syscall(rec::Addr(gocpp::recv(procGetShortPathNameW)), 3, uintptr_t(gocpp::unsafe_pointer(longpath)), uintptr_t(gocpp::unsafe_pointer(shortpath)), uintptr_t(buflen));
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    void getStartupInfo(struct StartupInfo* startupInfo)
    {
        Syscall(rec::Addr(gocpp::recv(procGetStartupInfoW)), 1, uintptr_t(gocpp::unsafe_pointer(startupInfo)), 0, 0);
        return;
    }

    std::tuple<syscall::Handle, struct gocpp::error> GetStdHandle(int stdhandle)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_87, e1] = Syscall(rec::Addr(gocpp::recv(procGetStdHandle)), 1, uintptr_t(stdhandle), 0, 0);
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    void GetSystemTimeAsFileTime(struct Filetime* time)
    {
        Syscall(rec::Addr(gocpp::recv(procGetSystemTimeAsFileTime)), 1, uintptr_t(gocpp::unsafe_pointer(time)), 0, 0);
        return;
    }

    std::tuple<uint32_t, struct gocpp::error> GetTempPath(uint32_t buflen, uint16_t* buf)
    {
        uint32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_88, e1] = Syscall(rec::Addr(gocpp::recv(procGetTempPathW)), 2, uintptr_t(buflen), uintptr_t(gocpp::unsafe_pointer(buf)), 0);
        n = uint32_t(r0);
        if(n == 0)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetTimeZoneInformation(struct Timezoneinformation* tzi)
    {
        uint32_t rc;
        struct gocpp::error err;
        auto [r0, gocpp_id_89, e1] = Syscall(rec::Addr(gocpp::recv(procGetTimeZoneInformation)), 1, uintptr_t(gocpp::unsafe_pointer(tzi)), 0, 0);
        rc = uint32_t(r0);
        if(rc == 0xffffffff)
        {
            err = errnoErr(e1);
        }
        return {rc, err};
    }

    std::tuple<uint32_t, struct gocpp::error> GetVersion()
    {
        uint32_t ver;
        struct gocpp::error err;
        auto [r0, gocpp_id_90, e1] = Syscall(rec::Addr(gocpp::recv(procGetVersion)), 0, 0, 0, 0);
        ver = uint32_t(r0);
        if(ver == 0)
        {
            err = errnoErr(e1);
        }
        return {ver, err};
    }

    struct gocpp::error initializeProcThreadAttributeList(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t attrcount, uint32_t flags, uintptr_t* size)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_91, e1] = Syscall6(rec::Addr(gocpp::recv(procInitializeProcThreadAttributeList)), 4, uintptr_t(gocpp::unsafe_pointer(attrlist)), uintptr_t(attrcount), uintptr_t(flags), uintptr_t(gocpp::unsafe_pointer(size)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> LoadLibrary(gocpp::string libname)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        uint16_t* _p0 = {};
        std::tie(_p0, err) = UTF16PtrFromString(libname);
        if(err != nullptr)
        {
            return {handle, err};
        }
        return _LoadLibrary(_p0);
    }

    std::tuple<syscall::Handle, struct gocpp::error> _LoadLibrary(uint16_t* libname)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_92, e1] = Syscall(rec::Addr(gocpp::recv(procLoadLibraryW)), 1, uintptr_t(gocpp::unsafe_pointer(libname)), 0, 0);
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<syscall::Handle, struct gocpp::error> LocalFree(golang::syscall::Handle hmem)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_93, e1] = Syscall(rec::Addr(gocpp::recv(procLocalFree)), 1, uintptr_t(hmem), 0, 0);
        handle = Handle(r0);
        if(handle != 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    std::tuple<uintptr_t, struct gocpp::error> MapViewOfFile(golang::syscall::Handle handle, uint32_t access, uint32_t offsetHigh, uint32_t offsetLow, uintptr_t length)
    {
        uintptr_t addr;
        struct gocpp::error err;
        auto [r0, gocpp_id_94, e1] = Syscall6(rec::Addr(gocpp::recv(procMapViewOfFile)), 5, uintptr_t(handle), uintptr_t(access), uintptr_t(offsetHigh), uintptr_t(offsetLow), uintptr_t(length), 0);
        addr = uintptr_t(r0);
        if(addr == 0)
        {
            err = errnoErr(e1);
        }
        return {addr, err};
    }

    struct gocpp::error MoveFile(uint16_t* from, uint16_t* to)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_95, e1] = Syscall(rec::Addr(gocpp::recv(procMoveFileW)), 2, uintptr_t(gocpp::unsafe_pointer(from)), uintptr_t(gocpp::unsafe_pointer(to)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> OpenProcess(uint32_t da, bool inheritHandle, uint32_t pid)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(inheritHandle)
        {
            _p0 = 1;
        }
        auto [r0, gocpp_id_96, e1] = Syscall(rec::Addr(gocpp::recv(procOpenProcess)), 3, uintptr_t(da), uintptr_t(_p0), uintptr_t(pid));
        handle = Handle(r0);
        if(handle == 0)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

    struct gocpp::error postQueuedCompletionStatus(golang::syscall::Handle cphandle, uint32_t qty, uintptr_t key, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_97, e1] = Syscall6(rec::Addr(gocpp::recv(procPostQueuedCompletionStatus)), 4, uintptr_t(cphandle), uintptr_t(qty), uintptr_t(key), uintptr_t(gocpp::unsafe_pointer(overlapped)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Process32First(golang::syscall::Handle snapshot, struct ProcessEntry32* procEntry)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_98, e1] = Syscall(rec::Addr(gocpp::recv(procProcess32FirstW)), 2, uintptr_t(snapshot), uintptr_t(gocpp::unsafe_pointer(procEntry)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Process32Next(golang::syscall::Handle snapshot, struct ProcessEntry32* procEntry)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_99, e1] = Syscall(rec::Addr(gocpp::recv(procProcess32NextW)), 2, uintptr_t(snapshot), uintptr_t(gocpp::unsafe_pointer(procEntry)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ReadConsole(golang::syscall::Handle console, uint16_t* buf, uint32_t toread, uint32_t* read, unsigned char* inputControl)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_100, e1] = Syscall6(rec::Addr(gocpp::recv(procReadConsoleW)), 5, uintptr_t(console), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(toread), uintptr_t(gocpp::unsafe_pointer(read)), uintptr_t(gocpp::unsafe_pointer(inputControl)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error ReadDirectoryChanges(golang::syscall::Handle handle, unsigned char* buf, uint32_t buflen, bool watchSubTree, uint32_t mask, uint32_t* retlen, struct Overlapped* overlapped, uintptr_t completionRoutine)
    {
        struct gocpp::error err;
        uint32_t _p0 = {};
        if(watchSubTree)
        {
            _p0 = 1;
        }
        auto [r1, gocpp_id_101, e1] = Syscall9(rec::Addr(gocpp::recv(procReadDirectoryChangesW)), 8, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(buflen), uintptr_t(_p0), uintptr_t(mask), uintptr_t(gocpp::unsafe_pointer(retlen)), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(completionRoutine), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error readFile(golang::syscall::Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            _p0 = & buf[0];
        }
        auto [r1, gocpp_id_102, e1] = Syscall6(rec::Addr(gocpp::recv(procReadFile)), 5, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(_p0)), uintptr_t(len(buf)), uintptr_t(gocpp::unsafe_pointer(done)), uintptr_t(gocpp::unsafe_pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error RemoveDirectory(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_103, e1] = Syscall(rec::Addr(gocpp::recv(procRemoveDirectoryW)), 1, uintptr_t(gocpp::unsafe_pointer(path)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetCurrentDirectory(uint16_t* path)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_104, e1] = Syscall(rec::Addr(gocpp::recv(procSetCurrentDirectoryW)), 1, uintptr_t(gocpp::unsafe_pointer(path)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetEndOfFile(golang::syscall::Handle handle)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_105, e1] = Syscall(rec::Addr(gocpp::recv(procSetEndOfFile)), 1, uintptr_t(handle), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetEnvironmentVariable(uint16_t* name, uint16_t* value)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_106, e1] = Syscall(rec::Addr(gocpp::recv(procSetEnvironmentVariableW)), 2, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(value)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetFileAttributes(uint16_t* name, uint32_t attrs)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_107, e1] = Syscall(rec::Addr(gocpp::recv(procSetFileAttributesW)), 2, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(attrs), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetFileCompletionNotificationModes(golang::syscall::Handle handle, uint8_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_108, e1] = Syscall(rec::Addr(gocpp::recv(procSetFileCompletionNotificationModes)), 2, uintptr_t(handle), uintptr_t(flags), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> SetFilePointer(golang::syscall::Handle handle, int32_t lowoffset, int32_t* highoffsetptr, uint32_t whence)
    {
        uint32_t newlowoffset;
        struct gocpp::error err;
        auto [r0, gocpp_id_109, e1] = Syscall6(rec::Addr(gocpp::recv(procSetFilePointer)), 4, uintptr_t(handle), uintptr_t(lowoffset), uintptr_t(gocpp::unsafe_pointer(highoffsetptr)), uintptr_t(whence), 0, 0);
        newlowoffset = uint32_t(r0);
        if(newlowoffset == 0xffffffff)
        {
            err = errnoErr(e1);
        }
        return {newlowoffset, err};
    }

    struct gocpp::error SetFileTime(golang::syscall::Handle handle, struct Filetime* ctime, struct Filetime* atime, struct Filetime* wtime)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_110, e1] = Syscall6(rec::Addr(gocpp::recv(procSetFileTime)), 4, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(ctime)), uintptr_t(gocpp::unsafe_pointer(atime)), uintptr_t(gocpp::unsafe_pointer(wtime)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error SetHandleInformation(golang::syscall::Handle handle, uint32_t mask, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_111, e1] = Syscall(rec::Addr(gocpp::recv(procSetHandleInformation)), 3, uintptr_t(handle), uintptr_t(mask), uintptr_t(flags));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error TerminateProcess(golang::syscall::Handle handle, uint32_t exitcode)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_112, e1] = Syscall(rec::Addr(gocpp::recv(procTerminateProcess)), 2, uintptr_t(handle), uintptr_t(exitcode), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error UnmapViewOfFile(uintptr_t addr)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_113, e1] = Syscall(rec::Addr(gocpp::recv(procUnmapViewOfFile)), 1, uintptr_t(addr), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error updateProcThreadAttribute(struct _PROC_THREAD_ATTRIBUTE_LIST* attrlist, uint32_t flags, uintptr_t attr, gocpp::unsafe_pointer value, uintptr_t size, gocpp::unsafe_pointer prevvalue, uintptr_t* returnedsize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_114, e1] = Syscall9(rec::Addr(gocpp::recv(procUpdateProcThreadAttribute)), 7, uintptr_t(gocpp::unsafe_pointer(attrlist)), uintptr_t(flags), uintptr_t(attr), uintptr_t(value), uintptr_t(size), uintptr_t(prevvalue), uintptr_t(gocpp::unsafe_pointer(returnedsize)), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error VirtualLock(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_115, e1] = Syscall(rec::Addr(gocpp::recv(procVirtualLock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error VirtualUnlock(uintptr_t addr, uintptr_t length)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_116, e1] = Syscall(rec::Addr(gocpp::recv(procVirtualUnlock)), 2, uintptr_t(addr), uintptr_t(length), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<uint32_t, struct gocpp::error> WaitForSingleObject(golang::syscall::Handle handle, uint32_t waitMilliseconds)
    {
        uint32_t event;
        struct gocpp::error err;
        auto [r0, gocpp_id_117, e1] = Syscall(rec::Addr(gocpp::recv(procWaitForSingleObject)), 2, uintptr_t(handle), uintptr_t(waitMilliseconds), 0);
        event = uint32_t(r0);
        if(event == 0xffffffff)
        {
            err = errnoErr(e1);
        }
        return {event, err};
    }

    struct gocpp::error WriteConsole(golang::syscall::Handle console, uint16_t* buf, uint32_t towrite, uint32_t* written, unsigned char* reserved)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_118, e1] = Syscall6(rec::Addr(gocpp::recv(procWriteConsoleW)), 5, uintptr_t(console), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(towrite), uintptr_t(gocpp::unsafe_pointer(written)), uintptr_t(gocpp::unsafe_pointer(reserved)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error writeFile(golang::syscall::Handle handle, gocpp::slice<unsigned char> buf, uint32_t* done, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        unsigned char* _p0 = {};
        if(len(buf) > 0)
        {
            _p0 = & buf[0];
        }
        auto [r1, gocpp_id_119, e1] = Syscall6(rec::Addr(gocpp::recv(procWriteFile)), 5, uintptr_t(handle), uintptr_t(gocpp::unsafe_pointer(_p0)), uintptr_t(len(buf)), uintptr_t(gocpp::unsafe_pointer(done)), uintptr_t(gocpp::unsafe_pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error AcceptEx(golang::syscall::Handle ls, golang::syscall::Handle as, unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, uint32_t* recvd, struct Overlapped* overlapped)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_120, e1] = Syscall9(rec::Addr(gocpp::recv(procAcceptEx)), 8, uintptr_t(ls), uintptr_t(as), uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(gocpp::unsafe_pointer(recvd)), uintptr_t(gocpp::unsafe_pointer(overlapped)), 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void GetAcceptExSockaddrs(unsigned char* buf, uint32_t rxdatalen, uint32_t laddrlen, uint32_t raddrlen, struct RawSockaddrAny** lrsa, int32_t* lrsalen, struct RawSockaddrAny** rrsa, int32_t* rrsalen)
    {
        Syscall9(rec::Addr(gocpp::recv(procGetAcceptExSockaddrs)), 8, uintptr_t(gocpp::unsafe_pointer(buf)), uintptr_t(rxdatalen), uintptr_t(laddrlen), uintptr_t(raddrlen), uintptr_t(gocpp::unsafe_pointer(lrsa)), uintptr_t(gocpp::unsafe_pointer(lrsalen)), uintptr_t(gocpp::unsafe_pointer(rrsa)), uintptr_t(gocpp::unsafe_pointer(rrsalen)), 0);
        return;
    }

    struct gocpp::error TransmitFile(golang::syscall::Handle s, golang::syscall::Handle handle, uint32_t bytesToWrite, uint32_t bytsPerSend, struct Overlapped* overlapped, struct TransmitFileBuffers* transmitFileBuf, uint32_t flags)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_121, e1] = Syscall9(rec::Addr(gocpp::recv(procTransmitFile)), 7, uintptr_t(s), uintptr_t(handle), uintptr_t(bytesToWrite), uintptr_t(bytsPerSend), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(gocpp::unsafe_pointer(transmitFileBuf)), uintptr_t(flags), 0, 0);
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error NetApiBufferFree(unsigned char* buf)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_122, gocpp_id_123] = Syscall(rec::Addr(gocpp::recv(procNetApiBufferFree)), 1, uintptr_t(gocpp::unsafe_pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            neterr = Errno(r0);
        }
        return neterr;
    }

    struct gocpp::error NetGetJoinInformation(uint16_t* server, uint16_t** name, uint32_t* bufType)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_124, gocpp_id_125] = Syscall(rec::Addr(gocpp::recv(procNetGetJoinInformation)), 3, uintptr_t(gocpp::unsafe_pointer(server)), uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(bufType)));
        if(r0 != 0)
        {
            neterr = Errno(r0);
        }
        return neterr;
    }

    struct gocpp::error NetUserGetInfo(uint16_t* serverName, uint16_t* userName, uint32_t level, unsigned char** buf)
    {
        struct gocpp::error neterr;
        auto [r0, gocpp_id_126, gocpp_id_127] = Syscall6(rec::Addr(gocpp::recv(procNetUserGetInfo)), 4, uintptr_t(gocpp::unsafe_pointer(serverName)), uintptr_t(gocpp::unsafe_pointer(userName)), uintptr_t(level), uintptr_t(gocpp::unsafe_pointer(buf)), 0, 0);
        if(r0 != 0)
        {
            neterr = Errno(r0);
        }
        return neterr;
    }

    void rtlGetNtVersionNumbers(uint32_t* majorVersion, uint32_t* minorVersion, uint32_t* buildNumber)
    {
        Syscall(rec::Addr(gocpp::recv(procRtlGetNtVersionNumbers)), 3, uintptr_t(gocpp::unsafe_pointer(majorVersion)), uintptr_t(gocpp::unsafe_pointer(minorVersion)), uintptr_t(gocpp::unsafe_pointer(buildNumber)));
        return;
    }

    struct gocpp::error GetUserNameEx(uint32_t nameFormat, uint16_t* nameBuffre, uint32_t* nSize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_128, e1] = Syscall(rec::Addr(gocpp::recv(procGetUserNameExW)), 3, uintptr_t(nameFormat), uintptr_t(gocpp::unsafe_pointer(nameBuffre)), uintptr_t(gocpp::unsafe_pointer(nSize)));
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error TranslateName(uint16_t* accName, uint32_t accNameFormat, uint32_t desiredNameFormat, uint16_t* translatedName, uint32_t* nSize)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_129, e1] = Syscall6(rec::Addr(gocpp::recv(procTranslateNameW)), 5, uintptr_t(gocpp::unsafe_pointer(accName)), uintptr_t(accNameFormat), uintptr_t(desiredNameFormat), uintptr_t(gocpp::unsafe_pointer(translatedName)), uintptr_t(gocpp::unsafe_pointer(nSize)), 0);
        if(r1 & 0xff == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<gocpp::array_ptr<gocpp::array<gocpp::array_ptr<gocpp::array<uint16_t, 8192>>, 8192>>, struct gocpp::error> CommandLineToArgv(uint16_t* cmd, int32_t* argc)
    {
        gocpp::array_ptr<gocpp::array<gocpp::array_ptr<gocpp::array<uint16_t, 8192>>, 8192>> argv;
        struct gocpp::error err;
        auto [r0, gocpp_id_130, e1] = Syscall(rec::Addr(gocpp::recv(procCommandLineToArgvW)), 2, uintptr_t(gocpp::unsafe_pointer(cmd)), uintptr_t(gocpp::unsafe_pointer(argc)), 0);
        argv = (gocpp::array_ptr<gocpp::array<gocpp::array_ptr<gocpp::array<uint16_t, 8192>>, 8192>>)(gocpp::unsafe_pointer(r0));
        if(argv == nullptr)
        {
            err = errnoErr(e1);
        }
        return {argv, err};
    }

    struct gocpp::error GetUserProfileDirectory(golang::syscall::Token t, uint16_t* dir, uint32_t* dirLen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_131, e1] = Syscall(rec::Addr(gocpp::recv(procGetUserProfileDirectoryW)), 3, uintptr_t(t), uintptr_t(gocpp::unsafe_pointer(dir)), uintptr_t(gocpp::unsafe_pointer(dirLen)));
        if(r1 == 0)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    void FreeAddrInfoW(struct AddrinfoW* addrinfo)
    {
        Syscall(rec::Addr(gocpp::recv(procFreeAddrInfoW)), 1, uintptr_t(gocpp::unsafe_pointer(addrinfo)), 0, 0);
        return;
    }

    struct gocpp::error GetAddrInfoW(uint16_t* nodename, uint16_t* servicename, struct AddrinfoW* hints, struct AddrinfoW** result)
    {
        struct gocpp::error sockerr;
        auto [r0, gocpp_id_132, gocpp_id_133] = Syscall6(rec::Addr(gocpp::recv(procGetAddrInfoW)), 4, uintptr_t(gocpp::unsafe_pointer(nodename)), uintptr_t(gocpp::unsafe_pointer(servicename)), uintptr_t(gocpp::unsafe_pointer(hints)), uintptr_t(gocpp::unsafe_pointer(result)), 0, 0);
        if(r0 != 0)
        {
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    struct gocpp::error WSACleanup()
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_134, e1] = Syscall(rec::Addr(gocpp::recv(procWSACleanup)), 0, 0, 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<int32_t, struct gocpp::error> WSAEnumProtocols(int32_t* protocols, struct WSAProtocolInfo* protocolBuffer, uint32_t* bufferLength)
    {
        int32_t n;
        struct gocpp::error err;
        auto [r0, gocpp_id_135, e1] = Syscall(rec::Addr(gocpp::recv(procWSAEnumProtocolsW)), 3, uintptr_t(gocpp::unsafe_pointer(protocols)), uintptr_t(gocpp::unsafe_pointer(protocolBuffer)), uintptr_t(gocpp::unsafe_pointer(bufferLength)));
        n = int32_t(r0);
        if(n == - 1)
        {
            err = errnoErr(e1);
        }
        return {n, err};
    }

    struct gocpp::error WSAIoctl(golang::syscall::Handle s, uint32_t iocc, unsigned char* inbuf, uint32_t cbif, unsigned char* outbuf, uint32_t cbob, uint32_t* cbbr, struct Overlapped* overlapped, uintptr_t completionRoutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_136, e1] = Syscall9(rec::Addr(gocpp::recv(procWSAIoctl)), 9, uintptr_t(s), uintptr_t(iocc), uintptr_t(gocpp::unsafe_pointer(inbuf)), uintptr_t(cbif), uintptr_t(gocpp::unsafe_pointer(outbuf)), uintptr_t(cbob), uintptr_t(gocpp::unsafe_pointer(cbbr)), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(completionRoutine));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSARecv(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_137, e1] = Syscall9(rec::Addr(gocpp::recv(procWSARecv)), 7, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(bufs)), uintptr_t(bufcnt), uintptr_t(gocpp::unsafe_pointer(recvd)), uintptr_t(gocpp::unsafe_pointer(flags)), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(gocpp::unsafe_pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSARecvFrom(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* recvd, uint32_t* flags, struct RawSockaddrAny* from, int32_t* fromlen, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_138, e1] = Syscall9(rec::Addr(gocpp::recv(procWSARecvFrom)), 9, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(bufs)), uintptr_t(bufcnt), uintptr_t(gocpp::unsafe_pointer(recvd)), uintptr_t(gocpp::unsafe_pointer(flags)), uintptr_t(gocpp::unsafe_pointer(from)), uintptr_t(gocpp::unsafe_pointer(fromlen)), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(gocpp::unsafe_pointer(croutine)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSASend(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_139, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASend)), 7, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(bufs)), uintptr_t(bufcnt), uintptr_t(gocpp::unsafe_pointer(sent)), uintptr_t(flags), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(gocpp::unsafe_pointer(croutine)), 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSASendTo(golang::syscall::Handle s, struct WSABuf* bufs, uint32_t bufcnt, uint32_t* sent, uint32_t flags, struct RawSockaddrAny* to, int32_t tolen, struct Overlapped* overlapped, unsigned char* croutine)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_140, e1] = Syscall9(rec::Addr(gocpp::recv(procWSASendTo)), 9, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(bufs)), uintptr_t(bufcnt), uintptr_t(gocpp::unsafe_pointer(sent)), uintptr_t(flags), uintptr_t(gocpp::unsafe_pointer(to)), uintptr_t(tolen), uintptr_t(gocpp::unsafe_pointer(overlapped)), uintptr_t(gocpp::unsafe_pointer(croutine)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error WSAStartup(uint32_t verreq, struct WSAData* data)
    {
        struct gocpp::error sockerr;
        auto [r0, gocpp_id_141, gocpp_id_142] = Syscall(rec::Addr(gocpp::recv(procWSAStartup)), 2, uintptr_t(verreq), uintptr_t(gocpp::unsafe_pointer(data)), 0);
        if(r0 != 0)
        {
            sockerr = Errno(r0);
        }
        return sockerr;
    }

    struct gocpp::error bind(golang::syscall::Handle s, gocpp::unsafe_pointer name, int32_t namelen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_143, e1] = Syscall(rec::Addr(gocpp::recv(procbind)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Closesocket(golang::syscall::Handle s)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_144, e1] = Syscall(rec::Addr(gocpp::recv(procclosesocket)), 1, uintptr_t(s), 0, 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error connect(golang::syscall::Handle s, gocpp::unsafe_pointer name, int32_t namelen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_145, e1] = Syscall(rec::Addr(gocpp::recv(procconnect)), 3, uintptr_t(s), uintptr_t(name), uintptr_t(namelen));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct Hostent*, struct gocpp::error> GetHostByName(gocpp::string name)
    {
        struct Hostent* h;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {h, err};
        }
        return _GetHostByName(_p0);
    }

    std::tuple<struct Hostent*, struct gocpp::error> _GetHostByName(unsigned char* name)
    {
        struct Hostent* h;
        struct gocpp::error err;
        auto [r0, gocpp_id_146, e1] = Syscall(rec::Addr(gocpp::recv(procgethostbyname)), 1, uintptr_t(gocpp::unsafe_pointer(name)), 0, 0);
        h = (Hostent*)(gocpp::unsafe_pointer(r0));
        if(h == nullptr)
        {
            err = errnoErr(e1);
        }
        return {h, err};
    }

    struct gocpp::error getpeername(golang::syscall::Handle s, struct RawSockaddrAny* rsa, int32_t* addrlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_147, e1] = Syscall(rec::Addr(gocpp::recv(procgetpeername)), 3, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(rsa)), uintptr_t(gocpp::unsafe_pointer(addrlen)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<struct Protoent*, struct gocpp::error> GetProtoByName(gocpp::string name)
    {
        struct Protoent* p;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {p, err};
        }
        return _GetProtoByName(_p0);
    }

    std::tuple<struct Protoent*, struct gocpp::error> _GetProtoByName(unsigned char* name)
    {
        struct Protoent* p;
        struct gocpp::error err;
        auto [r0, gocpp_id_148, e1] = Syscall(rec::Addr(gocpp::recv(procgetprotobyname)), 1, uintptr_t(gocpp::unsafe_pointer(name)), 0, 0);
        p = (Protoent*)(gocpp::unsafe_pointer(r0));
        if(p == nullptr)
        {
            err = errnoErr(e1);
        }
        return {p, err};
    }

    std::tuple<struct Servent*, struct gocpp::error> GetServByName(gocpp::string name, gocpp::string proto)
    {
        struct Servent* s;
        struct gocpp::error err;
        unsigned char* _p0 = {};
        std::tie(_p0, err) = BytePtrFromString(name);
        if(err != nullptr)
        {
            return {s, err};
        }
        unsigned char* _p1 = {};
        std::tie(_p1, err) = BytePtrFromString(proto);
        if(err != nullptr)
        {
            return {s, err};
        }
        return _GetServByName(_p0, _p1);
    }

    std::tuple<struct Servent*, struct gocpp::error> _GetServByName(unsigned char* name, unsigned char* proto)
    {
        struct Servent* s;
        struct gocpp::error err;
        auto [r0, gocpp_id_149, e1] = Syscall(rec::Addr(gocpp::recv(procgetservbyname)), 2, uintptr_t(gocpp::unsafe_pointer(name)), uintptr_t(gocpp::unsafe_pointer(proto)), 0);
        s = (Servent*)(gocpp::unsafe_pointer(r0));
        if(s == nullptr)
        {
            err = errnoErr(e1);
        }
        return {s, err};
    }

    struct gocpp::error getsockname(golang::syscall::Handle s, struct RawSockaddrAny* rsa, int32_t* addrlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_150, e1] = Syscall(rec::Addr(gocpp::recv(procgetsockname)), 3, uintptr_t(s), uintptr_t(gocpp::unsafe_pointer(rsa)), uintptr_t(gocpp::unsafe_pointer(addrlen)));
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error Getsockopt(golang::syscall::Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t* optlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_151, e1] = Syscall6(rec::Addr(gocpp::recv(procgetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(gocpp::unsafe_pointer(optval)), uintptr_t(gocpp::unsafe_pointer(optlen)), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error listen(golang::syscall::Handle s, int32_t backlog)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_152, e1] = Syscall(rec::Addr(gocpp::recv(proclisten)), 2, uintptr_t(s), uintptr_t(backlog), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    uint16_t Ntohs(uint16_t netshort)
    {
        uint16_t u;
        auto [r0, gocpp_id_153, gocpp_id_154] = Syscall(rec::Addr(gocpp::recv(procntohs)), 1, uintptr_t(netshort), 0, 0);
        u = uint16_t(r0);
        return u;
    }

    struct gocpp::error Setsockopt(golang::syscall::Handle s, int32_t level, int32_t optname, unsigned char* optval, int32_t optlen)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_155, e1] = Syscall6(rec::Addr(gocpp::recv(procsetsockopt)), 5, uintptr_t(s), uintptr_t(level), uintptr_t(optname), uintptr_t(gocpp::unsafe_pointer(optval)), uintptr_t(optlen), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    struct gocpp::error shutdown(golang::syscall::Handle s, int32_t how)
    {
        struct gocpp::error err;
        auto [r1, gocpp_id_156, e1] = Syscall(rec::Addr(gocpp::recv(procshutdown)), 2, uintptr_t(s), uintptr_t(how), 0);
        if(r1 == socket_error)
        {
            err = errnoErr(e1);
        }
        return err;
    }

    std::tuple<syscall::Handle, struct gocpp::error> socket(int32_t af, int32_t typ, int32_t protocol)
    {
        syscall::Handle handle;
        struct gocpp::error err;
        auto [r0, gocpp_id_157, e1] = Syscall(rec::Addr(gocpp::recv(procsocket)), 3, uintptr_t(af), uintptr_t(typ), uintptr_t(protocol));
        handle = Handle(r0);
        if(handle == InvalidHandle)
        {
            err = errnoErr(e1);
        }
        return {handle, err};
    }

}

