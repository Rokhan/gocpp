// generated by GoCpp from file '$(ImportDir)/runtime/debuglog.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/debuglog.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/cputicks.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mem_windows.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // debugLogBytes is the size of each per-M ring buffer. This is
    // allocated off-heap to avoid blowing up the M and hence the GC'd
    // heap size.
    // debugLogStringLimit is the maximum number of bytes in a string.
    // Above this, the string will be truncated with "..(n more bytes).."
    // dlog returns a debug logger. The caller can use methods on the
    // returned logger to add values, which will be space-separated in the
    // final output, much like println. The caller must call end() to
    // finish the message.
    //
    // dlog can be used from highly-constrained corners of the runtime: it
    // is safe to use in the signal handler, from within the write
    // barrier, from within the stack implementation, and in places that
    // must be recursively nosplit.
    //
    // This will be compiled away if built without the debuglog build tag.
    // However, argument construction may not be. If any of the arguments
    // are not literals or trivial expressions, consider protecting the
    // call with "if dlogEnabled".
    //
    //go:nosplit
    //go:nowritebarrierrec
    struct dlogger* dlog()
    {
        if(! dlogEnabled)
        {
            return nullptr;
        }
        auto [tick, nano] = std::tuple{uint64_t(cputicks()), uint64_t(nanotime())};
        auto l = getCachedDlogger();
        if(l == nullptr)
        {
            auto allp = (uintptr_t*)(gocpp::unsafe_pointer(& allDloggers));
            auto all = (dlogger*)(gocpp::unsafe_pointer(atomic::Loaduintptr(allp)));
            for(auto l1 = all; l1 != nullptr; l1 = l1->allLink)
            {
                if(rec::Load(gocpp::recv(l1->owned)) == 0 && rec::CompareAndSwap(gocpp::recv(l1->owned), 0, 1))
                {
                    l = l1;
                    break;
                }
            }
        }
        if(l == nullptr)
        {
            l = (dlogger*)(sysAllocOS(gocpp::Sizeof<dlogger>()));
            if(l == nullptr)
            {
                go_throw("failed to allocate debug log"_s);
            }
            l->w.r.data = & l->w.data;
            rec::Store(gocpp::recv(l->owned), 1);
            auto headp = (uintptr_t*)(gocpp::unsafe_pointer(& allDloggers));
            for(; ; )
            {
                auto head = atomic::Loaduintptr(headp);
                l->allLink = (dlogger*)(gocpp::unsafe_pointer(head));
                if(atomic::Casuintptr(headp, head, uintptr_t(gocpp::unsafe_pointer(l))))
                {
                    break;
                }
            }
        }
        // If the time delta is getting too high, write a new sync
        // packet. We set the limit so we don't write more than 6
        // bytes of delta in the record header.
        auto deltaLimit = (1 << (3 * 7)) - 1;
        if(tick - l->w.tick > deltaLimit || nano - l->w.nano > deltaLimit)
        {
            rec::writeSync(gocpp::recv(l->w), tick, nano);
        }
        rec::ensure(gocpp::recv(l->w), debugLogHeaderSize);
        l->w.write += debugLogHeaderSize;
        rec::uvarint(gocpp::recv(l->w), tick - l->w.tick);
        rec::uvarint(gocpp::recv(l->w), nano - l->w.nano);
        auto gp = getg();
        if(gp != nullptr && gp->m != nullptr && gp->m->p != 0)
        {
            rec::varint(gocpp::recv(l->w), int64_t(rec::ptr(gocpp::recv(gp->m->p))->id));
        }
        else
        {
            rec::varint(gocpp::recv(l->w), - 1);
        }
        return l;
    }

    // A dlogger writes to the debug log.
    //
    // To obtain a dlogger, call dlog(). When done with the dlogger, call
    // end().
    
    template<typename T> requires gocpp::GoStruct<T>
    dlogger::operator T()
    {
        T result;
        result._1 = this->_1;
        result.w = this->w;
        result.allLink = this->allLink;
        result.owned = this->owned;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dlogger::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (w != ref.w) return false;
        if (allLink != ref.allLink) return false;
        if (owned != ref.owned) return false;
        return true;
    }

    std::ostream& dlogger::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << w;
        os << " " << allLink;
        os << " " << owned;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dlogger& value)
    {
        return value.PrintTo(os);
    }

    // allDloggers is a list of all dloggers, linked through
    // dlogger.allLink. This is accessed atomically. This is prepend only,
    // so it doesn't need to protect against ABA races.
    dlogger* allDloggers;
    //go:nosplit
    void rec::end(golang::runtime::dlogger* l)
    {
        if(! dlogEnabled)
        {
            return;
        }
        auto size = l->w.write - l->w.r.end;
        if(! rec::writeFrameAt(gocpp::recv(l->w), l->w.r.end, size))
        {
            go_throw("record too large"_s);
        }
        l->w.r.end = l->w.write;
        if(putCachedDlogger(l))
        {
            return;
        }
        rec::Store(gocpp::recv(l->owned), 0);
    }

    //go:nosplit
    struct dlogger* rec::b(golang::runtime::dlogger* l, bool x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        if(x)
        {
            rec::byte(gocpp::recv(l->w), debugLogBoolTrue);
        }
        else
        {
            rec::byte(gocpp::recv(l->w), debugLogBoolFalse);
        }
        return l;
    }

    //go:nosplit
    struct dlogger* rec::i(golang::runtime::dlogger* l, int x)
    {
        return rec::i64(gocpp::recv(l), int64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::i8(golang::runtime::dlogger* l, int8_t x)
    {
        return rec::i64(gocpp::recv(l), int64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::i16(golang::runtime::dlogger* l, int16_t x)
    {
        return rec::i64(gocpp::recv(l), int64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::i32(golang::runtime::dlogger* l, int32_t x)
    {
        return rec::i64(gocpp::recv(l), int64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::i64(golang::runtime::dlogger* l, int64_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        rec::byte(gocpp::recv(l->w), debugLogInt);
        rec::varint(gocpp::recv(l->w), x);
        return l;
    }

    //go:nosplit
    struct dlogger* rec::u(golang::runtime::dlogger* l, unsigned int x)
    {
        return rec::u64(gocpp::recv(l), uint64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::uptr(golang::runtime::dlogger* l, uintptr_t x)
    {
        return rec::u64(gocpp::recv(l), uint64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::u8(golang::runtime::dlogger* l, uint8_t x)
    {
        return rec::u64(gocpp::recv(l), uint64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::u16(golang::runtime::dlogger* l, uint16_t x)
    {
        return rec::u64(gocpp::recv(l), uint64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::u32(golang::runtime::dlogger* l, uint32_t x)
    {
        return rec::u64(gocpp::recv(l), uint64_t(x));
    }

    //go:nosplit
    struct dlogger* rec::u64(golang::runtime::dlogger* l, uint64_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        rec::byte(gocpp::recv(l->w), debugLogUint);
        rec::uvarint(gocpp::recv(l->w), x);
        return l;
    }

    //go:nosplit
    struct dlogger* rec::hex(golang::runtime::dlogger* l, uint64_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        rec::byte(gocpp::recv(l->w), debugLogHex);
        rec::uvarint(gocpp::recv(l->w), x);
        return l;
    }

    //go:nosplit
    struct dlogger* rec::p(golang::runtime::dlogger* l, go_any x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        rec::byte(gocpp::recv(l->w), debugLogPtr);
        if(x == nullptr)
        {
            rec::uvarint(gocpp::recv(l->w), 0);
        }
        else
        {
            auto v = efaceOf(& x);
            //Go switch emulation
            {
                auto condition = v->_type->Kind_ & kindMask;
                int conditionId = -1;
                if(condition == kindChan) { conditionId = 0; }
                else if(condition == kindFunc) { conditionId = 1; }
                else if(condition == kindMap) { conditionId = 2; }
                else if(condition == kindPtr) { conditionId = 3; }
                else if(condition == kindUnsafePointer) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        rec::uvarint(gocpp::recv(l->w), uint64_t(uintptr_t(v->data)));
                        break;
                    default:
                        go_throw("not a pointer type"_s);
                        break;
                }
            }
        }
        return l;
    }

    //go:nosplit
    struct dlogger* rec::s(golang::runtime::dlogger* l, gocpp::string x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        auto strData = unsafe::StringData(x);
        auto datap = & firstmoduledata;
        if(len(x) > 4 && datap->etext <= uintptr_t(gocpp::unsafe_pointer(strData)) && uintptr_t(gocpp::unsafe_pointer(strData)) < datap->end)
        {
            rec::byte(gocpp::recv(l->w), debugLogConstString);
            rec::uvarint(gocpp::recv(l->w), uint64_t(len(x)));
            rec::uvarint(gocpp::recv(l->w), uint64_t(uintptr_t(gocpp::unsafe_pointer(strData)) - datap->etext));
        }
        else
        {
            rec::byte(gocpp::recv(l->w), debugLogString);
            // We can't use unsafe.Slice as it may panic, which isn't safe
            // in this (potentially) nowritebarrier context.
            gocpp::slice<unsigned char> b = {};
            auto bb = (slice*)(gocpp::unsafe_pointer(& b));
            bb->array = gocpp::unsafe_pointer(strData);
            std::tie(bb->len, bb->cap) = std::tuple{len(x), len(x)};
            if(len(b) > debugLogStringLimit)
            {
                b = b.make_slice(0, debugLogStringLimit);
            }
            rec::uvarint(gocpp::recv(l->w), uint64_t(len(b)));
            rec::bytes(gocpp::recv(l->w), b);
            if(len(b) != len(x))
            {
                rec::byte(gocpp::recv(l->w), debugLogStringOverflow);
                rec::uvarint(gocpp::recv(l->w), uint64_t(len(x) - len(b)));
            }
        }
        return l;
    }

    //go:nosplit
    struct dlogger* rec::pc(golang::runtime::dlogger* l, uintptr_t x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        rec::byte(gocpp::recv(l->w), debugLogPC);
        rec::uvarint(gocpp::recv(l->w), uint64_t(x));
        return l;
    }

    //go:nosplit
    struct dlogger* rec::traceback(golang::runtime::dlogger* l, gocpp::slice<uintptr_t> x)
    {
        if(! dlogEnabled)
        {
            return l;
        }
        rec::byte(gocpp::recv(l->w), debugLogTraceback);
        rec::uvarint(gocpp::recv(l->w), uint64_t(len(x)));
        for(auto [gocpp_ignored, pc] : x)
        {
            rec::uvarint(gocpp::recv(l->w), uint64_t(pc));
        }
        return l;
    }

    // A debugLogWriter is a ring buffer of binary debug log records.
    //
    // A log record consists of a 2-byte framing header and a sequence of
    // fields. The framing header gives the size of the record as a little
    // endian 16-bit value. Each field starts with a byte indicating its
    // type, followed by type-specific data. If the size in the framing
    // header is 0, it's a sync record consisting of two little endian
    // 64-bit values giving a new time base.
    //
    // Because this is a ring buffer, new records will eventually
    // overwrite old records. Hence, it maintains a reader that consumes
    // the log as it gets overwritten. That reader state is where an
    // actual log reader would start.
    
    template<typename T> requires gocpp::GoStruct<T>
    debugLogWriter::operator T()
    {
        T result;
        result._1 = this->_1;
        result.write = this->write;
        result.data = this->data;
        result.tick = this->tick;
        result.nano = this->nano;
        result.r = this->r;
        result.buf = this->buf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool debugLogWriter::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (write != ref.write) return false;
        if (data != ref.data) return false;
        if (tick != ref.tick) return false;
        if (nano != ref.nano) return false;
        if (r != ref.r) return false;
        if (buf != ref.buf) return false;
        return true;
    }

    std::ostream& debugLogWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << write;
        os << " " << data;
        os << " " << tick;
        os << " " << nano;
        os << " " << r;
        os << " " << buf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct debugLogWriter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    debugLogBuf::operator T()
    {
        T result;
        result._1 = this->_1;
        result.b = this->b;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool debugLogBuf::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (b != ref.b) return false;
        return true;
    }

    std::ostream& debugLogBuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << b;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct debugLogBuf& value)
    {
        return value.PrintTo(os);
    }

    // debugLogHeaderSize is the number of bytes in the framing
    // header of every dlog record.
    // debugLogSyncSize is the number of bytes in a sync record.
    //go:nosplit
    void rec::ensure(golang::runtime::debugLogWriter* l, uint64_t n)
    {
        for(; l->write + n >= l->r.begin + uint64_t(len(l->data.b)); )
        {
            if(rec::skip(gocpp::recv(l->r)) == ~ uint64_t(0))
            {
                go_throw("record wrapped around"_s);
            }
        }
    }

    //go:nosplit
    bool rec::writeFrameAt(golang::runtime::debugLogWriter* l, uint64_t pos, uint64_t size)
    {
        l->data.b[pos % uint64_t(len(l->data.b))] = uint8_t(size);
        l->data.b[(pos + 1) % uint64_t(len(l->data.b))] = uint8_t(size >> 8);
        return size <= 0xFFFF;
    }

    //go:nosplit
    void rec::writeSync(golang::runtime::debugLogWriter* l, uint64_t tick, uint64_t nano)
    {
        std::tie(l->tick, l->nano) = std::tuple{tick, nano};
        rec::ensure(gocpp::recv(l), debugLogHeaderSize);
        rec::writeFrameAt(gocpp::recv(l), l->write, 0);
        l->write += debugLogHeaderSize;
        rec::writeUint64LE(gocpp::recv(l), tick);
        rec::writeUint64LE(gocpp::recv(l), nano);
        l->r.end = l->write;
    }

    //go:nosplit
    void rec::writeUint64LE(golang::runtime::debugLogWriter* l, uint64_t x)
    {
        gocpp::array<unsigned char, 8> b = {};
        b[0] = (unsigned char)(x);
        b[1] = (unsigned char)(x >> 8);
        b[2] = (unsigned char)(x >> 16);
        b[3] = (unsigned char)(x >> 24);
        b[4] = (unsigned char)(x >> 32);
        b[5] = (unsigned char)(x >> 40);
        b[6] = (unsigned char)(x >> 48);
        b[7] = (unsigned char)(x >> 56);
        rec::bytes(gocpp::recv(l), b.make_slice(0));
    }

    //go:nosplit
    void rec::byte(golang::runtime::debugLogWriter* l, unsigned char x)
    {
        rec::ensure(gocpp::recv(l), 1);
        auto pos = l->write;
        l->write++;
        l->data.b[pos % uint64_t(len(l->data.b))] = x;
    }

    //go:nosplit
    void rec::bytes(golang::runtime::debugLogWriter* l, gocpp::slice<unsigned char> x)
    {
        rec::ensure(gocpp::recv(l), uint64_t(len(x)));
        auto pos = l->write;
        l->write += uint64_t(len(x));
        for(; len(x) > 0; )
        {
            auto n = copy(l->data.b.make_slice(pos % uint64_t(len(l->data.b))), x);
            pos += uint64_t(n);
            x = x.make_slice(n);
        }
    }

    //go:nosplit
    void rec::varint(golang::runtime::debugLogWriter* l, int64_t x)
    {
        uint64_t u = {};
        if(x < 0)
        {
            u = (~ uint64_t(x) << 1) | 1;
        }
        else
        {
            u = (uint64_t(x) << 1);
        }
        rec::uvarint(gocpp::recv(l), u);
    }

    //go:nosplit
    void rec::uvarint(golang::runtime::debugLogWriter* l, uint64_t u)
    {
        auto i = 0;
        for(; u >= 0x80; )
        {
            l->buf[i] = (unsigned char)(u) | 0x80;
            u >>= 7;
            i++;
        }
        l->buf[i] = (unsigned char)(u);
        i++;
        rec::bytes(gocpp::recv(l), l->buf.make_slice(0, i));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    debugLogReader::operator T()
    {
        T result;
        result.data = this->data;
        result.begin = this->begin;
        result.end = this->end;
        result.tick = this->tick;
        result.nano = this->nano;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool debugLogReader::operator==(const T& ref) const
    {
        if (data != ref.data) return false;
        if (begin != ref.begin) return false;
        if (end != ref.end) return false;
        if (tick != ref.tick) return false;
        if (nano != ref.nano) return false;
        return true;
    }

    std::ostream& debugLogReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << data;
        os << " " << begin;
        os << " " << end;
        os << " " << tick;
        os << " " << nano;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct debugLogReader& value)
    {
        return value.PrintTo(os);
    }

    //go:nosplit
    uint64_t rec::skip(golang::runtime::debugLogReader* r)
    {
        if(r->begin + debugLogHeaderSize > r->end)
        {
            return ~ uint64_t(0);
        }
        auto size = uint64_t(rec::readUint16LEAt(gocpp::recv(r), r->begin));
        if(size == 0)
        {
            r->tick = rec::readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize);
            r->nano = rec::readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize + 8);
            size = debugLogSyncSize;
        }
        if(r->begin + size > r->end)
        {
            return ~ uint64_t(0);
        }
        r->begin += size;
        return size;
    }

    //go:nosplit
    uint16_t rec::readUint16LEAt(golang::runtime::debugLogReader* r, uint64_t pos)
    {
        return uint16_t(r->data->b[pos % uint64_t(len(r->data->b))]) | (uint16_t(r->data->b[(pos + 1) % uint64_t(len(r->data->b))]) << 8);
    }

    //go:nosplit
    uint64_t rec::readUint64LEAt(golang::runtime::debugLogReader* r, uint64_t pos)
    {
        gocpp::array<unsigned char, 8> b = {};
        for(auto [i, gocpp_ignored] : b)
        {
            b[i] = r->data->b[pos % uint64_t(len(r->data->b))];
            pos++;
        }
        return uint64_t(b[0]) | (uint64_t(b[1]) << 8) | (uint64_t(b[2]) << 16) | (uint64_t(b[3]) << 24) | (uint64_t(b[4]) << 32) | (uint64_t(b[5]) << 40) | (uint64_t(b[6]) << 48) | (uint64_t(b[7]) << 56);
    }

    uint64_t rec::peek(golang::runtime::debugLogReader* r)
    {
        uint64_t tick;
        auto size = uint64_t(0);
        for(; size == 0; )
        {
            if(r->begin + debugLogHeaderSize > r->end)
            {
                return ~ uint64_t(0);
            }
            size = uint64_t(rec::readUint16LEAt(gocpp::recv(r), r->begin));
            if(size != 0)
            {
                break;
            }
            if(r->begin + debugLogSyncSize > r->end)
            {
                return ~ uint64_t(0);
            }
            r->tick = rec::readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize);
            r->nano = rec::readUint64LEAt(gocpp::recv(r), r->begin + debugLogHeaderSize + 8);
            r->begin += debugLogSyncSize;
        }
        if(r->begin + size > r->end)
        {
            return ~ uint64_t(0);
        }
        auto pos = r->begin + debugLogHeaderSize;
        uint64_t u = {};
        for(auto i = (unsigned int)(0); ; i += 7)
        {
            auto b = r->data->b[pos % uint64_t(len(r->data->b))];
            pos++;
            u |= uint64_t(b &^ 0x80) << i;
            if(b & 0x80 == 0)
            {
                break;
            }
        }
        if(pos > r->begin + size)
        {
            return ~ uint64_t(0);
        }
        return r->tick + u;
    }

    std::tuple<uint64_t, uint64_t, uint64_t, int> rec::header(golang::runtime::debugLogReader* r)
    {
        uint64_t end;
        uint64_t tick;
        uint64_t nano;
        int p;
        auto size = uint64_t(rec::readUint16LEAt(gocpp::recv(r), r->begin));
        end = r->begin + size;
        r->begin += debugLogHeaderSize;
        tick = rec::uvarint(gocpp::recv(r)) + r->tick;
        nano = rec::uvarint(gocpp::recv(r)) + r->nano;
        p = int(rec::varint(gocpp::recv(r)));
        return {end, tick, nano, p};
    }

    uint64_t rec::uvarint(golang::runtime::debugLogReader* r)
    {
        uint64_t u = {};
        for(auto i = (unsigned int)(0); ; i += 7)
        {
            auto b = r->data->b[r->begin % uint64_t(len(r->data->b))];
            r->begin++;
            u |= uint64_t(b &^ 0x80) << i;
            if(b & 0x80 == 0)
            {
                break;
            }
        }
        return u;
    }

    int64_t rec::varint(golang::runtime::debugLogReader* r)
    {
        auto u = rec::uvarint(gocpp::recv(r));
        int64_t v = {};
        if(u & 1 == 0)
        {
            v = int64_t(u >> 1);
        }
        else
        {
            v = ~ int64_t(u >> 1);
        }
        return v;
    }

    bool rec::printVal(golang::runtime::debugLogReader* r)
    {
        auto typ = r->data->b[r->begin % uint64_t(len(r->data->b))];
        r->begin++;
        //Go switch emulation
        {
            auto condition = typ;
            int conditionId = -1;
            if(condition == debugLogUnknown) { conditionId = 0; }
            else if(condition == debugLogBoolTrue) { conditionId = 1; }
            else if(condition == debugLogBoolFalse) { conditionId = 2; }
            else if(condition == debugLogInt) { conditionId = 3; }
            else if(condition == debugLogUint) { conditionId = 4; }
            else if(condition == debugLogHex) { conditionId = 5; }
            else if(condition == debugLogPtr) { conditionId = 6; }
            else if(condition == debugLogString) { conditionId = 7; }
            else if(condition == debugLogConstString) { conditionId = 8; }
            else if(condition == debugLogStringOverflow) { conditionId = 9; }
            else if(condition == debugLogPC) { conditionId = 10; }
            else if(condition == debugLogTraceback) { conditionId = 11; }
            switch(conditionId)
            {
                default:
                    print("<unknown field type "_s, hex(typ), " pos "_s, r->begin - 1, " end "_s, r->end, ">\n"_s);
                    return false;
                    break;
                case 0:
                    print("<unknown kind>"_s);
                    break;
                case 1:
                    print(true);
                    break;
                case 2:
                    print(false);
                    break;
                case 3:
                    print(rec::varint(gocpp::recv(r)));
                    break;
                case 4:
                    print(rec::uvarint(gocpp::recv(r)));
                    break;
                case 5:
                case 6:
                    print(hex(rec::uvarint(gocpp::recv(r))));
                    break;
                case 7:
                    auto sl = rec::uvarint(gocpp::recv(r));
                    if(r->begin + sl > r->end)
                    {
                        r->begin = r->end;
                        print("<string length corrupted>"_s);
                        break;
                    }
                    for(; sl > 0; )
                    {
                        auto b = r->data->b.make_slice(r->begin % uint64_t(len(r->data->b)));
                        if(uint64_t(len(b)) > sl)
                        {
                            b = b.make_slice(0, sl);
                        }
                        r->begin += uint64_t(len(b));
                        sl -= uint64_t(len(b));
                        gwrite(b);
                    }
                    break;
                case 8:
                    auto [len, ptr] = std::tuple{int(rec::uvarint(gocpp::recv(r))), uintptr_t(rec::uvarint(gocpp::recv(r)))};
                    ptr += firstmoduledata.etext;
                    auto str_tmp = gocpp::Init<stringStruct>([=](auto& x) {
                        x.str = gocpp::unsafe_pointer(ptr);
                        x.len = len;
                    });
                    auto& str = str_tmp;
                    auto s = *(gocpp::string*)(gocpp::unsafe_pointer(& str));
                    print(s);
                    break;
                case 9:
                    print("..("_s, rec::uvarint(gocpp::recv(r)), " more bytes).."_s);
                    break;
                case 10:
                    printDebugLogPC(uintptr_t(rec::uvarint(gocpp::recv(r))), false);
                    break;
                case 11:
                    auto n = int(rec::uvarint(gocpp::recv(r)));
                    for(auto i = 0; i < n; i++)
                    {
                        print("\n\t"_s);
                        printDebugLogPC(uintptr_t(rec::uvarint(gocpp::recv(r))), true);
                    }
                    break;
            }
        }
        return true;
    }

    struct gocpp_id_0
            {
                uint64_t tick;
                int i;

                using isGoStruct = void;

                template<typename T> requires gocpp::GoStruct<T>
                operator T()
                {
                    T result;
                    result.tick = this->tick;
                    result.i = this->i;
                    return result;
                }

                template<typename T> requires gocpp::GoStruct<T>
                bool operator==(const T& ref) const
                {
                    if (tick != ref.tick) return false;
                    if (i != ref.i) return false;
                    return true;
                }

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << "" << tick;
                    os << " " << i;
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
            {
                return value.PrintTo(os);
            }


    // printDebugLog prints the debug log.
    void printDebugLog()
    {
        if(! dlogEnabled)
        {
            return;
        }
        printlock();
        auto allp = (uintptr_t*)(gocpp::unsafe_pointer(& allDloggers));
        auto all = (dlogger*)(gocpp::unsafe_pointer(atomic::Loaduintptr(allp)));
        auto n = 0;
        for(auto l = all; l != nullptr; l = l->allLink)
        {
            n++;
        }
        if(n == 0)
        {
            printunlock();
            return;
        }
        // Prepare read state for all logs.
        struct readState
        {
            debugLogReader debugLogReader;
            bool first;
            uint64_t lost;
            uint64_t nextTick;

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << debugLogReader;
                os << " " << first;
                os << " " << lost;
                os << " " << nextTick;
                os << '}';
                return os;
            }
        };
        auto state1 = sysAllocOS(gocpp::Sizeof<readState>() * uintptr_t(n));
        if(state1 == nullptr)
        {
            println("failed to allocate read state for"_s, n, "logs"_s);
            printunlock();
            return;
        }
        auto state = (gocpp::array_ptr<gocpp::array<readState, 1 << 20>>)(state1).make_slice(0, n);
        {
            auto l = all;
            for(auto [i, gocpp_ignored] : state)
            {
                auto s = & state[i];
                s->debugLogReader = l->w.r;
                s->first = true;
                s->lost = l->w.r.begin;
                s->nextTick = rec::peek(gocpp::recv(s));
                l = l->allLink;
            }
        }
        for(; ; )
        {
            // Find the next record.
            gocpp_id_0 best = {};
            best.tick = ~ uint64_t(0);
            for(auto [i, gocpp_ignored] : state)
            {
                if(state[i].nextTick < best.tick)
                {
                    best.tick = state[i].nextTick;
                    best.i = i;
                }
            }
            if(best.tick == ~ uint64_t(0))
            {
                break;
            }
            auto s = & state[best.i];
            if(s->first)
            {
                print(">> begin log "_s, best.i);
                if(s->lost != 0)
                {
                    print("; lost first "_s, s->lost >> 10, "KB"_s);
                }
                print(" <<\n"_s);
                s->first = false;
            }
            auto [end, gocpp_id_1, nano, p] = rec::header(gocpp::recv(s));
            auto oldEnd = s->end;
            s->end = end;
            print("["_s);
            gocpp::array<unsigned char, 21> tmpbuf = {};
            auto pnano = int64_t(nano) - runtimeInitTime;
            if(pnano < 0)
            {
                pnano = 0;
            }
            auto pnanoBytes = itoaDiv(tmpbuf.make_slice(0), uint64_t(pnano), 9);
            print(slicebytetostringtmp((unsigned char*)(noescape(gocpp::unsafe_pointer(& pnanoBytes[0]))), len(pnanoBytes)));
            print(" P "_s, p, "] "_s);
            for(auto i = 0; s->begin < s->end; i++)
            {
                if(i > 0)
                {
                    print(" "_s);
                }
                if(! rec::printVal(gocpp::recv(s)))
                {
                    print("<aborting P log>"_s);
                    end = oldEnd;
                    break;
                }
            }
            println();
            s->begin = end;
            s->end = oldEnd;
            s->nextTick = rec::peek(gocpp::recv(s));
        }
        printunlock();
    }

    // printDebugLogPC prints a single symbolized PC. If returnPC is true,
    // pc is a return PC that must first be converted to a call PC.
    void printDebugLogPC(uintptr_t pc, bool returnPC)
    {
        auto fn = findfunc(pc);
        if(returnPC && (! rec::valid(gocpp::recv(fn)) || pc > rec::entry(gocpp::recv(fn))))
        {
            pc--;
        }
        print(hex(pc));
        if(! rec::valid(gocpp::recv(fn)))
        {
            print(" [unknown PC]"_s);
        }
        else
        {
            auto name = funcname(fn);
            auto [file, line] = funcline(fn, pc);
            print(" ["_s, name, "+"_s, hex(pc - rec::entry(gocpp::recv(fn))), " "_s, file, ":"_s, line, "]"_s);
        }
    }

}

