// generated by GoCpp from file '$(ImportDir)/runtime/defs_windows.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/defs_windows.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/defs_windows_amd64.h"

namespace golang::runtime
{
    extern int _PROT_NONE;
    extern int _PROT_READ;
    extern int _PROT_WRITE;
    extern int _PROT_EXEC;
    extern int _MAP_ANON;
    extern int _MAP_PRIVATE;
    extern int _DUPLICATE_SAME_ACCESS;
    extern int _THREAD_PRIORITY_HIGHEST;
    extern int _SIGINT;
    extern int _SIGTERM;
    extern int _CTRL_C_EVENT;
    extern int _CTRL_BREAK_EVENT;
    extern int _CTRL_CLOSE_EVENT;
    extern int _CTRL_LOGOFF_EVENT;
    extern int _CTRL_SHUTDOWN_EVENT;
    extern int _EXCEPTION_ACCESS_VIOLATION;
    extern int _EXCEPTION_IN_PAGE_ERROR;
    extern int _EXCEPTION_BREAKPOINT;
    extern int _EXCEPTION_ILLEGAL_INSTRUCTION;
    extern int _EXCEPTION_FLT_DENORMAL_OPERAND;
    extern int _EXCEPTION_FLT_DIVIDE_BY_ZERO;
    extern int _EXCEPTION_FLT_INEXACT_RESULT;
    extern int _EXCEPTION_FLT_OVERFLOW;
    extern int _EXCEPTION_FLT_UNDERFLOW;
    extern int _EXCEPTION_INT_DIVIDE_BY_ZERO;
    extern int _EXCEPTION_INT_OVERFLOW;
    extern int _INFINITE;
    extern int _WAIT_TIMEOUT;
    extern int _EXCEPTION_CONTINUE_EXECUTION;
    extern int _EXCEPTION_CONTINUE_SEARCH;
    extern int _EXCEPTION_CONTINUE_SEARCH_SEH;
    struct systeminfo
    {
        gocpp::array<unsigned char, 4> anon0;
        uint32_t dwpagesize;
        unsigned char* lpminimumapplicationaddress;
        unsigned char* lpmaximumapplicationaddress;
        uintptr_t dwactiveprocessormask;
        uint32_t dwnumberofprocessors;
        uint32_t dwprocessortype;
        uint32_t dwallocationgranularity;
        uint16_t wprocessorlevel;
        uint16_t wprocessorrevision;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct systeminfo& value);
    struct exceptionpointers
    {
        exceptionrecord* record;
        context* context;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct exceptionpointers& value);
    struct exceptionrecord
    {
        uint32_t exceptioncode;
        uint32_t exceptionflags;
        exceptionrecord* exceptionrecord;
        uintptr_t exceptionaddress;
        uint32_t numberparameters;
        gocpp::array<uintptr_t, 15> exceptioninformation;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct exceptionrecord& value);
    struct overlapped
    {
        uintptr_t internal;
        uintptr_t internalhigh;
        gocpp::array<unsigned char, 8> anon0;
        unsigned char* hevent;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct overlapped& value);
    struct memoryBasicInformation
    {
        uintptr_t baseAddress;
        uintptr_t allocationBase;
        uint32_t allocationProtect;
        uintptr_t regionSize;
        uint32_t state;
        uint32_t protect;
        uint32_t type_;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct memoryBasicInformation& value);
}

