// generated by GoCpp from file '$(ImportDir)/reflect/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/value.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/map.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/itoa/itoa.h"
#include "golang/internal/unsafeheader/unsafeheader.h"
#include "golang/math/const.h"
#include "golang/reflect/abi.h"
#include "golang/reflect/makefunc.h"
#include "golang/reflect/type.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/symtab.h"
#include "golang/sync/cond.h"
#include "golang/sync/pool.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflect
{
    namespace rec
    {
        using namespace mocklib::rec;
        using abi::rec::Common;
        using abi::rec::Dump;
        using abi::rec::Elem;
        using abi::rec::Embedded;
        using abi::rec::Equal;
        using abi::rec::ExportedMethods;
        using abi::rec::IfaceIndir;
        using abi::rec::In;
        using abi::rec::InSlice;
        using abi::rec::IsExported;
        using abi::rec::IsVariadic;
        using abi::rec::Kind;
        using abi::rec::Len;
        using abi::rec::NumIn;
        using abi::rec::NumMethod;
        using abi::rec::NumOut;
        using abi::rec::Out;
        using abi::rec::OutSlice;
        using abi::rec::Pointers;
        using abi::rec::Size;
        using runtime::rec::Name;
        using runtime::rec::Next;
        using sync::rec::Get;
        using sync::rec::Put;
    }

    // Value is the reflection interface to a Go value.
    //
    // Not all methods apply to all kinds of values. Restrictions,
    // if any, are noted in the documentation for each method.
    // Use the Kind method to find out the kind of value before
    // calling kind-specific methods. Calling a method
    // inappropriate to the kind of type causes a run time panic.
    //
    // The zero Value represents no value.
    // Its IsValid method returns false, its Kind method returns Invalid,
    // its String method returns "<invalid Value>", and all other methods panic.
    // Most functions and methods never return an invalid value.
    // If one does, its documentation states the conditions explicitly.
    //
    // A Value can be used concurrently by multiple goroutines provided that
    // the underlying Go value can be used concurrently for the equivalent
    // direct operations.
    //
    // To compare two Values, compare the results of the Interface method.
    // Using == on two Values does not compare the underlying values
    // they represent.
    
    template<typename T> requires gocpp::GoStruct<T>
    Value::operator T()
    {
        T result;
        result.typ_ = this->typ_;
        result.ptr = this->ptr;
        result.flag = this->flag;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Value::operator==(const T& ref) const
    {
        if (typ_ != ref.typ_) return false;
        if (ptr != ref.ptr) return false;
        if (flag != ref.flag) return false;
        return true;
    }

    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ_;
        os << " " << ptr;
        os << " " << flag;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Value& value)
    {
        return value.PrintTo(os);
    }

    reflect::Kind rec::kind(golang::reflect::flag f)
    {
        return Kind(f & flagKindMask);
    }

    reflect::flag rec::ro(golang::reflect::flag f)
    {
        if(f & flagRO != 0)
        {
            return flagStickyRO;
        }
        return 0;
    }

    abi::Type* rec::typ(struct Value v)
    {
        return (abi::Type*)(noescape(unsafe::Pointer(v.typ_)));
    }

    // pointer returns the underlying pointer represented by v.
    // v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer
    // if v.Kind() == Pointer, the base type must not be not-in-heap.
    unsafe::Pointer rec::pointer(struct Value v)
    {
        if(rec::Size(gocpp::recv(rec::typ(gocpp::recv(v)))) != goarch::PtrSize || ! rec::Pointers(gocpp::recv(rec::typ(gocpp::recv(v)))))
        {
            gocpp::panic("can't call pointer on a non-pointer Value"s);
        }
        if(v.flag & flagIndir != 0)
        {
            return *(unsafe::Pointer*)(v.ptr);
        }
        return v.ptr;
    }

    // packEface converts v to the empty interface.
    go_any packEface(struct Value v)
    {
        auto t = rec::typ(gocpp::recv(v));
        go_any i = {};
        auto e = (emptyInterface*)(unsafe::Pointer(& i));
        //Go switch emulation
        {
            int conditionId = -1;
            if(rec::IfaceIndir(gocpp::recv(t))) { conditionId = 0; }
            else if(v.flag & flagIndir != 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(v.flag & flagIndir == 0)
                    {
                        gocpp::panic("bad indir"s);
                    }
                    auto ptr = v.ptr;
                    if(v.flag & flagAddr != 0)
                    {
                        auto c = unsafe_New(t);
                        typedmemmove(t, c, ptr);
                        ptr = c;
                    }
                    e->word = ptr;
                    break;
                case 1:
                    e->word = *(unsafe::Pointer*)(v.ptr);
                    break;
                default:
                    e->word = v.ptr;
                    break;
            }
        }
        e->typ = t;
        return i;
    }

    // unpackEface converts the empty interface i to a Value.
    struct Value unpackEface(go_any i)
    {
        auto e = (emptyInterface*)(unsafe::Pointer(& i));
        auto t = e->typ;
        if(t == nullptr)
        {
            return Value {};
        }
        auto f = flag(rec::Kind(gocpp::recv(t)));
        if(rec::IfaceIndir(gocpp::recv(t)))
        {
            f |= flagIndir;
        }
        return Value {t, e->word, f};
    }

    // A ValueError occurs when a Value method is invoked on
    // a [Value] that does not support it. Such cases are documented
    // in the description of each method.
    
    template<typename T> requires gocpp::GoStruct<T>
    ValueError::operator T()
    {
        T result;
        result.Method = this->Method;
        result.Kind = this->Kind;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ValueError::operator==(const T& ref) const
    {
        if (Method != ref.Method) return false;
        if (Kind != ref.Kind) return false;
        return true;
    }

    std::ostream& ValueError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Method;
        os << " " << Kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct ValueError* e)
    {
        if(e->Kind == 0)
        {
            return "reflect: call of "s + e->Method + " on zero Value"s;
        }
        return "reflect: call of "s + e->Method + " on "s + rec::String(gocpp::recv(e->Kind)) + " Value"s;
    }

    // valueMethodName returns the name of the exported calling method on Value.
    std::string valueMethodName()
    {
        gocpp::array<uintptr_t, 5> pc = {};
        auto n = runtime::Callers(1, pc.make_slice(0));
        auto frames = runtime::CallersFrames(pc.make_slice(0, n));
        runtime::Frame frame = {};
        for(auto more = true; more; )
        {
            auto prefix = "reflect.Value."s;
            std::tie(frame, more) = rec::Next(gocpp::recv(frames));
            auto name = frame.Function;
            if(len(name) > len(prefix) && name.make_slice(0, len(prefix)) == prefix)
            {
                auto methodName = name.make_slice(len(prefix));
                if(len(methodName) > 0 && 'A' <= methodName[0] && methodName[0] <= 'Z')
                {
                    return name;
                }
            }
        }
        return "unknown method"s;
    }

    // emptyInterface is the header for an interface{} value.
    
    template<typename T> requires gocpp::GoStruct<T>
    emptyInterface::operator T()
    {
        T result;
        result.typ = this->typ;
        result.word = this->word;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool emptyInterface::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (word != ref.word) return false;
        return true;
    }

    std::ostream& emptyInterface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << word;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_0::operator T()
    {
        T result;
        result.ityp = this->ityp;
        result.typ = this->typ;
        result.hash = this->hash;
        result._1 = this->_1;
        result.fun = this->fun;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_0::operator==(const T& ref) const
    {
        if (ityp != ref.ityp) return false;
        if (typ != ref.typ) return false;
        if (hash != ref.hash) return false;
        if (_1 != ref._1) return false;
        if (fun != ref.fun) return false;
        return true;
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ityp;
        os << " " << typ;
        os << " " << hash;
        os << " " << _1;
        os << " " << fun;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // nonEmptyInterface is the header for an interface value with methods.
    
    template<typename T> requires gocpp::GoStruct<T>
    nonEmptyInterface::operator T()
    {
        T result;
        result.itab = this->itab;
        result.word = this->word;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool nonEmptyInterface::operator==(const T& ref) const
    {
        if (itab != ref.itab) return false;
        if (word != ref.word) return false;
        return true;
    }

    std::ostream& nonEmptyInterface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << itab;
        os << " " << word;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct nonEmptyInterface& value)
    {
        return value.PrintTo(os);
    }

    // mustBe panics if f's kind is not expected.
    // Making this a method on flag instead of on Value
    // (and embedding flag in Value) means that we can write
    // the very clear v.mustBe(Bool) and have it compile into
    // v.flag.mustBe(Bool), which will only bother to copy the
    // single important word for the receiver.
    void rec::mustBe(golang::reflect::flag f, golang::reflect::Kind expected)
    {
        if(Kind(f & flagKindMask) != expected)
        {
            gocpp::panic(new ValueError {valueMethodName(), rec::kind(gocpp::recv(f))});
        }
    }

    // mustBeExported panics if f records that the value was obtained using
    // an unexported field.
    void rec::mustBeExported(golang::reflect::flag f)
    {
        if(f == 0 || f & flagRO != 0)
        {
            rec::mustBeExportedSlow(gocpp::recv(f));
        }
    }

    void rec::mustBeExportedSlow(golang::reflect::flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {valueMethodName(), Invalid});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: "s + valueMethodName() + " using value obtained using unexported field"s);
        }
    }

    // mustBeAssignable panics if f records that the value is not assignable,
    // which is to say that either it was obtained using an unexported field
    // or it is not addressable.
    void rec::mustBeAssignable(golang::reflect::flag f)
    {
        if(f & flagRO != 0 || f & flagAddr == 0)
        {
            rec::mustBeAssignableSlow(gocpp::recv(f));
        }
    }

    void rec::mustBeAssignableSlow(golang::reflect::flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {valueMethodName(), Invalid});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: "s + valueMethodName() + " using value obtained using unexported field"s);
        }
        if(f & flagAddr == 0)
        {
            gocpp::panic("reflect: "s + valueMethodName() + " using unaddressable value"s);
        }
    }

    // Addr returns a pointer value representing the address of v.
    // It panics if [Value.CanAddr] returns false.
    // Addr is typically used to obtain a pointer to a struct field
    // or slice element in order to call a method that requires a
    // pointer receiver.
    struct Value rec::Addr(struct Value v)
    {
        if(v.flag & flagAddr == 0)
        {
            gocpp::panic("reflect.Value.Addr of unaddressable value"s);
        }
        auto fl = v.flag & flagRO;
        return Value {ptrTo(rec::typ(gocpp::recv(v))), v.ptr, fl | flag(Pointer)};
    }

    // Bool returns v's underlying value.
    // It panics if v's kind is not [Bool].
    bool rec::Bool(struct Value v)
    {
        if(rec::kind(gocpp::recv(v)) != Bool)
        {
            rec::panicNotBool(gocpp::recv(v));
        }
        return *(bool*)(v.ptr);
    }

    void rec::panicNotBool(struct Value v)
    {
        rec::mustBe(gocpp::recv(v), Bool);
    }

    abi::Type* bytesType = rtypeOf((gocpp::slice<unsigned char>)(nullptr));
    // Bytes returns v's underlying value.
    // It panics if v's underlying value is not a slice of bytes or
    // an addressable array of bytes.
    gocpp::slice<unsigned char> rec::Bytes(struct Value v)
    {
        if(v.typ_ == bytesType)
        {
            return *(gocpp::slice<unsigned char>*)(v.ptr);
        }
        return rec::bytesSlow(gocpp::recv(v));
    }

    gocpp::slice<unsigned char> rec::bytesSlow(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Slice) { conditionId = 0; }
            else if(condition == Array) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) != abi::Uint8)
                    {
                        gocpp::panic("reflect.Value.Bytes of non-byte slice"s);
                    }
                    return *(gocpp::slice<unsigned char>*)(v.ptr);
                    break;
                case 1:
                    if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) != abi::Uint8)
                    {
                        gocpp::panic("reflect.Value.Bytes of non-byte array"s);
                    }
                    if(! rec::CanAddr(gocpp::recv(v)))
                    {
                        gocpp::panic("reflect.Value.Bytes of unaddressable byte array"s);
                    }
                    auto p = (unsigned char*)(v.ptr);
                    auto n = int((reflect::arrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))))->Len);
                    return unsafe::Slice(p, n);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Bytes"s, rec::kind(gocpp::recv(v))});
    }

    // runes returns v's underlying value.
    // It panics if v's underlying value is not a slice of runes (int32s).
    gocpp::slice<gocpp::rune> rec::runes(struct Value v)
    {
        rec::mustBe(gocpp::recv(v), Slice);
        if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) != abi::Int32)
        {
            gocpp::panic("reflect.Value.Bytes of non-rune slice"s);
        }
        return *(gocpp::slice<gocpp::rune>*)(v.ptr);
    }

    // CanAddr reports whether the value's address can be obtained with [Value.Addr].
    // Such values are called addressable. A value is addressable if it is
    // an element of a slice, an element of an addressable array,
    // a field of an addressable struct, or the result of dereferencing a pointer.
    // If CanAddr returns false, calling [Value.Addr] will panic.
    bool rec::CanAddr(struct Value v)
    {
        return v.flag & flagAddr != 0;
    }

    // CanSet reports whether the value of v can be changed.
    // A [Value] can be changed only if it is addressable and was not
    // obtained by the use of unexported struct fields.
    // If CanSet returns false, calling [Value.Set] or any type-specific
    // setter (e.g., [Value.SetBool], [Value.SetInt]) will panic.
    bool rec::CanSet(struct Value v)
    {
        return v.flag & (flagAddr | flagRO) == flagAddr;
    }

    // Call calls the function v with the input arguments in.
    // For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
    // Call panics if v's Kind is not [Func].
    // It returns the output results as Values.
    // As in Go, each input argument must be assignable to the
    // type of the function's corresponding input parameter.
    // If v is a variadic function, Call creates the variadic slice parameter
    // itself, copying in the corresponding values.
    gocpp::slice<Value> rec::Call(struct Value v, gocpp::slice<Value> in)
    {
        rec::mustBe(gocpp::recv(v), Func);
        rec::mustBeExported(gocpp::recv(v));
        return rec::call(gocpp::recv(v), "Call"s, in);
    }

    // CallSlice calls the variadic function v with the input arguments in,
    // assigning the slice in[len(in)-1] to v's final variadic argument.
    // For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).
    // CallSlice panics if v's Kind is not [Func] or if v is not variadic.
    // It returns the output results as Values.
    // As in Go, each input argument must be assignable to the
    // type of the function's corresponding input parameter.
    gocpp::slice<Value> rec::CallSlice(struct Value v, gocpp::slice<Value> in)
    {
        rec::mustBe(gocpp::recv(v), Func);
        rec::mustBeExported(gocpp::recv(v));
        return rec::call(gocpp::recv(v), "CallSlice"s, in);
    }

    bool callGC;
    gocpp::slice<Value> rec::call(struct Value v, std::string op, gocpp::slice<Value> in)
    {
        auto t = (reflect::funcType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        unsafe::Pointer fn = {};
        Value rcvr = {};
        abi::Type* rcvrtype = {};
        if(v.flag & flagMethod != 0)
        {
            rcvr = v;
            std::tie(rcvrtype, t, fn) = methodReceiver(op, v, int(v.flag) >> flagMethodShift);
        }
        else
        if(v.flag & flagIndir != 0)
        {
            fn = *(unsafe::Pointer*)(v.ptr);
        }
        else
        {
            fn = v.ptr;
        }
        if(fn == nullptr)
        {
            gocpp::panic("reflect.Value.Call: call of nil function"s);
        }
        auto isSlice = op == "CallSlice"s;
        auto n = rec::NumIn(gocpp::recv(t));
        auto isVariadic = rec::IsVariadic(gocpp::recv(t));
        if(isSlice)
        {
            if(! isVariadic)
            {
                gocpp::panic("reflect: CallSlice of non-variadic function"s);
            }
            if(len(in) < n)
            {
                gocpp::panic("reflect: CallSlice with too few input arguments"s);
            }
            if(len(in) > n)
            {
                gocpp::panic("reflect: CallSlice with too many input arguments"s);
            }
        }
        else
        {
            if(isVariadic)
            {
                n--;
            }
            if(len(in) < n)
            {
                gocpp::panic("reflect: Call with too few input arguments"s);
            }
            if(! isVariadic && len(in) > n)
            {
                gocpp::panic("reflect: Call with too many input arguments"s);
            }
        }
        for(auto [gocpp_ignored, x] : in)
        {
            if(rec::Kind(gocpp::recv(x)) == Invalid)
            {
                gocpp::panic("reflect: "s + op + " using zero Value argument"s);
            }
        }
        for(auto i = 0; i < n; i++)
        {
            if(auto [xt, targ] = std::tuple{rec::Type(gocpp::recv(in[i])), rec::In(gocpp::recv(t), i)}; ! rec::AssignableTo(gocpp::recv(xt), toRType(targ)))
            {
                gocpp::panic("reflect: "s + op + " using "s + rec::String(gocpp::recv(xt)) + " as type "s + stringFor(targ));
            }
        }
        if(! isSlice && isVariadic)
        {
            auto m = len(in) - n;
            auto slice = MakeSlice(toRType(rec::In(gocpp::recv(t), n)), m, m);
            auto elem = rec::Elem(gocpp::recv(toRType(rec::In(gocpp::recv(t), n))));
            for(auto i = 0; i < m; i++)
            {
                auto x = in[n + i];
                if(auto xt = rec::Type(gocpp::recv(x)); ! rec::AssignableTo(gocpp::recv(xt), elem))
                {
                    gocpp::panic("reflect: cannot use "s + rec::String(gocpp::recv(xt)) + " as type "s + rec::String(gocpp::recv(elem)) + " in "s + op);
                }
                rec::Set(gocpp::recv(rec::Index(gocpp::recv(slice), i)), x);
            }
            auto origIn = in;
            in = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), n + 1);
            copy(in.make_slice(0, n), origIn);
            in[n] = slice;
        }
        auto nin = len(in);
        if(nin != rec::NumIn(gocpp::recv(t)))
        {
            gocpp::panic("reflect.Value.Call: wrong argument count"s);
        }
        auto nout = rec::NumOut(gocpp::recv(t));
        // Register argument space.
        abi::RegArgs regArgs = {};
        auto [frametype, framePool, abid] = funcLayout(t, rcvrtype);
        // Allocate a chunk of memory for frame if needed.
        unsafe::Pointer stackArgs = {};
        if(rec::Size(gocpp::recv(frametype)) != 0)
        {
            if(nout == 0)
            {
                stackArgs = gocpp::getValue<unsafe::Pointer>(rec::Get(gocpp::recv(framePool)));
            }
            else
            {
                stackArgs = unsafe_New(frametype);
            }
        }
        auto frameSize = rec::Size(gocpp::recv(frametype));
        if(debugReflectCall)
        {
            println("reflect.call"s, stringFor(& t->Type));
            rec::dump(gocpp::recv(abid));
        }
        auto inStart = 0;
        if(rcvrtype != nullptr)
        {
            //Go switch emulation
            {
                auto st = abid.call.steps[0];
                auto condition = st.kind;
                int conditionId = -1;
                if(condition == abiStepStack) { conditionId = 0; }
                else if(condition == abiStepPointer) { conditionId = 1; }
                else if(condition == abiStepIntReg) { conditionId = 2; }
                else if(condition == abiStepFloatReg) { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        storeRcvr(rcvr, stackArgs);
                        break;
                    case 1:
                        storeRcvr(rcvr, unsafe::Pointer(& regArgs.Ptrs[st.ireg]));
                    case 2:
                        storeRcvr(rcvr, unsafe::Pointer(& regArgs.Ints[st.ireg]));
                        break;
                    case 3:
                        storeRcvr(rcvr, unsafe::Pointer(& regArgs.Floats[st.freg]));
                        break;
                    default:
                        gocpp::panic("unknown ABI parameter kind"s);
                        break;
                }
            }
            inStart = 1;
        }
        for(auto [i, v] : in)
        {
            rec::mustBeExported(gocpp::recv(v));
            auto targ = toRType(rec::In(gocpp::recv(t), i));
            v = rec::assignTo(gocpp::recv(v), "reflect.Value.Call"s, & targ->t, nullptr);
            stepsLoop:
            for(auto [gocpp_ignored, st] : rec::stepsForValue(gocpp::recv(abid.call), i + inStart))
            {
                //Go switch emulation
                {
                    auto condition = st.kind;
                    int conditionId = -1;
                    if(condition == abiStepStack) { conditionId = 0; }
                    else if(condition == abiStepIntReg) { conditionId = 1; }
                    else if(condition == abiStepPointer) { conditionId = 2; }
                    else if(condition == abiStepFloatReg) { conditionId = 3; }
                    switch(conditionId)
                    {
                        case 0:
                            auto addr = add(stackArgs, st.stkOff, "precomputed stack arg offset"s);
                            if(v.flag & flagIndir != 0)
                            {
                                typedmemmove(& targ->t, addr, v.ptr);
                            }
                            else
                            {
                                *(unsafe::Pointer*)(addr) = v.ptr;
                            }
                            goto stepsLoop_break;
                            break;
                        case 1:
                        case 2:
                            if(v.flag & flagIndir != 0)
                            {
                                auto offset = add(v.ptr, st.offset, "precomputed value offset"s);
                                if(st.kind == abiStepPointer)
                                {
                                    regArgs.Ptrs[st.ireg] = *(unsafe::Pointer*)(offset);
                                }
                                intToReg(& regArgs, st.ireg, st.size, offset);
                            }
                            else
                            {
                                if(st.kind == abiStepPointer)
                                {
                                    regArgs.Ptrs[st.ireg] = v.ptr;
                                }
                                regArgs.Ints[st.ireg] = uintptr_t(v.ptr);
                            }
                            break;
                        case 3:
                            if(v.flag & flagIndir == 0)
                            {
                                gocpp::panic("attempted to copy pointer to FP register"s);
                            }
                            auto offset = add(v.ptr, st.offset, "precomputed value offset"s);
                            floatToReg(& regArgs, st.freg, st.size, offset);
                            break;
                        default:
                            gocpp::panic("unknown ABI part kind"s);
                            break;
                    }
                }
                if(false) {
                stepsLoop_continue:
                    continue;
                stepsLoop_break:
                    break;
                }
            }
        }
        frameSize = align(frameSize, goarch::PtrSize);
        frameSize += abid.spill;
        regArgs.ReturnIsPtr = abid.outRegPtrs;
        if(debugReflectCall)
        {
            rec::Dump(gocpp::recv(regArgs));
        }
        if(callGC)
        {
            runtime::GC();
        }
        call(frametype, fn, stackArgs, uint32_t(rec::Size(gocpp::recv(frametype))), uint32_t(abid.retOffset), uint32_t(frameSize), & regArgs);
        if(callGC)
        {
            runtime::GC();
        }
        gocpp::slice<Value> ret = {};
        if(nout == 0)
        {
            if(stackArgs != nullptr)
            {
                typedmemclr(frametype, stackArgs);
                rec::Put(gocpp::recv(framePool), stackArgs);
            }
        }
        else
        {
            if(stackArgs != nullptr)
            {
                typedmemclrpartial(frametype, stackArgs, 0, abid.retOffset);
            }
            ret = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), nout);
            for(auto i = 0; i < nout; i++)
            {
                auto tv = rec::Out(gocpp::recv(t), i);
                if(rec::Size(gocpp::recv(tv)) == 0)
                {
                    ret[i] = Zero(toRType(tv));
                    continue;
                }
                auto steps = rec::stepsForValue(gocpp::recv(abid.ret), i);
                if(auto st = steps[0]; st.kind == abiStepStack)
                {
                    auto fl = flagIndir | flag(rec::Kind(gocpp::recv(tv)));
                    ret[i] = Value {tv, add(stackArgs, st.stkOff, "tv.Size() != 0"s), fl};
                    continue;
                }
                if(! ifaceIndir(tv))
                {
                    if(steps[0].kind != abiStepPointer)
                    {
                        print("kind="s, steps[0].kind, ", type="s, stringFor(tv), "\n"s);
                        gocpp::panic("mismatch between ABI description and types"s);
                    }
                    ret[i] = Value {tv, regArgs.Ptrs[steps[0].ireg], flag(rec::Kind(gocpp::recv(tv)))};
                    continue;
                }
                auto s = unsafe_New(tv);
                for(auto [gocpp_ignored, st] : steps)
                {
                    //Go switch emulation
                    {
                        auto condition = st.kind;
                        int conditionId = -1;
                        if(condition == abiStepIntReg) { conditionId = 0; }
                        else if(condition == abiStepPointer) { conditionId = 1; }
                        else if(condition == abiStepFloatReg) { conditionId = 2; }
                        else if(condition == abiStepStack) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                auto offset = add(s, st.offset, "precomputed value offset"s);
                                intFromReg(& regArgs, st.ireg, st.size, offset);
                                break;
                            case 1:
                                auto s = add(s, st.offset, "precomputed value offset"s);
                                *((unsafe::Pointer*)(s)) = regArgs.Ptrs[st.ireg];
                                break;
                            case 2:
                                auto offset = add(s, st.offset, "precomputed value offset"s);
                                floatFromReg(& regArgs, st.freg, st.size, offset);
                                break;
                            case 3:
                                gocpp::panic("register-based return value has stack component"s);
                                break;
                            default:
                                gocpp::panic("unknown ABI part kind"s);
                                break;
                        }
                    }
                }
                ret[i] = Value {tv, s, flagIndir | flag(rec::Kind(gocpp::recv(tv)))};
            }
        }
        return ret;
    }

    // callReflect is the call implementation used by a function
    // returned by MakeFunc. In many ways it is the opposite of the
    // method Value.call above. The method above converts a call using Values
    // into a call of a function with a concrete argument frame, while
    // callReflect converts a call of a function with a concrete argument
    // frame into a call using Values.
    // It is in this file so that it can be next to the call method above.
    // The remainder of the MakeFunc implementation is in makefunc.go.
    //
    // NOTE: This function must be marked as a "wrapper" in the generated code,
    // so that the linker can make it work correctly for panic and recover.
    // The gc compilers know to do that for the name "reflect.callReflect".
    //
    // ctxt is the "closure" generated by MakeFunc.
    // frame is a pointer to the arguments to that closure on the stack.
    // retValid points to a boolean which should be set when the results
    // section of frame is set.
    //
    // regs contains the argument values passed in registers and will contain
    // the values returned from ctxt.fn in registers.
    void callReflect(struct makeFuncImpl* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs)
    {
        if(callGC)
        {
            runtime::GC();
        }
        auto ftyp = ctxt->ftyp;
        auto f = ctxt->fn;
        auto [gocpp_id_3, gocpp_id_4, abid] = funcLayout(ftyp, nullptr);
        auto ptr = frame;
        auto in = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), 0, int(ftyp->InCount));
        for(auto [i, typ] : rec::InSlice(gocpp::recv(ftyp)))
        {
            if(rec::Size(gocpp::recv(typ)) == 0)
            {
                in = append(in, Zero(toRType(typ)));
                continue;
            }
            auto v = Value {typ, nullptr, flag(rec::Kind(gocpp::recv(typ)))};
            auto steps = rec::stepsForValue(gocpp::recv(abid.call), i);
            if(auto st = steps[0]; st.kind == abiStepStack)
            {
                if(ifaceIndir(typ))
                {
                    v.ptr = unsafe_New(typ);
                    if(rec::Size(gocpp::recv(typ)) > 0)
                    {
                        typedmemmove(typ, v.ptr, add(ptr, st.stkOff, "typ.size > 0"s));
                    }
                    v.flag |= flagIndir;
                }
                else
                {
                    v.ptr = *(unsafe::Pointer*)(add(ptr, st.stkOff, "1-ptr"s));
                }
            }
            else
            {
                if(ifaceIndir(typ))
                {
                    v.flag |= flagIndir;
                    v.ptr = unsafe_New(typ);
                    for(auto [gocpp_ignored, st] : steps)
                    {
                        //Go switch emulation
                        {
                            auto condition = st.kind;
                            int conditionId = -1;
                            if(condition == abiStepIntReg) { conditionId = 0; }
                            else if(condition == abiStepPointer) { conditionId = 1; }
                            else if(condition == abiStepFloatReg) { conditionId = 2; }
                            else if(condition == abiStepStack) { conditionId = 3; }
                            switch(conditionId)
                            {
                                case 0:
                                    auto offset = add(v.ptr, st.offset, "precomputed value offset"s);
                                    intFromReg(regs, st.ireg, st.size, offset);
                                    break;
                                case 1:
                                    auto s = add(v.ptr, st.offset, "precomputed value offset"s);
                                    *((unsafe::Pointer*)(s)) = regs->Ptrs[st.ireg];
                                    break;
                                case 2:
                                    auto offset = add(v.ptr, st.offset, "precomputed value offset"s);
                                    floatFromReg(regs, st.freg, st.size, offset);
                                    break;
                                case 3:
                                    gocpp::panic("register-based return value has stack component"s);
                                    break;
                                default:
                                    gocpp::panic("unknown ABI part kind"s);
                                    break;
                            }
                        }
                    }
                }
                else
                {
                    if(steps[0].kind != abiStepPointer)
                    {
                        print("kind="s, steps[0].kind, ", type="s, stringFor(typ), "\n"s);
                        gocpp::panic("mismatch between ABI description and types"s);
                    }
                    v.ptr = regs->Ptrs[steps[0].ireg];
                }
            }
            in = append(in, v);
        }
        auto out = f(in);
        auto numOut = rec::NumOut(gocpp::recv(ftyp));
        if(len(out) != numOut)
        {
            gocpp::panic("reflect: wrong return count from function created by MakeFunc"s);
        }
        if(numOut > 0)
        {
            for(auto [i, typ] : rec::OutSlice(gocpp::recv(ftyp)))
            {
                auto v = out[i];
                if(rec::typ(gocpp::recv(v)) == nullptr)
                {
                    gocpp::panic("reflect: function created by MakeFunc using "s + funcName(f) + " returned zero Value"s);
                }
                if(v.flag & flagRO != 0)
                {
                    gocpp::panic("reflect: function created by MakeFunc using "s + funcName(f) + " returned value obtained from unexported field"s);
                }
                if(rec::Size(gocpp::recv(typ)) == 0)
                {
                    continue;
                }
                v = rec::assignTo(gocpp::recv(v), "reflect.MakeFunc"s, typ, nullptr);
                stepsLoop:
                for(auto [gocpp_ignored, st] : rec::stepsForValue(gocpp::recv(abid.ret), i))
                {
                    //Go switch emulation
                    {
                        auto condition = st.kind;
                        int conditionId = -1;
                        if(condition == abiStepStack) { conditionId = 0; }
                        else if(condition == abiStepIntReg) { conditionId = 1; }
                        else if(condition == abiStepPointer) { conditionId = 2; }
                        else if(condition == abiStepFloatReg) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                auto addr = add(ptr, st.stkOff, "precomputed stack arg offset"s);
                                if(v.flag & flagIndir != 0)
                                {
                                    memmove(addr, v.ptr, st.size);
                                }
                                else
                                {
                                    *(uintptr_t*)(addr) = uintptr_t(v.ptr);
                                }
                                goto stepsLoop_break;
                                break;
                            case 1:
                            case 2:
                                if(v.flag & flagIndir != 0)
                                {
                                    auto offset = add(v.ptr, st.offset, "precomputed value offset"s);
                                    intToReg(regs, st.ireg, st.size, offset);
                                }
                                else
                                {
                                    regs->Ints[st.ireg] = uintptr_t(v.ptr);
                                }
                                break;
                            case 3:
                                if(v.flag & flagIndir == 0)
                                {
                                    gocpp::panic("attempted to copy pointer to FP register"s);
                                }
                                auto offset = add(v.ptr, st.offset, "precomputed value offset"s);
                                floatToReg(regs, st.freg, st.size, offset);
                                break;
                            default:
                                gocpp::panic("unknown ABI part kind"s);
                                break;
                        }
                    }
                    if(false) {
                    stepsLoop_continue:
                        continue;
                    stepsLoop_break:
                        break;
                    }
                }
            }
        }
        *retValid = true;
        runtime::KeepAlive(out);
        runtime::KeepAlive(ctxt);
    }

    // methodReceiver returns information about the receiver
    // described by v. The Value v may or may not have the
    // flagMethod bit set, so the kind cached in v.flag should
    // not be used.
    // The return value rcvrtype gives the method's actual receiver type.
    // The return value t gives the method type signature (without the receiver).
    // The return value fn is a pointer to the method code.
    std::tuple<abi::Type*, reflect::funcType*, unsafe::Pointer> methodReceiver(std::string op, struct Value v, int methodIndex)
    {
        abi::Type* rcvrtype;
        reflect::funcType* t;
        unsafe::Pointer fn;
        auto i = methodIndex;
        if(rec::Kind(gocpp::recv(rec::typ(gocpp::recv(v)))) == abi::Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
            if((unsigned int)(i) >= (unsigned int)(len(tt->Methods)))
            {
                gocpp::panic("reflect: internal error: invalid method index"s);
            }
            auto m = & tt->Methods[i];
            if(! rec::IsExported(gocpp::recv(rec::nameOff(gocpp::recv(tt), m->Name))))
            {
                gocpp::panic("reflect: "s + op + " of unexported method"s);
            }
            auto iface = (nonEmptyInterface*)(v.ptr);
            if(iface->itab == nullptr)
            {
                gocpp::panic("reflect: "s + op + " of method on nil interface value"s);
            }
            rcvrtype = iface->itab->typ;
            fn = unsafe::Pointer(& iface->itab->fun[i]);
            t = (reflect::funcType*)(unsafe::Pointer(rec::typeOff(gocpp::recv(tt), m->Typ)));
        }
        else
        {
            rcvrtype = rec::typ(gocpp::recv(v));
            auto ms = rec::ExportedMethods(gocpp::recv(rec::typ(gocpp::recv(v))));
            if((unsigned int)(i) >= (unsigned int)(len(ms)))
            {
                gocpp::panic("reflect: internal error: invalid method index"s);
            }
            auto m = ms[i];
            if(! rec::IsExported(gocpp::recv(nameOffFor(rec::typ(gocpp::recv(v)), m.Name))))
            {
                gocpp::panic("reflect: "s + op + " of unexported method"s);
            }
            auto ifn = textOffFor(rec::typ(gocpp::recv(v)), m.Ifn);
            fn = unsafe::Pointer(& ifn);
            t = (reflect::funcType*)(unsafe::Pointer(typeOffFor(rec::typ(gocpp::recv(v)), m.Mtyp)));
        }
        return {rcvrtype, t, fn};
    }

    // v is a method receiver. Store at p the word which is used to
    // encode that receiver at the start of the argument list.
    // Reflect uses the "interface" calling convention for
    // methods, which always uses one word to record the receiver.
    void storeRcvr(struct Value v, unsafe::Pointer p)
    {
        auto t = rec::typ(gocpp::recv(v));
        if(rec::Kind(gocpp::recv(t)) == abi::Interface)
        {
            auto iface = (nonEmptyInterface*)(v.ptr);
            *(unsafe::Pointer*)(p) = iface->word;
        }
        else
        if(v.flag & flagIndir != 0 && ! ifaceIndir(t))
        {
            *(unsafe::Pointer*)(p) = *(unsafe::Pointer*)(v.ptr);
        }
        else
        {
            *(unsafe::Pointer*)(p) = v.ptr;
        }
    }

    // align returns the result of rounding x up to a multiple of n.
    // n must be a power of two.
    uintptr_t align(uintptr_t x, uintptr_t n)
    {
        return (x + n - 1) &^ (n - 1);
    }

    // callMethod is the call implementation used by a function returned
    // by makeMethodValue (used by v.Method(i).Interface()).
    // It is a streamlined version of the usual reflect call: the caller has
    // already laid out the argument frame for us, so we don't have
    // to deal with individual Values for each argument.
    // It is in this file so that it can be next to the two similar functions above.
    // The remainder of the makeMethodValue implementation is in makefunc.go.
    //
    // NOTE: This function must be marked as a "wrapper" in the generated code,
    // so that the linker can make it work correctly for panic and recover.
    // The gc compilers know to do that for the name "reflect.callMethod".
    //
    // ctxt is the "closure" generated by makeVethodValue.
    // frame is a pointer to the arguments to that closure on the stack.
    // retValid points to a boolean which should be set when the results
    // section of frame is set.
    //
    // regs contains the argument values passed in registers and will contain
    // the values returned from ctxt.fn in registers.
    void callMethod(struct methodValue* ctxt, unsafe::Pointer frame, bool* retValid, abi::RegArgs* regs)
    {
        auto rcvr = ctxt->rcvr;
        auto [rcvrType, valueFuncType, methodFn] = methodReceiver("call"s, rcvr, ctxt->method);
        auto [gocpp_id_7, gocpp_id_8, valueABI] = funcLayout(valueFuncType, nullptr);
        auto [valueFrame, valueRegs] = std::tuple{frame, regs};
        auto [methodFrameType, methodFramePool, methodABI] = funcLayout(valueFuncType, rcvrType);
        auto methodFrame = gocpp::getValue<unsafe::Pointer>(rec::Get(gocpp::recv(methodFramePool)));
        abi::RegArgs methodRegs = {};
        //Go switch emulation
        {
            auto st = methodABI.call.steps[0];
            auto condition = st.kind;
            int conditionId = -1;
            if(condition == abiStepStack) { conditionId = 0; }
            else if(condition == abiStepPointer) { conditionId = 1; }
            else if(condition == abiStepIntReg) { conditionId = 2; }
            else if(condition == abiStepFloatReg) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    storeRcvr(rcvr, methodFrame);
                    break;
                case 1:
                    storeRcvr(rcvr, unsafe::Pointer(& methodRegs.Ptrs[st.ireg]));
                case 2:
                    storeRcvr(rcvr, unsafe::Pointer(& methodRegs.Ints[st.ireg]));
                    break;
                case 3:
                    storeRcvr(rcvr, unsafe::Pointer(& methodRegs.Floats[st.freg]));
                    break;
                default:
                    gocpp::panic("unknown ABI parameter kind"s);
                    break;
            }
        }
        for(auto [i, t] : rec::InSlice(gocpp::recv(valueFuncType)))
        {
            auto valueSteps = rec::stepsForValue(gocpp::recv(valueABI.call), i);
            auto methodSteps = rec::stepsForValue(gocpp::recv(methodABI.call), i + 1);
            if(len(valueSteps) == 0)
            {
                if(len(methodSteps) != 0)
                {
                    gocpp::panic("method ABI and value ABI do not align"s);
                }
                continue;
            }
            if(auto vStep = valueSteps[0]; vStep.kind == abiStepStack)
            {
                auto mStep = methodSteps[0];
                if(mStep.kind == abiStepStack)
                {
                    if(vStep.size != mStep.size)
                    {
                        gocpp::panic("method ABI and value ABI do not align"s);
                    }
                    typedmemmove(t, add(methodFrame, mStep.stkOff, "precomputed stack offset"s), add(valueFrame, vStep.stkOff, "precomputed stack offset"s));
                    continue;
                }
                for(auto [gocpp_ignored, mStep] : methodSteps)
                {
                    auto from = add(valueFrame, vStep.stkOff + mStep.offset, "precomputed stack offset"s);
                    //Go switch emulation
                    {
                        auto condition = mStep.kind;
                        int conditionId = -1;
                        if(condition == abiStepPointer) { conditionId = 0; }
                        else if(condition == abiStepIntReg) { conditionId = 1; }
                        else if(condition == abiStepFloatReg) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                methodRegs.Ptrs[mStep.ireg] = *(unsafe::Pointer*)(from);
                            case 1:
                                intToReg(& methodRegs, mStep.ireg, mStep.size, from);
                                break;
                            case 2:
                                floatToReg(& methodRegs, mStep.freg, mStep.size, from);
                                break;
                            default:
                                gocpp::panic("unexpected method step"s);
                                break;
                        }
                    }
                }
                continue;
            }
            if(auto mStep = methodSteps[0]; mStep.kind == abiStepStack)
            {
                for(auto [gocpp_ignored, vStep] : valueSteps)
                {
                    auto to = add(methodFrame, mStep.stkOff + vStep.offset, "precomputed stack offset"s);
                    //Go switch emulation
                    {
                        auto condition = vStep.kind;
                        int conditionId = -1;
                        if(condition == abiStepPointer) { conditionId = 0; }
                        else if(condition == abiStepIntReg) { conditionId = 1; }
                        else if(condition == abiStepFloatReg) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                *(unsafe::Pointer*)(to) = valueRegs->Ptrs[vStep.ireg];
                                break;
                            case 1:
                                intFromReg(valueRegs, vStep.ireg, vStep.size, to);
                                break;
                            case 2:
                                floatFromReg(valueRegs, vStep.freg, vStep.size, to);
                                break;
                            default:
                                gocpp::panic("unexpected value step"s);
                                break;
                        }
                    }
                }
                continue;
            }
            if(len(valueSteps) != len(methodSteps))
            {
                gocpp::panic("method ABI and value ABI don't align"s);
            }
            for(auto [i, vStep] : valueSteps)
            {
                auto mStep = methodSteps[i];
                if(mStep.kind != vStep.kind)
                {
                    gocpp::panic("method ABI and value ABI don't align"s);
                }
                //Go switch emulation
                {
                    auto condition = vStep.kind;
                    int conditionId = -1;
                    if(condition == abiStepPointer) { conditionId = 0; }
                    else if(condition == abiStepIntReg) { conditionId = 1; }
                    else if(condition == abiStepFloatReg) { conditionId = 2; }
                    switch(conditionId)
                    {
                        case 0:
                            methodRegs.Ptrs[mStep.ireg] = valueRegs->Ptrs[vStep.ireg];
                        case 1:
                            methodRegs.Ints[mStep.ireg] = valueRegs->Ints[vStep.ireg];
                            break;
                        case 2:
                            methodRegs.Floats[mStep.freg] = valueRegs->Floats[vStep.freg];
                            break;
                        default:
                            gocpp::panic("unexpected value step"s);
                            break;
                    }
                }
            }
        }
        auto methodFrameSize = rec::Size(gocpp::recv(methodFrameType));
        methodFrameSize = align(methodFrameSize, goarch::PtrSize);
        methodFrameSize += methodABI.spill;
        methodRegs.ReturnIsPtr = methodABI.outRegPtrs;
        call(methodFrameType, methodFn, methodFrame, uint32_t(rec::Size(gocpp::recv(methodFrameType))), uint32_t(methodABI.retOffset), uint32_t(methodFrameSize), & methodRegs);
        if(valueRegs != nullptr)
        {
            *valueRegs = methodRegs;
        }
        if(auto retSize = rec::Size(gocpp::recv(methodFrameType)) - methodABI.retOffset; retSize > 0)
        {
            auto valueRet = add(valueFrame, valueABI.retOffset, "valueFrame's size > retOffset"s);
            auto methodRet = add(methodFrame, methodABI.retOffset, "methodFrame's size > retOffset"s);
            memmove(valueRet, methodRet, retSize);
        }
        *retValid = true;
        typedmemclr(methodFrameType, methodFrame);
        rec::Put(gocpp::recv(methodFramePool), methodFrame);
        runtime::KeepAlive(ctxt);
        runtime::KeepAlive(valueRegs);
    }

    // funcName returns the name of f, for use in error messages.
    std::string funcName(std::function<gocpp::slice<Value> (gocpp::slice<Value> _1)> f)
    {
        auto pc = *(uintptr_t*)(unsafe::Pointer(& f));
        auto rf = runtime::FuncForPC(pc);
        if(rf != nullptr)
        {
            return rec::Name(gocpp::recv(rf));
        }
        return "closure"s;
    }

    // Cap returns v's capacity.
    // It panics if v's Kind is not [Array], [Chan], [Slice] or pointer to [Array].
    int rec::Cap(struct Value v)
    {
        if(rec::kind(gocpp::recv(v)) == Slice)
        {
            return (unsafeheader::Slice*)(v.ptr)->Cap;
        }
        return rec::capNonSlice(gocpp::recv(v));
    }

    int rec::capNonSlice(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Ptr) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return rec::Len(gocpp::recv(rec::typ(gocpp::recv(v))));
                    break;
                case 1:
                    return chancap(rec::pointer(gocpp::recv(v)));
                    break;
                case 2:
                    if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) == abi::Array)
                    {
                        return rec::Len(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v))))));
                    }
                    gocpp::panic("reflect: call of reflect.Value.Cap on ptr to non-array Value"s);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Cap"s, rec::kind(gocpp::recv(v))});
    }

    // Close closes the channel v.
    // It panics if v's Kind is not [Chan] or
    // v is a receive-only channel.
    void rec::Close(struct Value v)
    {
        rec::mustBe(gocpp::recv(v), Chan);
        rec::mustBeExported(gocpp::recv(v));
        auto tt = (reflect::chanType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        if(ChanDir(tt->Dir) & SendDir == 0)
        {
            gocpp::panic("reflect: close of receive-only channel"s);
        }
        chanclose(rec::pointer(gocpp::recv(v)));
    }

    // CanComplex reports whether [Value.Complex] can be used without panicking.
    bool rec::CanComplex(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Complex64) { conditionId = 0; }
            else if(condition == Complex128) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    return true;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    // Complex returns v's underlying value, as a complex128.
    // It panics if v's Kind is not [Complex64] or [Complex128]
    struct gocpp::complex128 rec::Complex(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Complex64) { conditionId = 0; }
            else if(condition == Complex128) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return gocpp::complex128(*(gocpp::complex64*)(v.ptr));
                    break;
                case 1:
                    return *(gocpp::complex128*)(v.ptr);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Complex"s, rec::kind(gocpp::recv(v))});
    }

    
                        template<typename T>
                        gocpp_id_9::gocpp_id_9(T& ref)
                        {
                            value.reset(new gocpp_id_9Impl<T, std::unique_ptr<T>>(new T(ref)));
                        }

                        template<typename T>
                        gocpp_id_9::gocpp_id_9(const T& ref)
                        {
                            value.reset(new gocpp_id_9Impl<T, std::unique_ptr<T>>(new T(ref)));
                        }

                        template<typename T>
                        gocpp_id_9::gocpp_id_9(T* ptr)
                        {
                            value.reset(new gocpp_id_9Impl<T, gocpp::ptr<T>>(ptr));
                        }

                        std::ostream& gocpp_id_9::PrintTo(std::ostream& os) const
                        {
                            return os;
                        }

                        template<typename T, typename StoreT>
                        void gocpp_id_9::gocpp_id_9Impl<T, StoreT>::vM()
                        {
                            return rec::M(gocpp::PtrRecv<T, false>(value.get()));
                        }

                        namespace rec
                        {
                            void M(const gocpp::PtrRecv<struct gocpp_id_9, false>& self)
                            {
                                return self.ptr->value->vM();
                            }

                            void M(const gocpp::ObjRecv<struct gocpp_id_9>& self)
                            {
                                return self.obj.value->vM();
                            }
                        }

                        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_9& value)
                        {
                            return value.PrintTo(os);
                        }


    // Elem returns the value that the interface v contains
    // or that the pointer v points to.
    // It panics if v's Kind is not [Interface] or [Pointer].
    // It returns the zero Value if v is nil.
    struct Value rec::Elem(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Interface) { conditionId = 0; }
            else if(condition == Pointer) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    go_any eface = {};
                    if(rec::NumMethod(gocpp::recv(rec::typ(gocpp::recv(v)))) == 0)
                    {
                        eface = *(go_any*)(v.ptr);
                    }
                    else
                    {
                        eface = (go_any)(*(gocpp_id_9*)(v.ptr));
                    }
                    auto x = unpackEface(eface);
                    if(x.flag != 0)
                    {
                        x.flag |= rec::ro(gocpp::recv(v.flag));
                    }
                    return x;
                    break;
                case 1:
                    auto ptr = v.ptr;
                    if(v.flag & flagIndir != 0)
                    {
                        if(ifaceIndir(rec::typ(gocpp::recv(v))))
                        {
                            if(! verifyNotInHeapPtr(*(uintptr_t*)(ptr)))
                            {
                                gocpp::panic("reflect: reflect.Value.Elem on an invalid notinheap pointer"s);
                            }
                        }
                        ptr = *(unsafe::Pointer*)(ptr);
                    }
                    if(ptr == nullptr)
                    {
                        return Value {};
                    }
                    auto tt = (ptrType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    auto typ = tt->Elem;
                    auto fl = v.flag & flagRO | flagIndir | flagAddr;
                    fl |= flag(rec::Kind(gocpp::recv(typ)));
                    return Value {typ, ptr, fl};
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Elem"s, rec::kind(gocpp::recv(v))});
    }

    // Field returns the i'th field of the struct v.
    // It panics if v's Kind is not [Struct] or i is out of range.
    struct Value rec::Field(struct Value v, int i)
    {
        if(rec::kind(gocpp::recv(v)) != Struct)
        {
            gocpp::panic(new ValueError {"reflect.Value.Field"s, rec::kind(gocpp::recv(v))});
        }
        auto tt = (structType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        if((unsigned int)(i) >= (unsigned int)(len(tt->Fields)))
        {
            gocpp::panic("reflect: Field index out of range"s);
        }
        auto field = & tt->Fields[i];
        auto typ = field->Typ;
        auto fl = v.flag & (flagStickyRO | flagIndir | flagAddr) | flag(rec::Kind(gocpp::recv(typ)));
        if(! rec::IsExported(gocpp::recv(field->Name)))
        {
            if(rec::Embedded(gocpp::recv(field)))
            {
                fl |= flagEmbedRO;
            }
            else
            {
                fl |= flagStickyRO;
            }
        }
        auto ptr = add(v.ptr, field->Offset, "same as non-reflect &v.field"s);
        return Value {typ, ptr, fl};
    }

    // FieldByIndex returns the nested field corresponding to index.
    // It panics if evaluation requires stepping through a nil
    // pointer or a field that is not a struct.
    struct Value rec::FieldByIndex(struct Value v, gocpp::slice<int> index)
    {
        if(len(index) == 1)
        {
            return rec::Field(gocpp::recv(v), index[0]);
        }
        rec::mustBe(gocpp::recv(v), Struct);
        for(auto [i, x] : index)
        {
            if(i > 0)
            {
                if(rec::Kind(gocpp::recv(v)) == Pointer && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) == abi::Struct)
                {
                    if(rec::IsNil(gocpp::recv(v)))
                    {
                        gocpp::panic("reflect: indirection through nil pointer to embedded struct"s);
                    }
                    v = rec::Elem(gocpp::recv(v));
                }
            }
            v = rec::Field(gocpp::recv(v), x);
        }
        return v;
    }

    // FieldByIndexErr returns the nested field corresponding to index.
    // It returns an error if evaluation requires stepping through a nil
    // pointer, but panics if it must step through a field that
    // is not a struct.
    std::tuple<struct Value, struct gocpp::error> rec::FieldByIndexErr(struct Value v, gocpp::slice<int> index)
    {
        if(len(index) == 1)
        {
            return {rec::Field(gocpp::recv(v), index[0]), nullptr};
        }
        rec::mustBe(gocpp::recv(v), Struct);
        for(auto [i, x] : index)
        {
            if(i > 0)
            {
                if(rec::Kind(gocpp::recv(v)) == Ptr && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) == abi::Struct)
                {
                    if(rec::IsNil(gocpp::recv(v)))
                    {
                        return {Value {}, errors::New("reflect: indirection through nil pointer to embedded struct field "s + nameFor(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v))))))};
                    }
                    v = rec::Elem(gocpp::recv(v));
                }
            }
            v = rec::Field(gocpp::recv(v), x);
        }
        return {v, nullptr};
    }

    // FieldByName returns the struct field with the given name.
    // It returns the zero Value if no field was found.
    // It panics if v's Kind is not [Struct].
    struct Value rec::FieldByName(struct Value v, std::string name)
    {
        rec::mustBe(gocpp::recv(v), Struct);
        if(auto [f, ok] = rec::FieldByName(gocpp::recv(toRType(rec::typ(gocpp::recv(v)))), name); ok)
        {
            return rec::FieldByIndex(gocpp::recv(v), f.Index);
        }
        return Value {};
    }

    // FieldByNameFunc returns the struct field with a name
    // that satisfies the match function.
    // It panics if v's Kind is not [Struct].
    // It returns the zero Value if no field was found.
    struct Value rec::FieldByNameFunc(struct Value v, std::function<bool (std::string _1)> match)
    {
        if(auto [f, ok] = rec::FieldByNameFunc(gocpp::recv(toRType(rec::typ(gocpp::recv(v)))), match); ok)
        {
            return rec::FieldByIndex(gocpp::recv(v), f.Index);
        }
        return Value {};
    }

    // CanFloat reports whether [Value.Float] can be used without panicking.
    bool rec::CanFloat(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Float32) { conditionId = 0; }
            else if(condition == Float64) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    return true;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    // Float returns v's underlying value, as a float64.
    // It panics if v's Kind is not [Float32] or [Float64]
    double rec::Float(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Float32) { conditionId = 0; }
            else if(condition == Float64) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return double(*(float*)(v.ptr));
                    break;
                case 1:
                    return *(double*)(v.ptr);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Float"s, rec::kind(gocpp::recv(v))});
    }

    abi::Type* uint8Type = rtypeOf(uint8_t(0));
    // Index returns v's i'th element.
    // It panics if v's Kind is not [Array], [Slice], or [String] or i is out of range.
    struct Value rec::Index(struct Value v, int i)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Slice) { conditionId = 1; }
            else if(condition == String) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    if((unsigned int)(i) >= (unsigned int)(tt->Len))
                    {
                        gocpp::panic("reflect: array index out of range"s);
                    }
                    auto typ = tt->Elem;
                    auto offset = uintptr_t(i) * rec::Size(gocpp::recv(typ));
                    auto val = add(v.ptr, offset, "same as &v[i], i < tt.len"s);
                    auto fl = v.flag & (flagIndir | flagAddr) | rec::ro(gocpp::recv(v.flag)) | flag(rec::Kind(gocpp::recv(typ)));
                    return Value {typ, val, fl};
                    break;
                case 1:
                    auto s = (unsafeheader::Slice*)(v.ptr);
                    if((unsigned int)(i) >= (unsigned int)(s->Len))
                    {
                        gocpp::panic("reflect: slice index out of range"s);
                    }
                    auto tt = (sliceType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    auto typ = tt->Elem;
                    auto val = arrayAt(s->Data, i, rec::Size(gocpp::recv(typ)), "i < s.Len"s);
                    auto fl = flagAddr | flagIndir | rec::ro(gocpp::recv(v.flag)) | flag(rec::Kind(gocpp::recv(typ)));
                    return Value {typ, val, fl};
                    break;
                case 2:
                    auto s = (unsafeheader::String*)(v.ptr);
                    if((unsigned int)(i) >= (unsigned int)(s->Len))
                    {
                        gocpp::panic("reflect: string index out of range"s);
                    }
                    auto p = arrayAt(s->Data, i, 1, "i < s.Len"s);
                    auto fl = rec::ro(gocpp::recv(v.flag)) | flag(Uint8) | flagIndir;
                    return Value {uint8Type, p, fl};
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Index"s, rec::kind(gocpp::recv(v))});
    }

    // CanInt reports whether Int can be used without panicking.
    bool rec::CanInt(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Int) { conditionId = 0; }
            else if(condition == Int8) { conditionId = 1; }
            else if(condition == Int16) { conditionId = 2; }
            else if(condition == Int32) { conditionId = 3; }
            else if(condition == Int64) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    return true;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    // Int returns v's underlying value, as an int64.
    // It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64].
    int64_t rec::Int(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        auto p = v.ptr;
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Int) { conditionId = 0; }
            else if(condition == Int8) { conditionId = 1; }
            else if(condition == Int16) { conditionId = 2; }
            else if(condition == Int32) { conditionId = 3; }
            else if(condition == Int64) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    return int64_t(*(int*)(p));
                    break;
                case 1:
                    return int64_t(*(int8_t*)(p));
                    break;
                case 2:
                    return int64_t(*(int16_t*)(p));
                    break;
                case 3:
                    return int64_t(*(int32_t*)(p));
                    break;
                case 4:
                    return *(int64_t*)(p);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Int"s, rec::kind(gocpp::recv(v))});
    }

    // CanInterface reports whether [Value.Interface] can be used without panicking.
    bool rec::CanInterface(struct Value v)
    {
        if(v.flag == 0)
        {
            gocpp::panic(new ValueError {"reflect.Value.CanInterface"s, Invalid});
        }
        return v.flag & flagRO == 0;
    }

    // Interface returns v's current value as an interface{}.
    // It is equivalent to:
    //
    //	var i interface{} = (v's underlying value)
    //
    // It panics if the Value was obtained by accessing
    // unexported struct fields.
    go_any rec::Interface(struct Value v)
    {
        go_any i;
        return valueInterface(v, true);
    }

    
            template<typename T>
            gocpp_id_10::gocpp_id_10(T& ref)
            {
                value.reset(new gocpp_id_10Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_10::gocpp_id_10(const T& ref)
            {
                value.reset(new gocpp_id_10Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_10::gocpp_id_10(T* ptr)
            {
                value.reset(new gocpp_id_10Impl<T, gocpp::ptr<T>>(ptr));
            }

            std::ostream& gocpp_id_10::PrintTo(std::ostream& os) const
            {
                return os;
            }

            template<typename T, typename StoreT>
            void gocpp_id_10::gocpp_id_10Impl<T, StoreT>::vM()
            {
                return rec::M(gocpp::PtrRecv<T, false>(value.get()));
            }

            namespace rec
            {
                void M(const gocpp::PtrRecv<struct gocpp_id_10, false>& self)
                {
                    return self.ptr->value->vM();
                }

                void M(const gocpp::ObjRecv<struct gocpp_id_10>& self)
                {
                    return self.obj.value->vM();
                }
            }

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_10& value)
            {
                return value.PrintTo(os);
            }


    go_any valueInterface(struct Value v, bool safe)
    {
        if(v.flag == 0)
        {
            gocpp::panic(new ValueError {"reflect.Value.Interface"s, Invalid});
        }
        if(safe && v.flag & flagRO != 0)
        {
            gocpp::panic("reflect.Value.Interface: cannot return value obtained from unexported field or method"s);
        }
        if(v.flag & flagMethod != 0)
        {
            v = makeMethodValue("Interface"s, v);
        }
        if(rec::kind(gocpp::recv(v)) == Interface)
        {
            if(rec::NumMethod(gocpp::recv(v)) == 0)
            {
                return *(go_any*)(v.ptr);
            }
            return *(gocpp_id_10*)(v.ptr);
        }
        return packEface(v);
    }

    // InterfaceData returns a pair of unspecified uintptr values.
    // It panics if v's Kind is not Interface.
    //
    // In earlier versions of Go, this function returned the interface's
    // value as a uintptr pair. As of Go 1.4, the implementation of
    // interface values precludes any defined use of InterfaceData.
    //
    // Deprecated: The memory representation of interface values is not
    // compatible with InterfaceData.
    gocpp::array<uintptr_t, 2> rec::InterfaceData(struct Value v)
    {
        rec::mustBe(gocpp::recv(v), Interface);
        escapes(v.ptr);
        return *(gocpp::array<uintptr_t, 2>*)(v.ptr);
    }

    // IsNil reports whether its argument v is nil. The argument must be
    // a chan, func, interface, map, pointer, or slice value; if it is
    // not, IsNil panics. Note that IsNil is not always equivalent to a
    // regular comparison with nil in Go. For example, if v was created
    // by calling ValueOf with an uninitialized interface variable i,
    // i==nil will be true but v.IsNil will panic as v will be the zero
    // Value.
    bool rec::IsNil(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Chan) { conditionId = 0; }
            else if(condition == Func) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == Pointer) { conditionId = 3; }
            else if(condition == UnsafePointer) { conditionId = 4; }
            else if(condition == Interface) { conditionId = 5; }
            else if(condition == Slice) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    if(v.flag & flagMethod != 0)
                    {
                        return false;
                    }
                    auto ptr = v.ptr;
                    if(v.flag & flagIndir != 0)
                    {
                        ptr = *(unsafe::Pointer*)(ptr);
                    }
                    return ptr == nullptr;
                    break;
                case 5:
                case 6:
                    return *(unsafe::Pointer*)(v.ptr) == nullptr;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.IsNil"s, rec::kind(gocpp::recv(v))});
    }

    // IsValid reports whether v represents a value.
    // It returns false if v is the zero Value.
    // If IsValid returns false, all other methods except String panic.
    // Most functions and methods never return an invalid Value.
    // If one does, its documentation states the conditions explicitly.
    bool rec::IsValid(struct Value v)
    {
        return v.flag != 0;
    }

    // IsZero reports whether v is the zero value for its type.
    // It panics if the argument is invalid.
    bool rec::IsZero(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            else if(condition == Int) { conditionId = 1; }
            else if(condition == Int8) { conditionId = 2; }
            else if(condition == Int16) { conditionId = 3; }
            else if(condition == Int32) { conditionId = 4; }
            else if(condition == Int64) { conditionId = 5; }
            else if(condition == Uint) { conditionId = 6; }
            else if(condition == Uint8) { conditionId = 7; }
            else if(condition == Uint16) { conditionId = 8; }
            else if(condition == Uint32) { conditionId = 9; }
            else if(condition == Uint64) { conditionId = 10; }
            else if(condition == Uintptr) { conditionId = 11; }
            else if(condition == Float32) { conditionId = 12; }
            else if(condition == Float64) { conditionId = 13; }
            else if(condition == Complex64) { conditionId = 14; }
            else if(condition == Complex128) { conditionId = 15; }
            else if(condition == Array) { conditionId = 16; }
            else if(condition == Chan) { conditionId = 17; }
            else if(condition == Func) { conditionId = 18; }
            else if(condition == Interface) { conditionId = 19; }
            else if(condition == Map) { conditionId = 20; }
            else if(condition == Pointer) { conditionId = 21; }
            else if(condition == Slice) { conditionId = 22; }
            else if(condition == UnsafePointer) { conditionId = 23; }
            else if(condition == String) { conditionId = 24; }
            else if(condition == Struct) { conditionId = 25; }
            switch(conditionId)
            {
                case 0:
                    return ! rec::Bool(gocpp::recv(v));
                    break;
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    return rec::Int(gocpp::recv(v)) == 0;
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    return rec::Uint(gocpp::recv(v)) == 0;
                    break;
                case 12:
                case 13:
                    return rec::Float(gocpp::recv(v)) == 0;
                    break;
                case 14:
                case 15:
                    return rec::Complex(gocpp::recv(v)) == 0;
                    break;
                case 16:
                    if(v.flag & flagIndir == 0)
                    {
                        return v.ptr == nullptr;
                    }
                    auto typ = (abi::ArrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    if(typ->Equal != nullptr && rec::Size(gocpp::recv(typ)) <= abi::ZeroValSize)
                    {
                        return rec::Equal(gocpp::recv(typ), noescape(v.ptr), unsafe::Pointer(& zeroVal[0]));
                    }
                    if(typ->TFlag & abi::TFlagRegularMemory != 0)
                    {
                        return isZero(unsafe::Slice(((unsigned char*)(v.ptr)), rec::Size(gocpp::recv(typ))));
                    }
                    auto n = int(typ->Len);
                    for(auto i = 0; i < n; i++)
                    {
                        if(! rec::IsZero(gocpp::recv(rec::Index(gocpp::recv(v), i))))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                    return rec::IsNil(gocpp::recv(v));
                    break;
                case 24:
                    return rec::Len(gocpp::recv(v)) == 0;
                    break;
                case 25:
                    if(v.flag & flagIndir == 0)
                    {
                        return v.ptr == nullptr;
                    }
                    auto typ = (abi::StructType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    if(typ->Equal != nullptr && rec::Size(gocpp::recv(typ)) <= abi::ZeroValSize)
                    {
                        return rec::Equal(gocpp::recv(typ), noescape(v.ptr), unsafe::Pointer(& zeroVal[0]));
                    }
                    if(typ->TFlag & abi::TFlagRegularMemory != 0)
                    {
                        return isZero(unsafe::Slice(((unsigned char*)(v.ptr)), rec::Size(gocpp::recv(typ))));
                    }
                    auto n = rec::NumField(gocpp::recv(v));
                    for(auto i = 0; i < n; i++)
                    {
                        if(! rec::IsZero(gocpp::recv(rec::Field(gocpp::recv(v), i))) && rec::Field(gocpp::recv(rec::Type(gocpp::recv(v))), i).Name != "_"s)
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                default:
                    gocpp::panic(new ValueError {"reflect.Value.IsZero"s, rec::Kind(gocpp::recv(v))});
                    break;
            }
        }
    }

    // isZero For all zeros, performance is not as good as
    // return bytealg.Count(b, byte(0)) == len(b)
    bool isZero(gocpp::slice<unsigned char> b)
    {
        if(len(b) == 0)
        {
            return true;
        }
        auto n = 32;
        for(; uintptr_t(unsafe::Pointer(& b[0])) % 8 != 0; )
        {
            if(b[0] != 0)
            {
                return false;
            }
            b = b.make_slice(1);
            if(len(b) == 0)
            {
                return true;
            }
        }
        for(; len(b) % 8 != 0; )
        {
            if(b[len(b) - 1] != 0)
            {
                return false;
            }
            b = b.make_slice(0, len(b) - 1);
        }
        if(len(b) == 0)
        {
            return true;
        }
        auto w = unsafe::Slice((uint64_t*)(unsafe::Pointer(& b[0])), len(b) / 8);
        for(; len(w) % n != 0; )
        {
            if(w[0] != 0)
            {
                return false;
            }
            w = w.make_slice(1);
        }
        for(; len(w) >= n; )
        {
            if(w[0] != 0 || w[1] != 0 || w[2] != 0 || w[3] != 0 || w[4] != 0 || w[5] != 0 || w[6] != 0 || w[7] != 0 || w[8] != 0 || w[9] != 0 || w[10] != 0 || w[11] != 0 || w[12] != 0 || w[13] != 0 || w[14] != 0 || w[15] != 0 || w[16] != 0 || w[17] != 0 || w[18] != 0 || w[19] != 0 || w[20] != 0 || w[21] != 0 || w[22] != 0 || w[23] != 0 || w[24] != 0 || w[25] != 0 || w[26] != 0 || w[27] != 0 || w[28] != 0 || w[29] != 0 || w[30] != 0 || w[31] != 0)
            {
                return false;
            }
            w = w.make_slice(n);
        }
        return true;
    }

    // SetZero sets v to be the zero value of v's type.
    // It panics if [Value.CanSet] returns false.
    void rec::SetZero(struct Value v)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            else if(condition == Int) { conditionId = 1; }
            else if(condition == Int8) { conditionId = 2; }
            else if(condition == Int16) { conditionId = 3; }
            else if(condition == Int32) { conditionId = 4; }
            else if(condition == Int64) { conditionId = 5; }
            else if(condition == Uint) { conditionId = 6; }
            else if(condition == Uint8) { conditionId = 7; }
            else if(condition == Uint16) { conditionId = 8; }
            else if(condition == Uint32) { conditionId = 9; }
            else if(condition == Uint64) { conditionId = 10; }
            else if(condition == Uintptr) { conditionId = 11; }
            else if(condition == Float32) { conditionId = 12; }
            else if(condition == Float64) { conditionId = 13; }
            else if(condition == Complex64) { conditionId = 14; }
            else if(condition == Complex128) { conditionId = 15; }
            else if(condition == String) { conditionId = 16; }
            else if(condition == Slice) { conditionId = 17; }
            else if(condition == Interface) { conditionId = 18; }
            else if(condition == Chan) { conditionId = 19; }
            else if(condition == Func) { conditionId = 20; }
            else if(condition == Map) { conditionId = 21; }
            else if(condition == Pointer) { conditionId = 22; }
            else if(condition == UnsafePointer) { conditionId = 23; }
            else if(condition == Array) { conditionId = 24; }
            else if(condition == Struct) { conditionId = 25; }
            switch(conditionId)
            {
                case 0:
                    *(bool*)(v.ptr) = false;
                    break;
                case 1:
                    *(int*)(v.ptr) = 0;
                    break;
                case 2:
                    *(int8_t*)(v.ptr) = 0;
                    break;
                case 3:
                    *(int16_t*)(v.ptr) = 0;
                    break;
                case 4:
                    *(int32_t*)(v.ptr) = 0;
                    break;
                case 5:
                    *(int64_t*)(v.ptr) = 0;
                    break;
                case 6:
                    *(unsigned int*)(v.ptr) = 0;
                    break;
                case 7:
                    *(uint8_t*)(v.ptr) = 0;
                    break;
                case 8:
                    *(uint16_t*)(v.ptr) = 0;
                    break;
                case 9:
                    *(uint32_t*)(v.ptr) = 0;
                    break;
                case 10:
                    *(uint64_t*)(v.ptr) = 0;
                    break;
                case 11:
                    *(uintptr_t*)(v.ptr) = 0;
                    break;
                case 12:
                    *(float*)(v.ptr) = 0;
                    break;
                case 13:
                    *(double*)(v.ptr) = 0;
                    break;
                case 14:
                    *(gocpp::complex64*)(v.ptr) = 0;
                    break;
                case 15:
                    *(gocpp::complex128*)(v.ptr) = 0;
                    break;
                case 16:
                    *(std::string*)(v.ptr) = ""s;
                    break;
                case 17:
                    *(unsafeheader::Slice*)(v.ptr) = unsafeheader::Slice {};
                    break;
                case 18:
                    *(emptyInterface*)(v.ptr) = emptyInterface {};
                    break;
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                    *(unsafe::Pointer*)(v.ptr) = nullptr;
                    break;
                case 24:
                case 25:
                    typedmemclr(rec::typ(gocpp::recv(v)), v.ptr);
                    break;
                default:
                    gocpp::panic(new ValueError {"reflect.Value.SetZero"s, rec::Kind(gocpp::recv(v))});
                    break;
            }
        }
    }

    // Kind returns v's Kind.
    // If v is the zero Value ([Value.IsValid] returns false), Kind returns Invalid.
    reflect::Kind rec::Kind(struct Value v)
    {
        return rec::kind(gocpp::recv(v));
    }

    // Len returns v's length.
    // It panics if v's Kind is not [Array], [Chan], [Map], [Slice], [String], or pointer to [Array].
    int rec::Len(struct Value v)
    {
        if(rec::kind(gocpp::recv(v)) == Slice)
        {
            return (unsafeheader::Slice*)(v.ptr)->Len;
        }
        return rec::lenNonSlice(gocpp::recv(v));
    }

    int rec::lenNonSlice(struct Value v)
    {
        //Go switch emulation
        {
            auto k = rec::kind(gocpp::recv(v));
            auto condition = k;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == String) { conditionId = 3; }
            else if(condition == Ptr) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    return int(tt->Len);
                    break;
                case 1:
                    return chanlen(rec::pointer(gocpp::recv(v)));
                    break;
                case 2:
                    return maplen(rec::pointer(gocpp::recv(v)));
                    break;
                case 3:
                    return (unsafeheader::String*)(v.ptr)->Len;
                    break;
                case 4:
                    if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) == abi::Array)
                    {
                        return rec::Len(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v))))));
                    }
                    gocpp::panic("reflect: call of reflect.Value.Len on ptr to non-array Value"s);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Len"s, rec::kind(gocpp::recv(v))});
    }

    abi::Type* stringType = rtypeOf(""s);
    // MapIndex returns the value associated with key in the map v.
    // It panics if v's Kind is not [Map].
    // It returns the zero Value if key is not found in the map or if v represents a nil map.
    // As in Go, the key's value must be assignable to the map's key type.
    struct Value rec::MapIndex(struct Value v, struct Value key)
    {
        rec::mustBe(gocpp::recv(v), Map);
        auto tt = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        unsafe::Pointer e = {};
        if((tt->Key == stringType || rec::kind(gocpp::recv(key)) == String) && tt->Key == rec::typ(gocpp::recv(key)) && rec::Size(gocpp::recv(tt->Elem)) <= maxValSize)
        {
            auto k = *(std::string*)(key.ptr);
            e = mapaccess_faststr(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)), k);
        }
        else
        {
            key = rec::assignTo(gocpp::recv(key), "reflect.Value.MapIndex"s, tt->Key, nullptr);
            unsafe::Pointer k = {};
            if(key.flag & flagIndir != 0)
            {
                k = key.ptr;
            }
            else
            {
                k = unsafe::Pointer(& key.ptr);
            }
            e = mapaccess(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)), k);
        }
        if(e == nullptr)
        {
            return Value {};
        }
        auto typ = tt->Elem;
        auto fl = rec::ro(gocpp::recv((v.flag | key.flag)));
        fl |= flag(rec::Kind(gocpp::recv(typ)));
        return copyVal(typ, fl, e);
    }

    // MapKeys returns a slice containing all the keys present in the map,
    // in unspecified order.
    // It panics if v's Kind is not [Map].
    // It returns an empty slice if v represents a nil map.
    gocpp::slice<Value> rec::MapKeys(struct Value v)
    {
        rec::mustBe(gocpp::recv(v), Map);
        auto tt = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        auto keyType = tt->Key;
        auto fl = rec::ro(gocpp::recv(v.flag)) | flag(rec::Kind(gocpp::recv(keyType)));
        auto m = rec::pointer(gocpp::recv(v));
        auto mlen = int(0);
        if(m != nullptr)
        {
            mlen = maplen(m);
        }
        hiter it = {};
        mapiterinit(rec::typ(gocpp::recv(v)), m, & it);
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<Value>>(), mlen);
        int i = {};
        for(i = 0; i < len(a); i++)
        {
            auto key = mapiterkey(& it);
            if(key == nullptr)
            {
                break;
            }
            a[i] = copyVal(keyType, fl, key);
            mapiternext(& it);
        }
        return a.make_slice(0, i);
    }

    // hiter's structure matches runtime.hiter's structure.
    // Having a clone here allows us to embed a map iterator
    // inside type MapIter so that MapIters can be re-used
    // without doing any allocations.
    
    template<typename T> requires gocpp::GoStruct<T>
    hiter::operator T()
    {
        T result;
        result.key = this->key;
        result.elem = this->elem;
        result.t = this->t;
        result.h = this->h;
        result.buckets = this->buckets;
        result.bptr = this->bptr;
        result.overflow = this->overflow;
        result.oldoverflow = this->oldoverflow;
        result.startBucket = this->startBucket;
        result.offset = this->offset;
        result.wrapped = this->wrapped;
        result.B = this->B;
        result.i = this->i;
        result.bucket = this->bucket;
        result.checkBucket = this->checkBucket;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool hiter::operator==(const T& ref) const
    {
        if (key != ref.key) return false;
        if (elem != ref.elem) return false;
        if (t != ref.t) return false;
        if (h != ref.h) return false;
        if (buckets != ref.buckets) return false;
        if (bptr != ref.bptr) return false;
        if (overflow != ref.overflow) return false;
        if (oldoverflow != ref.oldoverflow) return false;
        if (startBucket != ref.startBucket) return false;
        if (offset != ref.offset) return false;
        if (wrapped != ref.wrapped) return false;
        if (B != ref.B) return false;
        if (i != ref.i) return false;
        if (bucket != ref.bucket) return false;
        if (checkBucket != ref.checkBucket) return false;
        return true;
    }

    std::ostream& hiter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << key;
        os << " " << elem;
        os << " " << t;
        os << " " << h;
        os << " " << buckets;
        os << " " << bptr;
        os << " " << overflow;
        os << " " << oldoverflow;
        os << " " << startBucket;
        os << " " << offset;
        os << " " << wrapped;
        os << " " << B;
        os << " " << i;
        os << " " << bucket;
        os << " " << checkBucket;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct hiter& value)
    {
        return value.PrintTo(os);
    }

    bool rec::initialized(struct hiter* h)
    {
        return h->t != nullptr;
    }

    // A MapIter is an iterator for ranging over a map.
    // See [Value.MapRange].
    
    template<typename T> requires gocpp::GoStruct<T>
    MapIter::operator T()
    {
        T result;
        result.m = this->m;
        result.hiter = this->hiter;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool MapIter::operator==(const T& ref) const
    {
        if (m != ref.m) return false;
        if (hiter != ref.hiter) return false;
        return true;
    }

    std::ostream& MapIter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << m;
        os << " " << hiter;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct MapIter& value)
    {
        return value.PrintTo(os);
    }

    // Key returns the key of iter's current map entry.
    struct Value rec::Key(struct MapIter* iter)
    {
        if(! rec::initialized(gocpp::recv(iter->hiter)))
        {
            gocpp::panic("MapIter.Key called before Next"s);
        }
        auto iterkey = mapiterkey(& iter->hiter);
        if(iterkey == nullptr)
        {
            gocpp::panic("MapIter.Key called on exhausted iterator"s);
        }
        auto t = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(iter->m))));
        auto ktype = t->Key;
        return copyVal(ktype, rec::ro(gocpp::recv(iter->m.flag)) | flag(rec::Kind(gocpp::recv(ktype))), iterkey);
    }

    // SetIterKey assigns to v the key of iter's current map entry.
    // It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.
    // As in Go, the key must be assignable to v's type and
    // must not be derived from an unexported field.
    void rec::SetIterKey(struct Value v, struct MapIter* iter)
    {
        if(! rec::initialized(gocpp::recv(iter->hiter)))
        {
            gocpp::panic("reflect: Value.SetIterKey called before Next"s);
        }
        auto iterkey = mapiterkey(& iter->hiter);
        if(iterkey == nullptr)
        {
            gocpp::panic("reflect: Value.SetIterKey called on exhausted iterator"s);
        }
        rec::mustBeAssignable(gocpp::recv(v));
        unsafe::Pointer target = {};
        if(rec::kind(gocpp::recv(v)) == Interface)
        {
            target = v.ptr;
        }
        auto t = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(iter->m))));
        auto ktype = t->Key;
        rec::mustBeExported(gocpp::recv(iter->m));
        auto key = Value {ktype, iterkey, iter->m.flag | flag(rec::Kind(gocpp::recv(ktype))) | flagIndir};
        key = rec::assignTo(gocpp::recv(key), "reflect.MapIter.SetKey"s, rec::typ(gocpp::recv(v)), target);
        typedmemmove(rec::typ(gocpp::recv(v)), v.ptr, key.ptr);
    }

    // Value returns the value of iter's current map entry.
    struct Value rec::Value(struct MapIter* iter)
    {
        if(! rec::initialized(gocpp::recv(iter->hiter)))
        {
            gocpp::panic("MapIter.Value called before Next"s);
        }
        auto iterelem = mapiterelem(& iter->hiter);
        if(iterelem == nullptr)
        {
            gocpp::panic("MapIter.Value called on exhausted iterator"s);
        }
        auto t = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(iter->m))));
        auto vtype = t->Elem;
        return copyVal(vtype, rec::ro(gocpp::recv(iter->m.flag)) | flag(rec::Kind(gocpp::recv(vtype))), iterelem);
    }

    // SetIterValue assigns to v the value of iter's current map entry.
    // It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.
    // As in Go, the value must be assignable to v's type and
    // must not be derived from an unexported field.
    void rec::SetIterValue(struct Value v, struct MapIter* iter)
    {
        if(! rec::initialized(gocpp::recv(iter->hiter)))
        {
            gocpp::panic("reflect: Value.SetIterValue called before Next"s);
        }
        auto iterelem = mapiterelem(& iter->hiter);
        if(iterelem == nullptr)
        {
            gocpp::panic("reflect: Value.SetIterValue called on exhausted iterator"s);
        }
        rec::mustBeAssignable(gocpp::recv(v));
        unsafe::Pointer target = {};
        if(rec::kind(gocpp::recv(v)) == Interface)
        {
            target = v.ptr;
        }
        auto t = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(iter->m))));
        auto vtype = t->Elem;
        rec::mustBeExported(gocpp::recv(iter->m));
        auto elem = Value {vtype, iterelem, iter->m.flag | flag(rec::Kind(gocpp::recv(vtype))) | flagIndir};
        elem = rec::assignTo(gocpp::recv(elem), "reflect.MapIter.SetValue"s, rec::typ(gocpp::recv(v)), target);
        typedmemmove(rec::typ(gocpp::recv(v)), v.ptr, elem.ptr);
    }

    // Next advances the map iterator and reports whether there is another
    // entry. It returns false when iter is exhausted; subsequent
    // calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic.
    bool rec::Next(struct MapIter* iter)
    {
        if(! rec::IsValid(gocpp::recv(iter->m)))
        {
            gocpp::panic("MapIter.Next called on an iterator that does not have an associated map Value"s);
        }
        if(! rec::initialized(gocpp::recv(iter->hiter)))
        {
            mapiterinit(rec::typ(gocpp::recv(iter->m)), rec::pointer(gocpp::recv(iter->m)), & iter->hiter);
        }
        else
        {
            if(mapiterkey(& iter->hiter) == nullptr)
            {
                gocpp::panic("MapIter.Next called on exhausted iterator"s);
            }
            mapiternext(& iter->hiter);
        }
        return mapiterkey(& iter->hiter) != nullptr;
    }

    // Reset modifies iter to iterate over v.
    // It panics if v's Kind is not [Map] and v is not the zero Value.
    // Reset(Value{}) causes iter to not to refer to any map,
    // which may allow the previously iterated-over map to be garbage collected.
    void rec::Reset(struct MapIter* iter, struct Value v)
    {
        if(rec::IsValid(gocpp::recv(v)))
        {
            rec::mustBe(gocpp::recv(v), Map);
        }
        iter->m = v;
        iter->hiter = hiter {};
    }

    // MapRange returns a range iterator for a map.
    // It panics if v's Kind is not [Map].
    //
    // Call [MapIter.Next] to advance the iterator, and [MapIter.Key]/[MapIter.Value] to access each entry.
    // [MapIter.Next] returns false when the iterator is exhausted.
    // MapRange follows the same iteration semantics as a range statement.
    //
    // Example:
    //
    //	iter := reflect.ValueOf(m).MapRange()
    //	for iter.Next() {
    //		k := iter.Key()
    //		v := iter.Value()
    //		...
    //	}
    struct MapIter* rec::MapRange(struct Value v)
    {
        if(rec::kind(gocpp::recv(v)) != Map)
        {
            rec::panicNotMap(gocpp::recv(v));
        }
        return gocpp::InitPtr<MapIter>([=](auto& x) {
            x.m = v;
        });
    }

    // Force slow panicking path not inlined, so it won't add to the
    // inlining budget of the caller.
    // TODO: undo when the inliner is no longer bottom-up only.
    //
    //go:noinline
    void rec::panicNotMap(golang::reflect::flag f)
    {
        rec::mustBe(gocpp::recv(f), Map);
    }

    // copyVal returns a Value containing the map key or value at ptr,
    // allocating a new variable as needed.
    struct Value copyVal(abi::Type* typ, golang::reflect::flag fl, unsafe::Pointer ptr)
    {
        if(rec::IfaceIndir(gocpp::recv(typ)))
        {
            auto c = unsafe_New(typ);
            typedmemmove(typ, c, ptr);
            return Value {typ, c, fl | flagIndir};
        }
        return Value {typ, *(unsafe::Pointer*)(ptr), fl};
    }

    // Method returns a function value corresponding to v's i'th method.
    // The arguments to a Call on the returned function should not include
    // a receiver; the returned function will always use v as the receiver.
    // Method panics if i is out of range or if v is a nil interface value.
    struct Value rec::Method(struct Value v, int i)
    {
        if(rec::typ(gocpp::recv(v)) == nullptr)
        {
            gocpp::panic(new ValueError {"reflect.Value.Method"s, Invalid});
        }
        if(v.flag & flagMethod != 0 || (unsigned int)(i) >= (unsigned int)(rec::NumMethod(gocpp::recv(toRType(rec::typ(gocpp::recv(v)))))))
        {
            gocpp::panic("reflect: Method index out of range"s);
        }
        if(rec::Kind(gocpp::recv(rec::typ(gocpp::recv(v)))) == abi::Interface && rec::IsNil(gocpp::recv(v)))
        {
            gocpp::panic("reflect: Method on nil interface value"s);
        }
        auto fl = rec::ro(gocpp::recv(v.flag)) | (v.flag & flagIndir);
        fl |= flag(Func);
        fl |= (flag(i) << flagMethodShift) | flagMethod;
        return Value {rec::typ(gocpp::recv(v)), v.ptr, fl};
    }

    // NumMethod returns the number of methods in the value's method set.
    //
    // For a non-interface type, it returns the number of exported methods.
    //
    // For an interface type, it returns the number of exported and unexported methods.
    int rec::NumMethod(struct Value v)
    {
        if(rec::typ(gocpp::recv(v)) == nullptr)
        {
            gocpp::panic(new ValueError {"reflect.Value.NumMethod"s, Invalid});
        }
        if(v.flag & flagMethod != 0)
        {
            return 0;
        }
        return rec::NumMethod(gocpp::recv(toRType(rec::typ(gocpp::recv(v)))));
    }

    // MethodByName returns a function value corresponding to the method
    // of v with the given name.
    // The arguments to a Call on the returned function should not include
    // a receiver; the returned function will always use v as the receiver.
    // It returns the zero Value if no method was found.
    struct Value rec::MethodByName(struct Value v, std::string name)
    {
        if(rec::typ(gocpp::recv(v)) == nullptr)
        {
            gocpp::panic(new ValueError {"reflect.Value.MethodByName"s, Invalid});
        }
        if(v.flag & flagMethod != 0)
        {
            return Value {};
        }
        auto [m, ok] = rec::MethodByName(gocpp::recv(toRType(rec::typ(gocpp::recv(v)))), name);
        if(! ok)
        {
            return Value {};
        }
        return rec::Method(gocpp::recv(v), m.Index);
    }

    // NumField returns the number of fields in the struct v.
    // It panics if v's Kind is not [Struct].
    int rec::NumField(struct Value v)
    {
        rec::mustBe(gocpp::recv(v), Struct);
        auto tt = (structType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        return len(tt->Fields);
    }

    // OverflowComplex reports whether the complex128 x cannot be represented by v's type.
    // It panics if v's Kind is not [Complex64] or [Complex128].
    bool rec::OverflowComplex(struct Value v, struct gocpp::complex128 x)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Complex64) { conditionId = 0; }
            else if(condition == Complex128) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return overflowFloat32(real(x)) || overflowFloat32(imag(x));
                    break;
                case 1:
                    return false;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.OverflowComplex"s, rec::kind(gocpp::recv(v))});
    }

    // OverflowFloat reports whether the float64 x cannot be represented by v's type.
    // It panics if v's Kind is not [Float32] or [Float64].
    bool rec::OverflowFloat(struct Value v, double x)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Float32) { conditionId = 0; }
            else if(condition == Float64) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return overflowFloat32(x);
                    break;
                case 1:
                    return false;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.OverflowFloat"s, rec::kind(gocpp::recv(v))});
    }

    bool overflowFloat32(double x)
    {
        if(x < 0)
        {
            x = - x;
        }
        return math::MaxFloat32 < x && x <= math::MaxFloat64;
    }

    // OverflowInt reports whether the int64 x cannot be represented by v's type.
    // It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64].
    bool rec::OverflowInt(struct Value v, int64_t x)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Int) { conditionId = 0; }
            else if(condition == Int8) { conditionId = 1; }
            else if(condition == Int16) { conditionId = 2; }
            else if(condition == Int32) { conditionId = 3; }
            else if(condition == Int64) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    auto bitSize = rec::Size(gocpp::recv(rec::typ(gocpp::recv(v)))) * 8;
                    auto trunc = (x << (64 - bitSize)) >> (64 - bitSize);
                    return x != trunc;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.OverflowInt"s, rec::kind(gocpp::recv(v))});
    }

    // OverflowUint reports whether the uint64 x cannot be represented by v's type.
    // It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64].
    bool rec::OverflowUint(struct Value v, uint64_t x)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Uint) { conditionId = 0; }
            else if(condition == Uintptr) { conditionId = 1; }
            else if(condition == Uint8) { conditionId = 2; }
            else if(condition == Uint16) { conditionId = 3; }
            else if(condition == Uint32) { conditionId = 4; }
            else if(condition == Uint64) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    auto bitSize = rec::Size(gocpp::recv(v.typ_)) * 8;
                    auto trunc = (x << (64 - bitSize)) >> (64 - bitSize);
                    return x != trunc;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.OverflowUint"s, rec::kind(gocpp::recv(v))});
    }

    // Pointer returns v's value as a uintptr.
    // It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], or [UnsafePointer].
    //
    // If v's Kind is [Func], the returned pointer is an underlying
    // code pointer, but not necessarily enough to identify a
    // single function uniquely. The only guarantee is that the
    // result is zero if and only if v is a nil func Value.
    //
    // If v's Kind is [Slice], the returned pointer is to the first
    // element of the slice. If the slice is nil the returned value
    // is 0.  If the slice is empty but non-nil the return value is non-zero.
    //
    // It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result.
    uintptr_t rec::Pointer(struct Value v)
    {
        escapes(v.ptr);
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Pointer) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == UnsafePointer) { conditionId = 3; }
            else if(condition == Func) { conditionId = 4; }
            else if(condition == Slice) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                    if(rec::typ(gocpp::recv(v))->PtrBytes == 0)
                    {
                        auto val = *(uintptr_t*)(v.ptr);
                        if(! verifyNotInHeapPtr(val))
                        {
                            gocpp::panic("reflect: reflect.Value.Pointer on an invalid notinheap pointer"s);
                        }
                        return val;
                    }
                case 1:
                case 2:
                case 3:
                    return uintptr_t(rec::pointer(gocpp::recv(v)));
                    break;
                case 4:
                    if(v.flag & flagMethod != 0)
                    {
                        return methodValueCallCodePtr();
                    }
                    auto p = rec::pointer(gocpp::recv(v));
                    if(p != nullptr)
                    {
                        p = *(unsafe::Pointer*)(p);
                    }
                    return uintptr_t(p);
                    break;
                case 5:
                    return uintptr_t((unsafeheader::Slice*)(v.ptr)->Data);
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Pointer"s, rec::kind(gocpp::recv(v))});
    }

    // Recv receives and returns a value from the channel v.
    // It panics if v's Kind is not [Chan].
    // The receive blocks until a value is ready.
    // The boolean value ok is true if the value x corresponds to a send
    // on the channel, false if it is a zero value received because the channel is closed.
    std::tuple<struct Value, bool> rec::Recv(struct Value v)
    {
        struct Value x;
        bool ok;
        rec::mustBe(gocpp::recv(v), Chan);
        rec::mustBeExported(gocpp::recv(v));
        return rec::recv(gocpp::recv(v), false);
    }

    // internal recv, possibly non-blocking (nb).
    // v is known to be a channel.
    std::tuple<struct Value, bool> rec::recv(struct Value v, bool nb)
    {
        struct Value val;
        bool ok;
        auto tt = (reflect::chanType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        if(ChanDir(tt->Dir) & RecvDir == 0)
        {
            gocpp::panic("reflect: recv on send-only channel"s);
        }
        auto t = tt->Elem;
        val = Value {t, nullptr, flag(rec::Kind(gocpp::recv(t)))};
        unsafe::Pointer p = {};
        if(ifaceIndir(t))
        {
            p = unsafe_New(t);
            val.ptr = p;
            val.flag |= flagIndir;
        }
        else
        {
            p = unsafe::Pointer(& val.ptr);
        }
        auto [selected, ok] = chanrecv(rec::pointer(gocpp::recv(v)), nb, p);
        if(! selected)
        {
            val = Value {};
        }
        return {val, ok};
    }

    // Send sends x on the channel v.
    // It panics if v's kind is not [Chan] or if x's type is not the same type as v's element type.
    // As in Go, x's value must be assignable to the channel's element type.
    void rec::Send(struct Value v, struct Value x)
    {
        rec::mustBe(gocpp::recv(v), Chan);
        rec::mustBeExported(gocpp::recv(v));
        rec::send(gocpp::recv(v), x, false);
    }

    // internal send, possibly non-blocking.
    // v is known to be a channel.
    bool rec::send(struct Value v, struct Value x, bool nb)
    {
        bool selected;
        auto tt = (reflect::chanType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        if(ChanDir(tt->Dir) & SendDir == 0)
        {
            gocpp::panic("reflect: send on recv-only channel"s);
        }
        rec::mustBeExported(gocpp::recv(x));
        x = rec::assignTo(gocpp::recv(x), "reflect.Value.Send"s, tt->Elem, nullptr);
        unsafe::Pointer p = {};
        if(x.flag & flagIndir != 0)
        {
            p = x.ptr;
        }
        else
        {
            p = unsafe::Pointer(& x.ptr);
        }
        return chansend(rec::pointer(gocpp::recv(v)), p, nb);
    }

    // Set assigns x to the value v.
    // It panics if [Value.CanSet] returns false.
    // As in Go, x's value must be assignable to v's type and
    // must not be derived from an unexported field.
    void rec::Set(struct Value v, struct Value x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBeExported(gocpp::recv(x));
        unsafe::Pointer target = {};
        if(rec::kind(gocpp::recv(v)) == Interface)
        {
            target = v.ptr;
        }
        x = rec::assignTo(gocpp::recv(x), "reflect.Set"s, rec::typ(gocpp::recv(v)), target);
        if(x.flag & flagIndir != 0)
        {
            if(x.ptr == unsafe::Pointer(& zeroVal[0]))
            {
                typedmemclr(rec::typ(gocpp::recv(v)), v.ptr);
            }
            else
            {
                typedmemmove(rec::typ(gocpp::recv(v)), v.ptr, x.ptr);
            }
        }
        else
        {
            *(unsafe::Pointer*)(v.ptr) = x.ptr;
        }
    }

    // SetBool sets v's underlying value.
    // It panics if v's Kind is not [Bool] or if [Value.CanSet] returns false.
    void rec::SetBool(struct Value v, bool x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Bool);
        *(bool*)(v.ptr) = x;
    }

    // SetBytes sets v's underlying value.
    // It panics if v's underlying value is not a slice of bytes.
    void rec::SetBytes(struct Value v, gocpp::slice<unsigned char> x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Slice);
        if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(toRType(rec::typ(gocpp::recv(v))))))) != Uint8)
        {
            gocpp::panic("reflect.Value.SetBytes of non-byte slice"s);
        }
        *(gocpp::slice<unsigned char>*)(v.ptr) = x;
    }

    // setRunes sets v's underlying value.
    // It panics if v's underlying value is not a slice of runes (int32s).
    void rec::setRunes(struct Value v, gocpp::slice<gocpp::rune> x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Slice);
        if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v)))))) != abi::Int32)
        {
            gocpp::panic("reflect.Value.setRunes of non-rune slice"s);
        }
        *(gocpp::slice<gocpp::rune>*)(v.ptr) = x;
    }

    // SetComplex sets v's underlying value to x.
    // It panics if v's Kind is not [Complex64] or [Complex128], or if [Value.CanSet] returns false.
    void rec::SetComplex(struct Value v, struct gocpp::complex128 x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        //Go switch emulation
        {
            auto k = rec::kind(gocpp::recv(v));
            auto condition = k;
            int conditionId = -1;
            if(condition == Complex64) { conditionId = 0; }
            else if(condition == Complex128) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    gocpp::panic(new ValueError {"reflect.Value.SetComplex"s, rec::kind(gocpp::recv(v))});
                    break;
                case 0:
                    *(gocpp::complex64*)(v.ptr) = gocpp::complex64(x);
                    break;
                case 1:
                    *(gocpp::complex128*)(v.ptr) = x;
                    break;
            }
        }
    }

    // SetFloat sets v's underlying value to x.
    // It panics if v's Kind is not [Float32] or [Float64], or if [Value.CanSet] returns false.
    void rec::SetFloat(struct Value v, double x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        //Go switch emulation
        {
            auto k = rec::kind(gocpp::recv(v));
            auto condition = k;
            int conditionId = -1;
            if(condition == Float32) { conditionId = 0; }
            else if(condition == Float64) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    gocpp::panic(new ValueError {"reflect.Value.SetFloat"s, rec::kind(gocpp::recv(v))});
                    break;
                case 0:
                    *(float*)(v.ptr) = float(x);
                    break;
                case 1:
                    *(double*)(v.ptr) = x;
                    break;
            }
        }
    }

    // SetInt sets v's underlying value to x.
    // It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64], or if [Value.CanSet] returns false.
    void rec::SetInt(struct Value v, int64_t x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        //Go switch emulation
        {
            auto k = rec::kind(gocpp::recv(v));
            auto condition = k;
            int conditionId = -1;
            if(condition == Int) { conditionId = 0; }
            else if(condition == Int8) { conditionId = 1; }
            else if(condition == Int16) { conditionId = 2; }
            else if(condition == Int32) { conditionId = 3; }
            else if(condition == Int64) { conditionId = 4; }
            switch(conditionId)
            {
                default:
                    gocpp::panic(new ValueError {"reflect.Value.SetInt"s, rec::kind(gocpp::recv(v))});
                    break;
                case 0:
                    *(int*)(v.ptr) = int(x);
                    break;
                case 1:
                    *(int8_t*)(v.ptr) = int8_t(x);
                    break;
                case 2:
                    *(int16_t*)(v.ptr) = int16_t(x);
                    break;
                case 3:
                    *(int32_t*)(v.ptr) = int32_t(x);
                    break;
                case 4:
                    *(int64_t*)(v.ptr) = x;
                    break;
            }
        }
    }

    // SetLen sets v's length to n.
    // It panics if v's Kind is not [Slice] or if n is negative or
    // greater than the capacity of the slice.
    void rec::SetLen(struct Value v, int n)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Slice);
        auto s = (unsafeheader::Slice*)(v.ptr);
        if((unsigned int)(n) > (unsigned int)(s->Cap))
        {
            gocpp::panic("reflect: slice length out of range in SetLen"s);
        }
        s->Len = n;
    }

    // SetCap sets v's capacity to n.
    // It panics if v's Kind is not [Slice] or if n is smaller than the length or
    // greater than the capacity of the slice.
    void rec::SetCap(struct Value v, int n)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Slice);
        auto s = (unsafeheader::Slice*)(v.ptr);
        if(n < s->Len || n > s->Cap)
        {
            gocpp::panic("reflect: slice capacity out of range in SetCap"s);
        }
        s->Cap = n;
    }

    // SetMapIndex sets the element associated with key in the map v to elem.
    // It panics if v's Kind is not [Map].
    // If elem is the zero Value, SetMapIndex deletes the key from the map.
    // Otherwise if v holds a nil map, SetMapIndex will panic.
    // As in Go, key's elem must be assignable to the map's key type,
    // and elem's value must be assignable to the map's elem type.
    void rec::SetMapIndex(struct Value v, struct Value key, struct Value elem)
    {
        rec::mustBe(gocpp::recv(v), Map);
        rec::mustBeExported(gocpp::recv(v));
        rec::mustBeExported(gocpp::recv(key));
        auto tt = (mapType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
        if((tt->Key == stringType || rec::kind(gocpp::recv(key)) == String) && tt->Key == rec::typ(gocpp::recv(key)) && rec::Size(gocpp::recv(tt->Elem)) <= maxValSize)
        {
            auto k = *(std::string*)(key.ptr);
            if(rec::typ(gocpp::recv(elem)) == nullptr)
            {
                mapdelete_faststr(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)), k);
                return;
            }
            rec::mustBeExported(gocpp::recv(elem));
            elem = rec::assignTo(gocpp::recv(elem), "reflect.Value.SetMapIndex"s, tt->Elem, nullptr);
            unsafe::Pointer e = {};
            if(elem.flag & flagIndir != 0)
            {
                e = elem.ptr;
            }
            else
            {
                e = unsafe::Pointer(& elem.ptr);
            }
            mapassign_faststr(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)), k, e);
            return;
        }
        key = rec::assignTo(gocpp::recv(key), "reflect.Value.SetMapIndex"s, tt->Key, nullptr);
        unsafe::Pointer k = {};
        if(key.flag & flagIndir != 0)
        {
            k = key.ptr;
        }
        else
        {
            k = unsafe::Pointer(& key.ptr);
        }
        if(rec::typ(gocpp::recv(elem)) == nullptr)
        {
            mapdelete(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)), k);
            return;
        }
        rec::mustBeExported(gocpp::recv(elem));
        elem = rec::assignTo(gocpp::recv(elem), "reflect.Value.SetMapIndex"s, tt->Elem, nullptr);
        unsafe::Pointer e = {};
        if(elem.flag & flagIndir != 0)
        {
            e = elem.ptr;
        }
        else
        {
            e = unsafe::Pointer(& elem.ptr);
        }
        mapassign(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)), k, e);
    }

    // SetUint sets v's underlying value to x.
    // It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64], or if [Value.CanSet] returns false.
    void rec::SetUint(struct Value v, uint64_t x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        //Go switch emulation
        {
            auto k = rec::kind(gocpp::recv(v));
            auto condition = k;
            int conditionId = -1;
            if(condition == Uint) { conditionId = 0; }
            else if(condition == Uint8) { conditionId = 1; }
            else if(condition == Uint16) { conditionId = 2; }
            else if(condition == Uint32) { conditionId = 3; }
            else if(condition == Uint64) { conditionId = 4; }
            else if(condition == Uintptr) { conditionId = 5; }
            switch(conditionId)
            {
                default:
                    gocpp::panic(new ValueError {"reflect.Value.SetUint"s, rec::kind(gocpp::recv(v))});
                    break;
                case 0:
                    *(unsigned int*)(v.ptr) = (unsigned int)(x);
                    break;
                case 1:
                    *(uint8_t*)(v.ptr) = uint8_t(x);
                    break;
                case 2:
                    *(uint16_t*)(v.ptr) = uint16_t(x);
                    break;
                case 3:
                    *(uint32_t*)(v.ptr) = uint32_t(x);
                    break;
                case 4:
                    *(uint64_t*)(v.ptr) = x;
                    break;
                case 5:
                    *(uintptr_t*)(v.ptr) = uintptr_t(x);
                    break;
            }
        }
    }

    // SetPointer sets the [unsafe.Pointer] value v to x.
    // It panics if v's Kind is not UnsafePointer.
    void rec::SetPointer(struct Value v, unsafe::Pointer x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), UnsafePointer);
        *(unsafe::Pointer*)(v.ptr) = x;
    }

    // SetString sets v's underlying value to x.
    // It panics if v's Kind is not [String] or if [Value.CanSet] returns false.
    void rec::SetString(struct Value v, std::string x)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), String);
        *(std::string*)(v.ptr) = x;
    }

    // Slice returns v[i:j].
    // It panics if v's Kind is not [Array], [Slice] or [String], or if v is an unaddressable array,
    // or if the indexes are out of bounds.
    struct Value rec::Slice(struct Value v, int i, int j)
    {
        int cap = {};
        sliceType* typ = {};
        unsafe::Pointer base = {};
        //Go switch emulation
        {
            auto kind = rec::kind(gocpp::recv(v));
            auto condition = kind;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Slice) { conditionId = 1; }
            else if(condition == String) { conditionId = 2; }
            switch(conditionId)
            {
                default:
                    gocpp::panic(new ValueError {"reflect.Value.Slice"s, rec::kind(gocpp::recv(v))});
                    break;
                case 0:
                    if(v.flag & flagAddr == 0)
                    {
                        gocpp::panic("reflect.Value.Slice: slice of unaddressable array"s);
                    }
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    cap = int(tt->Len);
                    typ = (sliceType*)(unsafe::Pointer(tt->Slice));
                    base = v.ptr;
                    break;
                case 1:
                    typ = (sliceType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    auto s = (unsafeheader::Slice*)(v.ptr);
                    base = s->Data;
                    cap = s->Cap;
                    break;
                case 2:
                    auto s = (unsafeheader::String*)(v.ptr);
                    if(i < 0 || j < i || j > s->Len)
                    {
                        gocpp::panic("reflect.Value.Slice: string slice index out of bounds"s);
                    }
                    unsafeheader::String t = {};
                    if(i < s->Len)
                    {
                        t = gocpp::Init<unsafeheader::String>([=](auto& x) {
                            x.Data = arrayAt(s->Data, i, 1, "i < s.Len"s);
                            x.Len = j - i;
                        });
                    }
                    return Value {rec::typ(gocpp::recv(v)), unsafe::Pointer(& t), v.flag};
                    break;
            }
        }
        if(i < 0 || j < i || j > cap)
        {
            gocpp::panic("reflect.Value.Slice: slice index out of bounds"s);
        }
        // Declare slice so that gc can see the base pointer in it.
        gocpp::slice<unsafe::Pointer> x = {};
        auto s = (unsafeheader::Slice*)(unsafe::Pointer(& x));
        s->Len = j - i;
        s->Cap = cap - i;
        if(cap - i > 0)
        {
            s->Data = arrayAt(base, i, rec::Size(gocpp::recv(typ->Elem)), "i < cap"s);
        }
        else
        {
            s->Data = base;
        }
        auto fl = rec::ro(gocpp::recv(v.flag)) | flagIndir | flag(Slice);
        return Value {rec::Common(gocpp::recv(typ)), unsafe::Pointer(& x), fl};
    }

    // Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
    // It panics if v's Kind is not [Array] or [Slice], or if v is an unaddressable array,
    // or if the indexes are out of bounds.
    struct Value rec::Slice3(struct Value v, int i, int j, int k)
    {
        int cap = {};
        sliceType* typ = {};
        unsafe::Pointer base = {};
        //Go switch emulation
        {
            auto kind = rec::kind(gocpp::recv(v));
            auto condition = kind;
            int conditionId = -1;
            if(condition == Array) { conditionId = 0; }
            else if(condition == Slice) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    gocpp::panic(new ValueError {"reflect.Value.Slice3"s, rec::kind(gocpp::recv(v))});
                    break;
                case 0:
                    if(v.flag & flagAddr == 0)
                    {
                        gocpp::panic("reflect.Value.Slice3: slice of unaddressable array"s);
                    }
                    auto tt = (reflect::arrayType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    cap = int(tt->Len);
                    typ = (sliceType*)(unsafe::Pointer(tt->Slice));
                    base = v.ptr;
                    break;
                case 1:
                    typ = (sliceType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    auto s = (unsafeheader::Slice*)(v.ptr);
                    base = s->Data;
                    cap = s->Cap;
                    break;
            }
        }
        if(i < 0 || j < i || k < j || k > cap)
        {
            gocpp::panic("reflect.Value.Slice3: slice index out of bounds"s);
        }
        // Declare slice so that the garbage collector
        // can see the base pointer in it.
        gocpp::slice<unsafe::Pointer> x = {};
        auto s = (unsafeheader::Slice*)(unsafe::Pointer(& x));
        s->Len = j - i;
        s->Cap = k - i;
        if(k - i > 0)
        {
            s->Data = arrayAt(base, i, rec::Size(gocpp::recv(typ->Elem)), "i < k <= cap"s);
        }
        else
        {
            s->Data = base;
        }
        auto fl = rec::ro(gocpp::recv(v.flag)) | flagIndir | flag(Slice);
        return Value {rec::Common(gocpp::recv(typ)), unsafe::Pointer(& x), fl};
    }

    // String returns the string v's underlying value, as a string.
    // String is a special case because of Go's String method convention.
    // Unlike the other getters, it does not panic if v's Kind is not [String].
    // Instead, it returns a string of the form "<T value>" where T is v's type.
    // The fmt package treats Values specially. It does not call their String
    // method implicitly but instead prints the concrete values they hold.
    std::string rec::String(struct Value v)
    {
        if(rec::kind(gocpp::recv(v)) == String)
        {
            return *(std::string*)(v.ptr);
        }
        return rec::stringNonString(gocpp::recv(v));
    }

    std::string rec::stringNonString(struct Value v)
    {
        if(rec::kind(gocpp::recv(v)) == Invalid)
        {
            return "<invalid Value>"s;
        }
        return "<"s + rec::String(gocpp::recv(rec::Type(gocpp::recv(v)))) + " Value>"s;
    }

    // TryRecv attempts to receive a value from the channel v but will not block.
    // It panics if v's Kind is not [Chan].
    // If the receive delivers a value, x is the transferred value and ok is true.
    // If the receive cannot finish without blocking, x is the zero Value and ok is false.
    // If the channel is closed, x is the zero value for the channel's element type and ok is false.
    std::tuple<struct Value, bool> rec::TryRecv(struct Value v)
    {
        struct Value x;
        bool ok;
        rec::mustBe(gocpp::recv(v), Chan);
        rec::mustBeExported(gocpp::recv(v));
        return rec::recv(gocpp::recv(v), true);
    }

    // TrySend attempts to send x on the channel v but will not block.
    // It panics if v's Kind is not [Chan].
    // It reports whether the value was sent.
    // As in Go, x's value must be assignable to the channel's element type.
    bool rec::TrySend(struct Value v, struct Value x)
    {
        rec::mustBe(gocpp::recv(v), Chan);
        rec::mustBeExported(gocpp::recv(v));
        return rec::send(gocpp::recv(v), x, true);
    }

    // Type returns v's type.
    struct Type rec::Type(struct Value v)
    {
        if(v.flag != 0 && v.flag & flagMethod == 0)
        {
            return (rtype*)(noescape(unsafe::Pointer(v.typ_)));
        }
        return rec::typeSlow(gocpp::recv(v));
    }

    struct Type rec::typeSlow(struct Value v)
    {
        if(v.flag == 0)
        {
            gocpp::panic(new ValueError {"reflect.Value.Type"s, Invalid});
        }
        auto typ = rec::typ(gocpp::recv(v));
        if(v.flag & flagMethod == 0)
        {
            return toRType(rec::typ(gocpp::recv(v)));
        }
        auto i = int(v.flag) >> flagMethodShift;
        if(rec::Kind(gocpp::recv(rec::typ(gocpp::recv(v)))) == abi::Interface)
        {
            auto tt = (interfaceType*)(unsafe::Pointer(typ));
            if((unsigned int)(i) >= (unsigned int)(len(tt->Methods)))
            {
                gocpp::panic("reflect: internal error: invalid method index"s);
            }
            auto m = & tt->Methods[i];
            return toRType(typeOffFor(typ, m->Typ));
        }
        auto ms = rec::ExportedMethods(gocpp::recv(typ));
        if((unsigned int)(i) >= (unsigned int)(len(ms)))
        {
            gocpp::panic("reflect: internal error: invalid method index"s);
        }
        auto m = ms[i];
        return toRType(typeOffFor(typ, m.Mtyp));
    }

    // CanUint reports whether [Value.Uint] can be used without panicking.
    bool rec::CanUint(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Uint) { conditionId = 0; }
            else if(condition == Uint8) { conditionId = 1; }
            else if(condition == Uint16) { conditionId = 2; }
            else if(condition == Uint32) { conditionId = 3; }
            else if(condition == Uint64) { conditionId = 4; }
            else if(condition == Uintptr) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    return true;
                    break;
                default:
                    return false;
                    break;
            }
        }
    }

    // Uint returns v's underlying value, as a uint64.
    // It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64].
    uint64_t rec::Uint(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        auto p = v.ptr;
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Uint) { conditionId = 0; }
            else if(condition == Uint8) { conditionId = 1; }
            else if(condition == Uint16) { conditionId = 2; }
            else if(condition == Uint32) { conditionId = 3; }
            else if(condition == Uint64) { conditionId = 4; }
            else if(condition == Uintptr) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                    return uint64_t(*(unsigned int*)(p));
                    break;
                case 1:
                    return uint64_t(*(uint8_t*)(p));
                    break;
                case 2:
                    return uint64_t(*(uint16_t*)(p));
                    break;
                case 3:
                    return uint64_t(*(uint32_t*)(p));
                    break;
                case 4:
                    return *(uint64_t*)(p);
                    break;
                case 5:
                    return uint64_t(*(uintptr_t*)(p));
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Uint"s, rec::kind(gocpp::recv(v))});
    }

    // UnsafeAddr returns a pointer to v's data, as a uintptr.
    // It panics if v is not addressable.
    //
    // It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result.
    uintptr_t rec::UnsafeAddr(struct Value v)
    {
        if(rec::typ(gocpp::recv(v)) == nullptr)
        {
            gocpp::panic(new ValueError {"reflect.Value.UnsafeAddr"s, Invalid});
        }
        if(v.flag & flagAddr == 0)
        {
            gocpp::panic("reflect.Value.UnsafeAddr of unaddressable value"s);
        }
        escapes(v.ptr);
        return uintptr_t(v.ptr);
    }

    // UnsafePointer returns v's value as a [unsafe.Pointer].
    // It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], or [UnsafePointer].
    //
    // If v's Kind is [Func], the returned pointer is an underlying
    // code pointer, but not necessarily enough to identify a
    // single function uniquely. The only guarantee is that the
    // result is zero if and only if v is a nil func Value.
    //
    // If v's Kind is [Slice], the returned pointer is to the first
    // element of the slice. If the slice is nil the returned value
    // is nil.  If the slice is empty but non-nil the return value is non-nil.
    unsafe::Pointer rec::UnsafePointer(struct Value v)
    {
        auto k = rec::kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Pointer) { conditionId = 0; }
            else if(condition == Chan) { conditionId = 1; }
            else if(condition == Map) { conditionId = 2; }
            else if(condition == UnsafePointer) { conditionId = 3; }
            else if(condition == Func) { conditionId = 4; }
            else if(condition == Slice) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                    if(rec::typ(gocpp::recv(v))->PtrBytes == 0)
                    {
                        if(! verifyNotInHeapPtr(*(uintptr_t*)(v.ptr)))
                        {
                            gocpp::panic("reflect: reflect.Value.UnsafePointer on an invalid notinheap pointer"s);
                        }
                        return *(unsafe::Pointer*)(v.ptr);
                    }
                case 1:
                case 2:
                case 3:
                    return rec::pointer(gocpp::recv(v));
                    break;
                case 4:
                    if(v.flag & flagMethod != 0)
                    {
                        auto code = methodValueCallCodePtr();
                        return *(unsafe::Pointer*)(unsafe::Pointer(& code));
                    }
                    auto p = rec::pointer(gocpp::recv(v));
                    if(p != nullptr)
                    {
                        p = *(unsafe::Pointer*)(p);
                    }
                    return p;
                    break;
                case 5:
                    return (unsafeheader::Slice*)(v.ptr)->Data;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.UnsafePointer"s, rec::kind(gocpp::recv(v))});
    }

    // StringHeader is the runtime representation of a string.
    // It cannot be used safely or portably and its representation may
    // change in a later release.
    // Moreover, the Data field is not sufficient to guarantee the data
    // it references will not be garbage collected, so programs must keep
    // a separate, correctly typed pointer to the underlying data.
    //
    // Deprecated: Use unsafe.String or unsafe.StringData instead.
    
    template<typename T> requires gocpp::GoStruct<T>
    StringHeader::operator T()
    {
        T result;
        result.Data = this->Data;
        result.Len = this->Len;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool StringHeader::operator==(const T& ref) const
    {
        if (Data != ref.Data) return false;
        if (Len != ref.Len) return false;
        return true;
    }

    std::ostream& StringHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Data;
        os << " " << Len;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct StringHeader& value)
    {
        return value.PrintTo(os);
    }

    // SliceHeader is the runtime representation of a slice.
    // It cannot be used safely or portably and its representation may
    // change in a later release.
    // Moreover, the Data field is not sufficient to guarantee the data
    // it references will not be garbage collected, so programs must keep
    // a separate, correctly typed pointer to the underlying data.
    //
    // Deprecated: Use unsafe.Slice or unsafe.SliceData instead.
    
    template<typename T> requires gocpp::GoStruct<T>
    SliceHeader::operator T()
    {
        T result;
        result.Data = this->Data;
        result.Len = this->Len;
        result.Cap = this->Cap;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SliceHeader::operator==(const T& ref) const
    {
        if (Data != ref.Data) return false;
        if (Len != ref.Len) return false;
        if (Cap != ref.Cap) return false;
        return true;
    }

    std::ostream& SliceHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Data;
        os << " " << Len;
        os << " " << Cap;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SliceHeader& value)
    {
        return value.PrintTo(os);
    }

    void typesMustMatch(std::string what, struct Type t1, struct Type t2)
    {
        if(t1 != t2)
        {
            gocpp::panic(what + ": "s + rec::String(gocpp::recv(t1)) + " != "s + rec::String(gocpp::recv(t2)));
        }
    }

    // arrayAt returns the i-th element of p,
    // an array whose elements are eltSize bytes wide.
    // The array pointed at by p must have at least i+1 elements:
    // it is invalid (but impossible to check here) to pass i >= len,
    // because then the result will point outside the array.
    // whySafe must explain why i < len. (Passing "i < len" is fine;
    // the benefit is to surface this assumption at the call site.)
    unsafe::Pointer arrayAt(unsafe::Pointer p, int i, uintptr_t eltSize, std::string whySafe)
    {
        return add(p, uintptr_t(i) * eltSize, "i < len"s);
    }

    // Grow increases the slice's capacity, if necessary, to guarantee space for
    // another n elements. After Grow(n), at least n elements can be appended
    // to the slice without another allocation.
    //
    // It panics if v's Kind is not a [Slice] or if n is negative or too large to
    // allocate the memory.
    void rec::Grow(struct Value v, int n)
    {
        rec::mustBeAssignable(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Slice);
        rec::grow(gocpp::recv(v), n);
    }

    // grow is identical to Grow but does not check for assignability.
    void rec::grow(struct Value v, int n)
    {
        auto p = (unsafeheader::Slice*)(v.ptr);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n < 0) { conditionId = 0; }
            else if(p->Len + n < 0) { conditionId = 1; }
            else if(p->Len + n > p->Cap) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    gocpp::panic("reflect.Value.Grow: negative len"s);
                    break;
                case 1:
                    gocpp::panic("reflect.Value.Grow: slice overflow"s);
                    break;
                case 2:
                    auto t = rec::Elem(gocpp::recv(rec::typ(gocpp::recv(v))));
                    *p = growslice(t, *p, n);
                    break;
            }
        }
    }

    // extendSlice extends a slice by n elements.
    //
    // Unlike Value.grow, which modifies the slice in place and
    // does not change the length of the slice in place,
    // extendSlice returns a new slice value with the length
    // incremented by the number of specified elements.
    struct Value rec::extendSlice(struct Value v, int n)
    {
        rec::mustBeExported(gocpp::recv(v));
        rec::mustBe(gocpp::recv(v), Slice);
        auto sh = *(unsafeheader::Slice*)(v.ptr);
        auto s = & sh;
        v.ptr = unsafe::Pointer(s);
        v.flag = flagIndir | flag(Slice);
        rec::grow(gocpp::recv(v), n);
        s->Len += n;
        return v;
    }

    // Clear clears the contents of a map or zeros the contents of a slice.
    //
    // It panics if v's Kind is not [Map] or [Slice].
    void rec::Clear(struct Value v)
    {
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Slice) { conditionId = 0; }
            else if(condition == Map) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    auto sh = *(unsafeheader::Slice*)(v.ptr);
                    auto st = (sliceType*)(unsafe::Pointer(rec::typ(gocpp::recv(v))));
                    typedarrayclear(st->Elem, sh.Data, sh.Len);
                    break;
                case 1:
                    mapclear(rec::typ(gocpp::recv(v)), rec::pointer(gocpp::recv(v)));
                    break;
                default:
                    gocpp::panic(new ValueError {"reflect.Value.Clear"s, rec::Kind(gocpp::recv(v))});
                    break;
            }
        }
    }

    // Append appends the values x to a slice s and returns the resulting slice.
    // As in Go, each x's value must be assignable to the slice's element type.
    struct Value Append(struct Value s, gocpp::slice<Value> x)
    {
        rec::mustBe(gocpp::recv(s), Slice);
        auto n = rec::Len(gocpp::recv(s));
        s = rec::extendSlice(gocpp::recv(s), len(x));
        for(auto [i, v] : x)
        {
            rec::Set(gocpp::recv(rec::Index(gocpp::recv(s), n + i)), v);
        }
        return s;
    }

    // AppendSlice appends a slice t to a slice s and returns the resulting slice.
    // The slices s and t must have the same element type.
    struct Value AppendSlice(struct Value s, struct Value t)
    {
        rec::mustBe(gocpp::recv(s), Slice);
        rec::mustBe(gocpp::recv(t), Slice);
        typesMustMatch("reflect.AppendSlice"s, rec::Elem(gocpp::recv(rec::Type(gocpp::recv(s)))), rec::Elem(gocpp::recv(rec::Type(gocpp::recv(t)))));
        auto ns = rec::Len(gocpp::recv(s));
        auto nt = rec::Len(gocpp::recv(t));
        s = rec::extendSlice(gocpp::recv(s), nt);
        Copy(rec::Slice(gocpp::recv(s), ns, ns + nt), t);
        return s;
    }

    // Copy copies the contents of src into dst until either
    // dst has been filled or src has been exhausted.
    // It returns the number of elements copied.
    // Dst and src each must have kind [Slice] or [Array], and
    // dst and src must have the same element type.
    //
    // As a special case, src can have kind [String] if the element type of dst is kind [Uint8].
    int Copy(struct Value dst, struct Value src)
    {
        auto dk = rec::kind(gocpp::recv(dst));
        if(dk != Array && dk != Slice)
        {
            gocpp::panic(new ValueError {"reflect.Copy"s, dk});
        }
        if(dk == Array)
        {
            rec::mustBeAssignable(gocpp::recv(dst));
        }
        rec::mustBeExported(gocpp::recv(dst));
        auto sk = rec::kind(gocpp::recv(src));
        bool stringCopy = {};
        if(sk != Array && sk != Slice)
        {
            stringCopy = sk == String && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::typ(gocpp::recv(dst)))))) == abi::Uint8;
            if(! stringCopy)
            {
                gocpp::panic(new ValueError {"reflect.Copy"s, sk});
            }
        }
        rec::mustBeExported(gocpp::recv(src));
        auto de = rec::Elem(gocpp::recv(rec::typ(gocpp::recv(dst))));
        if(! stringCopy)
        {
            auto se = rec::Elem(gocpp::recv(rec::typ(gocpp::recv(src))));
            typesMustMatch("reflect.Copy"s, toType(de), toType(se));
        }
        unsafeheader::Slice ds = {};
        unsafeheader::Slice ss = {};
        if(dk == Array)
        {
            ds.Data = dst.ptr;
            ds.Len = rec::Len(gocpp::recv(dst));
            ds.Cap = ds.Len;
        }
        else
        {
            ds = *(unsafeheader::Slice*)(dst.ptr);
        }
        if(sk == Array)
        {
            ss.Data = src.ptr;
            ss.Len = rec::Len(gocpp::recv(src));
            ss.Cap = ss.Len;
        }
        else
        if(sk == Slice)
        {
            ss = *(unsafeheader::Slice*)(src.ptr);
        }
        else
        {
            auto sh = *(unsafeheader::String*)(src.ptr);
            ss.Data = sh.Data;
            ss.Len = sh.Len;
            ss.Cap = sh.Len;
        }
        return typedslicecopy(rec::Common(gocpp::recv(de)), ds, ss);
    }

    // A runtimeSelect is a single case passed to rselect.
    // This must match ../runtime/select.go:/runtimeSelect
    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeSelect::operator T()
    {
        T result;
        result.dir = this->dir;
        result.typ = this->typ;
        result.ch = this->ch;
        result.val = this->val;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeSelect::operator==(const T& ref) const
    {
        if (dir != ref.dir) return false;
        if (typ != ref.typ) return false;
        if (ch != ref.ch) return false;
        if (val != ref.val) return false;
        return true;
    }

    std::ostream& runtimeSelect::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << dir;
        os << " " << typ;
        os << " " << ch;
        os << " " << val;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeSelect& value)
    {
        return value.PrintTo(os);
    }

    // rselect runs a select. It returns the index of the chosen case.
    // If the case was a receive, val is filled in with the received value.
    // The conventional OK bool indicates whether the receive corresponds
    // to a sent value.
    //
    // rselect generally doesn't escape the runtimeSelect slice, except
    // that for the send case the value to send needs to escape. We don't
    // have a way to represent that in the function signature. So we handle
    // that with a forced escape in function Select.
    //
    //go:noescape
    std::tuple<int, bool> rselect(gocpp::slice<runtimeSelect>)
    /* convertBlockStmt, nil block */;

    // A SelectDir describes the communication direction of a select case.
    // A SelectCase describes a single case in a select operation.
    // The kind of case depends on Dir, the communication direction.
    //
    // If Dir is SelectDefault, the case represents a default case.
    // Chan and Send must be zero Values.
    //
    // If Dir is SelectSend, the case represents a send operation.
    // Normally Chan's underlying value must be a channel, and Send's underlying value must be
    // assignable to the channel's element type. As a special case, if Chan is a zero Value,
    // then the case is ignored, and the field Send will also be ignored and may be either zero
    // or non-zero.
    //
    // If Dir is SelectRecv, the case represents a receive operation.
    // Normally Chan's underlying value must be a channel and Send must be a zero Value.
    // If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.
    // When a receive operation is selected, the received Value is returned by Select.
    
    template<typename T> requires gocpp::GoStruct<T>
    SelectCase::operator T()
    {
        T result;
        result.Dir = this->Dir;
        result.Chan = this->Chan;
        result.Send = this->Send;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SelectCase::operator==(const T& ref) const
    {
        if (Dir != ref.Dir) return false;
        if (Chan != ref.Chan) return false;
        if (Send != ref.Send) return false;
        return true;
    }

    std::ostream& SelectCase::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Dir;
        os << " " << Chan;
        os << " " << Send;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SelectCase& value)
    {
        return value.PrintTo(os);
    }

    // Select executes a select operation described by the list of cases.
    // Like the Go select statement, it blocks until at least one of the cases
    // can proceed, makes a uniform pseudo-random choice,
    // and then executes that case. It returns the index of the chosen case
    // and, if that case was a receive operation, the value received and a
    // boolean indicating whether the value corresponds to a send on the channel
    // (as opposed to a zero value received because the channel is closed).
    // Select supports a maximum of 65536 cases.
    std::tuple<int, struct Value, bool> Select(gocpp::slice<SelectCase> cases)
    {
        int chosen;
        struct Value recv;
        bool recvOK;
        if(len(cases) > 65536)
        {
            gocpp::panic("reflect.Select: too many cases (max 65536)"s);
        }
        // NOTE: Do not trust that caller is not modifying cases data underfoot.
        // The range is safe because the caller cannot modify our copy of the len
        // and each iteration makes its own copy of the value c.
        gocpp::slice<runtimeSelect> runcases = {};
        if(len(cases) > 4)
        {
            runcases = gocpp::make(gocpp::Tag<gocpp::slice<runtimeSelect>>(), len(cases));
        }
        else
        {
            runcases = gocpp::make(gocpp::Tag<gocpp::slice<runtimeSelect>>(), len(cases), 4);
        }
        auto haveDefault = false;
        for(auto [i, c] : cases)
        {
            auto rc = & runcases[i];
            rc->dir = c.Dir;
            //Go switch emulation
            {
                auto condition = c.Dir;
                int conditionId = -1;
                if(condition == SelectDefault) { conditionId = 0; }
                else if(condition == SelectSend) { conditionId = 1; }
                else if(condition == SelectRecv) { conditionId = 2; }
                switch(conditionId)
                {
                    default:
                        gocpp::panic("reflect.Select: invalid Dir"s);
                        break;
                    case 0:
                        if(haveDefault)
                        {
                            gocpp::panic("reflect.Select: multiple default cases"s);
                        }
                        haveDefault = true;
                        if(rec::IsValid(gocpp::recv(c.Chan)))
                        {
                            gocpp::panic("reflect.Select: default case has Chan value"s);
                        }
                        if(rec::IsValid(gocpp::recv(c.Send)))
                        {
                            gocpp::panic("reflect.Select: default case has Send value"s);
                        }
                        break;
                    case 1:
                        auto ch = c.Chan;
                        if(! rec::IsValid(gocpp::recv(ch)))
                        {
                            break;
                        }
                        rec::mustBe(gocpp::recv(ch), Chan);
                        rec::mustBeExported(gocpp::recv(ch));
                        auto tt = (reflect::chanType*)(unsafe::Pointer(rec::typ(gocpp::recv(ch))));
                        if(ChanDir(tt->Dir) & SendDir == 0)
                        {
                            gocpp::panic("reflect.Select: SendDir case using recv-only channel"s);
                        }
                        rc->ch = rec::pointer(gocpp::recv(ch));
                        rc->typ = toRType(& tt->Type);
                        auto v = c.Send;
                        if(! rec::IsValid(gocpp::recv(v)))
                        {
                            gocpp::panic("reflect.Select: SendDir case missing Send value"s);
                        }
                        rec::mustBeExported(gocpp::recv(v));
                        v = rec::assignTo(gocpp::recv(v), "reflect.Select"s, tt->Elem, nullptr);
                        if(v.flag & flagIndir != 0)
                        {
                            rc->val = v.ptr;
                        }
                        else
                        {
                            rc->val = unsafe::Pointer(& v.ptr);
                        }
                        escapes(rc->val);
                        break;
                    case 2:
                        if(rec::IsValid(gocpp::recv(c.Send)))
                        {
                            gocpp::panic("reflect.Select: RecvDir case has Send value"s);
                        }
                        auto ch = c.Chan;
                        if(! rec::IsValid(gocpp::recv(ch)))
                        {
                            break;
                        }
                        rec::mustBe(gocpp::recv(ch), Chan);
                        rec::mustBeExported(gocpp::recv(ch));
                        auto tt = (reflect::chanType*)(unsafe::Pointer(rec::typ(gocpp::recv(ch))));
                        if(ChanDir(tt->Dir) & RecvDir == 0)
                        {
                            gocpp::panic("reflect.Select: RecvDir case using send-only channel"s);
                        }
                        rc->ch = rec::pointer(gocpp::recv(ch));
                        rc->typ = toRType(& tt->Type);
                        rc->val = unsafe_New(tt->Elem);
                        break;
                }
            }
        }
        std::tie(chosen, recvOK) = rselect(runcases);
        if(runcases[chosen].dir == SelectRecv)
        {
            auto tt = (reflect::chanType*)(unsafe::Pointer(runcases[chosen].typ));
            auto t = tt->Elem;
            auto p = runcases[chosen].val;
            auto fl = flag(rec::Kind(gocpp::recv(t)));
            if(rec::IfaceIndir(gocpp::recv(t)))
            {
                recv = Value {t, p, fl | flagIndir};
            }
            else
            {
                recv = Value {t, *(unsafe::Pointer*)(p), fl};
            }
        }
        return {chosen, recv, recvOK};
    }

    //go:noescape
    unsafe::Pointer unsafe_New(abi::Type*)
    /* convertBlockStmt, nil block */;

    //go:noescape
    unsafe::Pointer unsafe_NewArray(abi::Type*, int)
    /* convertBlockStmt, nil block */;

    // MakeSlice creates a new zero-initialized slice value
    // for the specified slice type, length, and capacity.
    struct Value MakeSlice(struct Type typ, int len, int cap)
    {
        if(rec::Kind(gocpp::recv(typ)) != Slice)
        {
            gocpp::panic("reflect.MakeSlice of non-slice type"s);
        }
        if(len < 0)
        {
            gocpp::panic("reflect.MakeSlice: negative len"s);
        }
        if(cap < 0)
        {
            gocpp::panic("reflect.MakeSlice: negative cap"s);
        }
        if(len > cap)
        {
            gocpp::panic("reflect.MakeSlice: len > cap"s);
        }
        auto s = gocpp::Init<unsafeheader::Slice>([=](auto& x) {
            x.Data = unsafe_NewArray(& (gocpp::getValue<rtype*>(rec::Elem(gocpp::recv(typ)))->t), cap);
            x.Len = len;
            x.Cap = cap;
        });
        return Value {& gocpp::getValue<rtype*>(typ)->t, unsafe::Pointer(& s), flagIndir | flag(Slice)};
    }

    // MakeChan creates a new channel with the specified type and buffer size.
    struct Value MakeChan(struct Type typ, int buffer)
    {
        if(rec::Kind(gocpp::recv(typ)) != Chan)
        {
            gocpp::panic("reflect.MakeChan of non-chan type"s);
        }
        if(buffer < 0)
        {
            gocpp::panic("reflect.MakeChan: negative buffer size"s);
        }
        if(rec::ChanDir(gocpp::recv(typ)) != BothDir)
        {
            gocpp::panic("reflect.MakeChan: unidirectional channel type"s);
        }
        auto t = rec::common(gocpp::recv(typ));
        auto ch = makechan(t, buffer);
        return Value {t, ch, flag(Chan)};
    }

    // MakeMap creates a new map with the specified type.
    struct Value MakeMap(struct Type typ)
    {
        return MakeMapWithSize(typ, 0);
    }

    // MakeMapWithSize creates a new map with the specified type
    // and initial space for approximately n elements.
    struct Value MakeMapWithSize(struct Type typ, int n)
    {
        if(rec::Kind(gocpp::recv(typ)) != Map)
        {
            gocpp::panic("reflect.MakeMapWithSize of non-map type"s);
        }
        auto t = rec::common(gocpp::recv(typ));
        auto m = makemap(t, n);
        return Value {t, m, flag(Map)};
    }

    // Indirect returns the value that v points to.
    // If v is a nil pointer, Indirect returns a zero Value.
    // If v is not a pointer, Indirect returns v.
    struct Value Indirect(struct Value v)
    {
        if(rec::Kind(gocpp::recv(v)) != Pointer)
        {
            return v;
        }
        return rec::Elem(gocpp::recv(v));
    }

    // ValueOf returns a new Value initialized to the concrete value
    // stored in the interface i. ValueOf(nil) returns the zero Value.
    struct Value ValueOf(go_any i)
    {
        if(i == nullptr)
        {
            return Value {};
        }
        return unpackEface(i);
    }

    // Zero returns a Value representing the zero value for the specified type.
    // The result is different from the zero value of the Value struct,
    // which represents no value at all.
    // For example, Zero(TypeOf(42)) returns a Value with Kind [Int] and value 0.
    // The returned value is neither addressable nor settable.
    struct Value Zero(struct Type typ)
    {
        if(typ == nullptr)
        {
            gocpp::panic("reflect: Zero(nil)"s);
        }
        auto t = & gocpp::getValue<rtype*>(typ)->t;
        auto fl = flag(rec::Kind(gocpp::recv(t)));
        if(rec::IfaceIndir(gocpp::recv(t)))
        {
            unsafe::Pointer p = {};
            if(rec::Size(gocpp::recv(t)) <= abi::ZeroValSize)
            {
                p = unsafe::Pointer(& zeroVal[0]);
            }
            else
            {
                p = unsafe_New(t);
            }
            return Value {t, p, fl | flagIndir};
        }
        return Value {t, nullptr, fl};
    }

    //go:linkname zeroVal runtime.zeroVal
    gocpp::array<unsigned char, abi::ZeroValSize> zeroVal;
    // New returns a Value representing a pointer to a new zero value
    // for the specified type. That is, the returned Value's Type is PointerTo(typ).
    struct Value New(struct Type typ)
    {
        if(typ == nullptr)
        {
            gocpp::panic("reflect: New(nil)"s);
        }
        auto t = & gocpp::getValue<rtype*>(typ)->t;
        auto pt = ptrTo(t);
        if(ifaceIndir(pt))
        {
            gocpp::panic("reflect: New of type that may not be allocated in heap (possibly undefined cgo C type)"s);
        }
        auto ptr = unsafe_New(t);
        auto fl = flag(Pointer);
        return Value {pt, ptr, fl};
    }

    // NewAt returns a Value representing a pointer to a value of the
    // specified type, using p as that pointer.
    struct Value NewAt(struct Type typ, unsafe::Pointer p)
    {
        auto fl = flag(Pointer);
        auto t = gocpp::getValue<rtype*>(typ);
        return Value {rec::ptrTo(gocpp::recv(t)), p, fl};
    }

    // assignTo returns a value v that can be assigned directly to dst.
    // It panics if v is not assignable to dst.
    // For a conversion to an interface type, target, if not nil,
    // is a suggested scratch space to use.
    // target must be initialized memory (or nil).
    struct Value rec::assignTo(struct Value v, std::string context, abi::Type* dst, unsafe::Pointer target)
    {
        if(v.flag & flagMethod != 0)
        {
            v = makeMethodValue(context, v);
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(directlyAssignable(dst, rec::typ(gocpp::recv(v)))) { conditionId = 0; }
            else if(implements(dst, rec::typ(gocpp::recv(v)))) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    auto fl = v.flag & (flagAddr | flagIndir) | rec::ro(gocpp::recv(v.flag));
                    fl |= flag(rec::Kind(gocpp::recv(dst)));
                    return Value {dst, v.ptr, fl};
                    break;
                case 1:
                    if(rec::Kind(gocpp::recv(v)) == Interface && rec::IsNil(gocpp::recv(v)))
                    {
                        return Value {dst, nullptr, flag(Interface)};
                    }
                    auto x = valueInterface(v, false);
                    if(target == nullptr)
                    {
                        target = unsafe_New(dst);
                    }
                    if(rec::NumMethod(gocpp::recv(dst)) == 0)
                    {
                        *(go_any*)(target) = x;
                    }
                    else
                    {
                        ifaceE2I(dst, x, target);
                    }
                    return Value {dst, target, flagIndir | flag(Interface)};
                    break;
            }
        }
        gocpp::panic(context + ": value of type "s + stringFor(rec::typ(gocpp::recv(v))) + " is not assignable to type "s + stringFor(dst));
    }

    // Convert returns the value v converted to type t.
    // If the usual Go conversion rules do not allow conversion
    // of the value v to type t, or if converting v to type t panics, Convert panics.
    struct Value rec::Convert(struct Value v, struct Type t)
    {
        if(v.flag & flagMethod != 0)
        {
            v = makeMethodValue("Convert"s, v);
        }
        auto op = convertOp(rec::common(gocpp::recv(t)), rec::typ(gocpp::recv(v)));
        if(op == nullptr)
        {
            gocpp::panic("reflect.Value.Convert: value of type "s + stringFor(rec::typ(gocpp::recv(v))) + " cannot be converted to type "s + rec::String(gocpp::recv(t)));
        }
        return op(v, t);
    }

    // CanConvert reports whether the value v can be converted to type t.
    // If v.CanConvert(t) returns true then v.Convert(t) will not panic.
    bool rec::CanConvert(struct Value v, struct Type t)
    {
        auto vt = rec::Type(gocpp::recv(v));
        if(! rec::ConvertibleTo(gocpp::recv(vt), t))
        {
            return false;
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(rec::Kind(gocpp::recv(vt)) == Slice && rec::Kind(gocpp::recv(t)) == Array) { conditionId = 0; }
            else if(rec::Kind(gocpp::recv(vt)) == Slice && rec::Kind(gocpp::recv(t)) == Pointer && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(t)))) == Array) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(rec::Len(gocpp::recv(t)) > rec::Len(gocpp::recv(v)))
                    {
                        return false;
                    }
                    break;
                case 1:
                    auto n = rec::Len(gocpp::recv(rec::Elem(gocpp::recv(t))));
                    if(n > rec::Len(gocpp::recv(v)))
                    {
                        return false;
                    }
                    break;
            }
        }
        return true;
    }

    // Comparable reports whether the value v is comparable.
    // If the type of v is an interface, this checks the dynamic type.
    // If this reports true then v.Interface() == x will not panic for any x,
    // nor will v.Equal(u) for any Value u.
    bool rec::Comparable(struct Value v)
    {
        auto k = rec::Kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == Invalid) { conditionId = 0; }
            else if(condition == Array) { conditionId = 1; }
            else if(condition == Interface) { conditionId = 2; }
            else if(condition == Struct) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return false;
                    break;
                case 1:
                    //Go switch emulation
                    {
                        auto condition = rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(rec::Type(gocpp::recv(v))))));
                        int conditionId = -1;
                        if(condition == Interface) { conditionId = 0; }
                        else if(condition == Array) { conditionId = 1; }
                        else if(condition == Struct) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                            case 1:
                            case 2:
                                for(auto i = 0; i < rec::Len(gocpp::recv(rec::Type(gocpp::recv(v)))); i++)
                                {
                                    if(! rec::Comparable(gocpp::recv(rec::Index(gocpp::recv(v), i))))
                                    {
                                        return false;
                                    }
                                }
                                return true;
                                break;
                        }
                    }
                    return rec::Comparable(gocpp::recv(rec::Type(gocpp::recv(v))));
                    break;
                case 2:
                    return rec::Comparable(gocpp::recv(rec::Elem(gocpp::recv(v))));
                    break;
                case 3:
                    for(auto i = 0; i < rec::NumField(gocpp::recv(v)); i++)
                    {
                        if(! rec::Comparable(gocpp::recv(rec::Field(gocpp::recv(v), i))))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                default:
                    return rec::Comparable(gocpp::recv(rec::Type(gocpp::recv(v))));
                    break;
            }
        }
    }

    // Equal reports true if v is equal to u.
    // For two invalid values, Equal will report true.
    // For an interface value, Equal will compare the value within the interface.
    // Otherwise, If the values have different types, Equal will report false.
    // Otherwise, for arrays and structs Equal will compare each element in order,
    // and report false if it finds non-equal elements.
    // During all comparisons, if values of the same type are compared,
    // and the type is not comparable, Equal will panic.
    bool rec::Equal(struct Value v, struct Value u)
    {
        if(rec::Kind(gocpp::recv(v)) == Interface)
        {
            v = rec::Elem(gocpp::recv(v));
        }
        if(rec::Kind(gocpp::recv(u)) == Interface)
        {
            u = rec::Elem(gocpp::recv(u));
        }
        if(! rec::IsValid(gocpp::recv(v)) || ! rec::IsValid(gocpp::recv(u)))
        {
            return rec::IsValid(gocpp::recv(v)) == rec::IsValid(gocpp::recv(u));
        }
        if(rec::Kind(gocpp::recv(v)) != rec::Kind(gocpp::recv(u)) || rec::Type(gocpp::recv(v)) != rec::Type(gocpp::recv(u)))
        {
            return false;
        }
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(v));
            int conditionId = -1;
            if(condition == Bool) { conditionId = 0; }
            else if(condition == Int) { conditionId = 1; }
            else if(condition == Int8) { conditionId = 2; }
            else if(condition == Int16) { conditionId = 3; }
            else if(condition == Int32) { conditionId = 4; }
            else if(condition == Int64) { conditionId = 5; }
            else if(condition == Uint) { conditionId = 6; }
            else if(condition == Uint8) { conditionId = 7; }
            else if(condition == Uint16) { conditionId = 8; }
            else if(condition == Uint32) { conditionId = 9; }
            else if(condition == Uint64) { conditionId = 10; }
            else if(condition == Uintptr) { conditionId = 11; }
            else if(condition == Float32) { conditionId = 12; }
            else if(condition == Float64) { conditionId = 13; }
            else if(condition == Complex64) { conditionId = 14; }
            else if(condition == Complex128) { conditionId = 15; }
            else if(condition == String) { conditionId = 16; }
            else if(condition == Chan) { conditionId = 17; }
            else if(condition == Pointer) { conditionId = 18; }
            else if(condition == UnsafePointer) { conditionId = 19; }
            else if(condition == Array) { conditionId = 20; }
            else if(condition == Struct) { conditionId = 21; }
            else if(condition == Func) { conditionId = 22; }
            else if(condition == Map) { conditionId = 23; }
            else if(condition == Slice) { conditionId = 24; }
            switch(conditionId)
            {
                default:
                    gocpp::panic("reflect.Value.Equal: invalid Kind"s);
                    break;
                case 0:
                    return rec::Bool(gocpp::recv(v)) == rec::Bool(gocpp::recv(u));
                    break;
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    return rec::Int(gocpp::recv(v)) == rec::Int(gocpp::recv(u));
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    return rec::Uint(gocpp::recv(v)) == rec::Uint(gocpp::recv(u));
                    break;
                case 12:
                case 13:
                    return rec::Float(gocpp::recv(v)) == rec::Float(gocpp::recv(u));
                    break;
                case 14:
                case 15:
                    return rec::Complex(gocpp::recv(v)) == rec::Complex(gocpp::recv(u));
                    break;
                case 16:
                    return rec::String(gocpp::recv(v)) == rec::String(gocpp::recv(u));
                    break;
                case 17:
                case 18:
                case 19:
                    return rec::Pointer(gocpp::recv(v)) == rec::Pointer(gocpp::recv(u));
                    break;
                case 20:
                    auto vl = rec::Len(gocpp::recv(v));
                    if(vl == 0)
                    {
                        if(! rec::Comparable(gocpp::recv(rec::Elem(gocpp::recv(rec::Type(gocpp::recv(v)))))))
                        {
                            break;
                        }
                        return true;
                    }
                    for(auto i = 0; i < vl; i++)
                    {
                        if(! rec::Equal(gocpp::recv(rec::Index(gocpp::recv(v), i)), rec::Index(gocpp::recv(u), i)))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 21:
                    auto nf = rec::NumField(gocpp::recv(v));
                    for(auto i = 0; i < nf; i++)
                    {
                        if(! rec::Equal(gocpp::recv(rec::Field(gocpp::recv(v), i)), rec::Field(gocpp::recv(u), i)))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 22:
                case 23:
                case 24:
                    break;
                    break;
            }
        }
        gocpp::panic("reflect.Value.Equal: values of type "s + rec::String(gocpp::recv(rec::Type(gocpp::recv(v)))) + " are not comparable"s);
    }

    // convertOp returns the function to convert a value of type src
    // to a value of type dst. If the conversion is illegal, convertOp returns nil.
    std::function<struct Value (struct Value _1, struct Type _2)> convertOp(abi::Type* dst, abi::Type* src)
    {
        //Go switch emulation
        {
            auto condition = Kind(rec::Kind(gocpp::recv(src)));
            int conditionId = -1;
            if(condition == Int) { conditionId = 0; }
            else if(condition == Int8) { conditionId = 1; }
            else if(condition == Int16) { conditionId = 2; }
            else if(condition == Int32) { conditionId = 3; }
            else if(condition == Int64) { conditionId = 4; }
            else if(condition == Uint) { conditionId = 5; }
            else if(condition == Uint8) { conditionId = 6; }
            else if(condition == Uint16) { conditionId = 7; }
            else if(condition == Uint32) { conditionId = 8; }
            else if(condition == Uint64) { conditionId = 9; }
            else if(condition == Uintptr) { conditionId = 10; }
            else if(condition == Float32) { conditionId = 11; }
            else if(condition == Float64) { conditionId = 12; }
            else if(condition == Complex64) { conditionId = 13; }
            else if(condition == Complex128) { conditionId = 14; }
            else if(condition == String) { conditionId = 15; }
            else if(condition == Slice) { conditionId = 16; }
            else if(condition == Chan) { conditionId = 17; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    //Go switch emulation
                    {
                        auto condition = Kind(rec::Kind(gocpp::recv(dst)));
                        int conditionId = -1;
                        if(condition == Int) { conditionId = 0; }
                        else if(condition == Int8) { conditionId = 1; }
                        else if(condition == Int16) { conditionId = 2; }
                        else if(condition == Int32) { conditionId = 3; }
                        else if(condition == Int64) { conditionId = 4; }
                        else if(condition == Uint) { conditionId = 5; }
                        else if(condition == Uint8) { conditionId = 6; }
                        else if(condition == Uint16) { conditionId = 7; }
                        else if(condition == Uint32) { conditionId = 8; }
                        else if(condition == Uint64) { conditionId = 9; }
                        else if(condition == Uintptr) { conditionId = 10; }
                        else if(condition == Float32) { conditionId = 11; }
                        else if(condition == Float64) { conditionId = 12; }
                        else if(condition == String) { conditionId = 13; }
                        switch(conditionId)
                        {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                return cvtInt;
                                break;
                            case 11:
                            case 12:
                                return cvtIntFloat;
                                break;
                            case 13:
                                return cvtIntString;
                                break;
                        }
                    }
                    break;
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    //Go switch emulation
                    {
                        auto condition = Kind(rec::Kind(gocpp::recv(dst)));
                        int conditionId = -1;
                        if(condition == Int) { conditionId = 0; }
                        else if(condition == Int8) { conditionId = 1; }
                        else if(condition == Int16) { conditionId = 2; }
                        else if(condition == Int32) { conditionId = 3; }
                        else if(condition == Int64) { conditionId = 4; }
                        else if(condition == Uint) { conditionId = 5; }
                        else if(condition == Uint8) { conditionId = 6; }
                        else if(condition == Uint16) { conditionId = 7; }
                        else if(condition == Uint32) { conditionId = 8; }
                        else if(condition == Uint64) { conditionId = 9; }
                        else if(condition == Uintptr) { conditionId = 10; }
                        else if(condition == Float32) { conditionId = 11; }
                        else if(condition == Float64) { conditionId = 12; }
                        else if(condition == String) { conditionId = 13; }
                        switch(conditionId)
                        {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                return cvtUint;
                                break;
                            case 11:
                            case 12:
                                return cvtUintFloat;
                                break;
                            case 13:
                                return cvtUintString;
                                break;
                        }
                    }
                    break;
                case 11:
                case 12:
                    //Go switch emulation
                    {
                        auto condition = Kind(rec::Kind(gocpp::recv(dst)));
                        int conditionId = -1;
                        if(condition == Int) { conditionId = 0; }
                        else if(condition == Int8) { conditionId = 1; }
                        else if(condition == Int16) { conditionId = 2; }
                        else if(condition == Int32) { conditionId = 3; }
                        else if(condition == Int64) { conditionId = 4; }
                        else if(condition == Uint) { conditionId = 5; }
                        else if(condition == Uint8) { conditionId = 6; }
                        else if(condition == Uint16) { conditionId = 7; }
                        else if(condition == Uint32) { conditionId = 8; }
                        else if(condition == Uint64) { conditionId = 9; }
                        else if(condition == Uintptr) { conditionId = 10; }
                        else if(condition == Float32) { conditionId = 11; }
                        else if(condition == Float64) { conditionId = 12; }
                        switch(conditionId)
                        {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                return cvtFloatInt;
                                break;
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                return cvtFloatUint;
                                break;
                            case 11:
                            case 12:
                                return cvtFloat;
                                break;
                        }
                    }
                    break;
                case 13:
                case 14:
                    //Go switch emulation
                    {
                        auto condition = Kind(rec::Kind(gocpp::recv(dst)));
                        int conditionId = -1;
                        if(condition == Complex64) { conditionId = 0; }
                        else if(condition == Complex128) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                            case 1:
                                return cvtComplex;
                                break;
                        }
                    }
                    break;
                case 15:
                    if(rec::Kind(gocpp::recv(dst)) == abi::Slice && pkgPathFor(rec::Elem(gocpp::recv(dst))) == ""s)
                    {
                        //Go switch emulation
                        {
                            auto condition = Kind(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(dst)))));
                            int conditionId = -1;
                            if(condition == Uint8) { conditionId = 0; }
                            else if(condition == Int32) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    return cvtStringBytes;
                                    break;
                                case 1:
                                    return cvtStringRunes;
                                    break;
                            }
                        }
                    }
                    break;
                case 16:
                    if(rec::Kind(gocpp::recv(dst)) == abi::String && pkgPathFor(rec::Elem(gocpp::recv(src))) == ""s)
                    {
                        //Go switch emulation
                        {
                            auto condition = Kind(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(src)))));
                            int conditionId = -1;
                            if(condition == Uint8) { conditionId = 0; }
                            else if(condition == Int32) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    return cvtBytesString;
                                    break;
                                case 1:
                                    return cvtRunesString;
                                    break;
                            }
                        }
                    }
                    if(rec::Kind(gocpp::recv(dst)) == abi::Pointer && rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(dst)))) == abi::Array && rec::Elem(gocpp::recv(src)) == rec::Elem(gocpp::recv(rec::Elem(gocpp::recv(dst)))))
                    {
                        return cvtSliceArrayPtr;
                    }
                    if(rec::Kind(gocpp::recv(dst)) == abi::Array && rec::Elem(gocpp::recv(src)) == rec::Elem(gocpp::recv(dst)))
                    {
                        return cvtSliceArray;
                    }
                    break;
                case 17:
                    if(rec::Kind(gocpp::recv(dst)) == abi::Chan && specialChannelAssignability(dst, src))
                    {
                        return cvtDirect;
                    }
                    break;
            }
        }
        if(haveIdenticalUnderlyingType(dst, src, false))
        {
            return cvtDirect;
        }
        if(rec::Kind(gocpp::recv(dst)) == abi::Pointer && nameFor(dst) == ""s && rec::Kind(gocpp::recv(src)) == abi::Pointer && nameFor(src) == ""s && haveIdenticalUnderlyingType(elem(dst), elem(src), false))
        {
            return cvtDirect;
        }
        if(implements(dst, src))
        {
            if(rec::Kind(gocpp::recv(src)) == abi::Interface)
            {
                return cvtI2I;
            }
            return cvtT2I;
        }
        return nullptr;
    }

    // makeInt returns a Value of type t equal to bits (possibly truncated),
    // where t is a signed or unsigned int type.
    struct Value makeInt(golang::reflect::flag f, uint64_t bits, struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ptr = unsafe_New(typ);
        //Go switch emulation
        {
            auto condition = rec::Size(gocpp::recv(typ));
            int conditionId = -1;
            if(condition == 1) { conditionId = 0; }
            else if(condition == 2) { conditionId = 1; }
            else if(condition == 4) { conditionId = 2; }
            else if(condition == 8) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    *(uint8_t*)(ptr) = uint8_t(bits);
                    break;
                case 1:
                    *(uint16_t*)(ptr) = uint16_t(bits);
                    break;
                case 2:
                    *(uint32_t*)(ptr) = uint32_t(bits);
                    break;
                case 3:
                    *(uint64_t*)(ptr) = bits;
                    break;
            }
        }
        return Value {typ, ptr, f | flagIndir | flag(rec::Kind(gocpp::recv(typ)))};
    }

    // makeFloat returns a Value of type t equal to v (possibly truncated to float32),
    // where t is a float32 or float64 type.
    struct Value makeFloat(golang::reflect::flag f, double v, struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ptr = unsafe_New(typ);
        //Go switch emulation
        {
            auto condition = rec::Size(gocpp::recv(typ));
            int conditionId = -1;
            if(condition == 4) { conditionId = 0; }
            else if(condition == 8) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    *(float*)(ptr) = float(v);
                    break;
                case 1:
                    *(double*)(ptr) = v;
                    break;
            }
        }
        return Value {typ, ptr, f | flagIndir | flag(rec::Kind(gocpp::recv(typ)))};
    }

    // makeFloat32 returns a Value of type t equal to v, where t is a float32 type.
    struct Value makeFloat32(golang::reflect::flag f, double v, struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ptr = unsafe_New(typ);
        *(float*)(ptr) = v;
        return Value {typ, ptr, f | flagIndir | flag(rec::Kind(gocpp::recv(typ)))};
    }

    // makeComplex returns a Value of type t equal to v (possibly truncated to complex64),
    // where t is a complex64 or complex128 type.
    struct Value makeComplex(golang::reflect::flag f, struct gocpp::complex128 v, struct Type t)
    {
        auto typ = rec::common(gocpp::recv(t));
        auto ptr = unsafe_New(typ);
        //Go switch emulation
        {
            auto condition = rec::Size(gocpp::recv(typ));
            int conditionId = -1;
            if(condition == 8) { conditionId = 0; }
            else if(condition == 16) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    *(gocpp::complex64*)(ptr) = gocpp::complex64(v);
                    break;
                case 1:
                    *(gocpp::complex128*)(ptr) = v;
                    break;
            }
        }
        return Value {typ, ptr, f | flagIndir | flag(rec::Kind(gocpp::recv(typ)))};
    }

    struct Value makeString(golang::reflect::flag f, std::string v, struct Type t)
    {
        auto ret = rec::Elem(gocpp::recv(New(t)));
        rec::SetString(gocpp::recv(ret), v);
        ret.flag = ret.flag &^ flagAddr | f;
        return ret;
    }

    struct Value makeBytes(golang::reflect::flag f, gocpp::slice<unsigned char> v, struct Type t)
    {
        auto ret = rec::Elem(gocpp::recv(New(t)));
        rec::SetBytes(gocpp::recv(ret), v);
        ret.flag = ret.flag &^ flagAddr | f;
        return ret;
    }

    struct Value makeRunes(golang::reflect::flag f, gocpp::slice<gocpp::rune> v, struct Type t)
    {
        auto ret = rec::Elem(gocpp::recv(New(t)));
        rec::setRunes(gocpp::recv(ret), v);
        ret.flag = ret.flag &^ flagAddr | f;
        return ret;
    }

    // convertOp: intXX -> [u]intXX
    struct Value cvtInt(struct Value v, struct Type t)
    {
        return makeInt(rec::ro(gocpp::recv(v.flag)), uint64_t(rec::Int(gocpp::recv(v))), t);
    }

    // convertOp: uintXX -> [u]intXX
    struct Value cvtUint(struct Value v, struct Type t)
    {
        return makeInt(rec::ro(gocpp::recv(v.flag)), rec::Uint(gocpp::recv(v)), t);
    }

    // convertOp: floatXX -> intXX
    struct Value cvtFloatInt(struct Value v, struct Type t)
    {
        return makeInt(rec::ro(gocpp::recv(v.flag)), uint64_t(int64_t(rec::Float(gocpp::recv(v)))), t);
    }

    // convertOp: floatXX -> uintXX
    struct Value cvtFloatUint(struct Value v, struct Type t)
    {
        return makeInt(rec::ro(gocpp::recv(v.flag)), uint64_t(rec::Float(gocpp::recv(v))), t);
    }

    // convertOp: intXX -> floatXX
    struct Value cvtIntFloat(struct Value v, struct Type t)
    {
        return makeFloat(rec::ro(gocpp::recv(v.flag)), double(rec::Int(gocpp::recv(v))), t);
    }

    // convertOp: uintXX -> floatXX
    struct Value cvtUintFloat(struct Value v, struct Type t)
    {
        return makeFloat(rec::ro(gocpp::recv(v.flag)), double(rec::Uint(gocpp::recv(v))), t);
    }

    // convertOp: floatXX -> floatXX
    struct Value cvtFloat(struct Value v, struct Type t)
    {
        if(rec::Kind(gocpp::recv(rec::Type(gocpp::recv(v)))) == Float32 && rec::Kind(gocpp::recv(t)) == Float32)
        {
            return makeFloat32(rec::ro(gocpp::recv(v.flag)), *(float*)(v.ptr), t);
        }
        return makeFloat(rec::ro(gocpp::recv(v.flag)), rec::Float(gocpp::recv(v)), t);
    }

    // convertOp: complexXX -> complexXX
    struct Value cvtComplex(struct Value v, struct Type t)
    {
        return makeComplex(rec::ro(gocpp::recv(v.flag)), rec::Complex(gocpp::recv(v)), t);
    }

    // convertOp: intXX -> string
    struct Value cvtIntString(struct Value v, struct Type t)
    {
        auto s = "\uFFFD"s;
        if(auto x = rec::Int(gocpp::recv(v)); int64_t(gocpp::rune(x)) == x)
        {
            s = std::string(gocpp::rune(x));
        }
        return makeString(rec::ro(gocpp::recv(v.flag)), s, t);
    }

    // convertOp: uintXX -> string
    struct Value cvtUintString(struct Value v, struct Type t)
    {
        auto s = "\uFFFD"s;
        if(auto x = rec::Uint(gocpp::recv(v)); uint64_t(gocpp::rune(x)) == x)
        {
            s = std::string(gocpp::rune(x));
        }
        return makeString(rec::ro(gocpp::recv(v.flag)), s, t);
    }

    // convertOp: []byte -> string
    struct Value cvtBytesString(struct Value v, struct Type t)
    {
        return makeString(rec::ro(gocpp::recv(v.flag)), std::string(rec::Bytes(gocpp::recv(v))), t);
    }

    // convertOp: string -> []byte
    struct Value cvtStringBytes(struct Value v, struct Type t)
    {
        return makeBytes(rec::ro(gocpp::recv(v.flag)), gocpp::slice<unsigned char>(rec::String(gocpp::recv(v))), t);
    }

    // convertOp: []rune -> string
    struct Value cvtRunesString(struct Value v, struct Type t)
    {
        return makeString(rec::ro(gocpp::recv(v.flag)), std::string(rec::runes(gocpp::recv(v))), t);
    }

    // convertOp: string -> []rune
    struct Value cvtStringRunes(struct Value v, struct Type t)
    {
        return makeRunes(rec::ro(gocpp::recv(v.flag)), gocpp::slice<gocpp::rune>(rec::String(gocpp::recv(v))), t);
    }

    // convertOp: []T -> *[N]T
    struct Value cvtSliceArrayPtr(struct Value v, struct Type t)
    {
        auto n = rec::Len(gocpp::recv(rec::Elem(gocpp::recv(t))));
        if(n > rec::Len(gocpp::recv(v)))
        {
            gocpp::panic("reflect: cannot convert slice with length "s + itoa::Itoa(rec::Len(gocpp::recv(v))) + " to pointer to array with length "s + itoa::Itoa(n));
        }
        auto h = (unsafeheader::Slice*)(v.ptr);
        return Value {rec::common(gocpp::recv(t)), h->Data, v.flag &^ (flagIndir | flagAddr | flagKindMask) | flag(Pointer)};
    }

    // convertOp: []T -> [N]T
    struct Value cvtSliceArray(struct Value v, struct Type t)
    {
        auto n = rec::Len(gocpp::recv(t));
        if(n > rec::Len(gocpp::recv(v)))
        {
            gocpp::panic("reflect: cannot convert slice with length "s + itoa::Itoa(rec::Len(gocpp::recv(v))) + " to array with length "s + itoa::Itoa(n));
        }
        auto h = (unsafeheader::Slice*)(v.ptr);
        auto typ = rec::common(gocpp::recv(t));
        auto ptr = h->Data;
        auto c = unsafe_New(typ);
        typedmemmove(typ, c, ptr);
        ptr = c;
        return Value {typ, ptr, v.flag &^ (flagAddr | flagKindMask) | flag(Array)};
    }

    // convertOp: direct copy
    struct Value cvtDirect(struct Value v, struct Type typ)
    {
        auto f = v.flag;
        auto t = rec::common(gocpp::recv(typ));
        auto ptr = v.ptr;
        if(f & flagAddr != 0)
        {
            auto c = unsafe_New(t);
            typedmemmove(t, c, ptr);
            ptr = c;
            f &^= flagAddr;
        }
        return Value {t, ptr, rec::ro(gocpp::recv(v.flag)) | f};
    }

    // convertOp: concrete -> interface
    struct Value cvtT2I(struct Value v, struct Type typ)
    {
        auto target = unsafe_New(rec::common(gocpp::recv(typ)));
        auto x = valueInterface(v, false);
        if(rec::NumMethod(gocpp::recv(typ)) == 0)
        {
            *(go_any*)(target) = x;
        }
        else
        {
            ifaceE2I(rec::common(gocpp::recv(typ)), x, target);
        }
        return Value {rec::common(gocpp::recv(typ)), target, rec::ro(gocpp::recv(v.flag)) | flagIndir | flag(Interface)};
    }

    // convertOp: interface -> interface
    struct Value cvtI2I(struct Value v, struct Type typ)
    {
        if(rec::IsNil(gocpp::recv(v)))
        {
            auto ret = Zero(typ);
            ret.flag |= rec::ro(gocpp::recv(v.flag));
            return ret;
        }
        return cvtT2I(rec::Elem(gocpp::recv(v)), typ);
    }

    // implemented in ../runtime
    //
    //go:noescape
    int chancap(unsafe::Pointer ch)
    /* convertBlockStmt, nil block */;

    //go:noescape
    void chanclose(unsafe::Pointer ch)
    /* convertBlockStmt, nil block */;

    //go:noescape
    int chanlen(unsafe::Pointer ch)
    /* convertBlockStmt, nil block */;

    //go:noescape
    std::tuple<bool, bool> chanrecv(unsafe::Pointer ch, bool nb, unsafe::Pointer val)
    /* convertBlockStmt, nil block */;

    //go:noescape
    bool chansend0(unsafe::Pointer ch, unsafe::Pointer val, bool nb)
    /* convertBlockStmt, nil block */;

    bool chansend(unsafe::Pointer ch, unsafe::Pointer val, bool nb)
    {
        contentEscapes(val);
        return chansend0(ch, val, nb);
    }

    unsafe::Pointer makechan(abi::Type* typ, int size)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer makemap(abi::Type* t, int cap)
    /* convertBlockStmt, nil block */;

    //go:noescape
    unsafe::Pointer mapaccess(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key)
    /* convertBlockStmt, nil block */;

    //go:noescape
    unsafe::Pointer mapaccess_faststr(abi::Type* t, unsafe::Pointer m, std::string key)
    /* convertBlockStmt, nil block */;

    //go:noescape
    void mapassign0(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key, unsafe::Pointer val)
    /* convertBlockStmt, nil block */;

    void mapassign(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key, unsafe::Pointer val)
    {
        contentEscapes(key);
        contentEscapes(val);
        mapassign0(t, m, key, val);
    }

    //go:noescape
    void mapassign_faststr0(abi::Type* t, unsafe::Pointer m, std::string key, unsafe::Pointer val)
    /* convertBlockStmt, nil block */;

    void mapassign_faststr(abi::Type* t, unsafe::Pointer m, std::string key, unsafe::Pointer val)
    {
        contentEscapes((unsafeheader::String*)(unsafe::Pointer(& key))->Data);
        contentEscapes(val);
        mapassign_faststr0(t, m, key, val);
    }

    //go:noescape
    void mapdelete(abi::Type* t, unsafe::Pointer m, unsafe::Pointer key)
    /* convertBlockStmt, nil block */;

    //go:noescape
    void mapdelete_faststr(abi::Type* t, unsafe::Pointer m, std::string key)
    /* convertBlockStmt, nil block */;

    //go:noescape
    void mapiterinit(abi::Type* t, unsafe::Pointer m, struct hiter* it)
    /* convertBlockStmt, nil block */;

    //go:noescape
    unsafe::Pointer mapiterkey(struct hiter* it)
    /* convertBlockStmt, nil block */;

    //go:noescape
    unsafe::Pointer mapiterelem(struct hiter* it)
    /* convertBlockStmt, nil block */;

    //go:noescape
    void mapiternext(struct hiter* it)
    /* convertBlockStmt, nil block */;

    //go:noescape
    int maplen(unsafe::Pointer m)
    /* convertBlockStmt, nil block */;

    void mapclear(abi::Type* t, unsafe::Pointer m)
    /* convertBlockStmt, nil block */;

    // call calls fn with "stackArgsSize" bytes of stack arguments laid out
    // at stackArgs and register arguments laid out in regArgs. frameSize is
    // the total amount of stack space that will be reserved by call, so this
    // should include enough space to spill register arguments to the stack in
    // case of preemption.
    //
    // After fn returns, call copies stackArgsSize-stackRetOffset result bytes
    // back into stackArgs+stackRetOffset before returning, for any return
    // values passed on the stack. Register-based return values will be found
    // in the same regArgs structure.
    //
    // regArgs must also be prepared with an appropriate ReturnIsPtr bitmap
    // indicating which registers will contain pointer-valued return values. The
    // purpose of this bitmap is to keep pointers visible to the GC between
    // returning from reflectcall and actually using them.
    //
    // If copying result bytes back from the stack, the caller must pass the
    // argument frame type as stackArgsType, so that call can execute appropriate
    // write barriers during the copy.
    //
    // Arguments passed through to call do not escape. The type is used only in a
    // very limited callee of call, the stackArgs are copied, and regArgs is only
    // used in the call frame.
    //
    //go:noescape
    //go:linkname call runtime.reflectcall
    void call(abi::Type* stackArgsType, unsafe::Pointer f, unsafe::Pointer stackArgs, uint32_t stackArgsSize, uint32_t stackRetOffset, uint32_t frameSize, abi::RegArgs* regArgs)
    /* convertBlockStmt, nil block */;

    void ifaceE2I(abi::Type* t, go_any src, unsafe::Pointer dst)
    /* convertBlockStmt, nil block */;

    // memmove copies size bytes to dst from src. No write barriers are used.
    //
    //go:noescape
    void memmove(unsafe::Pointer dst, unsafe::Pointer src, uintptr_t size)
    /* convertBlockStmt, nil block */;

    // typedmemmove copies a value of type t to dst from src.
    //
    //go:noescape
    void typedmemmove(abi::Type* t, unsafe::Pointer dst, unsafe::Pointer src)
    /* convertBlockStmt, nil block */;

    // typedmemclr zeros the value at ptr of type t.
    //
    //go:noescape
    void typedmemclr(abi::Type* t, unsafe::Pointer ptr)
    /* convertBlockStmt, nil block */;

    // typedmemclrpartial is like typedmemclr but assumes that
    // dst points off bytes into the value and only clears size bytes.
    //
    //go:noescape
    void typedmemclrpartial(abi::Type* t, unsafe::Pointer ptr, uintptr_t off, uintptr_t size)
    /* convertBlockStmt, nil block */;

    // typedslicecopy copies a slice of elemType values from src to dst,
    // returning the number of elements copied.
    //
    //go:noescape
    int typedslicecopy(abi::Type* t, unsafeheader::Slice dst, unsafeheader::Slice src)
    /* convertBlockStmt, nil block */;

    // typedarrayclear zeroes the value at ptr of an array of elemType,
    // only clears len elem.
    //
    //go:noescape
    void typedarrayclear(abi::Type* elemType, unsafe::Pointer ptr, int len)
    /* convertBlockStmt, nil block */;

    //go:noescape
    uintptr_t typehash(abi::Type* t, unsafe::Pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    bool verifyNotInHeapPtr(uintptr_t p)
    /* convertBlockStmt, nil block */;

    //go:noescape
    unsafeheader::Slice growslice(abi::Type* t, unsafeheader::Slice old, int num)
    /* convertBlockStmt, nil block */;

    // Dummy annotation marking that the value x escapes,
    // for use in cases where the reflect code is so clever that
    // the compiler cannot follow.
    void escapes(go_any x)
    {
        if(dummy.b)
        {
            dummy.x = x;
        }
    }

    struct gocpp_id_11
    {
        bool b;
        go_any x;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.b = this->b;
            result.x = this->x;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (b != ref.b) return false;
            if (x != ref.x) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << b;
            os << " " << x;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_11& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_11 dummy;
    // Dummy annotation marking that the content of value x
    // escapes (i.e. modeling roughly heap=*x),
    // for use in cases where the reflect code is so clever that
    // the compiler cannot follow.
    void contentEscapes(unsafe::Pointer x)
    {
        if(dummy.b)
        {
            escapes(*(go_any*)(x));
        }
    }

    //go:nosplit
    unsafe::Pointer noescape(unsafe::Pointer p)
    {
        auto x = uintptr_t(p);
        return unsafe::Pointer(x ^ 0);
    }

}

