// generated by GoCpp from file '$(ImportDir)/golang.org/x/tour/pic/pic.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/golang.org/x/tour/pic/pic.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/deflate.h"
#include "golang/compress/flate/deflatefast.h"
#include "golang/compress/flate/huffman_bit_writer.h"
#include "golang/compress/flate/huffman_code.h"
#include "golang/compress/flate/token.h"
#include "golang/compress/zlib/writer.h"
#include "golang/encoding/base64/base64.h"
#include "golang/hash/hash.h"
#include "golang/image/color/color.h"
#include "golang/image/geom.h"
#include "golang/image/image.h"
#include "golang/image/png/writer.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/io.h"
#include "golang/os/dir_windows.h"
#include "golang/os/file_windows.h"
#include "golang/os/types.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"

// Package pic implements functions that
// display pictures on the Go playground.
namespace golang::pic
{
    namespace rec
    {
        using namespace mocklib::rec;
        using bufio::rec::Flush;
        using io::rec::Close;
        using png::rec::Encode;
    }

    // Show displays a picture defined by the function f
    // when executed on the Go Playground.
    //
    // f should return a slice of length dy,
    // each element of which is a slice of dx
    // 8-bit unsigned int. The integers are
    // interpreted as bluescale values,
    // where the value 0 means full blue,
    // and the value 255 means full white.
    void Show(std::function<gocpp::slice<gocpp::slice<uint8_t>> (int dx, int dy)> f)
    {
        auto dx = 256;
        auto dy = 256;
        auto data = f(dx, dy);
        auto m = image::NewNRGBA(image::Rect(0, 0, dx, dy));
        for(auto y = 0; y < dy; y++)
        {
            for(auto x = 0; x < dx; x++)
            {
                auto v = data[y][x];
                auto i = y * m->Stride + x * 4;
                m->Pix[i] = v;
                m->Pix[i + 1] = v;
                m->Pix[i + 2] = 255;
                m->Pix[i + 3] = 255;
            }
        }
        ShowImage(m);
    }

    // ShowImage displays the image m
    // when executed on the Go Playground.
    void ShowImage(image::Image m)
    {
        gocpp::Defer defer;
        try
        {
            auto w = bufio::NewWriter(os::Stdout);
            defer.push_back([=]{ rec::Flush(gocpp::recv(w)); });
            io::WriteString(w, "IMAGE:"_s);
            auto b64 = base64::NewEncoder(base64::StdEncoding, w);
            auto err = rec::Encode(gocpp::recv((gocpp::InitPtr<png::Encoder>([=](auto& x) {
                x.CompressionLevel = png::BestCompression;
            }))), b64, m);
            if(err != nullptr)
            {
                gocpp::panic(err);
            }
            rec::Close(gocpp::recv(b64));
            io::WriteString(w, "\n"_s);
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

