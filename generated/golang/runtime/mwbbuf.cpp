// generated by GoCpp from file '$(ImportDir)/runtime/mwbbuf.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mwbbuf.h"
#include "gocpp/support.h"

#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mgcmark.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& wbBuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << " " << end;
        os << " " << buf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct wbBuf& value)
    {
        return value.PrintTo(os);
    }

    void reset(struct wbBuf* b)
    {
        auto start = uintptr_t(unsafe::Pointer(& b->buf[0]));
        b->next = start;
        if(testSmallBuf)
        {
            b->end = uintptr_t(unsafe::Pointer(& b->buf[wbMaxEntriesPerCall + 1]));
        }
        else
        {
            b->end = start + uintptr_t(len(b->buf)) * unsafe::Sizeof(b->buf[0]);
        }
        if((b->end - b->next) % unsafe::Sizeof(b->buf[0]) != 0)
        {
            go_throw("bad write barrier buffer bounds");
        }
    }

    void discard(struct wbBuf* b)
    {
        b->next = uintptr_t(unsafe::Pointer(& b->buf[0]));
    }

    bool empty(struct wbBuf* b)
    {
        return b->next == uintptr_t(unsafe::Pointer(& b->buf[0]));
    }

    gocpp::array<uintptr_t, 1>* get1(struct wbBuf* b)
    {
        if(b->next + goarch::PtrSize > b->end)
        {
            wbBufFlush();
        }
        auto p = (gocpp::array<uintptr_t, 1>*)(unsafe::Pointer(b->next));
        b->next += goarch::PtrSize;
        return p;
    }

    gocpp::array<uintptr_t, 2>* get2(struct wbBuf* b)
    {
        if(b->next + 2 * goarch::PtrSize > b->end)
        {
            wbBufFlush();
        }
        auto p = (gocpp::array<uintptr_t, 2>*)(unsafe::Pointer(b->next));
        b->next += 2 * goarch::PtrSize;
        return p;
    }

    void wbBufFlush()
    {
        if(getg()->m->dying > 0)
        {
            discard(gocpp::recv(ptr(gocpp::recv(getg()->m->p))->wbBuf));
            return;
        }
        systemstack([=]() mutable -> void
        {
            wbBufFlush1(ptr(gocpp::recv(getg()->m->p)));
        }
);
    }

    void wbBufFlush1(p* pp)
    {
        auto start = uintptr_t(unsafe::Pointer(& pp->wbBuf.buf[0]));
        auto n = (pp->wbBuf.next - start) / unsafe::Sizeof(pp->wbBuf.buf[0]);
        auto ptrs = pp->wbBuf.buf.make_slice(0, n);
        pp->wbBuf.next = 0;
        if(useCheckmark)
        {
            for(auto [_, ptr] : ptrs)
            {
                shade(ptr);
            }
            reset(gocpp::recv(pp->wbBuf));
            return;
        }
        auto gcw = & pp->gcw;
        auto pos = 0;
        for(auto [_, ptr] : ptrs)
        {
            if(ptr < minLegalPointer)
            {
                continue;
            }
            auto [obj, span, objIndex] = findObject(ptr, 0, 0);
            if(obj == 0)
            {
                continue;
            }
            auto mbits = markBitsForIndex(gocpp::recv(span), objIndex);
            if(isMarked(gocpp::recv(mbits)))
            {
                continue;
            }
            setMarked(gocpp::recv(mbits));
            auto [arena, pageIdx, pageMask] = pageIndexOf(base(gocpp::recv(span)));
            if(arena->pageMarks[pageIdx] & pageMask == 0)
            {
                atomic::Or8(& arena->pageMarks[pageIdx], pageMask);
            }
            if(noscan(gocpp::recv(span->spanclass)))
            {
                gcw->bytesMarked += uint64_t(span->elemsize);
                continue;
            }
            ptrs[pos] = obj;
            pos++;
        }
        putBatch(gocpp::recv(gcw), ptrs.make_slice(0, pos));
        reset(gocpp::recv(pp->wbBuf));
    }

}

