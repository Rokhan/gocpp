// generated by GoCpp from file '$(ImportDir)/time/zoneinfo_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/zoneinfo_windows.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/internal/syscall/windows/registry/key.h"
#include "golang/internal/syscall/windows/registry/value.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zsyscall_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/time/zoneinfo_abbrs_windows.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
        using registry::rec::Close;
        using registry::rec::GetMUIStringValue;
        using registry::rec::GetStringValue;
        using registry::rec::ReadSubKeyNames;
    }

    gocpp::slice<std::string> platformZoneSources;
    // matchZoneKey checks if stdname and dstname match the corresponding key
    // values "MUI_Std" and MUI_Dlt" or "Std" and "Dlt" in the kname key stored
    // under the open registry key zones.
    std::tuple<bool, struct gocpp::error> matchZoneKey(registry::Key zones, std::string kname, std::string stdname, std::string dstname)
    {
        gocpp::Defer defer;
        try
        {
            bool matched;
            struct gocpp::error err2;
            auto [k, err] = registry::OpenKey(zones, kname, registry::READ);
            if(err != nullptr)
            {
                return {false, err};
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(k)); });
            std::string std = {};
            std::string dlt = {};
            std::tie(std, err) = rec::GetMUIStringValue(gocpp::recv(k), "MUI_Std"s);
            if(err == nullptr)
            {
                std::tie(dlt, err) = rec::GetMUIStringValue(gocpp::recv(k), "MUI_Dlt"s);
            }
            if(err != nullptr)
            {
                if(std::tie(std, gocpp_id_0, err) = rec::GetStringValue(gocpp::recv(k), "Std"s); err != nullptr)
                {
                    return {false, err};
                }
                if(std::tie(dlt, gocpp_id_1, err) = rec::GetStringValue(gocpp::recv(k), "Dlt"s); err != nullptr)
                {
                    return {false, err};
                }
            }
            if(std != stdname)
            {
                return {false, nullptr};
            }
            if(dlt != dstname && dstname != stdname)
            {
                return {false, nullptr};
            }
            return {true, nullptr};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // toEnglishName searches the registry for an English name of a time zone
    // whose zone names are stdname and dstname and returns the English name.
    std::tuple<std::string, struct gocpp::error> toEnglishName(std::string stdname, std::string dstname)
    {
        gocpp::Defer defer;
        try
        {
            auto [k, err] = registry::OpenKey(registry::LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"s, registry::ENUMERATE_SUB_KEYS | registry::QUERY_VALUE);
            if(err != nullptr)
            {
                return {""s, err};
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(k)); });
            gocpp::slice<std::string> names;
            std::tie(names, err) = rec::ReadSubKeyNames(gocpp::recv(k));
            if(err != nullptr)
            {
                return {""s, err};
            }
            for(auto [gocpp_ignored, name] : names)
            {
                auto [matched, err] = matchZoneKey(k, name, stdname, dstname);
                if(err == nullptr && matched)
                {
                    return {name, nullptr};
                }
            }
            return {""s, errors::New("English name for time zone ""s + stdname + "" not found in registry"s)};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // extractCAPS extracts capital letters from description desc.
    std::string extractCAPS(std::string desc)
    {
        gocpp::slice<gocpp::rune> short = {};
        for(auto [gocpp_ignored, c] : desc)
        {
            if('A' <= c && c <= 'Z')
            {
                short = append(short, c);
            }
        }
        return std::string(short);
    }

    // abbrev returns the abbreviations to use for the given zone z.
    std::tuple<std::string, std::string> abbrev(syscall::Timezoneinformation* z)
    {
        std::string std;
        std::string dst;
        auto stdName = syscall::UTF16ToString(z->StandardName.make_slice(0));
        auto [a, ok] = abbrs[stdName];
        if(! ok)
        {
            auto dstName = syscall::UTF16ToString(z->DaylightName.make_slice(0));
            auto [englishName, err] = toEnglishName(stdName, dstName);
            if(err == nullptr)
            {
                std::tie(a, ok) = abbrs[englishName];
                if(ok)
                {
                    return {a.std, a.dst};
                }
            }
            return {extractCAPS(stdName), extractCAPS(dstName)};
        }
        return {a.std, a.dst};
    }

    // pseudoUnix returns the pseudo-Unix time (seconds since Jan 1 1970 *LOCAL TIME*)
    // denoted by the system date+time d in the given year.
    // It is up to the caller to convert this local time into a UTC-based time.
    int64_t pseudoUnix(int year, syscall::Systemtime* d)
    {
        auto day = 1;
        auto t = Date(year, Month(d->Month), day, int(d->Hour), int(d->Minute), int(d->Second), 0, UTC);
        auto i = int(d->DayOfWeek) - int(rec::Weekday(gocpp::recv(t)));
        if(i < 0)
        {
            i += 7;
        }
        day += i;
        if(auto week = int(d->Day) - 1; week < 4)
        {
            day += week * 7;
        }
        else
        {
            day += 4 * 7;
            if(day > daysIn(Month(d->Month), year))
            {
                day -= 7;
            }
        }
        return rec::sec(gocpp::recv(t)) + int64_t(day - 1) * secondsPerDay + internalToUnix;
    }

    void initLocalFromTZI(syscall::Timezoneinformation* i)
    {
        auto l = & localLoc;
        l->name = "Local"s;
        auto nzone = 1;
        if(i->StandardDate.Month > 0)
        {
            nzone++;
        }
        l->zone = gocpp::make(gocpp::Tag<gocpp::slice<zone>>(), nzone);
        auto [stdname, dstname] = abbrev(i);
        auto std = & l->zone[0];
        std->name = stdname;
        if(nzone == 1)
        {
            std->offset = - int(i->Bias) * 60;
            l->cacheStart = alpha;
            l->cacheEnd = omega;
            l->cacheZone = std;
            l->tx = gocpp::make(gocpp::Tag<gocpp::slice<zoneTrans>>(), 1);
            l->tx[0].when = l->cacheStart;
            l->tx[0].index = 0;
            return;
        }
        std->offset = - int(i->Bias + i->StandardBias) * 60;
        auto dst = & l->zone[1];
        dst->name = dstname;
        dst->offset = - int(i->Bias + i->DaylightBias) * 60;
        dst->isDST = true;
        auto d0 = & i->StandardDate;
        auto d1 = & i->DaylightDate;
        auto i0 = 0;
        auto i1 = 1;
        if(d0->Month > d1->Month)
        {
            std::tie(d0, d1) = std::tuple{d1, d0};
            std::tie(i0, i1) = std::tuple{i1, i0};
        }
        l->tx = gocpp::make(gocpp::Tag<gocpp::slice<zoneTrans>>(), 400);
        auto t = rec::UTC(gocpp::recv(Now()));
        auto year = rec::Year(gocpp::recv(t));
        auto txi = 0;
        for(auto y = year - 100; y < year + 100; y++)
        {
            auto tx = & l->tx[txi];
            tx->when = pseudoUnix(y, d0) - int64_t(l->zone[i1].offset);
            tx->index = uint8_t(i0);
            txi++;
            tx = & l->tx[txi];
            tx->when = pseudoUnix(y, d1) - int64_t(l->zone[i0].offset);
            tx->index = uint8_t(i1);
            txi++;
        }
    }

    syscall::Timezoneinformation usPacific = gocpp::Init<syscall::Timezoneinformation>([](auto& x) {
        x.Bias = 8 * 60;
        x.StandardName = gocpp::array<uint16_t, 32> {'P', 'a', 'c', 'i', 'f', 'i', 'c', ' ', 'S', 't', 'a', 'n', 'd', 'a', 'r', 'd', ' ', 'T', 'i', 'm', 'e'};
        x.StandardDate = gocpp::Init<syscall::Systemtime>([](auto& x) {
            x.Month = 11;
            x.Day = 1;
            x.Hour = 2;
        });
        x.DaylightName = gocpp::array<uint16_t, 32> {'P', 'a', 'c', 'i', 'f', 'i', 'c', ' ', 'D', 'a', 'y', 'l', 'i', 'g', 'h', 't', ' ', 'T', 'i', 'm', 'e'};
        x.DaylightDate = gocpp::Init<syscall::Systemtime>([](auto& x) {
            x.Month = 3;
            x.Day = 2;
            x.Hour = 2;
        });
        x.DaylightBias = - 60;
    });
    syscall::Timezoneinformation aus = gocpp::Init<syscall::Timezoneinformation>([](auto& x) {
        x.Bias = - 10 * 60;
        x.StandardName = gocpp::array<uint16_t, 32> {'A', 'U', 'S', ' ', 'E', 'a', 's', 't', 'e', 'r', 'n', ' ', 'S', 't', 'a', 'n', 'd', 'a', 'r', 'd', ' ', 'T', 'i', 'm', 'e'};
        x.StandardDate = gocpp::Init<syscall::Systemtime>([](auto& x) {
            x.Month = 4;
            x.Day = 1;
            x.Hour = 3;
        });
        x.DaylightName = gocpp::array<uint16_t, 32> {'A', 'U', 'S', ' ', 'E', 'a', 's', 't', 'e', 'r', 'n', ' ', 'D', 'a', 'y', 'l', 'i', 'g', 'h', 't', ' ', 'T', 'i', 'm', 'e'};
        x.DaylightDate = gocpp::Init<syscall::Systemtime>([](auto& x) {
            x.Month = 10;
            x.Day = 1;
            x.Hour = 2;
        });
        x.DaylightBias = - 60;
    });
    void initLocal()
    {
        syscall::Timezoneinformation i = {};
        if(auto [gocpp_id_2, err] = syscall::GetTimeZoneInformation(& i); err != nullptr)
        {
            localLoc.name = "UTC"s;
            return;
        }
        initLocalFromTZI(& i);
    }

}

