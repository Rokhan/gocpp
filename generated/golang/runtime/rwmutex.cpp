// generated by GoCpp from file '$(ImportDir)/runtime/rwmutex.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/rwmutex.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
    }

    // A rwmutex is a reader/writer mutual exclusion lock.
    // The lock can be held by an arbitrary number of readers or a single writer.
    // This is a variant of sync.RWMutex, for the runtime package.
    // Like mutex, rwmutex blocks the calling M.
    // It does not interact with the goroutine scheduler.
    
    template<typename T> requires gocpp::GoStruct<T>
    rwmutex::operator T()
    {
        T result;
        result.rLock = this->rLock;
        result.readers = this->readers;
        result.readerPass = this->readerPass;
        result.wLock = this->wLock;
        result.writer = this->writer;
        result.readerCount = this->readerCount;
        result.readerWait = this->readerWait;
        result.readRank = this->readRank;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool rwmutex::operator==(const T& ref) const
    {
        if (rLock != ref.rLock) return false;
        if (readers != ref.readers) return false;
        if (readerPass != ref.readerPass) return false;
        if (wLock != ref.wLock) return false;
        if (writer != ref.writer) return false;
        if (readerCount != ref.readerCount) return false;
        if (readerWait != ref.readerWait) return false;
        if (readRank != ref.readRank) return false;
        return true;
    }

    std::ostream& rwmutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << rLock;
        os << " " << readers;
        os << " " << readerPass;
        os << " " << wLock;
        os << " " << writer;
        os << " " << readerCount;
        os << " " << readerWait;
        os << " " << readRank;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rwmutex& value)
    {
        return value.PrintTo(os);
    }

    // Lock ranking an rwmutex has two aspects:
    //
    // Semantic ranking: this rwmutex represents some higher level lock that
    // protects some resource (e.g., allocmLock protects creation of new Ms). The
    // read and write locks of that resource need to be represented in the lock
    // rank.
    //
    // Internal ranking: as an implementation detail, rwmutex uses two mutexes:
    // rLock and wLock. These have lock order requirements: wLock must be locked
    // before rLock. This also needs to be represented in the lock rank.
    //
    // Semantic ranking is represented by acquiring readRank during read lock and
    // writeRank during write lock.
    //
    // wLock is held for the duration of a write lock, so it uses writeRank
    // directly, both for semantic and internal ranking. rLock is only held
    // temporarily inside the rlock/lock methods, so it uses readRankInternal to
    // represent internal ranking. Semantic ranking is represented by a separate
    // acquire of readRank for the duration of a read lock.
    //
    // The lock ranking must document this ordering:
    // - readRankInternal is a leaf lock.
    // - readRank is taken before readRankInternal.
    // - writeRank is taken before readRankInternal.
    // - readRank is placed in the lock order wherever a read lock of this rwmutex
    //   belongs.
    // - writeRank is placed in the lock order wherever a write lock of this
    //   rwmutex belongs.
    void rec::init(struct rwmutex* rw, golang::runtime::lockRank readRank, golang::runtime::lockRank readRankInternal, golang::runtime::lockRank writeRank)
    {
        rw->readRank = readRank;
        lockInit(& rw->rLock, readRankInternal);
        lockInit(& rw->wLock, writeRank);
    }

    // rlock locks rw for reading.
    void rec::rlock(struct rwmutex* rw)
    {
        acquirem();
        acquireLockRank(rw->readRank);
        lockWithRankMayAcquire(& rw->rLock, getLockRank(& rw->rLock));
        if(rec::Add(gocpp::recv(rw->readerCount), 1) < 0)
        {
            systemstack([=]() mutable -> void
            {
                lock(& rw->rLock);
                if(rw->readerPass > 0)
                {
                    rw->readerPass -= 1;
                    unlock(& rw->rLock);
                }
                else
                {
                    auto m = getg()->m;
                    m->schedlink = rw->readers;
                    rec::set(gocpp::recv(rw->readers), m);
                    unlock(& rw->rLock);
                    notesleep(& m->park);
                    noteclear(& m->park);
                }
            });
        }
    }

    // runlock undoes a single rlock call on rw.
    void rec::runlock(struct rwmutex* rw)
    {
        if(auto r = rec::Add(gocpp::recv(rw->readerCount), - 1); r < 0)
        {
            if(r + 1 == 0 || r + 1 == - rwmutexMaxReaders)
            {
                go_throw("runlock of unlocked rwmutex"s);
            }
            if(rec::Add(gocpp::recv(rw->readerWait), - 1) == 0)
            {
                lock(& rw->rLock);
                auto w = rec::ptr(gocpp::recv(rw->writer));
                if(w != nullptr)
                {
                    notewakeup(& w->park);
                }
                unlock(& rw->rLock);
            }
        }
        releaseLockRank(rw->readRank);
        releasem(getg()->m);
    }

    // lock locks rw for writing.
    void rec::lock(struct rwmutex* rw)
    {
        lock(& rw->wLock);
        auto m = getg()->m;
        auto r = rec::Add(gocpp::recv(rw->readerCount), - rwmutexMaxReaders) + rwmutexMaxReaders;
        lock(& rw->rLock);
        if(r != 0 && rec::Add(gocpp::recv(rw->readerWait), r) != 0)
        {
            systemstack([=]() mutable -> void
            {
                rec::set(gocpp::recv(rw->writer), m);
                unlock(& rw->rLock);
                notesleep(& m->park);
                noteclear(& m->park);
            });
        }
        else
        {
            unlock(& rw->rLock);
        }
    }

    // unlock unlocks rw for writing.
    void rec::unlock(struct rwmutex* rw)
    {
        auto r = rec::Add(gocpp::recv(rw->readerCount), rwmutexMaxReaders);
        if(r >= rwmutexMaxReaders)
        {
            go_throw("unlock of unlocked rwmutex"s);
        }
        lock(& rw->rLock);
        for(; rec::ptr(gocpp::recv(rw->readers)) != nullptr; )
        {
            auto reader = rec::ptr(gocpp::recv(rw->readers));
            rw->readers = reader->schedlink;
            rec::set(gocpp::recv(reader->schedlink), nullptr);
            notewakeup(& reader->park);
            r -= 1;
        }
        rw->readerPass += uint32_t(r);
        unlock(& rw->rLock);
        unlock(& rw->wLock);
    }

}

