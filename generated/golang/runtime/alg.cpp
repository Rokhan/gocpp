// generated by GoCpp from file '$(ImportDir)/runtime/alg.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/alg.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/hash64.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace goarch::rec;
        using namespace runtime::rec;
        using namespace unsafe::rec;
    }

    uintptr_t memhash0(unsafe::Pointer p, uintptr_t h)
    {
        return h;
    }

    uintptr_t memhash8(unsafe::Pointer p, uintptr_t h)
    {
        return memhash(p, h, 1);
    }

    uintptr_t memhash16(unsafe::Pointer p, uintptr_t h)
    {
        return memhash(p, h, 2);
    }

    uintptr_t memhash128(unsafe::Pointer p, uintptr_t h)
    {
        return memhash(p, h, 16);
    }

    uintptr_t memhash_varlen(unsafe::Pointer p, uintptr_t h)
    {
        auto ptr = getclosureptr();
        auto size = *(uintptr_t*)(unsafe::Pointer(ptr + gocpp::Sizeof<uintptr_t>()));
        return memhash(p, h, size);
    }

    bool useAeshash;
    uintptr_t memhash(unsafe::Pointer p, uintptr_t h, uintptr_t s)
    /* convertBlockStmt, nil block */;

    uintptr_t memhash32(unsafe::Pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    uintptr_t memhash64(unsafe::Pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    uintptr_t strhash(unsafe::Pointer p, uintptr_t h)
    /* convertBlockStmt, nil block */;

    uintptr_t strhashFallback(unsafe::Pointer a, uintptr_t h)
    {
        auto x = (stringStruct*)(a);
        return memhashFallback(x->str, h, uintptr_t(x->len));
    }

    uintptr_t f32hash(unsafe::Pointer p, uintptr_t h)
    {
        auto f = *(float*)(p);
        //Go switch emulation
        {
            int conditionId = -1;
            if(f == 0) { conditionId = 0; }
            else if(f != f) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return c1 * (c0 ^ h);
                    break;
                case 1:
                    return c1 * (c0 ^ h ^ uintptr_t(rand()));
                    break;
                default:
                    return memhash(p, h, 4);
                    break;
            }
        }
    }

    uintptr_t f64hash(unsafe::Pointer p, uintptr_t h)
    {
        auto f = *(double*)(p);
        //Go switch emulation
        {
            int conditionId = -1;
            if(f == 0) { conditionId = 0; }
            else if(f != f) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return c1 * (c0 ^ h);
                    break;
                case 1:
                    return c1 * (c0 ^ h ^ uintptr_t(rand()));
                    break;
                default:
                    return memhash(p, h, 8);
                    break;
            }
        }
    }

    uintptr_t c64hash(unsafe::Pointer p, uintptr_t h)
    {
        auto x = (gocpp::array<float, 2>*)(p);
        return f32hash(unsafe::Pointer(& x[1]), f32hash(unsafe::Pointer(& x[0]), h));
    }

    uintptr_t c128hash(unsafe::Pointer p, uintptr_t h)
    {
        auto x = (gocpp::array<double, 2>*)(p);
        return f64hash(unsafe::Pointer(& x[1]), f64hash(unsafe::Pointer(& x[0]), h));
    }

    uintptr_t interhash(unsafe::Pointer p, uintptr_t h)
    {
        auto a = (iface*)(p);
        auto tab = a->tab;
        if(tab == nullptr)
        {
            return h;
        }
        auto t = tab->_type;
        if(t->Equal == nullptr)
        {
            gocpp::panic(errorString("hash of unhashable type " + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return c1 * typehash(t, unsafe::Pointer(& a->data), h ^ c0);
        }
        else
        {
            return c1 * typehash(t, a->data, h ^ c0);
        }
    }

    uintptr_t nilinterhash(unsafe::Pointer p, uintptr_t h)
    {
        auto a = (eface*)(p);
        auto t = a->_type;
        if(t == nullptr)
        {
            return h;
        }
        if(t->Equal == nullptr)
        {
            gocpp::panic(errorString("hash of unhashable type " + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return c1 * typehash(t, unsafe::Pointer(& a->data), h ^ c0);
        }
        else
        {
            return c1 * typehash(t, a->data, h ^ c0);
        }
    }

    uintptr_t typehash(struct _type* t, unsafe::Pointer p, uintptr_t h)
    {
        if(t->TFlag & abi::TFlagRegularMemory != 0)
        {
            //Go switch emulation
            {
                auto condition = t->Size_;
                int conditionId = -1;
                if(condition == 4) { conditionId = 0; }
                else if(condition == 8) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        return memhash32(p, h);
                        break;
                    case 1:
                        return memhash64(p, h);
                        break;
                    default:
                        return memhash(p, h, t->Size_);
                        break;
                }
            }
        }
        //Go switch emulation
        {
            auto condition = t->Kind_ & kindMask;
            int conditionId = -1;
            if(condition == kindFloat32) { conditionId = 0; }
            else if(condition == kindFloat64) { conditionId = 1; }
            else if(condition == kindComplex64) { conditionId = 2; }
            else if(condition == kindComplex128) { conditionId = 3; }
            else if(condition == kindString) { conditionId = 4; }
            else if(condition == kindInterface) { conditionId = 5; }
            else if(condition == kindArray) { conditionId = 6; }
            else if(condition == kindStruct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return f32hash(p, h);
                    break;
                case 1:
                    return f64hash(p, h);
                    break;
                case 2:
                    return c64hash(p, h);
                    break;
                case 3:
                    return c128hash(p, h);
                    break;
                case 4:
                    return strhash(p, h);
                    break;
                case 5:
                    auto i = (interfacetype*)(unsafe::Pointer(t));
                    if(len(i->Methods) == 0)
                    {
                        return nilinterhash(p, h);
                    }
                    return interhash(p, h);
                    break;
                case 6:
                    auto a = (arraytype*)(unsafe::Pointer(t));
                    for(auto i = uintptr_t(0); i < a->Len; i++)
                    {
                        h = typehash(a->Elem, add(p, i * a->Elem->Size_), h);
                    }
                    return h;
                    break;
                case 7:
                    auto s = (structtype*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : s->Fields)
                    {
                        if(rec::IsBlank(gocpp::recv(f.Name)))
                        {
                            continue;
                        }
                        h = typehash(f.Typ, add(p, f.Offset), h);
                    }
                    return h;
                    break;
                default:
                    gocpp::panic(errorString("hash of unhashable type " + rec::string(gocpp::recv(toRType(t)))));
                    break;
            }
        }
    }

    struct gocpp::error mapKeyError(struct maptype* t, unsafe::Pointer p)
    {
        if(! rec::HashMightPanic(gocpp::recv(t)))
        {
            return nullptr;
        }
        return mapKeyError2(t->Key, p);
    }

    struct gocpp::error mapKeyError2(struct _type* t, unsafe::Pointer p)
    {
        if(t->TFlag & abi::TFlagRegularMemory != 0)
        {
            return nullptr;
        }
        //Go switch emulation
        {
            auto condition = t->Kind_ & kindMask;
            int conditionId = -1;
            if(condition == kindFloat32) { conditionId = 0; }
            if(condition == kindFloat64) { conditionId = 1; }
            if(condition == kindComplex64) { conditionId = 2; }
            if(condition == kindComplex128) { conditionId = 3; }
            if(condition == kindString) { conditionId = 4; }
            else if(condition == kindInterface) { conditionId = 5; }
            else if(condition == kindArray) { conditionId = 6; }
            else if(condition == kindStruct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    return nullptr;
                    break;
                case 5:
                    auto i = (interfacetype*)(unsafe::Pointer(t));
                    _type* t = {};
                    unsafe::Pointer* pdata = {};
                    if(len(i->Methods) == 0)
                    {
                        auto a = (eface*)(p);
                        t = a->_type;
                        if(t == nullptr)
                        {
                            return nullptr;
                        }
                        pdata = & a->data;
                    }
                    else
                    {
                        auto a = (iface*)(p);
                        if(a->tab == nullptr)
                        {
                            return nullptr;
                        }
                        t = a->tab->_type;
                        pdata = & a->data;
                    }
                    if(t->Equal == nullptr)
                    {
                        return errorString("hash of unhashable type " + rec::string(gocpp::recv(toRType(t))));
                    }
                    if(isDirectIface(t))
                    {
                        return mapKeyError2(t, unsafe::Pointer(pdata));
                    }
                    else
                    {
                        return mapKeyError2(t, *pdata);
                    }
                    break;
                case 6:
                    auto a = (arraytype*)(unsafe::Pointer(t));
                    for(auto i = uintptr_t(0); i < a->Len; i++)
                    {
                        if(auto err = mapKeyError2(a->Elem, add(p, i * a->Elem->Size_)); err != nullptr)
                        {
                            return err;
                        }
                    }
                    return nullptr;
                    break;
                case 7:
                    auto s = (structtype*)(unsafe::Pointer(t));
                    for(auto [gocpp_ignored, f] : s->Fields)
                    {
                        if(rec::IsBlank(gocpp::recv(f.Name)))
                        {
                            continue;
                        }
                        if(auto err = mapKeyError2(f.Typ, add(p, f.Offset)); err != nullptr)
                        {
                            return err;
                        }
                    }
                    return nullptr;
                    break;
                default:
                    return errorString("hash of unhashable type " + rec::string(gocpp::recv(toRType(t))));
                    break;
            }
        }
    }

    uintptr_t reflect_typehash(struct _type* t, unsafe::Pointer p, uintptr_t h)
    {
        return typehash(t, p, h);
    }

    bool memequal0(unsafe::Pointer p, unsafe::Pointer q)
    {
        return true;
    }

    bool memequal8(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(int8_t*)(p) == *(int8_t*)(q);
    }

    bool memequal16(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(int16_t*)(p) == *(int16_t*)(q);
    }

    bool memequal32(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(int32_t*)(p) == *(int32_t*)(q);
    }

    bool memequal64(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(int64_t*)(p) == *(int64_t*)(q);
    }

    bool memequal128(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(gocpp::array<int64_t, 2>*)(p) == *(gocpp::array<int64_t, 2>*)(q);
    }

    bool f32equal(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(float*)(p) == *(float*)(q);
    }

    bool f64equal(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(double*)(p) == *(double*)(q);
    }

    bool c64equal(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(gocpp::complex64*)(p) == *(gocpp::complex64*)(q);
    }

    bool c128equal(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(gocpp::complex128*)(p) == *(gocpp::complex128*)(q);
    }

    bool strequal(unsafe::Pointer p, unsafe::Pointer q)
    {
        return *(std::string*)(p) == *(std::string*)(q);
    }

    bool interequal(unsafe::Pointer p, unsafe::Pointer q)
    {
        auto x = *(iface*)(p);
        auto y = *(iface*)(q);
        return x.tab == y.tab && ifaceeq(x.tab, x.data, y.data);
    }

    bool nilinterequal(unsafe::Pointer p, unsafe::Pointer q)
    {
        auto x = *(eface*)(p);
        auto y = *(eface*)(q);
        return x._type == y._type && efaceeq(x._type, x.data, y.data);
    }

    bool efaceeq(struct _type* t, unsafe::Pointer x, unsafe::Pointer y)
    {
        if(t == nullptr)
        {
            return true;
        }
        auto eq = t->Equal;
        if(eq == nullptr)
        {
            gocpp::panic(errorString("comparing uncomparable type " + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return x == y;
        }
        return eq(x, y);
    }

    bool ifaceeq(struct itab* tab, unsafe::Pointer x, unsafe::Pointer y)
    {
        if(tab == nullptr)
        {
            return true;
        }
        auto t = tab->_type;
        auto eq = t->Equal;
        if(eq == nullptr)
        {
            gocpp::panic(errorString("comparing uncomparable type " + rec::string(gocpp::recv(toRType(t)))));
        }
        if(isDirectIface(t))
        {
            return x == y;
        }
        return eq(x, y);
    }

    uintptr_t stringHash(std::string s, uintptr_t seed)
    {
        return strhash(noescape(unsafe::Pointer(& s)), seed);
    }

    uintptr_t bytesHash(gocpp::slice<unsigned char> b, uintptr_t seed)
    {
        auto s = (slice*)(unsafe::Pointer(& b));
        return memhash(s->array, seed, uintptr_t(s->len));
    }

    uintptr_t int32Hash(uint32_t i, uintptr_t seed)
    {
        return memhash32(noescape(unsafe::Pointer(& i)), seed);
    }

    uintptr_t int64Hash(uint64_t i, uintptr_t seed)
    {
        return memhash64(noescape(unsafe::Pointer(& i)), seed);
    }

    uintptr_t efaceHash(go_any i, uintptr_t seed)
    {
        return nilinterhash(noescape(unsafe::Pointer(& i)), seed);
    }

    
    template<typename T>
    gocpp_id_0::gocpp_id_0(T& ref)
    {
        value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    gocpp_id_0::gocpp_id_0(const T& ref)
    {
        value.reset(new gocpp_id_0Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    gocpp_id_0::gocpp_id_0(T* ptr)
    {
        value.reset(new gocpp_id_0Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& gocpp_id_0::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void gocpp_id_0::gocpp_id_0Impl<T, StoreT>::vF()
    {
        return rec::F(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        void F(const gocpp::PtrRecv<gocpp_id_0, false>& self)
        {
            return self.ptr->value->vF();
        }

        void F(const gocpp::ObjRecv<gocpp_id_0>& self)
        {
            return self.obj.value->vF();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    uintptr_t ifaceHash(gocpp_id_0 i, uintptr_t seed)
    {
        return interhash(noescape(unsafe::Pointer(& i)), seed);
    }

    gocpp::array<unsigned char, hashRandomBytes> aeskeysched;
    gocpp::array<uintptr_t, 4> hashkey;
    void alginit()
    {
        if((GOARCH == "386" || GOARCH == "amd64") && cpu::X86.HasAES && cpu::X86.HasSSSE3 && cpu::X86.HasSSE41)
        {
            initAlgAES();
            return;
        }
        if(GOARCH == "arm64" && cpu::ARM64.HasAES)
        {
            initAlgAES();
            return;
        }
        for(auto [i, gocpp_ignored] : hashkey)
        {
            hashkey[i] = uintptr_t(rand()) | 1;
        }
    }

    void initAlgAES()
    {
        useAeshash = true;
        auto key = (gocpp::array<uint64_t, hashRandomBytes / 8>*)(unsafe::Pointer(& aeskeysched));
        for(auto [i, gocpp_ignored] : key)
        {
            key[i] = bootstrapRand();
        }
    }

    uint32_t readUnaligned32(unsafe::Pointer p)
    {
        auto q = (gocpp::array<unsigned char, 4>*)(p);
        if(goarch::BigEndian)
        {
            return uint32_t(q[3]) | (uint32_t(q[2]) << 8) | (uint32_t(q[1]) << 16) | (uint32_t(q[0]) << 24);
        }
        return uint32_t(q[0]) | (uint32_t(q[1]) << 8) | (uint32_t(q[2]) << 16) | (uint32_t(q[3]) << 24);
    }

    uint64_t readUnaligned64(unsafe::Pointer p)
    {
        auto q = (gocpp::array<unsigned char, 8>*)(p);
        if(goarch::BigEndian)
        {
            return uint64_t(q[7]) | (uint64_t(q[6]) << 8) | (uint64_t(q[5]) << 16) | (uint64_t(q[4]) << 24) | (uint64_t(q[3]) << 32) | (uint64_t(q[2]) << 40) | (uint64_t(q[1]) << 48) | (uint64_t(q[0]) << 56);
        }
        return uint64_t(q[0]) | (uint64_t(q[1]) << 8) | (uint64_t(q[2]) << 16) | (uint64_t(q[3]) << 24) | (uint64_t(q[4]) << 32) | (uint64_t(q[5]) << 40) | (uint64_t(q[6]) << 48) | (uint64_t(q[7]) << 56);
    }

}

