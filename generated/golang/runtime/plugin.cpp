// generated by GoCpp from file '$(ImportDir)/runtime/plugin.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/plugin.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/runtime/iface.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using abi::rec::Name;
    }

    //go:linkname plugin_lastmoduleinit plugin.lastmoduleinit
    std::tuple<gocpp::string, gocpp::map<gocpp::string, go_any>, gocpp::slice<initTask*>, gocpp::string> plugin_lastmoduleinit()
    {
        gocpp::string path;
        gocpp::map<gocpp::string, go_any> syms;
        gocpp::slice<initTask*> initTasks;
        gocpp::string errstr;
        moduledata* md = {};
        for(auto pmd = firstmoduledata.next; pmd != nullptr; pmd = pmd->next)
        {
            if(pmd->bad)
            {
                md = nullptr;
                continue;
            }
            md = pmd;
        }
        if(md == nullptr)
        {
            go_throw("runtime: no plugin module data"_s);
        }
        if(md->pluginpath == ""_s)
        {
            go_throw("runtime: plugin has empty pluginpath"_s);
        }
        if(md->typemap != nullptr)
        {
            return {""_s, nullptr, nullptr, "plugin already loaded"_s};
        }
        for(auto [gocpp_ignored, pmd] : activeModules())
        {
            if(pmd->pluginpath == md->pluginpath)
            {
                md->bad = true;
                return {""_s, nullptr, nullptr, "plugin already loaded"_s};
            }
            if(inRange(pmd->text, pmd->etext, md->text, md->etext) || inRange(pmd->bss, pmd->ebss, md->bss, md->ebss) || inRange(pmd->data, pmd->edata, md->data, md->edata) || inRange(pmd->types, pmd->etypes, md->types, md->etypes))
            {
                println("plugin: new module data overlaps with previous moduledata"_s);
                println("\tpmd.text-etext="_s, hex(pmd->text), "-"_s, hex(pmd->etext));
                println("\tpmd.bss-ebss="_s, hex(pmd->bss), "-"_s, hex(pmd->ebss));
                println("\tpmd.data-edata="_s, hex(pmd->data), "-"_s, hex(pmd->edata));
                println("\tpmd.types-etypes="_s, hex(pmd->types), "-"_s, hex(pmd->etypes));
                println("\tmd.text-etext="_s, hex(md->text), "-"_s, hex(md->etext));
                println("\tmd.bss-ebss="_s, hex(md->bss), "-"_s, hex(md->ebss));
                println("\tmd.data-edata="_s, hex(md->data), "-"_s, hex(md->edata));
                println("\tmd.types-etypes="_s, hex(md->types), "-"_s, hex(md->etypes));
                go_throw("plugin: new module data overlaps with previous moduledata"_s);
            }
        }
        for(auto [gocpp_ignored, pkghash] : md->pkghashes)
        {
            if(pkghash.linktimehash != *pkghash.runtimehash)
            {
                md->bad = true;
                return {""_s, nullptr, nullptr, "plugin was built with a different version of package "_s + pkghash.modulename};
            }
        }
        modulesinit();
        typelinksinit();
        pluginftabverify(md);
        moduledataverify1(md);
        lock(& itabLock);
        for(auto [gocpp_ignored, i] : md->itablinks)
        {
            itabAdd(i);
        }
        unlock(& itabLock);
        syms = gocpp::make(gocpp::Tag<gocpp::map<gocpp::string, go_any>>(), len(md->ptab));
        for(auto [gocpp_ignored, ptab] : md->ptab)
        {
            auto symName = resolveNameOff(unsafe::Pointer(md->types), ptab.name);
            auto t = rec::typeOff(gocpp::recv(toRType((runtime::_type*)(unsafe::Pointer(md->types)))), ptab.typ);
            go_any val = {};
            auto valp = (gocpp::array<unsafe::Pointer, 2>*)(unsafe::Pointer(& val));
            (*valp)[0] = unsafe::Pointer(t);
            auto name = rec::Name(gocpp::recv(symName));
            if(t->Kind_ & kindMask == kindFunc)
            {
                name = "."_s + name;
            }
            syms[name] = val;
        }
        return {md->pluginpath, syms, md->inittasks, ""_s};
    }

    void pluginftabverify(struct moduledata* md)
    {
        auto badtable = false;
        for(auto i = 0; i < len(md->ftab); i++)
        {
            auto entry = rec::textAddr(gocpp::recv(md), md->ftab[i].entryoff);
            if(md->minpc <= entry && entry <= md->maxpc)
            {
                continue;
            }
            auto f = funcInfo {(_func*)(unsafe::Pointer(& md->pclntable[md->ftab[i].funcoff])), md};
            auto name = funcname(f);
            auto name2 = "none"_s;
            auto entry2 = uintptr_t(0);
            auto f2 = findfunc(entry);
            if(rec::valid(gocpp::recv(f2)))
            {
                name2 = funcname(f2);
                entry2 = rec::entry(gocpp::recv(f2));
            }
            badtable = true;
            println("ftab entry"_s, hex(entry), "/"_s, hex(entry2), ": "_s, name, "/"_s, name2, "outside pc range:["_s, hex(md->minpc), ","_s, hex(md->maxpc), "], modulename="_s, md->modulename, ", pluginpath="_s, md->pluginpath);
        }
        if(badtable)
        {
            go_throw("runtime: plugin has bad symbol table"_s);
        }
    }

    // inRange reports whether v0 or v1 are in the range [r0, r1].
    bool inRange(uintptr_t r0, uintptr_t r1, uintptr_t v0, uintptr_t v1)
    {
        return (v0 >= r0 && v0 <= r1) || (v1 >= r0 && v1 <= r1);
    }

    // A ptabEntry is generated by the compiler for each exported function
    // and global variable in the main package of a plugin. It is used to
    // initialize the plugin module's symbol map.
    
    template<typename T> requires gocpp::GoStruct<T>
    ptabEntry::operator T()
    {
        T result;
        result.name = this->name;
        result.typ = this->typ;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ptabEntry::operator==(const T& ref) const
    {
        if (name != ref.name) return false;
        if (typ != ref.typ) return false;
        return true;
    }

    std::ostream& ptabEntry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << typ;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ptabEntry& value)
    {
        return value.PrintTo(os);
    }

}

