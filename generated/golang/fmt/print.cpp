// generated by GoCpp from file '$(ImportDir)/fmt/print.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/fmt/print.h"
#include "gocpp/support.h"

#include "golang/fmt/format.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/fmtsort/sort.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/io.h"
#include "golang/os/dir_windows.h"
#include "golang/os/file_windows.h"
#include "golang/os/types.h"
#include "golang/reflect/type.h"
#include "golang/reflect/value.h"
#include "golang/strconv/itoa.h"
#include "golang/sync/cond.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/unicode/utf8/utf8.h"

namespace golang::fmt
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace fmt::rec;
        using namespace fmtsort::rec;
        using namespace io::rec;
        using namespace os::rec;
        using namespace poll::rec;
        using namespace reflect::rec;
        using namespace strconv::rec;
        using namespace sync::rec;
        using namespace syscall::rec;
        using namespace utf8::rec;
        using namespace windows::rec;
    }

    std::string commaSpaceString = ", ";
    std::string nilAngleString = "<nil>";
    std::string nilParenString = "(nil)";
    std::string nilString = "nil";
    std::string mapString = "map[";
    std::string percentBangString = "%!";
    std::string missingString = "(MISSING)";
    std::string badIndexString = "(BADINDEX)";
    std::string panicString = "(PANIC=";
    std::string extraString = "%!(EXTRA ";
    std::string badWidthString = "%!(BADWIDTH)";
    std::string badPrecString = "%!(BADPREC)";
    std::string noVerbString = "%!(NOVERB)";
    std::string invReflectString = "<invalid reflect.Value>";
    
    template<typename T>
    State::State(T& ref)
    {
        value.reset(new StateImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    State::State(const T& ref)
    {
        value.reset(new StateImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    State::State(T* ptr)
    {
        value.reset(new StateImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& State::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, struct gocpp::error> State::StateImpl<T, StoreT>::vWrite(gocpp::slice<unsigned char> b)
    {
        return rec::Write(gocpp::PtrRecv<T, false>(value.get()), b);
    }
    template<typename T, typename StoreT>
    std::tuple<int, bool> State::StateImpl<T, StoreT>::vWidth()
    {
        return rec::Width(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::tuple<int, bool> State::StateImpl<T, StoreT>::vPrecision()
    {
        return rec::Precision(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool State::StateImpl<T, StoreT>::vFlag(int c)
    {
        return rec::Flag(gocpp::PtrRecv<T, false>(value.get()), c);
    }

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Write(const gocpp::PtrRecv<struct State, false>& self, gocpp::slice<unsigned char> b)
        {
            return self.ptr->value->vWrite(b);
        }

        std::tuple<int, struct gocpp::error> Write(const gocpp::ObjRecv<struct State>& self, gocpp::slice<unsigned char> b)
        {
            return self.obj.value->vWrite(b);
        }

        std::tuple<int, bool> Width(const gocpp::PtrRecv<struct State, false>& self)
        {
            return self.ptr->value->vWidth();
        }

        std::tuple<int, bool> Width(const gocpp::ObjRecv<struct State>& self)
        {
            return self.obj.value->vWidth();
        }

        std::tuple<int, bool> Precision(const gocpp::PtrRecv<struct State, false>& self)
        {
            return self.ptr->value->vPrecision();
        }

        std::tuple<int, bool> Precision(const gocpp::ObjRecv<struct State>& self)
        {
            return self.obj.value->vPrecision();
        }

        bool Flag(const gocpp::PtrRecv<struct State, false>& self, int c)
        {
            return self.ptr->value->vFlag(c);
        }

        bool Flag(const gocpp::ObjRecv<struct State>& self, int c)
        {
            return self.obj.value->vFlag(c);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct State& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Formatter::Formatter(T& ref)
    {
        value.reset(new FormatterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Formatter::Formatter(const T& ref)
    {
        value.reset(new FormatterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Formatter::Formatter(T* ptr)
    {
        value.reset(new FormatterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Formatter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    void Formatter::FormatterImpl<T, StoreT>::vFormat(struct State f, gocpp::rune verb)
    {
        return rec::Format(gocpp::PtrRecv<T, false>(value.get()), f, verb);
    }

    namespace rec
    {
        void Format(const gocpp::PtrRecv<struct Formatter, false>& self, struct State f, gocpp::rune verb)
        {
            return self.ptr->value->vFormat(f, verb);
        }

        void Format(const gocpp::ObjRecv<struct Formatter>& self, struct State f, gocpp::rune verb)
        {
            return self.obj.value->vFormat(f, verb);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Formatter& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Stringer::Stringer(T& ref)
    {
        value.reset(new StringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Stringer::Stringer(const T& ref)
    {
        value.reset(new StringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Stringer::Stringer(T* ptr)
    {
        value.reset(new StringerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Stringer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string Stringer::StringerImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::string String(const gocpp::PtrRecv<struct Stringer, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<struct Stringer>& self)
        {
            return self.obj.value->vString();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Stringer& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    GoStringer::GoStringer(T& ref)
    {
        value.reset(new GoStringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    GoStringer::GoStringer(const T& ref)
    {
        value.reset(new GoStringerImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    GoStringer::GoStringer(T* ptr)
    {
        value.reset(new GoStringerImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& GoStringer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string GoStringer::GoStringerImpl<T, StoreT>::vGoString()
    {
        return rec::GoString(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::string GoString(const gocpp::PtrRecv<struct GoStringer, false>& self)
        {
            return self.ptr->value->vGoString();
        }

        std::string GoString(const gocpp::ObjRecv<struct GoStringer>& self)
        {
            return self.obj.value->vGoString();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct GoStringer& value)
    {
        return value.PrintTo(os);
    }

    std::string FormatString(struct State state, gocpp::rune verb)
    {
        gocpp::array<unsigned char, 16> tmp = {};
        auto b = append(tmp.make_slice(0, 0), '%');
        for(auto [gocpp_ignored, c] : " +-#0")
        {
            if(rec::Flag(gocpp::recv(state), int(c)))
            {
                b = append(b, unsigned char(c));
            }
        }
        if(auto [w, ok] = rec::Width(gocpp::recv(state)); ok)
        {
            b = strconv::AppendInt(b, int64_t(w), 10);
        }
        if(auto [p, ok] = rec::Precision(gocpp::recv(state)); ok)
        {
            b = append(b, '.');
            b = strconv::AppendInt(b, int64_t(p), 10);
        }
        b = utf8::AppendRune(b, verb);
        return string(b);
    }

    void rec::write(golang::fmt::buffer* b, gocpp::slice<unsigned char> p)
    {
        *b = append(*b, p);
    }

    void rec::writeString(golang::fmt::buffer* b, std::string s)
    {
        *b = append(*b, s);
    }

    void rec::writeByte(golang::fmt::buffer* b, unsigned char c)
    {
        *b = append(*b, c);
    }

    void rec::writeRune(golang::fmt::buffer* b, gocpp::rune r)
    {
        *b = utf8::AppendRune(*b, r);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pp::operator T()
    {
        T result;
        result.buf = this->buf;
        result.arg = this->arg;
        result.value = this->value;
        result.fmt = this->fmt;
        result.reordered = this->reordered;
        result.goodArgNum = this->goodArgNum;
        result.panicking = this->panicking;
        result.erroring = this->erroring;
        result.wrapErrs = this->wrapErrs;
        result.wrappedErrs = this->wrappedErrs;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pp::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (arg != ref.arg) return false;
        if (value != ref.value) return false;
        if (fmt != ref.fmt) return false;
        if (reordered != ref.reordered) return false;
        if (goodArgNum != ref.goodArgNum) return false;
        if (panicking != ref.panicking) return false;
        if (erroring != ref.erroring) return false;
        if (wrapErrs != ref.wrapErrs) return false;
        if (wrappedErrs != ref.wrappedErrs) return false;
        return true;
    }

    std::ostream& pp::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << arg;
        os << " " << value;
        os << " " << fmt;
        os << " " << reordered;
        os << " " << goodArgNum;
        os << " " << panicking;
        os << " " << erroring;
        os << " " << wrapErrs;
        os << " " << wrappedErrs;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pp& value)
    {
        return value.PrintTo(os);
    }

    sync::Pool ppFree = gocpp::Init<sync::Pool>([](auto& x) {
        x.New = []() mutable -> go_any
    {
        return go_new(pp);
    };
    });
    struct pp* newPrinter()
    {
        auto p = gocpp::getValue<pp*>(rec::Get(gocpp::recv(ppFree)));
        p->panicking = false;
        p->erroring = false;
        p->wrapErrs = false;
        rec::init(gocpp::recv(p->fmt), & p->buf);
        return p;
    }

    void rec::free(struct pp* p)
    {
        if(cap(p->buf) > 64 * 1024)
        {
            p->buf = nullptr;
        }
        else
        {
            p->buf = p->buf.make_slice(0, 0);
        }
        if(cap(p->wrappedErrs) > 8)
        {
            p->wrappedErrs = nullptr;
        }
        p->arg = nullptr;
        p->value = reflect::Value {};
        p->wrappedErrs = p->wrappedErrs.make_slice(0, 0);
        rec::Put(gocpp::recv(ppFree), p);
    }

    std::tuple<int, bool> rec::Width(struct pp* p)
    {
        int wid;
        bool ok;
        return {p->fmt.wid, p->fmt.widPresent};
    }

    std::tuple<int, bool> rec::Precision(struct pp* p)
    {
        int prec;
        bool ok;
        return {p->fmt.prec, p->fmt.precPresent};
    }

    bool rec::Flag(struct pp* p, int b)
    {
        //Go switch emulation
        {
            auto condition = b;
            int conditionId = -1;
            if(condition == '-') { conditionId = 0; }
            else if(condition == '+') { conditionId = 1; }
            else if(condition == '#') { conditionId = 2; }
            else if(condition == ' ') { conditionId = 3; }
            else if(condition == '0') { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    return p->fmt.minus;
                    break;
                case 1:
                    return p->fmt.plus || p->fmt.plusV;
                    break;
                case 2:
                    return p->fmt.sharp || p->fmt.sharpV;
                    break;
                case 3:
                    return p->fmt.space;
                    break;
                case 4:
                    return p->fmt.zero;
                    break;
            }
        }
        return false;
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct pp* p, gocpp::slice<unsigned char> b)
    {
        int ret;
        struct gocpp::error err;
        rec::write(gocpp::recv(p->buf), b);
        return {len(b), nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::WriteString(struct pp* p, std::string s)
    {
        int ret;
        struct gocpp::error err;
        rec::writeString(gocpp::recv(p->buf), s);
        return {len(s), nullptr};
    }

    std::tuple<int, struct gocpp::error> Fprintf(io::Writer w, std::string format, gocpp::slice<go_any> a)
    {
        int n;
        struct gocpp::error err;
        auto p = newPrinter();
        rec::doPrintf(gocpp::recv(p), format, a);
        std::tie(n, err) = rec::Write(gocpp::recv(w), p->buf);
        rec::free(gocpp::recv(p));
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> Printf(std::string format, gocpp::slice<go_any> a)
    {
        int n;
        struct gocpp::error err;
        return Fprintf(os::Stdout, format, a);
    }

    std::string Sprintf(std::string format, gocpp::slice<go_any> a)
    {
        auto p = newPrinter();
        rec::doPrintf(gocpp::recv(p), format, a);
        auto s = string(p->buf);
        rec::free(gocpp::recv(p));
        return s;
    }

    gocpp::slice<unsigned char> Appendf(gocpp::slice<unsigned char> b, std::string format, gocpp::slice<go_any> a)
    {
        auto p = newPrinter();
        rec::doPrintf(gocpp::recv(p), format, a);
        b = append(b, p->buf);
        rec::free(gocpp::recv(p));
        return b;
    }

    std::tuple<int, struct gocpp::error> Fprint(io::Writer w, gocpp::slice<go_any> a)
    {
        int n;
        struct gocpp::error err;
        auto p = newPrinter();
        rec::doPrint(gocpp::recv(p), a);
        std::tie(n, err) = rec::Write(gocpp::recv(w), p->buf);
        rec::free(gocpp::recv(p));
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> Print(gocpp::slice<go_any> a)
    {
        int n;
        struct gocpp::error err;
        return Fprint(os::Stdout, a);
    }

    std::string Sprint(gocpp::slice<go_any> a)
    {
        auto p = newPrinter();
        rec::doPrint(gocpp::recv(p), a);
        auto s = string(p->buf);
        rec::free(gocpp::recv(p));
        return s;
    }

    gocpp::slice<unsigned char> Append(gocpp::slice<unsigned char> b, gocpp::slice<go_any> a)
    {
        auto p = newPrinter();
        rec::doPrint(gocpp::recv(p), a);
        b = append(b, p->buf);
        rec::free(gocpp::recv(p));
        return b;
    }

    std::tuple<int, struct gocpp::error> Fprintln(io::Writer w, gocpp::slice<go_any> a)
    {
        int n;
        struct gocpp::error err;
        auto p = newPrinter();
        rec::doPrintln(gocpp::recv(p), a);
        std::tie(n, err) = rec::Write(gocpp::recv(w), p->buf);
        rec::free(gocpp::recv(p));
        return {n, err};
    }

    std::tuple<int, struct gocpp::error> Println(gocpp::slice<go_any> a)
    {
        int n;
        struct gocpp::error err;
        return Fprintln(os::Stdout, a);
    }

    std::string Sprintln(gocpp::slice<go_any> a)
    {
        auto p = newPrinter();
        rec::doPrintln(gocpp::recv(p), a);
        auto s = string(p->buf);
        rec::free(gocpp::recv(p));
        return s;
    }

    gocpp::slice<unsigned char> Appendln(gocpp::slice<unsigned char> b, gocpp::slice<go_any> a)
    {
        auto p = newPrinter();
        rec::doPrintln(gocpp::recv(p), a);
        b = append(b, p->buf);
        rec::free(gocpp::recv(p));
        return b;
    }

    reflect::Value getField(reflect::Value v, int i)
    {
        auto val = rec::Field(gocpp::recv(v), i);
        if(rec::Kind(gocpp::recv(val)) == reflect::Interface && ! rec::IsNil(gocpp::recv(val)))
        {
            val = rec::Elem(gocpp::recv(val));
        }
        return val;
    }

    bool tooLarge(int x)
    {
        int max = 1e6;
        return x > max || x < - max;
    }

    std::tuple<int, bool, int> parsenum(std::string s, int start, int end)
    {
        int num;
        bool isnum;
        int newi;
        if(start >= end)
        {
            int num;
            bool isnum;
            int newi;
            return {0, false, end};
        }
        for(newi = start; newi < end && '0' <= s[newi] && s[newi] <= '9'; newi++)
        {
            int num;
            bool isnum;
            int newi;
            if(tooLarge(num))
            {
                int num;
                bool isnum;
                int newi;
                return {0, false, end};
            }
            num = num * 10 + int(s[newi] - '0');
            isnum = true;
        }
        return {num, isnum, newi};
    }

    void rec::unknownType(struct pp* p, reflect::Value v)
    {
        if(! rec::IsValid(gocpp::recv(v)))
        {
            rec::writeString(gocpp::recv(p->buf), nilAngleString);
            return;
        }
        rec::writeByte(gocpp::recv(p->buf), '?');
        rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(v)))));
        rec::writeByte(gocpp::recv(p->buf), '?');
    }

    void rec::badVerb(struct pp* p, gocpp::rune verb)
    {
        p->erroring = true;
        rec::writeString(gocpp::recv(p->buf), percentBangString);
        rec::writeRune(gocpp::recv(p->buf), verb);
        rec::writeByte(gocpp::recv(p->buf), '(');
        //Go switch emulation
        {
            int conditionId = -1;
            if(p->arg != nullptr) { conditionId = 0; }
            else if(rec::IsValid(gocpp::recv(p->value))) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(reflect::TypeOf(p->arg))));
                    rec::writeByte(gocpp::recv(p->buf), '=');
                    rec::printArg(gocpp::recv(p), p->arg, 'v');
                    break;
                case 1:
                    rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(p->value)))));
                    rec::writeByte(gocpp::recv(p->buf), '=');
                    rec::printValue(gocpp::recv(p), p->value, 'v', 0);
                    break;
                default:
                    rec::writeString(gocpp::recv(p->buf), nilAngleString);
                    break;
            }
        }
        rec::writeByte(gocpp::recv(p->buf), ')');
        p->erroring = false;
    }

    void rec::fmtBool(struct pp* p, bool v, gocpp::rune verb)
    {
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 't') { conditionId = 0; }
            if(condition == 'v') { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    rec::fmtBoolean(gocpp::recv(p->fmt), v);
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    break;
            }
        }
    }

    void rec::fmt0x64(struct pp* p, uint64_t v, bool leading0x)
    {
        auto sharp = p->fmt.sharp;
        p->fmt.sharp = leading0x;
        rec::fmtInteger(gocpp::recv(p->fmt), v, 16, go_unsigned, 'v', ldigits);
        p->fmt.sharp = sharp;
    }

    void rec::fmtInteger(struct pp* p, uint64_t v, bool isSigned, gocpp::rune verb)
    {
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'v') { conditionId = 0; }
            else if(condition == 'd') { conditionId = 1; }
            else if(condition == 'b') { conditionId = 2; }
            else if(condition == 'o') { conditionId = 3; }
            else if(condition == 'O') { conditionId = 4; }
            else if(condition == 'x') { conditionId = 5; }
            else if(condition == 'X') { conditionId = 6; }
            else if(condition == 'c') { conditionId = 7; }
            else if(condition == 'q') { conditionId = 8; }
            else if(condition == 'U') { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                    if(p->fmt.sharpV && ! isSigned)
                    {
                        rec::fmt0x64(gocpp::recv(p), v, true);
                    }
                    else
                    {
                        rec::fmtInteger(gocpp::recv(p->fmt), v, 10, isSigned, verb, ldigits);
                    }
                    break;
                case 1:
                    rec::fmtInteger(gocpp::recv(p->fmt), v, 10, isSigned, verb, ldigits);
                    break;
                case 2:
                    rec::fmtInteger(gocpp::recv(p->fmt), v, 2, isSigned, verb, ldigits);
                    break;
                case 3:
                case 4:
                    rec::fmtInteger(gocpp::recv(p->fmt), v, 8, isSigned, verb, ldigits);
                    break;
                case 5:
                    rec::fmtInteger(gocpp::recv(p->fmt), v, 16, isSigned, verb, ldigits);
                    break;
                case 6:
                    rec::fmtInteger(gocpp::recv(p->fmt), v, 16, isSigned, verb, udigits);
                    break;
                case 7:
                    rec::fmtC(gocpp::recv(p->fmt), v);
                    break;
                case 8:
                    rec::fmtQc(gocpp::recv(p->fmt), v);
                    break;
                case 9:
                    rec::fmtUnicode(gocpp::recv(p->fmt), v);
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    break;
            }
        }
    }

    void rec::fmtFloat(struct pp* p, double v, int size, gocpp::rune verb)
    {
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'v') { conditionId = 0; }
            else if(condition == 'b') { conditionId = 1; }
            else if(condition == 'g') { conditionId = 2; }
            else if(condition == 'G') { conditionId = 3; }
            else if(condition == 'x') { conditionId = 4; }
            else if(condition == 'X') { conditionId = 5; }
            else if(condition == 'f') { conditionId = 6; }
            else if(condition == 'e') { conditionId = 7; }
            else if(condition == 'E') { conditionId = 8; }
            else if(condition == 'F') { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                    rec::fmtFloat(gocpp::recv(p->fmt), v, size, 'g', - 1);
                    break;
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    rec::fmtFloat(gocpp::recv(p->fmt), v, size, verb, - 1);
                    break;
                case 6:
                case 7:
                case 8:
                    rec::fmtFloat(gocpp::recv(p->fmt), v, size, verb, 6);
                    break;
                case 9:
                    rec::fmtFloat(gocpp::recv(p->fmt), v, size, 'f', 6);
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    break;
            }
        }
    }

    void rec::fmtComplex(struct pp* p, struct gocpp::complex128 v, int size, gocpp::rune verb)
    {
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'v') { conditionId = 0; }
            if(condition == 'b') { conditionId = 1; }
            if(condition == 'g') { conditionId = 2; }
            if(condition == 'G') { conditionId = 3; }
            if(condition == 'x') { conditionId = 4; }
            if(condition == 'X') { conditionId = 5; }
            if(condition == 'f') { conditionId = 6; }
            if(condition == 'F') { conditionId = 7; }
            if(condition == 'e') { conditionId = 8; }
            if(condition == 'E') { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    auto oldPlus = p->fmt.plus;
                    rec::writeByte(gocpp::recv(p->buf), '(');
                    rec::fmtFloat(gocpp::recv(p), real(v), size / 2, verb);
                    p->fmt.plus = true;
                    rec::fmtFloat(gocpp::recv(p), imag(v), size / 2, verb);
                    rec::writeString(gocpp::recv(p->buf), "i)");
                    p->fmt.plus = oldPlus;
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    break;
            }
        }
    }

    void rec::fmtString(struct pp* p, std::string v, gocpp::rune verb)
    {
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'v') { conditionId = 0; }
            else if(condition == 's') { conditionId = 1; }
            else if(condition == 'x') { conditionId = 2; }
            else if(condition == 'X') { conditionId = 3; }
            else if(condition == 'q') { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    if(p->fmt.sharpV)
                    {
                        rec::fmtQ(gocpp::recv(p->fmt), v);
                    }
                    else
                    {
                        rec::fmtS(gocpp::recv(p->fmt), v);
                    }
                    break;
                case 1:
                    rec::fmtS(gocpp::recv(p->fmt), v);
                    break;
                case 2:
                    rec::fmtSx(gocpp::recv(p->fmt), v, ldigits);
                    break;
                case 3:
                    rec::fmtSx(gocpp::recv(p->fmt), v, udigits);
                    break;
                case 4:
                    rec::fmtQ(gocpp::recv(p->fmt), v);
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    break;
            }
        }
    }

    void rec::fmtBytes(struct pp* p, gocpp::slice<unsigned char> v, gocpp::rune verb, std::string typeString)
    {
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'v') { conditionId = 0; }
            if(condition == 'd') { conditionId = 1; }
            else if(condition == 's') { conditionId = 2; }
            else if(condition == 'x') { conditionId = 3; }
            else if(condition == 'X') { conditionId = 4; }
            else if(condition == 'q') { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    if(p->fmt.sharpV)
                    {
                        rec::writeString(gocpp::recv(p->buf), typeString);
                        if(v == nullptr)
                        {
                            rec::writeString(gocpp::recv(p->buf), nilParenString);
                            return;
                        }
                        rec::writeByte(gocpp::recv(p->buf), '{');
                        for(auto [i, c] : v)
                        {
                            if(i > 0)
                            {
                                rec::writeString(gocpp::recv(p->buf), commaSpaceString);
                            }
                            rec::fmt0x64(gocpp::recv(p), uint64_t(c), true);
                        }
                        rec::writeByte(gocpp::recv(p->buf), '}');
                    }
                    else
                    {
                        rec::writeByte(gocpp::recv(p->buf), '[');
                        for(auto [i, c] : v)
                        {
                            if(i > 0)
                            {
                                rec::writeByte(gocpp::recv(p->buf), ' ');
                            }
                            rec::fmtInteger(gocpp::recv(p->fmt), uint64_t(c), 10, go_unsigned, verb, ldigits);
                        }
                        rec::writeByte(gocpp::recv(p->buf), ']');
                    }
                    break;
                case 2:
                    rec::fmtBs(gocpp::recv(p->fmt), v);
                    break;
                case 3:
                    rec::fmtBx(gocpp::recv(p->fmt), v, ldigits);
                    break;
                case 4:
                    rec::fmtBx(gocpp::recv(p->fmt), v, udigits);
                    break;
                case 5:
                    rec::fmtQ(gocpp::recv(p->fmt), string(v));
                    break;
                default:
                    rec::printValue(gocpp::recv(p), reflect::ValueOf(v), verb, 0);
                    break;
            }
        }
    }

    void rec::fmtPointer(struct pp* p, reflect::Value value, gocpp::rune verb)
    {
        uintptr_t u = {};
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(value));
            int conditionId = -1;
            if(condition == reflect::Chan) { conditionId = 0; }
            if(condition == reflect::Func) { conditionId = 1; }
            if(condition == reflect::Map) { conditionId = 2; }
            if(condition == reflect::Pointer) { conditionId = 3; }
            if(condition == reflect::Slice) { conditionId = 4; }
            if(condition == reflect::UnsafePointer) { conditionId = 5; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    u = uintptr_t(rec::UnsafePointer(gocpp::recv(value)));
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    return;
                    break;
            }
        }
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'v') { conditionId = 0; }
            else if(condition == 'p') { conditionId = 1; }
            else if(condition == 'b') { conditionId = 2; }
            else if(condition == 'o') { conditionId = 3; }
            else if(condition == 'd') { conditionId = 4; }
            else if(condition == 'x') { conditionId = 5; }
            else if(condition == 'X') { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    if(p->fmt.sharpV)
                    {
                        rec::writeByte(gocpp::recv(p->buf), '(');
                        rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(value)))));
                        rec::writeString(gocpp::recv(p->buf), ")(");
                        if(u == 0)
                        {
                            rec::writeString(gocpp::recv(p->buf), nilString);
                        }
                        else
                        {
                            rec::fmt0x64(gocpp::recv(p), uint64_t(u), true);
                        }
                        rec::writeByte(gocpp::recv(p->buf), ')');
                    }
                    else
                    {
                        if(u == 0)
                        {
                            rec::padString(gocpp::recv(p->fmt), nilAngleString);
                        }
                        else
                        {
                            rec::fmt0x64(gocpp::recv(p), uint64_t(u), ! p->fmt.sharp);
                        }
                    }
                    break;
                case 1:
                    rec::fmt0x64(gocpp::recv(p), uint64_t(u), ! p->fmt.sharp);
                    break;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    rec::fmtInteger(gocpp::recv(p), uint64_t(u), go_unsigned, verb);
                    break;
                default:
                    rec::badVerb(gocpp::recv(p), verb);
                    break;
            }
        }
    }

    void rec::catchPanic(struct pp* p, go_any arg, gocpp::rune verb, std::string method)
    {
        if(auto err = gocpp::recover(); err != nullptr)
        {
            if(auto v = reflect::ValueOf(arg); rec::Kind(gocpp::recv(v)) == reflect::Pointer && rec::IsNil(gocpp::recv(v)))
            {
                rec::writeString(gocpp::recv(p->buf), nilAngleString);
                return;
            }
            if(p->panicking)
            {
                gocpp::panic(err);
            }
            auto oldFlags = p->fmt.fmtFlags;
            rec::clearflags(gocpp::recv(p->fmt));
            rec::writeString(gocpp::recv(p->buf), percentBangString);
            rec::writeRune(gocpp::recv(p->buf), verb);
            rec::writeString(gocpp::recv(p->buf), panicString);
            rec::writeString(gocpp::recv(p->buf), method);
            rec::writeString(gocpp::recv(p->buf), " method: ");
            p->panicking = true;
            rec::printArg(gocpp::recv(p), err, 'v');
            p->panicking = false;
            rec::writeByte(gocpp::recv(p->buf), ')');
            p->fmt.fmtFlags = oldFlags;
        }
    }

    bool rec::handleMethods(struct pp* p, gocpp::rune verb)
    {
        gocpp::Defer defer;
        try
        {
            bool handled;
            if(p->erroring)
            {
                bool handled;
                return handled;
            }
            if(verb == 'w')
            {
                bool handled;
                auto [gocpp_id_1, ok] = gocpp::getValue<gocpp::error>(p->arg);
                if(! ok || ! p->wrapErrs)
                {
                    bool handled;
                    rec::badVerb(gocpp::recv(p), verb);
                    return true;
                }
                verb = 'v';
            }
            if(auto [formatter, ok] = gocpp::getValue<Formatter>(p->arg); ok)
            {
                bool handled;
                handled = true;
                defer.push_back([=]{ rec::catchPanic(gocpp::recv(p), p->arg, verb, "Format"); });
                rec::Format(gocpp::recv(formatter), p, verb);
                return handled;
            }
            if(p->fmt.sharpV)
            {
                bool handled;
                if(auto [stringer, ok] = gocpp::getValue<GoStringer>(p->arg); ok)
                {
                    bool handled;
                    handled = true;
                    defer.push_back([=]{ rec::catchPanic(gocpp::recv(p), p->arg, verb, "GoString"); });
                    rec::fmtS(gocpp::recv(p->fmt), rec::GoString(gocpp::recv(stringer)));
                    return handled;
                }
            }
            else
            {
                bool handled;
                //Go switch emulation
                {
                    auto condition = verb;
                    int conditionId = -1;
                    if(condition == 'v') { conditionId = 0; }
                    if(condition == 's') { conditionId = 1; }
                    if(condition == 'x') { conditionId = 2; }
                    if(condition == 'X') { conditionId = 3; }
                    if(condition == 'q') { conditionId = 4; }
                    switch(conditionId)
                    {
                        bool handled;
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            //Go type switch emulation
                            {
                                const auto& gocpp_id_2 = gocpp::type_info(p->arg);
                                int conditionId = -1;
                                if(gocpp_id_2 == typeid(gocpp::error)) { conditionId = 0; }
                                else if(gocpp_id_2 == typeid(Stringer)) { conditionId = 1; }
                                switch(conditionId)
                                {
                                    bool handled;
                                    case 0:
                                    {
                                        gocpp::error v = gocpp::any_cast<gocpp::error>(p->arg);
                                        handled = true;
                                        defer.push_back([=]{ rec::catchPanic(gocpp::recv(p), p->arg, verb, "Error"); });
                                        rec::fmtString(gocpp::recv(p), rec::Error(gocpp::recv(v)), verb);
                                        return handled;
                                        break;
                                    }
                                    case 1:
                                    {
                                        Stringer v = gocpp::any_cast<Stringer>(p->arg);
                                        handled = true;
                                        defer.push_back([=]{ rec::catchPanic(gocpp::recv(p), p->arg, verb, "String"); });
                                        rec::fmtString(gocpp::recv(p), rec::String(gocpp::recv(v)), verb);
                                        return handled;
                                        break;
                                    }
                                }
                            }
                            break;
                    }
                }
            }
            return false;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void rec::printArg(struct pp* p, go_any arg, gocpp::rune verb)
    {
        p->arg = arg;
        p->value = reflect::Value {};
        if(arg == nullptr)
        {
            //Go switch emulation
            {
                auto condition = verb;
                int conditionId = -1;
                if(condition == 'T') { conditionId = 0; }
                if(condition == 'v') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        rec::padString(gocpp::recv(p->fmt), nilAngleString);
                        break;
                    default:
                        rec::badVerb(gocpp::recv(p), verb);
                        break;
                }
            }
            return;
        }
        //Go switch emulation
        {
            auto condition = verb;
            int conditionId = -1;
            if(condition == 'T') { conditionId = 0; }
            else if(condition == 'p') { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    rec::fmtS(gocpp::recv(p->fmt), rec::String(gocpp::recv(reflect::TypeOf(arg))));
                    return;
                    break;
                case 1:
                    rec::fmtPointer(gocpp::recv(p), reflect::ValueOf(arg), 'p');
                    return;
                    break;
            }
        }
        //Go type switch emulation
        {
            const auto& gocpp_id_3 = gocpp::type_info(arg);
            int conditionId = -1;
            if(gocpp_id_3 == typeid(bool)) { conditionId = 0; }
            else if(gocpp_id_3 == typeid(float)) { conditionId = 1; }
            else if(gocpp_id_3 == typeid(double)) { conditionId = 2; }
            else if(gocpp_id_3 == typeid(gocpp::complex64)) { conditionId = 3; }
            else if(gocpp_id_3 == typeid(gocpp::complex128)) { conditionId = 4; }
            else if(gocpp_id_3 == typeid(int)) { conditionId = 5; }
            else if(gocpp_id_3 == typeid(int8_t)) { conditionId = 6; }
            else if(gocpp_id_3 == typeid(int16_t)) { conditionId = 7; }
            else if(gocpp_id_3 == typeid(int32_t)) { conditionId = 8; }
            else if(gocpp_id_3 == typeid(int64_t)) { conditionId = 9; }
            else if(gocpp_id_3 == typeid(unsigned int)) { conditionId = 10; }
            else if(gocpp_id_3 == typeid(uint8_t)) { conditionId = 11; }
            else if(gocpp_id_3 == typeid(uint16_t)) { conditionId = 12; }
            else if(gocpp_id_3 == typeid(uint32_t)) { conditionId = 13; }
            else if(gocpp_id_3 == typeid(uint64_t)) { conditionId = 14; }
            else if(gocpp_id_3 == typeid(uintptr_t)) { conditionId = 15; }
            else if(gocpp_id_3 == typeid(std::string)) { conditionId = 16; }
            else if(gocpp_id_3 == typeid(gocpp::slice<unsigned char>)) { conditionId = 17; }
            else if(gocpp_id_3 == typeid(reflect::Value)) { conditionId = 18; }
            switch(conditionId)
            {
                case 0:
                {
                    bool f = gocpp::any_cast<bool>(arg);
                    rec::fmtBool(gocpp::recv(p), f, verb);
                    break;
                }
                case 1:
                {
                    float f = gocpp::any_cast<float>(arg);
                    rec::fmtFloat(gocpp::recv(p), double(f), 32, verb);
                    break;
                }
                case 2:
                {
                    double f = gocpp::any_cast<double>(arg);
                    rec::fmtFloat(gocpp::recv(p), f, 64, verb);
                    break;
                }
                case 3:
                {
                    gocpp::complex64 f = gocpp::any_cast<gocpp::complex64>(arg);
                    rec::fmtComplex(gocpp::recv(p), gocpp::complex128(f), 64, verb);
                    break;
                }
                case 4:
                {
                    gocpp::complex128 f = gocpp::any_cast<gocpp::complex128>(arg);
                    rec::fmtComplex(gocpp::recv(p), f, 128, verb);
                    break;
                }
                case 5:
                {
                    int f = gocpp::any_cast<int>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_signed, verb);
                    break;
                }
                case 6:
                {
                    int8_t f = gocpp::any_cast<int8_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_signed, verb);
                    break;
                }
                case 7:
                {
                    int16_t f = gocpp::any_cast<int16_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_signed, verb);
                    break;
                }
                case 8:
                {
                    int32_t f = gocpp::any_cast<int32_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_signed, verb);
                    break;
                }
                case 9:
                {
                    int64_t f = gocpp::any_cast<int64_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_signed, verb);
                    break;
                }
                case 10:
                {
                    unsigned int f = gocpp::any_cast<unsigned int>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_unsigned, verb);
                    break;
                }
                case 11:
                {
                    uint8_t f = gocpp::any_cast<uint8_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_unsigned, verb);
                    break;
                }
                case 12:
                {
                    uint16_t f = gocpp::any_cast<uint16_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_unsigned, verb);
                    break;
                }
                case 13:
                {
                    uint32_t f = gocpp::any_cast<uint32_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_unsigned, verb);
                    break;
                }
                case 14:
                {
                    uint64_t f = gocpp::any_cast<uint64_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), f, go_unsigned, verb);
                    break;
                }
                case 15:
                {
                    uintptr_t f = gocpp::any_cast<uintptr_t>(arg);
                    rec::fmtInteger(gocpp::recv(p), uint64_t(f), go_unsigned, verb);
                    break;
                }
                case 16:
                {
                    std::string f = gocpp::any_cast<std::string>(arg);
                    rec::fmtString(gocpp::recv(p), f, verb);
                    break;
                }
                case 17:
                {
                    gocpp::slice<unsigned char> f = gocpp::any_cast<gocpp::slice<unsigned char>>(arg);
                    rec::fmtBytes(gocpp::recv(p), f, verb, "[]byte");
                    break;
                }
                case 18:
                {
                    reflect::Value f = gocpp::any_cast<reflect::Value>(arg);
                    if(rec::IsValid(gocpp::recv(f)) && rec::CanInterface(gocpp::recv(f)))
                    {
                        p->arg = rec::Interface(gocpp::recv(f));
                        if(rec::handleMethods(gocpp::recv(p), verb))
                        {
                            return;
                        }
                    }
                    rec::printValue(gocpp::recv(p), f, verb, 0);
                    break;
                }
                default:
                {
                    auto f = arg;
                    if(! rec::handleMethods(gocpp::recv(p), verb))
                    {
                        rec::printValue(gocpp::recv(p), reflect::ValueOf(f), verb, 0);
                    }
                    break;
                }
            }
        }
    }

    void rec::printValue(struct pp* p, reflect::Value value, gocpp::rune verb, int depth)
    {
        if(depth > 0 && rec::IsValid(gocpp::recv(value)) && rec::CanInterface(gocpp::recv(value)))
        {
            p->arg = rec::Interface(gocpp::recv(value));
            if(rec::handleMethods(gocpp::recv(p), verb))
            {
                return;
            }
        }
        p->arg = nullptr;
        p->value = value;
        //Go switch emulation
        {
            auto f = value;
            auto condition = rec::Kind(gocpp::recv(value));
            int conditionId = -1;
            if(condition == reflect::Invalid) { conditionId = 0; }
            else if(condition == reflect::Bool) { conditionId = 1; }
            else if(condition == reflect::Int) { conditionId = 2; }
            else if(condition == reflect::Int8) { conditionId = 3; }
            else if(condition == reflect::Int16) { conditionId = 4; }
            else if(condition == reflect::Int32) { conditionId = 5; }
            else if(condition == reflect::Int64) { conditionId = 6; }
            else if(condition == reflect::Uint) { conditionId = 7; }
            else if(condition == reflect::Uint8) { conditionId = 8; }
            else if(condition == reflect::Uint16) { conditionId = 9; }
            else if(condition == reflect::Uint32) { conditionId = 10; }
            else if(condition == reflect::Uint64) { conditionId = 11; }
            else if(condition == reflect::Uintptr) { conditionId = 12; }
            else if(condition == reflect::Float32) { conditionId = 13; }
            else if(condition == reflect::Float64) { conditionId = 14; }
            else if(condition == reflect::Complex64) { conditionId = 15; }
            else if(condition == reflect::Complex128) { conditionId = 16; }
            else if(condition == reflect::String) { conditionId = 17; }
            else if(condition == reflect::Map) { conditionId = 18; }
            else if(condition == reflect::Struct) { conditionId = 19; }
            else if(condition == reflect::Interface) { conditionId = 20; }
            else if(condition == reflect::Array) { conditionId = 21; }
            else if(condition == reflect::Slice) { conditionId = 22; }
            else if(condition == reflect::Pointer) { conditionId = 23; }
            else if(condition == reflect::Chan) { conditionId = 24; }
            else if(condition == reflect::Func) { conditionId = 25; }
            else if(condition == reflect::UnsafePointer) { conditionId = 26; }
            switch(conditionId)
            {
                case 0:
                    if(depth == 0)
                    {
                        rec::writeString(gocpp::recv(p->buf), invReflectString);
                    }
                    else
                    {
                        //Go switch emulation
                        {
                            auto condition = verb;
                            int conditionId = -1;
                            if(condition == 'v') { conditionId = 0; }
                            switch(conditionId)
                            {
                                case 0:
                                    rec::writeString(gocpp::recv(p->buf), nilAngleString);
                                    break;
                                default:
                                    rec::badVerb(gocpp::recv(p), verb);
                                    break;
                            }
                        }
                    }
                    break;
                case 1:
                    rec::fmtBool(gocpp::recv(p), rec::Bool(gocpp::recv(f)), verb);
                    break;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    rec::fmtInteger(gocpp::recv(p), uint64_t(rec::Int(gocpp::recv(f))), go_signed, verb);
                    break;
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    rec::fmtInteger(gocpp::recv(p), rec::Uint(gocpp::recv(f)), go_unsigned, verb);
                    break;
                case 13:
                    rec::fmtFloat(gocpp::recv(p), rec::Float(gocpp::recv(f)), 32, verb);
                    break;
                case 14:
                    rec::fmtFloat(gocpp::recv(p), rec::Float(gocpp::recv(f)), 64, verb);
                    break;
                case 15:
                    rec::fmtComplex(gocpp::recv(p), rec::Complex(gocpp::recv(f)), 64, verb);
                    break;
                case 16:
                    rec::fmtComplex(gocpp::recv(p), rec::Complex(gocpp::recv(f)), 128, verb);
                    break;
                case 17:
                    rec::fmtString(gocpp::recv(p), rec::String(gocpp::recv(f)), verb);
                    break;
                case 18:
                    if(p->fmt.sharpV)
                    {
                        rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(f)))));
                        if(rec::IsNil(gocpp::recv(f)))
                        {
                            rec::writeString(gocpp::recv(p->buf), nilParenString);
                            return;
                        }
                        rec::writeByte(gocpp::recv(p->buf), '{');
                    }
                    else
                    {
                        rec::writeString(gocpp::recv(p->buf), mapString);
                    }
                    auto sorted = fmtsort::Sort(f);
                    for(auto [i, key] : sorted->Key)
                    {
                        if(i > 0)
                        {
                            if(p->fmt.sharpV)
                            {
                                rec::writeString(gocpp::recv(p->buf), commaSpaceString);
                            }
                            else
                            {
                                rec::writeByte(gocpp::recv(p->buf), ' ');
                            }
                        }
                        rec::printValue(gocpp::recv(p), key, verb, depth + 1);
                        rec::writeByte(gocpp::recv(p->buf), ':');
                        rec::printValue(gocpp::recv(p), sorted->Value[i], verb, depth + 1);
                    }
                    if(p->fmt.sharpV)
                    {
                        rec::writeByte(gocpp::recv(p->buf), '}');
                    }
                    else
                    {
                        rec::writeByte(gocpp::recv(p->buf), ']');
                    }
                    break;
                case 19:
                    if(p->fmt.sharpV)
                    {
                        rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(f)))));
                    }
                    rec::writeByte(gocpp::recv(p->buf), '{');
                    for(auto i = 0; i < rec::NumField(gocpp::recv(f)); i++)
                    {
                        if(i > 0)
                        {
                            if(p->fmt.sharpV)
                            {
                                rec::writeString(gocpp::recv(p->buf), commaSpaceString);
                            }
                            else
                            {
                                rec::writeByte(gocpp::recv(p->buf), ' ');
                            }
                        }
                        if(p->fmt.plusV || p->fmt.sharpV)
                        {
                            if(auto name = rec::Field(gocpp::recv(rec::Type(gocpp::recv(f))), i).Name; name != "")
                            {
                                rec::writeString(gocpp::recv(p->buf), name);
                                rec::writeByte(gocpp::recv(p->buf), ':');
                            }
                        }
                        rec::printValue(gocpp::recv(p), getField(f, i), verb, depth + 1);
                    }
                    rec::writeByte(gocpp::recv(p->buf), '}');
                    break;
                case 20:
                    auto value = rec::Elem(gocpp::recv(f));
                    if(! rec::IsValid(gocpp::recv(value)))
                    {
                        if(p->fmt.sharpV)
                        {
                            rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(f)))));
                            rec::writeString(gocpp::recv(p->buf), nilParenString);
                        }
                        else
                        {
                            rec::writeString(gocpp::recv(p->buf), nilAngleString);
                        }
                    }
                    else
                    {
                        rec::printValue(gocpp::recv(p), value, verb, depth + 1);
                    }
                    break;
                case 21:
                case 22:
                    //Go switch emulation
                    {
                        auto condition = verb;
                        int conditionId = -1;
                        if(condition == 's') { conditionId = 0; }
                        if(condition == 'q') { conditionId = 1; }
                        if(condition == 'x') { conditionId = 2; }
                        if(condition == 'X') { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                auto t = rec::Type(gocpp::recv(f));
                                if(rec::Kind(gocpp::recv(rec::Elem(gocpp::recv(t)))) == reflect::Uint8)
                                {
                                    gocpp::slice<unsigned char> bytes = {};
                                    if(rec::Kind(gocpp::recv(f)) == reflect::Slice || rec::CanAddr(gocpp::recv(f)))
                                    {
                                        bytes = rec::Bytes(gocpp::recv(f));
                                    }
                                    else
                                    {
                                        bytes = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), rec::Len(gocpp::recv(f)));
                                        for(auto [i, gocpp_ignored] : bytes)
                                        {
                                            bytes[i] = unsigned char(rec::Uint(gocpp::recv(rec::Index(gocpp::recv(f), i))));
                                        }
                                    }
                                    rec::fmtBytes(gocpp::recv(p), bytes, verb, rec::String(gocpp::recv(t)));
                                    return;
                                }
                                break;
                        }
                    }
                    if(p->fmt.sharpV)
                    {
                        rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(rec::Type(gocpp::recv(f)))));
                        if(rec::Kind(gocpp::recv(f)) == reflect::Slice && rec::IsNil(gocpp::recv(f)))
                        {
                            rec::writeString(gocpp::recv(p->buf), nilParenString);
                            return;
                        }
                        rec::writeByte(gocpp::recv(p->buf), '{');
                        for(auto i = 0; i < rec::Len(gocpp::recv(f)); i++)
                        {
                            if(i > 0)
                            {
                                rec::writeString(gocpp::recv(p->buf), commaSpaceString);
                            }
                            rec::printValue(gocpp::recv(p), rec::Index(gocpp::recv(f), i), verb, depth + 1);
                        }
                        rec::writeByte(gocpp::recv(p->buf), '}');
                    }
                    else
                    {
                        rec::writeByte(gocpp::recv(p->buf), '[');
                        for(auto i = 0; i < rec::Len(gocpp::recv(f)); i++)
                        {
                            if(i > 0)
                            {
                                rec::writeByte(gocpp::recv(p->buf), ' ');
                            }
                            rec::printValue(gocpp::recv(p), rec::Index(gocpp::recv(f), i), verb, depth + 1);
                        }
                        rec::writeByte(gocpp::recv(p->buf), ']');
                    }
                    break;
                case 23:
                    if(depth == 0 && rec::UnsafePointer(gocpp::recv(f)) != nullptr)
                    {
                        //Go switch emulation
                        {
                            auto a = rec::Elem(gocpp::recv(f));
                            auto condition = rec::Kind(gocpp::recv(a));
                            int conditionId = -1;
                            if(condition == reflect::Array) { conditionId = 0; }
                            if(condition == reflect::Slice) { conditionId = 1; }
                            if(condition == reflect::Struct) { conditionId = 2; }
                            if(condition == reflect::Map) { conditionId = 3; }
                            switch(conditionId)
                            {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    rec::writeByte(gocpp::recv(p->buf), '&');
                                    rec::printValue(gocpp::recv(p), a, verb, depth + 1);
                                    return;
                                    break;
                            }
                        }
                    }
                case 24:
                case 25:
                case 26:
                    rec::fmtPointer(gocpp::recv(p), f, verb);
                    break;
                default:
                    rec::unknownType(gocpp::recv(p), f);
                    break;
            }
        }
    }

    std::tuple<int, bool, int> intFromArg(gocpp::slice<go_any> a, int argNum)
    {
        int num;
        bool isInt;
        int newArgNum;
        newArgNum = argNum;
        if(argNum < len(a))
        {
            int num;
            bool isInt;
            int newArgNum;
            std::tie(num, isInt) = gocpp::getValue<int>(a[argNum]);
            if(! isInt)
            {
                int num;
                bool isInt;
                int newArgNum;
                //Go switch emulation
                {
                    auto v = reflect::ValueOf(a[argNum]);
                    auto condition = rec::Kind(gocpp::recv(v));
                    int conditionId = -1;
                    if(condition == reflect::Int) { conditionId = 0; }
                    if(condition == reflect::Int8) { conditionId = 1; }
                    if(condition == reflect::Int16) { conditionId = 2; }
                    if(condition == reflect::Int32) { conditionId = 3; }
                    if(condition == reflect::Int64) { conditionId = 4; }
                    else if(condition == reflect::Uint) { conditionId = 5; }
                    else if(condition == reflect::Uint8) { conditionId = 6; }
                    else if(condition == reflect::Uint16) { conditionId = 7; }
                    else if(condition == reflect::Uint32) { conditionId = 8; }
                    else if(condition == reflect::Uint64) { conditionId = 9; }
                    else if(condition == reflect::Uintptr) { conditionId = 10; }
                    switch(conditionId)
                    {
                        int num;
                        bool isInt;
                        int newArgNum;
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            auto n = rec::Int(gocpp::recv(v));
                            if(int64_t(int(n)) == n)
                            {
                                int num;
                                bool isInt;
                                int newArgNum;
                                num = int(n);
                                isInt = true;
                            }
                            break;
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            auto n = rec::Uint(gocpp::recv(v));
                            if(int64_t(n) >= 0 && uint64_t(int(n)) == n)
                            {
                                int num;
                                bool isInt;
                                int newArgNum;
                                num = int(n);
                                isInt = true;
                            }
                            break;
                        default:
                            break;
                    }
                }
            }
            newArgNum = argNum + 1;
            if(tooLarge(num))
            {
                int num;
                bool isInt;
                int newArgNum;
                num = 0;
                isInt = false;
            }
        }
        return {num, isInt, newArgNum};
    }

    std::tuple<int, int, bool> parseArgNumber(std::string format)
    {
        int index;
        int wid;
        bool ok;
        if(len(format) < 3)
        {
            int index;
            int wid;
            bool ok;
            return {0, 1, false};
        }
        for(auto i = 1; i < len(format); i++)
        {
            int index;
            int wid;
            bool ok;
            if(format[i] == ']')
            {
                int index;
                int wid;
                bool ok;
                auto [width, ok, newi] = parsenum(format, 1, i);
                if(! ok || newi != i)
                {
                    int index;
                    int wid;
                    bool ok;
                    return {0, i + 1, false};
                }
                return {width - 1, i + 1, true};
            }
        }
        return {0, 1, false};
    }

    std::tuple<int, int, bool> rec::argNumber(struct pp* p, int argNum, std::string format, int i, int numArgs)
    {
        int newArgNum;
        int newi;
        bool found;
        if(len(format) <= i || format[i] != '[')
        {
            int newArgNum;
            int newi;
            bool found;
            return {argNum, i, false};
        }
        p->reordered = true;
        auto [index, wid, ok] = parseArgNumber(format.make_slice(i));
        if(ok && 0 <= index && index < numArgs)
        {
            int newArgNum;
            int newi;
            bool found;
            return {index, i + wid, true};
        }
        p->goodArgNum = false;
        return {argNum, i + wid, ok};
    }

    void rec::badArgNum(struct pp* p, gocpp::rune verb)
    {
        rec::writeString(gocpp::recv(p->buf), percentBangString);
        rec::writeRune(gocpp::recv(p->buf), verb);
        rec::writeString(gocpp::recv(p->buf), badIndexString);
    }

    void rec::missingArg(struct pp* p, gocpp::rune verb)
    {
        rec::writeString(gocpp::recv(p->buf), percentBangString);
        rec::writeRune(gocpp::recv(p->buf), verb);
        rec::writeString(gocpp::recv(p->buf), missingString);
    }

    void rec::doPrintf(struct pp* p, std::string format, gocpp::slice<go_any> a)
    {
        auto end = len(format);
        auto argNum = 0;
        auto afterIndex = false;
        p->reordered = false;
        formatLoop:
        for(auto i = 0; i < end; )
        {
            p->goodArgNum = true;
            auto lasti = i;
            for(; i < end && format[i] != '%'; )
            {
                i++;
            }
            if(i > lasti)
            {
                rec::writeString(gocpp::recv(p->buf), format.make_slice(lasti, i));
            }
            if(i >= end)
            {
                break;
            }
            i++;
            rec::clearflags(gocpp::recv(p->fmt));
            simpleFormat:
            for(; i < end; i++)
            {
                auto c = format[i];
                //Go switch emulation
                {
                    auto condition = c;
                    int conditionId = -1;
                    if(condition == '#') { conditionId = 0; }
                    else if(condition == '0') { conditionId = 1; }
                    else if(condition == '+') { conditionId = 2; }
                    else if(condition == '-') { conditionId = 3; }
                    else if(condition == ' ') { conditionId = 4; }
                    switch(conditionId)
                    {
                        case 0:
                            p->fmt.sharp = true;
                            break;
                        case 1:
                            p->fmt.zero = ! p->fmt.minus;
                            break;
                        case 2:
                            p->fmt.plus = true;
                            break;
                        case 3:
                            p->fmt.minus = true;
                            p->fmt.zero = false;
                            break;
                        case 4:
                            p->fmt.space = true;
                            break;
                        default:
                            if('a' <= c && c <= 'z' && argNum < len(a))
                            {
                                //Go switch emulation
                                {
                                    auto condition = c;
                                    int conditionId = -1;
                                    if(condition == 'w') { conditionId = 0; }
                                    else if(condition == 'v') { conditionId = 1; }
                                    switch(conditionId)
                                    {
                                        case 0:
                                            p->wrappedErrs = append(p->wrappedErrs, argNum);
                                        case 1:
                                            p->fmt.sharpV = p->fmt.sharp;
                                            p->fmt.sharp = false;
                                            p->fmt.plusV = p->fmt.plus;
                                            p->fmt.plus = false;
                                            break;
                                    }
                                }
                                rec::printArg(gocpp::recv(p), a[argNum], rune(c));
                                argNum++;
                                i++;
                                goto formatLoop_continue;
                            }
                            goto simpleFormat_break;
                            break;
                    }
                }
                if(false) {
                simpleFormat_continue:
                    continue;
                simpleFormat_break:
                    break;
                }
            }
            std::tie(argNum, i, afterIndex) = rec::argNumber(gocpp::recv(p), argNum, format, i, len(a));
            if(i < end && format[i] == '*')
            {
                i++;
                std::tie(p->fmt.wid, p->fmt.widPresent, argNum) = intFromArg(a, argNum);
                if(! p->fmt.widPresent)
                {
                    rec::writeString(gocpp::recv(p->buf), badWidthString);
                }
                if(p->fmt.wid < 0)
                {
                    p->fmt.wid = - p->fmt.wid;
                    p->fmt.minus = true;
                    p->fmt.zero = false;
                }
                afterIndex = false;
            }
            else
            {
                std::tie(p->fmt.wid, p->fmt.widPresent, i) = parsenum(format, i, end);
                if(afterIndex && p->fmt.widPresent)
                {
                    p->goodArgNum = false;
                }
            }
            if(i + 1 < end && format[i] == '.')
            {
                i++;
                if(afterIndex)
                {
                    p->goodArgNum = false;
                }
                std::tie(argNum, i, afterIndex) = rec::argNumber(gocpp::recv(p), argNum, format, i, len(a));
                if(i < end && format[i] == '*')
                {
                    i++;
                    std::tie(p->fmt.prec, p->fmt.precPresent, argNum) = intFromArg(a, argNum);
                    if(p->fmt.prec < 0)
                    {
                        p->fmt.prec = 0;
                        p->fmt.precPresent = false;
                    }
                    if(! p->fmt.precPresent)
                    {
                        rec::writeString(gocpp::recv(p->buf), badPrecString);
                    }
                    afterIndex = false;
                }
                else
                {
                    std::tie(p->fmt.prec, p->fmt.precPresent, i) = parsenum(format, i, end);
                    if(! p->fmt.precPresent)
                    {
                        p->fmt.prec = 0;
                        p->fmt.precPresent = true;
                    }
                }
            }
            if(! afterIndex)
            {
                std::tie(argNum, i, afterIndex) = rec::argNumber(gocpp::recv(p), argNum, format, i, len(a));
            }
            if(i >= end)
            {
                rec::writeString(gocpp::recv(p->buf), noVerbString);
                break;
            }
            auto [verb, size] = std::tuple{rune(format[i]), 1};
            if(verb >= utf8::RuneSelf)
            {
                std::tie(verb, size) = utf8::DecodeRuneInString(format.make_slice(i));
            }
            i += size;
            //Go switch emulation
            {
                int conditionId = -1;
                if(verb == '%') { conditionId = 0; }
                else if(! p->goodArgNum) { conditionId = 1; }
                else if(argNum >= len(a)) { conditionId = 2; }
                else if(verb == 'w') { conditionId = 3; }
                else if(verb == 'v') { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                        rec::writeByte(gocpp::recv(p->buf), '%');
                        break;
                    case 1:
                        rec::badArgNum(gocpp::recv(p), verb);
                        break;
                    case 2:
                        rec::missingArg(gocpp::recv(p), verb);
                        break;
                    case 3:
                        p->wrappedErrs = append(p->wrappedErrs, argNum);
                    case 4:
                        p->fmt.sharpV = p->fmt.sharp;
                        p->fmt.sharp = false;
                        p->fmt.plusV = p->fmt.plus;
                        p->fmt.plus = false;
                    default:
                        rec::printArg(gocpp::recv(p), a[argNum], verb);
                        argNum++;
                        break;
                }
            }
            if(false) {
            formatLoop_continue:
                continue;
            formatLoop_break:
                break;
            }
        }
        if(! p->reordered && argNum < len(a))
        {
            rec::clearflags(gocpp::recv(p->fmt));
            rec::writeString(gocpp::recv(p->buf), extraString);
            for(auto [i, arg] : a.make_slice(argNum))
            {
                if(i > 0)
                {
                    rec::writeString(gocpp::recv(p->buf), commaSpaceString);
                }
                if(arg == nullptr)
                {
                    rec::writeString(gocpp::recv(p->buf), nilAngleString);
                }
                else
                {
                    rec::writeString(gocpp::recv(p->buf), rec::String(gocpp::recv(reflect::TypeOf(arg))));
                    rec::writeByte(gocpp::recv(p->buf), '=');
                    rec::printArg(gocpp::recv(p), arg, 'v');
                }
            }
            rec::writeByte(gocpp::recv(p->buf), ')');
        }
    }

    void rec::doPrint(struct pp* p, gocpp::slice<go_any> a)
    {
        auto prevString = false;
        for(auto [argNum, arg] : a)
        {
            auto isString = arg != nullptr && rec::Kind(gocpp::recv(reflect::TypeOf(arg))) == reflect::String;
            if(argNum > 0 && ! isString && ! prevString)
            {
                rec::writeByte(gocpp::recv(p->buf), ' ');
            }
            rec::printArg(gocpp::recv(p), arg, 'v');
            prevString = isString;
        }
    }

    void rec::doPrintln(struct pp* p, gocpp::slice<go_any> a)
    {
        for(auto [argNum, arg] : a)
        {
            if(argNum > 0)
            {
                rec::writeByte(gocpp::recv(p->buf), ' ');
            }
            rec::printArg(gocpp::recv(p), arg, 'v');
        }
        rec::writeByte(gocpp::recv(p->buf), '\n');
    }

}

