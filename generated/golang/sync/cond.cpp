// generated by GoCpp from file '$(ImportDir)/sync/cond.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/cond.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/mutex.h"
// #include "golang/sync/runtime.h"  [Ignored, known errors]
// #include "golang/sync/runtime2.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Cond::operator T()
    {
        T result;
        result.noCopy = this->noCopy;
        result.L = this->L;
        result.notify = this->notify;
        result.checker = this->checker;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Cond::operator==(const T& ref) const
    {
        if (noCopy != ref.noCopy) return false;
        if (L != ref.L) return false;
        if (notify != ref.notify) return false;
        if (checker != ref.checker) return false;
        return true;
    }

    std::ostream& Cond::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << noCopy;
        os << " " << L;
        os << " " << notify;
        os << " " << checker;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Cond& value)
    {
        return value.PrintTo(os);
    }

    struct Cond* NewCond(struct Locker l)
    {
        return gocpp::InitPtr<Cond>([](Cond& x) { x.L = l; });
    }

    void Wait(struct Cond* c)
    {
        check(gocpp::recv(c->checker));
        auto t = runtime_notifyListAdd(& c->notify);
        Unlock(gocpp::recv(c->L));
        runtime_notifyListWait(& c->notify, t);
        Lock(gocpp::recv(c->L));
    }

    void Signal(struct Cond* c)
    {
        check(gocpp::recv(c->checker));
        runtime_notifyListNotifyOne(& c->notify);
    }

    void Broadcast(struct Cond* c)
    {
        check(gocpp::recv(c->checker));
        runtime_notifyListNotifyAll(& c->notify);
    }

    void check(copyChecker* c)
    {
        if(uintptr_t(*c) != uintptr_t(unsafe::Pointer(c)) && ! atomic::CompareAndSwapUintptr((uintptr_t*)(c), 0, uintptr_t(unsafe::Pointer(c))) && uintptr_t(*c) != uintptr_t(unsafe::Pointer(c)))
        {
            gocpp::panic("sync.Cond is copied");
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    noCopy::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noCopy::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noCopy::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value)
    {
        return value.PrintTo(os);
    }

    void Lock(noCopy*)
    {
    }

    void Unlock(noCopy*)
    {
    }

}

