// generated by GoCpp from file '$(ImportDir)/runtime/trace2.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/preempt.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/sema.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2cpu.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwapNoWB;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_1::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_1::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_1::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_1& value)
    {
        return value.PrintTo(os);
    }


    struct gocpp_id_0
    {
        mutex lock;
        traceBuf* reading;
        traceBuf* empty;
        gocpp::array<traceBufQueue, 2> full;
        atomic::Bool workAvailable;
        atomic::Uintptr readerGen;
        atomic::Uintptr flushedGen;
        bool headerWritten;
        gocpp::array<uint32_t, 2> doneSema;
        gocpp::array<traceStackTable, 2> stackTab;
        gocpp::array<traceStringTable, 2> stringTab;
        gocpp::array<profBuf*, 2> cpuLogRead;
        atomic::Uint32 signalLock;
        gocpp::array<atomic::Pointer<profBuf>, 2> cpuLogWrite;
        wakeableSleep* cpuSleep;
        gocpp::channel<gocpp_id_1> cpuLogDone;
        gocpp::array<traceBuf*, 2> cpuBuf;
        atomic::Pointer<g> reader;
        gocpp::array<gocpp::array<golang::runtime::traceArg, len(gcMarkWorkerModeStrings)>, 2> markWorkerLabels;
        gocpp::array<gocpp::array<golang::runtime::traceArg, len(traceGoStopReasonStrings)>, 2> goStopReasons;
        gocpp::array<gocpp::array<golang::runtime::traceArg, len(traceBlockReasonStrings)>, 2> goBlockReasons;
        atomic::Uintptr gen;
        uintptr_t lastNonZeroGen;
        atomic::Bool shutdown;
        atomic::Int32 exitingSyscall;
        uint64_t seqGC;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.lock = this->lock;
            result.reading = this->reading;
            result.empty = this->empty;
            result.full = this->full;
            result.workAvailable = this->workAvailable;
            result.readerGen = this->readerGen;
            result.flushedGen = this->flushedGen;
            result.headerWritten = this->headerWritten;
            result.doneSema = this->doneSema;
            result.stackTab = this->stackTab;
            result.stringTab = this->stringTab;
            result.cpuLogRead = this->cpuLogRead;
            result.signalLock = this->signalLock;
            result.cpuLogWrite = this->cpuLogWrite;
            result.cpuSleep = this->cpuSleep;
            result.cpuLogDone = this->cpuLogDone;
            result.cpuBuf = this->cpuBuf;
            result.reader = this->reader;
            result.markWorkerLabels = this->markWorkerLabels;
            result.goStopReasons = this->goStopReasons;
            result.goBlockReasons = this->goBlockReasons;
            result.gen = this->gen;
            result.lastNonZeroGen = this->lastNonZeroGen;
            result.shutdown = this->shutdown;
            result.exitingSyscall = this->exitingSyscall;
            result.seqGC = this->seqGC;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (lock != ref.lock) return false;
            if (reading != ref.reading) return false;
            if (empty != ref.empty) return false;
            if (full != ref.full) return false;
            if (workAvailable != ref.workAvailable) return false;
            if (readerGen != ref.readerGen) return false;
            if (flushedGen != ref.flushedGen) return false;
            if (headerWritten != ref.headerWritten) return false;
            if (doneSema != ref.doneSema) return false;
            if (stackTab != ref.stackTab) return false;
            if (stringTab != ref.stringTab) return false;
            if (cpuLogRead != ref.cpuLogRead) return false;
            if (signalLock != ref.signalLock) return false;
            if (cpuLogWrite != ref.cpuLogWrite) return false;
            if (cpuSleep != ref.cpuSleep) return false;
            if (cpuLogDone != ref.cpuLogDone) return false;
            if (cpuBuf != ref.cpuBuf) return false;
            if (reader != ref.reader) return false;
            if (markWorkerLabels != ref.markWorkerLabels) return false;
            if (goStopReasons != ref.goStopReasons) return false;
            if (goBlockReasons != ref.goBlockReasons) return false;
            if (gen != ref.gen) return false;
            if (lastNonZeroGen != ref.lastNonZeroGen) return false;
            if (shutdown != ref.shutdown) return false;
            if (exitingSyscall != ref.exitingSyscall) return false;
            if (seqGC != ref.seqGC) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << reading;
            os << " " << empty;
            os << " " << full;
            os << " " << workAvailable;
            os << " " << readerGen;
            os << " " << flushedGen;
            os << " " << headerWritten;
            os << " " << doneSema;
            os << " " << stackTab;
            os << " " << stringTab;
            os << " " << cpuLogRead;
            os << " " << signalLock;
            os << " " << cpuLogWrite;
            os << " " << cpuSleep;
            os << " " << cpuLogDone;
            os << " " << cpuBuf;
            os << " " << reader;
            os << " " << markWorkerLabels;
            os << " " << goStopReasons;
            os << " " << goBlockReasons;
            os << " " << gen;
            os << " " << lastNonZeroGen;
            os << " " << shutdown;
            os << " " << exitingSyscall;
            os << " " << seqGC;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // trace is global tracing context.
    gocpp_id_0 trace;
    uint32_t traceAdvanceSema = 1;
    uint32_t traceShutdownSema = 1;
    // StartTrace enables tracing for the current process.
    // While tracing, the data will be buffered and available via [ReadTrace].
    // StartTrace returns an error if tracing is already enabled.
    // Most clients should use the [runtime/trace] package or the [testing] package's
    // -test.trace flag instead of calling StartTrace directly.
    struct gocpp::error StartTrace()
    {
        if(traceEnabled() || traceShuttingDown())
        {
            return errorString("tracing is already enabled"_s);
        }
        semacquire(& traceShutdownSema);
        semrelease(& traceShutdownSema);
        semacquire(& traceAdvanceSema);
        traceInitReadCPU();
        auto firstGen = traceNextGen(trace.lastNonZeroGen);
        trace.seqGC = 1;
        trace.headerWritten = false;
        rec::Store(gocpp::recv(trace.readerGen), firstGen);
        rec::Store(gocpp::recv(trace.flushedGen), 0);
        traceRegisterLabelsAndReasons(firstGen);
        auto stw = stopTheWorld(stwStartTrace);
        lock(& sched.sysmonlock);
        for(auto [gocpp_ignored, pp] : allp)
        {
            pp->trace.mSyscallID = - 1;
        }
        rec::Store(gocpp::recv(trace.gen), firstGen);
        for(; rec::Load(gocpp::recv(trace.exitingSyscall)) != 0; )
        {
            osyield();
        }
        auto tl = traceAcquire();
        rec::Gomaxprocs(gocpp::recv(tl), gomaxprocs);
        rec::STWStart(gocpp::recv(tl), stwStartTrace);
        if(gcphase == _GCmark || gcphase == _GCmarktermination)
        {
            rec::GCActive(gocpp::recv(tl));
        }
        rec::HeapGoal(gocpp::recv(tl));
        for(auto [gocpp_ignored, pp] : allp)
        {
            rec::end(gocpp::recv(rec::writeProcStatusForP(gocpp::recv(rec::writer(gocpp::recv(tl))), pp, pp == rec::ptr(gocpp::recv(tl.mp->p)))));
        }
        traceRelease(tl);
        unlock(& sched.sysmonlock);
        startTheWorld(stw);
        traceStartReadCPU();
        rec::start(gocpp::recv(traceAdvancer));
        semrelease(& traceAdvanceSema);
        return nullptr;
    }

    // StopTrace stops tracing, if it was previously enabled.
    // StopTrace only returns after all the reads for the trace have completed.
    void StopTrace()
    {
        traceAdvance(true);
    }

    // traceAdvance moves tracing to the next generation, and cleans up the current generation,
    // ensuring that it's flushed out before returning. If stopTrace is true, it disables tracing
    // altogether instead of advancing to the next generation.
    //
    // traceAdvanceSema must not be held.
    void traceAdvance(bool stopTrace)
    {
        semacquire(& traceAdvanceSema);
        auto gen = rec::Load(gocpp::recv(trace.gen));
        if(gen == 0)
        {
            semrelease(& traceAdvanceSema);
            return;
        }
        traceFrequency(gen);
        // Collect all the untraced Gs.
        struct untracedG
        {
            g* gp;
            uint64_t goid;
            int64_t mid;
            uint32_t status;
            golang::runtime::waitReason waitreason;
            bool inMarkAssist;

            using isGoStruct = void;

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << "" << gp;
                os << " " << goid;
                os << " " << mid;
                os << " " << status;
                os << " " << waitreason;
                os << " " << inMarkAssist;
                os << '}';
                return os;
            }
        };
        gocpp::slice<untracedG> untracedGs = {};
        forEachGRace([=](struct g* gp) mutable -> void
        {
            rec::readyNextGen(gocpp::recv(gp->trace), gen);
            if(rec::statusWasTraced(gocpp::recv(gp->trace), gen))
            {
                return;
            }
            auto ug = gocpp::Init<untracedG>([=](auto& x) {
                x.gp = gp;
                x.mid = - 1;
            });
            systemstack([=]() mutable -> void
            {
                auto me = getg()->m->curg;
                casGToWaiting(me, _Grunning, waitReasonTraceGoroutineStatus);
                auto s = suspendG(gp);
                if(! s.dead)
                {
                    ug.goid = s.g->goid;
                    if(s.g->m != nullptr)
                    {
                        ug.mid = int64_t(s.g->m->procid);
                    }
                    ug.status = readgstatus(s.g) &^ _Gscan;
                    ug.waitreason = s.g->waitreason;
                    ug.inMarkAssist = s.g->inMarkAssist;
                }
                resumeG(s);
                casgstatus(me, _Gwaiting, _Grunning);
            });
            if(ug.goid != 0)
            {
                untracedGs = append(untracedGs, ug);
            }
        });
        if(! stopTrace)
        {
            traceRegisterLabelsAndReasons(traceNextGen(gen));
        }
        semacquire(& worldsema);
        auto mp = acquirem();
        trace.lastNonZeroGen = gen;
        if(stopTrace)
        {
            systemstack([=]() mutable -> void
            {
                lock(& trace.lock);
                rec::Store(gocpp::recv(trace.shutdown), true);
                rec::Store(gocpp::recv(trace.gen), 0);
                unlock(& trace.lock);
            });
        }
        else
        {
            rec::Store(gocpp::recv(trace.gen), traceNextGen(gen));
        }
        if(! stopTrace)
        {
            auto tl = traceAcquire();
            rec::Gomaxprocs(gocpp::recv(tl), gomaxprocs);
            traceRelease(tl);
        }
        if(! stopTrace && (gcphase == _GCmark || gcphase == _GCmarktermination))
        {
            auto tl = traceAcquire();
            rec::GCActive(gocpp::recv(tl));
            traceRelease(tl);
        }
        releasem(mp);
        semrelease(& worldsema);
        lock(& sched.lock);
        auto mToFlush = allm;
        for(auto mp = mToFlush; mp != nullptr; mp = mp->alllink)
        {
            mp->trace.link = mp->alllink;
        }
        for(auto mp = sched.freem; mp != nullptr; mp = mp->freelink)
        {
            mp->trace.link = mToFlush;
            mToFlush = mp;
        }
        unlock(& sched.lock);
        // Iterate over our snapshot, flushing every buffer until we're done.
        //
        // Because trace writers read the generation while the seqlock is
        // held, we can be certain that when there are no writers there are
        // also no stale generation values left. Therefore, it's safe to flush
        // any buffers that remain in that generation's slot.
        auto debugDeadlock = false;
        systemstack([=]() mutable -> void
        {
            auto i = 0;
            auto detectedDeadlock = false;
            for(; mToFlush != nullptr; )
            {
                auto prev = & mToFlush;
                for(auto mp = *prev; mp != nullptr; )
                {
                    if(rec::Load(gocpp::recv(mp->trace.seqlock)) % 2 != 0)
                    {
                        prev = & mp->trace.link;
                        mp = mp->trace.link;
                        continue;
                    }
                    lock(& trace.lock);
                    auto bufp = & mp->trace.buf[gen % 2];
                    if(*bufp != nullptr)
                    {
                        traceBufFlush(*bufp, gen);
                        *bufp = nullptr;
                    }
                    unlock(& trace.lock);
                    *prev = mp->trace.link;
                    mp->trace.link = nullptr;
                    mp = *prev;
                }
                if(mToFlush != nullptr)
                {
                    osyield();
                }
                if(debugDeadlock)
                {
                    if(i > 100000 && ! detectedDeadlock)
                    {
                        detectedDeadlock = true;
                        println("runtime: failing to flush"_s);
                        for(auto mp = mToFlush; mp != nullptr; mp = mp->trace.link)
                        {
                            print("runtime: m="_s, mp->id, "\n"_s);
                        }
                    }
                    i++;
                }
            }
        });
        auto statusWriter = unsafeTraceWriter(gen, nullptr);
        for(auto [gocpp_ignored, ug] : untracedGs)
        {
            if(rec::statusWasTraced(gocpp::recv(ug.gp->trace), gen))
            {
                continue;
            }
            auto status = goStatusToTraceGoStatus(ug.status, ug.waitreason);
            statusWriter = rec::writeGoStatus(gocpp::recv(statusWriter), ug.goid, ug.mid, status, ug.inMarkAssist);
        }
        rec::end(gocpp::recv(rec::flush(gocpp::recv(statusWriter))));
        traceReadCPU(gen);
        systemstack([=]() mutable -> void
        {
            traceCPUFlush(gen);
            rec::dump(gocpp::recv(trace.stackTab[gen % 2]), gen);
            rec::reset(gocpp::recv(trace.stringTab[gen % 2]), gen);
            lock(& trace.lock);
            rec::Store(gocpp::recv(trace.flushedGen), gen);
            unlock(& trace.lock);
        });
        if(stopTrace)
        {
            semacquire(& traceShutdownSema);
            traceStopReadCPU();
        }
        else
        {
            semacquire(& worldsema);
            forEachP(waitReasonTraceProcStatus, [=](struct p* pp) mutable -> void
            {
                auto tl = traceAcquire();
                if(! rec::statusWasTraced(gocpp::recv(pp->trace), tl.gen))
                {
                    rec::end(gocpp::recv(rec::writeProcStatusForP(gocpp::recv(rec::writer(gocpp::recv(tl))), pp, false)));
                }
                traceRelease(tl);
            });
            for(auto [gocpp_ignored, pp] : allp.make_slice(len(allp), cap(allp)))
            {
                rec::readyNextGen(gocpp::recv(pp->trace), traceNextGen(gen));
            }
            semrelease(& worldsema);
        }
        semacquire(& trace.doneSema[gen % 2]);
        if(raceenabled)
        {
            raceacquire(gocpp::unsafe_pointer(& trace.doneSema[gen % 2]));
        }
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(! rec::empty(gocpp::recv(trace.full[gen % 2])))
            {
                go_throw("trace: non-empty full trace buffer for done generation"_s);
            }
            if(stopTrace)
            {
                if(! rec::empty(gocpp::recv(trace.full[1 - (gen % 2)])))
                {
                    go_throw("trace: non-empty full trace buffer for next generation"_s);
                }
                if(trace.reading != nullptr || rec::Load<g>(gocpp::recv(trace.reader)) != nullptr)
                {
                    go_throw("trace: reading after shutdown"_s);
                }
                for(; trace.empty != nullptr; )
                {
                    auto buf = trace.empty;
                    trace.empty = buf->link;
                    sysFree(gocpp::unsafe_pointer(buf), gocpp::Sizeof<traceBuf>(), & memstats.other_sys);
                }
                trace.headerWritten = false;
                rec::Store(gocpp::recv(trace.shutdown), false);
            }
            unlock(& trace.lock);
        });
        if(stopTrace)
        {
            auto mp = acquirem();
            for(auto [gocpp_ignored, pp] : allp.make_slice(0, cap(allp)))
            {
                pp->trace.inSweep = false;
                pp->trace.maySweep = false;
                pp->trace.swept = 0;
                pp->trace.reclaimed = 0;
            }
            releasem(mp);
        }
        semrelease1(& traceAdvanceSema, true, 0);
        if(stopTrace)
        {
            rec::stop(gocpp::recv(traceAdvancer));
            semrelease(& traceShutdownSema);
        }
    }

    uintptr_t traceNextGen(uintptr_t gen)
    {
        if(gen == ~ uintptr_t(0))
        {
            return 4;
        }
        return gen + 1;
    }

    // traceRegisterLabelsAndReasons re-registers mark worker labels and
    // goroutine stop/block reasons in the string table for the provided
    // generation. Note: the provided generation must not have started yet.
    void traceRegisterLabelsAndReasons(uintptr_t gen)
    {
        for(auto [i, label] : gcMarkWorkerModeStrings.make_slice(0))
        {
            trace.markWorkerLabels[gen % 2][i] = traceArg(rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, label));
        }
        for(auto [i, str] : traceBlockReasonStrings.make_slice(0))
        {
            trace.goBlockReasons[gen % 2][i] = traceArg(rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, str));
        }
        for(auto [i, str] : traceGoStopReasonStrings.make_slice(0))
        {
            trace.goStopReasons[gen % 2][i] = traceArg(rec::put(gocpp::recv(trace.stringTab[gen % 2]), gen, str));
        }
    }

    // ReadTrace returns the next chunk of binary tracing data, blocking until data
    // is available. If tracing is turned off and all the data accumulated while it
    // was on has been returned, ReadTrace returns nil. The caller must copy the
    // returned data before calling ReadTrace again.
    // ReadTrace must be called from one goroutine at a time.
    gocpp::slice<unsigned char> ReadTrace()
    {
        top:
        gocpp::slice<unsigned char> buf = {};
        bool park = {};
        systemstack([=]() mutable -> void
        {
            std::tie(buf, park) = readTrace0();
        });
        if(park)
        {
            gopark([=](struct g* gp, gocpp::unsafe_pointer _1) mutable -> bool
            {
                if(! rec::CompareAndSwapNoWB<g>(gocpp::recv(trace.reader), nullptr, gp))
                {
                    return false;
                }
                if(auto g2 = traceReader(); gp == g2)
                {
                    return false;
                }
                else
                if(g2 != nullptr)
                {
                    printlock();
                    println("runtime: got trace reader"_s, g2, g2->goid);
                    go_throw("unexpected trace reader"_s);
                }
                return true;
            }, nullptr, waitReasonTraceReaderBlocked, traceBlockSystemGoroutine, 2);
            goto top;
        }
        return buf;
    }

    // readTrace0 is ReadTrace's continuation on g0. This must run on the
    // system stack because it acquires trace.lock.
    //
    //go:systemstack
    std::tuple<gocpp::slice<unsigned char>, bool> readTrace0()
    {
        gocpp::Defer defer;
        try
        {
            gocpp::slice<unsigned char> buf;
            bool park;
            if(raceenabled)
            {
                if(getg()->racectx != 0)
                {
                    go_throw("expected racectx == 0"_s);
                }
                getg()->racectx = getg()->m->curg->racectx;
                defer.push_back([=]{ [=]() mutable -> void
                {
                    getg()->racectx = 0;
                }(); });
            }
            lock(& trace.lock);
            if(rec::Load<g>(gocpp::recv(trace.reader)) != nullptr)
            {
                unlock(& trace.lock);
                println("runtime: ReadTrace called from multiple goroutines simultaneously"_s);
                return {nullptr, false};
            }
            if(auto buf = trace.reading; buf != nullptr)
            {
                buf->link = trace.empty;
                trace.empty = buf;
                trace.reading = nullptr;
            }
            if(! trace.headerWritten)
            {
                trace.headerWritten = true;
                unlock(& trace.lock);
                return {gocpp::slice<unsigned char>("go 1.22 trace\x00\x00\x00"_s), false};
            }
            if(rec::Load(gocpp::recv(trace.readerGen)) == 0)
            {
                rec::Store(gocpp::recv(trace.readerGen), 1);
            }
            uintptr_t gen = {};
            for(; ; )
            {
                assertLockHeld(& trace.lock);
                gen = rec::Load(gocpp::recv(trace.readerGen));
                if(! rec::empty(gocpp::recv(trace.full[gen % 2])))
                {
                    break;
                }
                if(rec::Load(gocpp::recv(trace.flushedGen)) == gen)
                {
                    if(rec::Load(gocpp::recv(trace.shutdown)))
                    {
                        unlock(& trace.lock);
                        if(raceenabled)
                        {
                            racerelease(gocpp::unsafe_pointer(& trace.doneSema[gen % 2]));
                        }
                        semrelease(& trace.doneSema[gen % 2]);
                        return {nullptr, false};
                    }
                    rec::Store(gocpp::recv(trace.readerGen), rec::Load(gocpp::recv(trace.gen)));
                    unlock(& trace.lock);
                    if(raceenabled)
                    {
                        racerelease(gocpp::unsafe_pointer(& trace.doneSema[gen % 2]));
                    }
                    semrelease(& trace.doneSema[gen % 2]);
                    lock(& trace.lock);
                    continue;
                }
                rec::Store(gocpp::recv(trace.workAvailable), false);
                unlock(& trace.lock);
                return {nullptr, true};
            }
            auto tbuf = rec::pop(gocpp::recv(trace.full[gen % 2]));
            trace.reading = tbuf;
            unlock(& trace.lock);
            return {tbuf->arr.make_slice(0, tbuf->pos), false};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    // traceReader returns the trace reader that should be woken up, if any.
    // Callers should first check (traceEnabled() || traceShuttingDown()).
    //
    // This must run on the system stack because it acquires trace.lock.
    //
    //go:systemstack
    struct g* traceReader()
    {
        auto gp = traceReaderAvailable();
        if(gp == nullptr || ! rec::CompareAndSwapNoWB<g>(gocpp::recv(trace.reader), gp, nullptr))
        {
            return nullptr;
        }
        return gp;
    }

    // traceReaderAvailable returns the trace reader if it is not currently
    // scheduled and should be. Callers should first check that
    // (traceEnabled() || traceShuttingDown()) is true.
    struct g* traceReaderAvailable()
    {
        if(rec::Load(gocpp::recv(trace.flushedGen)) == rec::Load(gocpp::recv(trace.readerGen)) || rec::Load(gocpp::recv(trace.workAvailable)) || rec::Load(gocpp::recv(trace.shutdown)))
        {
            return rec::Load<g>(gocpp::recv(trace.reader));
        }
        return nullptr;
    }

    // Trace advancer goroutine.
    traceAdvancerState traceAdvancer;
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_2::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_2::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_2::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value)
    {
        return value.PrintTo(os);
    }


    
    template<typename T> requires gocpp::GoStruct<T>
    traceAdvancerState::operator T()
    {
        T result;
        result.timer = this->timer;
        result.done = this->done;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceAdvancerState::operator==(const T& ref) const
    {
        if (timer != ref.timer) return false;
        if (done != ref.done) return false;
        return true;
    }

    std::ostream& traceAdvancerState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << timer;
        os << " " << done;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceAdvancerState& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_3
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_3& value)
        {
            return value.PrintTo(os);
        }


    struct gocpp_id_4
            {

                using isGoStruct = void;

                template<typename T> requires gocpp::GoStruct<T>
                operator T()
                {
                    T result;
                    return result;
                }

                template<typename T> requires gocpp::GoStruct<T>
                bool operator==(const T& ref) const
                {
                    return true;
                }

                std::ostream& PrintTo(std::ostream& os) const
                {
                    os << '{';
                    os << '}';
                    return os;
                }
            };

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_4& value)
            {
                return value.PrintTo(os);
            }


    // start starts a new traceAdvancer.
    void rec::start(golang::runtime::traceAdvancerState* s)
    {
        s->done = gocpp::make(gocpp::Tag<gocpp::channel<gocpp_id_3>>());
        s->timer = newWakeableSleep();
        gocpp::go([&]{ [=]() mutable -> void
        {
            for(; traceEnabled(); )
            {
                rec::sleep(gocpp::recv(s->timer), int64_t(debug.traceadvanceperiod));
                traceAdvance(false);
            }
            s->done.send(gocpp_id_4 {});
        }(); });
    }

    // stop stops a traceAdvancer and blocks until it exits.
    void rec::stop(golang::runtime::traceAdvancerState* s)
    {
        rec::wake(gocpp::recv(s->timer));
        s->done.recv();
        close(s->done);
        rec::close(gocpp::recv(s->timer));
    }

    // traceAdvancePeriod is the approximate period between
    // new generations.
    
    template<typename T> requires gocpp::GoStruct<T>
    gocpp_id_5::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gocpp_id_5::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& gocpp_id_5::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_5& value)
    {
        return value.PrintTo(os);
    }


    // wakeableSleep manages a wakeable goroutine sleep.
    //
    // Users of this type must call init before first use and
    // close to free up resources. Once close is called, init
    // must be called before another use.
    
    template<typename T> requires gocpp::GoStruct<T>
    wakeableSleep::operator T()
    {
        T result;
        result.timer = this->timer;
        result.lock = this->lock;
        result.wakeup = this->wakeup;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool wakeableSleep::operator==(const T& ref) const
    {
        if (timer != ref.timer) return false;
        if (lock != ref.lock) return false;
        if (wakeup != ref.wakeup) return false;
        return true;
    }

    std::ostream& wakeableSleep::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << timer;
        os << " " << lock;
        os << " " << wakeup;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct wakeableSleep& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_6
        {

            using isGoStruct = void;

            template<typename T> requires gocpp::GoStruct<T>
            operator T()
            {
                T result;
                return result;
            }

            template<typename T> requires gocpp::GoStruct<T>
            bool operator==(const T& ref) const
            {
                return true;
            }

            std::ostream& PrintTo(std::ostream& os) const
            {
                os << '{';
                os << '}';
                return os;
            }
        };

        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value)
        {
            return value.PrintTo(os);
        }


    // newWakeableSleep initializes a new wakeableSleep and returns it.
    struct wakeableSleep* newWakeableSleep()
    {
        auto s = new(wakeableSleep);
        lockInit(& s->lock, lockRankWakeableSleep);
        s->wakeup = gocpp::make(gocpp::Tag<gocpp::channel<gocpp_id_6>>(), 1);
        s->timer = new(timer);
        s->timer->arg = s;
        s->timer->f = [=](go_any s, uintptr_t _1) mutable -> void
        {
            rec::wake(gocpp::recv(gocpp::getValue<wakeableSleep*>(s)));
        };
        return s;
    }

    // sleep sleeps for the provided duration in nanoseconds or until
    // another goroutine calls wake.
    //
    // Must not be called by more than one goroutine at a time and
    // must not be called concurrently with close.
    void rec::sleep(golang::runtime::wakeableSleep* s, int64_t ns)
    {
        resetTimer(s->timer, nanotime() + ns);
        lock(& s->lock);
        if(raceenabled)
        {
            raceacquire(gocpp::unsafe_pointer(& s->lock));
        }
        auto wakeup = s->wakeup;
        if(raceenabled)
        {
            racerelease(gocpp::unsafe_pointer(& s->lock));
        }
        unlock(& s->lock);
        wakeup.recv();
        stopTimer(s->timer);
    }

    struct gocpp_id_7
                {

                    using isGoStruct = void;

                    template<typename T> requires gocpp::GoStruct<T>
                    operator T()
                    {
                        T result;
                        return result;
                    }

                    template<typename T> requires gocpp::GoStruct<T>
                    bool operator==(const T& ref) const
                    {
                        return true;
                    }

                    std::ostream& PrintTo(std::ostream& os) const
                    {
                        os << '{';
                        os << '}';
                        return os;
                    }
                };

                std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value)
                {
                    return value.PrintTo(os);
                }


    // wake awakens any goroutine sleeping on the timer.
    //
    // Safe for concurrent use with all other methods.
    void rec::wake(golang::runtime::wakeableSleep* s)
    {
        lock(& s->lock);
        if(raceenabled)
        {
            raceacquire(gocpp::unsafe_pointer(& s->lock));
        }
        if(s->wakeup != nullptr)
        {
            //Go select emulation
            {
                int conditionId = -1;
                if(s->wakeup.trySend(gocpp_id_7 {})) { conditionId = 0; }
                switch(conditionId)
                {
                    case 0:
                        break;
                    default:
                        break;
                }
            }
            std::this_thread::yield();
        }
        if(raceenabled)
        {
            racerelease(gocpp::unsafe_pointer(& s->lock));
        }
        unlock(& s->lock);
    }

    // close wakes any goroutine sleeping on the timer and prevents
    // further sleeping on it.
    //
    // Once close is called, the wakeableSleep must no longer be used.
    //
    // It must only be called once no goroutine is sleeping on the
    // timer *and* nothing else will call wake concurrently.
    void rec::close(golang::runtime::wakeableSleep* s)
    {
        lock(& s->lock);
        if(raceenabled)
        {
            raceacquire(gocpp::unsafe_pointer(& s->lock));
        }
        auto wakeup = s->wakeup;
        s->wakeup = nullptr;
        close(wakeup);
        if(raceenabled)
        {
            racerelease(gocpp::unsafe_pointer(& s->lock));
        }
        unlock(& s->lock);
        return;
    }

}

