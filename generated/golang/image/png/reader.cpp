// generated by GoCpp from file '$(ImportDir)/image/png/reader.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/png/reader.h"
#include "gocpp/support.h"

#include "golang/compress/zlib/reader.h"
#include "golang/encoding/binary/binary.h"
// #include "golang/fmt/print.h"  [Ignored, known errors]
#include "golang/hash/crc32/crc32.h"
#include "golang/hash/hash.h"
#include "golang/image/color/color.h"
#include "golang/image/png/paeth.h"
#include "golang/image/format.h"
#include "golang/image/geom.h"
#include "golang/image/image.h"
// #include "golang/io/io.h"  [Ignored, known errors]

namespace golang::png
{
    int ctGrayscale = 0;
    int ctTrueColor = 2;
    int ctPaletted = 3;
    int ctGrayscaleAlpha = 4;
    int ctTrueColorAlpha = 6;
    int cbInvalid = 0;
    int cbG1 = 1;
    int cbG2 = 2;
    int cbG4 = 3;
    int cbG8 = 4;
    int cbGA8 = 5;
    int cbTC8 = 6;
    int cbP1 = 7;
    int cbP2 = 8;
    int cbP4 = 9;
    int cbP8 = 10;
    int cbTCA8 = 11;
    int cbG16 = 12;
    int cbGA16 = 13;
    int cbTC16 = 14;
    int cbTCA16 = 15;
    bool cbPaletted(int cb)
    {
        return cbP1 <= cb && cb <= cbP8;
    }

    bool cbTrueColor(int cb)
    {
        return cb == cbTC8 || cb == cbTC16;
    }

    int ftNone = 0;
    int ftSub = 1;
    int ftUp = 2;
    int ftAverage = 3;
    int ftPaeth = 4;
    int nFilter = 5;
    int itNone = 0;
    int itAdam7 = 1;
    
    std::ostream& interlaceScan::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << xFactor;
        os << " " << yFactor;
        os << " " << xOffset;
        os << " " << yOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct interlaceScan& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<interlaceScan> interlacing = gocpp::slice<interlaceScan> { {8, 8, 0, 0},  {8, 8, 4, 0},  {4, 8, 0, 4},  {4, 4, 2, 0},  {2, 4, 0, 2},  {2, 2, 1, 0},  {1, 2, 0, 1}};
    int dsStart = 0;
    int dsSeenIHDR = 1;
    int dsSeenPLTE = 2;
    int dsSeentRNS = 3;
    int dsSeenIDAT = 4;
    int dsSeenIEND = 5;
    std::string pngHeader = "\x89PNG\r\n\x1a\n";
    
    std::ostream& decoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << img;
        os << " " << crc;
        os << " " << width;
        os << " " << height;
        os << " " << depth;
        os << " " << palette;
        os << " " << cb;
        os << " " << stage;
        os << " " << idatLength;
        os << " " << tmp;
        os << " " << interlace;
        os << " " << useTransparent;
        os << " " << transparent;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decoder& value)
    {
        return value.PrintTo(os);
    }

    std::string Error(FormatError e)
    {
        return "png: invalid format: " + string(e);
    }

    png.FormatError chunkOrderError = FormatError("chunk out of order");
    std::string Error(UnsupportedError e)
    {
        return "png: unsupported feature: " + string(e);
    }

    std::string parseIHDR(struct decoder* d, uint32_t length)
    {
        if(length != 13)
        {
            return FormatError("bad IHDR length");
        }
        if(auto [_, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, 13)); err != nullptr)
        {
            return err;
        }
        Write(gocpp::recv(d->crc), d->tmp.make_slice(0, 13));
        if(d->tmp[10] != 0)
        {
            return UnsupportedError("compression method");
        }
        if(d->tmp[11] != 0)
        {
            return UnsupportedError("filter method");
        }
        if(d->tmp[12] != itNone && d->tmp[12] != itAdam7)
        {
            return FormatError("invalid interlace method");
        }
        d->interlace = int(d->tmp[12]);
        auto w = int32(Uint32(gocpp::recv(binary.BigEndian), d->tmp.make_slice(0, 4)));
        auto h = int32(Uint32(gocpp::recv(binary.BigEndian), d->tmp.make_slice(4, 8)));
        if(w <= 0 || h <= 0)
        {
            return FormatError("non-positive dimension");
        }
        auto nPixels64 = int64(w) * int64(h);
        auto nPixels = int(nPixels64);
        if(nPixels64 != int64(nPixels))
        {
            return UnsupportedError("dimension overflow");
        }
        if(nPixels != (nPixels * 8) / 8)
        {
            return UnsupportedError("dimension overflow");
        }
        d->cb = cbInvalid;
        d->depth = int(d->tmp[8]);
        //Go switch emulation
        {
            auto condition = d->depth;
            int conditionId = -1;
            if(condition == 1) { conditionId = 0; }
            else if(condition == 2) { conditionId = 1; }
            else if(condition == 4) { conditionId = 2; }
            else if(condition == 8) { conditionId = 3; }
            else if(condition == 16) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctPaletted) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG1;
                                break;
                            case 1:
                                d->cb = cbP1;
                                break;
                        }
                    }
                    break;
                case 1:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctPaletted) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG2;
                                break;
                            case 1:
                                d->cb = cbP2;
                                break;
                        }
                    }
                    break;
                case 2:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctPaletted) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG4;
                                break;
                            case 1:
                                d->cb = cbP4;
                                break;
                        }
                    }
                    break;
                case 3:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctTrueColor) { conditionId = 1; }
                        else if(condition == ctPaletted) { conditionId = 2; }
                        else if(condition == ctGrayscaleAlpha) { conditionId = 3; }
                        else if(condition == ctTrueColorAlpha) { conditionId = 4; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG8;
                                break;
                            case 1:
                                d->cb = cbTC8;
                                break;
                            case 2:
                                d->cb = cbP8;
                                break;
                            case 3:
                                d->cb = cbGA8;
                                break;
                            case 4:
                                d->cb = cbTCA8;
                                break;
                        }
                    }
                    break;
                case 4:
                    //Go switch emulation
                    {
                        auto condition = d->tmp[9];
                        int conditionId = -1;
                        if(condition == ctGrayscale) { conditionId = 0; }
                        else if(condition == ctTrueColor) { conditionId = 1; }
                        else if(condition == ctGrayscaleAlpha) { conditionId = 2; }
                        else if(condition == ctTrueColorAlpha) { conditionId = 3; }
                        switch(conditionId)
                        {
                            case 0:
                                d->cb = cbG16;
                                break;
                            case 1:
                                d->cb = cbTC16;
                                break;
                            case 2:
                                d->cb = cbGA16;
                                break;
                            case 3:
                                d->cb = cbTCA16;
                                break;
                        }
                    }
                    break;
            }
        }
        if(d->cb == cbInvalid)
        {
            return UnsupportedError(mocklib::Sprintf("bit depth %d, color type %d", d->tmp[8], d->tmp[9]));
        }
        std::tie(d->width, d->height) = std::tuple{int(w), int(h)};
        return verifyChecksum(gocpp::recv(d));
    }

    std::string parsePLTE(struct decoder* d, uint32_t length)
    {
        auto np = int(length / 3);
        if(length % 3 != 0 || np <= 0 || np > 256 || np > (1 << (unsigned int)(d->depth)))
        {
            return FormatError("bad PLTE length");
        }
        auto [n, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, 3 * np));
        if(err != nullptr)
        {
            return err;
        }
        Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbP1) { conditionId = 0; }
            if(condition == cbP2) { conditionId = 1; }
            if(condition == cbP4) { conditionId = 2; }
            if(condition == cbP8) { conditionId = 3; }
            else if(condition == cbTC8) { conditionId = 4; }
            else if(condition == cbTCA8) { conditionId = 5; }
            else if(condition == cbTC16) { conditionId = 6; }
            else if(condition == cbTCA16) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    d->palette = gocpp::make(color.Palette, 256);
                    for(auto i = 0; i < np; i++)
                    {
                        d->palette[i] = color::RGBA {d->tmp[3 * i + 0], d->tmp[3 * i + 1], d->tmp[3 * i + 2], 0xff};
                    }
                    for(auto i = np; i < 256; i++)
                    {
                        d->palette[i] = color::RGBA {0x00, 0x00, 0x00, 0xff};
                    }
                    d->palette = d->palette.make_slice(0, np);
                    break;
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                default:
                    return FormatError("PLTE, color type mismatch");
                    break;
            }
        }
        return verifyChecksum(gocpp::recv(d));
    }

    std::string parsetRNS(struct decoder* d, uint32_t length)
    {
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbG1) { conditionId = 0; }
            if(condition == cbG2) { conditionId = 1; }
            if(condition == cbG4) { conditionId = 2; }
            if(condition == cbG8) { conditionId = 3; }
            if(condition == cbG16) { conditionId = 4; }
            else if(condition == cbTC8) { conditionId = 5; }
            else if(condition == cbTC16) { conditionId = 6; }
            else if(condition == cbP1) { conditionId = 7; }
            else if(condition == cbP2) { conditionId = 8; }
            else if(condition == cbP4) { conditionId = 9; }
            else if(condition == cbP8) { conditionId = 10; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    if(length != 2)
                    {
                        return FormatError("bad tRNS length");
                    }
                    auto [n, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, length));
                    if(err != nullptr)
                    {
                        return err;
                    }
                    Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
                    copy(d->transparent.make_slice(0, ), d->tmp.make_slice(0, length));
                    //Go switch emulation
                    {
                        auto condition = d->cb;
                        int conditionId = -1;
                        if(condition == cbG1) { conditionId = 0; }
                        else if(condition == cbG2) { conditionId = 1; }
                        else if(condition == cbG4) { conditionId = 2; }
                        switch(conditionId)
                        {
                            case 0:
                                d->transparent[1] *= 0xff;
                                break;
                            case 1:
                                d->transparent[1] *= 0x55;
                                break;
                            case 2:
                                d->transparent[1] *= 0x11;
                                break;
                        }
                    }
                    d->useTransparent = true;
                    break;
                case 5:
                case 6:
                    if(length != 6)
                    {
                        return FormatError("bad tRNS length");
                    }
                    std::tie(n, err) = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, length));
                    if(err != nullptr)
                    {
                        return err;
                    }
                    Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
                    copy(d->transparent.make_slice(0, ), d->tmp.make_slice(0, length));
                    d->useTransparent = true;
                    break;
                case 7:
                case 8:
                case 9:
                case 10:
                    if(length > 256)
                    {
                        return FormatError("bad tRNS length");
                    }
                    std::tie(n, err) = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, length));
                    if(err != nullptr)
                    {
                        return err;
                    }
                    Write(gocpp::recv(d->crc), d->tmp.make_slice(0, n));
                    if(len(d->palette) < n)
                    {
                        d->palette = d->palette.make_slice(0, n);
                    }
                    for(auto i = 0; i < n; i++)
                    {
                        auto rgba = gocpp::getValue<image/color.RGBA>(d->palette[i]);
                        d->palette[i] = color::NRGBA {rgba.R, rgba.G, rgba.B, d->tmp[i]};
                    }
                    break;
                default:
                    return FormatError("tRNS, color type mismatch");
                    break;
            }
        }
        return verifyChecksum(gocpp::recv(d));
    }

    std::tuple<int, std::string> Read(struct decoder* d, gocpp::slice<unsigned char> p)
    {
        if(len(p) == 0)
        {
            return {0, nullptr};
        }
        for(; d->idatLength == 0; )
        {
            if(auto err = verifyChecksum(gocpp::recv(d)); err != nullptr)
            {
                return {0, err};
            }
            if(auto [_, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, 8)); err != nullptr)
            {
                return {0, err};
            }
            d->idatLength = Uint32(gocpp::recv(binary.BigEndian), d->tmp.make_slice(0, 4));
            if(string(d->tmp.make_slice(4, 8)) != "IDAT")
            {
                return {0, FormatError("not enough pixel data")};
            }
            Reset(gocpp::recv(d->crc));
            Write(gocpp::recv(d->crc), d->tmp.make_slice(4, 8));
        }
        if(int(d->idatLength) < 0)
        {
            return {0, UnsupportedError("IDAT chunk length overflow")};
        }
        auto [n, err] = Read(gocpp::recv(d->r), p.make_slice(0, min(len(p), int(d->idatLength))));
        Write(gocpp::recv(d->crc), p.make_slice(0, n));
        d->idatLength -= uint32_t(n);
        return {n, err};
    }

    std::tuple<image::Image, std::string> decode(struct decoder* d)
    {
        gocpp::Defer defer;
        auto [r, err] = NewReader(gocpp::recv(zlib), d);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        defer.push_back([=]{ Close(gocpp::recv(r)); });
        image::Image img = {};
        if(d->interlace == itNone)
        {
            std::tie(img, err) = readImagePass(gocpp::recv(d), r, 0, false);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
        }
        else
        if(d->interlace == itAdam7)
        {
            std::tie(img, err) = readImagePass(gocpp::recv(d), nullptr, 0, true);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            for(auto pass = 0; pass < 7; pass++)
            {
                auto [imagePass, err] = readImagePass(gocpp::recv(d), r, pass, false);
                if(err != nullptr)
                {
                    return {nullptr, err};
                }
                if(imagePass != nullptr)
                {
                    mergePassInto(gocpp::recv(d), img, imagePass, pass);
                }
            }
        }
        auto n = 0;
        for(auto i = 0; n == 0 && err == nullptr; i++)
        {
            if(i == 100)
            {
                return {nullptr, io.ErrNoProgress};
            }
            std::tie(n, err) = Read(gocpp::recv(r), d->tmp.make_slice(0, 1));
        }
        if(err != nullptr && err != io.go_EOF)
        {
            return {nullptr, FormatError(Error(gocpp::recv(err)))};
        }
        if(n != 0 || d->idatLength != 0)
        {
            return {nullptr, FormatError("too much pixel data")};
        }
        return {img, nullptr};
    }

    std::tuple<image::Image, std::string> readImagePass(struct decoder* d, io::Reader r, int pass, bool allocateOnly)
    {
        auto bitsPerPixel = 0;
        auto pixOffset = 0;
        image::Gray* gray = {};
        image::RGBA* rgba = {};
        image::Paletted* paletted = {};
        image::NRGBA* nrgba = {};
        image::Gray16* gray16 = {};
        image::RGBA64* rgba64 = {};
        image::NRGBA64* nrgba64 = {};
        image::Image img = {};
        auto [width, height] = std::tuple{d->width, d->height};
        if(d->interlace == itAdam7 && ! allocateOnly)
        {
            auto p = interlacing[pass];
            width = (width - p.xOffset + p.xFactor - 1) / p.xFactor;
            height = (height - p.yOffset + p.yFactor - 1) / p.yFactor;
            if(width == 0 || height == 0)
            {
                return {nullptr, nullptr};
            }
        }
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbG1) { conditionId = 0; }
            if(condition == cbG2) { conditionId = 1; }
            if(condition == cbG4) { conditionId = 2; }
            if(condition == cbG8) { conditionId = 3; }
            else if(condition == cbGA8) { conditionId = 4; }
            else if(condition == cbTC8) { conditionId = 5; }
            else if(condition == cbP1) { conditionId = 6; }
            else if(condition == cbP2) { conditionId = 7; }
            else if(condition == cbP4) { conditionId = 8; }
            else if(condition == cbP8) { conditionId = 9; }
            else if(condition == cbTCA8) { conditionId = 10; }
            else if(condition == cbG16) { conditionId = 11; }
            else if(condition == cbGA16) { conditionId = 12; }
            else if(condition == cbTC16) { conditionId = 13; }
            else if(condition == cbTCA16) { conditionId = 14; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    bitsPerPixel = d->depth;
                    if(d->useTransparent)
                    {
                        nrgba = NewNRGBA(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = nrgba;
                    }
                    else
                    {
                        gray = NewGray(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = gray;
                    }
                    break;
                case 4:
                    bitsPerPixel = 16;
                    nrgba = NewNRGBA(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                    img = nrgba;
                    break;
                case 5:
                    bitsPerPixel = 24;
                    if(d->useTransparent)
                    {
                        nrgba = NewNRGBA(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = nrgba;
                    }
                    else
                    {
                        rgba = NewRGBA(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = rgba;
                    }
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                    bitsPerPixel = d->depth;
                    paletted = NewPaletted(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height), d->palette);
                    img = paletted;
                    break;
                case 10:
                    bitsPerPixel = 32;
                    nrgba = NewNRGBA(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                    img = nrgba;
                    break;
                case 11:
                    bitsPerPixel = 16;
                    if(d->useTransparent)
                    {
                        nrgba64 = NewNRGBA64(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = nrgba64;
                    }
                    else
                    {
                        gray16 = NewGray16(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = gray16;
                    }
                    break;
                case 12:
                    bitsPerPixel = 32;
                    nrgba64 = NewNRGBA64(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                    img = nrgba64;
                    break;
                case 13:
                    bitsPerPixel = 48;
                    if(d->useTransparent)
                    {
                        nrgba64 = NewNRGBA64(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = nrgba64;
                    }
                    else
                    {
                        rgba64 = NewRGBA64(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                        img = rgba64;
                    }
                    break;
                case 14:
                    bitsPerPixel = 64;
                    nrgba64 = NewNRGBA64(gocpp::recv(image), Rect(gocpp::recv(image), 0, 0, width, height));
                    img = nrgba64;
                    break;
            }
        }
        if(allocateOnly)
        {
            return {img, nullptr};
        }
        auto bytesPerPixel = (bitsPerPixel + 7) / 8;
        auto rowSize = 1 + (int64(bitsPerPixel) * int64(width) + 7) / 8;
        if(rowSize != int64(int(rowSize)))
        {
            return {nullptr, UnsupportedError("dimension overflow")};
        }
        auto cr = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), rowSize);
        auto pr = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), rowSize);
        for(auto y = 0; y < height; y++)
        {
            auto [_, err] = ReadFull(gocpp::recv(io), r, cr);
            if(err != nullptr)
            {
                if(err == io.go_EOF || err == io.ErrUnexpectedEOF)
                {
                    return {nullptr, FormatError("not enough pixel data")};
                }
                return {nullptr, err};
            }
            auto cdat = cr.make_slice(1);
            auto pdat = pr.make_slice(1);
            //Go switch emulation
            {
                auto condition = cr[0];
                int conditionId = -1;
                if(condition == ftNone) { conditionId = 0; }
                else if(condition == ftSub) { conditionId = 1; }
                else if(condition == ftUp) { conditionId = 2; }
                else if(condition == ftAverage) { conditionId = 3; }
                else if(condition == ftPaeth) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                        break;
                    case 1:
                        for(auto i = bytesPerPixel; i < len(cdat); i++)
                        {
                            cdat[i] += cdat[i - bytesPerPixel];
                        }
                        break;
                    case 2:
                        for(auto [i, p] : pdat)
                        {
                            cdat[i] += p;
                        }
                        break;
                    case 3:
                        for(auto i = 0; i < bytesPerPixel; i++)
                        {
                            cdat[i] += pdat[i] / 2;
                        }
                        for(auto i = bytesPerPixel; i < len(cdat); i++)
                        {
                            cdat[i] += uint8_t((int(cdat[i - bytesPerPixel]) + int(pdat[i])) / 2);
                        }
                        break;
                    case 4:
                        filterPaeth(cdat, pdat, bytesPerPixel);
                        break;
                    default:
                        return {nullptr, FormatError("bad filter type")};
                        break;
                }
            }
            //Go switch emulation
            {
                auto condition = d->cb;
                int conditionId = -1;
                if(condition == cbG1) { conditionId = 0; }
                else if(condition == cbG2) { conditionId = 1; }
                else if(condition == cbG4) { conditionId = 2; }
                else if(condition == cbG8) { conditionId = 3; }
                else if(condition == cbGA8) { conditionId = 4; }
                else if(condition == cbTC8) { conditionId = 5; }
                else if(condition == cbP1) { conditionId = 6; }
                else if(condition == cbP2) { conditionId = 7; }
                else if(condition == cbP4) { conditionId = 8; }
                else if(condition == cbP8) { conditionId = 9; }
                else if(condition == cbTCA8) { conditionId = 10; }
                else if(condition == cbG16) { conditionId = 11; }
                else if(condition == cbGA16) { conditionId = 12; }
                else if(condition == cbTC16) { conditionId = 13; }
                else if(condition == cbTCA16) { conditionId = 14; }
                switch(conditionId)
                {
                    case 0:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x += 8)
                            {
                                auto b = cdat[x / 8];
                                for(auto x2 = 0; x2 < 8 && x + x2 < width; x2++)
                                {
                                    auto ycol = (b >> 7) * 0xff;
                                    auto acol = uint8_t(0xff);
                                    if(ycol == ty)
                                    {
                                        acol = 0x00;
                                    }
                                    SetNRGBA(gocpp::recv(nrgba), x + x2, y, color::NRGBA {ycol, ycol, ycol, acol});
                                    b <<= 1;
                                }
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x += 8)
                            {
                                auto b = cdat[x / 8];
                                for(auto x2 = 0; x2 < 8 && x + x2 < width; x2++)
                                {
                                    SetGray(gocpp::recv(gray), x + x2, y, color::Gray {(b >> 7) * 0xff});
                                    b <<= 1;
                                }
                            }
                        }
                        break;
                    case 1:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x += 4)
                            {
                                auto b = cdat[x / 4];
                                for(auto x2 = 0; x2 < 4 && x + x2 < width; x2++)
                                {
                                    auto ycol = (b >> 6) * 0x55;
                                    auto acol = uint8_t(0xff);
                                    if(ycol == ty)
                                    {
                                        acol = 0x00;
                                    }
                                    SetNRGBA(gocpp::recv(nrgba), x + x2, y, color::NRGBA {ycol, ycol, ycol, acol});
                                    b <<= 2;
                                }
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x += 4)
                            {
                                auto b = cdat[x / 4];
                                for(auto x2 = 0; x2 < 4 && x + x2 < width; x2++)
                                {
                                    SetGray(gocpp::recv(gray), x + x2, y, color::Gray {(b >> 6) * 0x55});
                                    b <<= 2;
                                }
                            }
                        }
                        break;
                    case 2:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x += 2)
                            {
                                auto b = cdat[x / 2];
                                for(auto x2 = 0; x2 < 2 && x + x2 < width; x2++)
                                {
                                    auto ycol = (b >> 4) * 0x11;
                                    auto acol = uint8_t(0xff);
                                    if(ycol == ty)
                                    {
                                        acol = 0x00;
                                    }
                                    SetNRGBA(gocpp::recv(nrgba), x + x2, y, color::NRGBA {ycol, ycol, ycol, acol});
                                    b <<= 4;
                                }
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x += 2)
                            {
                                auto b = cdat[x / 2];
                                for(auto x2 = 0; x2 < 2 && x + x2 < width; x2++)
                                {
                                    SetGray(gocpp::recv(gray), x + x2, y, color::Gray {(b >> 4) * 0x11});
                                    b <<= 4;
                                }
                            }
                        }
                        break;
                    case 3:
                        if(d->useTransparent)
                        {
                            auto ty = d->transparent[1];
                            for(auto x = 0; x < width; x++)
                            {
                                auto ycol = cdat[x];
                                auto acol = uint8_t(0xff);
                                if(ycol == ty)
                                {
                                    acol = 0x00;
                                }
                                SetNRGBA(gocpp::recv(nrgba), x, y, color::NRGBA {ycol, ycol, ycol, acol});
                            }
                        }
                        else
                        {
                            copy(gray->Pix.make_slice(pixOffset), cdat);
                            pixOffset += gray->Stride;
                        }
                        break;
                    case 4:
                        for(auto x = 0; x < width; x++)
                        {
                            auto ycol = cdat[2 * x + 0];
                            SetNRGBA(gocpp::recv(nrgba), x, y, color::NRGBA {ycol, ycol, ycol, cdat[2 * x + 1]});
                        }
                        break;
                    case 5:
                        if(d->useTransparent)
                        {
                            auto [pix, i, j] = std::tuple{nrgba->Pix, pixOffset, 0};
                            auto [tr, tg, tb] = std::tuple{d->transparent[1], d->transparent[3], d->transparent[5]};
                            for(auto x = 0; x < width; x++)
                            {
                                auto r = cdat[j + 0];
                                auto g = cdat[j + 1];
                                auto b = cdat[j + 2];
                                auto a = uint8_t(0xff);
                                if(r == tr && g == tg && b == tb)
                                {
                                    a = 0x00;
                                }
                                pix[i + 0] = r;
                                pix[i + 1] = g;
                                pix[i + 2] = b;
                                pix[i + 3] = a;
                                i += 4;
                                j += 3;
                            }
                            pixOffset += nrgba->Stride;
                        }
                        else
                        {
                            auto [pix, i, j] = std::tuple{rgba->Pix, pixOffset, 0};
                            for(auto x = 0; x < width; x++)
                            {
                                pix[i + 0] = cdat[j + 0];
                                pix[i + 1] = cdat[j + 1];
                                pix[i + 2] = cdat[j + 2];
                                pix[i + 3] = 0xff;
                                i += 4;
                                j += 3;
                            }
                            pixOffset += rgba->Stride;
                        }
                        break;
                    case 6:
                        for(auto x = 0; x < width; x += 8)
                        {
                            auto b = cdat[x / 8];
                            for(auto x2 = 0; x2 < 8 && x + x2 < width; x2++)
                            {
                                auto idx = b >> 7;
                                if(len(paletted->Palette) <= int(idx))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(idx) + 1);
                                }
                                SetColorIndex(gocpp::recv(paletted), x + x2, y, idx);
                                b <<= 1;
                            }
                        }
                        break;
                    case 7:
                        for(auto x = 0; x < width; x += 4)
                        {
                            auto b = cdat[x / 4];
                            for(auto x2 = 0; x2 < 4 && x + x2 < width; x2++)
                            {
                                auto idx = b >> 6;
                                if(len(paletted->Palette) <= int(idx))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(idx) + 1);
                                }
                                SetColorIndex(gocpp::recv(paletted), x + x2, y, idx);
                                b <<= 2;
                            }
                        }
                        break;
                    case 8:
                        for(auto x = 0; x < width; x += 2)
                        {
                            auto b = cdat[x / 2];
                            for(auto x2 = 0; x2 < 2 && x + x2 < width; x2++)
                            {
                                auto idx = b >> 4;
                                if(len(paletted->Palette) <= int(idx))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(idx) + 1);
                                }
                                SetColorIndex(gocpp::recv(paletted), x + x2, y, idx);
                                b <<= 4;
                            }
                        }
                        break;
                    case 9:
                        if(len(paletted->Palette) != 256)
                        {
                            for(auto x = 0; x < width; x++)
                            {
                                if(len(paletted->Palette) <= int(cdat[x]))
                                {
                                    paletted->Palette = paletted->Palette.make_slice(0, int(cdat[x]) + 1);
                                }
                            }
                        }
                        copy(paletted->Pix.make_slice(pixOffset), cdat);
                        pixOffset += paletted->Stride;
                        break;
                    case 10:
                        copy(nrgba->Pix.make_slice(pixOffset), cdat);
                        pixOffset += nrgba->Stride;
                        break;
                    case 11:
                        if(d->useTransparent)
                        {
                            auto ty = (uint16_t(d->transparent[0]) << 8) | uint16_t(d->transparent[1]);
                            for(auto x = 0; x < width; x++)
                            {
                                auto ycol = (uint16_t(cdat[2 * x + 0]) << 8) | uint16_t(cdat[2 * x + 1]);
                                auto acol = uint16_t(0xffff);
                                if(ycol == ty)
                                {
                                    acol = 0x0000;
                                }
                                SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {ycol, ycol, ycol, acol});
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x++)
                            {
                                auto ycol = (uint16_t(cdat[2 * x + 0]) << 8) | uint16_t(cdat[2 * x + 1]);
                                SetGray16(gocpp::recv(gray16), x, y, color::Gray16 {ycol});
                            }
                        }
                        break;
                    case 12:
                        for(auto x = 0; x < width; x++)
                        {
                            auto ycol = (uint16_t(cdat[4 * x + 0]) << 8) | uint16_t(cdat[4 * x + 1]);
                            auto acol = (uint16_t(cdat[4 * x + 2]) << 8) | uint16_t(cdat[4 * x + 3]);
                            SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {ycol, ycol, ycol, acol});
                        }
                        break;
                    case 13:
                        if(d->useTransparent)
                        {
                            auto tr = (uint16_t(d->transparent[0]) << 8) | uint16_t(d->transparent[1]);
                            auto tg = (uint16_t(d->transparent[2]) << 8) | uint16_t(d->transparent[3]);
                            auto tb = (uint16_t(d->transparent[4]) << 8) | uint16_t(d->transparent[5]);
                            for(auto x = 0; x < width; x++)
                            {
                                auto rcol = (uint16_t(cdat[6 * x + 0]) << 8) | uint16_t(cdat[6 * x + 1]);
                                auto gcol = (uint16_t(cdat[6 * x + 2]) << 8) | uint16_t(cdat[6 * x + 3]);
                                auto bcol = (uint16_t(cdat[6 * x + 4]) << 8) | uint16_t(cdat[6 * x + 5]);
                                auto acol = uint16_t(0xffff);
                                if(rcol == tr && gcol == tg && bcol == tb)
                                {
                                    acol = 0x0000;
                                }
                                SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {rcol, gcol, bcol, acol});
                            }
                        }
                        else
                        {
                            for(auto x = 0; x < width; x++)
                            {
                                auto rcol = (uint16_t(cdat[6 * x + 0]) << 8) | uint16_t(cdat[6 * x + 1]);
                                auto gcol = (uint16_t(cdat[6 * x + 2]) << 8) | uint16_t(cdat[6 * x + 3]);
                                auto bcol = (uint16_t(cdat[6 * x + 4]) << 8) | uint16_t(cdat[6 * x + 5]);
                                SetRGBA64(gocpp::recv(rgba64), x, y, color::RGBA64 {rcol, gcol, bcol, 0xffff});
                            }
                        }
                        break;
                    case 14:
                        for(auto x = 0; x < width; x++)
                        {
                            auto rcol = (uint16_t(cdat[8 * x + 0]) << 8) | uint16_t(cdat[8 * x + 1]);
                            auto gcol = (uint16_t(cdat[8 * x + 2]) << 8) | uint16_t(cdat[8 * x + 3]);
                            auto bcol = (uint16_t(cdat[8 * x + 4]) << 8) | uint16_t(cdat[8 * x + 5]);
                            auto acol = (uint16_t(cdat[8 * x + 6]) << 8) | uint16_t(cdat[8 * x + 7]);
                            SetNRGBA64(gocpp::recv(nrgba64), x, y, color::NRGBA64 {rcol, gcol, bcol, acol});
                        }
                        break;
                }
            }
            std::tie(pr, cr) = std::tuple{cr, pr};
        }
        return {img, nullptr};
    }

    void mergePassInto(struct decoder* d, image::Image dst, image::Image src, int pass)
    {
        auto p = interlacing[pass];
        gocpp::slice<uint8_t> srcPix = {};
        gocpp::slice<uint8_t> dstPix = {};
        int stride = {};
        image::Rectangle rect = {};
        int bytesPerPixel = {};
        //Go type switch emulation
        {
            const auto& gocpp_id_0 = gocpp::type_info(dst);
            int conditionId = -1;
            if(gocpp_id_0 == typeid(image.Alpha*)) { conditionId = 0; }
            else if(gocpp_id_0 == typeid(image.Alpha16*)) { conditionId = 1; }
            else if(gocpp_id_0 == typeid(image.Gray*)) { conditionId = 2; }
            else if(gocpp_id_0 == typeid(image.Gray16*)) { conditionId = 3; }
            else if(gocpp_id_0 == typeid(image.NRGBA*)) { conditionId = 4; }
            else if(gocpp_id_0 == typeid(image.NRGBA64*)) { conditionId = 5; }
            else if(gocpp_id_0 == typeid(image.Paletted*)) { conditionId = 6; }
            else if(gocpp_id_0 == typeid(image.RGBA*)) { conditionId = 7; }
            else if(gocpp_id_0 == typeid(image.RGBA64*)) { conditionId = 8; }
            switch(conditionId)
            {
                case 0:
                {
                    image.Alpha* target = gocpp::any_cast<image.Alpha*>(dst);
                    srcPix = gocpp::getValue<image.Alpha*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 1;
                    break;
                }
                case 1:
                {
                    image.Alpha16* target = gocpp::any_cast<image.Alpha16*>(dst);
                    srcPix = gocpp::getValue<image.Alpha16*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 2;
                    break;
                }
                case 2:
                {
                    image.Gray* target = gocpp::any_cast<image.Gray*>(dst);
                    srcPix = gocpp::getValue<image.Gray*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 1;
                    break;
                }
                case 3:
                {
                    image.Gray16* target = gocpp::any_cast<image.Gray16*>(dst);
                    srcPix = gocpp::getValue<image.Gray16*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 2;
                    break;
                }
                case 4:
                {
                    image.NRGBA* target = gocpp::any_cast<image.NRGBA*>(dst);
                    srcPix = gocpp::getValue<image.NRGBA*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 4;
                    break;
                }
                case 5:
                {
                    image.NRGBA64* target = gocpp::any_cast<image.NRGBA64*>(dst);
                    srcPix = gocpp::getValue<image.NRGBA64*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 8;
                    break;
                }
                case 6:
                {
                    image.Paletted* target = gocpp::any_cast<image.Paletted*>(dst);
                    auto source = gocpp::getValue<image.Paletted*>(src);
                    srcPix = source->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 1;
                    if(len(target->Palette) < len(source->Palette))
                    {
                        target->Palette = source->Palette;
                    }
                    break;
                }
                case 7:
                {
                    image.RGBA* target = gocpp::any_cast<image.RGBA*>(dst);
                    srcPix = gocpp::getValue<image.RGBA*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 4;
                    break;
                }
                case 8:
                {
                    image.RGBA64* target = gocpp::any_cast<image.RGBA64*>(dst);
                    srcPix = gocpp::getValue<image.RGBA64*>(src)->Pix;
                    std::tie(dstPix, stride, rect) = std::tuple{target->Pix, target->Stride, target->Rect};
                    bytesPerPixel = 8;
                    break;
                }
            }
        }
        auto [s, bounds] = std::tuple{0, Bounds(gocpp::recv(src))};
        for(auto y = bounds.Min.Y; y < bounds.Max.Y; y++)
        {
            auto dBase = (y * p.yFactor + p.yOffset - rect.Min.Y) * stride + (p.xOffset - rect.Min.X) * bytesPerPixel;
            for(auto x = bounds.Min.X; x < bounds.Max.X; x++)
            {
                auto d = dBase + x * p.xFactor * bytesPerPixel;
                copy(dstPix.make_slice(d), srcPix.make_slice(s, s + bytesPerPixel));
                s += bytesPerPixel;
            }
        }
    }

    std::string parseIDAT(struct decoder* d, uint32_t length)
    {
        std::string err;
        d->idatLength = length;
        std::tie(d->img, err) = decode(gocpp::recv(d));
        if(err != nullptr)
        {
            std::string err;
            return err;
        }
        return verifyChecksum(gocpp::recv(d));
    }

    std::string parseIEND(struct decoder* d, uint32_t length)
    {
        if(length != 0)
        {
            return FormatError("bad IEND length");
        }
        return verifyChecksum(gocpp::recv(d));
    }

    std::string parseChunk(struct decoder* d, bool configOnly)
    {
        if(auto [_, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, 8)); err != nullptr)
        {
            return err;
        }
        auto length = Uint32(gocpp::recv(binary.BigEndian), d->tmp.make_slice(0, 4));
        Reset(gocpp::recv(d->crc));
        Write(gocpp::recv(d->crc), d->tmp.make_slice(4, 8));
        //Go switch emulation
        {
            auto condition = string(d->tmp.make_slice(4, 8));
            int conditionId = -1;
            if(condition == "IHDR") { conditionId = 0; }
            else if(condition == "PLTE") { conditionId = 1; }
            else if(condition == "tRNS") { conditionId = 2; }
            else if(condition == "IDAT") { conditionId = 3; }
            else if(condition == "IEND") { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    if(d->stage != dsStart)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeenIHDR;
                    return parseIHDR(gocpp::recv(d), length);
                    break;
                case 1:
                    if(d->stage != dsSeenIHDR)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeenPLTE;
                    return parsePLTE(gocpp::recv(d), length);
                    break;
                case 2:
                    if(cbPaletted(d->cb))
                    {
                        if(d->stage != dsSeenPLTE)
                        {
                            return chunkOrderError;
                        }
                    }
                    else
                    if(cbTrueColor(d->cb))
                    {
                        if(d->stage != dsSeenIHDR && d->stage != dsSeenPLTE)
                        {
                            return chunkOrderError;
                        }
                    }
                    else
                    if(d->stage != dsSeenIHDR)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeentRNS;
                    return parsetRNS(gocpp::recv(d), length);
                    break;
                case 3:
                    if(d->stage < dsSeenIHDR || d->stage > dsSeenIDAT || (d->stage == dsSeenIHDR && cbPaletted(d->cb)))
                    {
                        return chunkOrderError;
                    }
                    else
                    if(d->stage == dsSeenIDAT)
                    {
                        break;
                    }
                    d->stage = dsSeenIDAT;
                    if(configOnly)
                    {
                        return nullptr;
                    }
                    return parseIDAT(gocpp::recv(d), length);
                    break;
                case 4:
                    if(d->stage != dsSeenIDAT)
                    {
                        return chunkOrderError;
                    }
                    d->stage = dsSeenIEND;
                    return parseIEND(gocpp::recv(d), length);
                    break;
            }
        }
        if(length > 0x7fffffff)
        {
            return FormatError(mocklib::Sprintf("Bad chunk length: %d", length));
        }
        gocpp::array<unsigned char, 4096> ignored = {};
        for(; length > 0; )
        {
            auto [n, err] = ReadFull(gocpp::recv(io), d->r, ignored.make_slice(0, min(len(ignored), int(length))));
            if(err != nullptr)
            {
                return err;
            }
            Write(gocpp::recv(d->crc), ignored.make_slice(0, n));
            length -= uint32_t(n);
        }
        return verifyChecksum(gocpp::recv(d));
    }

    std::string verifyChecksum(struct decoder* d)
    {
        if(auto [_, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, 4)); err != nullptr)
        {
            return err;
        }
        if(Uint32(gocpp::recv(binary.BigEndian), d->tmp.make_slice(0, 4)) != Sum32(gocpp::recv(d->crc)))
        {
            return FormatError("invalid checksum");
        }
        return nullptr;
    }

    std::string checkHeader(struct decoder* d)
    {
        auto [_, err] = ReadFull(gocpp::recv(io), d->r, d->tmp.make_slice(0, len(pngHeader)));
        if(err != nullptr)
        {
            return err;
        }
        if(string(d->tmp.make_slice(0, len(pngHeader))) != pngHeader)
        {
            return FormatError("not a PNG file");
        }
        return nullptr;
    }

    std::tuple<image::Image, std::string> Decode(io::Reader r)
    {
        auto d = gocpp::InitPtr<decoder>([](decoder& x) { x.r = r; x.crc = NewIEEE(gocpp::recv(crc32)); });
        if(auto err = checkHeader(gocpp::recv(d)); err != nullptr)
        {
            if(err == io.go_EOF)
            {
                err = io.ErrUnexpectedEOF;
            }
            return {nullptr, err};
        }
        for(; d->stage != dsSeenIEND; )
        {
            if(auto err = parseChunk(gocpp::recv(d), false); err != nullptr)
            {
                if(err == io.go_EOF)
                {
                    err = io.ErrUnexpectedEOF;
                }
                return {nullptr, err};
            }
        }
        return {d->img, nullptr};
    }

    std::tuple<image::Config, std::string> DecodeConfig(io::Reader r)
    {
        auto d = gocpp::InitPtr<decoder>([](decoder& x) { x.r = r; x.crc = NewIEEE(gocpp::recv(crc32)); });
        if(auto err = checkHeader(gocpp::recv(d)); err != nullptr)
        {
            if(err == io.go_EOF)
            {
                err = io.ErrUnexpectedEOF;
            }
            return {image::Config {}, err};
        }
        for(; ; )
        {
            if(auto err = parseChunk(gocpp::recv(d), true); err != nullptr)
            {
                if(err == io.go_EOF)
                {
                    err = io.ErrUnexpectedEOF;
                }
                return {image::Config {}, err};
            }
            if(cbPaletted(d->cb))
            {
                if(d->stage >= dsSeentRNS)
                {
                    break;
                }
            }
            else
            {
                if(d->stage >= dsSeenIHDR)
                {
                    break;
                }
            }
        }
        color::Model cm = {};
        //Go switch emulation
        {
            auto condition = d->cb;
            int conditionId = -1;
            if(condition == cbG1) { conditionId = 0; }
            if(condition == cbG2) { conditionId = 1; }
            if(condition == cbG4) { conditionId = 2; }
            if(condition == cbG8) { conditionId = 3; }
            else if(condition == cbGA8) { conditionId = 4; }
            else if(condition == cbTC8) { conditionId = 5; }
            else if(condition == cbP1) { conditionId = 6; }
            else if(condition == cbP2) { conditionId = 7; }
            else if(condition == cbP4) { conditionId = 8; }
            else if(condition == cbP8) { conditionId = 9; }
            else if(condition == cbTCA8) { conditionId = 10; }
            else if(condition == cbG16) { conditionId = 11; }
            else if(condition == cbGA16) { conditionId = 12; }
            else if(condition == cbTC16) { conditionId = 13; }
            else if(condition == cbTCA16) { conditionId = 14; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    cm = color.GrayModel;
                    break;
                case 4:
                    cm = color.NRGBAModel;
                    break;
                case 5:
                    cm = color.RGBAModel;
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                    cm = d->palette;
                    break;
                case 10:
                    cm = color.NRGBAModel;
                    break;
                case 11:
                    cm = color.Gray16Model;
                    break;
                case 12:
                    cm = color.NRGBA64Model;
                    break;
                case 13:
                    cm = color.RGBA64Model;
                    break;
                case 14:
                    cm = color.NRGBA64Model;
                    break;
            }
        }
        return {gocpp::Init<image::Config>([](image::Config& x) { x.ColorModel = cm; x.Width = d->width; x.Height = d->height; }), nullptr};
    }

    void init()
    {
        RegisterFormat(gocpp::recv(image), "png", pngHeader, Decode, DecodeConfig);
    }

}

