// generated by GoCpp from file '$(ImportDir)/runtime/sema.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/sema.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct semaRoot
    {
        mutex lock;
        sudog* treap;
        atomic::Uint32 nwait;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct semaRoot& value);
    void sync_runtime_Semacquire(uint32_t* addr);
    void poll_runtime_Semacquire(uint32_t* addr);
    void sync_runtime_Semrelease(uint32_t* addr, bool handoff, int skipframes);
    void sync_runtime_SemacquireMutex(uint32_t* addr, bool lifo, int skipframes);
    void sync_runtime_SemacquireRWMutexR(uint32_t* addr, bool lifo, int skipframes);
    void sync_runtime_SemacquireRWMutex(uint32_t* addr, bool lifo, int skipframes);
    void poll_runtime_Semrelease(uint32_t* addr);
    void readyWithTime(struct sudog* s, int traceskip);
    void semacquire(uint32_t* addr);
    void semacquire1(uint32_t* addr, bool lifo, golang::runtime::semaProfileFlags profile, int skipframes, golang::runtime::waitReason reason);
    void semrelease(uint32_t* addr);
    void semrelease1(uint32_t* addr, bool handoff, int skipframes);
    bool cansemacquire(uint32_t* addr);
    struct notifyList
    {
        atomic::Uint32 wait;
        uint32_t notify;
        mutex lock;
        sudog* head;
        sudog* tail;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct notifyList& value);
    bool less(uint32_t a, uint32_t b);
    uint32_t notifyListAdd(struct notifyList* l);
    void notifyListWait(struct notifyList* l, uint32_t t);
    void notifyListNotifyAll(struct notifyList* l);
    void notifyListNotifyOne(struct notifyList* l);
    void notifyListCheck(uintptr_t sz);
    int64_t sync_nanotime();

    namespace rec
    {
        struct semaRoot* rootFor(golang::runtime::semTable* t, uint32_t* addr);
        void queue(struct semaRoot* root, uint32_t* addr, struct sudog* s, bool lifo);
        std::tuple<struct sudog*, int64_t, int64_t> dequeue(struct semaRoot* root, uint32_t* addr);
        void rotateLeft(struct semaRoot* root, struct sudog* x);
        void rotateRight(struct semaRoot* root, struct sudog* y);
    }
}

