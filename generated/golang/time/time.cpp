// generated by GoCpp from file '$(ImportDir)/time/time.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/time.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/time/format.h"
#include "golang/time/format_rfc3339.h"
#include "golang/time/zoneinfo.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace errors::rec;
        using namespace time::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Time::operator T()
    {
        T result;
        result.wall = this->wall;
        result.ext = this->ext;
        result.loc = this->loc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Time::operator==(const T& ref) const
    {
        if (wall != ref.wall) return false;
        if (ext != ref.ext) return false;
        if (loc != ref.loc) return false;
        return true;
    }

    std::ostream& Time::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wall;
        os << " " << ext;
        os << " " << loc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Time& value)
    {
        return value.PrintTo(os);
    }

    int32_t rec::nsec(struct Time* t)
    {
        return int32_t(t->wall & nsecMask);
    }

    int64_t rec::sec(struct Time* t)
    {
        if(t->wall & hasMonotonic != 0)
        {
            return wallToInternal + int64_t((t->wall << 1) >> (nsecShift + 1));
        }
        return t->ext;
    }

    int64_t rec::unixSec(struct Time* t)
    {
        return rec::sec(gocpp::recv(t)) + internalToUnix;
    }

    void rec::addSec(struct Time* t, int64_t d)
    {
        if(t->wall & hasMonotonic != 0)
        {
            auto sec = int64_t((t->wall << 1) >> (nsecShift + 1));
            auto dsec = sec + d;
            if(0 <= dsec && dsec <= (1 << 33) - 1)
            {
                t->wall = t->wall & nsecMask | (uint64_t(dsec) << nsecShift) | hasMonotonic;
                return;
            }
            rec::stripMono(gocpp::recv(t));
        }
        auto sum = t->ext + d;
        if((sum > t->ext) == (d > 0))
        {
            t->ext = sum;
        }
        else
        if(d > 0)
        {
            t->ext = (1 << 63) - 1;
        }
        else
        {
            t->ext = - ((1 << 63) - 1);
        }
    }

    void rec::setLoc(struct Time* t, struct Location* loc)
    {
        if(loc == & utcLoc)
        {
            loc = nullptr;
        }
        rec::stripMono(gocpp::recv(t));
        t->loc = loc;
    }

    void rec::stripMono(struct Time* t)
    {
        if(t->wall & hasMonotonic != 0)
        {
            t->ext = rec::sec(gocpp::recv(t));
            t->wall &= nsecMask;
        }
    }

    void rec::setMono(struct Time* t, int64_t m)
    {
        if(t->wall & hasMonotonic == 0)
        {
            auto sec = t->ext;
            if(sec < minWall || maxWall < sec)
            {
                return;
            }
            t->wall |= hasMonotonic | (uint64_t(sec - minWall) << nsecShift);
        }
        t->ext = m;
    }

    int64_t rec::mono(struct Time* t)
    {
        if(t->wall & hasMonotonic == 0)
        {
            return 0;
        }
        return t->ext;
    }

    bool rec::After(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return t.ext > u.ext;
        }
        auto ts = rec::sec(gocpp::recv(t));
        auto us = rec::sec(gocpp::recv(u));
        return ts > us || ts == us && rec::nsec(gocpp::recv(t)) > rec::nsec(gocpp::recv(u));
    }

    bool rec::Before(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return t.ext < u.ext;
        }
        auto ts = rec::sec(gocpp::recv(t));
        auto us = rec::sec(gocpp::recv(u));
        return ts < us || ts == us && rec::nsec(gocpp::recv(t)) < rec::nsec(gocpp::recv(u));
    }

    int rec::Compare(struct Time t, struct Time u)
    {
        int64_t tc = {};
        int64_t uc = {};
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            std::tie(tc, uc) = std::tuple{t.ext, u.ext};
        }
        else
        {
            std::tie(tc, uc) = std::tuple{rec::sec(gocpp::recv(t)), rec::sec(gocpp::recv(u))};
            if(tc == uc)
            {
                std::tie(tc, uc) = std::tuple{int64_t(rec::nsec(gocpp::recv(t))), int64_t(rec::nsec(gocpp::recv(u)))};
            }
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(tc < uc) { conditionId = 0; }
            else if(tc > uc) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return - 1;
                    break;
                case 1:
                    return + 1;
                    break;
            }
        }
        return 0;
    }

    bool rec::Equal(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return t.ext == u.ext;
        }
        return rec::sec(gocpp::recv(t)) == rec::sec(gocpp::recv(u)) && rec::nsec(gocpp::recv(t)) == rec::nsec(gocpp::recv(u));
    }

    std::string rec::String(time::Month m)
    {
        if(January <= m && m <= December)
        {
            return longMonthNames[m - 1];
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 20);
        auto n = fmtInt(buf, uint64_t(m));
        return "%!Month(" + string(buf.make_slice(n)) + ")";
    }

    std::string rec::String(time::Weekday d)
    {
        if(Sunday <= d && d <= Saturday)
        {
            return longDayNames[d];
        }
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 20);
        auto n = fmtInt(buf, uint64_t(d));
        return "%!Weekday(" + string(buf.make_slice(n)) + ")";
    }

    bool rec::IsZero(struct Time t)
    {
        return rec::sec(gocpp::recv(t)) == 0 && rec::nsec(gocpp::recv(t)) == 0;
    }

    uint64_t rec::abs(struct Time t)
    {
        auto l = t.loc;
        if(l == nullptr || l == & localLoc)
        {
            l = rec::get(gocpp::recv(l));
        }
        auto sec = rec::unixSec(gocpp::recv(t));
        if(l != & utcLoc)
        {
            if(l->cacheZone != nullptr && l->cacheStart <= sec && sec < l->cacheEnd)
            {
                sec += int64_t(l->cacheZone->offset);
            }
            else
            {
                auto [gocpp_id_4, offset, gocpp_id_5, gocpp_id_6, gocpp_id_7] = rec::lookup(gocpp::recv(l), sec);
                sec += int64_t(offset);
            }
        }
        return uint64_t(sec + (unixToInternal + internalToAbsolute));
    }

    std::tuple<std::string, int, uint64_t> rec::locabs(struct Time t)
    {
        std::string name;
        int offset;
        uint64_t abs;
        auto l = t.loc;
        if(l == nullptr || l == & localLoc)
        {
            std::string name;
            int offset;
            uint64_t abs;
            l = rec::get(gocpp::recv(l));
        }
        auto sec = rec::unixSec(gocpp::recv(t));
        if(l != & utcLoc)
        {
            std::string name;
            int offset;
            uint64_t abs;
            if(l->cacheZone != nullptr && l->cacheStart <= sec && sec < l->cacheEnd)
            {
                std::string name;
                int offset;
                uint64_t abs;
                name = l->cacheZone->name;
                offset = l->cacheZone->offset;
            }
            else
            {
                std::string name;
                int offset;
                uint64_t abs;
                std::tie(name, offset, gocpp_id_8, gocpp_id_9, gocpp_id_10) = rec::lookup(gocpp::recv(l), sec);
            }
            sec += int64_t(offset);
        }
        else
        {
            std::string name;
            int offset;
            uint64_t abs;
            name = "UTC";
        }
        abs = uint64_t(sec + (unixToInternal + internalToAbsolute));
        return {name, offset, abs};
    }

    std::tuple<int, time::Month, int> rec::Date(struct Time t)
    {
        int year;
        time::Month month;
        int day;
        std::tie(year, month, day, gocpp_id_11) = rec::date(gocpp::recv(t), true);
        return {year, month, day};
    }

    int rec::Year(struct Time t)
    {
        auto [year, gocpp_id_15, gocpp_id_16, gocpp_id_17] = rec::date(gocpp::recv(t), false);
        return year;
    }

    time::Month rec::Month(struct Time t)
    {
        auto [gocpp_id_21, month, gocpp_id_22, gocpp_id_23] = rec::date(gocpp::recv(t), true);
        return month;
    }

    int rec::Day(struct Time t)
    {
        auto [gocpp_id_27, gocpp_id_28, day, gocpp_id_29] = rec::date(gocpp::recv(t), true);
        return day;
    }

    time::Weekday rec::Weekday(struct Time t)
    {
        return absWeekday(rec::abs(gocpp::recv(t)));
    }

    time::Weekday absWeekday(uint64_t abs)
    {
        auto sec = (abs + uint64_t(Monday) * secondsPerDay) % secondsPerWeek;
        return Weekday(int(sec) / secondsPerDay);
    }

    std::tuple<int, int> rec::ISOWeek(struct Time t)
    {
        int year;
        int week;
        auto abs = rec::abs(gocpp::recv(t));
        auto d = Thursday - absWeekday(abs);
        if(d == 4)
        {
            int year;
            int week;
            d = - 3;
        }
        abs += uint64_t(d) * secondsPerDay;
        auto [year, gocpp_id_32, gocpp_id_33, yday] = absDate(abs, false);
        return {year, yday / 7 + 1};
    }

    std::tuple<int, int, int> rec::Clock(struct Time t)
    {
        int hour;
        int min;
        int sec;
        return absClock(rec::abs(gocpp::recv(t)));
    }

    std::tuple<int, int, int> absClock(uint64_t abs)
    {
        int hour;
        int min;
        int sec;
        sec = int(abs % secondsPerDay);
        hour = sec / secondsPerHour;
        sec -= hour * secondsPerHour;
        min = sec / secondsPerMinute;
        sec -= min * secondsPerMinute;
        return {hour, min, sec};
    }

    int rec::Hour(struct Time t)
    {
        return int(rec::abs(gocpp::recv(t)) % secondsPerDay) / secondsPerHour;
    }

    int rec::Minute(struct Time t)
    {
        return int(rec::abs(gocpp::recv(t)) % secondsPerHour) / secondsPerMinute;
    }

    int rec::Second(struct Time t)
    {
        return int(rec::abs(gocpp::recv(t)) % secondsPerMinute);
    }

    int rec::Nanosecond(struct Time t)
    {
        return int(rec::nsec(gocpp::recv(t)));
    }

    int rec::YearDay(struct Time t)
    {
        auto [gocpp_id_37, gocpp_id_38, gocpp_id_39, yday] = rec::date(gocpp::recv(t), false);
        return yday + 1;
    }

    std::string rec::String(time::Duration d)
    {
        gocpp::array<unsigned char, 32> arr = {};
        auto n = rec::format(gocpp::recv(d), & arr);
        return string(arr.make_slice(n));
    }

    int rec::format(time::Duration d, gocpp::array<unsigned char, 32>* buf)
    {
        auto w = len(buf);
        auto u = uint64_t(d);
        auto neg = d < 0;
        if(neg)
        {
            u = - u;
        }
        if(u < uint64_t(Second))
        {
            int prec = {};
            w--;
            buf[w] = 's';
            w--;
            //Go switch emulation
            {
                int conditionId = -1;
                if(u == 0) { conditionId = 0; }
                else if(u < uint64_t(Microsecond)) { conditionId = 1; }
                else if(u < uint64_t(Millisecond)) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        buf[w] = '0';
                        return w;
                        break;
                    case 1:
                        prec = 0;
                        buf[w] = 'n';
                        break;
                    case 2:
                        prec = 3;
                        w--;
                        copy(buf.make_slice(w), "µ");
                        break;
                    default:
                        prec = 6;
                        buf[w] = 'm';
                        break;
                }
            }
            std::tie(w, u) = fmtFrac(buf.make_slice(0, w), u, prec);
            w = fmtInt(buf.make_slice(0, w), u);
        }
        else
        {
            w--;
            buf[w] = 's';
            std::tie(w, u) = fmtFrac(buf.make_slice(0, w), u, 9);
            w = fmtInt(buf.make_slice(0, w), u % 60);
            u /= 60;
            if(u > 0)
            {
                w--;
                buf[w] = 'm';
                w = fmtInt(buf.make_slice(0, w), u % 60);
                u /= 60;
                if(u > 0)
                {
                    w--;
                    buf[w] = 'h';
                    w = fmtInt(buf.make_slice(0, w), u);
                }
            }
        }
        if(neg)
        {
            w--;
            buf[w] = '-';
        }
        return w;
    }

    std::tuple<int, uint64_t> fmtFrac(gocpp::slice<unsigned char> buf, uint64_t v, int prec)
    {
        int nw;
        uint64_t nv;
        auto w = len(buf);
        auto print = false;
        for(auto i = 0; i < prec; i++)
        {
            int nw;
            uint64_t nv;
            auto digit = v % 10;
            print = print || digit != 0;
            if(print)
            {
                int nw;
                uint64_t nv;
                w--;
                buf[w] = unsigned char(digit) + '0';
            }
            v /= 10;
        }
        if(print)
        {
            int nw;
            uint64_t nv;
            w--;
            buf[w] = '.';
        }
        return {w, v};
    }

    int fmtInt(gocpp::slice<unsigned char> buf, uint64_t v)
    {
        auto w = len(buf);
        if(v == 0)
        {
            w--;
            buf[w] = '0';
        }
        else
        {
            for(; v > 0; )
            {
                w--;
                buf[w] = unsigned char(v % 10) + '0';
                v /= 10;
            }
        }
        return w;
    }

    int64_t rec::Nanoseconds(time::Duration d)
    {
        return int64_t(d);
    }

    int64_t rec::Microseconds(time::Duration d)
    {
        return int64_t(d) / 1e3;
    }

    int64_t rec::Milliseconds(time::Duration d)
    {
        return int64_t(d) / 1e6;
    }

    double rec::Seconds(time::Duration d)
    {
        auto sec = d / Second;
        auto nsec = d % Second;
        return double(sec) + double(nsec) / 1e9;
    }

    double rec::Minutes(time::Duration d)
    {
        auto min = d / Minute;
        auto nsec = d % Minute;
        return double(min) + double(nsec) / (60 * 1e9);
    }

    double rec::Hours(time::Duration d)
    {
        auto hour = d / Hour;
        auto nsec = d % Hour;
        return double(hour) + double(nsec) / (60 * 60 * 1e9);
    }

    time::Duration rec::Truncate(time::Duration d, time::Duration m)
    {
        if(m <= 0)
        {
            return d;
        }
        return d - d % m;
    }

    bool lessThanHalf(time::Duration x, time::Duration y)
    {
        return uint64_t(x) + uint64_t(x) < uint64_t(y);
    }

    time::Duration rec::Round(time::Duration d, time::Duration m)
    {
        if(m <= 0)
        {
            return d;
        }
        auto r = d % m;
        if(d < 0)
        {
            r = - r;
            if(lessThanHalf(r, m))
            {
                return d + r;
            }
            if(auto d1 = d - m + r; d1 < d)
            {
                return d1;
            }
            return minDuration;
        }
        if(lessThanHalf(r, m))
        {
            return d - r;
        }
        if(auto d1 = d + m - r; d1 > d)
        {
            return d1;
        }
        return maxDuration;
    }

    time::Duration rec::Abs(time::Duration d)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(d >= 0) { conditionId = 0; }
            else if(d == minDuration) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return d;
                    break;
                case 1:
                    return maxDuration;
                    break;
                default:
                    return - d;
                    break;
            }
        }
    }

    struct Time rec::Add(struct Time t, time::Duration d)
    {
        auto dsec = int64_t(d / 1e9);
        auto nsec = rec::nsec(gocpp::recv(t)) + int32_t(d % 1e9);
        if(nsec >= 1e9)
        {
            dsec++;
            nsec -= 1e9;
        }
        else
        if(nsec < 0)
        {
            dsec--;
            nsec += 1e9;
        }
        t.wall = t.wall &^ nsecMask | uint64_t(nsec);
        rec::addSec(gocpp::recv(t), dsec);
        if(t.wall & hasMonotonic != 0)
        {
            auto te = t.ext + int64_t(d);
            if(d < 0 && te > t.ext || d > 0 && te < t.ext)
            {
                rec::stripMono(gocpp::recv(t));
            }
            else
            {
                t.ext = te;
            }
        }
        return t;
    }

    time::Duration rec::Sub(struct Time t, struct Time u)
    {
        if(t.wall & u.wall & hasMonotonic != 0)
        {
            return subMono(t.ext, u.ext);
        }
        auto d = Duration(rec::sec(gocpp::recv(t)) - rec::sec(gocpp::recv(u))) * Second + Duration(rec::nsec(gocpp::recv(t)) - rec::nsec(gocpp::recv(u)));
        //Go switch emulation
        {
            int conditionId = -1;
            if(rec::Equal(gocpp::recv(rec::Add(gocpp::recv(u), d)), t)) { conditionId = 0; }
            else if(rec::Before(gocpp::recv(t), u)) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return d;
                    break;
                case 1:
                    return minDuration;
                    break;
                default:
                    return maxDuration;
                    break;
            }
        }
    }

    time::Duration subMono(int64_t t, int64_t u)
    {
        auto d = Duration(t - u);
        if(d < 0 && t > u)
        {
            return maxDuration;
        }
        if(d > 0 && t < u)
        {
            return minDuration;
        }
        return d;
    }

    time::Duration Since(struct Time t)
    {
        if(t.wall & hasMonotonic != 0)
        {
            return subMono(runtimeNano() - startNano, t.ext);
        }
        return rec::Sub(gocpp::recv(Now()), t);
    }

    time::Duration Until(struct Time t)
    {
        if(t.wall & hasMonotonic != 0)
        {
            return subMono(t.ext, runtimeNano() - startNano);
        }
        return rec::Sub(gocpp::recv(t), Now());
    }

    struct Time rec::AddDate(struct Time t, int years, int months, int days)
    {
        auto [year, month, day] = rec::Date(gocpp::recv(t));
        auto [hour, min, sec] = rec::Clock(gocpp::recv(t));
        return Date(year + years, month + Month(months), day + days, hour, min, sec, int(rec::nsec(gocpp::recv(t))), rec::Location(gocpp::recv(t)));
    }

    std::tuple<int, time::Month, int, int> rec::date(struct Time t, bool full)
    {
        int year;
        time::Month month;
        int day;
        int yday;
        return absDate(rec::abs(gocpp::recv(t)), full);
    }

    std::tuple<int, time::Month, int, int> absDate(uint64_t abs, bool full)
    {
        int year;
        time::Month month;
        int day;
        int yday;
        auto d = abs / secondsPerDay;
        auto n = d / daysPer400Years;
        auto y = 400 * n;
        d -= daysPer400Years * n;
        n = d / daysPer100Years;
        n -= n >> 2;
        y += 100 * n;
        d -= daysPer100Years * n;
        n = d / daysPer4Years;
        y += 4 * n;
        d -= daysPer4Years * n;
        n = d / 365;
        n -= n >> 2;
        y += n;
        d -= 365 * n;
        year = int(int64_t(y) + absoluteZeroYear);
        yday = int(d);
        if(! full)
        {
            int year;
            time::Month month;
            int day;
            int yday;
            return {year, month, day, yday};
        }
        day = yday;
        if(isLeap(year))
        {
            int year;
            time::Month month;
            int day;
            int yday;
            //Go switch emulation
            {
                int conditionId = -1;
                if(day > 31 + 29 - 1) { conditionId = 0; }
                else if(day == 31 + 29 - 1) { conditionId = 1; }
                switch(conditionId)
                {
                    int year;
                    time::Month month;
                    int day;
                    int yday;
                    case 0:
                        day--;
                        break;
                    case 1:
                        month = February;
                        day = 29;
                        return {year, month, day, yday};
                        break;
                }
            }
        }
        month = Month(day / 31);
        auto end = int(daysBefore[month + 1]);
        int begin = {};
        if(day >= end)
        {
            int year;
            time::Month month;
            int day;
            int yday;
            month++;
            begin = end;
        }
        else
        {
            int year;
            time::Month month;
            int day;
            int yday;
            begin = int(daysBefore[month]);
        }
        month++;
        day = day - begin + 1;
        return {year, month, day, yday};
    }

    gocpp::array_base<int32_t> daysBefore = gocpp::array_base<int32_t> {0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31};
    int daysIn(time::Month m, int year)
    {
        if(m == February && isLeap(year))
        {
            return 29;
        }
        return int(daysBefore[m] - daysBefore[m - 1]);
    }

    uint64_t daysSinceEpoch(int year)
    {
        auto y = uint64_t(int64_t(year) - absoluteZeroYear);
        auto n = y / 400;
        y -= 400 * n;
        auto d = daysPer400Years * n;
        n = y / 100;
        y -= 100 * n;
        d += daysPer100Years * n;
        n = y / 4;
        y -= 4 * n;
        d += daysPer4Years * n;
        n = y;
        d += 365 * n;
        return d;
    }

    std::tuple<int64_t, int32_t, int64_t> now()
    /* convertBlockStmt, nil block */;

    int64_t runtimeNano()
    /* convertBlockStmt, nil block */;

    int64_t startNano = runtimeNano() - 1;
    struct Time Now()
    {
        auto [sec, nsec, mono] = now();
        mono -= startNano;
        sec += unixToInternal - minWall;
        if((uint64_t(sec) >> 33) != 0)
        {
            return Time {uint64_t(nsec), sec + minWall, Local};
        }
        return Time {hasMonotonic | (uint64_t(sec) << nsecShift) | uint64_t(nsec), mono, Local};
    }

    struct Time unixTime(int64_t sec, int32_t nsec)
    {
        return Time {uint64_t(nsec), sec + unixToInternal, Local};
    }

    struct Time rec::UTC(struct Time t)
    {
        rec::setLoc(gocpp::recv(t), & utcLoc);
        return t;
    }

    struct Time rec::Local(struct Time t)
    {
        rec::setLoc(gocpp::recv(t), Local);
        return t;
    }

    struct Time rec::In(struct Time t, struct Location* loc)
    {
        if(loc == nullptr)
        {
            gocpp::panic("time: missing Location in call to Time.In");
        }
        rec::setLoc(gocpp::recv(t), loc);
        return t;
    }

    struct Location* rec::Location(struct Time t)
    {
        auto l = t.loc;
        if(l == nullptr)
        {
            l = UTC;
        }
        return l;
    }

    std::tuple<std::string, int> rec::Zone(struct Time t)
    {
        std::string name;
        int offset;
        std::tie(name, offset, gocpp_id_40, gocpp_id_41, gocpp_id_42) = rec::lookup(gocpp::recv(t.loc), rec::unixSec(gocpp::recv(t)));
        return {name, offset};
    }

    std::tuple<struct Time, struct Time> rec::ZoneBounds(struct Time t)
    {
        struct Time start;
        struct Time end;
        auto [gocpp_id_46, gocpp_id_47, startSec, endSec, gocpp_id_48] = rec::lookup(gocpp::recv(t.loc), rec::unixSec(gocpp::recv(t)));
        if(startSec != alpha)
        {
            struct Time start;
            struct Time end;
            start = unixTime(startSec, 0);
            rec::setLoc(gocpp::recv(start), t.loc);
        }
        if(endSec != omega)
        {
            struct Time start;
            struct Time end;
            end = unixTime(endSec, 0);
            rec::setLoc(gocpp::recv(end), t.loc);
        }
        return {start, end};
    }

    int64_t rec::Unix(struct Time t)
    {
        return rec::unixSec(gocpp::recv(t));
    }

    int64_t rec::UnixMilli(struct Time t)
    {
        return rec::unixSec(gocpp::recv(t)) * 1e3 + int64_t(rec::nsec(gocpp::recv(t))) / 1e6;
    }

    int64_t rec::UnixMicro(struct Time t)
    {
        return rec::unixSec(gocpp::recv(t)) * 1e6 + int64_t(rec::nsec(gocpp::recv(t))) / 1e3;
    }

    int64_t rec::UnixNano(struct Time t)
    {
        return (rec::unixSec(gocpp::recv(t))) * 1e9 + int64_t(rec::nsec(gocpp::recv(t)));
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalBinary(struct Time t)
    {
        int16_t offsetMin = {};
        int8_t offsetSec = {};
        auto version = timeBinaryVersionV1;
        if(rec::Location(gocpp::recv(t)) == UTC)
        {
            offsetMin = - 1;
        }
        else
        {
            auto [gocpp_id_50, offset] = rec::Zone(gocpp::recv(t));
            if(offset % 60 != 0)
            {
                version = timeBinaryVersionV2;
                offsetSec = int8_t(offset % 60);
            }
            offset /= 60;
            if(offset < - 32768 || offset == - 1 || offset > 32767)
            {
                return {nullptr, errors::New("Time.MarshalBinary: unexpected zone offset")};
            }
            offsetMin = int16_t(offset);
        }
        auto sec = rec::sec(gocpp::recv(t));
        auto nsec = rec::nsec(gocpp::recv(t));
        auto enc = gocpp::slice<unsigned char> {version, unsigned char(sec >> 56), unsigned char(sec >> 48), unsigned char(sec >> 40), unsigned char(sec >> 32), unsigned char(sec >> 24), unsigned char(sec >> 16), unsigned char(sec >> 8), unsigned char(sec), unsigned char(nsec >> 24), unsigned char(nsec >> 16), unsigned char(nsec >> 8), unsigned char(nsec), unsigned char(offsetMin >> 8), unsigned char(offsetMin)};
        if(version == timeBinaryVersionV2)
        {
            enc = append(enc, unsigned char(offsetSec));
        }
        return {enc, nullptr};
    }

    struct gocpp::error rec::UnmarshalBinary(struct Time* t, gocpp::slice<unsigned char> data)
    {
        auto buf = data;
        if(len(buf) == 0)
        {
            return errors::New("Time.UnmarshalBinary: no data");
        }
        auto version = buf[0];
        if(version != timeBinaryVersionV1 && version != timeBinaryVersionV2)
        {
            return errors::New("Time.UnmarshalBinary: unsupported version");
        }
        auto wantLen = 1 + 8 + 4 + 2;
        if(version == timeBinaryVersionV2)
        {
            wantLen++;
        }
        if(len(buf) != wantLen)
        {
            return errors::New("Time.UnmarshalBinary: invalid length");
        }
        buf = buf.make_slice(1);
        auto sec = int64_t(buf[7]) | (int64_t(buf[6]) << 8) | (int64_t(buf[5]) << 16) | (int64_t(buf[4]) << 24) | (int64_t(buf[3]) << 32) | (int64_t(buf[2]) << 40) | (int64_t(buf[1]) << 48) | (int64_t(buf[0]) << 56);
        buf = buf.make_slice(8);
        auto nsec = int32_t(buf[3]) | (int32_t(buf[2]) << 8) | (int32_t(buf[1]) << 16) | (int32_t(buf[0]) << 24);
        buf = buf.make_slice(4);
        auto offset = int(int16_t(buf[1]) | (int16_t(buf[0]) << 8)) * 60;
        if(version == timeBinaryVersionV2)
        {
            offset += int(buf[2]);
        }
        *t = Time {};
        t->wall = uint64_t(nsec);
        t->ext = sec;
        if(offset == - 1 * 60)
        {
            rec::setLoc(gocpp::recv(t), & utcLoc);
        }
        else
        if(auto [gocpp_id_55, localoff, gocpp_id_56, gocpp_id_57, gocpp_id_58] = rec::lookup(gocpp::recv(Local), rec::unixSec(gocpp::recv(t))); offset == localoff)
        {
            rec::setLoc(gocpp::recv(t), Local);
        }
        else
        {
            rec::setLoc(gocpp::recv(t), FixedZone("", offset));
        }
        return nullptr;
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::GobEncode(struct Time t)
    {
        return rec::MarshalBinary(gocpp::recv(t));
    }

    struct gocpp::error rec::GobDecode(struct Time* t, gocpp::slice<unsigned char> data)
    {
        return rec::UnmarshalBinary(gocpp::recv(t), data);
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalJSON(struct Time t)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(RFC3339Nano) + len(""""));
        b = append(b, '"');
        gocpp::error err;
        std::tie(b, err) = rec::appendStrictRFC3339(gocpp::recv(t), b);
        b = append(b, '"');
        if(err != nullptr)
        {
            return {nullptr, errors::New("Time.MarshalJSON: " + rec::Error(gocpp::recv(err)))};
        }
        return {b, nullptr};
    }

    struct gocpp::error rec::UnmarshalJSON(struct Time* t, gocpp::slice<unsigned char> data)
    {
        if(string(data) == "null")
        {
            return nullptr;
        }
        if(len(data) < 2 || data[0] != '"' || data[len(data) - 1] != '"')
        {
            return errors::New("Time.UnmarshalJSON: input is not a JSON string");
        }
        data = data.make_slice(len("""), len(data) - len("""));
        gocpp::error err = {};
        std::tie(*t, err) = parseStrictRFC3339(data);
        return err;
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::MarshalText(struct Time t)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(RFC3339Nano));
        gocpp::error err;
        std::tie(b, err) = rec::appendStrictRFC3339(gocpp::recv(t), b);
        if(err != nullptr)
        {
            return {nullptr, errors::New("Time.MarshalText: " + rec::Error(gocpp::recv(err)))};
        }
        return {b, nullptr};
    }

    struct gocpp::error rec::UnmarshalText(struct Time* t, gocpp::slice<unsigned char> data)
    {
        gocpp::error err = {};
        std::tie(*t, err) = parseStrictRFC3339(data);
        return err;
    }

    struct Time Unix(int64_t sec, int64_t nsec)
    {
        if(nsec < 0 || nsec >= 1e9)
        {
            auto n = nsec / 1e9;
            sec += n;
            nsec -= n * 1e9;
            if(nsec < 0)
            {
                nsec += 1e9;
                sec--;
            }
        }
        return unixTime(sec, int32_t(nsec));
    }

    struct Time UnixMilli(int64_t msec)
    {
        return Unix(msec / 1e3, (msec % 1e3) * 1e6);
    }

    struct Time UnixMicro(int64_t usec)
    {
        return Unix(usec / 1e6, (usec % 1e6) * 1e3);
    }

    bool rec::IsDST(struct Time t)
    {
        auto [gocpp_id_63, gocpp_id_64, gocpp_id_65, gocpp_id_66, isDST] = rec::lookup(gocpp::recv(t.loc), rec::Unix(gocpp::recv(t)));
        return isDST;
    }

    bool isLeap(int year)
    {
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
    }

    std::tuple<int, int> norm(int hi, int lo, int base)
    {
        int nhi;
        int nlo;
        if(lo < 0)
        {
            int nhi;
            int nlo;
            auto n = (- lo - 1) / base + 1;
            hi -= n;
            lo += n * base;
        }
        if(lo >= base)
        {
            int nhi;
            int nlo;
            auto n = lo / base;
            hi += n;
            lo -= n * base;
        }
        return {hi, lo};
    }

    struct Time Date(int year, time::Month month, int day, int hour, int min, int sec, int nsec, struct Location* loc)
    {
        if(loc == nullptr)
        {
            gocpp::panic("time: missing Location in call to Date");
        }
        auto m = int(month) - 1;
        std::tie(year, m) = norm(year, m, 12);
        month = Month(m) + 1;
        std::tie(sec, nsec) = norm(sec, nsec, 1e9);
        std::tie(min, sec) = norm(min, sec, 60);
        std::tie(hour, min) = norm(hour, min, 60);
        std::tie(day, hour) = norm(day, hour, 24);
        auto d = daysSinceEpoch(year);
        d += uint64_t(daysBefore[month - 1]);
        if(isLeap(year) && month >= March)
        {
            d++;
        }
        d += uint64_t(day - 1);
        auto abs = d * secondsPerDay;
        abs += uint64_t(hour * secondsPerHour + min * secondsPerMinute + sec);
        auto unix = int64_t(abs) + (absoluteToInternal + internalToUnix);
        auto [gocpp_id_69, offset, start, end, gocpp_id_70] = rec::lookup(gocpp::recv(loc), unix);
        if(offset != 0)
        {
            auto utc = unix - int64_t(offset);
            if(utc < start || utc >= end)
            {
                std::tie(gocpp_id_71, offset, gocpp_id_72, gocpp_id_73, gocpp_id_74) = rec::lookup(gocpp::recv(loc), utc);
            }
            unix -= int64_t(offset);
        }
        auto t = unixTime(unix, int32_t(nsec));
        rec::setLoc(gocpp::recv(t), loc);
        return t;
    }

    struct Time rec::Truncate(struct Time t, time::Duration d)
    {
        rec::stripMono(gocpp::recv(t));
        if(d <= 0)
        {
            return t;
        }
        auto [gocpp_id_76, r] = div(t, d);
        return rec::Add(gocpp::recv(t), - r);
    }

    struct Time rec::Round(struct Time t, time::Duration d)
    {
        rec::stripMono(gocpp::recv(t));
        if(d <= 0)
        {
            return t;
        }
        auto [gocpp_id_78, r] = div(t, d);
        if(lessThanHalf(r, d))
        {
            return rec::Add(gocpp::recv(t), - r);
        }
        return rec::Add(gocpp::recv(t), d - r);
    }

    std::tuple<int, time::Duration> div(struct Time t, time::Duration d)
    {
        int qmod2;
        time::Duration r;
        auto neg = false;
        auto nsec = rec::nsec(gocpp::recv(t));
        auto sec = rec::sec(gocpp::recv(t));
        if(sec < 0)
        {
            int qmod2;
            time::Duration r;
            neg = true;
            sec = - sec;
            nsec = - nsec;
            if(nsec < 0)
            {
                int qmod2;
                time::Duration r;
                nsec += 1e9;
                sec--;
            }
        }
        //Go switch emulation
        {
            int conditionId = -1;
            if(d < Second && Second % (d + d) == 0) { conditionId = 0; }
            else if(d % Second == 0) { conditionId = 1; }
            switch(conditionId)
            {
                int qmod2;
                time::Duration r;
                case 0:
                    qmod2 = int(nsec / int32_t(d)) & 1;
                    r = Duration(nsec % int32_t(d));
                    break;
                case 1:
                    auto d1 = int64_t(d / Second);
                    qmod2 = int(sec / d1) & 1;
                    r = Duration(sec % d1) * Second + Duration(nsec);
                    break;
                default:
                    auto sec = uint64_t(sec);
                    auto tmp = (sec >> 32) * 1e9;
                    auto u1 = tmp >> 32;
                    auto u0 = tmp << 32;
                    tmp = (sec & 0xFFFFFFFF) * 1e9;
                    uint64_t u0x;
                    std::tie(u0x, u0) = std::tuple{u0, u0 + tmp};
                    if(u0 < u0x)
                    {
                        int qmod2;
                        time::Duration r;
                        u1++;
                    }
                    std::tie(u0x, u0) = std::tuple{u0, u0 + uint64_t(nsec)};
                    if(u0 < u0x)
                    {
                        int qmod2;
                        time::Duration r;
                        u1++;
                    }
                    auto d1 = uint64_t(d);
                    for(; (d1 >> 63) != 1; )
                    {
                        int qmod2;
                        time::Duration r;
                        d1 <<= 1;
                    }
                    auto d0 = uint64_t(0);
                    for(; ; )
                    {
                        int qmod2;
                        time::Duration r;
                        qmod2 = 0;
                        if(u1 > d1 || u1 == d1 && u0 >= d0)
                        {
                            int qmod2;
                            time::Duration r;
                            qmod2 = 1;
                            std::tie(u0x, u0) = std::tuple{u0, u0 - d0};
                            if(u0 > u0x)
                            {
                                int qmod2;
                                time::Duration r;
                                u1--;
                            }
                            u1 -= d1;
                        }
                        if(d1 == 0 && d0 == uint64_t(d))
                        {
                            int qmod2;
                            time::Duration r;
                            break;
                        }
                        d0 >>= 1;
                        d0 |= (d1 & 1) << 63;
                        d1 >>= 1;
                    }
                    r = Duration(u0);
                    break;
            }
        }
        if(neg && r != 0)
        {
            int qmod2;
            time::Duration r;
            qmod2 ^= 1;
            r = d - r;
        }
        return {qmod2, r};
    }

}

