// generated by GoCpp from file '$(ImportDir)/compress/flate/inflate.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/flate/inflate.fwd.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/dict_decoder.h"
#include "golang/io/io.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

namespace golang::flate
{
    struct ReadError
    {
        int64_t Offset;
        gocpp::error Err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ReadError& value);
    struct WriteError
    {
        int64_t Offset;
        gocpp::error Err;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct WriteError& value);
    struct Resetter : gocpp::Interface
    {
        Resetter(){}
        Resetter(Resetter& i) = default;
        Resetter(const Resetter& i) = default;
        Resetter& operator=(Resetter& i) = default;
        Resetter& operator=(const Resetter& i) = default;

        template<typename T>
        Resetter(T& ref);

        template<typename T>
        Resetter(const T& ref);

        template<typename T>
        Resetter(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IResetter
        {
            virtual struct gocpp::error vReset(struct io::Reader r, gocpp::slice<unsigned char> dict) = 0;
        };

        template<typename T, typename StoreT>
        struct ResetterImpl : IResetter
        {
            explicit ResetterImpl(T* ptr)
            {
                value.reset(ptr);
            }

            struct gocpp::error vReset(struct io::Reader r, gocpp::slice<unsigned char> dict) override;

            StoreT value;
        };

        std::shared_ptr<IResetter> value;
    };

    namespace rec
    {
        struct gocpp::error Reset(const gocpp::PtrRecv<Resetter, false>& self, struct io::Reader r, gocpp::slice<unsigned char> dict);
        struct gocpp::error Reset(const gocpp::ObjRecv<Resetter>& self, struct io::Reader r, gocpp::slice<unsigned char> dict);
    }

    std::ostream& operator<<(std::ostream& os, const struct Resetter& value);
    struct huffmanDecoder
    {
        int min;
        gocpp::array<uint32_t, huffmanNumChunks> chunks;
        gocpp::slice<gocpp::slice<uint32_t>> links;
        uint32_t linkMask;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct huffmanDecoder& value);
    struct Reader : gocpp::Interface
    {
        Reader(){}
        Reader(Reader& i) = default;
        Reader(const Reader& i) = default;
        Reader& operator=(Reader& i) = default;
        Reader& operator=(const Reader& i) = default;

        template<typename T>
        Reader(T& ref);

        template<typename T>
        Reader(const T& ref);

        template<typename T>
        Reader(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IReader
        {
        };

        template<typename T, typename StoreT>
        struct ReaderImpl : IReader
        {
            explicit ReaderImpl(T* ptr)
            {
                value.reset(ptr);
            }

            StoreT value;
        };

        std::shared_ptr<IReader> value;
    };

    namespace rec
    {    }

    std::ostream& operator<<(std::ostream& os, const struct Reader& value);
    struct decompressor
    {
        Reader r;
        bufio::Reader* rBuf;
        int64_t roffset;
        uint32_t b;
        unsigned int nb;
        huffmanDecoder h1;
        huffmanDecoder h2;
        gocpp::array<int, maxNumLit + maxNumDist>* bits;
        gocpp::array<int, numCodes>* codebits;
        dictDecoder dict;
        gocpp::array<unsigned char, 4> buf;
        std::function<void (decompressor*)> step;
        int stepState;
        bool final;
        gocpp::error err;
        gocpp::slice<unsigned char> toRead;
        huffmanDecoder* hl;
        huffmanDecoder* hd;
        int copyLen;
        int copyDist;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct decompressor& value);
    extern gocpp::array_base<int> codeOrder;
    struct gocpp::error noEOF(struct gocpp::error e);
    void fixedHuffmanDecoderInit();
    struct io::ReadCloser NewReader(struct io::Reader r);
    struct io::ReadCloser NewReaderDict(struct io::Reader r, gocpp::slice<unsigned char> dict);

    namespace rec
    {
        std::string Error(flate::CorruptInputError e);
        std::string Error(flate::InternalError e);
        std::string Error(struct ReadError* e);
        std::string Error(struct WriteError* e);
        bool init(struct huffmanDecoder* h, gocpp::slice<int> lengths);
        void nextBlock(struct decompressor* f);
        std::tuple<int, struct gocpp::error> Read(struct decompressor* f, gocpp::slice<unsigned char> b);
        struct gocpp::error Close(struct decompressor* f);
        struct gocpp::error readHuffman(struct decompressor* f);
        void huffmanBlock(struct decompressor* f);
        void dataBlock(struct decompressor* f);
        void copyData(struct decompressor* f);
        void finishBlock(struct decompressor* f);
        struct gocpp::error moreBits(struct decompressor* f);
        std::tuple<int, struct gocpp::error> huffSym(struct decompressor* f, struct huffmanDecoder* h);
        void makeReader(struct decompressor* f, struct io::Reader r);
        struct gocpp::error Reset(struct decompressor* f, struct io::Reader r, gocpp::slice<unsigned char> dict);
    }
}

