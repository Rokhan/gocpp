// generated by GoCpp from file '$(ImportDir)/image/image.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/image.h"
#include "gocpp/support.h"

#include "golang/image/color/color.h"
#include "golang/image/color/ycbcr.h"
#include "golang/image/geom.h"

namespace golang::image
{
    namespace rec
    {
        using namespace mocklib::rec;
        using color::rec::Convert;
        using color::rec::Index;
        using color::rec::RGBA;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Config::operator T()
    {
        T result;
        result.ColorModel = this->ColorModel;
        result.Width = this->Width;
        result.Height = this->Height;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Config::operator==(const T& ref) const
    {
        if (ColorModel != ref.ColorModel) return false;
        if (Width != ref.Width) return false;
        if (Height != ref.Height) return false;
        return true;
    }

    std::ostream& Config::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ColorModel;
        os << " " << Width;
        os << " " << Height;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Config& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Image::Image(T& ref)
    {
        value.reset(new ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Image::Image(const T& ref)
    {
        value.reset(new ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Image::Image(T* ptr)
    {
        value.reset(new ImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Image::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    color::Model Image::ImageImpl<T, StoreT>::vColorModel()
    {
        return rec::ColorModel(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Rectangle Image::ImageImpl<T, StoreT>::vBounds()
    {
        return rec::Bounds(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    color::Color Image::ImageImpl<T, StoreT>::vAt(int x, int y)
    {
        return rec::At(gocpp::PtrRecv<T, false>(value.get()), x, y);
    }

    namespace rec
    {
        color::Model ColorModel(const gocpp::PtrRecv<struct Image, false>& self)
        {
            return self.ptr->value->vColorModel();
        }

        color::Model ColorModel(const gocpp::ObjRecv<struct Image>& self)
        {
            return self.obj.value->vColorModel();
        }

        struct Rectangle Bounds(const gocpp::PtrRecv<struct Image, false>& self)
        {
            return self.ptr->value->vBounds();
        }

        struct Rectangle Bounds(const gocpp::ObjRecv<struct Image>& self)
        {
            return self.obj.value->vBounds();
        }

        color::Color At(const gocpp::PtrRecv<struct Image, false>& self, int x, int y)
        {
            return self.ptr->value->vAt(x, y);
        }

        color::Color At(const gocpp::ObjRecv<struct Image>& self, int x, int y)
        {
            return self.obj.value->vAt(x, y);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Image& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    RGBA64Image::RGBA64Image(T& ref)
    {
        value.reset(new RGBA64ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RGBA64Image::RGBA64Image(const T& ref)
    {
        value.reset(new RGBA64ImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    RGBA64Image::RGBA64Image(T* ptr)
    {
        value.reset(new RGBA64ImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& RGBA64Image::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    color::RGBA64 RGBA64Image::RGBA64ImageImpl<T, StoreT>::vRGBA64At(int x, int y)
    {
        return rec::RGBA64At(gocpp::PtrRecv<T, false>(value.get()), x, y);
    }

    namespace rec
    {
        color::RGBA64 RGBA64At(const gocpp::PtrRecv<struct RGBA64Image, false>& self, int x, int y)
        {
            return self.ptr->value->vRGBA64At(x, y);
        }

        color::RGBA64 RGBA64At(const gocpp::ObjRecv<struct RGBA64Image>& self, int x, int y)
        {
            return self.obj.value->vRGBA64At(x, y);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64Image& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    PalettedImage::PalettedImage(T& ref)
    {
        value.reset(new PalettedImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    PalettedImage::PalettedImage(const T& ref)
    {
        value.reset(new PalettedImageImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    PalettedImage::PalettedImage(T* ptr)
    {
        value.reset(new PalettedImageImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& PalettedImage::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint8_t PalettedImage::PalettedImageImpl<T, StoreT>::vColorIndexAt(int x, int y)
    {
        return rec::ColorIndexAt(gocpp::PtrRecv<T, false>(value.get()), x, y);
    }

    namespace rec
    {
        uint8_t ColorIndexAt(const gocpp::PtrRecv<struct PalettedImage, false>& self, int x, int y)
        {
            return self.ptr->value->vColorIndexAt(x, y);
        }

        uint8_t ColorIndexAt(const gocpp::ObjRecv<struct PalettedImage>& self, int x, int y)
        {
            return self.obj.value->vColorIndexAt(x, y);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct PalettedImage& value)
    {
        return value.PrintTo(os);
    }

    int pixelBufferLength(int bytesPerPixel, struct Rectangle r, std::string imageTypeName)
    {
        auto totalLength = mul3NonNeg(bytesPerPixel, rec::Dx(gocpp::recv(r)), rec::Dy(gocpp::recv(r)));
        if(totalLength < 0)
        {
            gocpp::panic("image: New"s + imageTypeName + " Rectangle has huge or negative dimensions"s);
        }
        return totalLength;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RGBA::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RGBA::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& RGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct RGBA* p)
    {
        return color::RGBAModel;
    }

    struct Rectangle rec::Bounds(struct RGBA* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct RGBA* p, int x, int y)
    {
        return rec::RGBAAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct RGBA* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        auto r = uint16_t(s[0]);
        auto g = uint16_t(s[1]);
        auto b = uint16_t(s[2]);
        auto a = uint16_t(s[3]);
        return color::RGBA64 {(r << 8) | r, (g << 8) | g, (b << 8) | b, (a << 8) | a};
    }

    color::RGBA rec::RGBAAt(struct RGBA* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::RGBA {s[0], s[1], s[2], s[3]};
    }

    int rec::PixOffset(struct RGBA* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void rec::Set(struct RGBA* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::RGBA>(rec::Convert(gocpp::recv(color::RGBAModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.R;
        s[1] = c1.G;
        s[2] = c1.B;
        s[3] = c1.A;
    }

    void rec::SetRGBA64(struct RGBA* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = uint8_t(c->R >> 8);
        s[1] = uint8_t(c->G >> 8);
        s[2] = uint8_t(c->B >> 8);
        s[3] = uint8_t(c->A >> 8);
    }

    void rec::SetRGBA(struct RGBA* p, int x, int y, color::RGBA c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c->R;
        s[1] = c->G;
        s[2] = c->B;
        s[3] = c->A;
    }

    struct Image rec::SubImage(struct RGBA* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new RGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<RGBA>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct RGBA* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{3, rec::Dx(gocpp::recv(p->Rect)) * 4};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 4)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    struct RGBA* NewRGBA(struct Rectangle r)
    {
        return gocpp::InitPtr<RGBA>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "RGBA"s));
            x.Stride = 4 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    RGBA64::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool RGBA64::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& RGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct RGBA64& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct RGBA64* p)
    {
        return color::RGBA64Model;
    }

    struct Rectangle rec::Bounds(struct RGBA64* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct RGBA64* p, int x, int y)
    {
        return rec::RGBA64At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct RGBA64* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::RGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        return color::RGBA64 {(uint16_t(s[0]) << 8) | uint16_t(s[1]), (uint16_t(s[2]) << 8) | uint16_t(s[3]), (uint16_t(s[4]) << 8) | uint16_t(s[5]), (uint16_t(s[6]) << 8) | uint16_t(s[7])};
    }

    int rec::PixOffset(struct RGBA64* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 8;
    }

    void rec::Set(struct RGBA64* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::RGBA64>(rec::Convert(gocpp::recv(color::RGBA64Model), c));
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c1.R >> 8);
        s[1] = uint8_t(c1.R);
        s[2] = uint8_t(c1.G >> 8);
        s[3] = uint8_t(c1.G);
        s[4] = uint8_t(c1.B >> 8);
        s[5] = uint8_t(c1.B);
        s[6] = uint8_t(c1.A >> 8);
        s[7] = uint8_t(c1.A);
    }

    void rec::SetRGBA64(struct RGBA64* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c->R >> 8);
        s[1] = uint8_t(c->R);
        s[2] = uint8_t(c->G >> 8);
        s[3] = uint8_t(c->G);
        s[4] = uint8_t(c->B >> 8);
        s[5] = uint8_t(c->B);
        s[6] = uint8_t(c->A >> 8);
        s[7] = uint8_t(c->A);
    }

    struct Image rec::SubImage(struct RGBA64* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new RGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<RGBA64>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct RGBA64* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{6, rec::Dx(gocpp::recv(p->Rect)) * 8};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 8)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    struct RGBA64* NewRGBA64(struct Rectangle r)
    {
        return gocpp::InitPtr<RGBA64>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(8, r, "RGBA64"s));
            x.Stride = 8 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    NRGBA::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NRGBA::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& NRGBA::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct NRGBA* p)
    {
        return color::NRGBAModel;
    }

    struct Rectangle rec::Bounds(struct NRGBA* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct NRGBA* p, int x, int y)
    {
        return rec::NRGBAAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct NRGBA* p, int x, int y)
    {
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(rec::NRGBAAt(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::NRGBA rec::NRGBAAt(struct NRGBA* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::NRGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::NRGBA {s[0], s[1], s[2], s[3]};
    }

    int rec::PixOffset(struct NRGBA* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void rec::Set(struct NRGBA* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::NRGBA>(rec::Convert(gocpp::recv(color::NRGBAModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.R;
        s[1] = c1.G;
        s[2] = c1.B;
        s[3] = c1.A;
    }

    void rec::SetRGBA64(struct NRGBA* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [r, g, b, a] = std::tuple{uint32_t(c->R), uint32_t(c->G), uint32_t(c->B), uint32_t(c->A)};
        if((a != 0) && (a != 0xffff))
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = uint8_t(r >> 8);
        s[1] = uint8_t(g >> 8);
        s[2] = uint8_t(b >> 8);
        s[3] = uint8_t(a >> 8);
    }

    void rec::SetNRGBA(struct NRGBA* p, int x, int y, color::NRGBA c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c->R;
        s[1] = c->G;
        s[2] = c->B;
        s[3] = c->A;
    }

    struct Image rec::SubImage(struct NRGBA* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new NRGBA {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<NRGBA>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct NRGBA* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{3, rec::Dx(gocpp::recv(p->Rect)) * 4};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 4)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    struct NRGBA* NewNRGBA(struct Rectangle r)
    {
        return gocpp::InitPtr<NRGBA>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "NRGBA"s));
            x.Stride = 4 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    NRGBA64::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool NRGBA64::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& NRGBA64::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct NRGBA64& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct NRGBA64* p)
    {
        return color::NRGBA64Model;
    }

    struct Rectangle rec::Bounds(struct NRGBA64* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct NRGBA64* p, int x, int y)
    {
        return rec::NRGBA64At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct NRGBA64* p, int x, int y)
    {
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(rec::NRGBA64At(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::NRGBA64 rec::NRGBA64At(struct NRGBA64* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::NRGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        return color::NRGBA64 {(uint16_t(s[0]) << 8) | uint16_t(s[1]), (uint16_t(s[2]) << 8) | uint16_t(s[3]), (uint16_t(s[4]) << 8) | uint16_t(s[5]), (uint16_t(s[6]) << 8) | uint16_t(s[7])};
    }

    int rec::PixOffset(struct NRGBA64* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 8;
    }

    void rec::Set(struct NRGBA64* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::NRGBA64>(rec::Convert(gocpp::recv(color::NRGBA64Model), c));
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c1.R >> 8);
        s[1] = uint8_t(c1.R);
        s[2] = uint8_t(c1.G >> 8);
        s[3] = uint8_t(c1.G);
        s[4] = uint8_t(c1.B >> 8);
        s[5] = uint8_t(c1.B);
        s[6] = uint8_t(c1.A >> 8);
        s[7] = uint8_t(c1.A);
    }

    void rec::SetRGBA64(struct NRGBA64* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [r, g, b, a] = std::tuple{uint32_t(c->R), uint32_t(c->G), uint32_t(c->B), uint32_t(c->A)};
        if((a != 0) && (a != 0xffff))
        {
            r = (r * 0xffff) / a;
            g = (g * 0xffff) / a;
            b = (b * 0xffff) / a;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(r >> 8);
        s[1] = uint8_t(r);
        s[2] = uint8_t(g >> 8);
        s[3] = uint8_t(g);
        s[4] = uint8_t(b >> 8);
        s[5] = uint8_t(b);
        s[6] = uint8_t(a >> 8);
        s[7] = uint8_t(a);
    }

    void rec::SetNRGBA64(struct NRGBA64* p, int x, int y, color::NRGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 8, i + 8);
        s[0] = uint8_t(c->R >> 8);
        s[1] = uint8_t(c->R);
        s[2] = uint8_t(c->G >> 8);
        s[3] = uint8_t(c->G);
        s[4] = uint8_t(c->B >> 8);
        s[5] = uint8_t(c->B);
        s[6] = uint8_t(c->A >> 8);
        s[7] = uint8_t(c->A);
    }

    struct Image rec::SubImage(struct NRGBA64* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new NRGBA64 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<NRGBA64>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct NRGBA64* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{6, rec::Dx(gocpp::recv(p->Rect)) * 8};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 8)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    struct NRGBA64* NewNRGBA64(struct Rectangle r)
    {
        return gocpp::InitPtr<NRGBA64>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(8, r, "NRGBA64"s));
            x.Stride = 8 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Alpha::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Alpha::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Alpha::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct Alpha* p)
    {
        return color::AlphaModel;
    }

    struct Rectangle rec::Bounds(struct Alpha* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct Alpha* p, int x, int y)
    {
        return rec::AlphaAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct Alpha* p, int x, int y)
    {
        auto a = uint16_t(rec::AlphaAt(gocpp::recv(p), x, y).A);
        a |= a << 8;
        return color::RGBA64 {a, a, a, a};
    }

    color::Alpha rec::AlphaAt(struct Alpha* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Alpha {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Alpha {p->Pix[i]};
    }

    int rec::PixOffset(struct Alpha* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void rec::Set(struct Alpha* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = gocpp::getValue<color::Alpha>(rec::Convert(gocpp::recv(color::AlphaModel), c)).A;
    }

    void rec::SetRGBA64(struct Alpha* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(c->A >> 8);
    }

    void rec::SetAlpha(struct Alpha* p, int x, int y, color::Alpha c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = c->A;
    }

    struct Image rec::SubImage(struct Alpha* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Alpha {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Alpha>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct Alpha* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{0, rec::Dx(gocpp::recv(p->Rect))};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i++)
            {
                if(p->Pix[i] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    struct Alpha* NewAlpha(struct Rectangle r)
    {
        return gocpp::InitPtr<Alpha>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Alpha"s));
            x.Stride = 1 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Alpha16::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Alpha16::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Alpha16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Alpha16& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct Alpha16* p)
    {
        return color::Alpha16Model;
    }

    struct Rectangle rec::Bounds(struct Alpha16* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct Alpha16* p, int x, int y)
    {
        return rec::Alpha16At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct Alpha16* p, int x, int y)
    {
        auto a = rec::Alpha16At(gocpp::recv(p), x, y).A;
        return color::RGBA64 {a, a, a, a};
    }

    color::Alpha16 rec::Alpha16At(struct Alpha16* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Alpha16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Alpha16 {(uint16_t(p->Pix[i + 0]) << 8) | uint16_t(p->Pix[i + 1])};
    }

    int rec::PixOffset(struct Alpha16* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 2;
    }

    void rec::Set(struct Alpha16* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::Alpha16>(rec::Convert(gocpp::recv(color::Alpha16Model), c));
        p->Pix[i + 0] = uint8_t(c1.A >> 8);
        p->Pix[i + 1] = uint8_t(c1.A);
    }

    void rec::SetRGBA64(struct Alpha16* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c->A >> 8);
        p->Pix[i + 1] = uint8_t(c->A);
    }

    void rec::SetAlpha16(struct Alpha16* p, int x, int y, color::Alpha16 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c->A >> 8);
        p->Pix[i + 1] = uint8_t(c->A);
    }

    struct Image rec::SubImage(struct Alpha16* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Alpha16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Alpha16>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct Alpha16* p)
    {
        if(rec::Empty(gocpp::recv(p->Rect)))
        {
            return true;
        }
        auto [i0, i1] = std::tuple{0, rec::Dx(gocpp::recv(p->Rect)) * 2};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto i = i0; i < i1; i += 2)
            {
                if(p->Pix[i + 0] != 0xff || p->Pix[i + 1] != 0xff)
                {
                    return false;
                }
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        return true;
    }

    struct Alpha16* NewAlpha16(struct Rectangle r)
    {
        return gocpp::InitPtr<Alpha16>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(2, r, "Alpha16"s));
            x.Stride = 2 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Gray::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Gray::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Gray::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct Gray* p)
    {
        return color::GrayModel;
    }

    struct Rectangle rec::Bounds(struct Gray* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct Gray* p, int x, int y)
    {
        return rec::GrayAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct Gray* p, int x, int y)
    {
        auto gray = uint16_t(rec::GrayAt(gocpp::recv(p), x, y).Y);
        gray |= gray << 8;
        return color::RGBA64 {gray, gray, gray, 0xffff};
    }

    color::Gray rec::GrayAt(struct Gray* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Gray {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Gray {p->Pix[i]};
    }

    int rec::PixOffset(struct Gray* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void rec::Set(struct Gray* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = gocpp::getValue<color::Gray>(rec::Convert(gocpp::recv(color::GrayModel), c)).Y;
    }

    void rec::SetRGBA64(struct Gray* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto gray = (19595 * uint32_t(c->R) + 38470 * uint32_t(c->G) + 7471 * uint32_t(c->B) + (1 << 15)) >> 24;
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(gray);
    }

    void rec::SetGray(struct Gray* p, int x, int y, color::Gray c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = c->Y;
    }

    struct Image rec::SubImage(struct Gray* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Gray {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Gray>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct Gray* p)
    {
        return true;
    }

    struct Gray* NewGray(struct Rectangle r)
    {
        return gocpp::InitPtr<Gray>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Gray"s));
            x.Stride = 1 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Gray16::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Gray16::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& Gray16::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Gray16& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct Gray16* p)
    {
        return color::Gray16Model;
    }

    struct Rectangle rec::Bounds(struct Gray16* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct Gray16* p, int x, int y)
    {
        return rec::Gray16At(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct Gray16* p, int x, int y)
    {
        auto gray = rec::Gray16At(gocpp::recv(p), x, y).Y;
        return color::RGBA64 {gray, gray, gray, 0xffff};
    }

    color::Gray16 rec::Gray16At(struct Gray16* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::Gray16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return color::Gray16 {(uint16_t(p->Pix[i + 0]) << 8) | uint16_t(p->Pix[i + 1])};
    }

    int rec::PixOffset(struct Gray16* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 2;
    }

    void rec::Set(struct Gray16* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::Gray16>(rec::Convert(gocpp::recv(color::Gray16Model), c));
        p->Pix[i + 0] = uint8_t(c1.Y >> 8);
        p->Pix[i + 1] = uint8_t(c1.Y);
    }

    void rec::SetRGBA64(struct Gray16* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto gray = (19595 * uint32_t(c->R) + 38470 * uint32_t(c->G) + 7471 * uint32_t(c->B) + (1 << 15)) >> 16;
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(gray >> 8);
        p->Pix[i + 1] = uint8_t(gray);
    }

    void rec::SetGray16(struct Gray16* p, int x, int y, color::Gray16 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i + 0] = uint8_t(c->Y >> 8);
        p->Pix[i + 1] = uint8_t(c->Y);
    }

    struct Image rec::SubImage(struct Gray16* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new Gray16 {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Gray16>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct Gray16* p)
    {
        return true;
    }

    struct Gray16* NewGray16(struct Rectangle r)
    {
        return gocpp::InitPtr<Gray16>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(2, r, "Gray16"s));
            x.Stride = 2 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    CMYK::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool CMYK::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        return true;
    }

    std::ostream& CMYK::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct CMYK& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct CMYK* p)
    {
        return color::CMYKModel;
    }

    struct Rectangle rec::Bounds(struct CMYK* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct CMYK* p, int x, int y)
    {
        return rec::CMYKAt(gocpp::recv(p), x, y);
    }

    color::RGBA64 rec::RGBA64At(struct CMYK* p, int x, int y)
    {
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(rec::CMYKAt(gocpp::recv(p), x, y)));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    color::CMYK rec::CMYKAt(struct CMYK* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return color::CMYK {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        return color::CMYK {s[0], s[1], s[2], s[3]};
    }

    int rec::PixOffset(struct CMYK* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 4;
    }

    void rec::Set(struct CMYK* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto c1 = gocpp::getValue<color::CMYK>(rec::Convert(gocpp::recv(color::CMYKModel), c));
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c1.C;
        s[1] = c1.M;
        s[2] = c1.Y;
        s[3] = c1.K;
    }

    void rec::SetRGBA64(struct CMYK* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto [cc, mm, yy, kk] = color::RGBToCMYK(uint8_t(c->R >> 8), uint8_t(c->G >> 8), uint8_t(c->B >> 8));
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = cc;
        s[1] = mm;
        s[2] = yy;
        s[3] = kk;
    }

    void rec::SetCMYK(struct CMYK* p, int x, int y, color::CMYK c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        auto s = p->Pix.make_slice(i, i + 4, i + 4);
        s[0] = c->C;
        s[1] = c->M;
        s[2] = c->Y;
        s[3] = c->K;
    }

    struct Image rec::SubImage(struct CMYK* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return new CMYK {};
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<CMYK>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = r;
        });
    }

    bool rec::Opaque(struct CMYK* p)
    {
        return true;
    }

    struct CMYK* NewCMYK(struct Rectangle r)
    {
        return gocpp::InitPtr<CMYK>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(4, r, "CMYK"s));
            x.Stride = 4 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
        });
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Paletted::operator T()
    {
        T result;
        result.Pix = this->Pix;
        result.Stride = this->Stride;
        result.Rect = this->Rect;
        result.Palette = this->Palette;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Paletted::operator==(const T& ref) const
    {
        if (Pix != ref.Pix) return false;
        if (Stride != ref.Stride) return false;
        if (Rect != ref.Rect) return false;
        if (Palette != ref.Palette) return false;
        return true;
    }

    std::ostream& Paletted::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Pix;
        os << " " << Stride;
        os << " " << Rect;
        os << " " << Palette;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Paletted& value)
    {
        return value.PrintTo(os);
    }

    color::Model rec::ColorModel(struct Paletted* p)
    {
        return p->Palette;
    }

    struct Rectangle rec::Bounds(struct Paletted* p)
    {
        return p->Rect;
    }

    color::Color rec::At(struct Paletted* p, int x, int y)
    {
        if(len(p->Palette) == 0)
        {
            return nullptr;
        }
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return p->Palette[0];
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return p->Palette[p->Pix[i]];
    }

    color::RGBA64 rec::RGBA64At(struct Paletted* p, int x, int y)
    {
        if(len(p->Palette) == 0)
        {
            return color::RGBA64 {};
        }
        auto c = color::Color(nullptr);
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            c = p->Palette[0];
        }
        else
        {
            auto i = rec::PixOffset(gocpp::recv(p), x, y);
            c = p->Palette[p->Pix[i]];
        }
        auto [r, g, b, a] = rec::RGBA(gocpp::recv(c));
        return color::RGBA64 {uint16_t(r), uint16_t(g), uint16_t(b), uint16_t(a)};
    }

    int rec::PixOffset(struct Paletted* p, int x, int y)
    {
        return (y - p->Rect.Min.Y) * p->Stride + (x - p->Rect.Min.X) * 1;
    }

    void rec::Set(struct Paletted* p, int x, int y, color::Color c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(rec::Index(gocpp::recv(p->Palette), c));
    }

    void rec::SetRGBA64(struct Paletted* p, int x, int y, color::RGBA64 c)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = uint8_t(rec::Index(gocpp::recv(p->Palette), c));
    }

    uint8_t rec::ColorIndexAt(struct Paletted* p, int x, int y)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return 0;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        return p->Pix[i];
    }

    void rec::SetColorIndex(struct Paletted* p, int x, int y, uint8_t index)
    {
        if(! (rec::In(gocpp::recv(Point {x, y}), p->Rect)))
        {
            return;
        }
        auto i = rec::PixOffset(gocpp::recv(p), x, y);
        p->Pix[i] = index;
    }

    struct Image rec::SubImage(struct Paletted* p, struct Rectangle r)
    {
        r = rec::Intersect(gocpp::recv(r), p->Rect);
        if(rec::Empty(gocpp::recv(r)))
        {
            return gocpp::InitPtr<Paletted>([=](auto& x) {
                x.Palette = p->Palette;
            });
        }
        auto i = rec::PixOffset(gocpp::recv(p), r.Min.X, r.Min.Y);
        return gocpp::InitPtr<Paletted>([=](auto& x) {
            x.Pix = p->Pix.make_slice(i);
            x.Stride = p->Stride;
            x.Rect = rec::Intersect(gocpp::recv(p->Rect), r);
            x.Palette = p->Palette;
        });
    }

    bool rec::Opaque(struct Paletted* p)
    {
        gocpp::array<bool, 256> present = {};
        auto [i0, i1] = std::tuple{0, rec::Dx(gocpp::recv(p->Rect))};
        for(auto y = p->Rect.Min.Y; y < p->Rect.Max.Y; y++)
        {
            for(auto [gocpp_ignored, c] : p->Pix.make_slice(i0, i1))
            {
                present[c] = true;
            }
            i0 += p->Stride;
            i1 += p->Stride;
        }
        for(auto [i, c] : p->Palette)
        {
            if(! present[i])
            {
                continue;
            }
            auto [gocpp_id_3, gocpp_id_4, gocpp_id_5, a] = rec::RGBA(gocpp::recv(c));
            if(a != 0xffff)
            {
                return false;
            }
        }
        return true;
    }

    struct Paletted* NewPaletted(struct Rectangle r, color::Palette p)
    {
        return gocpp::InitPtr<Paletted>([=](auto& x) {
            x.Pix = gocpp::make(gocpp::Tag<gocpp::slice<uint8_t>>(), pixelBufferLength(1, r, "Paletted"s));
            x.Stride = 1 * rec::Dx(gocpp::recv(r));
            x.Rect = r;
            x.Palette = p;
        });
    }

}

