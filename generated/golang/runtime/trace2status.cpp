// generated by GoCpp from file '$(ImportDir)/runtime/trace2status.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2status.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
    }

    struct traceWriter rec::writeGoStatus(struct traceWriter w, uint64_t goid, int64_t mid, golang::runtime::traceGoStatus status, bool markAssist)
    {
        if(status == traceGoBad)
        {
            print("runtime: goid=", goid, "\n");
            go_throw("attempted to trace a bad status for a goroutine");
        }
        w = rec::event(gocpp::recv(w), traceEvGoStatus, traceArg(goid), traceArg(uint64_t(mid)), traceArg(status));
        if(markAssist)
        {
            w = rec::event(gocpp::recv(w), traceEvGCMarkAssistActive, traceArg(goid));
        }
        return w;
    }

    struct traceWriter rec::writeProcStatusForP(struct traceWriter w, struct p* pp, bool inSTW)
    {
        if(! rec::acquireStatus(gocpp::recv(pp->trace), w.gen))
        {
            return w;
        }
        runtime::traceProcStatus status = {};
        //Go switch emulation
        {
            auto condition = pp->status;
            int conditionId = -1;
            if(condition == _Pidle) { conditionId = 0; }
            if(condition == _Pgcstop) { conditionId = 1; }
            else if(condition == _Prunning) { conditionId = 2; }
            else if(condition == _Psyscall) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    status = traceProcIdle;
                    if(pp->status == _Pgcstop && inSTW)
                    {
                        status = traceProcRunning;
                    }
                    break;
                case 2:
                    status = traceProcRunning;
                    if(rec::ptr(gocpp::recv(w.mp->p)) == pp && w.mp->curg != nullptr && readgstatus(w.mp->curg) &^ _Gscan == _Gsyscall)
                    {
                        status = traceProcSyscall;
                    }
                    break;
                case 3:
                    status = traceProcSyscall;
                    break;
                default:
                    go_throw("attempt to trace invalid or unsupported P status");
                    break;
            }
        }
        w = rec::writeProcStatus(gocpp::recv(w), uint64_t(pp->id), status, pp->trace.inSweep);
        return w;
    }

    struct traceWriter rec::writeProcStatus(struct traceWriter w, uint64_t pid, golang::runtime::traceProcStatus status, bool inSweep)
    {
        if(status == traceProcBad)
        {
            print("runtime: pid=", pid, "\n");
            go_throw("attempted to trace a bad status for a proc");
        }
        w = rec::event(gocpp::recv(w), traceEvProcStatus, traceArg(pid), traceArg(status));
        if(inSweep)
        {
            w = rec::event(gocpp::recv(w), traceEvGCSweepActive, traceArg(pid));
        }
        return w;
    }

    runtime::traceGoStatus goStatusToTraceGoStatus(uint32_t status, golang::runtime::waitReason wr)
    {
        runtime::traceGoStatus tgs = {};
        //Go switch emulation
        {
            auto condition = status &^ _Gscan;
            int conditionId = -1;
            if(condition == _Grunnable) { conditionId = 0; }
            else if(condition == _Grunning) { conditionId = 1; }
            else if(condition == _Gcopystack) { conditionId = 2; }
            else if(condition == _Gsyscall) { conditionId = 3; }
            else if(condition == _Gwaiting) { conditionId = 4; }
            else if(condition == _Gpreempted) { conditionId = 5; }
            else if(condition == _Gdead) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    tgs = traceGoRunnable;
                    break;
                case 1:
                case 2:
                    tgs = traceGoRunning;
                    break;
                case 3:
                    tgs = traceGoSyscall;
                    break;
                case 4:
                case 5:
                    tgs = traceGoWaiting;
                    if(status == _Gwaiting && wr == waitReasonStoppingTheWorld || wr == waitReasonGCMarkTermination || wr == waitReasonGarbageCollection || wr == waitReasonTraceProcStatus || wr == waitReasonPageTraceFlush || wr == waitReasonGCWorkerActive)
                    {
                        tgs = traceGoRunning;
                    }
                    break;
                case 6:
                    go_throw("tried to trace dead goroutine");
                    break;
                default:
                    go_throw("tried to trace goroutine with invalid or unsupported status");
                    break;
            }
        }
        return tgs;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceSchedResourceState::operator T()
    {
        T result;
        result.statusTraced = this->statusTraced;
        result.seq = this->seq;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceSchedResourceState::operator==(const T& ref) const
    {
        if (statusTraced != ref.statusTraced) return false;
        if (seq != ref.seq) return false;
        return true;
    }

    std::ostream& traceSchedResourceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << statusTraced;
        os << " " << seq;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceSchedResourceState& value)
    {
        return value.PrintTo(os);
    }

    bool rec::acquireStatus(struct traceSchedResourceState* r, uintptr_t gen)
    {
        if(! rec::CompareAndSwap(gocpp::recv(r->statusTraced[gen % 3]), 0, 1))
        {
            return false;
        }
        rec::readyNextGen(gocpp::recv(r), gen);
        return true;
    }

    void rec::readyNextGen(struct traceSchedResourceState* r, uintptr_t gen)
    {
        auto nextGen = traceNextGen(gen);
        r->seq[nextGen % 2] = 0;
        rec::Store(gocpp::recv(r->statusTraced[nextGen % 3]), 0);
    }

    bool rec::statusWasTraced(struct traceSchedResourceState* r, uintptr_t gen)
    {
        return rec::Load(gocpp::recv(r->statusTraced[gen % 3])) != 0;
    }

    void rec::setStatusTraced(struct traceSchedResourceState* r, uintptr_t gen)
    {
        rec::Store(gocpp::recv(r->statusTraced[gen % 3]), 1);
    }

    runtime::traceArg rec::nextSeq(struct traceSchedResourceState* r, uintptr_t gen)
    {
        r->seq[gen % 2]++;
        return traceArg(r->seq[gen % 2]);
    }

}

