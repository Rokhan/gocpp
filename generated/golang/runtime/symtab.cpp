// generated by GoCpp from file '$(ImportDir)/runtime/symtab.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/symtab.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtabinl.h"  [Ignored, known errors]
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& Frames::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << callers;
        os << " " << frames;
        os << " " << frameStore;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Frames& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& Frame::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << PC;
        os << " " << Func;
        os << " " << Function;
        os << " " << File;
        os << " " << Line;
        os << " " << startLine;
        os << " " << Entry;
        os << " " << funcInfo;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Frame& value)
    {
        return value.PrintTo(os);
    }

    Frames* CallersFrames(gocpp::slice<uintptr_t> callers)
    {
        auto f = gocpp::InitPtr<Frames>([](Frames& x) { x.callers = callers; });
        f->frames = f->frameStore.make_slice(0, 0);
        return f;
    }

    std::tuple<Frame, bool> Next(struct Frames* ci)
    {
        Frame frame;
        bool more;
        for(; len(ci->frames) < 2; )
        {
            Frame frame;
            bool more;
            if(len(ci->callers) == 0)
            {
                Frame frame;
                bool more;
                break;
            }
            auto pc = ci->callers[0];
            ci->callers = ci->callers.make_slice(1);
            auto funcInfo = findfunc(pc);
            if(! valid(gocpp::recv(funcInfo)))
            {
                Frame frame;
                bool more;
                if(cgoSymbolizer != nullptr)
                {
                    Frame frame;
                    bool more;
                    ci->frames = append(ci->frames, expandCgoFrames(pc));
                }
                continue;
            }
            auto f = _Func(gocpp::recv(funcInfo));
            auto entry = Entry(gocpp::recv(f));
            if(pc > entry)
            {
                Frame frame;
                bool more;
                pc--;
            }
            auto [u, uf] = newInlineUnwinder(funcInfo, pc);
            auto sf = srcFunc(gocpp::recv(u), uf);
            if(isInlined(gocpp::recv(u), uf))
            {
                Frame frame;
                bool more;
                f = nullptr;
            }
            ci->frames = append(ci->frames, gocpp::Init<Frame>([](Frame& x) { x.PC = pc; x.Func = f; x.Function = funcNameForPrint(name(gocpp::recv(sf))); x.Entry = entry; x.startLine = int(sf.startLine); x.funcInfo = funcInfo; }));
        }
        //Go switch emulation
        {
            auto condition = len(ci->frames);
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                Frame frame;
                bool more;
                case 0:
                    return {frame, more};
                    break;
                case 1:
                    frame = ci->frames[0];
                    ci->frames = ci->frameStore.make_slice(0, 0);
                    break;
                case 2:
                    frame = ci->frames[0];
                    ci->frameStore[0] = ci->frames[1];
                    ci->frames = ci->frameStore.make_slice(0, 1);
                    break;
                default:
                    frame = ci->frames[0];
                    ci->frames = ci->frames.make_slice(1);
                    break;
            }
        }
        more = len(ci->frames) > 0;
        if(valid(gocpp::recv(frame.funcInfo)))
        {
            Frame frame;
            bool more;
            auto [file, line] = funcline1(frame.funcInfo, frame.PC, false);
            std::tie(frame.File, frame.Line) = std::tuple{file, int(line)};
        }
        return {frame, more};
    }

    int runtime_FrameStartLine(Frame* f)
    {
        return f->startLine;
    }

    std::string runtime_FrameSymbolName(Frame* f)
    {
        if(! valid(gocpp::recv(f->funcInfo)))
        {
            return f->Function;
        }
        auto [u, uf] = newInlineUnwinder(f->funcInfo, f->PC);
        auto sf = srcFunc(gocpp::recv(u), uf);
        return name(gocpp::recv(sf));
    }

    gocpp::slice<uintptr_t> runtime_expandFinalInlineFrame(gocpp::slice<uintptr_t> stk)
    {
        if(len(stk) == 0)
        {
            return stk;
        }
        auto pc = stk[len(stk) - 1];
        auto tracepc = pc - 1;
        auto f = findfunc(tracepc);
        if(! valid(gocpp::recv(f)))
        {
            return stk;
        }
        auto [u, uf] = newInlineUnwinder(f, tracepc);
        if(! isInlined(gocpp::recv(u), uf))
        {
            return stk;
        }
        auto calleeID = abi::FuncIDNormal;
        stk = stk.make_slice(0, len(stk) - 1);
        for(; valid(gocpp::recv(uf)); uf = next(gocpp::recv(u), uf))
        {
            auto funcID = srcFunc(gocpp::recv(u), uf).funcID;
            if(funcID == abi::FuncIDWrapper && elideWrapperCalling(calleeID))
            {
            }
            else
            {
                stk = append(stk, uf.pc + 1);
            }
            calleeID = funcID;
        }
        return stk;
    }

    gocpp::slice<Frame> expandCgoFrames(uintptr_t pc)
    {
        auto arg = gocpp::Init<cgoSymbolizerArg>([](cgoSymbolizerArg& x) { x.pc = pc; });
        callCgoSymbolizer(& arg);
        if(arg.file == nullptr && arg.funcName == nullptr)
        {
            return nullptr;
        }
        gocpp::slice<Frame> frames = {};
        for(; ; )
        {
            frames = append(frames, gocpp::Init<Frame>([](Frame& x) { x.PC = pc; x.Func = nullptr; x.Function = gostring(arg.funcName); x.File = gostring(arg.file); x.Line = int(arg.lineno); x.Entry = arg.entry; }));
            if(arg.more == 0)
            {
                break;
            }
            callCgoSymbolizer(& arg);
        }
        arg.pc = 0;
        callCgoSymbolizer(& arg);
        return frames;
    }

    
    std::ostream& Func::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << opaque;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Func& value)
    {
        return value.PrintTo(os);
    }

    _func* raw(struct Func* f)
    {
        return (_func*)(unsafe::Pointer(f));
    }

    funcInfo funcInfo(struct Func* f)
    {
        return funcInfo(gocpp::recv(raw(gocpp::recv(f))));
    }

    funcInfo funcInfo(struct _func* f)
    {
        auto ptr = uintptr_t(unsafe::Pointer(f));
        moduledata* mod = {};
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(len(datap->pclntable) == 0)
            {
                continue;
            }
            auto base = uintptr_t(unsafe::Pointer(& datap->pclntable[0]));
            if(base <= ptr && ptr < base + uintptr_t(len(datap->pclntable)))
            {
                mod = datap;
                break;
            }
        }
        return funcInfo {f, mod};
    }

    
    std::ostream& pcHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << magic;
        os << " " << pad1;
        os << " " << pad2;
        os << " " << minLC;
        os << " " << ptrSize;
        os << " " << nfunc;
        os << " " << nfiles;
        os << " " << textStart;
        os << " " << funcnameOffset;
        os << " " << cuOffset;
        os << " " << filetabOffset;
        os << " " << pctabOffset;
        os << " " << pclnOffset;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pcHeader& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& moduledata::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << pcHeader;
        os << " " << funcnametab;
        os << " " << cutab;
        os << " " << filetab;
        os << " " << pctab;
        os << " " << pclntable;
        os << " " << ftab;
        os << " " << findfunctab;
        os << " " << minpc;
        os << " " << maxpc;
        os << " " << text;
        os << " " << etext;
        os << " " << noptrdata;
        os << " " << enoptrdata;
        os << " " << data;
        os << " " << edata;
        os << " " << bss;
        os << " " << ebss;
        os << " " << noptrbss;
        os << " " << enoptrbss;
        os << " " << covctrs;
        os << " " << ecovctrs;
        os << " " << end;
        os << " " << gcdata;
        os << " " << gcbss;
        os << " " << types;
        os << " " << etypes;
        os << " " << rodata;
        os << " " << gofunc;
        os << " " << textsectmap;
        os << " " << typelinks;
        os << " " << itablinks;
        os << " " << ptab;
        os << " " << pluginpath;
        os << " " << pkghashes;
        os << " " << inittasks;
        os << " " << modulename;
        os << " " << modulehashes;
        os << " " << hasmain;
        os << " " << gcdatamask;
        os << " " << gcbssmask;
        os << " " << typemap;
        os << " " << bad;
        os << " " << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct moduledata& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& modulehash::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << modulename;
        os << " " << linktimehash;
        os << " " << runtimehash;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct modulehash& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<gocpp::map<typeOff, _type*>> pinnedTypemaps;
    moduledata firstmoduledata;
    moduledata* lastmoduledatap;
    gocpp::slice<moduledata*>* modulesSlice;
    gocpp::slice<moduledata*> activeModules()
    {
        auto p = (gocpp::slice<moduledata*>*)(atomic::Loadp(unsafe::Pointer(& modulesSlice)));
        if(p == nullptr)
        {
            return nullptr;
        }
        return *p;
    }

    void modulesinit()
    {
        auto modules = go_new(gocpp::Tag<gocpp::slice<moduledata*>>());
        for(auto md = & firstmoduledata; md != nullptr; md = md->next)
        {
            if(md->bad)
            {
                continue;
            }
            *modules = append(*modules, md);
            if(md->gcdatamask == (bitvector {}))
            {
                auto scanDataSize = md->edata - md->data;
                md->gcdatamask = progToPointerMask((unsigned char*)(unsafe::Pointer(md->gcdata)), scanDataSize);
                auto scanBSSSize = md->ebss - md->bss;
                md->gcbssmask = progToPointerMask((unsigned char*)(unsafe::Pointer(md->gcbss)), scanBSSSize);
                addGlobals(gocpp::recv(gcController), int64_t(scanDataSize + scanBSSSize));
            }
        }
        for(auto [i, md] : *modules)
        {
            if(md->hasmain != 0)
            {
                (*modules)[0] = md;
                (*modules)[i] = & firstmoduledata;
                break;
            }
        }
        atomicstorep(unsafe::Pointer(& modulesSlice), unsafe::Pointer(modules));
    }

    
    std::ostream& functab::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << entryoff;
        os << " " << funcoff;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct functab& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& textsect::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << vaddr;
        os << " " << end;
        os << " " << baseaddr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct textsect& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& findfuncbucket::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << idx;
        os << " " << subbuckets;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct findfuncbucket& value)
    {
        return value.PrintTo(os);
    }

    void moduledataverify()
    {
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            moduledataverify1(datap);
        }
    }

    void moduledataverify1(moduledata* datap)
    {
        auto hdr = datap->pcHeader;
        if(hdr->magic != 0xfffffff1 || hdr->pad1 != 0 || hdr->pad2 != 0 || hdr->minLC != sys::PCQuantum || hdr->ptrSize != goarch::PtrSize || hdr->textStart != datap->text)
        {
            println("runtime: pcHeader: magic=", hex(hdr->magic), "pad1=", hdr->pad1, "pad2=", hdr->pad2, "minLC=", hdr->minLC, "ptrSize=", hdr->ptrSize, "pcHeader.textStart=", hex(hdr->textStart), "text=", hex(datap->text), "pluginpath=", datap->pluginpath);
            go_throw("invalid function symbol table");
        }
        auto nftab = len(datap->ftab) - 1;
        for(auto i = 0; i < nftab; i++)
        {
            if(datap->ftab[i].entryoff > datap->ftab[i + 1].entryoff)
            {
                auto f1 = funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[datap->ftab[i].funcoff])), datap};
                auto f2 = funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[datap->ftab[i + 1].funcoff])), datap};
                auto f2name = "end";
                if(i + 1 < nftab)
                {
                    f2name = funcname(f2);
                }
                println("function symbol table not sorted by PC offset:", hex(datap->ftab[i].entryoff), funcname(f1), ">", hex(datap->ftab[i + 1].entryoff), f2name, ", plugin:", datap->pluginpath);
                for(auto j = 0; j <= i; j++)
                {
                    println("\t", hex(datap->ftab[j].entryoff), funcname(funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[datap->ftab[j].funcoff])), datap}));
                }
                if(GOOS == "aix" && isarchive)
                {
                    println("-Wl,-bnoobjreorder is mandatory on aix/ppc64 with c-archive");
                }
                go_throw("invalid runtime symbol table");
            }
        }
        auto min = textAddr(gocpp::recv(datap), datap->ftab[0].entryoff);
        auto max = textAddr(gocpp::recv(datap), datap->ftab[nftab].entryoff);
        if(datap->minpc != min || datap->maxpc != max)
        {
            println("minpc=", hex(datap->minpc), "min=", hex(min), "maxpc=", hex(datap->maxpc), "max=", hex(max));
            go_throw("minpc or maxpc invalid");
        }
        for(auto [_, modulehash] : datap->modulehashes)
        {
            if(modulehash.linktimehash != *modulehash.runtimehash)
            {
                println("abi mismatch detected between", datap->modulename, "and", modulehash.modulename);
                go_throw("abi mismatch");
            }
        }
    }

    uintptr_t textAddr(struct moduledata* md, uint32_t off32)
    {
        auto off = uintptr_t(off32);
        auto res = md->text + off;
        if(len(md->textsectmap) > 1)
        {
            for(auto [i, sect] : md->textsectmap)
            {
                if(off >= sect.vaddr && off < sect.end || (i == len(md->textsectmap) - 1 && off == sect.end))
                {
                    res = sect.baseaddr + off - sect.vaddr;
                    break;
                }
            }
            if(res > md->etext && GOARCH != "wasm")
            {
                println("runtime: textAddr", hex(res), "out of range", hex(md->text), "-", hex(md->etext));
                go_throw("runtime: text offset out of range");
            }
        }
        return res;
    }

    std::tuple<uint32_t, bool> textOff(struct moduledata* md, uintptr_t pc)
    {
        auto res = uint32_t(pc - md->text);
        if(len(md->textsectmap) > 1)
        {
            for(auto [i, sect] : md->textsectmap)
            {
                if(sect.baseaddr > pc)
                {
                    return {0, false};
                }
                auto end = sect.baseaddr + (sect.end - sect.vaddr);
                if(i == len(md->textsectmap) - 1)
                {
                    end++;
                }
                if(pc < end)
                {
                    res = uint32_t(pc - sect.baseaddr + sect.vaddr);
                    break;
                }
            }
        }
        return {res, true};
    }

    std::string funcName(struct moduledata* md, int32_t nameOff)
    {
        if(nameOff == 0)
        {
            return "";
        }
        return gostringnocopy(& md->funcnametab[nameOff]);
    }

    Func* FuncForPC(uintptr_t pc)
    {
        auto f = findfunc(pc);
        if(! valid(gocpp::recv(f)))
        {
            return nullptr;
        }
        auto [u, uf] = newInlineUnwinder(f, pc);
        if(! isInlined(gocpp::recv(u), uf))
        {
            return _Func(gocpp::recv(f));
        }
        auto sf = srcFunc(gocpp::recv(u), uf);
        auto [file, line] = fileLine(gocpp::recv(u), uf);
        auto fi = gocpp::InitPtr<funcinl>([](funcinl& x) { x.ones = ~ uint32_t(0); x.entry = entry(gocpp::recv(f)); x.name = name(gocpp::recv(sf)); x.file = file; x.line = int32_t(line); x.startLine = sf.startLine; });
        return (Func*)(unsafe::Pointer(fi));
    }

    std::string Name(struct Func* f)
    {
        if(f == nullptr)
        {
            return "";
        }
        auto fn = raw(gocpp::recv(f));
        if(isInlined(gocpp::recv(fn)))
        {
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return funcNameForPrint(fi->name);
        }
        return funcNameForPrint(funcname(funcInfo(gocpp::recv(f))));
    }

    uintptr_t Entry(struct Func* f)
    {
        auto fn = raw(gocpp::recv(f));
        if(isInlined(gocpp::recv(fn)))
        {
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return fi->entry;
        }
        return entry(gocpp::recv(funcInfo(gocpp::recv(fn))));
    }

    std::tuple<std::string, int> FileLine(struct Func* f, uintptr_t pc)
    {
        std::string file;
        int line;
        auto fn = raw(gocpp::recv(f));
        if(isInlined(gocpp::recv(fn)))
        {
            std::string file;
            int line;
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return {fi->file, int(fi->line)};
        }
        auto [file, line32] = funcline1(funcInfo(gocpp::recv(f)), pc, false);
        return {file, int(line32)};
    }

    int32_t startLine(struct Func* f)
    {
        auto fn = raw(gocpp::recv(f));
        if(isInlined(gocpp::recv(fn)))
        {
            auto fi = (funcinl*)(unsafe::Pointer(fn));
            return fi->startLine;
        }
        return funcInfo(gocpp::recv(fn)).startLine;
    }

    moduledata* findmoduledatap(uintptr_t pc)
    {
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(datap->minpc <= pc && pc < datap->maxpc)
            {
                return datap;
            }
        }
        return nullptr;
    }

    
    std::ostream& funcInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << datap;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct funcInfo& value)
    {
        return value.PrintTo(os);
    }

    bool valid(struct funcInfo f)
    {
        return f._func != nullptr;
    }

    Func* _Func(struct funcInfo f)
    {
        return (Func*)(unsafe::Pointer(f._func));
    }

    bool isInlined(struct _func* f)
    {
        return f->entryOff == ~ uint32_t(0);
    }

    uintptr_t entry(struct funcInfo f)
    {
        return textAddr(gocpp::recv(f.datap), f.entryOff);
    }

    funcInfo findfunc(uintptr_t pc)
    {
        auto datap = findmoduledatap(pc);
        if(datap == nullptr)
        {
            return funcInfo {};
        }
        auto nsub = uintptr_t(len(findfuncbucket {}.subbuckets));
        auto [pcOff, ok] = textOff(gocpp::recv(datap), pc);
        if(! ok)
        {
            return funcInfo {};
        }
        auto x = uintptr_t(pcOff) + datap->text - datap->minpc;
        auto b = x / pcbucketsize;
        auto i = x % pcbucketsize / (pcbucketsize / nsub);
        auto ffb = (findfuncbucket*)(add(unsafe::Pointer(datap->findfunctab), b * unsafe::Sizeof(findfuncbucket {})));
        auto idx = ffb->idx + uint32_t(ffb->subbuckets[i]);
        for(; datap->ftab[idx + 1].entryoff <= pcOff; )
        {
            idx++;
        }
        auto funcoff = datap->ftab[idx].funcoff;
        return funcInfo {(_func*)(unsafe::Pointer(& datap->pclntable[funcoff])), datap};
    }

    
    std::ostream& srcFunc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << datap;
        os << " " << nameOff;
        os << " " << startLine;
        os << " " << funcID;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct srcFunc& value)
    {
        return value.PrintTo(os);
    }

    srcFunc srcFunc(struct funcInfo f)
    {
        if(! valid(gocpp::recv(f)))
        {
            return srcFunc {};
        }
        return srcFunc {f.datap, f.nameOff, f.startLine, f.funcID};
    }

    std::string name(struct srcFunc s)
    {
        if(s.datap == nullptr)
        {
            return "";
        }
        return funcName(gocpp::recv(s.datap), s.nameOff);
    }

    
    std::ostream& pcvalueCache::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << entries;
        os << " " << inUse;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCache& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& pcvalueCacheEnt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << targetpc;
        os << " " << off;
        os << " " << val;
        os << " " << valPC;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pcvalueCacheEnt& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t pcvalueCacheKey(uintptr_t targetpc)
    {
        return (targetpc / goarch::PtrSize) % uintptr_t(len(pcvalueCache {}.entries));
    }

    std::tuple<int32_t, uintptr_t> pcvalue(funcInfo f, uint32_t off, uintptr_t targetpc, bool strict)
    {
        auto debugCheckCache = false;
        if(off == 0)
        {
            return {- 1, 0};
        }
        int32_t checkVal = {};
        uintptr_t checkPC = {};
        auto ck = pcvalueCacheKey(targetpc);
        {
            auto mp = acquirem();
            auto cache = & mp->pcvalueCache;
            cache->inUse++;
            if(cache->inUse == 1)
            {
                for(auto [i, gocpp_ignored] : cache->entries[ck])
                {
                    auto ent = & cache->entries[ck][i];
                    if(ent->off == off && ent->targetpc == targetpc)
                    {
                        auto [val, pc] = std::tuple{ent->val, ent->valPC};
                        if(debugCheckCache)
                        {
                            std::tie(checkVal, checkPC) = std::tuple{ent->val, ent->valPC};
                            break;
                        }
                        else
                        {
                            cache->inUse--;
                            releasem(mp);
                            return {val, pc};
                        }
                    }
                }
            }
            else
            if(debugCheckCache && (cache->inUse < 1 || cache->inUse > 2))
            {
                go_throw("cache.inUse out of range");
            }
            cache->inUse--;
            releasem(mp);
        }
        if(! valid(gocpp::recv(f)))
        {
            if(strict && Load(gocpp::recv(panicking)) == 0)
            {
                println("runtime: no module data for", hex(entry(gocpp::recv(f))));
                go_throw("no module data");
            }
            return {- 1, 0};
        }
        auto datap = f.datap;
        auto p = datap->pctab.make_slice(off);
        auto pc = entry(gocpp::recv(f));
        auto prevpc = pc;
        auto val = int32_t(- 1);
        for(; ; )
        {
            bool ok = {};
            std::tie(p, ok) = step(p, & pc, & val, pc == entry(gocpp::recv(f)));
            if(! ok)
            {
                break;
            }
            if(targetpc < pc)
            {
                if(debugCheckCache && checkPC != 0)
                {
                    if(checkVal != val || checkPC != prevpc)
                    {
                        print("runtime: table value ", val, "@", prevpc, " != cache value ", checkVal, "@", checkPC, " at PC ", targetpc, " off ", off, "\n");
                        go_throw("bad pcvalue cache");
                    }
                }
                else
                {
                    auto mp = acquirem();
                    auto cache = & mp->pcvalueCache;
                    cache->inUse++;
                    if(cache->inUse == 1)
                    {
                        auto e = & cache->entries[ck];
                        auto ci = cheaprandn(uint32_t(len(cache->entries[ck])));
                        e[ci] = e[0];
                        e[0] = gocpp::Init<pcvalueCacheEnt>([](pcvalueCacheEnt& x) { x.targetpc = targetpc; x.off = off; x.val = val; x.valPC = prevpc; });
                    }
                    cache->inUse--;
                    releasem(mp);
                }
                return {val, prevpc};
            }
            prevpc = pc;
        }
        if(Load(gocpp::recv(panicking)) != 0 || ! strict)
        {
            return {- 1, 0};
        }
        print("runtime: invalid pc-encoded table f=", funcname(f), " pc=", hex(pc), " targetpc=", hex(targetpc), " tab=", p, "\n");
        p = datap->pctab.make_slice(off);
        pc = entry(gocpp::recv(f));
        val = - 1;
        for(; ; )
        {
            bool ok = {};
            std::tie(p, ok) = step(p, & pc, & val, pc == entry(gocpp::recv(f)));
            if(! ok)
            {
                break;
            }
            print("\tvalue=", val, " until pc=", hex(pc), "\n");
        }
        go_throw("invalid runtime symbol table");
        return {- 1, 0};
    }

    std::string funcname(funcInfo f)
    {
        if(! valid(gocpp::recv(f)))
        {
            return "";
        }
        return funcName(gocpp::recv(f.datap), f.nameOff);
    }

    std::string funcpkgpath(funcInfo f)
    {
        auto name = funcNameForPrint(funcname(f));
        auto i = len(name) - 1;
        for(; i > 0; i--)
        {
            if(name[i] == '/')
            {
                break;
            }
        }
        for(; i < len(name); i++)
        {
            if(name[i] == '.')
            {
                break;
            }
        }
        return name.make_slice(0, i);
    }

    std::string funcfile(funcInfo f, int32_t fileno)
    {
        auto datap = f.datap;
        if(! valid(gocpp::recv(f)))
        {
            return "?";
        }
        if(auto fileoff = datap->cutab[f.cuOffset + uint32_t(fileno)]; fileoff != ~ uint32_t(0))
        {
            return gostringnocopy(& datap->filetab[fileoff]);
        }
        return "?";
    }

    std::tuple<std::string, int32_t> funcline1(funcInfo f, uintptr_t targetpc, bool strict)
    {
        std::string file;
        int32_t line;
        auto datap = f.datap;
        if(! valid(gocpp::recv(f)))
        {
            std::string file;
            int32_t line;
            return {"?", 0};
        }
        auto [fileno, _] = pcvalue(f, f.pcfile, targetpc, strict);
        std::tie(line, _) = pcvalue(f, f.pcln, targetpc, strict);
        if(fileno == - 1 || line == - 1 || int(fileno) >= len(datap->filetab))
        {
            std::string file;
            int32_t line;
            return {"?", 0};
        }
        file = funcfile(f, fileno);
        return {file, line};
    }

    std::tuple<std::string, int32_t> funcline(funcInfo f, uintptr_t targetpc)
    {
        std::string file;
        int32_t line;
        return funcline1(f, targetpc, true);
    }

    int32_t funcspdelta(funcInfo f, uintptr_t targetpc)
    {
        auto [x, _] = pcvalue(f, f.pcsp, targetpc, true);
        if(debugPcln && x & (goarch::PtrSize - 1) != 0)
        {
            print("invalid spdelta ", funcname(f), " ", hex(entry(gocpp::recv(f))), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n");
            go_throw("bad spdelta");
        }
        return x;
    }

    int32_t funcMaxSPDelta(funcInfo f)
    {
        auto datap = f.datap;
        auto p = datap->pctab.make_slice(f.pcsp);
        auto pc = entry(gocpp::recv(f));
        auto val = int32_t(- 1);
        auto most = int32_t(0);
        for(; ; )
        {
            bool ok = {};
            std::tie(p, ok) = step(p, & pc, & val, pc == entry(gocpp::recv(f)));
            if(! ok)
            {
                return most;
            }
            most = max(most, val);
        }
    }

    uint32_t pcdatastart(funcInfo f, uint32_t table)
    {
        return *(uint32_t*)(add(unsafe::Pointer(& f.nfuncdata), unsafe::Sizeof(f.nfuncdata) + uintptr_t(table) * 4));
    }

    int32_t pcdatavalue(funcInfo f, uint32_t table, uintptr_t targetpc)
    {
        if(table >= f.npcdata)
        {
            return - 1;
        }
        auto [r, _] = pcvalue(f, pcdatastart(f, table), targetpc, true);
        return r;
    }

    int32_t pcdatavalue1(funcInfo f, uint32_t table, uintptr_t targetpc, bool strict)
    {
        if(table >= f.npcdata)
        {
            return - 1;
        }
        auto [r, _] = pcvalue(f, pcdatastart(f, table), targetpc, strict);
        return r;
    }

    std::tuple<int32_t, uintptr_t> pcdatavalue2(funcInfo f, uint32_t table, uintptr_t targetpc)
    {
        if(table >= f.npcdata)
        {
            return {- 1, 0};
        }
        return pcvalue(f, pcdatastart(f, table), targetpc, true);
    }

    unsafe::Pointer funcdata(funcInfo f, uint8_t i)
    {
        if(i < 0 || i >= f.nfuncdata)
        {
            return nullptr;
        }
        auto base = f.datap->gofunc;
        auto p = uintptr_t(unsafe::Pointer(& f.nfuncdata)) + unsafe::Sizeof(f.nfuncdata) + uintptr_t(f.npcdata) * 4 + uintptr_t(i) * 4;
        auto off = *(uint32_t*)(unsafe::Pointer(p));
        uintptr_t mask = {};
        if(off == ~ uint32_t(0))
        {
            mask = 1;
        }
        mask--;
        auto raw = base + uintptr_t(off);
        return unsafe::Pointer(raw & mask);
    }

    std::tuple<gocpp::slice<unsigned char>, bool> step(gocpp::slice<unsigned char> p, uintptr_t* pc, int32_t* val, bool first)
    {
        gocpp::slice<unsigned char> newp;
        bool ok;
        auto uvdelta = uint32_t(p[0]);
        if(uvdelta == 0 && ! first)
        {
            gocpp::slice<unsigned char> newp;
            bool ok;
            return {nullptr, false};
        }
        auto n = uint32_t(1);
        if(uvdelta & 0x80 != 0)
        {
            gocpp::slice<unsigned char> newp;
            bool ok;
            std::tie(n, uvdelta) = readvarint(p);
        }
        *val += int32_t(- (uvdelta & 1) ^ (uvdelta >> 1));
        p = p.make_slice(n);
        auto pcdelta = uint32_t(p[0]);
        n = 1;
        if(pcdelta & 0x80 != 0)
        {
            gocpp::slice<unsigned char> newp;
            bool ok;
            std::tie(n, pcdelta) = readvarint(p);
        }
        p = p.make_slice(n);
        *pc += uintptr_t(pcdelta * sys::PCQuantum);
        return {p, true};
    }

    std::tuple<uint32_t, uint32_t> readvarint(gocpp::slice<unsigned char> p)
    {
        uint32_t read;
        uint32_t val;
        uint32_t v = {};
        uint32_t shift = {};
        uint32_t n = {};
        for(; ; )
        {
            uint32_t read;
            uint32_t val;
            auto b = p[n];
            n++;
            v |= uint32_t(b & 0x7F) << (shift & 31);
            if(b & 0x80 == 0)
            {
                uint32_t read;
                uint32_t val;
                break;
            }
            shift += 7;
        }
        return {n, v};
    }

    
    std::ostream& stackmap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << n;
        os << " " << nbit;
        os << " " << bytedata;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stackmap& value)
    {
        return value.PrintTo(os);
    }

    bitvector stackmapdata(stackmap* stkmap, int32_t n)
    {
        if(stackDebug > 0 && (n < 0 || n >= stkmap->n))
        {
            go_throw("stackmapdata: index out of range");
        }
        return bitvector {stkmap->nbit, addb(& stkmap->bytedata[0], uintptr_t(n * ((stkmap->nbit + 7) >> 3)))};
    }

}

