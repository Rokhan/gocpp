// generated by GoCpp from file '$(ImportDir)/runtime/trace2buf.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2buf.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2string.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceWriter::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceWriter::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& traceWriter::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceWriter& value)
    {
        return value.PrintTo(os);
    }

    struct traceWriter rec::writer(struct traceLocker tl)
    {
        return gocpp::Init<traceWriter>([=](auto& x) {
            x.traceLocker = tl;
            x.traceBuf = tl.mp->trace.buf[tl.gen % 2];
        });
    }

    struct traceWriter unsafeTraceWriter(uintptr_t gen, struct traceBuf* buf)
    {
        return gocpp::Init<traceWriter>([=](auto& x) {
            x.traceLocker = gocpp::Init<traceLocker>([=](auto& x) {
                x.gen = gen;
            });
            x.traceBuf = buf;
        });
    }

    void rec::end(struct traceWriter w)
    {
        if(w.mp == nullptr)
        {
            return;
        }
        w.mp->trace.buf[w.gen % 2] = w.traceBuf;
    }

    std::tuple<struct traceWriter, bool> rec::ensure(struct traceWriter w, int maxSize)
    {
        auto refill = w.traceBuf == nullptr || ! rec::available(gocpp::recv(w), maxSize);
        if(refill)
        {
            w = rec::refill(gocpp::recv(w));
        }
        return {w, refill};
    }

    struct traceWriter rec::flush(struct traceWriter w)
    {
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(w.traceBuf != nullptr)
            {
                traceBufFlush(w.traceBuf, w.gen);
            }
            unlock(& trace.lock);
        });
        w.traceBuf = nullptr;
        return w;
    }

    struct traceWriter rec::refill(struct traceWriter w)
    {
        systemstack([=]() mutable -> void
        {
            lock(& trace.lock);
            if(w.traceBuf != nullptr)
            {
                traceBufFlush(w.traceBuf, w.gen);
            }
            if(trace.empty != nullptr)
            {
                w.traceBuf = trace.empty;
                trace.empty = w.traceBuf->link;
                unlock(& trace.lock);
            }
            else
            {
                unlock(& trace.lock);
                w.traceBuf = (traceBuf*)(sysAlloc(gocpp::Sizeof<traceBuf>(), & memstats.other_sys));
                if(w.traceBuf == nullptr)
                {
                    go_throw("trace: out of memory");
                }
            }
        });
        auto ts = traceClockNow();
        if(ts <= w.traceBuf->lastTime)
        {
            ts = w.traceBuf->lastTime + 1;
        }
        w.traceBuf->lastTime = ts;
        w.traceBuf->link = nullptr;
        w.traceBuf->pos = 0;
        auto mID = ~ uint64_t(0);
        if(w.mp != nullptr)
        {
            mID = uint64_t(w.mp->procid);
        }
        rec::byte(gocpp::recv(w), unsigned char(traceEvEventBatch));
        rec::varint(gocpp::recv(w), uint64_t(w.gen));
        rec::varint(gocpp::recv(w), uint64_t(mID));
        rec::varint(gocpp::recv(w), uint64_t(ts));
        w.traceBuf->lenPos = rec::varintReserve(gocpp::recv(w));
        return w;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceBufQueue::operator T()
    {
        T result;
        result.head = this->head;
        result.tail = this->tail;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceBufQueue::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        if (tail != ref.tail) return false;
        return true;
    }

    std::ostream& traceBufQueue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBufQueue& value)
    {
        return value.PrintTo(os);
    }

    void rec::push(struct traceBufQueue* q, struct traceBuf* buf)
    {
        buf->link = nullptr;
        if(q->head == nullptr)
        {
            q->head = buf;
        }
        else
        {
            q->tail->link = buf;
        }
        q->tail = buf;
    }

    struct traceBuf* rec::pop(struct traceBufQueue* q)
    {
        auto buf = q->head;
        if(buf == nullptr)
        {
            return nullptr;
        }
        q->head = buf->link;
        if(q->head == nullptr)
        {
            q->tail = nullptr;
        }
        buf->link = nullptr;
        return buf;
    }

    bool rec::empty(struct traceBufQueue* q)
    {
        return q->head == nullptr;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceBufHeader::operator T()
    {
        T result;
        result.link = this->link;
        result.lastTime = this->lastTime;
        result.pos = this->pos;
        result.lenPos = this->lenPos;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceBufHeader::operator==(const T& ref) const
    {
        if (link != ref.link) return false;
        if (lastTime != ref.lastTime) return false;
        if (pos != ref.pos) return false;
        if (lenPos != ref.lenPos) return false;
        return true;
    }

    std::ostream& traceBufHeader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << link;
        os << " " << lastTime;
        os << " " << pos;
        os << " " << lenPos;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBufHeader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    traceBuf::operator T()
    {
        T result;
        result._1 = this->_1;
        result.arr = this->arr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceBuf::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (arr != ref.arr) return false;
        return true;
    }

    std::ostream& traceBuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << arr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceBuf& value)
    {
        return value.PrintTo(os);
    }

    void rec::byte(struct traceBuf* buf, unsigned char v)
    {
        buf->arr[buf->pos] = v;
        buf->pos++;
    }

    void rec::varint(struct traceBuf* buf, uint64_t v)
    {
        auto pos = buf->pos;
        auto arr = buf->arr.make_slice(pos, pos + traceBytesPerNumber);
        for(auto [i, gocpp_ignored] : arr)
        {
            if(v < 0x80)
            {
                pos += i + 1;
                arr[i] = unsigned char(v);
                break;
            }
            arr[i] = 0x80 | unsigned char(v);
            v >>= 7;
        }
        buf->pos = pos;
    }

    int rec::varintReserve(struct traceBuf* buf)
    {
        auto p = buf->pos;
        buf->pos += traceBytesPerNumber;
        return p;
    }

    void rec::stringData(struct traceBuf* buf, std::string s)
    {
        buf->pos += copy(buf->arr.make_slice(buf->pos), s);
    }

    bool rec::available(struct traceBuf* buf, int size)
    {
        return len(buf->arr) - buf->pos >= size;
    }

    void rec::varintAt(struct traceBuf* buf, int pos, uint64_t v)
    {
        for(auto i = 0; i < traceBytesPerNumber; i++)
        {
            if(i < traceBytesPerNumber - 1)
            {
                buf->arr[pos] = 0x80 | unsigned char(v);
            }
            else
            {
                buf->arr[pos] = unsigned char(v);
            }
            v >>= 7;
            pos++;
        }
        if(v != 0)
        {
            go_throw("v could not fit in traceBytesPerNumber");
        }
    }

    void traceBufFlush(struct traceBuf* buf, uintptr_t gen)
    {
        assertLockHeld(& trace.lock);
        rec::varintAt(gocpp::recv(buf), buf->lenPos, uint64_t(buf->pos - (buf->lenPos + traceBytesPerNumber)));
        rec::push(gocpp::recv(trace.full[gen % 2]), buf);
        if(! rec::Load(gocpp::recv(trace.workAvailable)))
        {
            rec::Store(gocpp::recv(trace.workAvailable), true);
        }
    }

}

