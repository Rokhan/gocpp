// generated by GoCpp from file '$(ImportDir)/internal/cpu/cpu.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/cpu/cpu.h"
#include "gocpp/support.h"

#include "golang/internal/cpu/cpu_x86.h"

namespace golang::cpu
{
    bool DebugOptions;
    
    std::ostream& CacheLinePad::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const CacheLinePad& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t CacheLineSize = CacheLinePadSize;
    struct gocpp_id_0
    {
        CacheLinePad _;
        bool HasAES;
        bool HasADX;
        bool HasAVX;
        bool HasAVX2;
        bool HasAVX512F;
        bool HasAVX512BW;
        bool HasAVX512VL;
        bool HasBMI1;
        bool HasBMI2;
        bool HasERMS;
        bool HasFMA;
        bool HasOSXSAVE;
        bool HasPCLMULQDQ;
        bool HasPOPCNT;
        bool HasRDTSCP;
        bool HasSHA;
        bool HasSSE3;
        bool HasSSSE3;
        bool HasSSE41;
        bool HasSSE42;
        CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << _;
            os << " " << HasAES;
            os << " " << HasADX;
            os << " " << HasAVX;
            os << " " << HasAVX2;
            os << " " << HasAVX512F;
            os << " " << HasAVX512BW;
            os << " " << HasAVX512VL;
            os << " " << HasBMI1;
            os << " " << HasBMI2;
            os << " " << HasERMS;
            os << " " << HasFMA;
            os << " " << HasOSXSAVE;
            os << " " << HasPCLMULQDQ;
            os << " " << HasPOPCNT;
            os << " " << HasRDTSCP;
            os << " " << HasSHA;
            os << " " << HasSSE3;
            os << " " << HasSSSE3;
            os << " " << HasSSE41;
            os << " " << HasSSE42;
            os << " " << _;
            os << '}';
            return os;
        }
    };
    gocpp_id_0 X86;
    struct gocpp_id_1
    {
        CacheLinePad _;
        bool HasVFPv4;
        bool HasIDIVA;
        bool HasV7Atomics;
        CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << _;
            os << " " << HasVFPv4;
            os << " " << HasIDIVA;
            os << " " << HasV7Atomics;
            os << " " << _;
            os << '}';
            return os;
        }
    };
    gocpp_id_1 ARM;
    struct gocpp_id_2
    {
        CacheLinePad _;
        bool HasAES;
        bool HasPMULL;
        bool HasSHA1;
        bool HasSHA2;
        bool HasSHA512;
        bool HasCRC32;
        bool HasATOMICS;
        bool HasCPUID;
        bool IsNeoverse;
        CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << _;
            os << " " << HasAES;
            os << " " << HasPMULL;
            os << " " << HasSHA1;
            os << " " << HasSHA2;
            os << " " << HasSHA512;
            os << " " << HasCRC32;
            os << " " << HasATOMICS;
            os << " " << HasCPUID;
            os << " " << IsNeoverse;
            os << " " << _;
            os << '}';
            return os;
        }
    };
    gocpp_id_2 ARM64;
    struct gocpp_id_3
    {
        CacheLinePad _;
        bool HasMSA;
        CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << _;
            os << " " << HasMSA;
            os << " " << _;
            os << '}';
            return os;
        }
    };
    gocpp_id_3 MIPS64X;
    struct gocpp_id_4
    {
        CacheLinePad _;
        bool HasDARN;
        bool HasSCV;
        bool IsPOWER8;
        bool IsPOWER9;
        bool IsPOWER10;
        CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << _;
            os << " " << HasDARN;
            os << " " << HasSCV;
            os << " " << IsPOWER8;
            os << " " << IsPOWER9;
            os << " " << IsPOWER10;
            os << " " << _;
            os << '}';
            return os;
        }
    };
    gocpp_id_4 PPC64;
    struct gocpp_id_5
    {
        CacheLinePad _;
        bool HasZARCH;
        bool HasSTFLE;
        bool HasLDISP;
        bool HasEIMM;
        bool HasDFP;
        bool HasETF3EH;
        bool HasMSA;
        bool HasAES;
        bool HasAESCBC;
        bool HasAESCTR;
        bool HasAESGCM;
        bool HasGHASH;
        bool HasSHA1;
        bool HasSHA256;
        bool HasSHA512;
        bool HasSHA3;
        bool HasVX;
        bool HasVXE;
        bool HasKDSA;
        bool HasECDSA;
        bool HasEDDSA;
        CacheLinePad _;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << _;
            os << " " << HasZARCH;
            os << " " << HasSTFLE;
            os << " " << HasLDISP;
            os << " " << HasEIMM;
            os << " " << HasDFP;
            os << " " << HasETF3EH;
            os << " " << HasMSA;
            os << " " << HasAES;
            os << " " << HasAESCBC;
            os << " " << HasAESCTR;
            os << " " << HasAESGCM;
            os << " " << HasGHASH;
            os << " " << HasSHA1;
            os << " " << HasSHA256;
            os << " " << HasSHA512;
            os << " " << HasSHA3;
            os << " " << HasVX;
            os << " " << HasVXE;
            os << " " << HasKDSA;
            os << " " << HasECDSA;
            os << " " << HasEDDSA;
            os << " " << _;
            os << '}';
            return os;
        }
    };
    gocpp_id_5 S390X;
    void Initialize(std::string env)
    {
        doinit();
        processOptions(env);
    }

    gocpp::slice<option> options;
    
    std::ostream& option::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Name;
        os << " " << Feature;
        os << " " << Specified;
        os << " " << Enable;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const option& value)
    {
        return value.PrintTo(os);
    }

    void processOptions(std::string env)
    {
        for(; env != ""; )
        {
            auto field = "";
            auto i = indexByte(env, ',');
            if(i < 0)
            {
                std::tie(field, env) = std::tuple{env, ""};
            }
            else
            {
                std::tie(field, env) = std::tuple{env.make_slice(0, i), env.make_slice(i + 1)};
            }
            if(len(field) < 4 || field.make_slice(0, 4) != "cpu.")
            {
                continue;
            }
            i = indexByte(field, '=');
            if(i < 0)
            {
                print("GODEBUG: no value specified for \"", field, "\"\n");
                continue;
            }
            auto [key, value] = std::tuple{field.make_slice(4, i), field.make_slice(i + 1)};
            bool enable = {};
            //Go switch emulation
            {
                auto condition = value;
                int conditionId = -1;
                if(condition == "on") { conditionId = 0; }
                else if(condition == "off") { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        enable = true;
                        break;
                    case 1:
                        enable = false;
                        break;
                    default:
                        print("GODEBUG: value \"", value, "\" not supported for cpu option \"", key, "\"\n");
                        goto field_continue;
                        break;
                }
            }
            if(key == "all")
            {
                for(auto [i, gocpp_ignored] : options)
                {
                    options[i].Specified = true;
                    options[i].Enable = enable;
                }
                goto field_continue;
            }
            for(auto [i, gocpp_ignored] : options)
            {
                if(options[i].Name == key)
                {
                    options[i].Specified = true;
                    options[i].Enable = enable;
                    goto field_continue;
                }
            }
            print("GODEBUG: unknown cpu feature \"", key, "\"\n");
            if(false) {
            field_continue:
                continue;
            field_break:
                break;
            }
        }
        for(auto [_, o] : options)
        {
            if(! o.Specified)
            {
                continue;
            }
            if(o.Enable && ! *o.Feature)
            {
                print("GODEBUG: can not enable \"", o.Name, "\", missing CPU support\n");
                continue;
            }
            *o.Feature = o.Enable;
        }
    }

    int indexByte(std::string s, unsigned char c)
    {
        for(auto i = 0; i < len(s); i++)
        {
            if(s[i] == c)
            {
                return i;
            }
        }
        return - 1;
    }

}

