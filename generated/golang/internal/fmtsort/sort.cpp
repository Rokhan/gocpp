// generated by GoCpp from file '$(ImportDir)/internal/fmtsort/sort.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/fmtsort/sort.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/reflect/type.h"
#include "golang/reflect/value.h"
#include "golang/sort/sort.h"

// Package fmtsort provides a general stable ordering mechanism
// for maps, on behalf of the fmt and text/template packages.
// It is not guaranteed to be efficient and works only for types
// that are valid map keys.
namespace golang::fmtsort
{
    namespace rec
    {
        using namespace mocklib::rec;
        using reflect::rec::Bool;
        using reflect::rec::Complex;
        using reflect::rec::Elem;
        using reflect::rec::Field;
        using reflect::rec::Float;
        using reflect::rec::Index;
        using reflect::rec::Int;
        using reflect::rec::IsNil;
        using reflect::rec::Key;
        using reflect::rec::Kind;
        using reflect::rec::Len;
        using reflect::rec::MapRange;
        using reflect::rec::Next;
        using reflect::rec::NumField;
        using reflect::rec::Pointer;
        using reflect::rec::String;
        using reflect::rec::Type;
        using reflect::rec::Uint;
        using reflect::rec::Value;
    }

    // SortedMap represents a map's keys and values. The keys and values are
    // aligned in index order: Value[i] is the value in the map corresponding to Key[i].
    
    template<typename T> requires gocpp::GoStruct<T>
    SortedMap::operator T()
    {
        T result;
        result.Key = this->Key;
        result.Value = this->Value;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool SortedMap::operator==(const T& ref) const
    {
        if (Key != ref.Key) return false;
        if (Value != ref.Value) return false;
        return true;
    }

    std::ostream& SortedMap::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Key;
        os << " " << Value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct SortedMap& value)
    {
        return value.PrintTo(os);
    }

    int rec::Len(struct SortedMap* o)
    {
        return len(o->Key);
    }

    bool rec::Less(struct SortedMap* o, int i, int j)
    {
        return compare(o->Key[i], o->Key[j]) < 0;
    }

    void rec::Swap(struct SortedMap* o, int i, int j)
    {
        std::tie(o->Key[i], o->Key[j]) = std::tuple{o->Key[j], o->Key[i]};
        std::tie(o->Value[i], o->Value[j]) = std::tuple{o->Value[j], o->Value[i]};
    }

    // Sort accepts a map and returns a SortedMap that has the same keys and
    // values but in a stable sorted order according to the keys, modulo issues
    // raised by unorderable key values such as NaNs.
    //
    // The ordering rules are more general than with Go's < operator:
    //
    //   - when applicable, nil compares low
    //   - ints, floats, and strings order by <
    //   - NaN compares less than non-NaN floats
    //   - bool compares false before true
    //   - complex compares real, then imag
    //   - pointers compare by machine address
    //   - channel values compare by machine address
    //   - structs compare each field in turn
    //   - arrays compare each element in turn.
    //     Otherwise identical arrays compare by length.
    //   - interface values compare first by reflect.Type describing the concrete type
    //     and then by concrete value as described in the previous rules.
    struct SortedMap* Sort(reflect::Value mapValue)
    {
        if(rec::Kind(gocpp::recv(rec::Type(gocpp::recv(mapValue)))) != reflect::Map)
        {
            return nullptr;
        }
        auto n = rec::Len(gocpp::recv(mapValue));
        auto key = gocpp::make(gocpp::Tag<gocpp::slice<reflect::Value>>(), 0, n);
        auto value = gocpp::make(gocpp::Tag<gocpp::slice<reflect::Value>>(), 0, n);
        auto iter = rec::MapRange(gocpp::recv(mapValue));
        for(; rec::Next(gocpp::recv(iter)); )
        {
            key = append(key, rec::Key(gocpp::recv(iter)));
            value = append(value, rec::Value(gocpp::recv(iter)));
        }
        auto sorted = gocpp::InitPtr<SortedMap>([=](auto& x) {
            x.Key = key;
            x.Value = value;
        });
        sort::Stable(sorted);
        return sorted;
    }

    // compare compares two values of the same type. It returns -1, 0, 1
    // according to whether a > b (1), a == b (0), or a < b (-1).
    // If the types differ, it returns -1.
    // See the comment on Sort for the comparison rules.
    int compare(reflect::Value aVal, reflect::Value bVal)
    {
        auto [aType, bType] = std::tuple{rec::Type(gocpp::recv(aVal)), rec::Type(gocpp::recv(bVal))};
        if(aType != bType)
        {
            return - 1;
        }
        //Go switch emulation
        {
            auto condition = rec::Kind(gocpp::recv(aVal));
            int conditionId = -1;
            if(condition == reflect::Int) { conditionId = 0; }
            else if(condition == reflect::Int8) { conditionId = 1; }
            else if(condition == reflect::Int16) { conditionId = 2; }
            else if(condition == reflect::Int32) { conditionId = 3; }
            else if(condition == reflect::Int64) { conditionId = 4; }
            else if(condition == reflect::Uint) { conditionId = 5; }
            else if(condition == reflect::Uint8) { conditionId = 6; }
            else if(condition == reflect::Uint16) { conditionId = 7; }
            else if(condition == reflect::Uint32) { conditionId = 8; }
            else if(condition == reflect::Uint64) { conditionId = 9; }
            else if(condition == reflect::Uintptr) { conditionId = 10; }
            else if(condition == reflect::String) { conditionId = 11; }
            else if(condition == reflect::Float32) { conditionId = 12; }
            else if(condition == reflect::Float64) { conditionId = 13; }
            else if(condition == reflect::Complex64) { conditionId = 14; }
            else if(condition == reflect::Complex128) { conditionId = 15; }
            else if(condition == reflect::Bool) { conditionId = 16; }
            else if(condition == reflect::Pointer) { conditionId = 17; }
            else if(condition == reflect::UnsafePointer) { conditionId = 18; }
            else if(condition == reflect::Chan) { conditionId = 19; }
            else if(condition == reflect::Struct) { conditionId = 20; }
            else if(condition == reflect::Array) { conditionId = 21; }
            else if(condition == reflect::Interface) { conditionId = 22; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    auto [a, b] = std::tuple{rec::Int(gocpp::recv(aVal)), rec::Int(gocpp::recv(bVal))};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(a < b) { conditionId = 0; }
                        else if(a > b) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                return - 1;
                                break;
                            case 1:
                                return 1;
                                break;
                            default:
                                return 0;
                                break;
                        }
                    }
                    break;
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    std::tie(a, b) = std::tuple{rec::Uint(gocpp::recv(aVal)), rec::Uint(gocpp::recv(bVal))};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(a < b) { conditionId = 0; }
                        else if(a > b) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                return - 1;
                                break;
                            case 1:
                                return 1;
                                break;
                            default:
                                return 0;
                                break;
                        }
                    }
                    break;
                case 11:
                    std::tie(a, b) = std::tuple{rec::String(gocpp::recv(aVal)), rec::String(gocpp::recv(bVal))};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(a < b) { conditionId = 0; }
                        else if(a > b) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                return - 1;
                                break;
                            case 1:
                                return 1;
                                break;
                            default:
                                return 0;
                                break;
                        }
                    }
                    break;
                case 12:
                case 13:
                    return floatCompare(rec::Float(gocpp::recv(aVal)), rec::Float(gocpp::recv(bVal)));
                    break;
                case 14:
                case 15:
                    std::tie(a, b) = std::tuple{rec::Complex(gocpp::recv(aVal)), rec::Complex(gocpp::recv(bVal))};
                    if(auto c = floatCompare(real(a), real(b)); c != 0)
                    {
                        return c;
                    }
                    return floatCompare(imag(a), imag(b));
                    break;
                case 16:
                    std::tie(a, b) = std::tuple{rec::Bool(gocpp::recv(aVal)), rec::Bool(gocpp::recv(bVal))};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(a == b) { conditionId = 0; }
                        else if(a) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                return 0;
                                break;
                            case 1:
                                return 1;
                                break;
                            default:
                                return - 1;
                                break;
                        }
                    }
                    break;
                case 17:
                case 18:
                    std::tie(a, b) = std::tuple{rec::Pointer(gocpp::recv(aVal)), rec::Pointer(gocpp::recv(bVal))};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(a < b) { conditionId = 0; }
                        else if(a > b) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                return - 1;
                                break;
                            case 1:
                                return 1;
                                break;
                            default:
                                return 0;
                                break;
                        }
                    }
                    break;
                case 19:
                    if(auto [c, ok] = nilCompare(aVal, bVal); ok)
                    {
                        return c;
                    }
                    auto [ap, bp] = std::tuple{rec::Pointer(gocpp::recv(aVal)), rec::Pointer(gocpp::recv(bVal))};
                    //Go switch emulation
                    {
                        int conditionId = -1;
                        if(ap < bp) { conditionId = 0; }
                        else if(ap > bp) { conditionId = 1; }
                        switch(conditionId)
                        {
                            case 0:
                                return - 1;
                                break;
                            case 1:
                                return 1;
                                break;
                            default:
                                return 0;
                                break;
                        }
                    }
                    break;
                case 20:
                    for(auto i = 0; i < rec::NumField(gocpp::recv(aVal)); i++)
                    {
                        if(auto c = compare(rec::Field(gocpp::recv(aVal), i), rec::Field(gocpp::recv(bVal), i)); c != 0)
                        {
                            return c;
                        }
                    }
                    return 0;
                    break;
                case 21:
                    for(auto i = 0; i < rec::Len(gocpp::recv(aVal)); i++)
                    {
                        if(auto c = compare(rec::Index(gocpp::recv(aVal), i), rec::Index(gocpp::recv(bVal), i)); c != 0)
                        {
                            return c;
                        }
                    }
                    return 0;
                    break;
                case 22:
                    if(auto [c, ok] = nilCompare(aVal, bVal); ok)
                    {
                        return c;
                    }
                    auto c = compare(reflect::ValueOf(rec::Type(gocpp::recv(rec::Elem(gocpp::recv(aVal))))), reflect::ValueOf(rec::Type(gocpp::recv(rec::Elem(gocpp::recv(bVal))))));
                    if(c != 0)
                    {
                        return c;
                    }
                    return compare(rec::Elem(gocpp::recv(aVal)), rec::Elem(gocpp::recv(bVal)));
                    break;
                default:
                    gocpp::panic("bad type in compare: "s + rec::String(gocpp::recv(aType)));
                    break;
            }
        }
    }

    // nilCompare checks whether either value is nil. If not, the boolean is false.
    // If either value is nil, the boolean is true and the integer is the comparison
    // value. The comparison is defined to be 0 if both are nil, otherwise the one
    // nil value compares low. Both arguments must represent a chan, func,
    // interface, map, pointer, or slice.
    std::tuple<int, bool> nilCompare(reflect::Value aVal, reflect::Value bVal)
    {
        if(rec::IsNil(gocpp::recv(aVal)))
        {
            if(rec::IsNil(gocpp::recv(bVal)))
            {
                return {0, true};
            }
            return {- 1, true};
        }
        if(rec::IsNil(gocpp::recv(bVal)))
        {
            return {1, true};
        }
        return {0, false};
    }

    // floatCompare compares two floating-point values. NaNs compare low.
    int floatCompare(double a, double b)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(isNaN(a)) { conditionId = 0; }
            else if(isNaN(b)) { conditionId = 1; }
            else if(a < b) { conditionId = 2; }
            else if(a > b) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return - 1;
                    break;
                case 1:
                    return 1;
                    break;
                case 2:
                    return - 1;
                    break;
                case 3:
                    return 1;
                    break;
            }
        }
        return 0;
    }

    bool isNaN(double a)
    {
        return a != a;
    }

}

