// generated by GoCpp from file '$(ImportDir)/internal/bisect/bisect.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/bisect/bisect.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/mutex.h"
#include "golang/unsafe/unsafe.h"

namespace golang::bisect
{
    std::tuple<Matcher*, gocpp::error> New(std::string pattern)
    {
        if(pattern == "")
        {
            return {nullptr, nullptr};
        }
        auto m = go_new(Matcher);
        auto p = pattern;
        if(len(p) > 0 && p[0] == 'q')
        {
            m->quiet = true;
            p = p.make_slice(1);
            if(p == "")
            {
                return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
            }
        }
        for(; len(p) > 0 && p[0] == 'v'; )
        {
            m->verbose = true;
            m->quiet = false;
            p = p.make_slice(1);
            if(p == "")
            {
                return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
            }
        }
        m->enable = true;
        for(; len(p) > 0 && p[0] == '!'; )
        {
            m->enable = ! m->enable;
            p = p.make_slice(1);
            if(p == "")
            {
                return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
            }
        }
        if(p == "n")
        {
            m->enable = ! m->enable;
            p = "y";
        }
        auto result = true;
        auto bits = uint64_t(0);
        auto start = 0;
        auto wid = 1;
        for(auto i = 0; i <= len(p); i++)
        {
            auto c = unsigned char('-');
            if(i < len(p))
            {
                c = p[i];
            }
            if(i == start && wid == 1 && c == 'x')
            {
                start = i + 1;
                wid = 4;
                continue;
            }
            //Go switch emulation
            {
                auto condition = c;
                int conditionId = -1;
                else if(condition == '2') { conditionId = 0; }
                else if(condition == '3') { conditionId = 1; }
                else if(condition == '4') { conditionId = 2; }
                else if(condition == '5') { conditionId = 3; }
                else if(condition == '6') { conditionId = 4; }
                else if(condition == '7') { conditionId = 5; }
                else if(condition == '8') { conditionId = 6; }
                else if(condition == '9') { conditionId = 7; }
                else if(condition == '0') { conditionId = 8; }
                else if(condition == '1') { conditionId = 9; }
                else if(condition == 'a') { conditionId = 10; }
                else if(condition == 'b') { conditionId = 11; }
                else if(condition == 'c') { conditionId = 12; }
                else if(condition == 'd') { conditionId = 13; }
                else if(condition == 'e') { conditionId = 14; }
                else if(condition == 'f') { conditionId = 15; }
                else if(condition == 'A') { conditionId = 16; }
                else if(condition == 'B') { conditionId = 17; }
                else if(condition == 'C') { conditionId = 18; }
                else if(condition == 'D') { conditionId = 19; }
                else if(condition == 'E') { conditionId = 20; }
                else if(condition == 'F') { conditionId = 21; }
                else if(condition == 'y') { conditionId = 22; }
                else if(condition == '+') { conditionId = 23; }
                else if(condition == '-') { conditionId = 24; }
                switch(conditionId)
                {
                    default:
                        return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
                        break;
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        if(wid != 4)
                        {
                            return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
                        }
                    case 8:
                    case 9:
                        bits <<= wid;
                        bits |= uint64_t(c - '0');
                        break;
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                        if(wid != 4)
                        {
                            return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
                        }
                        bits <<= 4;
                        bits |= uint64_t(c &^ 0x20 - 'A' + 10);
                        break;
                    case 22:
                        if(i + 1 < len(p) && (p[i + 1] == '0' || p[i + 1] == '1'))
                        {
                            return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
                        }
                        bits = 0;
                        break;
                    case 23:
                    case 24:
                        if(c == '+' && result == false)
                        {
                            return {nullptr, new parseError {"invalid pattern syntax (+ after -): " + pattern}};
                        }
                        if(i > 0)
                        {
                            auto n = (i - start) * wid;
                            if(n > 64)
                            {
                                return {nullptr, new parseError {"pattern bits too long: " + pattern}};
                            }
                            if(n <= 0)
                            {
                                return {nullptr, new parseError {"invalid pattern syntax: " + pattern}};
                            }
                            if(p[start] == 'y')
                            {
                                n = 0;
                            }
                            auto mask = (uint64_t(1) << n) - 1;
                            m->list = append(m->list, cond {mask, bits, result});
                        }
                        else
                        if(c == '-')
                        {
                            m->list = append(m->list, cond {0, 0, true});
                        }
                        bits = 0;
                        result = c == '+';
                        start = i + 1;
                        wid = 1;
                        break;
                }
            }
        }
        return {m, nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    Matcher::operator T()
    {
        T result;
        result.verbose = this->verbose;
        result.quiet = this->quiet;
        result.enable = this->enable;
        result.list = this->list;
        result.dedup = this->dedup;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Matcher::operator==(const T& ref) const
    {
        if (verbose != ref.verbose) return false;
        if (quiet != ref.quiet) return false;
        if (enable != ref.enable) return false;
        if (list != ref.list) return false;
        if (dedup != ref.dedup) return false;
        return true;
    }

    std::ostream& Matcher::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << verbose;
        os << " " << quiet;
        os << " " << enable;
        os << " " << list;
        os << " " << dedup;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Matcher& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    atomicPointerDedup::operator T()
    {
        T result;
        result.p = this->p;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicPointerDedup::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        return true;
    }

    std::ostream& atomicPointerDedup::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicPointerDedup& value)
    {
        return value.PrintTo(os);
    }

    dedup* Load(struct atomicPointerDedup* p)
    {
        return (dedup*)(atomic::LoadPointer(& p->p));
    }

    bool CompareAndSwap(struct atomicPointerDedup* p, dedup* old, dedup* go_new)
    {
        return atomic::CompareAndSwapPointer(& p->p, unsafe::Pointer(old), unsafe::Pointer(go_new));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    cond::operator T()
    {
        T result;
        result.mask = this->mask;
        result.bits = this->bits;
        result.result = this->result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cond::operator==(const T& ref) const
    {
        if (mask != ref.mask) return false;
        if (bits != ref.bits) return false;
        if (result != ref.result) return false;
        return true;
    }

    std::ostream& cond::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mask;
        os << " " << bits;
        os << " " << result;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cond& value)
    {
        return value.PrintTo(os);
    }

    bool MarkerOnly(struct Matcher* m)
    {
        return ! m->verbose;
    }

    bool ShouldEnable(struct Matcher* m, uint64_t id)
    {
        if(m == nullptr)
        {
            return true;
        }
        return matchResult(gocpp::recv(m), id) == m->enable;
    }

    bool ShouldPrint(struct Matcher* m, uint64_t id)
    {
        if(m == nullptr || m->quiet)
        {
            return false;
        }
        return matchResult(gocpp::recv(m), id);
    }

    bool matchResult(struct Matcher* m, uint64_t id)
    {
        for(auto i = len(m->list) - 1; i >= 0; i--)
        {
            auto c = & m->list[i];
            if(id & c->mask == c->bits)
            {
                return c->result;
            }
        }
        return false;
    }

    bool FileLine(struct Matcher* m, Writer w, std::string file, int line)
    {
        if(m == nullptr)
        {
            return true;
        }
        return fileLine(gocpp::recv(m), w, file, line);
    }

    bool fileLine(struct Matcher* m, Writer w, std::string file, int line)
    {
        auto h = Hash(file, line);
        if(ShouldPrint(gocpp::recv(m), h))
        {
            if(MarkerOnly(gocpp::recv(m)))
            {
                PrintMarker(w, h);
            }
            else
            {
                printFileLine(w, h, file, line);
            }
        }
        return ShouldEnable(gocpp::recv(m), h);
    }

    gocpp::error printFileLine(Writer w, uint64_t h, std::string file, int line)
    {
        auto markerLen = 40;
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, markerLen + len(file) + 24);
        b = AppendMarker(b, h);
        b = appendFileLine(b, file, line);
        b = append(b, '\n');
        auto [gocpp_id_1, err] = Write(gocpp::recv(w), b);
        return err;
    }

    gocpp::slice<unsigned char> appendFileLine(gocpp::slice<unsigned char> dst, std::string file, int line)
    {
        dst = append(dst, file);
        dst = append(dst, ':');
        auto u = (unsigned int)(line);
        if(line < 0)
        {
            dst = append(dst, '-');
            u = - u;
        }
        gocpp::array<unsigned char, 24> buf = {};
        auto i = len(buf);
        for(; i == len(buf) || u > 0; )
        {
            i--;
            buf[i] = '0' + unsigned char(u % 10);
            u /= 10;
        }
        dst = append(dst, buf.make_slice(i));
        return dst;
    }

    bool Stack(struct Matcher* m, Writer w)
    {
        if(m == nullptr)
        {
            return true;
        }
        return stack(gocpp::recv(m), w);
    }

    bool stack(struct Matcher* m, Writer w)
    {
        auto maxStack = 16;
        gocpp::array<uintptr_t, maxStack> stk = {};
        auto n = runtime::Callers(2, stk.make_slice(0, ));
        if(n <= 1)
        {
            return false;
        }
        auto base = stk[0];
        for(auto [i, gocpp_ignored] : stk.make_slice(0, n))
        {
            stk[i] -= base;
        }
        auto h = Hash(stk.make_slice(0, n));
        if(ShouldPrint(gocpp::recv(m), h))
        {
            dedup* d = {};
            for(; ; )
            {
                d = Load(gocpp::recv(m->dedup));
                if(d != nullptr)
                {
                    break;
                }
                d = go_new(dedup);
                if(CompareAndSwap(gocpp::recv(m->dedup), nullptr, d))
                {
                    break;
                }
            }
            if(MarkerOnly(gocpp::recv(m)))
            {
                if(! seenLossy(gocpp::recv(d), h))
                {
                    PrintMarker(w, h);
                }
            }
            else
            {
                if(! seen(gocpp::recv(d), h))
                {
                    for(auto [i, gocpp_ignored] : stk.make_slice(0, n))
                    {
                        stk[i] += base;
                    }
                    printStack(w, h, stk.make_slice(1, n));
                }
            }
        }
        return ShouldEnable(gocpp::recv(m), h);
    }

    
    template<typename T>
    Writer::Writer(T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(const T& ref)
    {
        value.reset(new WriterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Writer::Writer(T* ptr)
    {
        value.reset(new WriterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Writer::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::tuple<int, gocpp::error> Writer::WriterImpl<T, StoreT>::vWrite(gocpp::slice<unsigned char>)
    {
        return Write(gocpp::PtrRecv<T, false>(value.get()));
    }

    std::tuple<int, gocpp::error> Write(const gocpp::PtrRecv<Writer, false>& self, gocpp::slice<unsigned char>)
    {
        return self.ptr->value->vWrite();
    }

    std::tuple<int, gocpp::error> Write(const gocpp::ObjRecv<Writer>& self, gocpp::slice<unsigned char>)
    {
        return self.obj.value->vWrite();
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value)
    {
        return value.PrintTo(os);
    }

    gocpp::error PrintMarker(Writer w, uint64_t h)
    {
        gocpp::array<unsigned char, 50> buf = {};
        auto b = AppendMarker(buf.make_slice(0, 0), h);
        b = append(b, '\n');
        auto [gocpp_id_3, err] = Write(gocpp::recv(w), b);
        return err;
    }

    gocpp::error printStack(Writer w, uint64_t h, gocpp::slice<uintptr_t> stk)
    {
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 2048);
        gocpp::array<unsigned char, 100> prefixBuf = {};
        auto prefix = AppendMarker(prefixBuf.make_slice(0, 0), h);
        auto frames = runtime::CallersFrames(stk);
        for(; ; )
        {
            auto [f, more] = Next(gocpp::recv(frames));
            buf = append(buf, prefix);
            buf = append(buf, Name(gocpp::recv(f.Func)));
            buf = append(buf, "()\n");
            buf = append(buf, prefix);
            buf = append(buf, '\t');
            buf = appendFileLine(buf, f.File, f.Line);
            buf = append(buf, '\n');
            if(! more)
            {
                break;
            }
        }
        buf = append(buf, prefix);
        buf = append(buf, '\n');
        auto [gocpp_id_5, err] = Write(gocpp::recv(w), buf);
        return err;
    }

    std::string Marker(uint64_t id)
    {
        return string(AppendMarker(nullptr, id));
    }

    gocpp::slice<unsigned char> AppendMarker(gocpp::slice<unsigned char> dst, uint64_t id)
    {
        auto prefix = "[bisect-match 0x";
        gocpp::array<unsigned char, len(prefix) + 16 + 1> buf = {};
        copy(buf.make_slice(0, ), prefix);
        for(auto i = 0; i < 16; i++)
        {
            buf[len(prefix) + i] = "0123456789abcdef"[id >> 60];
            id <<= 4;
        }
        buf[len(prefix) + 16] = ']';
        return append(dst, buf.make_slice(0, ));
    }

    std::tuple<std::string, uint64_t, bool> CutMarker(std::string line)
    {
        std::string short;
        uint64_t id;
        bool ok;
        auto prefix = "[bisect-match ";
        auto i = 0;
        for(; ; i++)
        {
            std::string short;
            uint64_t id;
            bool ok;
            if(i >= len(line) - len(prefix))
            {
                std::string short;
                uint64_t id;
                bool ok;
                return {line, 0, false};
            }
            if(line[i] == '[' && line.make_slice(i, i + len(prefix)) == prefix)
            {
                std::string short;
                uint64_t id;
                bool ok;
                break;
            }
        }
        auto j = i + len(prefix);
        for(; j < len(line) && line[j] != ']'; )
        {
            std::string short;
            uint64_t id;
            bool ok;
            j++;
        }
        if(j >= len(line))
        {
            std::string short;
            uint64_t id;
            bool ok;
            return {line, 0, false};
        }
        auto idstr = line.make_slice(i + len(prefix), j);
        if(len(idstr) >= 3 && idstr.make_slice(0, 2) == "0x")
        {
            std::string short;
            uint64_t id;
            bool ok;
            if(len(idstr) > 2 + 16)
            {
                std::string short;
                uint64_t id;
                bool ok;
                return {line, 0, false};
            }
            for(auto i = 2; i < len(idstr); i++)
            {
                std::string short;
                uint64_t id;
                bool ok;
                id <<= 4;
                //Go switch emulation
                {
                    auto c = idstr[i];
                    int conditionId = -1;
                    if('0' <= c && c <= '9') { conditionId = 0; }
                    else if('a' <= c && c <= 'f') { conditionId = 1; }
                    else if('A' <= c && c <= 'F') { conditionId = 2; }
                    switch(conditionId)
                    {
                        std::string short;
                        uint64_t id;
                        bool ok;
                        case 0:
                            id |= uint64_t(c - '0');
                            break;
                        case 1:
                            id |= uint64_t(c - 'a' + 10);
                            break;
                        case 2:
                            id |= uint64_t(c - 'A' + 10);
                            break;
                    }
                }
            }
        }
        else
        {
            std::string short;
            uint64_t id;
            bool ok;
            if(idstr == "" || len(idstr) > 64)
            {
                std::string short;
                uint64_t id;
                bool ok;
                return {line, 0, false};
            }
            for(auto i = 0; i < len(idstr); i++)
            {
                std::string short;
                uint64_t id;
                bool ok;
                id <<= 1;
                //Go switch emulation
                {
                    auto c = idstr[i];
                    auto condition = c;
                    int conditionId = -1;
                    else if(condition == '0') { conditionId = 0; }
                    else if(condition == '1') { conditionId = 1; }
                    switch(conditionId)
                    {
                        std::string short;
                        uint64_t id;
                        bool ok;
                        default:
                            return {line, 0, false};
                            break;
                        case 0:
                        case 1:
                            id |= uint64_t(c - '0');
                            break;
                    }
                }
            }
        }
        j++;
        if(i > 0 && line[i - 1] == ' ')
        {
            std::string short;
            uint64_t id;
            bool ok;
            i--;
        }
        else
        if(j < len(line) && line[j] == ' ')
        {
            std::string short;
            uint64_t id;
            bool ok;
            j++;
        }
        short = line.make_slice(0, i) + line.make_slice(j);
        return {short, id, true};
    }

    uint64_t Hash(gocpp::slice<go_any> data)
    {
        auto h = offset64;
        for(auto [_, v] : data)
        {
            //Go type switch emulation
            {
                const auto& gocpp_id_6 = gocpp::type_info(v);
                int conditionId = -1;
                else if(gocpp_id_6 == typeid(std::string)) { conditionId = 0; }
                else if(gocpp_id_6 == typeid(unsigned char)) { conditionId = 1; }
                else if(gocpp_id_6 == typeid(int)) { conditionId = 2; }
                else if(gocpp_id_6 == typeid(unsigned int)) { conditionId = 3; }
                else if(gocpp_id_6 == typeid(int32_t)) { conditionId = 4; }
                else if(gocpp_id_6 == typeid(uint32_t)) { conditionId = 5; }
                else if(gocpp_id_6 == typeid(int64_t)) { conditionId = 6; }
                else if(gocpp_id_6 == typeid(uint64_t)) { conditionId = 7; }
                else if(gocpp_id_6 == typeid(uintptr_t)) { conditionId = 8; }
                else if(gocpp_id_6 == typeid(gocpp::slice<std::string>)) { conditionId = 9; }
                else if(gocpp_id_6 == typeid(gocpp::slice<unsigned char>)) { conditionId = 10; }
                else if(gocpp_id_6 == typeid(gocpp::slice<int>)) { conditionId = 11; }
                else if(gocpp_id_6 == typeid(gocpp::slice<unsigned int>)) { conditionId = 12; }
                else if(gocpp_id_6 == typeid(gocpp::slice<int32_t>)) { conditionId = 13; }
                else if(gocpp_id_6 == typeid(gocpp::slice<uint32_t>)) { conditionId = 14; }
                else if(gocpp_id_6 == typeid(gocpp::slice<int64_t>)) { conditionId = 15; }
                else if(gocpp_id_6 == typeid(gocpp::slice<uint64_t>)) { conditionId = 16; }
                else if(gocpp_id_6 == typeid(gocpp::slice<uintptr_t>)) { conditionId = 17; }
                switch(conditionId)
                {
                    default:
                    {
                        auto v = v;
                        gocpp::panic("bisect.Hash: unexpected argument type");
                        break;
                    }
                    case 0:
                    {
                        std::string v = gocpp::any_cast<std::string>(v);
                        h = fnvString(h, v);
                        break;
                    }
                    case 1:
                    {
                        unsigned char v = gocpp::any_cast<unsigned char>(v);
                        h = fnv(h, v);
                        break;
                    }
                    case 2:
                    {
                        int v = gocpp::any_cast<int>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 3:
                    {
                        unsigned int v = gocpp::any_cast<unsigned int>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 4:
                    {
                        int32_t v = gocpp::any_cast<int32_t>(v);
                        h = fnvUint32(h, uint32_t(v));
                        break;
                    }
                    case 5:
                    {
                        uint32_t v = gocpp::any_cast<uint32_t>(v);
                        h = fnvUint32(h, v);
                        break;
                    }
                    case 6:
                    {
                        int64_t v = gocpp::any_cast<int64_t>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 7:
                    {
                        uint64_t v = gocpp::any_cast<uint64_t>(v);
                        h = fnvUint64(h, v);
                        break;
                    }
                    case 8:
                    {
                        uintptr_t v = gocpp::any_cast<uintptr_t>(v);
                        h = fnvUint64(h, uint64_t(v));
                        break;
                    }
                    case 9:
                    {
                        gocpp::slice<std::string> v = gocpp::any_cast<gocpp::slice<std::string>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvString(h, x);
                        }
                        break;
                    }
                    case 10:
                    {
                        gocpp::slice<unsigned char> v = gocpp::any_cast<gocpp::slice<unsigned char>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnv(h, x);
                        }
                        break;
                    }
                    case 11:
                    {
                        gocpp::slice<int> v = gocpp::any_cast<gocpp::slice<int>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                    case 12:
                    {
                        gocpp::slice<unsigned int> v = gocpp::any_cast<gocpp::slice<unsigned int>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                    case 13:
                    {
                        gocpp::slice<int32_t> v = gocpp::any_cast<gocpp::slice<int32_t>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint32(h, uint32_t(x));
                        }
                        break;
                    }
                    case 14:
                    {
                        gocpp::slice<uint32_t> v = gocpp::any_cast<gocpp::slice<uint32_t>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint32(h, x);
                        }
                        break;
                    }
                    case 15:
                    {
                        gocpp::slice<int64_t> v = gocpp::any_cast<gocpp::slice<int64_t>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                    case 16:
                    {
                        gocpp::slice<uint64_t> v = gocpp::any_cast<gocpp::slice<uint64_t>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint64(h, x);
                        }
                        break;
                    }
                    case 17:
                    {
                        gocpp::slice<uintptr_t> v = gocpp::any_cast<gocpp::slice<uintptr_t>>(v);
                        for(auto [_, x] : v)
                        {
                            h = fnvUint64(h, uint64_t(x));
                        }
                        break;
                    }
                }
            }
        }
        return h;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    parseError::operator T()
    {
        T result;
        result.text = this->text;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool parseError::operator==(const T& ref) const
    {
        if (text != ref.text) return false;
        return true;
    }

    std::ostream& parseError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << text;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct parseError& value)
    {
        return value.PrintTo(os);
    }

    std::string Error(struct parseError* e)
    {
        return e->text;
    }

    uint64_t fnv(uint64_t h, unsigned char x)
    {
        h ^= uint64_t(x);
        h *= prime64;
        return h;
    }

    uint64_t fnvString(uint64_t h, std::string x)
    {
        for(auto i = 0; i < len(x); i++)
        {
            h ^= uint64_t(x[i]);
            h *= prime64;
        }
        return h;
    }

    uint64_t fnvUint64(uint64_t h, uint64_t x)
    {
        for(auto i = 0; i < 8; i++)
        {
            h ^= x & 0xFF;
            x >>= 8;
            h *= prime64;
        }
        return h;
    }

    uint64_t fnvUint32(uint64_t h, uint32_t x)
    {
        for(auto i = 0; i < 4; i++)
        {
            h ^= uint64_t(x & 0xFF);
            x >>= 8;
            h *= prime64;
        }
        return h;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dedup::operator T()
    {
        T result;
        result.recent = this->recent;
        result.mu = this->mu;
        result.m = this->m;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dedup::operator==(const T& ref) const
    {
        if (recent != ref.recent) return false;
        if (mu != ref.mu) return false;
        if (m != ref.m) return false;
        return true;
    }

    std::ostream& dedup::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << recent;
        os << " " << mu;
        os << " " << m;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dedup& value)
    {
        return value.PrintTo(os);
    }

    bool seen(struct dedup* d, uint64_t h)
    {
        Lock(gocpp::recv(d->mu));
        if(d->m == nullptr)
        {
            d->m = gocpp::make(gocpp::Tag<gocpp::map<uint64_t, bool>>());
        }
        auto seen = d->m[h];
        d->m[h] = true;
        Unlock(gocpp::recv(d->mu));
        return seen;
    }

    bool seenLossy(struct dedup* d, uint64_t h)
    {
        auto cache = & d->recent[(unsigned int)(h) % (unsigned int)(len(d->recent))];
        for(auto i = 0; i < len(cache); i++)
        {
            if(atomic::LoadUint64(& cache[i]) == h)
            {
                return true;
            }
        }
        auto ch = offset64;
        for(auto [_, x] : cache)
        {
            ch = fnvUint64(ch, x);
        }
        atomic::StoreUint64(& cache[(unsigned int)(ch) % (unsigned int)(len(cache))], h);
        return false;
    }

}

