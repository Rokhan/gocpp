// generated by GoCpp from file '$(ImportDir)/runtime/netpoll_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/netpoll_windows.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/defs_windows.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/netpoll.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    net_op::operator T()
    {
        T result;
        result.o = this->o;
        result.pd = this->pd;
        result.mode = this->mode;
        result.errno = this->errno;
        result.qty = this->qty;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool net_op::operator==(const T& ref) const
    {
        if (o != ref.o) return false;
        if (pd != ref.pd) return false;
        if (mode != ref.mode) return false;
        if (errno != ref.errno) return false;
        if (qty != ref.qty) return false;
        return true;
    }

    std::ostream& net_op::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << o;
        os << " " << pd;
        os << " " << mode;
        os << " " << errno;
        os << " " << qty;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct net_op& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    overlappedEntry::operator T()
    {
        T result;
        result.key = this->key;
        result.op = this->op;
        result.internal = this->internal;
        result.qty = this->qty;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool overlappedEntry::operator==(const T& ref) const
    {
        if (key != ref.key) return false;
        if (op != ref.op) return false;
        if (internal != ref.internal) return false;
        if (qty != ref.qty) return false;
        return true;
    }

    std::ostream& overlappedEntry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << key;
        os << " " << op;
        os << " " << internal;
        os << " " << qty;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct overlappedEntry& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t iocphandle = _INVALID_HANDLE_VALUE;
    atomic::Uint32 netpollWakeSig = _INVALID_HANDLE_VALUE;
    void netpollinit()
    {
        iocphandle = stdcall4(_CreateIoCompletionPort, _INVALID_HANDLE_VALUE, 0, 0, _DWORD_MAX);
        if(iocphandle == 0)
        {
            println("runtime: CreateIoCompletionPort failed (errno=", getlasterror(), ")");
            go_throw("runtime: netpollinit failed");
        }
    }

    bool netpollIsPollDescriptor(uintptr_t fd)
    {
        return fd == iocphandle;
    }

    int32_t netpollopen(uintptr_t fd, struct pollDesc* pd)
    {
        if(stdcall4(_CreateIoCompletionPort, fd, iocphandle, uintptr_t(unsafe::Pointer(pd)), 0) == 0)
        {
            return int32_t(getlasterror());
        }
        return 0;
    }

    int32_t netpollclose(uintptr_t fd)
    {
        return 0;
    }

    void netpollarm(struct pollDesc* pd, int mode)
    {
        go_throw("runtime: unused");
    }

    void netpollBreak()
    {
        if(! rec::CompareAndSwap(gocpp::recv(netpollWakeSig), 0, 1))
        {
            return;
        }
        if(stdcall4(_PostQueuedCompletionStatus, iocphandle, 0, 0, 0) == 0)
        {
            println("runtime: netpoll: PostQueuedCompletionStatus failed (errno=", getlasterror(), ")");
            go_throw("runtime: netpoll: PostQueuedCompletionStatus failed");
        }
    }

    std::tuple<struct gList, int32_t> netpoll(int64_t delay)
    {
        gocpp::array<overlappedEntry, 64> entries = {};
        uint32_t wait = {};
        uint32_t qty = {};
        uint32_t flags = {};
        uint32_t n = {};
        uint32_t i = {};
        int32_t errno = {};
        net_op* op = {};
        gList toRun = {};
        auto mp = getg()->m;
        if(iocphandle == _INVALID_HANDLE_VALUE)
        {
            return {gList {}, 0};
        }
        if(delay < 0)
        {
            wait = _INFINITE;
        }
        else
        if(delay == 0)
        {
            wait = 0;
        }
        else
        if(delay < 1e6)
        {
            wait = 1;
        }
        else
        if(delay < 1e15)
        {
            wait = uint32_t(delay / 1e6);
        }
        else
        {
            wait = 1e9;
        }
        n = uint32_t(len(entries) / int(gomaxprocs));
        if(n < 8)
        {
            n = 8;
        }
        if(delay != 0)
        {
            mp->blocked = true;
        }
        if(stdcall6(_GetQueuedCompletionStatusEx, iocphandle, uintptr_t(unsafe::Pointer(& entries[0])), uintptr_t(n), uintptr_t(unsafe::Pointer(& n)), uintptr_t(wait), 0) == 0)
        {
            mp->blocked = false;
            errno = int32_t(getlasterror());
            if(errno == _WAIT_TIMEOUT)
            {
                return {gList {}, 0};
            }
            println("runtime: GetQueuedCompletionStatusEx failed (errno=", errno, ")");
            go_throw("runtime: netpoll failed");
        }
        mp->blocked = false;
        auto delta = int32_t(0);
        for(i = 0; i < n; i++)
        {
            op = entries[i].op;
            if(op != nullptr && op->pd == entries[i].key)
            {
                errno = 0;
                qty = 0;
                if(stdcall5(_WSAGetOverlappedResult, op->pd->fd, uintptr_t(unsafe::Pointer(op)), uintptr_t(unsafe::Pointer(& qty)), 0, uintptr_t(unsafe::Pointer(& flags))) == 0)
                {
                    errno = int32_t(getlasterror());
                }
                delta += handlecompletion(& toRun, op, errno, qty);
            }
            else
            {
                rec::Store(gocpp::recv(netpollWakeSig), 0);
                if(delay == 0)
                {
                    netpollBreak();
                }
            }
        }
        return {toRun, delta};
    }

    int32_t handlecompletion(struct gList* toRun, struct net_op* op, int32_t errno, uint32_t qty)
    {
        auto mode = op->mode;
        if(mode != 'r' && mode != 'w')
        {
            println("runtime: GetQueuedCompletionStatusEx returned invalid mode=", mode);
            go_throw("runtime: netpoll failed");
        }
        op->errno = errno;
        op->qty = qty;
        return netpollready(toRun, op->pd, mode);
    }

}

