// generated by GoCpp from file '$(ImportDir)/compress/zlib/reader.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/compress/zlib/reader.h"
#include "gocpp/support.h"

#include "golang/bufio/bufio.h"
#include "golang/compress/flate/inflate.h"
#include "golang/encoding/binary/binary.h"
#include "golang/errors/errors.h"
#include "golang/hash/adler32/adler32.h"
#include "golang/hash/hash.h"
#include "golang/io/io.h"

namespace golang::zlib
{
    gocpp::error ErrChecksum = errors::New("zlib: invalid checksum");
    gocpp::error ErrDictionary = errors::New("zlib: invalid dictionary");
    gocpp::error ErrHeader = errors::New("zlib: invalid header");
    
    template<typename T> requires gocpp::GoStruct<T>
    reader::operator T()
    {
        T result;
        result.r = this->r;
        result.decompressor = this->decompressor;
        result.digest = this->digest;
        result.err = this->err;
        result.scratch = this->scratch;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool reader::operator==(const T& ref) const
    {
        if (r != ref.r) return false;
        if (decompressor != ref.decompressor) return false;
        if (digest != ref.digest) return false;
        if (err != ref.err) return false;
        if (scratch != ref.scratch) return false;
        return true;
    }

    std::ostream& reader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << r;
        os << " " << decompressor;
        os << " " << digest;
        os << " " << err;
        os << " " << scratch;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct reader& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Resetter::Resetter(T& ref)
    {
        value.reset(new ResetterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Resetter::Resetter(const T& ref)
    {
        value.reset(new ResetterImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Resetter::Resetter(T* ptr)
    {
        value.reset(new ResetterImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Resetter::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::error Resetter::ResetterImpl<T, StoreT>::vReset(io::Reader r, gocpp::slice<unsigned char> dict)
    {
        return Reset(gocpp::PtrRecv<T, false>(value.get()), r, dict);
    }

    gocpp::error Reset(const gocpp::PtrRecv<Resetter, false>& self, io::Reader r, gocpp::slice<unsigned char> dict)
    {
        return self.ptr->value->vReset(r, dict);
    }

    gocpp::error Reset(const gocpp::ObjRecv<Resetter>& self, io::Reader r, gocpp::slice<unsigned char> dict)
    {
        return self.obj.value->vReset(r, dict);
    }

    std::ostream& operator<<(std::ostream& os, const struct Resetter& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<io::ReadCloser, gocpp::error> NewReader(io::Reader r)
    {
        return NewReaderDict(r, nullptr);
    }

    std::tuple<io::ReadCloser, gocpp::error> NewReaderDict(io::Reader r, gocpp::slice<unsigned char> dict)
    {
        auto z = go_new(reader);
        auto err = Reset(gocpp::recv(z), r, dict);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        return {z, nullptr};
    }

    std::tuple<int, gocpp::error> Read(struct reader* z, gocpp::slice<unsigned char> p)
    {
        if(z->err != nullptr)
        {
            return {0, z->err};
        }
        int n = {};
        std::tie(n, z->err) = Read(gocpp::recv(z->decompressor), p);
        Write(gocpp::recv(z->digest), p.make_slice(0, n));
        if(z->err != io::go_EOF)
        {
            return {n, z->err};
        }
        if(auto [gocpp_id_1, err] = io::ReadFull(z->r, z->scratch.make_slice(0, 4)); err != nullptr)
        {
            if(err == io::go_EOF)
            {
                err = io::ErrUnexpectedEOF;
            }
            z->err = err;
            return {n, z->err};
        }
        auto checksum = Uint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 4));
        if(checksum != Sum32(gocpp::recv(z->digest)))
        {
            z->err = ErrChecksum;
            return {n, z->err};
        }
        return {n, io::go_EOF};
    }

    gocpp::error Close(struct reader* z)
    {
        if(z->err != nullptr && z->err != io::go_EOF)
        {
            return z->err;
        }
        z->err = Close(gocpp::recv(z->decompressor));
        return z->err;
    }

    gocpp::error Reset(struct reader* z, io::Reader r, gocpp::slice<unsigned char> dict)
    {
        *z = gocpp::Init<reader>([](reader& x) { x.decompressor = z->decompressor; });
        if(auto [fr, ok] = gocpp::getValue<flate::Reader>(r); ok)
        {
            z->r = fr;
        }
        else
        {
            z->r = bufio::NewReader(r);
        }
        std::tie(gocpp_id_2, z->err) = io::ReadFull(z->r, z->scratch.make_slice(0, 2));
        if(z->err != nullptr)
        {
            if(z->err == io::go_EOF)
            {
                z->err = io::ErrUnexpectedEOF;
            }
            return z->err;
        }
        auto h = Uint16(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 2));
        if((z->scratch[0] & 0x0f != zlibDeflate) || ((z->scratch[0] >> 4) > zlibMaxWindow) || (h % 31 != 0))
        {
            z->err = ErrHeader;
            return z->err;
        }
        auto haveDict = z->scratch[1] & 0x20 != 0;
        if(haveDict)
        {
            std::tie(gocpp_id_3, z->err) = io::ReadFull(z->r, z->scratch.make_slice(0, 4));
            if(z->err != nullptr)
            {
                if(z->err == io::go_EOF)
                {
                    z->err = io::ErrUnexpectedEOF;
                }
                return z->err;
            }
            auto checksum = Uint32(gocpp::recv(binary::BigEndian), z->scratch.make_slice(0, 4));
            if(checksum != adler32::Checksum(dict))
            {
                z->err = ErrDictionary;
                return z->err;
            }
        }
        if(z->decompressor == nullptr)
        {
            if(haveDict)
            {
                z->decompressor = flate::NewReaderDict(z->r, dict);
            }
            else
            {
                z->decompressor = flate::NewReader(z->r);
            }
        }
        else
        {
            Reset(gocpp::recv(gocpp::getValue<flate::Resetter>(z->decompressor)), z->r, dict);
        }
        z->digest = adler32::New();
        return nullptr;
    }

}

