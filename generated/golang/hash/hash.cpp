// generated by GoCpp from file '$(ImportDir)/hash/hash.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/hash/hash.h"
#include "gocpp/support.h"

#include "golang/io/io.h"

// Package hash provides interfaces for hash functions.
namespace golang::hash
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Hash is the common interface implemented by all hash functions.
    //
    // Hash implementations in the standard library (e.g. [hash/crc32] and
    // [crypto/sha256]) implement the [encoding.BinaryMarshaler] and
    // [encoding.BinaryUnmarshaler] interfaces. Marshaling a hash implementation
    // allows its internal state to be saved and used for additional processing
    // later, without having to re-write the data previously written to the hash.
    // The hash state may contain portions of the input in its original form,
    // which users are expected to handle for any possible security implications.
    //
    // Compatibility: Any future changes to hash or crypto packages will endeavor
    // to maintain compatibility with state encoded using previous versions.
    // That is, any released versions of the packages should be able to
    // decode data written with any previously released version,
    // subject to issues such as security fixes.
    // See the Go compatibility document for background: https://golang.org/doc/go1compat
    
    template<typename T>
    Hash::Hash(T& ref)
    {
        value.reset(new HashImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash::Hash(const T& ref)
    {
        value.reset(new HashImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash::Hash(T* ptr)
    {
        value.reset(new HashImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Hash::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::slice<unsigned char> Hash::HashImpl<T, StoreT>::vSum(gocpp::slice<unsigned char> b)
    {
        return rec::Sum(gocpp::PtrRecv<T, false>(value.get()), b);
    }
    template<typename T, typename StoreT>
    void Hash::HashImpl<T, StoreT>::vReset()
    {
        return rec::Reset(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Hash::HashImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Hash::HashImpl<T, StoreT>::vBlockSize()
    {
        return rec::BlockSize(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        gocpp::slice<unsigned char> Sum(const gocpp::PtrRecv<struct Hash, false>& self, gocpp::slice<unsigned char> b)
        {
            return self.ptr->value->vSum(b);
        }

        gocpp::slice<unsigned char> Sum(const gocpp::ObjRecv<struct Hash>& self, gocpp::slice<unsigned char> b)
        {
            return self.obj.value->vSum(b);
        }

        void Reset(const gocpp::PtrRecv<struct Hash, false>& self)
        {
            return self.ptr->value->vReset();
        }

        void Reset(const gocpp::ObjRecv<struct Hash>& self)
        {
            return self.obj.value->vReset();
        }

        int Size(const gocpp::PtrRecv<struct Hash, false>& self)
        {
            return self.ptr->value->vSize();
        }

        int Size(const gocpp::ObjRecv<struct Hash>& self)
        {
            return self.obj.value->vSize();
        }

        int BlockSize(const gocpp::PtrRecv<struct Hash, false>& self)
        {
            return self.ptr->value->vBlockSize();
        }

        int BlockSize(const gocpp::ObjRecv<struct Hash>& self)
        {
            return self.obj.value->vBlockSize();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Hash& value)
    {
        return value.PrintTo(os);
    }

    // Hash32 is the common interface implemented by all 32-bit hash functions.
    
    template<typename T>
    Hash32::Hash32(T& ref)
    {
        value.reset(new Hash32Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash32::Hash32(const T& ref)
    {
        value.reset(new Hash32Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash32::Hash32(T* ptr)
    {
        value.reset(new Hash32Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Hash32::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint32_t Hash32::Hash32Impl<T, StoreT>::vSum32()
    {
        return rec::Sum32(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        uint32_t Sum32(const gocpp::PtrRecv<struct Hash32, false>& self)
        {
            return self.ptr->value->vSum32();
        }

        uint32_t Sum32(const gocpp::ObjRecv<struct Hash32>& self)
        {
            return self.obj.value->vSum32();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Hash32& value)
    {
        return value.PrintTo(os);
    }

    // Hash64 is the common interface implemented by all 64-bit hash functions.
    
    template<typename T>
    Hash64::Hash64(T& ref)
    {
        value.reset(new Hash64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash64::Hash64(const T& ref)
    {
        value.reset(new Hash64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash64::Hash64(T* ptr)
    {
        value.reset(new Hash64Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Hash64::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint64_t Hash64::Hash64Impl<T, StoreT>::vSum64()
    {
        return rec::Sum64(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        uint64_t Sum64(const gocpp::PtrRecv<struct Hash64, false>& self)
        {
            return self.ptr->value->vSum64();
        }

        uint64_t Sum64(const gocpp::ObjRecv<struct Hash64>& self)
        {
            return self.obj.value->vSum64();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Hash64& value)
    {
        return value.PrintTo(os);
    }

}

