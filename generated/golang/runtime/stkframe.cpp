// generated by GoCpp from file '$(ImportDir)/runtime/stkframe.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/stkframe.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A stkframe holds information about a single physical stack frame.
    
    template<typename T> requires gocpp::GoStruct<T>
    stkframe::operator T()
    {
        T result;
        result.fn = this->fn;
        result.pc = this->pc;
        result.continpc = this->continpc;
        result.lr = this->lr;
        result.sp = this->sp;
        result.fp = this->fp;
        result.varp = this->varp;
        result.argp = this->argp;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool stkframe::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (pc != ref.pc) return false;
        if (continpc != ref.continpc) return false;
        if (lr != ref.lr) return false;
        if (sp != ref.sp) return false;
        if (fp != ref.fp) return false;
        if (varp != ref.varp) return false;
        if (argp != ref.argp) return false;
        return true;
    }

    std::ostream& stkframe::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << pc;
        os << " " << continpc;
        os << " " << lr;
        os << " " << sp;
        os << " " << fp;
        os << " " << varp;
        os << " " << argp;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct stkframe& value)
    {
        return value.PrintTo(os);
    }

    // reflectMethodValue is a partial duplicate of reflect.makeFuncImpl
    // and reflect.methodValue.
    
    template<typename T> requires gocpp::GoStruct<T>
    reflectMethodValue::operator T()
    {
        T result;
        result.fn = this->fn;
        result.stack = this->stack;
        result.argLen = this->argLen;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool reflectMethodValue::operator==(const T& ref) const
    {
        if (fn != ref.fn) return false;
        if (stack != ref.stack) return false;
        if (argLen != ref.argLen) return false;
        return true;
    }

    std::ostream& reflectMethodValue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fn;
        os << " " << stack;
        os << " " << argLen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct reflectMethodValue& value)
    {
        return value.PrintTo(os);
    }

    // argBytes returns the argument frame size for a call to frame.fn.
    uintptr_t rec::argBytes(struct stkframe* frame)
    {
        if(frame->fn.args != abi::ArgsSizeUnknown)
        {
            return uintptr_t(frame->fn.args);
        }
        auto [argMap, gocpp_id_1] = rec::argMapInternal(gocpp::recv(frame));
        return uintptr_t(argMap.n) * goarch::PtrSize;
    }

    // argMapInternal is used internally by stkframe to fetch special
    // argument maps.
    //
    // argMap.n is always populated with the size of the argument map.
    //
    // argMap.bytedata is only populated for dynamic argument maps (used
    // by reflect). If the caller requires the argument map, it should use
    // this if non-nil, and otherwise fetch the argument map using the
    // current PC.
    //
    // hasReflectStackObj indicates that this frame also has a reflect
    // function stack object, which the caller must synthesize.
    std::tuple<struct bitvector, bool> rec::argMapInternal(struct stkframe* frame)
    {
        struct bitvector argMap;
        bool hasReflectStackObj;
        auto f = frame->fn;
        if(f.args != abi::ArgsSizeUnknown)
        {
            argMap.n = f.args / goarch::PtrSize;
            return {argMap, hasReflectStackObj};
        }
        //Go switch emulation
        {
            auto condition = funcname(f);
            int conditionId = -1;
            if(condition == "reflect.makeFuncStub"s) { conditionId = 0; }
            else if(condition == "reflect.methodValueCall"s) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    auto arg0 = frame->sp + sys::MinFrameSize;
                    auto minSP = frame->fp;
                    if(! usesLR)
                    {
                        minSP -= goarch::PtrSize;
                    }
                    if(arg0 >= minSP)
                    {
                        if(frame->pc != rec::entry(gocpp::recv(f)))
                        {
                            print("runtime: confused by "s, funcname(f), ": no frame (sp="s, hex(frame->sp), " fp="s, hex(frame->fp), ") at entry+"s, hex(frame->pc - rec::entry(gocpp::recv(f))), "\n"s);
                            go_throw("reflect mismatch"s);
                        }
                        return {bitvector {}, false};
                    }
                    hasReflectStackObj = true;
                    auto mv = *(reflectMethodValue**)(unsafe::Pointer(arg0));
                    auto retValid = *(bool*)(unsafe::Pointer(arg0 + 4 * goarch::PtrSize));
                    if(mv->fn != rec::entry(gocpp::recv(f)))
                    {
                        print("runtime: confused by "s, funcname(f), "\n"s);
                        go_throw("reflect mismatch"s);
                    }
                    argMap = *mv->stack;
                    if(! retValid)
                    {
                        auto n = int32_t((mv->argLen &^ (goarch::PtrSize - 1)) / goarch::PtrSize);
                        if(n < argMap.n)
                        {
                            argMap.n = n;
                        }
                    }
                    break;
            }
        }
        return {argMap, hasReflectStackObj};
    }

    // getStackMap returns the locals and arguments live pointer maps, and
    // stack object list for frame.
    std::tuple<struct bitvector, struct bitvector, gocpp::slice<stackObjectRecord>> rec::getStackMap(struct stkframe* frame, bool debug)
    {
        struct bitvector locals;
        struct bitvector args;
        gocpp::slice<stackObjectRecord> objs;
        auto targetpc = frame->continpc;
        if(targetpc == 0)
        {
            return {locals, args, objs};
        }
        auto f = frame->fn;
        auto pcdata = int32_t(- 1);
        if(targetpc != rec::entry(gocpp::recv(f)))
        {
            targetpc--;
            pcdata = pcdatavalue(f, abi::PCDATA_StackMapIndex, targetpc);
        }
        if(pcdata == - 1)
        {
            pcdata = 0;
        }
        auto size = frame->varp - frame->sp;
        uintptr_t minsize = {};
        //Go switch emulation
        {
            auto condition = goarch::ArchFamily;
            int conditionId = -1;
            if(condition == goarch::ARM64) { conditionId = 0; }
            switch(conditionId)
            {
                case 0:
                    minsize = sys::StackAlign;
                    break;
                default:
                    minsize = sys::MinFrameSize;
                    break;
            }
        }
        if(size > minsize)
        {
            auto stackid = pcdata;
            auto stkmap = (stackmap*)(funcdata(f, abi::FUNCDATA_LocalsPointerMaps));
            if(stkmap == nullptr || stkmap->n <= 0)
            {
                print("runtime: frame "s, funcname(f), " untyped locals "s, hex(frame->varp - size), "+"s, hex(size), "\n"s);
                go_throw("missing stackmap"s);
            }
            if(stkmap->nbit > 0)
            {
                if(stackid < 0 || stackid >= stkmap->n)
                {
                    print("runtime: pcdata is "s, stackid, " and "s, stkmap->n, " locals stack map entries for "s, funcname(f), " (targetpc="s, hex(targetpc), ")\n"s);
                    go_throw("bad symbol table"s);
                }
                locals = stackmapdata(stkmap, stackid);
                if(stackDebug >= 3 && debug)
                {
                    print("      locals "s, stackid, "/"s, stkmap->n, " "s, locals.n, " words "s, locals.bytedata, "\n"s);
                }
            }
            else
            if(stackDebug >= 3 && debug)
            {
                print("      no locals to adjust\n"s);
            }
        }
        // Arguments. First fetch frame size and special-case argument maps.
        bool isReflect = {};
        std::tie(args, isReflect) = rec::argMapInternal(gocpp::recv(frame));
        if(args.n > 0 && args.bytedata == nullptr)
        {
            auto stackmap = (stackmap*)(funcdata(f, abi::FUNCDATA_ArgsPointerMaps));
            if(stackmap == nullptr || stackmap->n <= 0)
            {
                print("runtime: frame "s, funcname(f), " untyped args "s, hex(frame->argp), "+"s, hex(args.n * goarch::PtrSize), "\n"s);
                go_throw("missing stackmap"s);
            }
            if(pcdata < 0 || pcdata >= stackmap->n)
            {
                print("runtime: pcdata is "s, pcdata, " and "s, stackmap->n, " args stack map entries for "s, funcname(f), " (targetpc="s, hex(targetpc), ")\n"s);
                go_throw("bad symbol table"s);
            }
            if(stackmap->nbit == 0)
            {
                args.n = 0;
            }
            else
            {
                args = stackmapdata(stackmap, pcdata);
            }
        }
        if((GOARCH == "amd64"s || GOARCH == "arm64"s || GOARCH == "loong64"s || GOARCH == "ppc64"s || GOARCH == "ppc64le"s || GOARCH == "riscv64"s) && gocpp::Sizeof<abi::RegArgs>() > 0 && isReflect)
        {
            objs = methodValueCallFrameObjs.make_slice(0);
        }
        else
        {
            auto p = funcdata(f, abi::FUNCDATA_StackObjects);
            if(p != nullptr)
            {
                auto n = *(uintptr_t*)(p);
                p = add(p, goarch::PtrSize);
                auto r0 = (stackObjectRecord*)(noescape(p));
                objs = unsafe::Slice(r0, int(n));
            }
        }
        return {locals, args, objs};
    }

    gocpp::array<stackObjectRecord, 1> methodValueCallFrameObjs;
    void stkobjinit()
    {
        go_any abiRegArgsEface = abi::RegArgs {};
        auto abiRegArgsType = efaceOf(& abiRegArgsEface)->_type;
        if(abiRegArgsType->Kind_ & kindGCProg != 0)
        {
            go_throw("abiRegArgsType needs GC Prog, update methodValueCallFrameObjs"s);
        }
        auto ptr = uintptr_t(unsafe::Pointer(& methodValueCallFrameObjs[0]));
        moduledata* mod = {};
        for(auto datap = & firstmoduledata; datap != nullptr; datap = datap->next)
        {
            if(datap->gofunc <= ptr && ptr < datap->end)
            {
                mod = datap;
                break;
            }
        }
        if(mod == nullptr)
        {
            go_throw("methodValueCallFrameObjs is not in a module"s);
        }
        methodValueCallFrameObjs[0] = gocpp::Init<stackObjectRecord>([=](auto& x) {
            x.off = - int32_t(alignUp(abiRegArgsType->Size_, 8));
            x.size = int32_t(abiRegArgsType->Size_);
            x._ptrdata = int32_t(abiRegArgsType->PtrBytes);
            x.gcdataoff = uint32_t(uintptr_t(unsafe::Pointer(abiRegArgsType->GCData)) - mod->rodata);
        });
    }

}

