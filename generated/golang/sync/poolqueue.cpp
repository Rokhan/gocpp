// generated by GoCpp from file '$(ImportDir)/sync/poolqueue.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/poolqueue.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/atomic/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    template<typename T> requires gocpp::GoStruct<T>
    poolDequeue::operator T()
    {
        T result;
        result.headTail = this->headTail;
        result.vals = this->vals;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolDequeue::operator==(const T& ref) const
    {
        if (headTail != ref.headTail) return false;
        if (vals != ref.vals) return false;
        return true;
    }

    std::ostream& poolDequeue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << headTail;
        os << " " << vals;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolDequeue& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    eface::operator T()
    {
        T result;
        result.typ = this->typ;
        result.val = this->val;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool eface::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (val != ref.val) return false;
        return true;
    }

    std::ostream& eface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << val;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct eface& value)
    {
        return value.PrintTo(os);
    }

    struct gocpp_id_0
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    std::tuple<uint32_t, uint32_t> unpack(struct poolDequeue* d, uint64_t ptrs)
    {
        uint32_t head;
        uint32_t tail;
        auto mask = (1 << dequeueBits) - 1;
        head = uint32_t((ptrs >> dequeueBits) & mask);
        tail = uint32_t(ptrs & mask);
        return {head, tail};
    }

    uint64_t pack(struct poolDequeue* d, uint32_t head, uint32_t tail)
    {
        auto mask = (1 << dequeueBits) - 1;
        return (uint64_t(head) << dequeueBits) | uint64_t(tail & mask);
    }

    bool pushHead(struct poolDequeue* d, go_any val)
    {
        auto ptrs = Load(gocpp::recv(d->headTail));
        auto [head, tail] = unpack(gocpp::recv(d), ptrs);
        if((tail + uint32_t(len(d->vals))) & ((1 << dequeueBits) - 1) == head)
        {
            return false;
        }
        auto slot = & d->vals[head & uint32_t(len(d->vals) - 1)];
        auto typ = atomic::LoadPointer(& slot->typ);
        if(typ != nullptr)
        {
            return false;
        }
        if(val == nullptr)
        {
            val = dequeueNil(nullptr);
        }
        *(go_any*)(unsafe::Pointer(slot)) = val;
        Add(gocpp::recv(d->headTail), 1 << dequeueBits);
        return true;
    }

    std::tuple<go_any, bool> popHead(struct poolDequeue* d)
    {
        eface* slot = {};
        for(; ; )
        {
            auto ptrs = Load(gocpp::recv(d->headTail));
            auto [head, tail] = unpack(gocpp::recv(d), ptrs);
            if(tail == head)
            {
                return {nullptr, false};
            }
            head--;
            auto ptrs2 = pack(gocpp::recv(d), head, tail);
            if(CompareAndSwap(gocpp::recv(d->headTail), ptrs, ptrs2))
            {
                slot = & d->vals[head & uint32_t(len(d->vals) - 1)];
                break;
            }
        }
        auto val = *(go_any*)(unsafe::Pointer(slot));
        if(val == dequeueNil(nullptr))
        {
            val = nullptr;
        }
        *slot = eface {};
        return {val, true};
    }

    std::tuple<go_any, bool> popTail(struct poolDequeue* d)
    {
        eface* slot = {};
        for(; ; )
        {
            auto ptrs = Load(gocpp::recv(d->headTail));
            auto [head, tail] = unpack(gocpp::recv(d), ptrs);
            if(tail == head)
            {
                return {nullptr, false};
            }
            auto ptrs2 = pack(gocpp::recv(d), head, tail + 1);
            if(CompareAndSwap(gocpp::recv(d->headTail), ptrs, ptrs2))
            {
                slot = & d->vals[tail & uint32_t(len(d->vals) - 1)];
                break;
            }
        }
        auto val = *(go_any*)(unsafe::Pointer(slot));
        if(val == dequeueNil(nullptr))
        {
            val = nullptr;
        }
        slot->val = nullptr;
        atomic::StorePointer(& slot->typ, nullptr);
        return {val, true};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    poolChain::operator T()
    {
        T result;
        result.head = this->head;
        result.tail = this->tail;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolChain::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        if (tail != ref.tail) return false;
        return true;
    }

    std::ostream& poolChain::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolChain& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    poolChainElt::operator T()
    {
        T result;
        result.next = this->next;
        result.prev = this->prev;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool poolChainElt::operator==(const T& ref) const
    {
        if (next != ref.next) return false;
        if (prev != ref.prev) return false;
        return true;
    }

    std::ostream& poolChainElt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << " " << prev;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolChainElt& value)
    {
        return value.PrintTo(os);
    }

    void storePoolChainElt(poolChainElt** pp, poolChainElt* v)
    {
        atomic::StorePointer((unsafe::Pointer*)(unsafe::Pointer(pp)), unsafe::Pointer(v));
    }

    poolChainElt* loadPoolChainElt(poolChainElt** pp)
    {
        return (poolChainElt*)(atomic::LoadPointer((unsafe::Pointer*)(unsafe::Pointer(pp))));
    }

    void pushHead(struct poolChain* c, go_any val)
    {
        auto d = c->head;
        if(d == nullptr)
        {
            auto initSize = 8;
            d = go_new(poolChainElt);
            d->vals = gocpp::make(gocpp::Tag<gocpp::slice<eface>>(), initSize);
            c->head = d;
            storePoolChainElt(& c->tail, d);
        }
        if(pushHead(gocpp::recv(d), val))
        {
            return;
        }
        auto newSize = len(d->vals) * 2;
        if(newSize >= dequeueLimit)
        {
            newSize = dequeueLimit;
        }
        auto d2 = gocpp::InitPtr<poolChainElt>([](poolChainElt& x) { x.prev = d; });
        d2->vals = gocpp::make(gocpp::Tag<gocpp::slice<eface>>(), newSize);
        c->head = d2;
        storePoolChainElt(& d->next, d2);
        pushHead(gocpp::recv(d2), val);
    }

    std::tuple<go_any, bool> popHead(struct poolChain* c)
    {
        auto d = c->head;
        for(; d != nullptr; )
        {
            if(auto [val, ok] = popHead(gocpp::recv(d)); ok)
            {
                return {val, ok};
            }
            d = loadPoolChainElt(& d->prev);
        }
        return {nullptr, false};
    }

    std::tuple<go_any, bool> popTail(struct poolChain* c)
    {
        auto d = loadPoolChainElt(& c->tail);
        if(d == nullptr)
        {
            return {nullptr, false};
        }
        for(; ; )
        {
            auto d2 = loadPoolChainElt(& d->next);
            if(auto [val, ok] = popTail(gocpp::recv(d)); ok)
            {
                return {val, ok};
            }
            if(d2 == nullptr)
            {
                return {nullptr, false};
            }
            if(atomic::CompareAndSwapPointer((unsafe::Pointer*)(unsafe::Pointer(& c->tail)), unsafe::Pointer(d), unsafe::Pointer(d2)))
            {
                storePoolChainElt(& d2->prev, nullptr);
            }
            d = d2;
        }
    }

}

