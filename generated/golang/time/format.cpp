// generated by GoCpp from file '$(ImportDir)/time/format.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/format.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/time/format_rfc3339.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::time
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    // Handy time stamps.
    gocpp::string Layout = "01/02 03:04:05PM '06 -0700"_s;
    gocpp::string ANSIC = "Mon Jan _2 15:04:05 2006"_s;
    gocpp::string UnixDate = "Mon Jan _2 15:04:05 MST 2006"_s;
    gocpp::string RubyDate = "Mon Jan 02 15:04:05 -0700 2006"_s;
    gocpp::string RFC822 = "02 Jan 06 15:04 MST"_s;
    gocpp::string RFC822Z = "02 Jan 06 15:04 -0700"_s;
    gocpp::string RFC850 = "Monday, 02-Jan-06 15:04:05 MST"_s;
    gocpp::string RFC1123 = "Mon, 02 Jan 2006 15:04:05 MST"_s;
    gocpp::string RFC1123Z = "Mon, 02 Jan 2006 15:04:05 -0700"_s;
    gocpp::string RFC3339 = "2006-01-02T15:04:05Z07:00"_s;
    gocpp::string RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"_s;
    gocpp::string Kitchen = "3:04PM"_s;
    gocpp::string Stamp = "Jan _2 15:04:05"_s;
    gocpp::string StampMilli = "Jan _2 15:04:05.000"_s;
    gocpp::string StampMicro = "Jan _2 15:04:05.000000"_s;
    gocpp::string StampNano = "Jan _2 15:04:05.000000000"_s;
    gocpp::string DateTime = "2006-01-02 15:04:05"_s;
    gocpp::string DateOnly = "2006-01-02"_s;
    gocpp::string TimeOnly = "15:04:05"_s;
    int gocpp_id_0 = 0;
    // std0x records the std values for "01", "02", ..., "06".
    gocpp::array<int, 6> std0x = gocpp::array<int, 6> {stdZeroMonth, stdZeroDay, stdZeroHour12, stdZeroMinute, stdZeroSecond, stdYear};
    // startsWithLowerCase reports whether the string has a lower-case letter at the beginning.
    // Its purpose is to prevent matching strings like "Month" when looking for "Mon".
    bool startsWithLowerCase(gocpp::string str)
    {
        if(len(str) == 0)
        {
            return false;
        }
        auto c = str[0];
        return 'a' <= c && c <= 'z';
    }

    // nextStdChunk finds the first occurrence of a std string in
    // layout and returns the text before, the std string, and the text after.
    std::tuple<gocpp::string, int, gocpp::string> nextStdChunk(gocpp::string layout)
    {
        gocpp::string prefix;
        int std;
        gocpp::string suffix;
        for(auto i = 0; i < len(layout); i++)
        {
            //Go switch emulation
            {
                auto c = int(layout[i]);
                auto condition = c;
                int conditionId = -1;
                if(condition == 'J') { conditionId = 0; }
                else if(condition == 'M') { conditionId = 1; }
                else if(condition == '0') { conditionId = 2; }
                else if(condition == '1') { conditionId = 3; }
                else if(condition == '2') { conditionId = 4; }
                else if(condition == '_') { conditionId = 5; }
                else if(condition == '3') { conditionId = 6; }
                else if(condition == '4') { conditionId = 7; }
                else if(condition == '5') { conditionId = 8; }
                else if(condition == 'P') { conditionId = 9; }
                else if(condition == 'p') { conditionId = 10; }
                else if(condition == '-') { conditionId = 11; }
                else if(condition == 'Z') { conditionId = 12; }
                else if(condition == '.') { conditionId = 13; }
                else if(condition == ',') { conditionId = 14; }
                switch(conditionId)
                {
                    case 0:
                        if(len(layout) >= i + 3 && layout.make_slice(i, i + 3) == "Jan"_s)
                        {
                            if(len(layout) >= i + 7 && layout.make_slice(i, i + 7) == "January"_s)
                            {
                                return {layout.make_slice(0, i), stdLongMonth, layout.make_slice(i + 7)};
                            }
                            if(! startsWithLowerCase(layout.make_slice(i + 3)))
                            {
                                return {layout.make_slice(0, i), stdMonth, layout.make_slice(i + 3)};
                            }
                        }
                        break;
                    case 1:
                        if(len(layout) >= i + 3)
                        {
                            if(layout.make_slice(i, i + 3) == "Mon"_s)
                            {
                                if(len(layout) >= i + 6 && layout.make_slice(i, i + 6) == "Monday"_s)
                                {
                                    return {layout.make_slice(0, i), stdLongWeekDay, layout.make_slice(i + 6)};
                                }
                                if(! startsWithLowerCase(layout.make_slice(i + 3)))
                                {
                                    return {layout.make_slice(0, i), stdWeekDay, layout.make_slice(i + 3)};
                                }
                            }
                            if(layout.make_slice(i, i + 3) == "MST"_s)
                            {
                                return {layout.make_slice(0, i), stdTZ, layout.make_slice(i + 3)};
                            }
                        }
                        break;
                    case 2:
                        if(len(layout) >= i + 2 && '1' <= layout[i + 1] && layout[i + 1] <= '6')
                        {
                            return {layout.make_slice(0, i), std0x[layout[i + 1] - '1'], layout.make_slice(i + 2)};
                        }
                        if(len(layout) >= i + 3 && layout[i + 1] == '0' && layout[i + 2] == '2')
                        {
                            return {layout.make_slice(0, i), stdZeroYearDay, layout.make_slice(i + 3)};
                        }
                        break;
                    case 3:
                        if(len(layout) >= i + 2 && layout[i + 1] == '5')
                        {
                            return {layout.make_slice(0, i), stdHour, layout.make_slice(i + 2)};
                        }
                        return {layout.make_slice(0, i), stdNumMonth, layout.make_slice(i + 1)};
                        break;
                    case 4:
                        if(len(layout) >= i + 4 && layout.make_slice(i, i + 4) == "2006"_s)
                        {
                            return {layout.make_slice(0, i), stdLongYear, layout.make_slice(i + 4)};
                        }
                        return {layout.make_slice(0, i), stdDay, layout.make_slice(i + 1)};
                        break;
                    case 5:
                        if(len(layout) >= i + 2 && layout[i + 1] == '2')
                        {
                            if(len(layout) >= i + 5 && layout.make_slice(i + 1, i + 5) == "2006"_s)
                            {
                                return {layout.make_slice(0, i + 1), stdLongYear, layout.make_slice(i + 5)};
                            }
                            return {layout.make_slice(0, i), stdUnderDay, layout.make_slice(i + 2)};
                        }
                        if(len(layout) >= i + 3 && layout[i + 1] == '_' && layout[i + 2] == '2')
                        {
                            return {layout.make_slice(0, i), stdUnderYearDay, layout.make_slice(i + 3)};
                        }
                        break;
                    case 6:
                        return {layout.make_slice(0, i), stdHour12, layout.make_slice(i + 1)};
                        break;
                    case 7:
                        return {layout.make_slice(0, i), stdMinute, layout.make_slice(i + 1)};
                        break;
                    case 8:
                        return {layout.make_slice(0, i), stdSecond, layout.make_slice(i + 1)};
                        break;
                    case 9:
                        if(len(layout) >= i + 2 && layout[i + 1] == 'M')
                        {
                            return {layout.make_slice(0, i), stdPM, layout.make_slice(i + 2)};
                        }
                        break;
                    case 10:
                        if(len(layout) >= i + 2 && layout[i + 1] == 'm')
                        {
                            return {layout.make_slice(0, i), stdpm, layout.make_slice(i + 2)};
                        }
                        break;
                    case 11:
                        if(len(layout) >= i + 7 && layout.make_slice(i, i + 7) == "-070000"_s)
                        {
                            return {layout.make_slice(0, i), stdNumSecondsTz, layout.make_slice(i + 7)};
                        }
                        if(len(layout) >= i + 9 && layout.make_slice(i, i + 9) == "-07:00:00"_s)
                        {
                            return {layout.make_slice(0, i), stdNumColonSecondsTZ, layout.make_slice(i + 9)};
                        }
                        if(len(layout) >= i + 5 && layout.make_slice(i, i + 5) == "-0700"_s)
                        {
                            return {layout.make_slice(0, i), stdNumTZ, layout.make_slice(i + 5)};
                        }
                        if(len(layout) >= i + 6 && layout.make_slice(i, i + 6) == "-07:00"_s)
                        {
                            return {layout.make_slice(0, i), stdNumColonTZ, layout.make_slice(i + 6)};
                        }
                        if(len(layout) >= i + 3 && layout.make_slice(i, i + 3) == "-07"_s)
                        {
                            return {layout.make_slice(0, i), stdNumShortTZ, layout.make_slice(i + 3)};
                        }
                        break;
                    case 12:
                        if(len(layout) >= i + 7 && layout.make_slice(i, i + 7) == "Z070000"_s)
                        {
                            return {layout.make_slice(0, i), stdISO8601SecondsTZ, layout.make_slice(i + 7)};
                        }
                        if(len(layout) >= i + 9 && layout.make_slice(i, i + 9) == "Z07:00:00"_s)
                        {
                            return {layout.make_slice(0, i), stdISO8601ColonSecondsTZ, layout.make_slice(i + 9)};
                        }
                        if(len(layout) >= i + 5 && layout.make_slice(i, i + 5) == "Z0700"_s)
                        {
                            return {layout.make_slice(0, i), stdISO8601TZ, layout.make_slice(i + 5)};
                        }
                        if(len(layout) >= i + 6 && layout.make_slice(i, i + 6) == "Z07:00"_s)
                        {
                            return {layout.make_slice(0, i), stdISO8601ColonTZ, layout.make_slice(i + 6)};
                        }
                        if(len(layout) >= i + 3 && layout.make_slice(i, i + 3) == "Z07"_s)
                        {
                            return {layout.make_slice(0, i), stdISO8601ShortTZ, layout.make_slice(i + 3)};
                        }
                        break;
                    case 13:
                    case 14:
                        if(i + 1 < len(layout) && (layout[i + 1] == '0' || layout[i + 1] == '9'))
                        {
                            auto ch = layout[i + 1];
                            auto j = i + 1;
                            for(; j < len(layout) && layout[j] == ch; )
                            {
                                j++;
                            }
                            if(! isDigit(layout, j))
                            {
                                auto code = stdFracSecond0;
                                if(layout[i + 1] == '9')
                                {
                                    code = stdFracSecond9;
                                }
                                auto std = stdFracSecond(code, j - (i + 1), c);
                                return {layout.make_slice(0, i), std, layout.make_slice(j)};
                            }
                        }
                        break;
                }
            }
        }
        return {layout, 0, ""_s};
    }

    gocpp::slice<gocpp::string> longDayNames = gocpp::slice<gocpp::string> {"Sunday"_s, "Monday"_s, "Tuesday"_s, "Wednesday"_s, "Thursday"_s, "Friday"_s, "Saturday"_s};
    gocpp::slice<gocpp::string> shortDayNames = gocpp::slice<gocpp::string> {"Sun"_s, "Mon"_s, "Tue"_s, "Wed"_s, "Thu"_s, "Fri"_s, "Sat"_s};
    gocpp::slice<gocpp::string> shortMonthNames = gocpp::slice<gocpp::string> {"Jan"_s, "Feb"_s, "Mar"_s, "Apr"_s, "May"_s, "Jun"_s, "Jul"_s, "Aug"_s, "Sep"_s, "Oct"_s, "Nov"_s, "Dec"_s};
    gocpp::slice<gocpp::string> longMonthNames = gocpp::slice<gocpp::string> {"January"_s, "February"_s, "March"_s, "April"_s, "May"_s, "June"_s, "July"_s, "August"_s, "September"_s, "October"_s, "November"_s, "December"_s};
    // match reports whether s1 and s2 match ignoring case.
    // It is assumed s1 and s2 are the same length.
    bool match(gocpp::string s1, gocpp::string s2)
    {
        for(auto i = 0; i < len(s1); i++)
        {
            auto c1 = s1[i];
            auto c2 = s2[i];
            if(c1 != c2)
            {
                c1 |= 'a' - 'A';
                c2 |= 'a' - 'A';
                if(c1 != c2 || c1 < 'a' || c1 > 'z')
                {
                    return false;
                }
            }
        }
        return true;
    }

    std::tuple<int, gocpp::string, struct gocpp::error> lookup(gocpp::slice<gocpp::string> tab, gocpp::string val)
    {
        for(auto [i, v] : tab)
        {
            if(len(val) >= len(v) && match(val.make_slice(0, len(v)), v))
            {
                return {i, val.make_slice(len(v)), nullptr};
            }
        }
        return {- 1, val, errBad};
    }

    // appendInt appends the decimal form of x to b and returns the result.
    // If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's.
    // Duplicates functionality in strconv, but avoids dependency.
    gocpp::slice<unsigned char> appendInt(gocpp::slice<unsigned char> b, int x, int width)
    {
        auto u = (unsigned int)(x);
        if(x < 0)
        {
            b = append(b, '-');
            u = (unsigned int)(- x);
        }
        auto utod = [=](unsigned int u) mutable -> unsigned char
        {
            return '0' + (unsigned char)(u);
        };
        //Go switch emulation
        {
            int conditionId = -1;
            if(width == 2 && u < 1e2) { conditionId = 0; }
            else if(width == 4 && u < 1e4) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return append(b, utod(u / 1e1), utod(u % 1e1));
                    break;
                case 1:
                    return append(b, utod(u / 1e3), utod(u / 1e2 % 1e1), utod(u / 1e1 % 1e1), utod(u % 1e1));
                    break;
            }
        }
        // Compute the number of decimal digits.
        int n = {};
        if(u == 0)
        {
            n = 1;
        }
        for(auto u2 = u; u2 > 0; u2 /= 10)
        {
            n++;
        }
        for(auto pad = width - n; pad > 0; pad--)
        {
            b = append(b, '0');
        }
        if(len(b) + n <= cap(b))
        {
            b = b.make_slice(0, len(b) + n);
        }
        else
        {
            b = append(b, gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n));
        }
        auto i = len(b) - 1;
        for(; u >= 10 && i > 0; )
        {
            auto q = u / 10;
            b[i] = utod(u - q * 10);
            u = q;
            i--;
        }
        b[i] = utod(u);
        return b;
    }

    // Never printed, just needs to be non-nil for return by atoi.
    gocpp::error errAtoi = errors::New("time: invalid number"_s);
    // Duplicates functionality in strconv, but avoids dependency.
    template<typename bytes>
    std::tuple<int, struct gocpp::error> atoi(bytes s)
    {
        int x;
        struct gocpp::error err;
        auto neg = false;
        if(len(s) > 0 && (s[0] == '-' || s[0] == '+'))
        {
            neg = s[0] == '-';
            s = s.make_slice(1);
        }
        uint64_t q;
        bytes rem;
        std::tie(q, rem, err) = leadingInt(s);
        x = int(q);
        if(err != nullptr || len(rem) > 0)
        {
            return {0, errAtoi};
        }
        if(neg)
        {
            x = - x;
        }
        return {x, nullptr};
    }

    // The "std" value passed to appendNano contains two packed fields: the number of
    // digits after the decimal and the separator character (period or comma).
    // These functions pack and unpack that variable.
    int stdFracSecond(int code, int n, int c)
    {
        if(c == '.')
        {
            return code | ((n & 0xfff) << stdArgShift);
        }
        return code | ((n & 0xfff) << stdArgShift) | (1 << stdSeparatorShift);
    }

    int digitsLen(int std)
    {
        return (std >> stdArgShift) & 0xfff;
    }

    unsigned char separator(int std)
    {
        if((std >> stdSeparatorShift) == 0)
        {
            return '.';
        }
        return ',';
    }

    // appendNano appends a fractional second, as nanoseconds, to b
    // and returns the result. The nanosec must be within [0, 999999999].
    gocpp::slice<unsigned char> appendNano(gocpp::slice<unsigned char> b, int nanosec, int std)
    {
        auto trim = std & stdMask == stdFracSecond9;
        auto n = digitsLen(std);
        if(trim && (n == 0 || nanosec == 0))
        {
            return b;
        }
        auto dot = separator(std);
        b = append(b, dot);
        b = appendInt(b, nanosec, 9);
        if(n < 9)
        {
            b = b.make_slice(0, len(b) - 9 + n);
        }
        if(trim)
        {
            for(; len(b) > 0 && b[len(b) - 1] == '0'; )
            {
                b = b.make_slice(0, len(b) - 1);
            }
            if(len(b) > 0 && b[len(b) - 1] == dot)
            {
                b = b.make_slice(0, len(b) - 1);
            }
        }
        return b;
    }

    // String returns the time formatted using the format string
    //
    //	"2006-01-02 15:04:05.999999999 -0700 MST"
    //
    // If the time has a monotonic clock reading, the returned string
    // includes a final field "m=±<value>", where value is the monotonic
    // clock reading formatted as a decimal number of seconds.
    //
    // The returned string is meant for debugging; for a stable serialized
    // representation, use t.MarshalText, t.MarshalBinary, or t.Format
    // with an explicit format string.
    gocpp::string rec::String(struct Time t)
    {
        auto s = rec::Format(gocpp::recv(t), "2006-01-02 15:04:05.999999999 -0700 MST"_s);
        if(t.wall & hasMonotonic != 0)
        {
            auto m2 = uint64_t(t.ext);
            auto sign = (unsigned char)('+');
            if(t.ext < 0)
            {
                sign = '-';
                m2 = - m2;
            }
            uint64_t m1;
            std::tie(m1, m2) = std::tuple{m2 / 1e9, m2 % 1e9};
            uint64_t m0;
            std::tie(m0, m1) = std::tuple{m1 / 1e9, m1 % 1e9};
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, 24);
            buf = append(buf, " m="_s);
            buf = append(buf, sign);
            auto wid = 0;
            if(m0 != 0)
            {
                buf = appendInt(buf, int(m0), 0);
                wid = 9;
            }
            buf = appendInt(buf, int(m1), wid);
            buf = append(buf, '.');
            buf = appendInt(buf, int(m2), 9);
            s += gocpp::string(buf);
        }
        return s;
    }

    // GoString implements fmt.GoStringer and formats t to be printed in Go source
    // code.
    gocpp::string rec::GoString(struct Time t)
    {
        auto abs = rec::abs(gocpp::recv(t));
        auto [year, month, day, gocpp_id_1] = absDate(abs, true);
        auto [hour, minute, second] = absClock(abs);
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len("time.Date(9999, time.September, 31, 23, 59, 59, 999999999, time.Local)"_s));
        buf = append(buf, "time.Date("_s);
        buf = appendInt(buf, year, 0);
        if(January <= month && month <= December)
        {
            buf = append(buf, ", time."_s);
            buf = append(buf, longMonthNames[month - 1]);
        }
        else
        {
            buf = appendInt(buf, int(month), 0);
        }
        buf = append(buf, ", "_s);
        buf = appendInt(buf, day, 0);
        buf = append(buf, ", "_s);
        buf = appendInt(buf, hour, 0);
        buf = append(buf, ", "_s);
        buf = appendInt(buf, minute, 0);
        buf = append(buf, ", "_s);
        buf = appendInt(buf, second, 0);
        buf = append(buf, ", "_s);
        buf = appendInt(buf, rec::Nanosecond(gocpp::recv(t)), 0);
        buf = append(buf, ", "_s);
        //Go switch emulation
        {
            auto loc = rec::Location(gocpp::recv(t));
            auto condition = loc;
            int conditionId = -1;
            if(condition == UTC) { conditionId = 0; }
            else if(condition == nullptr) { conditionId = 1; }
            else if(condition == Local) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    buf = append(buf, "time.UTC"_s);
                    break;
                case 2:
                    buf = append(buf, "time.Local"_s);
                    break;
                default:
                    buf = append(buf, "time.Location("_s);
                    buf = append(buf, quote(loc->name));
                    buf = append(buf, ')');
                    break;
            }
        }
        buf = append(buf, ')');
        return gocpp::string(buf);
    }

    // Format returns a textual representation of the time value formatted according
    // to the layout defined by the argument. See the documentation for the
    // constant called Layout to see how to represent the layout format.
    //
    // The executable example for Time.Format demonstrates the working
    // of the layout string in detail and is a good reference.
    gocpp::string rec::Format(struct Time t, gocpp::string layout)
    {
        auto bufSize = 64;
        gocpp::slice<unsigned char> b = {};
        auto max = len(layout) + 10;
        if(max < bufSize)
        {
            gocpp::array<unsigned char, bufSize> buf = {};
            b = buf.make_slice(0, 0);
        }
        else
        {
            b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, max);
        }
        b = rec::AppendFormat(gocpp::recv(t), b, layout);
        return gocpp::string(b);
    }

    // AppendFormat is like Format but appends the textual
    // representation to b and returns the extended buffer.
    gocpp::slice<unsigned char> rec::AppendFormat(struct Time t, gocpp::slice<unsigned char> b, gocpp::string layout)
    {
        //Go switch emulation
        {
            auto condition = layout;
            int conditionId = -1;
            if(condition == RFC3339) { conditionId = 0; }
            else if(condition == RFC3339Nano) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return rec::appendFormatRFC3339(gocpp::recv(t), b, false);
                    break;
                case 1:
                    return rec::appendFormatRFC3339(gocpp::recv(t), b, true);
                    break;
                default:
                    return rec::appendFormat(gocpp::recv(t), b, layout);
                    break;
            }
        }
    }

    gocpp::slice<unsigned char> rec::appendFormat(struct Time t, gocpp::slice<unsigned char> b, gocpp::string layout)
    {
        auto [name, offset, abs] = rec::locabs(gocpp::recv(t));
        int year = - 1;
        time::Month month = - 1;
        int day = - 1;
        int yday = - 1;
        int hour = - 1;
        int min = - 1;
        int sec = - 1;
        for(; layout != ""_s; )
        {
            auto [prefix, std, suffix] = nextStdChunk(layout);
            if(prefix != ""_s)
            {
                b = append(b, prefix);
            }
            if(std == 0)
            {
                break;
            }
            layout = suffix;
            if(year < 0 && std & stdNeedDate != 0)
            {
                std::tie(year, month, day, yday) = absDate(abs, true);
                yday++;
            }
            if(hour < 0 && std & stdNeedClock != 0)
            {
                std::tie(hour, min, sec) = absClock(abs);
            }
            //Go switch emulation
            {
                auto condition = std & stdMask;
                int conditionId = -1;
                if(condition == stdYear) { conditionId = 0; }
                else if(condition == stdLongYear) { conditionId = 1; }
                else if(condition == stdMonth) { conditionId = 2; }
                else if(condition == stdLongMonth) { conditionId = 3; }
                else if(condition == stdNumMonth) { conditionId = 4; }
                else if(condition == stdZeroMonth) { conditionId = 5; }
                else if(condition == stdWeekDay) { conditionId = 6; }
                else if(condition == stdLongWeekDay) { conditionId = 7; }
                else if(condition == stdDay) { conditionId = 8; }
                else if(condition == stdUnderDay) { conditionId = 9; }
                else if(condition == stdZeroDay) { conditionId = 10; }
                else if(condition == stdUnderYearDay) { conditionId = 11; }
                else if(condition == stdZeroYearDay) { conditionId = 12; }
                else if(condition == stdHour) { conditionId = 13; }
                else if(condition == stdHour12) { conditionId = 14; }
                else if(condition == stdZeroHour12) { conditionId = 15; }
                else if(condition == stdMinute) { conditionId = 16; }
                else if(condition == stdZeroMinute) { conditionId = 17; }
                else if(condition == stdSecond) { conditionId = 18; }
                else if(condition == stdZeroSecond) { conditionId = 19; }
                else if(condition == stdPM) { conditionId = 20; }
                else if(condition == stdpm) { conditionId = 21; }
                else if(condition == stdISO8601TZ) { conditionId = 22; }
                else if(condition == stdISO8601ColonTZ) { conditionId = 23; }
                else if(condition == stdISO8601SecondsTZ) { conditionId = 24; }
                else if(condition == stdISO8601ShortTZ) { conditionId = 25; }
                else if(condition == stdISO8601ColonSecondsTZ) { conditionId = 26; }
                else if(condition == stdNumTZ) { conditionId = 27; }
                else if(condition == stdNumColonTZ) { conditionId = 28; }
                else if(condition == stdNumSecondsTz) { conditionId = 29; }
                else if(condition == stdNumShortTZ) { conditionId = 30; }
                else if(condition == stdNumColonSecondsTZ) { conditionId = 31; }
                else if(condition == stdTZ) { conditionId = 32; }
                else if(condition == stdFracSecond0) { conditionId = 33; }
                else if(condition == stdFracSecond9) { conditionId = 34; }
                switch(conditionId)
                {
                    case 0:
                        auto y = year;
                        if(y < 0)
                        {
                            y = - y;
                        }
                        b = appendInt(b, y % 100, 2);
                        break;
                    case 1:
                        b = appendInt(b, year, 4);
                        break;
                    case 2:
                        b = append(b, rec::String(gocpp::recv(month)).make_slice(0, 3));
                        break;
                    case 3:
                        auto m = rec::String(gocpp::recv(month));
                        b = append(b, m);
                        break;
                    case 4:
                        b = appendInt(b, int(month), 0);
                        break;
                    case 5:
                        b = appendInt(b, int(month), 2);
                        break;
                    case 6:
                        b = append(b, rec::String(gocpp::recv(absWeekday(abs))).make_slice(0, 3));
                        break;
                    case 7:
                        auto s = rec::String(gocpp::recv(absWeekday(abs)));
                        b = append(b, s);
                        break;
                    case 8:
                        b = appendInt(b, day, 0);
                        break;
                    case 9:
                        if(day < 10)
                        {
                            b = append(b, ' ');
                        }
                        b = appendInt(b, day, 0);
                        break;
                    case 10:
                        b = appendInt(b, day, 2);
                        break;
                    case 11:
                        if(yday < 100)
                        {
                            b = append(b, ' ');
                            if(yday < 10)
                            {
                                b = append(b, ' ');
                            }
                        }
                        b = appendInt(b, yday, 0);
                        break;
                    case 12:
                        b = appendInt(b, yday, 3);
                        break;
                    case 13:
                        b = appendInt(b, hour, 2);
                        break;
                    case 14:
                        auto hr = hour % 12;
                        if(hr == 0)
                        {
                            hr = 12;
                        }
                        b = appendInt(b, hr, 0);
                        break;
                    case 15:
                        auto hr = hour % 12;
                        if(hr == 0)
                        {
                            hr = 12;
                        }
                        b = appendInt(b, hr, 2);
                        break;
                    case 16:
                        b = appendInt(b, min, 0);
                        break;
                    case 17:
                        b = appendInt(b, min, 2);
                        break;
                    case 18:
                        b = appendInt(b, sec, 0);
                        break;
                    case 19:
                        b = appendInt(b, sec, 2);
                        break;
                    case 20:
                        if(hour >= 12)
                        {
                            b = append(b, "PM"_s);
                        }
                        else
                        {
                            b = append(b, "AM"_s);
                        }
                        break;
                    case 21:
                        if(hour >= 12)
                        {
                            b = append(b, "pm"_s);
                        }
                        else
                        {
                            b = append(b, "am"_s);
                        }
                        break;
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        if(offset == 0 && (std == stdISO8601TZ || std == stdISO8601ColonTZ || std == stdISO8601SecondsTZ || std == stdISO8601ShortTZ || std == stdISO8601ColonSecondsTZ))
                        {
                            b = append(b, 'Z');
                            break;
                        }
                        auto zone = offset / 60;
                        auto absoffset = offset;
                        if(zone < 0)
                        {
                            b = append(b, '-');
                            zone = - zone;
                            absoffset = - absoffset;
                        }
                        else
                        {
                            b = append(b, '+');
                        }
                        b = appendInt(b, zone / 60, 2);
                        if(std == stdISO8601ColonTZ || std == stdNumColonTZ || std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ)
                        {
                            b = append(b, ':');
                        }
                        if(std != stdNumShortTZ && std != stdISO8601ShortTZ)
                        {
                            b = appendInt(b, zone % 60, 2);
                        }
                        if(std == stdISO8601SecondsTZ || std == stdNumSecondsTz || std == stdNumColonSecondsTZ || std == stdISO8601ColonSecondsTZ)
                        {
                            if(std == stdNumColonSecondsTZ || std == stdISO8601ColonSecondsTZ)
                            {
                                b = append(b, ':');
                            }
                            b = appendInt(b, absoffset % 60, 2);
                        }
                        break;
                    case 32:
                        if(name != ""_s)
                        {
                            b = append(b, name);
                            break;
                        }
                        auto zone = offset / 60;
                        if(zone < 0)
                        {
                            b = append(b, '-');
                            zone = - zone;
                        }
                        else
                        {
                            b = append(b, '+');
                        }
                        b = appendInt(b, zone / 60, 2);
                        b = appendInt(b, zone % 60, 2);
                        break;
                    case 33:
                    case 34:
                        b = appendNano(b, rec::Nanosecond(gocpp::recv(t)), std);
                        break;
                }
            }
        }
        return b;
    }

    gocpp::error errBad = errors::New("bad value for field"_s);
    // ParseError describes a problem parsing a time string.
    
    template<typename T> requires gocpp::GoStruct<T>
    ParseError::operator T()
    {
        T result;
        result.Layout = this->Layout;
        result.Value = this->Value;
        result.LayoutElem = this->LayoutElem;
        result.ValueElem = this->ValueElem;
        result.Message = this->Message;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ParseError::operator==(const T& ref) const
    {
        if (Layout != ref.Layout) return false;
        if (Value != ref.Value) return false;
        if (LayoutElem != ref.LayoutElem) return false;
        if (ValueElem != ref.ValueElem) return false;
        if (Message != ref.Message) return false;
        return true;
    }

    std::ostream& ParseError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Layout;
        os << " " << Value;
        os << " " << LayoutElem;
        os << " " << ValueElem;
        os << " " << Message;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ParseError& value)
    {
        return value.PrintTo(os);
    }

    // newParseError creates a new ParseError.
    // The provided value and valueElem are cloned to avoid escaping their values.
    struct ParseError* newParseError(gocpp::string layout, gocpp::string value, gocpp::string layoutElem, gocpp::string valueElem, gocpp::string message)
    {
        auto valueCopy = cloneString(value);
        auto valueElemCopy = cloneString(valueElem);
        return new ParseError {layout, valueCopy, layoutElem, valueElemCopy, message};
    }

    // cloneString returns a string copy of s.
    // Do not use strings.Clone to avoid dependency on strings package.
    gocpp::string cloneString(gocpp::string s)
    {
        return gocpp::string(gocpp::slice<unsigned char>(s));
    }

    // These are borrowed from unicode/utf8 and strconv and replicate behavior in
    // that package, since we can't take a dependency on either.
    gocpp::string lowerhex = "0123456789abcdef"_s;
    gocpp::string quote(gocpp::string s)
    {
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 1, len(s) + 2);
        buf[0] = '"';
        for(auto [i, c] : s)
        {
            if(c >= runeSelf || c < ' ')
            {
                // This means you are asking us to parse a time.Duration or
                // time.Location with unprintable or non-ASCII characters in it.
                // We don't expect to hit this case very often. We could try to
                // reproduce strconv.Quote's behavior with full fidelity but
                // given how rarely we expect to hit these edge cases, speed and
                // conciseness are better.
                int width = {};
                if(c == runeError)
                {
                    width = 1;
                    if(i + 2 < len(s) && s.make_slice(i, i + 3) == gocpp::string(runeError))
                    {
                        width = 3;
                    }
                }
                else
                {
                    width = len(gocpp::string(c));
                }
                for(auto j = 0; j < width; j++)
                {
                    buf = append(buf, "\\x"_s);
                    buf = append(buf, lowerhex[s[i + j] >> 4]);
                    buf = append(buf, lowerhex[s[i + j] & 0xF]);
                }
            }
            else
            {
                if(c == '"' || c == '\\')
                {
                    buf = append(buf, '\\');
                }
                buf = append(buf, gocpp::string(c));
            }
        }
        buf = append(buf, '"');
        return gocpp::string(buf);
    }

    // Error returns the string representation of a ParseError.
    gocpp::string rec::Error(struct ParseError* e)
    {
        if(e->Message == ""_s)
        {
            return "parsing time "_s + quote(e->Value) + " as "_s + quote(e->Layout) + ": cannot parse "_s + quote(e->ValueElem) + " as "_s + quote(e->LayoutElem);
        }
        return "parsing time "_s + quote(e->Value) + e->Message;
    }

    // isDigit reports whether s[i] is in range and is a decimal digit.
    template<typename bytes>
    bool isDigit(bytes s, int i)
    {
        if(len(s) <= i)
        {
            return false;
        }
        auto c = s[i];
        return '0' <= c && c <= '9';
    }

    // getnum parses s[0:1] or s[0:2] (fixed forces s[0:2])
    // as a decimal integer and returns the integer and the
    // remainder of the string.
    std::tuple<int, gocpp::string, struct gocpp::error> getnum(gocpp::string s, bool fixed)
    {
        if(! isDigit(s, 0))
        {
            return {0, s, errBad};
        }
        if(! isDigit(s, 1))
        {
            if(fixed)
            {
                return {0, s, errBad};
            }
            return {int(s[0] - '0'), s.make_slice(1), nullptr};
        }
        return {int(s[0] - '0') * 10 + int(s[1] - '0'), s.make_slice(2), nullptr};
    }

    // getnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3])
    // as a decimal integer and returns the integer and the remainder
    // of the string.
    std::tuple<int, gocpp::string, struct gocpp::error> getnum3(gocpp::string s, bool fixed)
    {
        int n = {};
        int i = {};
        for(i = 0; i < 3 && isDigit(s, i); i++)
        {
            n = n * 10 + int(s[i] - '0');
        }
        if(i == 0 || fixed && i != 3)
        {
            return {0, s, errBad};
        }
        return {n, s.make_slice(i), nullptr};
    }

    gocpp::string cutspace(gocpp::string s)
    {
        for(; len(s) > 0 && s[0] == ' '; )
        {
            s = s.make_slice(1);
        }
        return s;
    }

    // skip removes the given prefix from value,
    // treating runs of space characters as equivalent.
    std::tuple<gocpp::string, struct gocpp::error> skip(gocpp::string value, gocpp::string prefix)
    {
        for(; len(prefix) > 0; )
        {
            if(prefix[0] == ' ')
            {
                if(len(value) > 0 && value[0] != ' ')
                {
                    return {value, errBad};
                }
                prefix = cutspace(prefix);
                value = cutspace(value);
                continue;
            }
            if(len(value) == 0 || value[0] != prefix[0])
            {
                return {value, errBad};
            }
            prefix = prefix.make_slice(1);
            value = value.make_slice(1);
        }
        return {value, nullptr};
    }

    // Parse parses a formatted string and returns the time value it represents.
    // See the documentation for the constant called Layout to see how to
    // represent the format. The second argument must be parseable using
    // the format string (layout) provided as the first argument.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // When parsing (only), the input may contain a fractional second
    // field immediately after the seconds field, even if the layout does not
    // signify its presence. In that case either a comma or a decimal point
    // followed by a maximal series of digits is parsed as a fractional second.
    // Fractional seconds are truncated to nanosecond precision.
    //
    // Elements omitted from the layout are assumed to be zero or, when
    // zero is impossible, one, so parsing "3:04pm" returns the time
    // corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
    // 0, this time is before the zero Time).
    // Years must be in the range 0000..9999. The day of the week is checked
    // for syntax but it is otherwise ignored.
    //
    // For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
    // as 19NN and a value NN < 69 will be treated as 20NN.
    //
    // The remainder of this comment describes the handling of time zones.
    //
    // In the absence of a time zone indicator, Parse returns a time in UTC.
    //
    // When parsing a time with a zone offset like -0700, if the offset corresponds
    // to a time zone used by the current location (Local), then Parse uses that
    // location and zone in the returned time. Otherwise it records the time as
    // being in a fabricated location with time fixed at the given zone offset.
    //
    // When parsing a time with a zone abbreviation like MST, if the zone abbreviation
    // has a defined offset in the current location, then that offset is used.
    // The zone abbreviation "UTC" is recognized as UTC regardless of location.
    // If the zone abbreviation is unknown, Parse records the time as being
    // in a fabricated location with the given zone abbreviation and a zero offset.
    // This choice means that such a time can be parsed and reformatted with the
    // same layout losslessly, but the exact instant used in the representation will
    // differ by the actual zone offset. To avoid such problems, prefer time layouts
    // that use a numeric zone offset, or use ParseInLocation.
    std::tuple<struct Time, struct gocpp::error> Parse(gocpp::string layout, gocpp::string value)
    {
        if(layout == RFC3339 || layout == RFC3339Nano)
        {
            if(auto [t, ok] = parseRFC3339(value, Local); ok)
            {
                return {t, nullptr};
            }
        }
        return parse(layout, value, UTC, Local);
    }

    // ParseInLocation is like Parse but differs in two important ways.
    // First, in the absence of time zone information, Parse interprets a time as UTC;
    // ParseInLocation interprets the time as in the given location.
    // Second, when given a zone offset or abbreviation, Parse tries to match it
    // against the Local location; ParseInLocation uses the given location.
    std::tuple<struct Time, struct gocpp::error> ParseInLocation(gocpp::string layout, gocpp::string value, struct Location* loc)
    {
        if(layout == RFC3339 || layout == RFC3339Nano)
        {
            if(auto [t, ok] = parseRFC3339(value, loc); ok)
            {
                return {t, nullptr};
            }
        }
        return parse(layout, value, loc, loc);
    }

    std::tuple<struct Time, struct gocpp::error> parse(gocpp::string layout, gocpp::string value, struct Location* defaultLocation, struct Location* local)
    {
        auto [alayout, avalue] = std::tuple{layout, value};
        auto rangeErrString = ""_s;
        auto amSet = false;
        auto pmSet = false;
        // Time being constructed.
        int year = {};
        int month = - 1;
        int day = - 1;
        int yday = - 1;
        int hour = - 1;
        int min = - 1;
        int sec = - 1;
        int nsec = - 1;
        Location* z = - 1;
        int zoneOffset = - 1;
        gocpp::string zoneName = - 1;
        for(; ; )
        {
            gocpp::error err = {};
            auto [prefix, std, suffix] = nextStdChunk(layout);
            auto stdstr = layout.make_slice(len(prefix), len(layout) - len(suffix));
            std::tie(value, err) = skip(value, prefix);
            if(err != nullptr)
            {
                return {Time {}, newParseError(alayout, avalue, prefix, value, ""_s)};
            }
            if(std == 0)
            {
                if(len(value) != 0)
                {
                    return {Time {}, newParseError(alayout, avalue, ""_s, value, ": extra text: "_s + quote(value))};
                }
                break;
            }
            layout = suffix;
            gocpp::string p = {};
            auto hold = value;
            //Go switch emulation
            {
                auto condition = std & stdMask;
                int conditionId = -1;
                if(condition == stdYear) { conditionId = 0; }
                else if(condition == stdLongYear) { conditionId = 1; }
                else if(condition == stdMonth) { conditionId = 2; }
                else if(condition == stdLongMonth) { conditionId = 3; }
                else if(condition == stdNumMonth) { conditionId = 4; }
                else if(condition == stdZeroMonth) { conditionId = 5; }
                else if(condition == stdWeekDay) { conditionId = 6; }
                else if(condition == stdLongWeekDay) { conditionId = 7; }
                else if(condition == stdDay) { conditionId = 8; }
                else if(condition == stdUnderDay) { conditionId = 9; }
                else if(condition == stdZeroDay) { conditionId = 10; }
                else if(condition == stdUnderYearDay) { conditionId = 11; }
                else if(condition == stdZeroYearDay) { conditionId = 12; }
                else if(condition == stdHour) { conditionId = 13; }
                else if(condition == stdHour12) { conditionId = 14; }
                else if(condition == stdZeroHour12) { conditionId = 15; }
                else if(condition == stdMinute) { conditionId = 16; }
                else if(condition == stdZeroMinute) { conditionId = 17; }
                else if(condition == stdSecond) { conditionId = 18; }
                else if(condition == stdZeroSecond) { conditionId = 19; }
                else if(condition == stdPM) { conditionId = 20; }
                else if(condition == stdpm) { conditionId = 21; }
                else if(condition == stdISO8601TZ) { conditionId = 22; }
                else if(condition == stdISO8601ColonTZ) { conditionId = 23; }
                else if(condition == stdISO8601SecondsTZ) { conditionId = 24; }
                else if(condition == stdISO8601ShortTZ) { conditionId = 25; }
                else if(condition == stdISO8601ColonSecondsTZ) { conditionId = 26; }
                else if(condition == stdNumTZ) { conditionId = 27; }
                else if(condition == stdNumShortTZ) { conditionId = 28; }
                else if(condition == stdNumColonTZ) { conditionId = 29; }
                else if(condition == stdNumSecondsTz) { conditionId = 30; }
                else if(condition == stdNumColonSecondsTZ) { conditionId = 31; }
                else if(condition == stdTZ) { conditionId = 32; }
                else if(condition == stdFracSecond0) { conditionId = 33; }
                else if(condition == stdFracSecond9) { conditionId = 34; }
                switch(conditionId)
                {
                    case 0:
                        if(len(value) < 2)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 2), value.make_slice(2)};
                        std::tie(year, err) = atoi(p);
                        if(err != nullptr)
                        {
                            break;
                        }
                        if(year >= 69)
                        {
                            year += 1900;
                        }
                        else
                        {
                            year += 2000;
                        }
                        break;
                    case 1:
                        if(len(value) < 4 || ! isDigit(value, 0))
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 4), value.make_slice(4)};
                        std::tie(year, err) = atoi(p);
                        break;
                    case 2:
                        std::tie(month, value, err) = lookup(shortMonthNames, value);
                        month++;
                        break;
                    case 3:
                        std::tie(month, value, err) = lookup(longMonthNames, value);
                        month++;
                        break;
                    case 4:
                    case 5:
                        std::tie(month, value, err) = getnum(value, std == stdZeroMonth);
                        if(err == nullptr && (month <= 0 || 12 < month))
                        {
                            rangeErrString = "month"_s;
                        }
                        break;
                    case 6:
                        std::tie(gocpp_id_2, value, err) = lookup(shortDayNames, value);
                        break;
                    case 7:
                        std::tie(gocpp_id_3, value, err) = lookup(longDayNames, value);
                        break;
                    case 8:
                    case 9:
                    case 10:
                        if(std == stdUnderDay && len(value) > 0 && value[0] == ' ')
                        {
                            value = value.make_slice(1);
                        }
                        std::tie(day, value, err) = getnum(value, std == stdZeroDay);
                        break;
                    case 11:
                    case 12:
                        for(auto i = 0; i < 2; i++)
                        {
                            if(std == stdUnderYearDay && len(value) > 0 && value[0] == ' ')
                            {
                                value = value.make_slice(1);
                            }
                        }
                        std::tie(yday, value, err) = getnum3(value, std == stdZeroYearDay);
                        break;
                    case 13:
                        std::tie(hour, value, err) = getnum(value, false);
                        if(hour < 0 || 24 <= hour)
                        {
                            rangeErrString = "hour"_s;
                        }
                        break;
                    case 14:
                    case 15:
                        std::tie(hour, value, err) = getnum(value, std == stdZeroHour12);
                        if(hour < 0 || 12 < hour)
                        {
                            rangeErrString = "hour"_s;
                        }
                        break;
                    case 16:
                    case 17:
                        std::tie(min, value, err) = getnum(value, std == stdZeroMinute);
                        if(min < 0 || 60 <= min)
                        {
                            rangeErrString = "minute"_s;
                        }
                        break;
                    case 18:
                    case 19:
                        std::tie(sec, value, err) = getnum(value, std == stdZeroSecond);
                        if(err != nullptr)
                        {
                            break;
                        }
                        if(sec < 0 || 60 <= sec)
                        {
                            rangeErrString = "second"_s;
                            break;
                        }
                        if(len(value) >= 2 && commaOrPeriod(value[0]) && isDigit(value, 1))
                        {
                            std::tie(gocpp_id_4, std, gocpp_id_5) = nextStdChunk(layout);
                            std &= stdMask;
                            if(std == stdFracSecond0 || std == stdFracSecond9)
                            {
                                break;
                            }
                            auto n = 2;
                            for(; n < len(value) && isDigit(value, n); n++)
                            {
                            }
                            std::tie(nsec, rangeErrString, err) = parseNanoseconds(value, n);
                            value = value.make_slice(n);
                        }
                        break;
                    case 20:
                        if(len(value) < 2)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 2), value.make_slice(2)};
                        //Go switch emulation
                        {
                            auto condition = p;
                            int conditionId = -1;
                            if(condition == "PM"_s) { conditionId = 0; }
                            else if(condition == "AM"_s) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    pmSet = true;
                                    break;
                                case 1:
                                    amSet = true;
                                    break;
                                default:
                                    err = errBad;
                                    break;
                            }
                        }
                        break;
                    case 21:
                        if(len(value) < 2)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(p, value) = std::tuple{value.make_slice(0, 2), value.make_slice(2)};
                        //Go switch emulation
                        {
                            auto condition = p;
                            int conditionId = -1;
                            if(condition == "pm"_s) { conditionId = 0; }
                            else if(condition == "am"_s) { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    pmSet = true;
                                    break;
                                case 1:
                                    amSet = true;
                                    break;
                                default:
                                    err = errBad;
                                    break;
                            }
                        }
                        break;
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        if((std == stdISO8601TZ || std == stdISO8601ShortTZ || std == stdISO8601ColonTZ) && len(value) >= 1 && value[0] == 'Z')
                        {
                            value = value.make_slice(1);
                            z = UTC;
                            break;
                        }
                        gocpp::string sign = {};
                        gocpp::string hour = {};
                        gocpp::string min = {};
                        gocpp::string seconds = {};
                        if(std == stdISO8601ColonTZ || std == stdNumColonTZ)
                        {
                            if(len(value) < 6)
                            {
                                err = errBad;
                                break;
                            }
                            if(value[3] != ':')
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(4, 6), "00"_s, value.make_slice(6)};
                        }
                        else
                        if(std == stdNumShortTZ || std == stdISO8601ShortTZ)
                        {
                            if(len(value) < 3)
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), "00"_s, "00"_s, value.make_slice(3)};
                        }
                        else
                        if(std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ)
                        {
                            if(len(value) < 9)
                            {
                                err = errBad;
                                break;
                            }
                            if(value[3] != ':' || value[6] != ':')
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(4, 6), value.make_slice(7, 9), value.make_slice(9)};
                        }
                        else
                        if(std == stdISO8601SecondsTZ || std == stdNumSecondsTz)
                        {
                            if(len(value) < 7)
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(3, 5), value.make_slice(5, 7), value.make_slice(7)};
                        }
                        else
                        {
                            if(len(value) < 5)
                            {
                                err = errBad;
                                break;
                            }
                            std::tie(sign, hour, min, seconds, value) = std::tuple{value.make_slice(0, 1), value.make_slice(1, 3), value.make_slice(3, 5), "00"_s, value.make_slice(5)};
                        }
                        int hr = {};
                        int mm = {};
                        int ss = {};
                        std::tie(hr, gocpp_id_6, err) = getnum(hour, true);
                        if(err == nullptr)
                        {
                            std::tie(mm, gocpp_id_7, err) = getnum(min, true);
                        }
                        if(err == nullptr)
                        {
                            std::tie(ss, gocpp_id_8, err) = getnum(seconds, true);
                        }
                        zoneOffset = (hr * 60 + mm) * 60 + ss;
                        //Go switch emulation
                        {
                            auto condition = sign[0];
                            int conditionId = -1;
                            if(condition == '+') { conditionId = 0; }
                            else if(condition == '-') { conditionId = 1; }
                            switch(conditionId)
                            {
                                case 0:
                                    break;
                                case 1:
                                    zoneOffset = - zoneOffset;
                                    break;
                                default:
                                    err = errBad;
                                    break;
                            }
                        }
                        break;
                    case 32:
                        if(len(value) >= 3 && value.make_slice(0, 3) == "UTC"_s)
                        {
                            z = UTC;
                            value = value.make_slice(3);
                            break;
                        }
                        auto [n, ok] = parseTimeZone(value);
                        if(! ok)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(zoneName, value) = std::tuple{value.make_slice(0, n), value.make_slice(n)};
                        break;
                    case 33:
                        auto ndigit = 1 + digitsLen(std);
                        if(len(value) < ndigit)
                        {
                            err = errBad;
                            break;
                        }
                        std::tie(nsec, rangeErrString, err) = parseNanoseconds(value, ndigit);
                        value = value.make_slice(ndigit);
                        break;
                    case 34:
                        if(len(value) < 2 || ! commaOrPeriod(value[0]) || value[1] < '0' || '9' < value[1])
                        {
                            break;
                        }
                        auto i = 0;
                        for(; i + 1 < len(value) && '0' <= value[i + 1] && value[i + 1] <= '9'; )
                        {
                            i++;
                        }
                        std::tie(nsec, rangeErrString, err) = parseNanoseconds(value, 1 + i);
                        value = value.make_slice(1 + i);
                        break;
                }
            }
            if(rangeErrString != ""_s)
            {
                return {Time {}, newParseError(alayout, avalue, stdstr, value, ": "_s + rangeErrString + " out of range"_s)};
            }
            if(err != nullptr)
            {
                return {Time {}, newParseError(alayout, avalue, stdstr, hold, ""_s)};
            }
        }
        if(pmSet && hour < 12)
        {
            hour += 12;
        }
        else
        if(amSet && hour == 12)
        {
            hour = 0;
        }
        if(yday >= 0)
        {
            int d = {};
            int m = {};
            if(isLeap(year))
            {
                if(yday == 31 + 29)
                {
                    m = int(February);
                    d = 29;
                }
                else
                if(yday > 31 + 29)
                {
                    yday--;
                }
            }
            if(yday < 1 || yday > 365)
            {
                return {Time {}, newParseError(alayout, avalue, ""_s, value, ": day-of-year out of range"_s)};
            }
            if(m == 0)
            {
                m = (yday - 1) / 31 + 1;
                if(int(daysBefore[m]) < yday)
                {
                    m++;
                }
                d = yday - int(daysBefore[m - 1]);
            }
            if(month >= 0 && month != m)
            {
                return {Time {}, newParseError(alayout, avalue, ""_s, value, ": day-of-year does not match month"_s)};
            }
            month = m;
            if(day >= 0 && day != d)
            {
                return {Time {}, newParseError(alayout, avalue, ""_s, value, ": day-of-year does not match day"_s)};
            }
            day = d;
        }
        else
        {
            if(month < 0)
            {
                month = int(January);
            }
            if(day < 0)
            {
                day = 1;
            }
        }
        if(day < 1 || day > daysIn(Month(month), year))
        {
            return {Time {}, newParseError(alayout, avalue, ""_s, value, ": day out of range"_s)};
        }
        if(z != nullptr)
        {
            return {Date(year, Month(month), day, hour, min, sec, nsec, z), nullptr};
        }
        if(zoneOffset != - 1)
        {
            auto t = Date(year, Month(month), day, hour, min, sec, nsec, UTC);
            rec::addSec(gocpp::recv(t), - int64_t(zoneOffset));
            auto [name, offset, gocpp_id_9, gocpp_id_10, gocpp_id_11] = rec::lookup(gocpp::recv(local), rec::unixSec(gocpp::recv(t)));
            if(offset == zoneOffset && (zoneName == ""_s || name == zoneName))
            {
                rec::setLoc(gocpp::recv(t), local);
                return {t, nullptr};
            }
            auto zoneNameCopy = cloneString(zoneName);
            rec::setLoc(gocpp::recv(t), FixedZone(zoneNameCopy, zoneOffset));
            return {t, nullptr};
        }
        if(zoneName != ""_s)
        {
            auto t = Date(year, Month(month), day, hour, min, sec, nsec, UTC);
            auto [offset, ok] = rec::lookupName(gocpp::recv(local), zoneName, rec::unixSec(gocpp::recv(t)));
            if(ok)
            {
                rec::addSec(gocpp::recv(t), - int64_t(offset));
                rec::setLoc(gocpp::recv(t), local);
                return {t, nullptr};
            }
            if(len(zoneName) > 3 && zoneName.make_slice(0, 3) == "GMT"_s)
            {
                std::tie(offset, gocpp_id_12) = atoi(zoneName.make_slice(3));
                offset *= 3600;
            }
            auto zoneNameCopy = cloneString(zoneName);
            rec::setLoc(gocpp::recv(t), FixedZone(zoneNameCopy, offset));
            return {t, nullptr};
        }
        return {Date(year, Month(month), day, hour, min, sec, nsec, defaultLocation), nullptr};
    }

    // parseTimeZone parses a time zone string and returns its length. Time zones
    // are human-generated and unpredictable. We can't do precise error checking.
    // On the other hand, for a correct parse there must be a time zone at the
    // beginning of the string, so it's almost always true that there's one
    // there. We look at the beginning of the string for a run of upper-case letters.
    // If there are more than 5, it's an error.
    // If there are 4 or 5 and the last is a T, it's a time zone.
    // If there are 3, it's a time zone.
    // Otherwise, other than special cases, it's not a time zone.
    // GMT is special because it can have an hour offset.
    std::tuple<int, bool> parseTimeZone(gocpp::string value)
    {
        int length;
        bool ok;
        if(len(value) < 3)
        {
            return {0, false};
        }
        if(len(value) >= 4 && (value.make_slice(0, 4) == "ChST"_s || value.make_slice(0, 4) == "MeST"_s))
        {
            return {4, true};
        }
        if(value.make_slice(0, 3) == "GMT"_s)
        {
            length = parseGMT(value);
            return {length, true};
        }
        if(value[0] == '+' || value[0] == '-')
        {
            length = parseSignedOffset(value);
            auto ok = length > 0;
            return {length, ok};
        }
        // How many upper-case letters are there? Need at least three, at most five.
        int nUpper = {};
        for(nUpper = 0; nUpper < 6; nUpper++)
        {
            if(nUpper >= len(value))
            {
                break;
            }
            if(auto c = value[nUpper]; c < 'A' || 'Z' < c)
            {
                break;
            }
        }
        //Go switch emulation
        {
            auto condition = nUpper;
            int conditionId = -1;
            if(condition == 0) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            else if(condition == 6) { conditionId = 3; }
            else if(condition == 5) { conditionId = 4; }
            else if(condition == 4) { conditionId = 5; }
            else if(condition == 3) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    return {0, false};
                    break;
                case 4:
                    if(value[4] == 'T')
                    {
                        return {5, true};
                    }
                    break;
                case 5:
                    if(value[3] == 'T' || value.make_slice(0, 4) == "WITA"_s)
                    {
                        return {4, true};
                    }
                    break;
                case 6:
                    return {3, true};
                    break;
            }
        }
        return {0, false};
    }

    // parseGMT parses a GMT time zone. The input string is known to start "GMT".
    // The function checks whether that is followed by a sign and a number in the
    // range -23 through +23 excluding zero.
    int parseGMT(gocpp::string value)
    {
        value = value.make_slice(3);
        if(len(value) == 0)
        {
            return 3;
        }
        return 3 + parseSignedOffset(value);
    }

    // parseSignedOffset parses a signed timezone offset (e.g. "+03" or "-04").
    // The function checks for a signed number in the range -23 through +23 excluding zero.
    // Returns length of the found offset string or 0 otherwise.
    int parseSignedOffset(gocpp::string value)
    {
        auto sign = value[0];
        if(sign != '-' && sign != '+')
        {
            return 0;
        }
        auto [x, rem, err] = leadingInt(value.make_slice(1));
        if(err != nullptr || value.make_slice(1) == rem)
        {
            return 0;
        }
        if(x > 23)
        {
            return 0;
        }
        return len(value) - len(rem);
    }

    bool commaOrPeriod(unsigned char b)
    {
        return b == '.' || b == ',';
    }

    template<typename bytes>
    std::tuple<int, gocpp::string, struct gocpp::error> parseNanoseconds(bytes value, int nbytes)
    {
        int ns;
        gocpp::string rangeErrString;
        struct gocpp::error err;
        if(! commaOrPeriod(value[0]))
        {
            err = errBad;
            return {ns, rangeErrString, err};
        }
        if(nbytes > 10)
        {
            value = value.make_slice(0, 10);
            nbytes = 10;
        }
        if(std::tie(ns, err) = atoi(value.make_slice(1, nbytes)); err != nullptr)
        {
            return {ns, rangeErrString, err};
        }
        if(ns < 0)
        {
            rangeErrString = "fractional second"_s;
            return {ns, rangeErrString, err};
        }
        auto scaleDigits = 10 - nbytes;
        for(auto i = 0; i < scaleDigits; i++)
        {
            ns *= 10;
        }
        return {ns, rangeErrString, err};
    }

    gocpp::error errLeadingInt = errors::New("time: bad [0-9]*"_s);
    // leadingInt consumes the leading [0-9]* from s.
    template<typename bytes>
    std::tuple<uint64_t, bytes, struct gocpp::error> leadingInt(bytes s)
    {
        uint64_t x;
        bytes rem;
        struct gocpp::error err;
        auto i = 0;
        for(; i < len(s); i++)
        {
            auto c = s[i];
            if(c < '0' || c > '9')
            {
                break;
            }
            if(x > (1 << 63) / 10)
            {
                return {0, rem, errLeadingInt};
            }
            x = x * 10 + uint64_t(c) - '0';
            if(x > (1 << 63))
            {
                return {0, rem, errLeadingInt};
            }
        }
        return {x, s.make_slice(i), nullptr};
    }

    // leadingFraction consumes the leading [0-9]* from s.
    // It is used only for fractions, so does not return an error on overflow,
    // it just stops accumulating precision.
    std::tuple<uint64_t, double, gocpp::string> leadingFraction(gocpp::string s)
    {
        uint64_t x;
        double scale;
        gocpp::string rem;
        auto i = 0;
        scale = 1;
        auto overflow = false;
        for(; i < len(s); i++)
        {
            auto c = s[i];
            if(c < '0' || c > '9')
            {
                break;
            }
            if(overflow)
            {
                continue;
            }
            if(x > ((1 << 63) - 1) / 10)
            {
                overflow = true;
                continue;
            }
            auto y = x * 10 + uint64_t(c) - '0';
            if(y > (1 << 63))
            {
                overflow = true;
                continue;
            }
            x = y;
            scale *= 10;
        }
        return {x, scale, s.make_slice(i)};
    }

    gocpp::map<gocpp::string, uint64_t> unitMap = gocpp::map<gocpp::string, uint64_t> {{ "ns"_s, uint64_t(Nanosecond) }, { "us"_s, uint64_t(Microsecond) }, { "µs"_s, uint64_t(Microsecond) }, { "μs"_s, uint64_t(Microsecond) }, { "ms"_s, uint64_t(Millisecond) }, { "s"_s, uint64_t(Second) }, { "m"_s, uint64_t(Minute) }, { "h"_s, uint64_t(Hour) }};
    // ParseDuration parses a duration string.
    // A duration string is a possibly signed sequence of
    // decimal numbers, each with optional fraction and a unit suffix,
    // such as "300ms", "-1.5h" or "2h45m".
    // Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    std::tuple<time::Duration, struct gocpp::error> ParseDuration(gocpp::string s)
    {
        auto orig = s;
        uint64_t d = {};
        auto neg = false;
        if(s != ""_s)
        {
            auto c = s[0];
            if(c == '-' || c == '+')
            {
                neg = c == '-';
                s = s.make_slice(1);
            }
        }
        if(s == "0"_s)
        {
            return {0, nullptr};
        }
        if(s == ""_s)
        {
            return {0, errors::New("time: invalid duration "_s + quote(orig))};
        }
        for(; s != ""_s; )
        {
            uint64_t v = {};
            uint64_t f = {};
            double scale = 1;
            gocpp::error err = {};
            if(! (s[0] == '.' || '0' <= s[0] && s[0] <= '9'))
            {
                return {0, errors::New("time: invalid duration "_s + quote(orig))};
            }
            auto pl = len(s);
            std::tie(v, s, err) = leadingInt(s);
            if(err != nullptr)
            {
                return {0, errors::New("time: invalid duration "_s + quote(orig))};
            }
            auto pre = pl != len(s);
            auto post = false;
            if(s != ""_s && s[0] == '.')
            {
                s = s.make_slice(1);
                auto pl = len(s);
                std::tie(f, scale, s) = leadingFraction(s);
                post = pl != len(s);
            }
            if(! pre && ! post)
            {
                return {0, errors::New("time: invalid duration "_s + quote(orig))};
            }
            auto i = 0;
            for(; i < len(s); i++)
            {
                auto c = s[i];
                if(c == '.' || '0' <= c && c <= '9')
                {
                    break;
                }
            }
            if(i == 0)
            {
                return {0, errors::New("time: missing unit in duration "_s + quote(orig))};
            }
            auto u = s.make_slice(0, i);
            s = s.make_slice(i);
            auto [unit, ok] = unitMap[u];
            if(! ok)
            {
                return {0, errors::New("time: unknown unit "_s + quote(u) + " in duration "_s + quote(orig))};
            }
            if(v > (1 << 63) / unit)
            {
                return {0, errors::New("time: invalid duration "_s + quote(orig))};
            }
            v *= unit;
            if(f > 0)
            {
                v += uint64_t(double(f) * (double(unit) / scale));
                if(v > (1 << 63))
                {
                    return {0, errors::New("time: invalid duration "_s + quote(orig))};
                }
            }
            d += v;
            if(d > (1 << 63))
            {
                return {0, errors::New("time: invalid duration "_s + quote(orig))};
            }
        }
        if(neg)
        {
            return {- Duration(d), nullptr};
        }
        if(d > (1 << 63) - 1)
        {
            return {0, errors::New("time: invalid duration "_s + quote(orig))};
        }
        return {Duration(d), nullptr};
    }

}

