// generated by GoCpp from file '$(ImportDir)/image/color/color.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/image/color/color.fwd.h"
#include "gocpp/support.h"

namespace golang::color
{
    struct Color : gocpp::Interface
    {
        Color(){}
        Color(Color& i) = default;
        Color(const Color& i) = default;
        Color& operator=(Color& i) = default;
        Color& operator=(const Color& i) = default;

        template<typename T>
        Color(T& ref);

        template<typename T>
        Color(const T& ref);

        template<typename T>
        Color(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IColor
        {
            virtual std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> vRGBA() = 0;
        };

        template<typename T, typename StoreT>
        struct ColorImpl : IColor
        {
            explicit ColorImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> vRGBA() override;

            StoreT value;
        };

        std::shared_ptr<IColor> value;
    };

    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(const gocpp::PtrRecv<Color, false>& self);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(const gocpp::ObjRecv<Color>& self);

    std::ostream& operator<<(std::ostream& os, const Color& value);
    struct RGBA
    {
        uint8_t R;
        uint8_t G;
        uint8_t B;
        uint8_t A;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const RGBA& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(RGBA c);
    struct RGBA64
    {
        uint16_t R;
        uint16_t G;
        uint16_t B;
        uint16_t A;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const RGBA64& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(RGBA64 c);
    struct NRGBA
    {
        uint8_t R;
        uint8_t G;
        uint8_t B;
        uint8_t A;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const NRGBA& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(NRGBA c);
    struct NRGBA64
    {
        uint16_t R;
        uint16_t G;
        uint16_t B;
        uint16_t A;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const NRGBA64& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(NRGBA64 c);
    struct Alpha
    {
        uint8_t A;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const Alpha& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(Alpha c);
    struct Alpha16
    {
        uint16_t A;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const Alpha16& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(Alpha16 c);
    struct Gray
    {
        uint8_t Y;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const Gray& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(Gray c);
    struct Gray16
    {
        uint16_t Y;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const Gray16& value);
    std::tuple<uint32_t, uint32_t, uint32_t, uint32_t> RGBA(Gray16 c);
    struct Model : gocpp::Interface
    {
        Model(){}
        Model(Model& i) = default;
        Model(const Model& i) = default;
        Model& operator=(Model& i) = default;
        Model& operator=(const Model& i) = default;

        template<typename T>
        Model(T& ref);

        template<typename T>
        Model(const T& ref);

        template<typename T>
        Model(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IModel
        {
            virtual Color vConvert(Color c) = 0;
        };

        template<typename T, typename StoreT>
        struct ModelImpl : IModel
        {
            explicit ModelImpl(T* ptr)
            {
                value.reset(ptr);
            }

            Color vConvert(Color c) override;

            StoreT value;
        };

        std::shared_ptr<IModel> value;
    };

    Color Convert(const gocpp::PtrRecv<Model, false>& self, Color c);
    Color Convert(const gocpp::ObjRecv<Model>& self, Color c);

    std::ostream& operator<<(std::ostream& os, const Model& value);
    Model ModelFunc(std::function<Color (Color)> f);
    struct modelFunc
    {
        std::function<Color (Color)> f;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const modelFunc& value);
    Color Convert(modelFunc* m, Color c);
    Color rgbaModel(Color c);
    Color rgba64Model(Color c);
    Color nrgbaModel(Color c);
    Color nrgba64Model(Color c);
    Color alphaModel(Color c);
    Color alpha16Model(Color c);
    Color grayModel(Color c);
    Color gray16Model(Color c);
    Color Convert(Palette p, Color c);
    int Index(Palette p, Color c);
    uint32_t sqDiff(uint32_t x, uint32_t y);
    extern Gray16 Black;
    extern Gray16 White;
    extern Alpha16 Transparent;
    extern Alpha16 Opaque;
}

