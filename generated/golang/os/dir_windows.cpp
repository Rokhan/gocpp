// generated by GoCpp from file '$(ImportDir)/os/dir_windows.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/dir_windows.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/symlink_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/internal/syscall/windows/zsyscall_windows.h"
#include "golang/io/fs/format.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir.h"
#include "golang/os/error.h"
#include "golang/os/file_windows.h"
#include "golang/os/path_windows.h"
#include "golang/os/stat_windows.h"
#include "golang/os/types.h"
#include "golang/os/types_windows.h"
#include "golang/runtime/mfinal.h"
#include "golang/sync/cond.h"
#include "golang/sync/mutex.h"
#include "golang/sync/pool.h"
#include "golang/syscall/exec_windows.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/unsafe/unsafe.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using fs::rec::IsDir;
        using fs::rec::Type;
        using sync::rec::Get;
        using sync::rec::Put;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dirInfo::operator T()
    {
        T result;
        result.buf = this->buf;
        result.bufp = this->bufp;
        result.vol = this->vol;
        result.go_class = this->go_class;
        result.path = this->path;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dirInfo::operator==(const T& ref) const
    {
        if (buf != ref.buf) return false;
        if (bufp != ref.bufp) return false;
        if (vol != ref.vol) return false;
        if (go_class != ref.go_class) return false;
        if (path != ref.path) return false;
        return true;
    }

    std::ostream& dirInfo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << buf;
        os << " " << bufp;
        os << " " << vol;
        os << " " << go_class;
        os << " " << path;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dirInfo& value)
    {
        return value.PrintTo(os);
    }

    sync::Pool dirBufPool = gocpp::Init<sync::Pool>([](auto& x) {
        x.New = []() mutable -> go_any
        {
            auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), dirBufSize);
            return & buf;
        };
    });
    void rec::close(struct dirInfo* d)
    {
        if(d->buf != nullptr)
        {
            rec::Put(gocpp::recv(dirBufPool), d->buf);
            d->buf = nullptr;
        }
    }

    bool allowReadDirFileID = true;
    std::tuple<gocpp::slice<std::string>, gocpp::slice<os::DirEntry>, gocpp::slice<os::FileInfo>, struct gocpp::error> rec::readdir(struct File* file, int n, golang::os::readdirMode mode)
    {
        gocpp::slice<std::string> names;
        gocpp::slice<os::DirEntry> dirents;
        gocpp::slice<os::FileInfo> infos;
        struct gocpp::error err;
        if(file->dirinfo == nullptr)
        {
            uint32_t vol = {};
            uint32_t flags = {};
            err = windows::GetVolumeInformationByHandle(file->pfd.Sysfd, nullptr, 0, & vol, nullptr, & flags, nullptr, 0);
            runtime::KeepAlive(file);
            if(err != nullptr)
            {
                err = gocpp::InitPtr<os::PathError>([=](auto& x) {
                    x.Op = "readdir"s;
                    x.Path = file->name;
                    x.Err = err;
                });
                return {names, dirents, infos, err};
            }
            file->dirinfo = new(dirInfo);
            file->dirinfo->buf = gocpp::getValue<[]byte*>(rec::Get(gocpp::recv(dirBufPool)));
            file->dirinfo->vol = vol;
            if(allowReadDirFileID && flags & windows::FILE_SUPPORTS_OPEN_BY_FILE_ID != 0)
            {
                file->dirinfo->go_class = windows::FileIdBothDirectoryRestartInfo;
            }
            else
            {
                file->dirinfo->go_class = windows::FileFullDirectoryRestartInfo;
                file->dirinfo->path = file->name;
                if(! isAbs(file->dirinfo->path))
                {
                    std::tie(file->dirinfo->path, err) = syscall::FullPath(file->dirinfo->path);
                    if(err != nullptr)
                    {
                        err = gocpp::InitPtr<os::PathError>([=](auto& x) {
                            x.Op = "readdir"s;
                            x.Path = file->name;
                            x.Err = err;
                        });
                        return {names, dirents, infos, err};
                    }
                }
            }
        }
        auto d = file->dirinfo;
        auto wantAll = n <= 0;
        if(wantAll)
        {
            n = - 1;
        }
        for(; n != 0; )
        {
            if(d->bufp == 0)
            {
                err = windows::GetFileInformationByHandleEx(file->pfd.Sysfd, d->go_class, (unsigned char*)(unsafe::Pointer(& (*d->buf)[0])), uint32_t(len(*d->buf)));
                runtime::KeepAlive(file);
                if(err != nullptr)
                {
                    if(err == syscall::ERROR_NO_MORE_FILES)
                    {
                        break;
                    }
                    if(err == syscall::ERROR_FILE_NOT_FOUND && (d->go_class == windows::FileIdBothDirectoryRestartInfo || d->go_class == windows::FileFullDirectoryRestartInfo))
                    {
                        break;
                    }
                    if(auto [s, gocpp_id_1] = rec::Stat(gocpp::recv(file)); s != nullptr && ! rec::IsDir(gocpp::recv(s)))
                    {
                        err = gocpp::InitPtr<os::PathError>([=](auto& x) {
                            x.Op = "readdir"s;
                            x.Path = file->name;
                            x.Err = syscall::go_ENOTDIR;
                        });
                    }
                    else
                    {
                        err = gocpp::InitPtr<os::PathError>([=](auto& x) {
                            x.Op = "GetFileInformationByHandleEx"s;
                            x.Path = file->name;
                            x.Err = err;
                        });
                    }
                    return {names, dirents, infos, err};
                }
                if(d->go_class == windows::FileIdBothDirectoryRestartInfo)
                {
                    d->go_class = windows::FileIdBothDirectoryInfo;
                }
                else
                if(d->go_class == windows::FileFullDirectoryRestartInfo)
                {
                    d->go_class = windows::FileFullDirectoryInfo;
                }
            }
            bool islast = {};
            for(; n != 0 && ! islast; )
            {
                uint32_t nextEntryOffset = {};
                gocpp::slice<uint16_t> nameslice = {};
                auto entry = unsafe::Pointer(& (*d->buf)[d->bufp]);
                if(d->go_class == windows::FileIdBothDirectoryInfo)
                {
                    auto info = (windows::FILE_ID_BOTH_DIR_INFO*)(entry);
                    nextEntryOffset = info->NextEntryOffset;
                    nameslice = unsafe::Slice(& info->FileName[0], info->FileNameLength / 2);
                }
                else
                {
                    auto info = (windows::FILE_FULL_DIR_INFO*)(entry);
                    nextEntryOffset = info->NextEntryOffset;
                    nameslice = unsafe::Slice(& info->FileName[0], info->FileNameLength / 2);
                }
                d->bufp += int(nextEntryOffset);
                islast = nextEntryOffset == 0;
                if(islast)
                {
                    d->bufp = 0;
                }
                if((len(nameslice) == 1 && nameslice[0] == '.') || (len(nameslice) == 2 && nameslice[0] == '.' && nameslice[1] == '.'))
                {
                    continue;
                }
                auto name = syscall::UTF16ToString(nameslice);
                if(mode == readdirName)
                {
                    names = append(names, name);
                }
                else
                {
                    fileStat* f = {};
                    if(d->go_class == windows::FileIdBothDirectoryInfo)
                    {
                        f = newFileStatFromFileIDBothDirInfo((windows::FILE_ID_BOTH_DIR_INFO*)(entry));
                    }
                    else
                    {
                        f = newFileStatFromFileFullDirInfo((windows::FILE_FULL_DIR_INFO*)(entry));
                        f->appendNameToPath = true;
                        f->path = d->path;
                    }
                    f->name = name;
                    f->vol = d->vol;
                    if(mode == readdirDirEntry)
                    {
                        dirents = append(dirents, dirEntry {f});
                    }
                    else
                    {
                        infos = append(infos, f);
                    }
                }
                n--;
            }
        }
        if(! wantAll && len(names) + len(dirents) + len(infos) == 0)
        {
            return {nullptr, nullptr, nullptr, io::go_EOF};
        }
        return {names, dirents, infos, nullptr};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    dirEntry::operator T()
    {
        T result;
        result.fs = this->fs;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool dirEntry::operator==(const T& ref) const
    {
        if (fs != ref.fs) return false;
        return true;
    }

    std::ostream& dirEntry::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << fs;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dirEntry& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Name(struct dirEntry de)
    {
        return rec::Name(gocpp::recv(de.fs));
    }

    bool rec::IsDir(struct dirEntry de)
    {
        return rec::IsDir(gocpp::recv(de.fs));
    }

    os::FileMode rec::Type(struct dirEntry de)
    {
        return rec::Type(gocpp::recv(rec::Mode(gocpp::recv(de.fs))));
    }

    std::tuple<os::FileInfo, struct gocpp::error> rec::Info(struct dirEntry de)
    {
        return {de.fs, nullptr};
    }

    std::string rec::String(struct dirEntry de)
    {
        return fs::FormatDirEntry(de);
    }

}

