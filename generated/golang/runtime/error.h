// generated by GoCpp from file '$(ImportDir)/runtime/error.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/error.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"

namespace golang::runtime
{
    struct Error : gocpp::Interface
    {
        Error(){}
        Error(Error& i) = default;
        Error(const Error& i) = default;
        Error& operator=(Error& i) = default;
        Error& operator=(const Error& i) = default;

        template<typename T>
        Error(T& ref);

        template<typename T>
        Error(const T& ref);

        template<typename T>
        Error(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IError
        {
            virtual void vRuntimeError() = 0;
        };

        template<typename T, typename StoreT>
        struct ErrorImpl : IError
        {
            explicit ErrorImpl(T* ptr)
            {
                value.reset(ptr);
            }

            void vRuntimeError() override;

            StoreT value;
        };

        std::shared_ptr<IError> value;
    };

    void RuntimeError(const gocpp::PtrRecv<Error, false>& self);
    void RuntimeError(const gocpp::ObjRecv<Error>& self);

    std::ostream& operator<<(std::ostream& os, const struct Error& value);
    struct TypeAssertionError
    {
        _type* _interface;
        _type* concrete;
        _type* asserted;
        std::string missingMethod;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct TypeAssertionError& value);
    void RuntimeError(TypeAssertionError*);
    std::string Error(struct TypeAssertionError* e);
    gocpp::slice<unsigned char> itoa(gocpp::slice<unsigned char> buf, uint64_t val);
    void RuntimeError(errorString e);
    std::string Error(errorString e);
    struct errorAddressString
    {
        std::string msg;
        uintptr_t addr;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct errorAddressString& value);
    void RuntimeError(struct errorAddressString e);
    std::string Error(struct errorAddressString e);
    uintptr_t Addr(struct errorAddressString e);
    void RuntimeError(plainError e);
    std::string Error(plainError e);
    struct boundsError
    {
        int64_t x;
        int y;
        bool go_signed;
        boundsErrorCode code;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct boundsError& value);
    extern gocpp::array_base<std::string> boundsErrorFmts;
    extern gocpp::array_base<std::string> boundsNegErrorFmts;
    void RuntimeError(struct boundsError e);
    gocpp::slice<unsigned char> appendIntStr(gocpp::slice<unsigned char> b, int64_t v, bool go_signed);
    std::string Error(struct boundsError e);
    struct stringer : gocpp::Interface
    {
        stringer(){}
        stringer(stringer& i) = default;
        stringer(const stringer& i) = default;
        stringer& operator=(stringer& i) = default;
        stringer& operator=(const stringer& i) = default;

        template<typename T>
        stringer(T& ref);

        template<typename T>
        stringer(const T& ref);

        template<typename T>
        stringer(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct Istringer
        {
            virtual std::string vString() = 0;
        };

        template<typename T, typename StoreT>
        struct stringerImpl : Istringer
        {
            explicit stringerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vString() override;

            StoreT value;
        };

        std::shared_ptr<Istringer> value;
    };

    std::string String(const gocpp::PtrRecv<stringer, false>& self);
    std::string String(const gocpp::ObjRecv<stringer>& self);

    std::ostream& operator<<(std::ostream& os, const struct stringer& value);
    void printany(go_any i);
    void printanycustomtype(go_any i);
    void panicwrap();
}

