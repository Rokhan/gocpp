// generated by GoCpp from file '$(ImportDir)/runtime/mbitmap.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mbitmap.h"
#include "gocpp/support.h"

// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/malloc.h"
// #include "golang/runtime/mbitmap_allocheaders.h"  [Ignored, known errors]
#include "golang/runtime/mgcmark.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stack.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    unsigned char* addb(unsigned char* p, uintptr_t n)
    {
        return (*byte)(Pointer(gocpp::recv(unsafe), uintptr(Pointer(gocpp::recv(unsafe), p)) + n));
    }

    unsigned char* subtractb(unsigned char* p, uintptr_t n)
    {
        return (*byte)(Pointer(gocpp::recv(unsafe), uintptr(Pointer(gocpp::recv(unsafe), p)) - n));
    }

    unsigned char* add1(unsigned char* p)
    {
        return (*byte)(Pointer(gocpp::recv(unsafe), uintptr(Pointer(gocpp::recv(unsafe), p)) + 1));
    }

    unsigned char* subtract1(unsigned char* p)
    {
        return (*byte)(Pointer(gocpp::recv(unsafe), uintptr(Pointer(gocpp::recv(unsafe), p)) - 1));
    }

    
    std::ostream& markBits::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << bytep;
        os << " " << mask;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct markBits& value)
    {
        return value.PrintTo(os);
    }

    markBits allocBitsForIndex(struct mspan* s, uintptr_t allocBitIndex)
    {
        auto [bytep, mask] = bitp(gocpp::recv(s->allocBits), allocBitIndex);
        return markBits {bytep, mask, allocBitIndex};
    }

    void refillAllocCache(struct mspan* s, uint16_t whichByte)
    {
        auto bytes = (*gocpp::Tag<gocpp::array<uint8_t, 8>>())(Pointer(gocpp::recv(unsafe), bytep(gocpp::recv(s->allocBits), uintptr(whichByte))));
        auto aCache = uint64_t(0);
        aCache |= uint64_t(bytes[0]);
        aCache |= uint64_t(bytes[1]) << (1 * 8);
        aCache |= uint64_t(bytes[2]) << (2 * 8);
        aCache |= uint64_t(bytes[3]) << (3 * 8);
        aCache |= uint64_t(bytes[4]) << (4 * 8);
        aCache |= uint64_t(bytes[5]) << (5 * 8);
        aCache |= uint64_t(bytes[6]) << (6 * 8);
        aCache |= uint64_t(bytes[7]) << (7 * 8);
        s->allocCache = ^ aCache;
    }

    uint16_t nextFreeIndex(struct mspan* s)
    {
        auto sfreeindex = s->freeindex;
        auto snelems = s->nelems;
        if(sfreeindex == snelems)
        {
            return sfreeindex;
        }
        if(sfreeindex > snelems)
        {
            go_throw("s.freeindex > s.nelems");
        }
        auto aCache = s->allocCache;
        auto bitIndex = TrailingZeros64(gocpp::recv(sys), aCache);
        for(; bitIndex == 64; )
        {
            sfreeindex = (sfreeindex + 64) &^ (64 - 1);
            if(sfreeindex >= snelems)
            {
                s->freeindex = snelems;
                return snelems;
            }
            auto whichByte = sfreeindex / 8;
            refillAllocCache(gocpp::recv(s), whichByte);
            aCache = s->allocCache;
            bitIndex = TrailingZeros64(gocpp::recv(sys), aCache);
        }
        auto result = sfreeindex + uint16_t(bitIndex);
        if(result >= snelems)
        {
            s->freeindex = snelems;
            return snelems;
        }
        s->allocCache >>= (unsigned int)(bitIndex + 1);
        sfreeindex = result + 1;
        if(sfreeindex % 64 == 0 && sfreeindex != snelems)
        {
            auto whichByte = sfreeindex / 8;
            refillAllocCache(gocpp::recv(s), whichByte);
        }
        s->freeindex = sfreeindex;
        return result;
    }

    bool isFree(struct mspan* s, uintptr_t index)
    {
        if(index < uintptr(s->freeIndexForScan))
        {
            return false;
        }
        auto [bytep, mask] = bitp(gocpp::recv(s->allocBits), index);
        return *bytep & mask == 0;
    }

    uintptr_t divideByElemSize(struct mspan* s, uintptr_t n)
    {
        auto doubleCheck = false;
        auto q = uintptr((uint64_t(n) * uint64_t(s->divMul)) >> 32);
        if(doubleCheck && q != n / s->elemsize)
        {
            println(n, "/", s->elemsize, "should be", n / s->elemsize, "but got", q);
            go_throw("bad magic division");
        }
        return q;
    }

    uintptr_t objIndex(struct mspan* s, uintptr_t p)
    {
        return divideByElemSize(gocpp::recv(s), p - base(gocpp::recv(s)));
    }

    markBits markBitsForAddr(uintptr_t p)
    {
        auto s = spanOf(p);
        auto objIndex = objIndex(gocpp::recv(s), p);
        return markBitsForIndex(gocpp::recv(s), objIndex);
    }

    markBits markBitsForIndex(struct mspan* s, uintptr_t objIndex)
    {
        auto [bytep, mask] = bitp(gocpp::recv(s->gcmarkBits), objIndex);
        return markBits {bytep, mask, objIndex};
    }

    markBits markBitsForBase(struct mspan* s)
    {
        return markBits {& s->gcmarkBits->x, uint8_t(1), 0};
    }

    bool isMarked(struct markBits m)
    {
        return *m.bytep & m.mask != 0;
    }

    void setMarked(struct markBits m)
    {
        Or8(gocpp::recv(atomic), m.bytep, m.mask);
    }

    void setMarkedNonAtomic(struct markBits m)
    {
        *m.bytep |= m.mask;
    }

    void clearMarked(struct markBits m)
    {
        And8(gocpp::recv(atomic), m.bytep, ^ m.mask);
    }

    markBits markBitsForSpan(uintptr_t base)
    {
        markBits mbits;
        mbits = markBitsForAddr(base);
        if(mbits.mask != 1)
        {
            markBits mbits;
            go_throw("markBitsForSpan: unaligned start");
        }
        return mbits;
    }

    void advance(struct markBits* m)
    {
        if(m->mask == (1 << 7))
        {
            m->bytep = (*uint8_t)(Pointer(gocpp::recv(unsafe), uintptr(Pointer(gocpp::recv(unsafe), m->bytep)) + 1));
            m->mask = 1;
        }
        else
        {
            m->mask = m->mask << 1;
        }
        m->index++;
    }

    uintptr_t clobberdeadPtr = uintptr(0xdeaddead | (0xdeaddead << ((^ uintptr(0) >> 63) * 32)));
    void badPointer(mspan* s, uintptr_t p, uintptr_t refBase, uintptr_t refOff)
    {
        printlock();
        print("runtime: pointer ", hex(p));
        if(s != nullptr)
        {
            auto state = get(gocpp::recv(s->state));
            if(state != mSpanInUse)
            {
                print(" to unallocated span");
            }
            else
            {
                print(" to unused region of span");
            }
            print(" span.base()=", hex(base(gocpp::recv(s))), " span.limit=", hex(s->limit), " span.state=", state);
        }
        print("\n");
        if(refBase != 0)
        {
            print("runtime: found in object at *(", hex(refBase), "+", hex(refOff), ")\n");
            gcDumpObject("object", refBase, refOff);
        }
        getg()->m->traceback = 2;
        go_throw("found bad pointer in Go heap (incorrect use of unsafe or cgo?)");
    }

    std::tuple<uintptr_t, mspan*, uintptr_t> findObject(uintptr_t p, uintptr_t refBase, uintptr_t refOff)
    {
        uintptr_t base;
        mspan* s;
        uintptr_t objIndex;
        s = spanOf(p);
        if(s == nullptr)
        {
            uintptr_t base;
            mspan* s;
            uintptr_t objIndex;
            if((GOARCH == "amd64" || GOARCH == "arm64") && p == clobberdeadPtr && debug.invalidptr != 0)
            {
                uintptr_t base;
                mspan* s;
                uintptr_t objIndex;
                badPointer(s, p, refBase, refOff);
            }
            return {base, s, objIndex};
        }
        if(auto state = get(gocpp::recv(s->state)); state != mSpanInUse || p < base(gocpp::recv(s)) || p >= s->limit)
        {
            uintptr_t base;
            mspan* s;
            uintptr_t objIndex;
            if(state == mSpanManual)
            {
                uintptr_t base;
                mspan* s;
                uintptr_t objIndex;
                return {base, s, objIndex};
            }
            if(debug.invalidptr != 0)
            {
                uintptr_t base;
                mspan* s;
                uintptr_t objIndex;
                badPointer(s, p, refBase, refOff);
            }
            return {base, s, objIndex};
        }
        objIndex = objIndex(gocpp::recv(s), p);
        base = base(gocpp::recv(s)) + objIndex * s->elemsize;
        return {base, s, objIndex};
    }

    bool reflect_verifyNotInHeapPtr(uintptr_t p)
    {
        return spanOf(p) == nullptr && p != clobberdeadPtr;
    }

    int ptrBits = 8 * goarch.PtrSize;
    void bulkBarrierBitmap(uintptr_t dst, uintptr_t src, uintptr_t size, uintptr_t maskOffset, uint8_t* bits)
    {
        auto word = maskOffset / goarch.PtrSize;
        bits = addb(bits, word / 8);
        auto mask = uint8_t(1) << (word % 8);
        auto buf = & ptr(gocpp::recv(getg()->m->p))->wbBuf;
        for(auto i = uintptr(0); i < size; i += goarch.PtrSize)
        {
            if(mask == 0)
            {
                bits = addb(bits, 1);
                if(*bits == 0)
                {
                    i += 7 * goarch.PtrSize;
                    continue;
                }
                mask = 1;
            }
            if(*bits & mask != 0)
            {
                auto dstx = (*uintptr)(Pointer(gocpp::recv(unsafe), dst + i));
                if(src == 0)
                {
                    auto p = get1(gocpp::recv(buf));
                    p[0] = *dstx;
                }
                else
                {
                    auto srcx = (*uintptr)(Pointer(gocpp::recv(unsafe), src + i));
                    auto p = get2(gocpp::recv(buf));
                    p[0] = *dstx;
                    p[1] = *srcx;
                }
            }
            mask <<= 1;
        }
    }

    void typeBitsBulkBarrier(_type* typ, uintptr_t dst, uintptr_t src, uintptr_t size)
    {
        if(typ == nullptr)
        {
            go_throw("runtime: typeBitsBulkBarrier without type");
        }
        if(typ->Size_ != size)
        {
            println("runtime: typeBitsBulkBarrier with type ", string(gocpp::recv(toRType(typ))), " of size ", typ->Size_, " but memory size", size);
            go_throw("runtime: invalid typeBitsBulkBarrier");
        }
        if(typ->Kind_ & kindGCProg != 0)
        {
            println("runtime: typeBitsBulkBarrier with type ", string(gocpp::recv(toRType(typ))), " with GC prog");
            go_throw("runtime: invalid typeBitsBulkBarrier");
        }
        if(! writeBarrier.enabled)
        {
            return;
        }
        auto ptrmask = typ->GCData;
        auto buf = & ptr(gocpp::recv(getg()->m->p))->wbBuf;
        uint32_t bits = {};
        for(auto i = uintptr(0); i < typ->PtrBytes; i += goarch.PtrSize)
        {
            if(i & (goarch.PtrSize * 8 - 1) == 0)
            {
                bits = uint32_t(*ptrmask);
                ptrmask = addb(ptrmask, 1);
            }
            else
            {
                bits = bits >> 1;
            }
            if(bits & 1 != 0)
            {
                auto dstx = (*uintptr)(Pointer(gocpp::recv(unsafe), dst + i));
                auto srcx = (*uintptr)(Pointer(gocpp::recv(unsafe), src + i));
                auto p = get2(gocpp::recv(buf));
                p[0] = *dstx;
                p[1] = *srcx;
            }
        }
    }

    int countAlloc(struct mspan* s)
    {
        auto count = 0;
        auto bytes = divRoundUp(uintptr(s->nelems), 8);
        for(auto i = uintptr(0); i < bytes; i += 8)
        {
            auto mrkBits = *(*uint64_t)(Pointer(gocpp::recv(unsafe), bytep(gocpp::recv(s->gcmarkBits), i)));
            count += OnesCount64(gocpp::recv(sys), mrkBits);
        }
        return count;
    }

    uintptr_t readUintptr(unsigned char* p)
    {
        auto x = *(*uintptr)(Pointer(gocpp::recv(unsafe), p));
        if(goarch.BigEndian)
        {
            if(goarch.PtrSize == 8)
            {
                return uintptr(Bswap64(gocpp::recv(sys), uint64_t(x)));
            }
            return uintptr(Bswap32(gocpp::recv(sys), uint32_t(x)));
        }
        return x;
    }

    struct gocpp_id_0
    {
        mutex lock;
        unsigned char* data;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << data;
            os << '}';
            return os;
        }
    };
    gocpp_id_0 debugPtrmask;
    bitvector progToPointerMask(unsigned char* prog, uintptr_t size)
    {
        auto n = (size / goarch.PtrSize + 7) / 8;
        auto x = (*gocpp::Tag<gocpp::array<unsigned char, 1 << 30>>())(persistentalloc(n + 1, 1, & memstats.buckhash_sys)).make_slice(0, n + 1);
        x[len(x) - 1] = 0xa1;
        n = runGCProg(prog, & x[0]);
        if(x[len(x) - 1] != 0xa1)
        {
            go_throw("progToPointerMask: overflow");
        }
        return bitvector {int32(n), & x[0]};
    }

    uintptr_t runGCProg(unsigned char* prog, unsigned char* dst)
    {
        auto dstStart = dst;
        uintptr_t bits = {};
        uintptr_t nbits = {};
        auto p = prog;
        for(; ; )
        {
            for(; nbits >= 8; nbits -= 8)
            {
                *dst = uint8_t(bits);
                dst = add1(dst);
                bits >>= 8;
            }
            auto inst = uintptr(*p);
            p = add1(p);
            auto n = inst & 0x7F;
            if(inst & 0x80 == 0)
            {
                if(n == 0)
                {
                    goto Run_break;
                }
                auto nbyte = n / 8;
                for(auto i = uintptr(0); i < nbyte; i++)
                {
                    bits |= uintptr(*p) << nbits;
                    p = add1(p);
                    *dst = uint8_t(bits);
                    dst = add1(dst);
                    bits >>= 8;
                }
                if(n %= 8; n > 0)
                {
                    bits |= uintptr(*p) << nbits;
                    p = add1(p);
                    nbits += n;
                }
                goto Run_continue;
            }
            if(n == 0)
            {
                for(auto off = (unsigned int)(0); ; off += 7)
                {
                    auto x = uintptr(*p);
                    p = add1(p);
                    n |= (x & 0x7F) << off;
                    if(x & 0x80 == 0)
                    {
                        break;
                    }
                }
            }
            auto c = uintptr(0);
            for(auto off = (unsigned int)(0); ; off += 7)
            {
                auto x = uintptr(*p);
                p = add1(p);
                c |= (x & 0x7F) << off;
                if(x & 0x80 == 0)
                {
                    break;
                }
            }
            c *= n;
            auto src = dst;
            auto maxBits = goarch.PtrSize * 8 - 7;
            if(n <= maxBits)
            {
                auto pattern = bits;
                auto npattern = nbits;
                src = subtract1(src);
                for(; npattern < n; )
                {
                    pattern <<= 8;
                    pattern |= uintptr(*src);
                    src = subtract1(src);
                    npattern += 8;
                }
                if(npattern > n)
                {
                    pattern >>= npattern - n;
                    npattern = n;
                }
                if(npattern == 1)
                {
                    if(pattern == 1)
                    {
                        pattern = (1 << maxBits) - 1;
                        npattern = maxBits;
                    }
                    else
                    {
                        npattern = c;
                    }
                }
                else
                {
                    auto b = pattern;
                    auto nb = npattern;
                    if(nb + nb <= maxBits)
                    {
                        for(; nb <= goarch.PtrSize * 8; )
                        {
                            b |= b << nb;
                            nb += nb;
                        }
                        nb = maxBits / npattern * npattern;
                        b &= (1 << nb) - 1;
                        pattern = b;
                        npattern = nb;
                    }
                }
                for(; c >= npattern; c -= npattern)
                {
                    bits |= pattern << nbits;
                    nbits += npattern;
                    for(; nbits >= 8; )
                    {
                        *dst = uint8_t(bits);
                        dst = add1(dst);
                        bits >>= 8;
                        nbits -= 8;
                    }
                }
                if(c > 0)
                {
                    pattern &= (1 << c) - 1;
                    bits |= pattern << nbits;
                    nbits += c;
                }
                goto Run_continue;
            }
            auto off = n - nbits;
            src = subtractb(src, (off + 7) / 8);
            if(auto frag = off & 7; frag != 0)
            {
                bits |= (uintptr(*src) >> (8 - frag)) << nbits;
                src = add1(src);
                nbits += frag;
                c -= frag;
            }
            for(auto i = c / 8; i > 0; i--)
            {
                bits |= uintptr(*src) << nbits;
                src = add1(src);
                *dst = uint8_t(bits);
                dst = add1(dst);
                bits >>= 8;
            }
            if(c %= 8; c > 0)
            {
                bits |= (uintptr(*src) & ((1 << c) - 1)) << nbits;
                nbits += c;
            }
            if(false) {
            Run_continue:
                continue;
            Run_break:
                break;
            }
        }
        auto totalBits = (uintptr(Pointer(gocpp::recv(unsafe), dst)) - uintptr(Pointer(gocpp::recv(unsafe), dstStart))) * 8 + nbits;
        nbits += - nbits & 7;
        for(; nbits > 0; nbits -= 8)
        {
            *dst = uint8_t(bits);
            dst = add1(dst);
            bits >>= 8;
        }
        return totalBits;
    }

    mspan* materializeGCProg(uintptr_t ptrdata, unsigned char* prog)
    {
        auto bitmapBytes = divRoundUp(ptrdata, 8 * goarch.PtrSize);
        auto pages = divRoundUp(bitmapBytes, pageSize);
        auto s = allocManual(gocpp::recv(mheap_), pages, spanAllocPtrScalarBits);
        runGCProg(addb(prog, 4), (*byte)(Pointer(gocpp::recv(unsafe), s->startAddr)));
        return s;
    }

    void dematerializeGCProg(mspan* s)
    {
        freeManual(gocpp::recv(mheap_), s, spanAllocPtrScalarBits);
    }

    void dumpGCProg(unsigned char* p)
    {
        auto nptr = 0;
        for(; ; )
        {
            auto x = *p;
            p = add1(p);
            if(x == 0)
            {
                print("\t", nptr, " end\n");
                break;
            }
            if(x & 0x80 == 0)
            {
                print("\t", nptr, " lit ", x, ":");
                auto n = int(x + 7) / 8;
                for(auto i = 0; i < n; i++)
                {
                    print(" ", hex(*p));
                    p = add1(p);
                }
                print("\n");
                nptr += int(x);
            }
            else
            {
                auto nbit = int(x &^ 0x80);
                if(nbit == 0)
                {
                    for(auto nb = (unsigned int)(0); ; nb += 7)
                    {
                        auto x = *p;
                        p = add1(p);
                        nbit |= int(x & 0x7f) << nb;
                        if(x & 0x80 == 0)
                        {
                            break;
                        }
                    }
                }
                auto count = 0;
                for(auto nb = (unsigned int)(0); ; nb += 7)
                {
                    auto x = *p;
                    p = add1(p);
                    count |= int(x & 0x7f) << nb;
                    if(x & 0x80 == 0)
                    {
                        break;
                    }
                }
                print("\t", nptr, " repeat ", nbit, " × ", count, "\n");
                nptr += nbit * count;
            }
        }
    }

    gocpp::slice<unsigned char> reflect_gcbits(go_any x)
    {
        return getgcmask(x);
    }

}

