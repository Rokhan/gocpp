// generated by GoCpp from file '$(ImportDir)/os/dir.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/dir.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/io/fs/fs.h"
#include "golang/os/dir_windows.h"
#include "golang/os/file.h"
#include "golang/os/file_posix.h"
#include "golang/os/file_windows.h"
#include "golang/os/types.h"
#include "golang/sort/slice.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using fs::rec::Name;
    }

    std::tuple<gocpp::slice<os::FileInfo>, struct gocpp::error> rec::Readdir(struct File* f, int n)
    {
        if(f == nullptr)
        {
            return {nullptr, ErrInvalid};
        }
        auto [gocpp_id_2, gocpp_id_3, infos, err] = rec::readdir(gocpp::recv(f), n, readdirFileInfo);
        if(infos == nullptr)
        {
            infos = gocpp::slice<os::FileInfo> {};
        }
        return {infos, err};
    }

    std::tuple<gocpp::slice<std::string>, struct gocpp::error> rec::Readdirnames(struct File* f, int n)
    {
        gocpp::slice<std::string> names;
        struct gocpp::error err;
        if(f == nullptr)
        {
            gocpp::slice<std::string> names;
            struct gocpp::error err;
            return {nullptr, ErrInvalid};
        }
        std::tie(names, gocpp_id_4, gocpp_id_5, err) = rec::readdir(gocpp::recv(f), n, readdirName);
        if(names == nullptr)
        {
            gocpp::slice<std::string> names;
            struct gocpp::error err;
            names = gocpp::slice<std::string> {};
        }
        return {names, err};
    }

    std::tuple<gocpp::slice<os::DirEntry>, struct gocpp::error> rec::ReadDir(struct File* f, int n)
    {
        if(f == nullptr)
        {
            return {nullptr, ErrInvalid};
        }
        auto [gocpp_id_8, dirents, gocpp_id_9, err] = rec::readdir(gocpp::recv(f), n, readdirDirEntry);
        if(dirents == nullptr)
        {
            dirents = gocpp::slice<os::DirEntry> {};
        }
        return {dirents, err};
    }

    bool testingForceReadDirLstat;
    std::tuple<gocpp::slice<os::DirEntry>, struct gocpp::error> ReadDir(std::string name)
    {
        gocpp::Defer defer;
        try
        {
            auto [f, err] = Open(name);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(f)); });
            fs::DirEntry> dirs;
            std::tie(dirs, err) = rec::ReadDir(gocpp::recv(f), - 1);
            sort::Slice(dirs, [=](int i, int j) mutable -> bool
            {
                return rec::Name(gocpp::recv(dirs[i])) < rec::Name(gocpp::recv(dirs[j]));
            });
            return {dirs, err};
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

}

