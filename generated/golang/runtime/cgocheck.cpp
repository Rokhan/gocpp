// generated by GoCpp from file '$(ImportDir)/runtime/cgocheck.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/cgocheck.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    gocpp::string cgoWriteBarrierFail = "unpinned Go pointer stored into non-Go memory"_s;
    // cgoCheckPtrWrite is called whenever a pointer is stored into memory.
    // It throws if the program is storing an unpinned Go pointer into non-Go
    // memory.
    //
    // This is called from generated code when GOEXPERIMENT=cgocheck2 is enabled.
    //
    //go:nosplit
    //go:nowritebarrier
    void cgoCheckPtrWrite(unsafe::Pointer* dst, unsafe::Pointer src)
    {
        if(! mainStarted)
        {
            return;
        }
        if(! cgoIsGoPointer(src))
        {
            return;
        }
        if(cgoIsGoPointer(unsafe::Pointer(dst)))
        {
            return;
        }
        auto gp = getg();
        if(gp == gp->m->g0 || gp == gp->m->gsignal)
        {
            return;
        }
        if(gp->m->mallocing != 0)
        {
            return;
        }
        if(isPinned(src))
        {
            return;
        }
        if(inPersistentAlloc(uintptr_t(unsafe::Pointer(dst))))
        {
            return;
        }
        systemstack([=]() mutable -> void
        {
            println("write of unpinned Go pointer"_s, hex(uintptr_t(src)), "to non-Go memory"_s, hex(uintptr_t(unsafe::Pointer(dst))));
            go_throw(cgoWriteBarrierFail);
        });
    }

    // cgoCheckMemmove is called when moving a block of memory.
    // It throws if the program is copying a block that contains an unpinned Go
    // pointer into non-Go memory.
    //
    // This is called from generated code when GOEXPERIMENT=cgocheck2 is enabled.
    //
    //go:nosplit
    //go:nowritebarrier
    void cgoCheckMemmove(golang::runtime::_type* typ, unsafe::Pointer dst, unsafe::Pointer src)
    {
        cgoCheckMemmove2(typ, dst, src, 0, typ->Size_);
    }

    // cgoCheckMemmove2 is called when moving a block of memory.
    // dst and src point off bytes into the value to copy.
    // size is the number of bytes to copy.
    // It throws if the program is copying a block that contains an unpinned Go
    // pointer into non-Go memory.
    //
    //go:nosplit
    //go:nowritebarrier
    void cgoCheckMemmove2(golang::runtime::_type* typ, unsafe::Pointer dst, unsafe::Pointer src, uintptr_t off, uintptr_t size)
    {
        if(typ->PtrBytes == 0)
        {
            return;
        }
        if(! cgoIsGoPointer(src))
        {
            return;
        }
        if(cgoIsGoPointer(dst))
        {
            return;
        }
        cgoCheckTypedBlock(typ, src, off, size);
    }

    // cgoCheckSliceCopy is called when copying n elements of a slice.
    // src and dst are pointers to the first element of the slice.
    // typ is the element type of the slice.
    // It throws if the program is copying slice elements that contain unpinned Go
    // pointers into non-Go memory.
    //
    //go:nosplit
    //go:nowritebarrier
    void cgoCheckSliceCopy(golang::runtime::_type* typ, unsafe::Pointer dst, unsafe::Pointer src, int n)
    {
        if(typ->PtrBytes == 0)
        {
            return;
        }
        if(! cgoIsGoPointer(src))
        {
            return;
        }
        if(cgoIsGoPointer(dst))
        {
            return;
        }
        auto p = src;
        for(auto i = 0; i < n; i++)
        {
            cgoCheckTypedBlock(typ, p, 0, typ->Size_);
            p = add(p, typ->Size_);
        }
    }

    // cgoCheckTypedBlock checks the block of memory at src, for up to size bytes,
    // and throws if it finds an unpinned Go pointer. The type of the memory is typ,
    // and src is off bytes into that type.
    //
    //go:nosplit
    //go:nowritebarrier
    void cgoCheckTypedBlock(golang::runtime::_type* typ, unsafe::Pointer src, uintptr_t off, uintptr_t size)
    {
        if(typ->PtrBytes <= off)
        {
            return;
        }
        if(auto ptrdataSize = typ->PtrBytes - off; size > ptrdataSize)
        {
            size = ptrdataSize;
        }
        if(typ->Kind_ & kindGCProg == 0)
        {
            cgoCheckBits(src, typ->GCData, off, size);
            return;
        }
        for(auto [gocpp_ignored, datap] : activeModules())
        {
            if(cgoInRange(src, datap->data, datap->edata))
            {
                auto doff = uintptr_t(src) - datap->data;
                cgoCheckBits(add(src, - doff), datap->gcdatamask.bytedata, off + doff, size);
                return;
            }
            if(cgoInRange(src, datap->bss, datap->ebss))
            {
                auto boff = uintptr_t(src) - datap->bss;
                cgoCheckBits(add(src, - boff), datap->gcbssmask.bytedata, off + boff, size);
                return;
            }
        }
        auto s = spanOfUnchecked(uintptr_t(src));
        if(rec::get(gocpp::recv(s->state)) == mSpanManual)
        {
            systemstack([=]() mutable -> void
            {
                cgoCheckUsingType(typ, src, off, size);
            });
            return;
        }
        if(goexperiment::AllocHeaders)
        {
            auto tp = rec::typePointersOf(gocpp::recv(s), uintptr_t(src), size);
            for(; ; )
            {
                uintptr_t addr = {};
                if(std::tie(tp, addr) = rec::next(gocpp::recv(tp), uintptr_t(src) + size); addr == 0)
                {
                    break;
                }
                auto v = *(unsafe::Pointer*)(unsafe::Pointer(addr));
                if(cgoIsGoPointer(v) && ! isPinned(v))
                {
                    go_throw(cgoWriteBarrierFail);
                }
            }
        }
        else
        {
            auto hbits = heapBitsForAddr(uintptr_t(src), size);
            for(; ; )
            {
                uintptr_t addr = {};
                if(std::tie(hbits, addr) = rec::next(gocpp::recv(hbits)); addr == 0)
                {
                    break;
                }
                auto v = *(unsafe::Pointer*)(unsafe::Pointer(addr));
                if(cgoIsGoPointer(v) && ! isPinned(v))
                {
                    go_throw(cgoWriteBarrierFail);
                }
            }
        }
    }

    // cgoCheckBits checks the block of memory at src, for up to size
    // bytes, and throws if it finds an unpinned Go pointer. The gcbits mark each
    // pointer value. The src pointer is off bytes into the gcbits.
    //
    //go:nosplit
    //go:nowritebarrier
    void cgoCheckBits(unsafe::Pointer src, unsigned char* gcbits, uintptr_t off, uintptr_t size)
    {
        auto skipMask = off / goarch::PtrSize / 8;
        auto skipBytes = skipMask * goarch::PtrSize * 8;
        auto ptrmask = addb(gcbits, skipMask);
        src = add(src, skipBytes);
        off -= skipBytes;
        size += off;
        uint32_t bits = {};
        for(auto i = uintptr_t(0); i < size; i += goarch::PtrSize)
        {
            if(i & (goarch::PtrSize * 8 - 1) == 0)
            {
                bits = uint32_t(*ptrmask);
                ptrmask = addb(ptrmask, 1);
            }
            else
            {
                bits >>= 1;
            }
            if(off > 0)
            {
                off -= goarch::PtrSize;
            }
            else
            {
                if(bits & 1 != 0)
                {
                    auto v = *(unsafe::Pointer*)(add(src, i));
                    if(cgoIsGoPointer(v) && ! isPinned(v))
                    {
                        go_throw(cgoWriteBarrierFail);
                    }
                }
            }
        }
    }

    // cgoCheckUsingType is like cgoCheckTypedBlock, but is a last ditch
    // fall back to look for pointers in src using the type information.
    // We only use this when looking at a value on the stack when the type
    // uses a GC program, because otherwise it's more efficient to use the
    // GC bits. This is called on the system stack.
    //
    //go:nowritebarrier
    //go:systemstack
    void cgoCheckUsingType(golang::runtime::_type* typ, unsafe::Pointer src, uintptr_t off, uintptr_t size)
    {
        if(typ->PtrBytes == 0)
        {
            return;
        }
        if(typ->PtrBytes <= off)
        {
            return;
        }
        if(auto ptrdataSize = typ->PtrBytes - off; size > ptrdataSize)
        {
            size = ptrdataSize;
        }
        if(typ->Kind_ & kindGCProg == 0)
        {
            cgoCheckBits(src, typ->GCData, off, size);
            return;
        }
        //Go switch emulation
        {
            auto condition = typ->Kind_ & kindMask;
            int conditionId = -1;
            if(condition == kindArray) { conditionId = 0; }
            else if(condition == kindStruct) { conditionId = 1; }
            switch(conditionId)
            {
                default:
                    go_throw("can't happen"_s);
                    break;
                case 0:
                    auto at = (runtime::arraytype*)(unsafe::Pointer(typ));
                    for(auto i = uintptr_t(0); i < at->Len; i++)
                    {
                        if(off < at->Elem->Size_)
                        {
                            cgoCheckUsingType(at->Elem, src, off, size);
                        }
                        src = add(src, at->Elem->Size_);
                        auto skipped = off;
                        if(skipped > at->Elem->Size_)
                        {
                            skipped = at->Elem->Size_;
                        }
                        auto checked = at->Elem->Size_ - skipped;
                        off -= skipped;
                        if(size <= checked)
                        {
                            return;
                        }
                        size -= checked;
                    }
                    break;
                case 1:
                    auto st = (runtime::structtype*)(unsafe::Pointer(typ));
                    for(auto [gocpp_ignored, f] : st->Fields)
                    {
                        if(off < f.Typ->Size_)
                        {
                            cgoCheckUsingType(f.Typ, src, off, size);
                        }
                        src = add(src, f.Typ->Size_);
                        auto skipped = off;
                        if(skipped > f.Typ->Size_)
                        {
                            skipped = f.Typ->Size_;
                        }
                        auto checked = f.Typ->Size_ - skipped;
                        off -= skipped;
                        if(size <= checked)
                        {
                            return;
                        }
                        size -= checked;
                    }
                    break;
            }
        }
    }

}

