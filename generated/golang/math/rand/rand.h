// generated by GoCpp from file '$(ImportDir)/math/rand/rand.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/math/rand/rand.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/bisect/bisect.h"
#include "golang/internal/godebug/godebug.h"
#include "golang/internal/godebugs/table.h"
#include "golang/math/rand/rng.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

namespace golang::rand
{
    struct Source : gocpp::Interface
    {
        Source(){}
        Source(Source& i) = default;
        Source(const Source& i) = default;
        Source& operator=(Source& i) = default;
        Source& operator=(const Source& i) = default;

        template<typename T>
        Source(T& ref);

        template<typename T>
        Source(const T& ref);

        template<typename T>
        Source(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct ISource
        {
            virtual int64_t vInt63() = 0;
            virtual void vSeed(int64_t seed) = 0;
        };

        template<typename T, typename StoreT>
        struct SourceImpl : ISource
        {
            explicit SourceImpl(T* ptr)
            {
                value.reset(ptr);
            }

            int64_t vInt63() override;

            void vSeed(int64_t seed) override;

            StoreT value;
        };

        std::shared_ptr<ISource> value;
    };

    int64_t Int63(const gocpp::PtrRecv<Source, false>& self);
    int64_t Int63(const gocpp::ObjRecv<Source>& self);

    void Seed(const gocpp::PtrRecv<Source, false>& self, int64_t seed);
    void Seed(const gocpp::ObjRecv<Source>& self, int64_t seed);

    std::ostream& operator<<(std::ostream& os, const struct Source& value);
    struct Source64 : gocpp::Interface
    {
        Source64(){}
        Source64(Source64& i) = default;
        Source64(const Source64& i) = default;
        Source64& operator=(Source64& i) = default;
        Source64& operator=(const Source64& i) = default;

        template<typename T>
        Source64(T& ref);

        template<typename T>
        Source64(const T& ref);

        template<typename T>
        Source64(T* ptr);

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct ISource64
        {
            virtual uint64_t vUint64() = 0;
        };

        template<typename T, typename StoreT>
        struct Source64Impl : ISource64
        {
            explicit Source64Impl(T* ptr)
            {
                value.reset(ptr);
            }

            uint64_t vUint64() override;

            StoreT value;
        };

        std::shared_ptr<ISource64> value;
    };

    uint64_t Uint64(const gocpp::PtrRecv<Source64, false>& self);
    uint64_t Uint64(const gocpp::ObjRecv<Source64>& self);

    std::ostream& operator<<(std::ostream& os, const struct Source64& value);
    Source NewSource(int64_t seed);
    rngSource* newSource(int64_t seed);
    struct Rand
    {
        Source src;
        Source64 s64;
        int64_t readVal;
        int8_t readPos;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Rand& value);
    Rand* New(Source src);
    void Seed(struct Rand* r, int64_t seed);
    int64_t Int63(struct Rand* r);
    uint32_t Uint32(struct Rand* r);
    uint64_t Uint64(struct Rand* r);
    int32_t Int31(struct Rand* r);
    int Int(struct Rand* r);
    int64_t Int63n(struct Rand* r, int64_t n);
    int32_t Int31n(struct Rand* r, int32_t n);
    int32_t int31n(struct Rand* r, int32_t n);
    int Intn(struct Rand* r, int n);
    double Float64(struct Rand* r);
    double Float32(struct Rand* r);
    gocpp::slice<int> Perm(struct Rand* r, int n);
    void Shuffle(struct Rand* r, int n, std::function<void (int i, int j)> swap);
    std::tuple<int, std::string> Read(struct Rand* r, gocpp::slice<unsigned char> p);
    std::tuple<int, std::string> read(gocpp::slice<unsigned char> p, Source src, int64_t* readVal, int8_t* readPos);
    extern godebug::Setting* randautoseed;
    Rand* globalRand();
    uint64_t runtime_rand();
    struct runtimeSource
    {
        mocklib::Mutex mu;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct runtimeSource& value);
    int64_t Int63(runtimeSource*);
    void Seed(runtimeSource*, int64_t);
    uint64_t Uint64(runtimeSource*);
    std::tuple<int, std::string> read(struct runtimeSource* fs, gocpp::slice<unsigned char> p, int64_t* readVal, int8_t* readPos);
    void Seed(int64_t seed);
    int64_t Int63();
    uint32_t Uint32();
    uint64_t Uint64();
    int32_t Int31();
    int Int();
    int64_t Int63n(int64_t n);
    int32_t Int31n(int32_t n);
    int Intn(int n);
    double Float64();
    double Float32();
    gocpp::slice<int> Perm(int n);
    void Shuffle(int n, std::function<void (int i, int j)> swap);
    std::tuple<int, std::string> Read(gocpp::slice<unsigned char> p);
    double NormFloat64();
    double ExpFloat64();
    struct lockedSource
    {
        mocklib::Mutex lk;
        rngSource* s;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct lockedSource& value);
    int64_t Int63(struct lockedSource* r);
    uint64_t Uint64(struct lockedSource* r);
    void Seed(struct lockedSource* r, int64_t seed);
    void seedPos(struct lockedSource* r, int64_t seed, int8_t* readPos);
    void seed(struct lockedSource* r, int64_t seed);
    std::tuple<int, std::string> read(struct lockedSource* r, gocpp::slice<unsigned char> p, int64_t* readVal, int8_t* readPos);
}

