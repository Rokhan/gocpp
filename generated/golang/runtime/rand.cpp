// generated by GoCpp from file '$(ImportDir)/runtime/rand.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/rand.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/zgoarch_amd64.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/math/math.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using chacha8rand::rec::Init;
        using chacha8rand::rec::Init64;
        using chacha8rand::rec::Next;
        using chacha8rand::rec::Refill;
        using chacha8rand::rec::Reseed;
    }

    // OS-specific startup can set startupRand if the OS passes
    // random data to the process at startup time.
    // For example Linux passes 16 bytes in the auxv vector.
    gocpp::slice<unsigned char> startupRand;
    struct gocpp_id_0
    {
        mutex lock;
        gocpp::array<unsigned char, 32> seed;
        chacha8rand::State state;
        bool init;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.lock = this->lock;
            result.seed = this->seed;
            result.state = this->state;
            result.init = this->init;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (lock != ref.lock) return false;
            if (seed != ref.seed) return false;
            if (state != ref.state) return false;
            if (init != ref.init) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << seed;
            os << " " << state;
            os << " " << init;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_0& value)
    {
        return value.PrintTo(os);
    }


    // globalRand holds the global random state.
    // It is only used at startup and for creating new m's.
    // Otherwise the per-m random state should be used
    // by calling goodrand.
    gocpp_id_0 globalRand;
    bool readRandomFailed;
    // randinit initializes the global random state.
    // It must be called before any use of grand.
    void randinit()
    {
        lock(& globalRand.lock);
        if(globalRand.init)
        {
            fatal("randinit twice"s);
        }
        auto seed = & globalRand.seed;
        if(startupRand != nullptr)
        {
            for(auto [i, c] : startupRand)
            {
                seed[i % len(seed)] ^= c;
            }
            clear(startupRand);
            startupRand = nullptr;
        }
        else
        {
            if(readRandom(seed.make_slice(0)) != len(seed))
            {
                readRandomFailed = true;
                readTimeRandom(seed.make_slice(0));
            }
        }
        rec::Init(gocpp::recv(globalRand.state), *seed);
        clear(seed.make_slice(0));
        globalRand.init = true;
        unlock(& globalRand.lock);
    }

    // readTimeRandom stretches any entropy in the current time
    // into entropy the length of r and XORs it into r.
    // This is a fallback for when readRandom does not read
    // the full requested amount.
    // Whatever entropy r already contained is preserved.
    void readTimeRandom(gocpp::slice<unsigned char> r)
    {
        auto v = uint64_t(nanotime());
        for(; len(r) > 0; )
        {
            v ^= 0xa0761d6478bd642f;
            v *= 0xe7037ed1a0b428db;
            auto size = 8;
            if(len(r) < 8)
            {
                size = len(r);
            }
            for(auto i = 0; i < size; i++)
            {
                r[i] ^= (unsigned char)(v >> (8 * i));
            }
            r = r.make_slice(size);
            v = (v >> 32) | (v << 32);
        }
    }

    // bootstrapRand returns a random uint64 from the global random generator.
    uint64_t bootstrapRand()
    {
        lock(& globalRand.lock);
        if(! globalRand.init)
        {
            fatal("randinit missed"s);
        }
        for(; ; )
        {
            if(auto [x, ok] = rec::Next(gocpp::recv(globalRand.state)); ok)
            {
                unlock(& globalRand.lock);
                return x;
            }
            rec::Refill(gocpp::recv(globalRand.state));
        }
    }

    // bootstrapRandReseed reseeds the bootstrap random number generator,
    // clearing from memory any trace of previously returned random numbers.
    void bootstrapRandReseed()
    {
        lock(& globalRand.lock);
        if(! globalRand.init)
        {
            fatal("randinit missed"s);
        }
        rec::Reseed(gocpp::recv(globalRand.state));
        unlock(& globalRand.lock);
    }

    // rand32 is uint32(rand()), called from compiler-generated code.
    //go:nosplit
    uint32_t rand32()
    {
        return uint32_t(rand());
    }

    // rand returns a random uint64 from the per-m chacha8 state.
    // Do not change signature: used via linkname from other packages.
    //go:nosplit
    //go:linkname rand
    uint64_t rand()
    {
        auto mp = getg()->m;
        auto c = & mp->chacha8;
        for(; ; )
        {
            auto [x, ok] = rec::Next(gocpp::recv(c));
            if(ok)
            {
                return x;
            }
            mp->locks++;
            rec::Refill(gocpp::recv(c));
            mp->locks--;
        }
    }

    // mrandinit initializes the random state of an m.
    void mrandinit(struct m* mp)
    {
        gocpp::array<uint64_t, 4> seed = {};
        for(auto [i, gocpp_ignored] : seed)
        {
            seed[i] = bootstrapRand();
        }
        bootstrapRandReseed();
        rec::Init64(gocpp::recv(mp->chacha8), seed);
        mp->cheaprand = rand();
    }

    // randn is like rand() % n but faster.
    // Do not change signature: used via linkname from other packages.
    //go:nosplit
    //go:linkname randn
    uint32_t randn(uint32_t n)
    {
        return uint32_t((uint64_t(uint32_t(rand())) * uint64_t(n)) >> 32);
    }

    // cheaprand is a non-cryptographic-quality 32-bit random generator
    // suitable for calling at very high frequency (such as during scheduling decisions)
    // and at sensitive moments in the runtime (such as during stack unwinding).
    // it is "cheap" in the sense of both expense and quality.
    //
    // cheaprand must not be exported to other packages:
    // the rule is that other packages using runtime-provided
    // randomness must always use rand.
    //go:nosplit
    uint32_t cheaprand()
    {
        auto mp = getg()->m;
        if(goarch::IsAmd64 | goarch::IsArm64 | goarch::IsPpc64 | goarch::IsPpc64le | goarch::IsMips64 | goarch::IsMips64le | goarch::IsS390x | goarch::IsRiscv64 | goarch::IsLoong64 == 1)
        {
            mp->cheaprand += 0xa0761d6478bd642f;
            auto [hi, lo] = math::Mul64(mp->cheaprand, mp->cheaprand ^ 0xe7037ed1a0b428db);
            return uint32_t(hi ^ lo);
        }
        auto t = (gocpp::array<uint32_t, 2>*)(unsafe::Pointer(& mp->cheaprand));
        auto [s1, s0] = std::tuple{t[0], t[1]};
        s1 ^= s1 << 17;
        s1 = s1 ^ s0 ^ (s1 >> 7) ^ (s0 >> 16);
        std::tie(t[0], t[1]) = std::tuple{s0, s1};
        return s0 + s1;
    }

    // cheaprand64 is a non-cryptographic-quality 63-bit random generator
    // suitable for calling at very high frequency (such as during sampling decisions).
    // it is "cheap" in the sense of both expense and quality.
    //
    // cheaprand64 must not be exported to other packages:
    // the rule is that other packages using runtime-provided
    // randomness must always use rand.
    //go:nosplit
    int64_t cheaprand64()
    {
        return (int64_t(cheaprand()) << 31) ^ int64_t(cheaprand());
    }

    // cheaprandn is like cheaprand() % n but faster.
    //
    // cheaprandn must not be exported to other packages:
    // the rule is that other packages using runtime-provided
    // randomness must always use randn.
    //go:nosplit
    uint32_t cheaprandn(uint32_t n)
    {
        return uint32_t((uint64_t(cheaprand()) * uint64_t(n)) >> 32);
    }

    //go:linkname legacy_fastrand runtime.fastrand
    uint32_t legacy_fastrand()
    {
        return uint32_t(rand());
    }

    //go:linkname legacy_fastrandn runtime.fastrandn
    uint32_t legacy_fastrandn(uint32_t n)
    {
        return randn(n);
    }

    //go:linkname legacy_fastrand64 runtime.fastrand64
    uint64_t legacy_fastrand64()
    {
        return rand();
    }

}

