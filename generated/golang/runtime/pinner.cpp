// generated by GoCpp from file '$(ImportDir)/runtime/pinner.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/pinner.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/arena.h"
#include "golang/runtime/atomic_pointer.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
// #include "golang/runtime/mgcsweep.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/runtime1.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Pinner::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Pinner::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& Pinner::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Pinner& value)
    {
        return value.PrintTo(os);
    }

    void Pin(struct Pinner* p, go_any pointer)
    {
        if(p->pinner == nullptr)
        {
            auto mp = acquirem();
            if(auto pp = ptr(gocpp::recv(mp->p)); pp != nullptr)
            {
                p->pinner = pp->pinnerCache;
                pp->pinnerCache = nullptr;
            }
            releasem(mp);
            if(p->pinner == nullptr)
            {
                p->pinner = go_new(pinner);
                p->refs = p->refStore.make_slice(0, 0);
                SetFinalizer(p->pinner, [=](pinner* i) mutable -> void
                {
                    if(len(i->refs) != 0)
                    {
                        unpin(gocpp::recv(i));
                        pinnerLeakPanic();
                    }
                });
            }
        }
        auto ptr = pinnerGetPtr(& pointer);
        if(setPinned(ptr, true))
        {
            p->refs = append(p->refs, ptr);
        }
    }

    void Unpin(struct Pinner* p)
    {
        unpin(gocpp::recv(p->pinner));
        auto mp = acquirem();
        if(auto pp = ptr(gocpp::recv(mp->p)); pp != nullptr && pp->pinnerCache == nullptr)
        {
            pp->pinnerCache = p->pinner;
            p->pinner = nullptr;
        }
        releasem(mp);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pinner::operator T()
    {
        T result;
        result.refs = this->refs;
        result.refStore = this->refStore;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pinner::operator==(const T& ref) const
    {
        if (refs != ref.refs) return false;
        if (refStore != ref.refStore) return false;
        return true;
    }

    std::ostream& pinner::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << refs;
        os << " " << refStore;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pinner& value)
    {
        return value.PrintTo(os);
    }

    void unpin(struct pinner* p)
    {
        if(p == nullptr || p->refs == nullptr)
        {
            return;
        }
        for(auto [i, gocpp_ignored] : p->refs)
        {
            setPinned(p->refs[i], false);
        }
        p->refStore = gocpp::array<unsafe::Pointer, pinnerRefStoreSize> {};
        p->refs = p->refStore.make_slice(0, 0);
    }

    unsafe::Pointer pinnerGetPtr(go_any* i)
    {
        auto e = efaceOf(i);
        auto etyp = e->_type;
        if(etyp == nullptr)
        {
            gocpp::panic(errorString("runtime.Pinner: argument is nil"));
        }
        if(auto kind = etyp->Kind_ & kindMask; kind != kindPtr && kind != kindUnsafePointer)
        {
            gocpp::panic(errorString("runtime.Pinner: argument is not a pointer: " + string(gocpp::recv(toRType(etyp)))));
        }
        if(inUserArenaChunk(uintptr_t(e->data)))
        {
            gocpp::panic(errorString("runtime.Pinner: object was allocated into an arena"));
        }
        return e->data;
    }

    bool isPinned(unsafe::Pointer ptr)
    {
        auto span = spanOfHeap(uintptr_t(ptr));
        if(span == nullptr)
        {
            return true;
        }
        auto pinnerBits = getPinnerBits(gocpp::recv(span));
        if(pinnerBits == nullptr)
        {
            return false;
        }
        auto objIndex = objIndex(gocpp::recv(span), uintptr_t(ptr));
        auto pinState = ofObject(gocpp::recv(pinnerBits), objIndex);
        KeepAlive(ptr);
        return isPinned(gocpp::recv(pinState));
    }

    bool setPinned(unsafe::Pointer ptr, bool pin)
    {
        auto span = spanOfHeap(uintptr_t(ptr));
        if(span == nullptr)
        {
            if(! pin)
            {
                gocpp::panic(errorString("tried to unpin non-Go pointer"));
            }
            return false;
        }
        auto mp = acquirem();
        ensureSwept(gocpp::recv(span));
        KeepAlive(ptr);
        auto objIndex = objIndex(gocpp::recv(span), uintptr_t(ptr));
        lock(& span->speciallock);
        auto pinnerBits = getPinnerBits(gocpp::recv(span));
        if(pinnerBits == nullptr)
        {
            pinnerBits = newPinnerBits(gocpp::recv(span));
            setPinnerBits(gocpp::recv(span), pinnerBits);
        }
        auto pinState = ofObject(gocpp::recv(pinnerBits), objIndex);
        if(pin)
        {
            if(isPinned(gocpp::recv(pinState)))
            {
                setMultiPinned(gocpp::recv(pinState), true);
                systemstack([=]() mutable -> void
                {
                    auto offset = objIndex * span->elemsize;
                    incPinCounter(gocpp::recv(span), offset);
                });
            }
            else
            {
                setPinned(gocpp::recv(pinState), true);
            }
        }
        else
        {
            if(isPinned(gocpp::recv(pinState)))
            {
                if(isMultiPinned(gocpp::recv(pinState)))
                {
                    bool exists = {};
                    systemstack([=]() mutable -> void
                    {
                        auto offset = objIndex * span->elemsize;
                        exists = decPinCounter(gocpp::recv(span), offset);
                    });
                    if(! exists)
                    {
                        setMultiPinned(gocpp::recv(pinState), false);
                    }
                }
                else
                {
                    setPinned(gocpp::recv(pinState), false);
                }
            }
            else
            {
                go_throw("runtime.Pinner: object already unpinned");
            }
        }
        unlock(& span->speciallock);
        releasem(mp);
        return true;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    pinState::operator T()
    {
        T result;
        result.bytep = this->bytep;
        result.byteVal = this->byteVal;
        result.mask = this->mask;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool pinState::operator==(const T& ref) const
    {
        if (bytep != ref.bytep) return false;
        if (byteVal != ref.byteVal) return false;
        if (mask != ref.mask) return false;
        return true;
    }

    std::ostream& pinState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << bytep;
        os << " " << byteVal;
        os << " " << mask;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct pinState& value)
    {
        return value.PrintTo(os);
    }

    bool isPinned(struct pinState* v)
    {
        return (v->byteVal & v->mask) != 0;
    }

    bool isMultiPinned(struct pinState* v)
    {
        return (v->byteVal & (v->mask << 1)) != 0;
    }

    void setPinned(struct pinState* v, bool val)
    {
        set(gocpp::recv(v), val, false);
    }

    void setMultiPinned(struct pinState* v, bool val)
    {
        set(gocpp::recv(v), val, true);
    }

    void set(struct pinState* v, bool val, bool multipin)
    {
        auto mask = v->mask;
        if(multipin)
        {
            mask <<= 1;
        }
        if(val)
        {
            atomic::Or8(v->bytep, mask);
        }
        else
        {
            atomic::And8(v->bytep, ~ mask);
        }
    }

    pinState ofObject(struct pinnerBits* p, uintptr_t n)
    {
        auto [bytep, mask] = bitp(gocpp::recv((gcBits*)(p)), n * 2);
        auto byteVal = atomic::Load8(bytep);
        return pinState {bytep, byteVal, mask};
    }

    uintptr_t pinnerBitSize(struct mspan* s)
    {
        return divRoundUp(uintptr_t(s->nelems) * 2, 8);
    }

    pinnerBits* newPinnerBits(struct mspan* s)
    {
        return (pinnerBits*)(newMarkBits(uintptr_t(s->nelems) * 2));
    }

    pinnerBits* getPinnerBits(struct mspan* s)
    {
        return (pinnerBits*)(atomic::Loadp(unsafe::Pointer(& s->pinnerBits)));
    }

    void setPinnerBits(struct mspan* s, pinnerBits* p)
    {
        atomicstorep(unsafe::Pointer(& s->pinnerBits), unsafe::Pointer(p));
    }

    void refreshPinnerBits(struct mspan* s)
    {
        auto p = getPinnerBits(gocpp::recv(s));
        if(p == nullptr)
        {
            return;
        }
        auto hasPins = false;
        auto bytes = alignUp(pinnerBitSize(gocpp::recv(s)), 8);
        for(auto [_, x] : unsafe::Slice((uint64_t*)(unsafe::Pointer(& p->x)), bytes / 8))
        {
            if(x != 0)
            {
                hasPins = true;
                break;
            }
        }
        if(hasPins)
        {
            auto newPinnerBits = newPinnerBits(gocpp::recv(s));
            memmove(unsafe::Pointer(& newPinnerBits->x), unsafe::Pointer(& p->x), bytes);
            setPinnerBits(gocpp::recv(s), newPinnerBits);
        }
        else
        {
            setPinnerBits(gocpp::recv(s), nullptr);
        }
    }

    void incPinCounter(struct mspan* span, uintptr_t offset)
    {
        specialPinCounter* rec = {};
        auto [ref, exists] = specialFindSplicePoint(gocpp::recv(span), offset, _KindSpecialPinCounter);
        if(! exists)
        {
            lock(& mheap_.speciallock);
            rec = (specialPinCounter*)(alloc(gocpp::recv(mheap_.specialPinCounterAlloc)));
            unlock(& mheap_.speciallock);
            rec->special.offset = uint16_t(offset);
            rec->special.kind = _KindSpecialPinCounter;
            rec->special.next = *ref;
            *ref = (special*)(unsafe::Pointer(rec));
            spanHasSpecials(span);
        }
        else
        {
            rec = (specialPinCounter*)(unsafe::Pointer(*ref));
        }
        rec->counter++;
    }

    bool decPinCounter(struct mspan* span, uintptr_t offset)
    {
        auto [ref, exists] = specialFindSplicePoint(gocpp::recv(span), offset, _KindSpecialPinCounter);
        if(! exists)
        {
            go_throw("runtime.Pinner: decreased non-existing pin counter");
        }
        auto counter = (specialPinCounter*)(unsafe::Pointer(*ref));
        counter->counter--;
        if(counter->counter == 0)
        {
            *ref = counter->special.next;
            if(span->specials == nullptr)
            {
                spanHasNoSpecials(span);
            }
            lock(& mheap_.speciallock);
            free(gocpp::recv(mheap_.specialPinCounterAlloc), unsafe::Pointer(counter));
            unlock(& mheap_.speciallock);
            return false;
        }
        return true;
    }

    uintptr_t* pinnerGetPinCounter(unsafe::Pointer addr)
    {
        auto [gocpp_id_1, span, objIndex] = findObject(uintptr_t(addr), 0, 0);
        auto offset = objIndex * span->elemsize;
        auto [t, exists] = specialFindSplicePoint(gocpp::recv(span), offset, _KindSpecialPinCounter);
        if(! exists)
        {
            return nullptr;
        }
        auto counter = (specialPinCounter*)(unsafe::Pointer(*t));
        return & counter->counter;
    }

    std::function<void (void)> pinnerLeakPanic = []() mutable -> void
    {
        gocpp::panic(errorString("runtime.Pinner: found leaking pinned pointer; forgot to call Unpin()?"));
    };
}

