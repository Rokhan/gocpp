// generated by GoCpp from file '$(ImportDir)/runtime/mgcwork.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mgcwork.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
    }

    void init()
    {
        if(workbufAlloc % pageSize != 0 || workbufAlloc % _WorkbufSize != 0)
        {
            go_throw("bad workbufAlloc"s);
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gcWork::operator T()
    {
        T result;
        result.wbuf1 = this->wbuf1;
        result.wbuf2 = this->wbuf2;
        result.bytesMarked = this->bytesMarked;
        result.heapScanWork = this->heapScanWork;
        result.flushedWork = this->flushedWork;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gcWork::operator==(const T& ref) const
    {
        if (wbuf1 != ref.wbuf1) return false;
        if (wbuf2 != ref.wbuf2) return false;
        if (bytesMarked != ref.bytesMarked) return false;
        if (heapScanWork != ref.heapScanWork) return false;
        if (flushedWork != ref.flushedWork) return false;
        return true;
    }

    std::ostream& gcWork::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wbuf1;
        os << " " << wbuf2;
        os << " " << bytesMarked;
        os << " " << heapScanWork;
        os << " " << flushedWork;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcWork& value)
    {
        return value.PrintTo(os);
    }

    void rec::init(struct gcWork* w)
    {
        w->wbuf1 = getempty();
        auto wbuf2 = trygetfull();
        if(wbuf2 == nullptr)
        {
            wbuf2 = getempty();
        }
        w->wbuf2 = wbuf2;
    }

    void rec::put(struct gcWork* w, uintptr_t obj)
    {
        auto flushed = false;
        auto wbuf = w->wbuf1;
        lockWithRankMayAcquire(& work.wbufSpans.lock, lockRankWbufSpans);
        lockWithRankMayAcquire(& mheap_.lock, lockRankMheap);
        if(wbuf == nullptr)
        {
            rec::init(gocpp::recv(w));
            wbuf = w->wbuf1;
        }
        else
        if(wbuf->nobj == len(wbuf->obj))
        {
            std::tie(w->wbuf1, w->wbuf2) = std::tuple{w->wbuf2, w->wbuf1};
            wbuf = w->wbuf1;
            if(wbuf->nobj == len(wbuf->obj))
            {
                putfull(wbuf);
                w->flushedWork = true;
                wbuf = getempty();
                w->wbuf1 = wbuf;
                flushed = true;
            }
        }
        wbuf->obj[wbuf->nobj] = obj;
        wbuf->nobj++;
        if(flushed && gcphase == _GCmark)
        {
            rec::enlistWorker(gocpp::recv(gcController));
        }
    }

    bool rec::putFast(struct gcWork* w, uintptr_t obj)
    {
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr || wbuf->nobj == len(wbuf->obj))
        {
            return false;
        }
        wbuf->obj[wbuf->nobj] = obj;
        wbuf->nobj++;
        return true;
    }

    void rec::putBatch(struct gcWork* w, gocpp::slice<uintptr_t> obj)
    {
        if(len(obj) == 0)
        {
            return;
        }
        auto flushed = false;
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr)
        {
            rec::init(gocpp::recv(w));
            wbuf = w->wbuf1;
        }
        for(; len(obj) > 0; )
        {
            for(; wbuf->nobj == len(wbuf->obj); )
            {
                putfull(wbuf);
                w->flushedWork = true;
                std::tie(w->wbuf1, w->wbuf2) = std::tuple{w->wbuf2, getempty()};
                wbuf = w->wbuf1;
                flushed = true;
            }
            auto n = copy(wbuf->obj.make_slice(wbuf->nobj), obj);
            wbuf->nobj += n;
            obj = obj.make_slice(n);
        }
        if(flushed && gcphase == _GCmark)
        {
            rec::enlistWorker(gocpp::recv(gcController));
        }
    }

    uintptr_t rec::tryGet(struct gcWork* w)
    {
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr)
        {
            rec::init(gocpp::recv(w));
            wbuf = w->wbuf1;
        }
        if(wbuf->nobj == 0)
        {
            std::tie(w->wbuf1, w->wbuf2) = std::tuple{w->wbuf2, w->wbuf1};
            wbuf = w->wbuf1;
            if(wbuf->nobj == 0)
            {
                auto owbuf = wbuf;
                wbuf = trygetfull();
                if(wbuf == nullptr)
                {
                    return 0;
                }
                putempty(owbuf);
                w->wbuf1 = wbuf;
            }
        }
        wbuf->nobj--;
        return wbuf->obj[wbuf->nobj];
    }

    uintptr_t rec::tryGetFast(struct gcWork* w)
    {
        auto wbuf = w->wbuf1;
        if(wbuf == nullptr || wbuf->nobj == 0)
        {
            return 0;
        }
        wbuf->nobj--;
        return wbuf->obj[wbuf->nobj];
    }

    void rec::dispose(struct gcWork* w)
    {
        if(auto wbuf = w->wbuf1; wbuf != nullptr)
        {
            if(wbuf->nobj == 0)
            {
                putempty(wbuf);
            }
            else
            {
                putfull(wbuf);
                w->flushedWork = true;
            }
            w->wbuf1 = nullptr;
            wbuf = w->wbuf2;
            if(wbuf->nobj == 0)
            {
                putempty(wbuf);
            }
            else
            {
                putfull(wbuf);
                w->flushedWork = true;
            }
            w->wbuf2 = nullptr;
        }
        if(w->bytesMarked != 0)
        {
            atomic::Xadd64(& work.bytesMarked, int64_t(w->bytesMarked));
            w->bytesMarked = 0;
        }
        if(w->heapScanWork != 0)
        {
            rec::Add(gocpp::recv(gcController.heapScanWork), w->heapScanWork);
            w->heapScanWork = 0;
        }
    }

    void rec::balance(struct gcWork* w)
    {
        if(w->wbuf1 == nullptr)
        {
            return;
        }
        if(auto wbuf = w->wbuf2; wbuf->nobj != 0)
        {
            putfull(wbuf);
            w->flushedWork = true;
            w->wbuf2 = getempty();
        }
        else
        if(auto wbuf = w->wbuf1; wbuf->nobj > 4)
        {
            w->wbuf1 = handoff(wbuf);
            w->flushedWork = true;
        }
        else
        {
            return;
        }
        if(gcphase == _GCmark)
        {
            rec::enlistWorker(gocpp::recv(gcController));
        }
    }

    bool rec::empty(struct gcWork* w)
    {
        return w->wbuf1 == nullptr || (w->wbuf1->nobj == 0 && w->wbuf2->nobj == 0);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    workbufhdr::operator T()
    {
        T result;
        result.node = this->node;
        result.nobj = this->nobj;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool workbufhdr::operator==(const T& ref) const
    {
        if (node != ref.node) return false;
        if (nobj != ref.nobj) return false;
        return true;
    }

    std::ostream& workbufhdr::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << node;
        os << " " << nobj;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct workbufhdr& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    workbuf::operator T()
    {
        T result;
        result._1 = this->_1;
        result.obj = this->obj;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool workbuf::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (obj != ref.obj) return false;
        return true;
    }

    std::ostream& workbuf::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << obj;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct workbuf& value)
    {
        return value.PrintTo(os);
    }

    void rec::checknonempty(struct workbuf* b)
    {
        if(b->nobj == 0)
        {
            go_throw("workbuf is empty"s);
        }
    }

    void rec::checkempty(struct workbuf* b)
    {
        if(b->nobj != 0)
        {
            go_throw("workbuf is not empty"s);
        }
    }

    struct workbuf* getempty()
    {
        workbuf* b = {};
        if(work.empty != 0)
        {
            b = (workbuf*)(rec::pop(gocpp::recv(work.empty)));
            if(b != nullptr)
            {
                rec::checkempty(gocpp::recv(b));
            }
        }
        lockWithRankMayAcquire(& work.wbufSpans.lock, lockRankWbufSpans);
        lockWithRankMayAcquire(& mheap_.lock, lockRankMheap);
        if(b == nullptr)
        {
            mspan* s = {};
            if(work.wbufSpans.free.first != nullptr)
            {
                lock(& work.wbufSpans.lock);
                s = work.wbufSpans.free.first;
                if(s != nullptr)
                {
                    rec::remove(gocpp::recv(work.wbufSpans.free), s);
                    rec::insert(gocpp::recv(work.wbufSpans.busy), s);
                }
                unlock(& work.wbufSpans.lock);
            }
            if(s == nullptr)
            {
                systemstack([=]() mutable -> void
                {
                    s = rec::allocManual(gocpp::recv(mheap_), workbufAlloc / pageSize, spanAllocWorkBuf);
                });
                if(s == nullptr)
                {
                    go_throw("out of memory"s);
                }
                lock(& work.wbufSpans.lock);
                rec::insert(gocpp::recv(work.wbufSpans.busy), s);
                unlock(& work.wbufSpans.lock);
            }
            for(auto i = uintptr_t(0); i + _WorkbufSize <= workbufAlloc; i += _WorkbufSize)
            {
                auto newb = (workbuf*)(unsafe::Pointer(rec::base(gocpp::recv(s)) + i));
                newb->nobj = 0;
                lfnodeValidate(& newb->node);
                if(i == 0)
                {
                    b = newb;
                }
                else
                {
                    putempty(newb);
                }
            }
        }
        return b;
    }

    void putempty(struct workbuf* b)
    {
        rec::checkempty(gocpp::recv(b));
        rec::push(gocpp::recv(work.empty), & b->node);
    }

    void putfull(struct workbuf* b)
    {
        rec::checknonempty(gocpp::recv(b));
        rec::push(gocpp::recv(work.full), & b->node);
    }

    struct workbuf* trygetfull()
    {
        auto b = (workbuf*)(rec::pop(gocpp::recv(work.full)));
        if(b != nullptr)
        {
            rec::checknonempty(gocpp::recv(b));
            return b;
        }
        return b;
    }

    struct workbuf* handoff(struct workbuf* b)
    {
        auto b1 = getempty();
        auto n = b->nobj / 2;
        b->nobj -= n;
        b1->nobj = n;
        memmove(unsafe::Pointer(& b1->obj[0]), unsafe::Pointer(& b->obj[b->nobj]), uintptr_t(n) * gocpp::Sizeof<uintptr_t>());
        putfull(b);
        return b1;
    }

    void prepareFreeWorkbufs()
    {
        lock(& work.wbufSpans.lock);
        if(work.full != 0)
        {
            go_throw("cannot free workbufs when work.full != 0"s);
        }
        work.empty = 0;
        rec::takeAll(gocpp::recv(work.wbufSpans.free), & work.wbufSpans.busy);
        unlock(& work.wbufSpans.lock);
    }

    bool freeSomeWbufs(bool preemptible)
    {
        auto batchSize = 64;
        lock(& work.wbufSpans.lock);
        if(gcphase != _GCoff || rec::isEmpty(gocpp::recv(work.wbufSpans.free)))
        {
            unlock(& work.wbufSpans.lock);
            return false;
        }
        systemstack([=]() mutable -> void
        {
            auto gp = getg()->m->curg;
            for(auto i = 0; i < batchSize && ! (preemptible && gp->preempt); i++)
            {
                auto span = work.wbufSpans.free.first;
                if(span == nullptr)
                {
                    break;
                }
                rec::remove(gocpp::recv(work.wbufSpans.free), span);
                rec::freeManual(gocpp::recv(mheap_), span, spanAllocWorkBuf);
            }
        });
        auto more = ! rec::isEmpty(gocpp::recv(work.wbufSpans.free));
        unlock(& work.wbufSpans.lock);
        return more;
    }

}

