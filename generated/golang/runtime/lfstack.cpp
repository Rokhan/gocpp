// generated by GoCpp from file '$(ImportDir)/runtime/lfstack.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/lfstack.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
#include "golang/runtime/tagptr.h"
#include "golang/runtime/tagptr_64bit.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    void push(lfstack* head, struct lfnode* node)
    {
        node->pushcnt++;
        auto go_new = lfstackPack(node, node->pushcnt);
        if(auto node1 = lfstackUnpack(go_new); node1 != node)
        {
            print("runtime: lfstack.push invalid packing: node=", node, " cnt=", hex(node->pushcnt), " packed=", hex(go_new), " -> node=", node1, "\n");
            go_throw("lfstack.push");
        }
        for(; ; )
        {
            auto old = atomic::Load64((uint64_t*)(head));
            node->next = old;
            if(atomic::Cas64((uint64_t*)(head), old, go_new))
            {
                break;
            }
        }
    }

    unsafe::Pointer pop(lfstack* head)
    {
        for(; ; )
        {
            auto old = atomic::Load64((uint64_t*)(head));
            if(old == 0)
            {
                return nullptr;
            }
            auto node = lfstackUnpack(old);
            auto next = atomic::Load64(& node->next);
            if(atomic::Cas64((uint64_t*)(head), old, next))
            {
                return unsafe::Pointer(node);
            }
        }
    }

    bool empty(lfstack* head)
    {
        return atomic::Load64((uint64_t*)(head)) == 0;
    }

    void lfnodeValidate(struct lfnode* node)
    {
        if(auto [base, gocpp_id_2, gocpp_id_3] = findObject(uintptr_t(unsafe::Pointer(node)), 0, 0); base != 0)
        {
            go_throw("lfstack node allocated from the heap");
        }
        if(lfstackUnpack(lfstackPack(node, ~ uintptr_t(0))) != node)
        {
            printlock();
            println("runtime: bad lfnode address", hex(uintptr_t(unsafe::Pointer(node))));
            go_throw("bad lfnode address");
        }
    }

    uint64_t lfstackPack(struct lfnode* node, uintptr_t cnt)
    {
        return uint64_t(taggedPointerPack(unsafe::Pointer(node), cnt));
    }

    struct lfnode* lfstackUnpack(uint64_t val)
    {
        return (lfnode*)(pointer(gocpp::recv(taggedPointer(val))));
    }

}

