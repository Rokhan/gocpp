// generated by GoCpp from file '$(ImportDir)/internal/poll/fd_mutex.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/poll/fd_mutex.h"
#include "gocpp/support.h"

#include "golang/internal/poll/fd.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/sync/atomic/doc.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"

namespace golang::poll
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    fdMutex::operator T()
    {
        T result;
        result.state = this->state;
        result.rsema = this->rsema;
        result.wsema = this->wsema;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fdMutex::operator==(const T& ref) const
    {
        if (state != ref.state) return false;
        if (rsema != ref.rsema) return false;
        if (wsema != ref.wsema) return false;
        return true;
    }

    std::ostream& fdMutex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << state;
        os << " " << rsema;
        os << " " << wsema;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fdMutex& value)
    {
        return value.PrintTo(os);
    }

    std::string overflowMsg = "too many concurrent operations on a single file or socket (max 1048575)"s;
    bool rec::incref(struct fdMutex* mu)
    {
        for(; ; )
        {
            auto old = atomic::LoadUint64(& mu->state);
            if(old & mutexClosed != 0)
            {
                return false;
            }
            auto go_new = old + mutexRef;
            if(go_new & mutexRefMask == 0)
            {
                gocpp::panic(overflowMsg);
            }
            if(atomic::CompareAndSwapUint64(& mu->state, old, go_new))
            {
                return true;
            }
        }
    }

    bool rec::increfAndClose(struct fdMutex* mu)
    {
        for(; ; )
        {
            auto old = atomic::LoadUint64(& mu->state);
            if(old & mutexClosed != 0)
            {
                return false;
            }
            auto go_new = (old | mutexClosed) + mutexRef;
            if(go_new & mutexRefMask == 0)
            {
                gocpp::panic(overflowMsg);
            }
            go_new &^= mutexRMask | mutexWMask;
            if(atomic::CompareAndSwapUint64(& mu->state, old, go_new))
            {
                for(; old & mutexRMask != 0; )
                {
                    old -= mutexRWait;
                    runtime_Semrelease(& mu->rsema);
                }
                for(; old & mutexWMask != 0; )
                {
                    old -= mutexWWait;
                    runtime_Semrelease(& mu->wsema);
                }
                return true;
            }
        }
    }

    bool rec::decref(struct fdMutex* mu)
    {
        for(; ; )
        {
            auto old = atomic::LoadUint64(& mu->state);
            if(old & mutexRefMask == 0)
            {
                gocpp::panic("inconsistent poll.fdMutex"s);
            }
            auto go_new = old - mutexRef;
            if(atomic::CompareAndSwapUint64(& mu->state, old, go_new))
            {
                return go_new & (mutexClosed | mutexRefMask) == mutexClosed;
            }
        }
    }

    bool rec::rwlock(struct fdMutex* mu, bool read)
    {
        uint64_t mutexBit = {};
        uint64_t mutexWait = {};
        uint64_t mutexMask = {};
        uint32_t* mutexSema = {};
        if(read)
        {
            mutexBit = mutexRLock;
            mutexWait = mutexRWait;
            mutexMask = mutexRMask;
            mutexSema = & mu->rsema;
        }
        else
        {
            mutexBit = mutexWLock;
            mutexWait = mutexWWait;
            mutexMask = mutexWMask;
            mutexSema = & mu->wsema;
        }
        for(; ; )
        {
            auto old = atomic::LoadUint64(& mu->state);
            if(old & mutexClosed != 0)
            {
                return false;
            }
            uint64_t go_new = {};
            if(old & mutexBit == 0)
            {
                go_new = (old | mutexBit) + mutexRef;
                if(go_new & mutexRefMask == 0)
                {
                    gocpp::panic(overflowMsg);
                }
            }
            else
            {
                go_new = old + mutexWait;
                if(go_new & mutexMask == 0)
                {
                    gocpp::panic(overflowMsg);
                }
            }
            if(atomic::CompareAndSwapUint64(& mu->state, old, go_new))
            {
                if(old & mutexBit == 0)
                {
                    return true;
                }
                runtime_Semacquire(mutexSema);
            }
        }
    }

    bool rec::rwunlock(struct fdMutex* mu, bool read)
    {
        uint64_t mutexBit = {};
        uint64_t mutexWait = {};
        uint64_t mutexMask = {};
        uint32_t* mutexSema = {};
        if(read)
        {
            mutexBit = mutexRLock;
            mutexWait = mutexRWait;
            mutexMask = mutexRMask;
            mutexSema = & mu->rsema;
        }
        else
        {
            mutexBit = mutexWLock;
            mutexWait = mutexWWait;
            mutexMask = mutexWMask;
            mutexSema = & mu->wsema;
        }
        for(; ; )
        {
            auto old = atomic::LoadUint64(& mu->state);
            if(old & mutexBit == 0 || old & mutexRefMask == 0)
            {
                gocpp::panic("inconsistent poll.fdMutex"s);
            }
            auto go_new = (old &^ mutexBit) - mutexRef;
            if(old & mutexMask != 0)
            {
                go_new -= mutexWait;
            }
            if(atomic::CompareAndSwapUint64(& mu->state, old, go_new))
            {
                if(old & mutexMask != 0)
                {
                    runtime_Semrelease(mutexSema);
                }
                return go_new & (mutexClosed | mutexRefMask) == mutexClosed;
            }
        }
    }

    void runtime_Semacquire(uint32_t* sema)
    /* convertBlockStmt, nil block */;

    void runtime_Semrelease(uint32_t* sema)
    /* convertBlockStmt, nil block */;

    struct gocpp::error rec::incref(struct FD* fd)
    {
        if(! rec::incref(gocpp::recv(fd->fdmu)))
        {
            return errClosing(fd->isFile);
        }
        return nullptr;
    }

    struct gocpp::error rec::decref(struct FD* fd)
    {
        if(rec::decref(gocpp::recv(fd->fdmu)))
        {
            return rec::destroy(gocpp::recv(fd));
        }
        return nullptr;
    }

    struct gocpp::error rec::readLock(struct FD* fd)
    {
        if(! rec::rwlock(gocpp::recv(fd->fdmu), true))
        {
            return errClosing(fd->isFile);
        }
        return nullptr;
    }

    void rec::readUnlock(struct FD* fd)
    {
        if(rec::rwunlock(gocpp::recv(fd->fdmu), true))
        {
            rec::destroy(gocpp::recv(fd));
        }
    }

    struct gocpp::error rec::writeLock(struct FD* fd)
    {
        if(! rec::rwlock(gocpp::recv(fd->fdmu), false))
        {
            return errClosing(fd->isFile);
        }
        return nullptr;
    }

    void rec::writeUnlock(struct FD* fd)
    {
        if(rec::rwunlock(gocpp::recv(fd->fdmu), false))
        {
            rec::destroy(gocpp::recv(fd));
        }
    }

}

