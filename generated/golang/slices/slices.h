// generated by GoCpp from file '$(ImportDir)/slices/slices.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/slices/slices.fwd.h"
#include "gocpp/support.h"

// #include "golang/cmp/cmp.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::slices
{
    bool Equal(S s1, S s2);
    bool EqualFunc(S1 s1, S2 s2, std::function<bool (E1, E2)> eq);
    int Compare(S s1, S s2);
    int CompareFunc(S1 s1, S2 s2, std::function<int (E1, E2)> cmp);
    int Index(S s, E v);
    int IndexFunc(S s, std::function<bool (E)> f);
    bool Contains(S s, E v);
    bool ContainsFunc(S s, std::function<bool (E)> f);
    S Insert(S s, int i, gocpp::slice<E> v);
    template<typename... Args>
    S Insert(S s, int i, Args... v)
    {
        return Insert(s, i, gocpp::ToSlice<E>(v...));
    }

    S Delete(S s, int i, int j);
    S DeleteFunc(S s, std::function<bool (E)> del);
    S Replace(S s, int i, int j, gocpp::slice<E> v);
    template<typename... Args>
    S Replace(S s, int i, int j, Args... v)
    {
        return Replace(s, i, j, gocpp::ToSlice<E>(v...));
    }

    S Clone(S s);
    S Compact(S s);
    S CompactFunc(S s, std::function<bool (E, E)> eq);
    S Grow(S s, int n);
    S Clip(S s);
    void rotateLeft(gocpp::slice<E> s, int r);
    void rotateRight(gocpp::slice<E> s, int r);
    void swap(gocpp::slice<E> x, gocpp::slice<E> y);
    bool overlaps(gocpp::slice<E> a, gocpp::slice<E> b);
    int startIdx(gocpp::slice<E> haystack, gocpp::slice<E> needle);
    void Reverse(S s);
    S Concat(gocpp::slice<S> slices);
    template<typename... Args>
    S Concat(Args... slices)
    {
        return Concat(, gocpp::ToSlice<S>(slices...));
    }

}

