// generated by GoCpp from file '$(ImportDir)/runtime/mspanset.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mspanset.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using atomic::rec::StoreNoWB;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    spanSet::operator T()
    {
        T result;
        result.spineLock = this->spineLock;
        result.spine = this->spine;
        result.spineLen = this->spineLen;
        result.spineCap = this->spineCap;
        result.index = this->index;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool spanSet::operator==(const T& ref) const
    {
        if (spineLock != ref.spineLock) return false;
        if (spine != ref.spine) return false;
        if (spineLen != ref.spineLen) return false;
        if (spineCap != ref.spineCap) return false;
        if (index != ref.index) return false;
        return true;
    }

    std::ostream& spanSet::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << spineLock;
        os << " " << spine;
        os << " " << spineLen;
        os << " " << spineCap;
        os << " " << index;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSet& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    spanSetBlock::operator T()
    {
        T result;
        result.popped = this->popped;
        result.spans = this->spans;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool spanSetBlock::operator==(const T& ref) const
    {
        if (popped != ref.popped) return false;
        if (spans != ref.spans) return false;
        return true;
    }

    std::ostream& spanSetBlock::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << popped;
        os << " " << spans;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSetBlock& value)
    {
        return value.PrintTo(os);
    }

    void rec::push(struct spanSet* b, struct mspan* s)
    {
        auto cursor = uintptr_t(rec::tail(gocpp::recv(rec::incTail(gocpp::recv(b->index)))) - 1);
        auto [top, bottom] = std::tuple{cursor / spanSetBlockEntries, cursor % spanSetBlockEntries};
        auto spineLen = rec::Load(gocpp::recv(b->spineLen));
        spanSetBlock* block = {};
        retry:
        if(top < spineLen)
        {
            block = rec::Load(gocpp::recv(rec::lookup(gocpp::recv(rec::Load(gocpp::recv(b->spine))), top)));
        }
        else
        {
            lock(& b->spineLock);
            spineLen = rec::Load(gocpp::recv(b->spineLen));
            if(top < spineLen)
            {
                unlock(& b->spineLock);
                goto retry;
            }
            auto spine = rec::Load(gocpp::recv(b->spine));
            if(spineLen == b->spineCap)
            {
                auto newCap = b->spineCap * 2;
                if(newCap == 0)
                {
                    newCap = spanSetInitSpineCap;
                }
                auto newSpine = persistentalloc(newCap * goarch::PtrSize, cpu::CacheLineSize, & memstats.gcMiscSys);
                if(b->spineCap != 0)
                {
                    memmove(newSpine, spine.p, b->spineCap * goarch::PtrSize);
                }
                spine = spanSetSpinePointer {newSpine};
                rec::StoreNoWB(gocpp::recv(b->spine), spine);
                b->spineCap = newCap;
            }
            block = rec::alloc(gocpp::recv(spanSetBlockPool));
            rec::StoreNoWB(gocpp::recv(rec::lookup(gocpp::recv(spine), top)), block);
            rec::Store(gocpp::recv(b->spineLen), spineLen + 1);
            unlock(& b->spineLock);
        }
        rec::StoreNoWB(gocpp::recv(block->spans[bottom]), s);
    }

    struct mspan* rec::pop(struct spanSet* b)
    {
        uint32_t head = {};
        uint32_t tail = {};
        claimLoop:
        for(; ; )
        {
            auto headtail = rec::load(gocpp::recv(b->index));
            std::tie(head, tail) = rec::split(gocpp::recv(headtail));
            if(head >= tail)
            {
                return nullptr;
            }
            auto spineLen = rec::Load(gocpp::recv(b->spineLen));
            if(spineLen <= uintptr_t(head) / spanSetBlockEntries)
            {
                return nullptr;
            }
            auto want = head;
            for(; want == head; )
            {
                if(rec::cas(gocpp::recv(b->index), headtail, makeHeadTailIndex(want + 1, tail)))
                {
                    goto claimLoop_break;
                }
                headtail = rec::load(gocpp::recv(b->index));
                std::tie(head, tail) = rec::split(gocpp::recv(headtail));
            }
            if(false) {
            claimLoop_continue:
                continue;
            claimLoop_break:
                break;
            }
        }
        auto [top, bottom] = std::tuple{head / spanSetBlockEntries, head % spanSetBlockEntries};
        auto blockp = rec::lookup(gocpp::recv(rec::Load(gocpp::recv(b->spine))), uintptr_t(top));
        auto block = rec::Load(gocpp::recv(blockp));
        auto s = rec::Load(gocpp::recv(block->spans[bottom]));
        for(; s == nullptr; )
        {
            s = rec::Load(gocpp::recv(block->spans[bottom]));
        }
        rec::StoreNoWB(gocpp::recv(block->spans[bottom]), nullptr);
        if(rec::Add(gocpp::recv(block->popped), 1) == spanSetBlockEntries)
        {
            rec::StoreNoWB(gocpp::recv(blockp), nullptr);
            rec::free(gocpp::recv(spanSetBlockPool), block);
        }
        return s;
    }

    void rec::reset(struct spanSet* b)
    {
        auto [head, tail] = rec::split(gocpp::recv(rec::load(gocpp::recv(b->index))));
        if(head < tail)
        {
            print("head = "s, head, ", tail = "s, tail, "\n"s);
            go_throw("attempt to clear non-empty span set"s);
        }
        auto top = head / spanSetBlockEntries;
        if(uintptr_t(top) < rec::Load(gocpp::recv(b->spineLen)))
        {
            auto blockp = rec::lookup(gocpp::recv(rec::Load(gocpp::recv(b->spine))), uintptr_t(top));
            auto block = rec::Load(gocpp::recv(blockp));
            if(block != nullptr)
            {
                if(rec::Load(gocpp::recv(block->popped)) == 0)
                {
                    go_throw("span set block with unpopped elements found in reset"s);
                }
                if(rec::Load(gocpp::recv(block->popped)) == spanSetBlockEntries)
                {
                    go_throw("fully empty unfreed span set block found in reset"s);
                }
                rec::StoreNoWB(gocpp::recv(blockp), nullptr);
                rec::free(gocpp::recv(spanSetBlockPool), block);
            }
        }
        rec::reset(gocpp::recv(b->index));
        rec::Store(gocpp::recv(b->spineLen), 0);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    atomicSpanSetSpinePointer::operator T()
    {
        T result;
        result.a = this->a;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicSpanSetSpinePointer::operator==(const T& ref) const
    {
        if (a != ref.a) return false;
        return true;
    }

    std::ostream& atomicSpanSetSpinePointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << a;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicSpanSetSpinePointer& value)
    {
        return value.PrintTo(os);
    }

    struct spanSetSpinePointer rec::Load(struct atomicSpanSetSpinePointer* s)
    {
        return spanSetSpinePointer {rec::Load(gocpp::recv(s->a))};
    }

    void rec::StoreNoWB(struct atomicSpanSetSpinePointer* s, struct spanSetSpinePointer p)
    {
        rec::StoreNoWB(gocpp::recv(s->a), p.p);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    spanSetSpinePointer::operator T()
    {
        T result;
        result.p = this->p;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool spanSetSpinePointer::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        return true;
    }

    std::ostream& spanSetSpinePointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSetSpinePointer& value)
    {
        return value.PrintTo(os);
    }


    template<typename spanSetBlock>
    atomic::Pointer<spanSetBlock>* rec::lookup(struct spanSetSpinePointer s, uintptr_t idx)
    {
        return (atomic::Pointer<spanSetBlock>*)(add(s.p, goarch::PtrSize * idx));
    }

    spanSetBlockAlloc spanSetBlockPool;
    
    template<typename T> requires gocpp::GoStruct<T>
    spanSetBlockAlloc::operator T()
    {
        T result;
        result.stack = this->stack;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool spanSetBlockAlloc::operator==(const T& ref) const
    {
        if (stack != ref.stack) return false;
        return true;
    }

    std::ostream& spanSetBlockAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stack;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct spanSetBlockAlloc& value)
    {
        return value.PrintTo(os);
    }

    struct spanSetBlock* rec::alloc(struct spanSetBlockAlloc* p)
    {
        if(auto s = (spanSetBlock*)(rec::pop(gocpp::recv(p->stack))); s != nullptr)
        {
            return s;
        }
        return (spanSetBlock*)(persistentalloc(gocpp::Sizeof<spanSetBlock>(), cpu::CacheLineSize, & memstats.gcMiscSys));
    }

    void rec::free(struct spanSetBlockAlloc* p, struct spanSetBlock* block)
    {
        rec::Store(gocpp::recv(block->popped), 0);
        rec::push(gocpp::recv(p->stack), & block->lfnode);
    }

    runtime::headTailIndex makeHeadTailIndex(uint32_t head, uint32_t tail)
    {
        return headTailIndex((uint64_t(head) << 32) | uint64_t(tail));
    }

    uint32_t rec::head(golang::runtime::headTailIndex h)
    {
        return uint32_t(h >> 32);
    }

    uint32_t rec::tail(golang::runtime::headTailIndex h)
    {
        return uint32_t(h);
    }

    std::tuple<uint32_t, uint32_t> rec::split(golang::runtime::headTailIndex h)
    {
        uint32_t head;
        uint32_t tail;
        return {rec::head(gocpp::recv(h)), rec::tail(gocpp::recv(h))};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    atomicHeadTailIndex::operator T()
    {
        T result;
        result.u = this->u;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicHeadTailIndex::operator==(const T& ref) const
    {
        if (u != ref.u) return false;
        return true;
    }

    std::ostream& atomicHeadTailIndex::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << u;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicHeadTailIndex& value)
    {
        return value.PrintTo(os);
    }

    runtime::headTailIndex rec::load(struct atomicHeadTailIndex* h)
    {
        return headTailIndex(rec::Load(gocpp::recv(h->u)));
    }

    bool rec::cas(struct atomicHeadTailIndex* h, golang::runtime::headTailIndex old, golang::runtime::headTailIndex go_new)
    {
        return rec::CompareAndSwap(gocpp::recv(h->u), uint64_t(old), uint64_t(go_new));
    }

    runtime::headTailIndex rec::incHead(struct atomicHeadTailIndex* h)
    {
        return headTailIndex(rec::Add(gocpp::recv(h->u), 1 << 32));
    }

    runtime::headTailIndex rec::decHead(struct atomicHeadTailIndex* h)
    {
        return headTailIndex(rec::Add(gocpp::recv(h->u), - (1 << 32)));
    }

    runtime::headTailIndex rec::incTail(struct atomicHeadTailIndex* h)
    {
        auto ht = headTailIndex(rec::Add(gocpp::recv(h->u), 1));
        if(rec::tail(gocpp::recv(ht)) == 0)
        {
            print("runtime: head = "s, rec::head(gocpp::recv(ht)), ", tail = "s, rec::tail(gocpp::recv(ht)), "\n"s);
            go_throw("headTailIndex overflow"s);
        }
        return ht;
    }

    void rec::reset(struct atomicHeadTailIndex* h)
    {
        rec::Store(gocpp::recv(h->u), 0);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    atomicMSpanPointer::operator T()
    {
        T result;
        result.p = this->p;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool atomicMSpanPointer::operator==(const T& ref) const
    {
        if (p != ref.p) return false;
        return true;
    }

    std::ostream& atomicMSpanPointer::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct atomicMSpanPointer& value)
    {
        return value.PrintTo(os);
    }

    struct mspan* rec::Load(struct atomicMSpanPointer* p)
    {
        return (mspan*)(rec::Load(gocpp::recv(p->p)));
    }

    void rec::StoreNoWB(struct atomicMSpanPointer* p, struct mspan* s)
    {
        rec::StoreNoWB(gocpp::recv(p->p), unsafe::Pointer(s));
    }

}

