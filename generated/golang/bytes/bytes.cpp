// generated by GoCpp from file '$(ImportDir)/bytes/bytes.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/bytes/bytes.h"
#include "gocpp/support.h"

#include "golang/bytes/buffer.h"
#include "golang/internal/bytealg/bytealg.h"
#include "golang/internal/bytealg/compare_native.h"
#include "golang/internal/bytealg/count_native.h"
#include "golang/internal/bytealg/index_amd64.h"
#include "golang/internal/bytealg/index_native.h"
#include "golang/internal/bytealg/indexbyte_native.h"
#include "golang/internal/bytealg/lastindexbyte_generic.h"
#include "golang/unicode/digit.h"
#include "golang/unicode/graphic.h"
#include "golang/unicode/letter.h"
#include "golang/unicode/utf8/utf8.h"

// Package bytes implements functions for the manipulation of byte slices.
// It is analogous to the facilities of the [strings] package.
namespace golang::bytes
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Equal reports whether a and b
    // are the same length and contain the same bytes.
    // A nil argument is equivalent to an empty slice.
    bool Equal(gocpp::slice<unsigned char> a, gocpp::slice<unsigned char> b)
    {
        return gocpp::string(a) == gocpp::string(b);
    }

    // Compare returns an integer comparing two byte slices lexicographically.
    // The result will be 0 if a == b, -1 if a < b, and +1 if a > b.
    // A nil argument is equivalent to an empty slice.
    int Compare(gocpp::slice<unsigned char> a, gocpp::slice<unsigned char> b)
    {
        return bytealg::Compare(a, b);
    }

    // explode splits s into a slice of UTF-8 sequences, one per Unicode code point (still slices of bytes),
    // up to a maximum of n byte slices. Invalid UTF-8 sequences are chopped into individual bytes.
    gocpp::slice<gocpp::slice<unsigned char>> explode(gocpp::slice<unsigned char> s, int n)
    {
        if(n <= 0 || n > len(s))
        {
            n = len(s);
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), n);
        int size = {};
        auto na = 0;
        for(; len(s) > 0; )
        {
            if(na + 1 >= n)
            {
                a[na] = s;
                na++;
                break;
            }
            std::tie(std::ignore, size) = utf8::DecodeRune(s);
            a[na] = s.make_slice(0, size, size);
            s = s.make_slice(size);
            na++;
        }
        return a.make_slice(0, na);
    }

    // Count counts the number of non-overlapping instances of sep in s.
    // If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.
    int Count(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        if(len(sep) == 0)
        {
            return utf8::RuneCount(s) + 1;
        }
        if(len(sep) == 1)
        {
            return bytealg::Count(s, sep[0]);
        }
        auto n = 0;
        for(; ; )
        {
            auto i = Index(s, sep);
            if(i == - 1)
            {
                return n;
            }
            n++;
            s = s.make_slice(i + len(sep));
        }
    }

    // Contains reports whether subslice is within b.
    bool Contains(gocpp::slice<unsigned char> b, gocpp::slice<unsigned char> subslice)
    {
        return Index(b, subslice) != - 1;
    }

    // ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.
    bool ContainsAny(gocpp::slice<unsigned char> b, gocpp::string chars)
    {
        return IndexAny(b, chars) >= 0;
    }

    // ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.
    bool ContainsRune(gocpp::slice<unsigned char> b, gocpp::rune r)
    {
        return IndexRune(b, r) >= 0;
    }

    // ContainsFunc reports whether any of the UTF-8-encoded code points r within b satisfy f(r).
    bool ContainsFunc(gocpp::slice<unsigned char> b, std::function<bool (gocpp::rune _1)> f)
    {
        return IndexFunc(b, f) >= 0;
    }

    // IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.
    int IndexByte(gocpp::slice<unsigned char> b, unsigned char c)
    {
        return bytealg::IndexByte(b, c);
    }

    int indexBytePortable(gocpp::slice<unsigned char> s, unsigned char c)
    {
        for(auto [i, b] : s)
        {
            if(b == c)
            {
                return i;
            }
        }
        return - 1;
    }

    // LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.
    int LastIndex(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        auto n = len(sep);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    return len(s);
                    break;
                case 1:
                    return bytealg::LastIndexByte(s, sep[0]);
                    break;
                case 2:
                    if(Equal(s, sep))
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
            }
        }
        return bytealg::LastIndexRabinKarp(s, sep);
    }

    // LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.
    int LastIndexByte(gocpp::slice<unsigned char> s, unsigned char c)
    {
        return bytealg::LastIndexByte(s, c);
    }

    // IndexRune interprets s as a sequence of UTF-8-encoded code points.
    // It returns the byte index of the first occurrence in s of the given rune.
    // It returns -1 if rune is not present in s.
    // If r is utf8.RuneError, it returns the first instance of any
    // invalid UTF-8 byte sequence.
    int IndexRune(gocpp::slice<unsigned char> s, gocpp::rune r)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(0 <= r && r < utf8::RuneSelf) { conditionId = 0; }
            else if(r == utf8::RuneError) { conditionId = 1; }
            else if(! utf8::ValidRune(r)) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    return IndexByte(s, (unsigned char)(r));
                    break;
                case 1:
                    for(auto i = 0; i < len(s); )
                    {
                        auto [r1, n] = utf8::DecodeRune(s.make_slice(i));
                        if(r1 == utf8::RuneError)
                        {
                            return i;
                        }
                        i += n;
                    }
                    return - 1;
                    break;
                case 2:
                    return - 1;
                    break;
                default:
                    gocpp::array<unsigned char, utf8::UTFMax> b = {};
                    auto n = utf8::EncodeRune(b.make_slice(0), r);
                    return Index(s, b.make_slice(0, n));
                    break;
            }
        }
    }

    // IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.
    // It returns the byte index of the first occurrence in s of any of the Unicode
    // code points in chars. It returns -1 if chars is empty or if there is no code
    // point in common.
    int IndexAny(gocpp::slice<unsigned char> s, gocpp::string chars)
    {
        if(chars == ""_s)
        {
            return - 1;
        }
        if(len(s) == 1)
        {
            auto r = gocpp::rune(s[0]);
            if(r >= utf8::RuneSelf)
            {
                auto it_0 = std::begin(chars);
                std::tie(std::ignore, r) = *it_0;
                for(; it_0 != std::end(chars); std::tie(std::ignore, r) = *++it_0)
                {
                    if(r == utf8::RuneError)
                    {
                        return 0;
                    }
                }
                return - 1;
            }
            if(bytealg::IndexByteString(chars, s[0]) >= 0)
            {
                return 0;
            }
            return - 1;
        }
        if(len(chars) == 1)
        {
            auto r = gocpp::rune(chars[0]);
            if(r >= utf8::RuneSelf)
            {
                r = utf8::RuneError;
            }
            return IndexRune(s, r);
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto [i, c] : s)
                {
                    if(rec::contains(gocpp::recv(as), c))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        int width = {};
        for(auto i = 0; i < len(s); i += width)
        {
            auto r = gocpp::rune(s[i]);
            if(r < utf8::RuneSelf)
            {
                if(bytealg::IndexByteString(chars, s[i]) >= 0)
                {
                    return i;
                }
                width = 1;
                continue;
            }
            std::tie(r, width) = utf8::DecodeRune(s.make_slice(i));
            if(r != utf8::RuneError)
            {
                if(len(chars) == width)
                {
                    if(chars == gocpp::string(r))
                    {
                        return i;
                    }
                    continue;
                }
                if(bytealg::MaxLen >= width)
                {
                    if(bytealg::IndexString(chars, gocpp::string(r)) >= 0)
                    {
                        return i;
                    }
                    continue;
                }
            }
            for(auto [gocpp_ignored, ch] : chars)
            {
                if(r == ch)
                {
                    return i;
                }
            }
        }
        return - 1;
    }

    // LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code
    // points. It returns the byte index of the last occurrence in s of any of
    // the Unicode code points in chars. It returns -1 if chars is empty or if
    // there is no code point in common.
    int LastIndexAny(gocpp::slice<unsigned char> s, gocpp::string chars)
    {
        if(chars == ""_s)
        {
            return - 1;
        }
        if(len(s) > 8)
        {
            if(auto [as, isASCII] = makeASCIISet(chars); isASCII)
            {
                for(auto i = len(s) - 1; i >= 0; i--)
                {
                    if(rec::contains(gocpp::recv(as), s[i]))
                    {
                        return i;
                    }
                }
                return - 1;
            }
        }
        if(len(s) == 1)
        {
            auto r = gocpp::rune(s[0]);
            if(r >= utf8::RuneSelf)
            {
                auto it_0 = std::begin(chars);
                std::tie(std::ignore, r) = *it_0;
                for(; it_0 != std::end(chars); std::tie(std::ignore, r) = *++it_0)
                {
                    if(r == utf8::RuneError)
                    {
                        return 0;
                    }
                }
                return - 1;
            }
            if(bytealg::IndexByteString(chars, s[0]) >= 0)
            {
                return 0;
            }
            return - 1;
        }
        if(len(chars) == 1)
        {
            auto cr = gocpp::rune(chars[0]);
            if(cr >= utf8::RuneSelf)
            {
                cr = utf8::RuneError;
            }
            for(auto i = len(s); i > 0; )
            {
                auto [r, size] = utf8::DecodeLastRune(s.make_slice(0, i));
                i -= size;
                if(r == cr)
                {
                    return i;
                }
            }
            return - 1;
        }
        for(auto i = len(s); i > 0; )
        {
            auto r = gocpp::rune(s[i - 1]);
            if(r < utf8::RuneSelf)
            {
                if(bytealg::IndexByteString(chars, s[i - 1]) >= 0)
                {
                    return i - 1;
                }
                i--;
                continue;
            }
            int size;
            std::tie(r, size) = utf8::DecodeLastRune(s.make_slice(0, i));
            i -= size;
            if(r != utf8::RuneError)
            {
                if(len(chars) == size)
                {
                    if(chars == gocpp::string(r))
                    {
                        return i;
                    }
                    continue;
                }
                if(bytealg::MaxLen >= size)
                {
                    if(bytealg::IndexString(chars, gocpp::string(r)) >= 0)
                    {
                        return i;
                    }
                    continue;
                }
            }
            for(auto [gocpp_ignored, ch] : chars)
            {
                if(r == ch)
                {
                    return i;
                }
            }
        }
        return - 1;
    }

    // Generic split: splits after each instance of sep,
    // including sepSave bytes of sep in the subslices.
    gocpp::slice<gocpp::slice<unsigned char>> genSplit(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep, int sepSave, int n)
    {
        if(n == 0)
        {
            return nullptr;
        }
        if(len(sep) == 0)
        {
            return explode(s, n);
        }
        if(n < 0)
        {
            n = Count(s, sep) + 1;
        }
        if(n > len(s) + 1)
        {
            n = len(s) + 1;
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), n);
        n--;
        auto i = 0;
        for(; i < n; )
        {
            auto m = Index(s, sep);
            if(m < 0)
            {
                break;
            }
            a[i] = s.make_slice(0, m + sepSave, m + sepSave);
            s = s.make_slice(m + len(sep));
            i++;
        }
        a[i] = s;
        return a.make_slice(0, i + 1);
    }

    // SplitN slices s into subslices separated by sep and returns a slice of
    // the subslices between those separators.
    // If sep is empty, SplitN splits after each UTF-8 sequence.
    // The count determines the number of subslices to return:
    //
    //	n > 0: at most n subslices; the last subslice will be the unsplit remainder.
    //	n == 0: the result is nil (zero subslices)
    //	n < 0: all subslices
    //
    // To split around the first instance of a separator, see Cut.
    gocpp::slice<gocpp::slice<unsigned char>> SplitN(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep, int n)
    {
        return genSplit(s, sep, 0, n);
    }

    // SplitAfterN slices s into subslices after each instance of sep and
    // returns a slice of those subslices.
    // If sep is empty, SplitAfterN splits after each UTF-8 sequence.
    // The count determines the number of subslices to return:
    //
    //	n > 0: at most n subslices; the last subslice will be the unsplit remainder.
    //	n == 0: the result is nil (zero subslices)
    //	n < 0: all subslices
    gocpp::slice<gocpp::slice<unsigned char>> SplitAfterN(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep, int n)
    {
        return genSplit(s, sep, len(sep), n);
    }

    // Split slices s into all subslices separated by sep and returns a slice of
    // the subslices between those separators.
    // If sep is empty, Split splits after each UTF-8 sequence.
    // It is equivalent to SplitN with a count of -1.
    //
    // To split around the first instance of a separator, see Cut.
    gocpp::slice<gocpp::slice<unsigned char>> Split(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        return genSplit(s, sep, 0, - 1);
    }

    // SplitAfter slices s into all subslices after each instance of sep and
    // returns a slice of those subslices.
    // If sep is empty, SplitAfter splits after each UTF-8 sequence.
    // It is equivalent to SplitAfterN with a count of -1.
    gocpp::slice<gocpp::slice<unsigned char>> SplitAfter(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        return genSplit(s, sep, len(sep), - 1);
    }

    gocpp::array<uint8_t, 256> asciiSpace = gocpp::Init<gocpp::array<uint8_t, 256>>([](auto& x) {
        x['\t'] = 1;
        x['\n'] = 1;
        x['\v'] = 1;
        x['\f'] = 1;
        x['\r'] = 1;
        x[' '] = 1;
    });
    // Fields interprets s as a sequence of UTF-8-encoded code points.
    // It splits the slice s around each instance of one or more consecutive white space
    // characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an
    // empty slice if s contains only white space.
    gocpp::slice<gocpp::slice<unsigned char>> Fields(gocpp::slice<unsigned char> s)
    {
        auto n = 0;
        auto wasSpace = 1;
        auto setBits = uint8_t(0);
        for(auto i = 0; i < len(s); i++)
        {
            auto r = s[i];
            setBits |= r;
            auto isSpace = int(asciiSpace[r]);
            n += wasSpace & ~ isSpace;
            wasSpace = isSpace;
        }
        if(setBits >= utf8::RuneSelf)
        {
            return FieldsFunc(s, unicode::IsSpace);
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), n);
        auto na = 0;
        auto fieldStart = 0;
        auto i = 0;
        for(; i < len(s) && asciiSpace[s[i]] != 0; )
        {
            i++;
        }
        fieldStart = i;
        for(; i < len(s); )
        {
            if(asciiSpace[s[i]] == 0)
            {
                i++;
                continue;
            }
            a[na] = s.make_slice(fieldStart, i, i);
            na++;
            i++;
            for(; i < len(s) && asciiSpace[s[i]] != 0; )
            {
                i++;
            }
            fieldStart = i;
        }
        if(fieldStart < len(s))
        {
            a[na] = s.make_slice(fieldStart, len(s), len(s));
        }
        return a;
    }

    // FieldsFunc interprets s as a sequence of UTF-8-encoded code points.
    // It splits the slice s at each run of code points c satisfying f(c) and
    // returns a slice of subslices of s. If all code points in s satisfy f(c), or
    // len(s) == 0, an empty slice is returned.
    //
    // FieldsFunc makes no guarantees about the order in which it calls f(c)
    // and assumes that f always returns the same value for a given c.
    gocpp::slice<gocpp::slice<unsigned char>> FieldsFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune _1)> f)
    {
        // A span is used to record a slice of s of the form s[start:end].
        // The start index is inclusive and the end index is exclusive.
        
        template<typename T> requires gocpp::GoStruct<T>
        span::operator T()
        {
            T result;
            result.start = this->start;
            result.end = this->end;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool span::operator==(const T& ref) const
        {
            if (start != ref.start) return false;
            if (end != ref.end) return false;
            return true;
        }

        std::ostream& span::PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << start;
            os << " " << end;
            os << '}';
            return os;
        }

        std::ostream& operator<<(std::ostream& os, const struct span& value)
        {
            return value.PrintTo(os);
        }

        auto spans = gocpp::make(gocpp::Tag<gocpp::slice<span>>(), 0, 32);
        auto start = - 1;
        for(auto i = 0; i < len(s); )
        {
            auto size = 1;
            auto r = gocpp::rune(s[i]);
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, size) = utf8::DecodeRune(s.make_slice(i));
            }
            if(f(r))
            {
                if(start >= 0)
                {
                    spans = append(spans, span {start, i});
                    start = - 1;
                }
            }
            else
            {
                if(start < 0)
                {
                    start = i;
                }
            }
            i += size;
        }
        if(start >= 0)
        {
            spans = append(spans, span {start, len(s)});
        }
        auto a = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::slice<unsigned char>>>(), len(spans));
        for(auto [i, span] : spans)
        {
            a[i] = s.make_slice(span.start, span.end, span.end);
        }
        return a;
    }

    // Join concatenates the elements of s to create a new byte slice. The separator
    // sep is placed between elements in the resulting slice.
    gocpp::slice<unsigned char> Join(gocpp::slice<gocpp::slice<unsigned char>> s, gocpp::slice<unsigned char> sep)
    {
        if(len(s) == 0)
        {
            return gocpp::slice<unsigned char> {};
        }
        if(len(s) == 1)
        {
            return append(gocpp::slice<unsigned char>(nullptr), s[0]);
        }
        int n = {};
        if(len(sep) > 0)
        {
            if(len(sep) >= maxInt / (len(s) - 1))
            {
                gocpp::panic("bytes: Join output length overflow"_s);
            }
            n += len(sep) * (len(s) - 1);
        }
        for(auto [gocpp_ignored, v] : s)
        {
            if(len(v) > maxInt - n)
            {
                gocpp::panic("bytes: Join output length overflow"_s);
            }
            n += len(v);
        }
        auto b = bytealg::MakeNoZero(n);
        auto bp = copy(b, s[0]);
        for(auto [gocpp_ignored, v] : s.make_slice(1))
        {
            bp += copy(b.make_slice(bp), sep);
            bp += copy(b.make_slice(bp), v);
        }
        return b;
    }

    // HasPrefix reports whether the byte slice s begins with prefix.
    bool HasPrefix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> prefix)
    {
        return len(s) >= len(prefix) && Equal(s.make_slice(0, len(prefix)), prefix);
    }

    // HasSuffix reports whether the byte slice s ends with suffix.
    bool HasSuffix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> suffix)
    {
        return len(s) >= len(suffix) && Equal(s.make_slice(len(s) - len(suffix)), suffix);
    }

    // Map returns a copy of the byte slice s with all its characters modified
    // according to the mapping function. If mapping returns a negative value, the character is
    // dropped from the byte slice with no replacement. The characters in s and the
    // output are interpreted as UTF-8-encoded code points.
    gocpp::slice<unsigned char> Map(std::function<gocpp::rune (gocpp::rune r)> mapping, gocpp::slice<unsigned char> s)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(s));
        for(auto i = 0; i < len(s); )
        {
            auto wid = 1;
            auto r = gocpp::rune(s[i]);
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, wid) = utf8::DecodeRune(s.make_slice(i));
            }
            r = mapping(r);
            if(r >= 0)
            {
                b = utf8::AppendRune(b, r);
            }
            i += wid;
        }
        return b;
    }

    // Repeat returns a new byte slice consisting of count copies of b.
    //
    // It panics if count is negative or if the result of (len(b) * count)
    // overflows.
    gocpp::slice<unsigned char> Repeat(gocpp::slice<unsigned char> b, int count)
    {
        if(count == 0)
        {
            return gocpp::slice<unsigned char> {};
        }
        if(count < 0)
        {
            gocpp::panic("bytes: negative Repeat count"_s);
        }
        if(len(b) >= maxInt / count)
        {
            gocpp::panic("bytes: Repeat output length overflow"_s);
        }
        auto n = len(b) * count;
        if(len(b) == 0)
        {
            return gocpp::slice<unsigned char> {};
        }
        // Past a certain chunk size it is counterproductive to use
        // larger chunks as the source of the write, as when the source
        // is too large we are basically just thrashing the CPU D-cache.
        // So if the result length is larger than an empirically-found
        // limit (8KB), we stop growing the source string once the limit
        // is reached and keep reusing the same source string - that
        // should therefore be always resident in the L1 cache - until we
        // have completed the construction of the result.
        // This yields significant speedups (up to +100%) in cases where
        // the result length is large (roughly, over L2 cache size).
        auto chunkLimit = 8 * 1024;
        auto chunkMax = n;
        if(chunkMax > chunkLimit)
        {
            chunkMax = chunkLimit / len(b) * len(b);
            if(chunkMax == 0)
            {
                chunkMax = len(b);
            }
        }
        auto nb = bytealg::MakeNoZero(n);
        auto bp = copy(nb, b);
        for(; bp < n; )
        {
            auto chunk = bp;
            if(chunk > chunkMax)
            {
                chunk = chunkMax;
            }
            bp += copy(nb.make_slice(bp), nb.make_slice(0, chunk));
        }
        return nb;
    }

    // ToUpper returns a copy of the byte slice s with all Unicode letters mapped to
    // their upper case.
    gocpp::slice<unsigned char> ToUpper(gocpp::slice<unsigned char> s)
    {
        auto [isASCII, hasLower] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasLower = hasLower || ('a' <= c && c <= 'z');
        }
        if(isASCII)
        {
            if(! hasLower)
            {
                return append(gocpp::slice<unsigned char>(""_s), s);
            }
            auto b = bytealg::MakeNoZero(len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('a' <= c && c <= 'z')
                {
                    c -= 'a' - 'A';
                }
                b[i] = c;
            }
            return b;
        }
        return Map(unicode::ToUpper, s);
    }

    // ToLower returns a copy of the byte slice s with all Unicode letters mapped to
    // their lower case.
    gocpp::slice<unsigned char> ToLower(gocpp::slice<unsigned char> s)
    {
        auto [isASCII, hasUpper] = std::tuple{true, false};
        for(auto i = 0; i < len(s); i++)
        {
            auto c = s[i];
            if(c >= utf8::RuneSelf)
            {
                isASCII = false;
                break;
            }
            hasUpper = hasUpper || ('A' <= c && c <= 'Z');
        }
        if(isASCII)
        {
            if(! hasUpper)
            {
                return append(gocpp::slice<unsigned char>(""_s), s);
            }
            auto b = bytealg::MakeNoZero(len(s));
            for(auto i = 0; i < len(s); i++)
            {
                auto c = s[i];
                if('A' <= c && c <= 'Z')
                {
                    c += 'a' - 'A';
                }
                b[i] = c;
            }
            return b;
        }
        return Map(unicode::ToLower, s);
    }

    // ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.
    gocpp::slice<unsigned char> ToTitle(gocpp::slice<unsigned char> s)
    {
        return Map(unicode::ToTitle, s);
    }

    // ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
    // upper case, giving priority to the special casing rules.
    gocpp::slice<unsigned char> ToUpperSpecial(unicode::SpecialCase c, gocpp::slice<unsigned char> s)
    {
        return Map(c.ToUpper, s);
    }

    // ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
    // lower case, giving priority to the special casing rules.
    gocpp::slice<unsigned char> ToLowerSpecial(unicode::SpecialCase c, gocpp::slice<unsigned char> s)
    {
        return Map(c.ToLower, s);
    }

    // ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
    // title case, giving priority to the special casing rules.
    gocpp::slice<unsigned char> ToTitleSpecial(unicode::SpecialCase c, gocpp::slice<unsigned char> s)
    {
        return Map(c.ToTitle, s);
    }

    // ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes
    // representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.
    gocpp::slice<unsigned char> ToValidUTF8(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> replacement)
    {
        auto b = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, len(s) + len(replacement));
        auto invalid = false;
        for(auto i = 0; i < len(s); )
        {
            auto c = s[i];
            if(c < utf8::RuneSelf)
            {
                i++;
                invalid = false;
                b = append(b, c);
                continue;
            }
            auto [gocpp_id_0, wid] = utf8::DecodeRune(s.make_slice(i));
            if(wid == 1)
            {
                i++;
                if(! invalid)
                {
                    invalid = true;
                    b = append(b, replacement);
                }
                continue;
            }
            invalid = false;
            b = append(b, s.make_slice(i, i + wid));
            i += wid;
        }
        return b;
    }

    // isSeparator reports whether the rune could mark a word boundary.
    // TODO: update when package unicode captures more of the properties.
    bool isSeparator(gocpp::rune r)
    {
        if(r <= 0x7F)
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if('0' <= r && r <= '9') { conditionId = 0; }
                else if('a' <= r && r <= 'z') { conditionId = 1; }
                else if('A' <= r && r <= 'Z') { conditionId = 2; }
                else if(r == '_') { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        return false;
                        break;
                    case 1:
                        return false;
                        break;
                    case 2:
                        return false;
                        break;
                    case 3:
                        return false;
                        break;
                }
            }
            return true;
        }
        if(unicode::IsLetter(r) || unicode::IsDigit(r))
        {
            return false;
        }
        return unicode::IsSpace(r);
    }

    // Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
    // words mapped to their title case.
    //
    // Deprecated: The rule Title uses for word boundaries does not handle Unicode
    // punctuation properly. Use golang.org/x/text/cases instead.
    gocpp::slice<unsigned char> Title(gocpp::slice<unsigned char> s)
    {
        auto prev = ' ';
        return Map([=](gocpp::rune r) mutable -> gocpp::rune
        {
            if(isSeparator(prev))
            {
                prev = r;
                return unicode::ToTitle(r);
            }
            prev = r;
            return r;
        }, s);
    }

    // TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off
    // all leading UTF-8-encoded code points c that satisfy f(c).
    gocpp::slice<unsigned char> TrimLeftFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        auto i = indexFunc(s, f, false);
        if(i == - 1)
        {
            return nullptr;
        }
        return s.make_slice(i);
    }

    // TrimRightFunc returns a subslice of s by slicing off all trailing
    // UTF-8-encoded code points c that satisfy f(c).
    gocpp::slice<unsigned char> TrimRightFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        auto i = lastIndexFunc(s, f, false);
        if(i >= 0 && s[i] >= utf8::RuneSelf)
        {
            auto [gocpp_id_1, wid] = utf8::DecodeRune(s.make_slice(i));
            i += wid;
        }
        else
        {
            i++;
        }
        return s.make_slice(0, i);
    }

    // TrimFunc returns a subslice of s by slicing off all leading and trailing
    // UTF-8-encoded code points c that satisfy f(c).
    gocpp::slice<unsigned char> TrimFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        return TrimRightFunc(TrimLeftFunc(s, f), f);
    }

    // TrimPrefix returns s without the provided leading prefix string.
    // If s doesn't start with prefix, s is returned unchanged.
    gocpp::slice<unsigned char> TrimPrefix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> prefix)
    {
        if(HasPrefix(s, prefix))
        {
            return s.make_slice(len(prefix));
        }
        return s;
    }

    // TrimSuffix returns s without the provided trailing suffix string.
    // If s doesn't end with suffix, s is returned unchanged.
    gocpp::slice<unsigned char> TrimSuffix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> suffix)
    {
        if(HasSuffix(s, suffix))
        {
            return s.make_slice(0, len(s) - len(suffix));
        }
        return s;
    }

    // IndexFunc interprets s as a sequence of UTF-8-encoded code points.
    // It returns the byte index in s of the first Unicode
    // code point satisfying f(c), or -1 if none do.
    int IndexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        return indexFunc(s, f, true);
    }

    // LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.
    // It returns the byte index in s of the last Unicode
    // code point satisfying f(c), or -1 if none do.
    int LastIndexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f)
    {
        return lastIndexFunc(s, f, true);
    }

    // indexFunc is the same as IndexFunc except that if
    // truth==false, the sense of the predicate function is
    // inverted.
    int indexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f, bool truth)
    {
        auto start = 0;
        for(; start < len(s); )
        {
            auto wid = 1;
            auto r = gocpp::rune(s[start]);
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, wid) = utf8::DecodeRune(s.make_slice(start));
            }
            if(f(r) == truth)
            {
                return start;
            }
            start += wid;
        }
        return - 1;
    }

    // lastIndexFunc is the same as LastIndexFunc except that if
    // truth==false, the sense of the predicate function is
    // inverted.
    int lastIndexFunc(gocpp::slice<unsigned char> s, std::function<bool (gocpp::rune r)> f, bool truth)
    {
        for(auto i = len(s); i > 0; )
        {
            auto [r, size] = std::tuple{gocpp::rune(s[i - 1]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, size) = utf8::DecodeLastRune(s.make_slice(0, i));
            }
            i -= size;
            if(f(r) == truth)
            {
                return i;
            }
        }
        return - 1;
    }

    // asciiSet is a 32-byte value, where each bit represents the presence of a
    // given ASCII character in the set. The 128-bits of the lower 16 bytes,
    // starting with the least-significant bit of the lowest word to the
    // most-significant bit of the highest word, map to the full range of all
    // 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,
    // ensuring that any non-ASCII character will be reported as not in the set.
    // This allocates a total of 32 bytes even though the upper half
    // is unused to avoid bounds checks in asciiSet.contains.
    // makeASCIISet creates a set of ASCII characters and reports whether all
    // characters in chars are ASCII.
    std::tuple<bytes::asciiSet, bool> makeASCIISet(gocpp::string chars)
    {
        bytes::asciiSet as;
        bool ok;
        for(auto i = 0; i < len(chars); i++)
        {
            auto c = chars[i];
            if(c >= utf8::RuneSelf)
            {
                return {as, false};
            }
            as[c / 32] |= 1 << (c % 32);
        }
        return {as, true};
    }

    // contains reports whether c is inside the set.
    bool rec::contains(golang::bytes::asciiSet* as, unsigned char c)
    {
        return (as[c / 32] & (1 << (c % 32))) != 0;
    }

    // containsRune is a simplified version of strings.ContainsRune
    // to avoid importing the strings package.
    // We avoid bytes.ContainsRune to avoid allocating a temporary copy of s.
    bool containsRune(gocpp::string s, gocpp::rune r)
    {
        for(auto [gocpp_ignored, c] : s)
        {
            if(c == r)
            {
                return true;
            }
        }
        return false;
    }

    // Trim returns a subslice of s by slicing off all leading and
    // trailing UTF-8-encoded code points contained in cutset.
    gocpp::slice<unsigned char> Trim(gocpp::slice<unsigned char> s, gocpp::string cutset)
    {
        if(len(s) == 0)
        {
            return nullptr;
        }
        if(cutset == ""_s)
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(trimRightByte(s, cutset[0]), cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(trimRightASCII(s, & as), & as);
        }
        return trimLeftUnicode(trimRightUnicode(s, cutset), cutset);
    }

    // TrimLeft returns a subslice of s by slicing off all leading
    // UTF-8-encoded code points contained in cutset.
    gocpp::slice<unsigned char> TrimLeft(gocpp::slice<unsigned char> s, gocpp::string cutset)
    {
        if(len(s) == 0)
        {
            return nullptr;
        }
        if(cutset == ""_s)
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimLeftByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimLeftASCII(s, & as);
        }
        return trimLeftUnicode(s, cutset);
    }

    gocpp::slice<unsigned char> trimLeftByte(gocpp::slice<unsigned char> s, unsigned char c)
    {
        for(; len(s) > 0 && s[0] == c; )
        {
            s = s.make_slice(1);
        }
        if(len(s) == 0)
        {
            return nullptr;
        }
        return s;
    }

    gocpp::slice<unsigned char> trimLeftASCII(gocpp::slice<unsigned char> s, golang::bytes::asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[0]))
            {
                break;
            }
            s = s.make_slice(1);
        }
        if(len(s) == 0)
        {
            return nullptr;
        }
        return s;
    }

    gocpp::slice<unsigned char> trimLeftUnicode(gocpp::slice<unsigned char> s, gocpp::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{gocpp::rune(s[0]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeRune(s);
            }
            if(! containsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(n);
        }
        if(len(s) == 0)
        {
            return nullptr;
        }
        return s;
    }

    // TrimRight returns a subslice of s by slicing off all trailing
    // UTF-8-encoded code points that are contained in cutset.
    gocpp::slice<unsigned char> TrimRight(gocpp::slice<unsigned char> s, gocpp::string cutset)
    {
        if(len(s) == 0 || cutset == ""_s)
        {
            return s;
        }
        if(len(cutset) == 1 && cutset[0] < utf8::RuneSelf)
        {
            return trimRightByte(s, cutset[0]);
        }
        if(auto [as, ok] = makeASCIISet(cutset); ok)
        {
            return trimRightASCII(s, & as);
        }
        return trimRightUnicode(s, cutset);
    }

    gocpp::slice<unsigned char> trimRightByte(gocpp::slice<unsigned char> s, unsigned char c)
    {
        for(; len(s) > 0 && s[len(s) - 1] == c; )
        {
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    gocpp::slice<unsigned char> trimRightASCII(gocpp::slice<unsigned char> s, golang::bytes::asciiSet* as)
    {
        for(; len(s) > 0; )
        {
            if(! rec::contains(gocpp::recv(as), s[len(s) - 1]))
            {
                break;
            }
            s = s.make_slice(0, len(s) - 1);
        }
        return s;
    }

    gocpp::slice<unsigned char> trimRightUnicode(gocpp::slice<unsigned char> s, gocpp::string cutset)
    {
        for(; len(s) > 0; )
        {
            auto [r, n] = std::tuple{gocpp::rune(s[len(s) - 1]), 1};
            if(r >= utf8::RuneSelf)
            {
                std::tie(r, n) = utf8::DecodeLastRune(s);
            }
            if(! containsRune(cutset, r))
            {
                break;
            }
            s = s.make_slice(0, len(s) - n);
        }
        return s;
    }

    // TrimSpace returns a subslice of s by slicing off all leading and
    // trailing white space, as defined by Unicode.
    gocpp::slice<unsigned char> TrimSpace(gocpp::slice<unsigned char> s)
    {
        auto start = 0;
        for(; start < len(s); start++)
        {
            auto c = s[start];
            if(c >= utf8::RuneSelf)
            {
                return TrimFunc(s.make_slice(start), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        auto stop = len(s);
        for(; stop > start; stop--)
        {
            auto c = s[stop - 1];
            if(c >= utf8::RuneSelf)
            {
                return TrimFunc(s.make_slice(start, stop), unicode::IsSpace);
            }
            if(asciiSpace[c] == 0)
            {
                break;
            }
        }
        if(start == stop)
        {
            return nullptr;
        }
        return s.make_slice(start, stop);
    }

    // Runes interprets s as a sequence of UTF-8-encoded code points.
    // It returns a slice of runes (Unicode code points) equivalent to s.
    gocpp::slice<gocpp::rune> Runes(gocpp::slice<unsigned char> s)
    {
        auto t = gocpp::make(gocpp::Tag<gocpp::slice<gocpp::rune>>(), utf8::RuneCount(s));
        auto i = 0;
        for(; len(s) > 0; )
        {
            auto [r, l] = utf8::DecodeRune(s);
            t[i] = r;
            i++;
            s = s.make_slice(l);
        }
        return t;
    }

    // Replace returns a copy of the slice s with the first n
    // non-overlapping instances of old replaced by new.
    // If old is empty, it matches at the beginning of the slice
    // and after each UTF-8 sequence, yielding up to k+1 replacements
    // for a k-rune slice.
    // If n < 0, there is no limit on the number of replacements.
    gocpp::slice<unsigned char> Replace(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> old, gocpp::slice<unsigned char> go_new, int n)
    {
        auto m = 0;
        if(n != 0)
        {
            m = Count(s, old);
        }
        if(m == 0)
        {
            return append(gocpp::slice<unsigned char>(nullptr), s);
        }
        if(n < 0 || m < n)
        {
            n = m;
        }
        auto t = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), len(s) + n * (len(go_new) - len(old)));
        auto w = 0;
        auto start = 0;
        for(auto i = 0; i < n; i++)
        {
            auto j = start;
            if(len(old) == 0)
            {
                if(i > 0)
                {
                    auto [gocpp_id_2, wid] = utf8::DecodeRune(s.make_slice(start));
                    j += wid;
                }
            }
            else
            {
                j += Index(s.make_slice(start), old);
            }
            w += copy(t.make_slice(w), s.make_slice(start, j));
            w += copy(t.make_slice(w), go_new);
            start = j + len(old);
        }
        w += copy(t.make_slice(w), s.make_slice(start));
        return t.make_slice(0, w);
    }

    // ReplaceAll returns a copy of the slice s with all
    // non-overlapping instances of old replaced by new.
    // If old is empty, it matches at the beginning of the slice
    // and after each UTF-8 sequence, yielding up to k+1 replacements
    // for a k-rune slice.
    gocpp::slice<unsigned char> ReplaceAll(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> old, gocpp::slice<unsigned char> go_new)
    {
        return Replace(s, old, go_new, - 1);
    }

    // EqualFold reports whether s and t, interpreted as UTF-8 strings,
    // are equal under simple Unicode case-folding, which is a more general
    // form of case-insensitivity.
    bool EqualFold(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> t)
    {
        auto i = 0;
        for(; i < len(s) && i < len(t); i++)
        {
            auto sr = s[i];
            auto tr = t[i];
            if(sr | tr >= utf8::RuneSelf)
            {
                goto hasUnicode;
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
            {
                continue;
            }
            return false;
        }
        return len(s) == len(t);
        hasUnicode:
        s = s.make_slice(i);
        t = t.make_slice(i);
        for(; len(s) != 0 && len(t) != 0; )
        {
            // Extract first rune from each.
            gocpp::rune sr = {};
            gocpp::rune tr = {};
            if(s[0] < utf8::RuneSelf)
            {
                std::tie(sr, s) = std::tuple{gocpp::rune(s[0]), s.make_slice(1)};
            }
            else
            {
                auto [r, size] = utf8::DecodeRune(s);
                std::tie(sr, s) = std::tuple{r, s.make_slice(size)};
            }
            if(t[0] < utf8::RuneSelf)
            {
                std::tie(tr, t) = std::tuple{gocpp::rune(t[0]), t.make_slice(1)};
            }
            else
            {
                auto [r, size] = utf8::DecodeRune(t);
                std::tie(tr, t) = std::tuple{r, t.make_slice(size)};
            }
            if(tr == sr)
            {
                continue;
            }
            if(tr < sr)
            {
                std::tie(tr, sr) = std::tuple{sr, tr};
            }
            if(tr < utf8::RuneSelf)
            {
                if('A' <= sr && sr <= 'Z' && tr == sr + 'a' - 'A')
                {
                    continue;
                }
                return false;
            }
            auto r = unicode::SimpleFold(sr);
            for(; r != sr && r < tr; )
            {
                r = unicode::SimpleFold(r);
            }
            if(r == tr)
            {
                continue;
            }
            return false;
        }
        return len(s) == len(t);
    }

    // Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.
    int Index(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        auto n = len(sep);
        //Go switch emulation
        {
            int conditionId = -1;
            if(n == 0) { conditionId = 0; }
            else if(n == 1) { conditionId = 1; }
            else if(n == len(s)) { conditionId = 2; }
            else if(n > len(s)) { conditionId = 3; }
            else if(n <= bytealg::MaxLen) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    return 0;
                    break;
                case 1:
                    return IndexByte(s, sep[0]);
                    break;
                case 2:
                    if(Equal(sep, s))
                    {
                        return 0;
                    }
                    return - 1;
                    break;
                case 3:
                    return - 1;
                    break;
                case 4:
                    if(len(s) <= bytealg::MaxBruteForce)
                    {
                        return bytealg::Index(s, sep);
                    }
                    auto c0 = sep[0];
                    auto c1 = sep[1];
                    auto i = 0;
                    auto t = len(s) - n + 1;
                    auto fails = 0;
                    for(; i < t; )
                    {
                        if(s[i] != c0)
                        {
                            auto o = IndexByte(s.make_slice(i + 1, t), c0);
                            if(o < 0)
                            {
                                return - 1;
                            }
                            i += o + 1;
                        }
                        if(s[i + 1] == c1 && Equal(s.make_slice(i, i + n), sep))
                        {
                            return i;
                        }
                        fails++;
                        i++;
                        if(fails > bytealg::Cutover(i))
                        {
                            auto r = bytealg::Index(s.make_slice(i), sep);
                            if(r >= 0)
                            {
                                return r + i;
                            }
                            return - 1;
                        }
                    }
                    return - 1;
                    break;
            }
        }
        auto c0 = sep[0];
        auto c1 = sep[1];
        auto i = 0;
        auto fails = 0;
        auto t = len(s) - n + 1;
        for(; i < t; )
        {
            if(s[i] != c0)
            {
                auto o = IndexByte(s.make_slice(i + 1, t), c0);
                if(o < 0)
                {
                    break;
                }
                i += o + 1;
            }
            if(s[i + 1] == c1 && Equal(s.make_slice(i, i + n), sep))
            {
                return i;
            }
            i++;
            fails++;
            if(fails >= 4 + (i >> 4) && i < t)
            {
                auto j = bytealg::IndexRabinKarp(s.make_slice(i), sep);
                if(j < 0)
                {
                    return - 1;
                }
                return i + j;
            }
        }
        return - 1;
    }

    // Cut slices s around the first instance of sep,
    // returning the text before and after sep.
    // The found result reports whether sep appears in s.
    // If sep does not appear in s, cut returns s, nil, false.
    //
    // Cut returns slices of the original slice s, not copies.
    std::tuple<gocpp::slice<unsigned char>, gocpp::slice<unsigned char>, bool> Cut(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> sep)
    {
        gocpp::slice<unsigned char> before;
        gocpp::slice<unsigned char> after;
        bool found;
        if(auto i = Index(s, sep); i >= 0)
        {
            return {s.make_slice(0, i), s.make_slice(i + len(sep)), true};
        }
        return {s, nullptr, false};
    }

    // Clone returns a copy of b[:len(b)].
    // The result may have additional unused capacity.
    // Clone(nil) returns nil.
    gocpp::slice<unsigned char> Clone(gocpp::slice<unsigned char> b)
    {
        if(b == nullptr)
        {
            return nullptr;
        }
        return append(gocpp::slice<unsigned char> {}, b);
    }

    // CutPrefix returns s without the provided leading prefix byte slice
    // and reports whether it found the prefix.
    // If s doesn't start with prefix, CutPrefix returns s, false.
    // If prefix is the empty byte slice, CutPrefix returns s, true.
    //
    // CutPrefix returns slices of the original slice s, not copies.
    std::tuple<gocpp::slice<unsigned char>, bool> CutPrefix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> prefix)
    {
        gocpp::slice<unsigned char> after;
        bool found;
        if(! HasPrefix(s, prefix))
        {
            return {s, false};
        }
        return {s.make_slice(len(prefix)), true};
    }

    // CutSuffix returns s without the provided ending suffix byte slice
    // and reports whether it found the suffix.
    // If s doesn't end with suffix, CutSuffix returns s, false.
    // If suffix is the empty byte slice, CutSuffix returns s, true.
    //
    // CutSuffix returns slices of the original slice s, not copies.
    std::tuple<gocpp::slice<unsigned char>, bool> CutSuffix(gocpp::slice<unsigned char> s, gocpp::slice<unsigned char> suffix)
    {
        gocpp::slice<unsigned char> before;
        bool found;
        if(! HasSuffix(s, suffix))
        {
            return {s, false};
        }
        return {s.make_slice(0, len(s) - len(suffix)), true};
    }

}

