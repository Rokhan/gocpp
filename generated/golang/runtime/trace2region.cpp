// generated by GoCpp from file '$(ImportDir)/runtime/trace2region.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2region.h"
#include "gocpp/support.h"

// #include "golang/internal/goarch/goarch.h"  [Ignored, known errors]
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mem.h"
#include "golang/runtime/panic.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    
    std::ostream& traceRegionAlloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << off;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceRegionAlloc& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& traceRegionAllocBlock::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _;
        os << " " << next;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceRegionAllocBlock& value)
    {
        return value.PrintTo(os);
    }

    notInHeap* alloc(struct traceRegionAlloc* a, uintptr_t n)
    {
        n = alignUp(n, goarch.PtrSize);
        if(a->head == nullptr || a->off + n > uintptr(len(a->head->data)))
        {
            if(n > uintptr(len(a->head->data)))
            {
                go_throw("traceRegion: alloc too large");
            }
            auto block = (traceRegionAllocBlock*)(sysAlloc(Sizeof(gocpp::recv(unsafe), traceRegionAllocBlock {}), & memstats.other_sys));
            if(block == nullptr)
            {
                go_throw("traceRegion: out of memory");
            }
            block->next = a->head;
            a->head = block;
            a->off = 0;
        }
        auto p = & a->head->data[a->off];
        a->off += n;
        return (notInHeap*)(Pointer(gocpp::recv(unsafe), p));
    }

    void drop(struct traceRegionAlloc* a)
    {
        for(; a->head != nullptr; )
        {
            auto block = a->head;
            a->head = block->next;
            sysFree(Pointer(gocpp::recv(unsafe), block), Sizeof(gocpp::recv(unsafe), traceRegionAllocBlock {}), & memstats.other_sys);
        }
    }

}

