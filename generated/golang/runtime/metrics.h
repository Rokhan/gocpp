// generated by GoCpp from file '$(ImportDir)/runtime/metrics.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/metrics.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/debug.h"
#include "golang/runtime/float.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
// #include "golang/runtime/race0.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/sema.h"  [Ignored, known errors]
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/slice.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    extern uint32_t metricsSema;
    extern bool metricsInit;
    extern gocpp::map<std::string, metricData> metrics;
    extern gocpp::slice<double> sizeClassBuckets;
    extern gocpp::slice<double> timeHistBuckets;
    struct metricData
    {
        statDepSet deps;
        std::function<void (statAggregate* in, metricValue* out)> compute;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct metricData& value);
    void metricsLock();
    void metricsUnlock();
    void initMetrics();
    void compute0(statAggregate* _, metricValue* out);
    void compute(metricReader f, statAggregate* _, metricValue* out);
    void godebug_registerMetric(std::string name, std::function<uint64_t ()> read);
    statDepSet makeStatDepSet(gocpp::slice<statDep> deps);
    template<typename... Args>
    statDepSet makeStatDepSet(Args... deps)
    {
        return makeStatDepSet(, gocpp::ToSlice<statDep>(deps...));
    }

    statDepSet difference(statDepSet s, statDepSet b);
    statDepSet union(statDepSet s, statDepSet b);
    bool empty(statDepSet* s);
    bool has(statDepSet* s, statDep d);
    struct heapStatsAggregate
    {
        uint64_t inObjects;
        uint64_t numObjects;
        uint64_t totalAllocated;
        uint64_t totalFreed;
        uint64_t totalAllocs;
        uint64_t totalFrees;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct heapStatsAggregate& value);
    void compute(struct heapStatsAggregate* a);
    struct sysStatsAggregate
    {
        uint64_t stacksSys;
        uint64_t mSpanSys;
        uint64_t mSpanInUse;
        uint64_t mCacheSys;
        uint64_t mCacheInUse;
        uint64_t buckHashSys;
        uint64_t gcMiscSys;
        uint64_t otherSys;
        uint64_t heapGoal;
        uint64_t gcCyclesDone;
        uint64_t gcCyclesForced;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct sysStatsAggregate& value);
    void compute(struct sysStatsAggregate* a);
    struct cpuStatsAggregate
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cpuStatsAggregate& value);
    void compute(struct cpuStatsAggregate* a);
    struct gcStatsAggregate
    {
        uint64_t heapScan;
        uint64_t stackScan;
        uint64_t globalsScan;
        uint64_t totalScan;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gcStatsAggregate& value);
    void compute(struct gcStatsAggregate* a);
    double nsToSec(int64_t ns);
    struct statAggregate
    {
        statDepSet ensured;
        heapStatsAggregate heapStats;
        sysStatsAggregate sysStats;
        cpuStatsAggregate cpuStats;
        gcStatsAggregate gcStats;

        using i