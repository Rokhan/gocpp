// generated by GoCpp from file '$(ImportDir)/runtime/mbitmap_allocheaders.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mbitmap_allocheaders.h"
#include "gocpp/support.h"

// #include "golang/internal/abi/symtab.h"  [Ignored, known errors]
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
#include "golang/internal/goarch/goarch.h"
// #include "golang/runtime/cgocall.h"  [Ignored, known errors]
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/intrinsics.h"
#include "golang/runtime/internal/sys/nih.h"
// #include "golang/runtime/lockrank.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
// #include "golang/runtime/mcache.h"  [Ignored, known errors]
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
// #include "golang/runtime/mgclimit.h"  [Ignored, known errors]
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
// #include "golang/runtime/os_windows.h"  [Ignored, known errors]
// #include "golang/runtime/pagetrace_off.h"  [Ignored, known errors]
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
// #include "golang/runtime/print.h"  [Ignored, known errors]
#include "golang/runtime/proc.h"
// #include "golang/runtime/rand.h"  [Ignored, known errors]
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/signal_windows.h"  [Ignored, known errors]
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
// #include "golang/runtime/time.h"  [Ignored, known errors]
#include "golang/runtime/trace2buf.h"
// #include "golang/runtime/trace2runtime.h"  [Ignored, known errors]
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
// #include "golang/runtime/traceback.h"  [Ignored, known errors]
#include "golang/runtime/type.h"
// #include "golang/runtime/typekind.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    bool heapBitsInSpan(uintptr_t userSize)
    {
        return userSize <= minSizeForMallocHeader;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    heapArenaPtrScalar::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heapArenaPtrScalar::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& heapArenaPtrScalar::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapArenaPtrScalar& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    typePointers::operator T()
    {
        T result;
        result.elem = this->elem;
        result.addr = this->addr;
        result.mask = this->mask;
        result.typ = this->typ;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool typePointers::operator==(const T& ref) const
    {
        if (elem != ref.elem) return false;
        if (addr != ref.addr) return false;
        if (mask != ref.mask) return false;
        if (typ != ref.typ) return false;
        return true;
    }

    std::ostream& typePointers::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << elem;
        os << " " << addr;
        os << " " << mask;
        os << " " << typ;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct typePointers& value)
    {
        return value.PrintTo(os);
    }

    typePointers typePointersOf(struct mspan* span, uintptr_t addr, uintptr_t size)
    {
        auto base = objBase(gocpp::recv(span), addr);
        auto tp = typePointersOfUnchecked(gocpp::recv(span), base);
        if(base == addr && size == span->elemsize)
        {
            return tp;
        }
        return fastForward(gocpp::recv(tp), addr - tp.addr, addr + size);
    }

    typePointers typePointersOfUnchecked(struct mspan* span, uintptr_t addr)
    {
        auto doubleCheck = false;
        if(doubleCheck && objBase(gocpp::recv(span), addr) != addr)
        {
            print("runtime: addr=", addr, " base=", objBase(gocpp::recv(span), addr), "\n");
            go_throw("typePointersOfUnchecked consisting of non-base-address for object");
        }
        auto spc = span->spanclass;
        if(noscan(gocpp::recv(spc)))
        {
            return typePointers {};
        }
        if(heapBitsInSpan(span->elemsize))
        {
            return gocpp::Init<typePointers>([](typePointers& x) { x.elem = addr; x.addr = addr; x.mask = heapBitsSmallForAddr(gocpp::recv(span), addr); });
        }
        _type* typ = {};
        if(sizeclass(gocpp::recv(spc)) != 0)
        {
            typ = *(_type**)(unsafe::Pointer(addr));
            addr += mallocHeaderSize;
        }
        else
        {
            typ = span->largeType;
        }
        auto gcdata = typ->GCData;
        return gocpp::Init<typePointers>([](typePointers& x) { x.elem = addr; x.addr = addr; x.mask = readUintptr(gcdata); x.typ = typ; });
    }

    typePointers typePointersOfType(struct mspan* span, abi::Type* typ, uintptr_t addr)
    {
        auto doubleCheck = false;
        if(doubleCheck && (typ == nullptr || typ->Kind_ & kindGCProg != 0))
        {
            go_throw("bad type passed to typePointersOfType");
        }
        if(noscan(gocpp::recv(span->spanclass)))
        {
            return typePointers {};
        }
        auto gcdata = typ->GCData;
        return gocpp::Init<typePointers>([](typePointers& x) { x.elem = addr; x.addr = addr; x.mask = readUintptr(gcdata); x.typ = typ; });
    }

    std::tuple<typePointers, uintptr_t> nextFast(struct typePointers tp)
    {
        if(tp.mask == 0)
        {
            return {tp, 0};
        }
        int i = {};
        if(goarch::PtrSize == 8)
        {
            i = sys::TrailingZeros64(uint64_t(tp.mask));
        }
        else
        {
            i = sys::TrailingZeros32(uint32_t(tp.mask));
        }
        tp.mask ^= uintptr_t(1) << (i & (ptrBits - 1));
        return {tp, tp.addr + uintptr_t(i) * goarch::PtrSize};
    }

    std::tuple<typePointers, uintptr_t> next(struct typePointers tp, uintptr_t limit)
    {
        for(; ; )
        {
            if(tp.mask != 0)
            {
                return nextFast(gocpp::recv(tp));
            }
            if(tp.typ == nullptr)
            {
                return {typePointers {}, 0};
            }
            if(tp.addr + goarch::PtrSize * ptrBits >= tp.elem + tp.typ->PtrBytes)
            {
                tp.elem += tp.typ->Size_;
                tp.addr = tp.elem;
            }
            else
            {
                tp.addr += ptrBits * goarch::PtrSize;
            }
            if(tp.addr >= limit)
            {
                return {typePointers {}, 0};
            }
            tp.mask = readUintptr(addb(tp.typ->GCData, (tp.addr - tp.elem) / goarch::PtrSize / 8));
            if(tp.addr + goarch::PtrSize * ptrBits > limit)
            {
                auto bits = (tp.addr + goarch::PtrSize * ptrBits - limit) / goarch::PtrSize;
                tp.mask &^= ((1 << (bits)) - 1) << (ptrBits - bits);
            }
        }
    }

    typePointers fastForward(struct typePointers tp, uintptr_t n, uintptr_t limit)
    {
        auto target = tp.addr + n;
        if(target >= limit)
        {
            return typePointers {};
        }
        if(tp.typ == nullptr)
        {
            tp.mask &^= (1 << ((target - tp.addr) / goarch::PtrSize)) - 1;
            if(tp.addr + goarch::PtrSize * ptrBits > limit)
            {
                auto bits = (tp.addr + goarch::PtrSize * ptrBits - limit) / goarch::PtrSize;
                tp.mask &^= ((1 << (bits)) - 1) << (ptrBits - bits);
            }
            return tp;
        }
        if(n >= tp.typ->Size_)
        {
            auto oldelem = tp.elem;
            tp.elem += (tp.addr - tp.elem + n) / tp.typ->Size_ * tp.typ->Size_;
            tp.addr = tp.elem + alignDown(n - (tp.elem - oldelem), ptrBits * goarch::PtrSize);
        }
        else
        {
            tp.addr += alignDown(n, ptrBits * goarch::PtrSize);
        }
        if(tp.addr - tp.elem >= tp.typ->PtrBytes)
        {
            tp.elem += tp.typ->Size_;
            tp.addr = tp.elem;
            tp.mask = readUintptr(tp.typ->GCData);
            if(tp.addr >= limit)
            {
                return typePointers {};
            }
        }
        else
        {
            tp.mask = readUintptr(addb(tp.typ->GCData, (tp.addr - tp.elem) / goarch::PtrSize / 8));
            tp.mask &^= (1 << ((target - tp.addr) / goarch::PtrSize)) - 1;
        }
        if(tp.addr + goarch::PtrSize * ptrBits > limit)
        {
            auto bits = (tp.addr + goarch::PtrSize * ptrBits - limit) / goarch::PtrSize;
            tp.mask &^= ((1 << (bits)) - 1) << (ptrBits - bits);
        }
        return tp;
    }

    uintptr_t objBase(struct mspan* span, uintptr_t addr)
    {
        return base(gocpp::recv(span)) + objIndex(gocpp::recv(span), addr) * span->elemsize;
    }

    void bulkBarrierPreWrite(uintptr_t dst, uintptr_t src, uintptr_t size, abi::Type* typ)
    {
        if((dst | src | size) & (goarch::PtrSize - 1) != 0)
        {
            go_throw("bulkBarrierPreWrite: unaligned arguments");
        }
        if(! writeBarrier.enabled)
        {
            return;
        }
        auto s = spanOf(dst);
        if(s == nullptr)
        {
            for(auto [_, datap] : activeModules())
            {
                if(datap->data <= dst && dst < datap->edata)
                {
                    bulkBarrierBitmap(dst, src, size, dst - datap->data, datap->gcdatamask.bytedata);
                    return;
                }
            }
            for(auto [_, datap] : activeModules())
            {
                if(datap->bss <= dst && dst < datap->ebss)
                {
                    bulkBarrierBitmap(dst, src, size, dst - datap->bss, datap->gcbssmask.bytedata);
                    return;
                }
            }
            return;
        }
        else
        if(get(gocpp::recv(s->state)) != mSpanInUse || dst < base(gocpp::recv(s)) || s->limit <= dst)
        {
            return;
        }
        auto buf = & ptr(gocpp::recv(getg()->m->p))->wbBuf;
        auto doubleCheck = false;
        if(doubleCheck)
        {
            doubleCheckTypePointersOfType(s, typ, dst, size);
        }
        typePointers tp = {};
        if(typ != nullptr && typ->Kind_ & kindGCProg == 0)
        {
            tp = typePointersOfType(gocpp::recv(s), typ, dst);
        }
        else
        {
            tp = typePointersOf(gocpp::recv(s), dst, size);
        }
        if(src == 0)
        {
            for(; ; )
            {
                uintptr_t addr = {};
                if(std::tie(tp, addr) = next(gocpp::recv(tp), dst + size); addr == 0)
                {
                    break;
                }
                auto dstx = (uintptr_t*)(unsafe::Pointer(addr));
                auto p = get1(gocpp::recv(buf));
                p[0] = *dstx;
            }
        }
        else
        {
            for(; ; )
            {
                uintptr_t addr = {};
                if(std::tie(tp, addr) = next(gocpp::recv(tp), dst + size); addr == 0)
                {
                    break;
                }
                auto dstx = (uintptr_t*)(unsafe::Pointer(addr));
                auto srcx = (uintptr_t*)(unsafe::Pointer(src + (addr - dst)));
                auto p = get2(gocpp::recv(buf));
                p[0] = *dstx;
                p[1] = *srcx;
            }
        }
    }

    void bulkBarrierPreWriteSrcOnly(uintptr_t dst, uintptr_t src, uintptr_t size, abi::Type* typ)
    {
        if((dst | src | size) & (goarch::PtrSize - 1) != 0)
        {
            go_throw("bulkBarrierPreWrite: unaligned arguments");
        }
        if(! writeBarrier.enabled)
        {
            return;
        }
        auto buf = & ptr(gocpp::recv(getg()->m->p))->wbBuf;
        auto s = spanOf(dst);
        auto doubleCheck = false;
        if(doubleCheck)
        {
            doubleCheckTypePointersOfType(s, typ, dst, size);
        }
        typePointers tp = {};
        if(typ != nullptr && typ->Kind_ & kindGCProg == 0)
        {
            tp = typePointersOfType(gocpp::recv(s), typ, dst);
        }
        else
        {
            tp = typePointersOf(gocpp::recv(s), dst, size);
        }
        for(; ; )
        {
            uintptr_t addr = {};
            if(std::tie(tp, addr) = next(gocpp::recv(tp), dst + size); addr == 0)
            {
                break;
            }
            auto srcx = (uintptr_t*)(unsafe::Pointer(addr - dst + src));
            auto p = get1(gocpp::recv(buf));
            p[0] = *srcx;
        }
    }

    void initHeapBits(struct mspan* s, bool forceClear)
    {
        if((! noscan(gocpp::recv(s->spanclass)) && heapBitsInSpan(s->elemsize)) || s->isUserArenaChunk)
        {
            auto b = heapBits(gocpp::recv(s));
            for(auto [i, gocpp_ignored] : b)
            {
                b[i] = 0;
            }
        }
    }

    uintptr_t bswapIfBigEndian(uintptr_t x)
    {
        if(goarch::BigEndian)
        {
            if(goarch::PtrSize == 8)
            {
                return uintptr_t(sys::Bswap64(uint64_t(x)));
            }
            return uintptr_t(sys::Bswap32(uint32_t(x)));
        }
        return x;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    writeUserArenaHeapBits::operator T()
    {
        T result;
        result.offset = this->offset;
        result.mask = this->mask;
        result.valid = this->valid;
        result.low = this->low;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool writeUserArenaHeapBits::operator==(const T& ref) const
    {
        if (offset != ref.offset) return false;
        if (mask != ref.mask) return false;
        if (valid != ref.valid) return false;
        if (low != ref.low) return false;
        return true;
    }

    std::ostream& writeUserArenaHeapBits::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << offset;
        os << " " << mask;
        os << " " << valid;
        os << " " << low;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct writeUserArenaHeapBits& value)
    {
        return value.PrintTo(os);
    }

    writeUserArenaHeapBits writeUserArenaHeapBits(struct mspan* s, uintptr_t addr)
    {
        writeUserArenaHeapBits h;
        auto offset = addr - base(gocpp::recv(s));
        h.low = offset / goarch::PtrSize % ptrBits;
        h.offset = offset - h.low * goarch::PtrSize;
        h.mask = 0;
        h.valid = h.low;
        return h;
    }

    writeUserArenaHeapBits write(struct writeUserArenaHeapBits h, mspan* s, uintptr_t bits, uintptr_t valid)
    {
        if(h.valid + valid <= ptrBits)
        {
            h.mask |= bits << h.valid;
            h.valid += valid;
            return h;
        }
        auto data = h.mask | (bits << h.valid);
        h.mask = bits >> (ptrBits - h.valid);
        h.valid += valid - ptrBits;
        auto idx = h.offset / (ptrBits * goarch::PtrSize);
        auto m = (uintptr_t(1) << h.low) - 1;
        auto bitmap = heapBits(gocpp::recv(s));
        bitmap[idx] = bswapIfBigEndian(bswapIfBigEndian(bitmap[idx]) & m | data);
        h.offset += ptrBits * goarch::PtrSize;
        h.low = 0;
        return h;
    }

    writeUserArenaHeapBits pad(struct writeUserArenaHeapBits h, mspan* s, uintptr_t size)
    {
        if(size == 0)
        {
            return h;
        }
        auto words = size / goarch::PtrSize;
        for(; words > ptrBits; )
        {
            h = write(gocpp::recv(h), s, 0, ptrBits);
            words -= ptrBits;
        }
        return write(gocpp::recv(h), s, 0, words);
    }

    void flush(struct writeUserArenaHeapBits h, mspan* s, uintptr_t addr, uintptr_t size)
    {
        auto offset = addr - base(gocpp::recv(s));
        auto zeros = (offset + size - h.offset) / goarch::PtrSize - h.valid;
        if(zeros > 0)
        {
            auto z = ptrBits - h.valid;
            if(z > zeros)
            {
                z = zeros;
            }
            h.valid += z;
            zeros -= z;
        }
        auto bitmap = heapBits(gocpp::recv(s));
        auto idx = h.offset / (ptrBits * goarch::PtrSize);
        if(h.valid != h.low)
        {
            auto m = (uintptr_t(1) << h.low) - 1;
            m |= ~ ((uintptr_t(1) << h.valid) - 1);
            bitmap[idx] = bswapIfBigEndian(bswapIfBigEndian(bitmap[idx]) & m | h.mask);
        }
        if(zeros == 0)
        {
            return;
        }
        h.offset += ptrBits * goarch::PtrSize;
        for(; ; )
        {
            auto idx = h.offset / (ptrBits * goarch::PtrSize);
            if(zeros < ptrBits)
            {
                bitmap[idx] = bswapIfBigEndian(bswapIfBigEndian(bitmap[idx]) &^ ((uintptr_t(1) << zeros) - 1));
                break;
            }
            else
            if(zeros == ptrBits)
            {
                bitmap[idx] = 0;
                break;
            }
            else
            {
                bitmap[idx] = 0;
                zeros -= ptrBits;
            }
            h.offset += ptrBits * goarch::PtrSize;
        }
    }

    gocpp::slice<uintptr_t> heapBits(struct mspan* span)
    {
        auto doubleCheck = false;
        if(doubleCheck && ! span->isUserArenaChunk)
        {
            if(noscan(gocpp::recv(span->spanclass)))
            {
                go_throw("heapBits called for noscan");
            }
            if(span->elemsize > minSizeForMallocHeader)
            {
                go_throw("heapBits called for span class that should have a malloc header");
            }
        }
        if(span->npages == 1)
        {
            return heapBitsSlice(base(gocpp::recv(span)), pageSize);
        }
        return heapBitsSlice(base(gocpp::recv(span)), span->npages * pageSize);
    }

    gocpp::slice<uintptr_t> heapBitsSlice(uintptr_t spanBase, uintptr_t spanSize)
    {
        auto bitmapSize = spanSize / goarch::PtrSize / 8;
        auto elems = int(bitmapSize / goarch::PtrSize);
        notInHeapSlice sl = {};
        sl = notInHeapSlice {(notInHeap*)(unsafe::Pointer(spanBase + spanSize - bitmapSize)), elems, elems};
        return *(gocpp::slice<uintptr_t>*)(unsafe::Pointer(& sl));
    }

    uintptr_t heapBitsSmallForAddr(struct mspan* span, uintptr_t addr)
    {
        auto spanSize = span->npages * pageSize;
        auto bitmapSize = spanSize / goarch::PtrSize / 8;
        auto hbits = (unsigned char*)(unsafe::Pointer(base(gocpp::recv(span)) + spanSize - bitmapSize));
        auto i = (addr - base(gocpp::recv(span))) / goarch::PtrSize / ptrBits;
        auto j = (addr - base(gocpp::recv(span))) / goarch::PtrSize % ptrBits;
        auto bits = span->elemsize / goarch::PtrSize;
        auto word0 = (uintptr_t*)(unsafe::Pointer(addb(hbits, goarch::PtrSize * (i + 0))));
        auto word1 = (uintptr_t*)(unsafe::Pointer(addb(hbits, goarch::PtrSize * (i + 1))));
        uintptr_t read = {};
        if(j + bits > ptrBits)
        {
            auto bits0 = ptrBits - j;
            auto bits1 = bits - bits0;
            read = *word0 >> j;
            read |= (*word1 & ((1 << bits1) - 1)) << bits0;
        }
        else
        {
            read = (*word0 >> j) & ((1 << bits) - 1);
        }
        return read;
    }

    uintptr_t writeHeapBitsSmall(struct mspan* span, uintptr_t x, uintptr_t dataSize, _type* typ)
    {
        uintptr_t scanSize;
        auto src0 = readUintptr(typ->GCData);
        auto bits = span->elemsize / goarch::PtrSize;
        scanSize = typ->PtrBytes;
        auto src = src0;
        //Go switch emulation
        {
            auto condition = typ->Size_;
            int conditionId = -1;
            if(condition == goarch::PtrSize) { conditionId = 0; }
            switch(conditionId)
            {
                uintptr_t scanSize;
                case 0:
                    src = (1 << (dataSize / goarch::PtrSize)) - 1;
                    break;
                default:
                    for(auto i = typ->Size_; i < dataSize; i += typ->Size_)
                    {
                        uintptr_t scanSize;
                        src |= src0 << (i / goarch::PtrSize);
                        scanSize += typ->Size_;
                    }
                    break;
            }
        }
        auto dst = heapBits(gocpp::recv(span));
        auto o = (x - base(gocpp::recv(span))) / goarch::PtrSize;
        auto i = o / ptrBits;
        auto j = o % ptrBits;
        if(j + bits > ptrBits)
        {
            uintptr_t scanSize;
            auto bits0 = ptrBits - j;
            auto bits1 = bits - bits0;
            dst[i + 0] = dst[i + 0] & (~ uintptr_t(0) >> bits0) | (src << j);
            dst[i + 1] = dst[i + 1] &^ ((1 << bits1) - 1) | (src >> bits0);
        }
        else
        {
            uintptr_t scanSize;
            dst[i] = (dst[i] &^ (((1 << bits) - 1) << j)) | (src << j);
        }
        auto doubleCheck = false;
        if(doubleCheck)
        {
            uintptr_t scanSize;
            auto srcRead = heapBitsSmallForAddr(gocpp::recv(span), x);
            if(srcRead != src)
            {
                uintptr_t scanSize;
                print("runtime: x=", hex(x), " i=", i, " j=", j, " bits=", bits, "\n");
                print("runtime: dataSize=", dataSize, " typ.Size_=", typ->Size_, " typ.PtrBytes=", typ->PtrBytes, "\n");
                print("runtime: src0=", hex(src0), " src=", hex(src), " srcRead=", hex(srcRead), "\n");
                go_throw("bad pointer bits written for small object");
            }
        }
        return scanSize;
    }

    void heapBitsSetType(uintptr_t x, uintptr_t size, uintptr_t dataSize, _type* typ)
    {
    }

    uintptr_t heapSetType(uintptr_t x, uintptr_t dataSize, _type* typ, _type** header, mspan* span)
    {
        uintptr_t scanSize;
        auto doubleCheck = false;
        auto gctyp = typ;
        if(header == nullptr)
        {
            uintptr_t scanSize;
            if(doubleCheck && (! heapBitsInSpan(dataSize) || ! heapBitsInSpan(span->elemsize)))
            {
                uintptr_t scanSize;
                go_throw("tried to write heap bits, but no heap bits in span");
            }
            scanSize = writeHeapBitsSmall(gocpp::recv(span), x, dataSize, typ);
        }
        else
        {
            uintptr_t scanSize;
            if(typ->Kind_ & kindGCProg != 0)
            {
                uintptr_t scanSize;
                if(sizeclass(gocpp::recv(span->spanclass)) != 0)
                {
                    uintptr_t scanSize;
                    go_throw("GCProg for type that isn't large");
                }
                auto spaceNeeded = alignUp(gocpp::Sizeof<_type>(), goarch::PtrSize);
                auto heapBitsOff = spaceNeeded;
                spaceNeeded += alignUp(typ->PtrBytes / goarch::PtrSize / 8, goarch::PtrSize);
                auto npages = alignUp(spaceNeeded, pageSize) / pageSize;
                mspan* progSpan = {};
                systemstack([=]() mutable -> void
                {
                    progSpan = allocManual(gocpp::recv(mheap_), npages, spanAllocPtrScalarBits);
                    memclrNoHeapPointers(unsafe::Pointer(base(gocpp::recv(progSpan))), progSpan->npages * pageSize);
                });
                gctyp = (_type*)(unsafe::Pointer(base(gocpp::recv(progSpan))));
                gctyp->Size_ = typ->Size_;
                gctyp->PtrBytes = typ->PtrBytes;
                gctyp->GCData = (unsigned char*)(add(unsafe::Pointer(base(gocpp::recv(progSpan))), heapBitsOff));
                gctyp->TFlag = abi::TFlagUnrolledBitmap;
                runGCProg(addb(typ->GCData, 4), gctyp->GCData);
            }
            *header = gctyp;
            scanSize = span->elemsize;
        }
        if(doubleCheck)
        {
            uintptr_t scanSize;
            doubleCheckHeapPointers(x, dataSize, gctyp, header, span);
            auto maxIterBytes = span->elemsize;
            if(header == nullptr)
            {
                uintptr_t scanSize;
                maxIterBytes = dataSize;
            }
            auto off = alignUp(uintptr_t(cheaprand()) % dataSize, goarch::PtrSize);
            auto size = dataSize - off;
            if(size == 0)
            {
                uintptr_t scanSize;
                off -= goarch::PtrSize;
                size += goarch::PtrSize;
            }
            auto interior = x + off;
            size -= alignDown(uintptr_t(cheaprand()) % size, goarch::PtrSize);
            if(size == 0)
            {
                uintptr_t scanSize;
                size = goarch::PtrSize;
            }
            size = (size + gctyp->Size_ - 1) / gctyp->Size_ * gctyp->Size_;
            if(interior + size > x + maxIterBytes)
            {
                uintptr_t scanSize;
                size = x + maxIterBytes - interior;
            }
            doubleCheckHeapPointersInterior(x, interior, size, dataSize, gctyp, header, span);
        }
        return scanSize;
    }

    void doubleCheckHeapPointers(uintptr_t x, uintptr_t dataSize, _type* typ, _type** header, mspan* span)
    {
        auto tp = typePointersOfUnchecked(gocpp::recv(span), objBase(gocpp::recv(span), x));
        auto maxIterBytes = span->elemsize;
        if(header == nullptr)
        {
            maxIterBytes = dataSize;
        }
        auto bad = false;
        for(auto i = uintptr_t(0); i < maxIterBytes; i += goarch::PtrSize)
        {
            auto want = false;
            if(i < span->elemsize)
            {
                auto off = i % typ->Size_;
                if(off < typ->PtrBytes)
                {
                    auto j = off / goarch::PtrSize;
                    want = (*addb(typ->GCData, j / 8) >> (j % 8)) & 1 != 0;
                }
            }
            if(want)
            {
                uintptr_t addr = {};
                std::tie(tp, addr) = next(gocpp::recv(tp), x + span->elemsize);
                if(addr == 0)
                {
                    println("runtime: found bad iterator");
                }
                if(addr != x + i)
                {
                    print("runtime: addr=", hex(addr), " x+i=", hex(x + i), "\n");
                    bad = true;
                }
            }
        }
        if(! bad)
        {
            uintptr_t addr = {};
            std::tie(tp, addr) = next(gocpp::recv(tp), x + span->elemsize);
            if(addr == 0)
            {
                return;
            }
            println("runtime: extra pointer:", hex(addr));
        }
        print("runtime: hasHeader=", header != nullptr, " typ.Size_=", typ->Size_, " hasGCProg=", typ->Kind_ & kindGCProg != 0, "\n");
        print("runtime: x=", hex(x), " dataSize=", dataSize, " elemsize=", span->elemsize, "\n");
        print("runtime: typ=", unsafe::Pointer(typ), " typ.PtrBytes=", typ->PtrBytes, "\n");
        print("runtime: limit=", hex(x + span->elemsize), "\n");
        tp = typePointersOfUnchecked(gocpp::recv(span), x);
        dumpTypePointers(tp);
        for(; ; )
        {
            uintptr_t addr = {};
            if(std::tie(tp, addr) = next(gocpp::recv(tp), x + span->elemsize); addr == 0)
            {
                println("runtime: would've stopped here");
                dumpTypePointers(tp);
                break;
            }
            print("runtime: addr=", hex(addr), "\n");
            dumpTypePointers(tp);
        }
        go_throw("heapSetType: pointer entry not correct");
    }

    void doubleCheckHeapPointersInterior(uintptr_t x, uintptr_t interior, uintptr_t size, uintptr_t dataSize, _type* typ, _type** header, mspan* span)
    {
        auto bad = false;
        if(interior < x)
        {
            print("runtime: interior=", hex(interior), " x=", hex(x), "\n");
            go_throw("found bad interior pointer");
        }
        auto off = interior - x;
        auto tp = typePointersOf(gocpp::recv(span), interior, size);
        for(auto i = off; i < off + size; i += goarch::PtrSize)
        {
            auto want = false;
            if(i < span->elemsize)
            {
                auto off = i % typ->Size_;
                if(off < typ->PtrBytes)
                {
                    auto j = off / goarch::PtrSize;
                    want = (*addb(typ->GCData, j / 8) >> (j % 8)) & 1 != 0;
                }
            }
            if(want)
            {
                uintptr_t addr = {};
                std::tie(tp, addr) = next(gocpp::recv(tp), interior + size);
                if(addr == 0)
                {
                    println("runtime: found bad iterator");
                    bad = true;
                }
                if(addr != x + i)
                {
                    print("runtime: addr=", hex(addr), " x+i=", hex(x + i), "\n");
                    bad = true;
                }
            }
        }
        if(! bad)
        {
            uintptr_t addr = {};
            std::tie(tp, addr) = next(gocpp::recv(tp), interior + size);
            if(addr == 0)
            {
                return;
            }
            println("runtime: extra pointer:", hex(addr));
        }
        print("runtime: hasHeader=", header != nullptr, " typ.Size_=", typ->Size_, "\n");
        print("runtime: x=", hex(x), " dataSize=", dataSize, " elemsize=", span->elemsize, " interior=", hex(interior), " size=", size, "\n");
        print("runtime: limit=", hex(interior + size), "\n");
        tp = typePointersOf(gocpp::recv(span), interior, size);
        dumpTypePointers(tp);
        for(; ; )
        {
            uintptr_t addr = {};
            if(std::tie(tp, addr) = next(gocpp::recv(tp), interior + size); addr == 0)
            {
                println("runtime: would've stopped here");
                dumpTypePointers(tp);
                break;
            }
            print("runtime: addr=", hex(addr), "\n");
            dumpTypePointers(tp);
        }
        print("runtime: want: ");
        for(auto i = off; i < off + size; i += goarch::PtrSize)
        {
            auto want = false;
            if(i < dataSize)
            {
                auto off = i % typ->Size_;
                if(off < typ->PtrBytes)
                {
                    auto j = off / goarch::PtrSize;
                    want = (*addb(typ->GCData, j / 8) >> (j % 8)) & 1 != 0;
                }
            }
            if(want)
            {
                print("1");
            }
            else
            {
                print("0");
            }
        }
        println();
        go_throw("heapSetType: pointer entry not correct");
    }

    void doubleCheckTypePointersOfType(mspan* s, _type* typ, uintptr_t addr, uintptr_t size)
    {
        if(typ == nullptr || typ->Kind_ & kindGCProg != 0)
        {
            return;
        }
        if(typ->Kind_ & kindMask == kindInterface)
        {
            return;
        }
        auto tp0 = typePointersOfType(gocpp::recv(s), typ, addr);
        auto tp1 = typePointersOf(gocpp::recv(s), addr, size);
        auto failed = false;
        for(; ; )
        {
            uintptr_t addr0 = {};
            uintptr_t addr1 = {};
            std::tie(tp0, addr0) = next(gocpp::recv(tp0), addr + size);
            std::tie(tp1, addr1) = next(gocpp::recv(tp1), addr + size);
            if(addr0 != addr1)
            {
                failed = true;
                break;
            }
            if(addr0 == 0)
            {
                break;
            }
        }
        if(failed)
        {
            auto tp0 = typePointersOfType(gocpp::recv(s), typ, addr);
            auto tp1 = typePointersOf(gocpp::recv(s), addr, size);
            print("runtime: addr=", hex(addr), " size=", size, "\n");
            print("runtime: type=", string(gocpp::recv(toRType(typ))), "\n");
            dumpTypePointers(tp0);
            dumpTypePointers(tp1);
            for(; ; )
            {
                uintptr_t addr0 = {};
                uintptr_t addr1 = {};
                std::tie(tp0, addr0) = next(gocpp::recv(tp0), addr + size);
                std::tie(tp1, addr1) = next(gocpp::recv(tp1), addr + size);
                print("runtime: ", hex(addr0), " ", hex(addr1), "\n");
                if(addr0 == 0 && addr1 == 0)
                {
                    break;
                }
            }
            go_throw("mismatch between typePointersOfType and typePointersOf");
        }
    }

    void dumpTypePointers(typePointers tp)
    {
        print("runtime: tp.elem=", hex(tp.elem), " tp.typ=", unsafe::Pointer(tp.typ), "\n");
        print("runtime: tp.addr=", hex(tp.addr), " tp.mask=");
        for(auto i = uintptr_t(0); i < ptrBits; i++)
        {
            if(tp.mask & (uintptr_t(1) << i) != 0)
            {
                print("1");
            }
            else
            {
                print("0");
            }
        }
        println();
    }

    gocpp::slice<unsigned char> getgcmask(go_any ep)
    {
        gocpp::slice<unsigned char> mask;
        auto e = *efaceOf(& ep);
        auto p = e.data;
        auto t = e._type;
        _type* et = {};
        if(t->Kind_ & kindMask != kindPtr)
        {
            gocpp::slice<unsigned char> mask;
            go_throw("bad argument to getgcmask: expected type to be a pointer to the value type whose mask is being queried");
        }
        et = (ptrtype*)(unsafe::Pointer(t))->Elem;
        for(auto [_, datap] : activeModules())
        {
            gocpp::slice<unsigned char> mask;
            if(datap->data <= uintptr_t(p) && uintptr_t(p) < datap->edata)
            {
                gocpp::slice<unsigned char> mask;
                auto bitmap = datap->gcdatamask.bytedata;
                auto n = et->Size_;
                mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n / goarch::PtrSize);
                for(auto i = uintptr_t(0); i < n; i += goarch::PtrSize)
                {
                    gocpp::slice<unsigned char> mask;
                    auto off = (uintptr_t(p) + i - datap->data) / goarch::PtrSize;
                    mask[i / goarch::PtrSize] = (*addb(bitmap, off / 8) >> (off % 8)) & 1;
                }
                return mask;
            }
            if(datap->bss <= uintptr_t(p) && uintptr_t(p) < datap->ebss)
            {
                gocpp::slice<unsigned char> mask;
                auto bitmap = datap->gcbssmask.bytedata;
                auto n = et->Size_;
                mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n / goarch::PtrSize);
                for(auto i = uintptr_t(0); i < n; i += goarch::PtrSize)
                {
                    gocpp::slice<unsigned char> mask;
                    auto off = (uintptr_t(p) + i - datap->bss) / goarch::PtrSize;
                    mask[i / goarch::PtrSize] = (*addb(bitmap, off / 8) >> (off % 8)) & 1;
                }
                return mask;
            }
        }
        if(auto [base, s, gocpp_id_1] = findObject(uintptr_t(p), 0, 0); base != 0)
        {
            gocpp::slice<unsigned char> mask;
            if(noscan(gocpp::recv(s->spanclass)))
            {
                gocpp::slice<unsigned char> mask;
                return nullptr;
            }
            auto limit = base + s->elemsize;
            auto tp = typePointersOfUnchecked(gocpp::recv(s), base);
            base = tp.addr;
            auto maskFromHeap = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), (limit - base) / goarch::PtrSize);
            for(; ; )
            {
                gocpp::slice<unsigned char> mask;
                uintptr_t addr = {};
                if(std::tie(tp, addr) = next(gocpp::recv(tp), limit); addr == 0)
                {
                    gocpp::slice<unsigned char> mask;
                    break;
                }
                maskFromHeap[(addr - base) / goarch::PtrSize] = 1;
            }
            for(auto i = limit; i < s->elemsize; i++)
            {
                gocpp::slice<unsigned char> mask;
                if(*(unsigned char*)(unsafe::Pointer(i)) != 0)
                {
                    gocpp::slice<unsigned char> mask;
                    go_throw("found non-zeroed tail of allocation");
                }
            }
            for(; len(maskFromHeap) > 0 && maskFromHeap[len(maskFromHeap) - 1] == 0; )
            {
                gocpp::slice<unsigned char> mask;
                maskFromHeap = maskFromHeap.make_slice(0, len(maskFromHeap) - 1);
            }
            if(et->Kind_ & kindGCProg == 0)
            {
                gocpp::slice<unsigned char> mask;
                auto maskFromType = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), (limit - base) / goarch::PtrSize);
                tp = typePointersOfType(gocpp::recv(s), et, base);
                for(; ; )
                {
                    gocpp::slice<unsigned char> mask;
                    uintptr_t addr = {};
                    if(std::tie(tp, addr) = next(gocpp::recv(tp), limit); addr == 0)
                    {
                        gocpp::slice<unsigned char> mask;
                        break;
                    }
                    maskFromType[(addr - base) / goarch::PtrSize] = 1;
                }
                auto differs = false;
                for(auto [i, gocpp_ignored] : maskFromHeap)
                {
                    gocpp::slice<unsigned char> mask;
                    if(maskFromHeap[i] != maskFromType[i])
                    {
                        gocpp::slice<unsigned char> mask;
                        differs = true;
                        break;
                    }
                }
                if(differs)
                {
                    gocpp::slice<unsigned char> mask;
                    print("runtime: heap mask=");
                    for(auto [_, b] : maskFromHeap)
                    {
                        gocpp::slice<unsigned char> mask;
                        print(b);
                    }
                    println();
                    print("runtime: type mask=");
                    for(auto [_, b] : maskFromType)
                    {
                        gocpp::slice<unsigned char> mask;
                        print(b);
                    }
                    println();
                    print("runtime: type=", string(gocpp::recv(toRType(et))), "\n");
                    go_throw("found two different masks from two different methods");
                }
            }
            mask = maskFromHeap;
            KeepAlive(ep);
            return mask;
        }
        if(auto gp = getg(); gp->m->curg->stack.lo <= uintptr_t(p) && uintptr_t(p) < gp->m->curg->stack.hi)
        {
            gocpp::slice<unsigned char> mask;
            auto found = false;
            unwinder u = {};
            for(initAt(gocpp::recv(u), gp->m->curg->sched.pc, gp->m->curg->sched.sp, 0, gp->m->curg, 0); valid(gocpp::recv(u)); next(gocpp::recv(u)))
            {
                gocpp::slice<unsigned char> mask;
                if(u.frame.sp <= uintptr_t(p) && uintptr_t(p) < u.frame.varp)
                {
                    gocpp::slice<unsigned char> mask;
                    found = true;
                    break;
                }
            }
            if(found)
            {
                gocpp::slice<unsigned char> mask;
                auto [locals, gocpp_id_4, gocpp_id_5] = getStackMap(gocpp::recv(u.frame), false);
                if(locals.n == 0)
                {
                    gocpp::slice<unsigned char> mask;
                    return mask;
                }
                auto size = uintptr_t(locals.n) * goarch::PtrSize;
                auto n = (ptrtype*)(unsafe::Pointer(t))->Elem->Size_;
                mask = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), n / goarch::PtrSize);
                for(auto i = uintptr_t(0); i < n; i += goarch::PtrSize)
                {
                    gocpp::slice<unsigned char> mask;
                    auto off = (uintptr_t(p) + i - u.frame.varp + size) / goarch::PtrSize;
                    mask[i / goarch::PtrSize] = ptrbit(gocpp::recv(locals), off);
                }
            }
            return mask;
        }
        return mask;
    }

    void userArenaHeapBitsSetType(_type* typ, unsafe::Pointer ptr, mspan* s)
    {
        auto base = base(gocpp::recv(s));
        auto h = writeUserArenaHeapBits(gocpp::recv(s), uintptr_t(ptr));
        auto p = typ->GCData;
        uintptr_t gcProgBits = {};
        if(typ->Kind_ & kindGCProg != 0)
        {
            gcProgBits = runGCProg(addb(p, 4), (unsigned char*)(ptr));
            p = (unsigned char*)(ptr);
        }
        auto nb = typ->PtrBytes / goarch::PtrSize;
        for(auto i = uintptr_t(0); i < nb; i += ptrBits)
        {
            auto k = nb - i;
            if(k > ptrBits)
            {
                k = ptrBits;
            }
            h = write(gocpp::recv(h), s, readUintptr(addb(p, i / 8)), k);
        }
        h = pad(gocpp::recv(h), s, typ->Size_ - typ->PtrBytes);
        flush(gocpp::recv(h), s, uintptr_t(ptr), typ->Size_);
        if(typ->Kind_ & kindGCProg != 0)
        {
            memclrNoHeapPointers(ptr, (gcProgBits + 7) / 8);
        }
        s->largeType->PtrBytes = uintptr_t(ptr) - base + typ->PtrBytes;
        auto doubleCheck = false;
        if(doubleCheck)
        {
            doubleCheckHeapPointersInterior(uintptr_t(ptr), uintptr_t(ptr), typ->Size_, typ->Size_, typ, & s->largeType, s);
        }
    }

    void writeHeapBitsForAddr()
    {
        gocpp::panic("not implemented");
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    heapBits::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool heapBits::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& heapBits::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapBits& value)
    {
        return value.PrintTo(os);
    }

    heapBits heapBitsForAddr(uintptr_t addr, uintptr_t size)
    {
        gocpp::panic("not implemented");
    }

    std::tuple<heapBits, uintptr_t> next(struct heapBits h)
    {
        gocpp::panic("not implemented");
    }

    std::tuple<heapBits, uintptr_t> nextFast(struct heapBits h)
    {
        gocpp::panic("not implemented");
    }

}

