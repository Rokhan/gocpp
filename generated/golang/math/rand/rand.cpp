// generated by GoCpp from file '$(ImportDir)/math/rand/rand.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/math/rand/rand.h"
#include "gocpp/support.h"

#include "golang/internal/bisect/bisect.h"
#include "golang/internal/godebug/godebug.h"
#include "golang/internal/godebugs/table.h"
#include "golang/math/rand/exp.h"
#include "golang/math/rand/normal.h"
#include "golang/math/rand/rng.h"
#include "golang/sync/atomic/type.h"
#include "golang/sync/mutex.h"
#include "golang/sync/once.h"

// Package rand implements pseudo-random number generators suitable for tasks
// such as simulation, but it should not be used for security-sensitive work.
//
// Random numbers are generated by a [Source], usually wrapped in a [Rand].
// Both types should be used by a single goroutine at a time: sharing among
// multiple goroutines requires some kind of synchronization.
//
// Top-level functions, such as [Float64] and [Int],
// are safe for concurrent use by multiple goroutines.
//
// This package's outputs might be easily predictable regardless of how it's
// seeded. For random numbers suitable for security-sensitive work, see the
// crypto/rand package.
namespace golang::rand
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using godebug::rec::IncNonDefault;
        using godebug::rec::Value;
        using mocklib::rec::Lock;
        using mocklib::rec::Unlock;
    }

    // A Source represents a source of uniformly-distributed
    // pseudo-random int64 values in the range [0, 1<<63).
    //
    // A Source is not safe for concurrent use by multiple goroutines.
    
    template<typename T>
    Source::Source(T& ref)
    {
        value.reset(new SourceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source::Source(const T& ref)
    {
        value.reset(new SourceImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source::Source(T* ptr)
    {
        value.reset(new SourceImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Source::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    int64_t Source::SourceImpl<T, StoreT>::vInt63()
    {
        return rec::Int63(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    void Source::SourceImpl<T, StoreT>::vSeed(int64_t seed)
    {
        return rec::Seed(gocpp::PtrRecv<T, false>(value.get()), seed);
    }

    namespace rec
    {
        int64_t Int63(const gocpp::PtrRecv<struct Source, false>& self)
        {
            return self.ptr->value->vInt63();
        }

        int64_t Int63(const gocpp::ObjRecv<struct Source>& self)
        {
            return self.obj.value->vInt63();
        }

        void Seed(const gocpp::PtrRecv<struct Source, false>& self, int64_t seed)
        {
            return self.ptr->value->vSeed(seed);
        }

        void Seed(const gocpp::ObjRecv<struct Source>& self, int64_t seed)
        {
            return self.obj.value->vSeed(seed);
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Source& value)
    {
        return value.PrintTo(os);
    }

    // A Source64 is a [Source] that can also generate
    // uniformly-distributed pseudo-random uint64 values in
    // the range [0, 1<<64) directly.
    // If a [Rand] r's underlying [Source] s implements Source64,
    // then r.Uint64 returns the result of one call to s.Uint64
    // instead of making two calls to s.Int63.
    
    template<typename T>
    Source64::Source64(T& ref)
    {
        value.reset(new Source64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source64::Source64(const T& ref)
    {
        value.reset(new Source64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Source64::Source64(T* ptr)
    {
        value.reset(new Source64Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Source64::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint64_t Source64::Source64Impl<T, StoreT>::vUint64()
    {
        return rec::Uint64(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        uint64_t Uint64(const gocpp::PtrRecv<struct Source64, false>& self)
        {
            return self.ptr->value->vUint64();
        }

        uint64_t Uint64(const gocpp::ObjRecv<struct Source64>& self)
        {
            return self.obj.value->vUint64();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Source64& value)
    {
        return value.PrintTo(os);
    }

    // NewSource returns a new pseudo-random [Source] seeded with the given value.
    // Unlike the default [Source] used by top-level functions, this source is not
    // safe for concurrent use by multiple goroutines.
    // The returned [Source] implements [Source64].
    struct Source NewSource(int64_t seed)
    {
        return newSource(seed);
    }

    struct rngSource* newSource(int64_t seed)
    {
        rngSource rng = {};
        rec::Seed(gocpp::recv(rng), seed);
        return & rng;
    }

    // A Rand is a source of random numbers.
    
    template<typename T> requires gocpp::GoStruct<T>
    Rand::operator T()
    {
        T result;
        result.src = this->src;
        result.s64 = this->s64;
        result.readVal = this->readVal;
        result.readPos = this->readPos;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Rand::operator==(const T& ref) const
    {
        if (src != ref.src) return false;
        if (s64 != ref.s64) return false;
        if (readVal != ref.readVal) return false;
        if (readPos != ref.readPos) return false;
        return true;
    }

    std::ostream& Rand::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << src;
        os << " " << s64;
        os << " " << readVal;
        os << " " << readPos;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Rand& value)
    {
        return value.PrintTo(os);
    }

    // New returns a new [Rand] that uses random values from src
    // to generate other random values.
    struct Rand* New(struct Source src)
    {
        auto [s64, gocpp_id_0] = gocpp::getValue<Source64>(src);
        return gocpp::InitPtr<Rand>([=](auto& x) {
            x.src = src;
            x.s64 = s64;
        });
    }

    // Seed uses the provided seed value to initialize the generator to a deterministic state.
    // Seed should not be called concurrently with any other [Rand] method.
    void rec::Seed(struct Rand* r, int64_t seed)
    {
        if(auto [lk, ok] = gocpp::getValue<lockedSource*>(r->src); ok)
        {
            rec::seedPos(gocpp::recv(lk), seed, & r->readPos);
            return;
        }
        rec::Seed(gocpp::recv(r->src), seed);
        r->readPos = 0;
    }

    // Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
    int64_t rec::Int63(struct Rand* r)
    {
        return rec::Int63(gocpp::recv(r->src));
    }

    // Uint32 returns a pseudo-random 32-bit value as a uint32.
    uint32_t rec::Uint32(struct Rand* r)
    {
        return uint32_t(rec::Int63(gocpp::recv(r)) >> 31);
    }

    // Uint64 returns a pseudo-random 64-bit value as a uint64.
    uint64_t rec::Uint64(struct Rand* r)
    {
        if(r->s64 != nullptr)
        {
            return rec::Uint64(gocpp::recv(r->s64));
        }
        return (uint64_t(rec::Int63(gocpp::recv(r))) >> 31) | (uint64_t(rec::Int63(gocpp::recv(r))) << 32);
    }

    // Int31 returns a non-negative pseudo-random 31-bit integer as an int32.
    int32_t rec::Int31(struct Rand* r)
    {
        return int32_t(rec::Int63(gocpp::recv(r)) >> 32);
    }

    // Int returns a non-negative pseudo-random int.
    int rec::Int(struct Rand* r)
    {
        auto u = (unsigned int)(rec::Int63(gocpp::recv(r)));
        return int((u << 1) >> 1);
    }

    // Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n).
    // It panics if n <= 0.
    int64_t rec::Int63n(struct Rand* r, int64_t n)
    {
        if(n <= 0)
        {
            gocpp::panic("invalid argument to Int63n"_s);
        }
        if(n & (n - 1) == 0)
        {
            return rec::Int63(gocpp::recv(r)) & (n - 1);
        }
        auto max = int64_t((1 << 63) - 1 - (1 << 63) % uint64_t(n));
        auto v = rec::Int63(gocpp::recv(r));
        for(; v > max; )
        {
            v = rec::Int63(gocpp::recv(r));
        }
        return v % n;
    }

    // Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
    // It panics if n <= 0.
    int32_t rec::Int31n(struct Rand* r, int32_t n)
    {
        if(n <= 0)
        {
            gocpp::panic("invalid argument to Int31n"_s);
        }
        if(n & (n - 1) == 0)
        {
            return rec::Int31(gocpp::recv(r)) & (n - 1);
        }
        auto max = int32_t((1 << 31) - 1 - (1 << 31) % uint32_t(n));
        auto v = rec::Int31(gocpp::recv(r));
        for(; v > max; )
        {
            v = rec::Int31(gocpp::recv(r));
        }
        return v % n;
    }

    // int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
    // n must be > 0, but int31n does not check this; the caller must ensure it.
    // int31n exists because Int31n is inefficient, but Go 1 compatibility
    // requires that the stream of values produced by math/rand remain unchanged.
    // int31n can thus only be used internally, by newly introduced APIs.
    //
    // For implementation details, see:
    // https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
    // https://lemire.me/blog/2016/06/30/fast-random-shuffling
    int32_t rec::int31n(struct Rand* r, int32_t n)
    {
        auto v = rec::Uint32(gocpp::recv(r));
        auto prod = uint64_t(v) * uint64_t(n);
        auto low = uint32_t(prod);
        if(low < uint32_t(n))
        {
            auto thresh = uint32_t(- n) % uint32_t(n);
            for(; low < thresh; )
            {
                v = rec::Uint32(gocpp::recv(r));
                prod = uint64_t(v) * uint64_t(n);
                low = uint32_t(prod);
            }
        }
        return int32_t(prod >> 32);
    }

    // Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n).
    // It panics if n <= 0.
    int rec::Intn(struct Rand* r, int n)
    {
        if(n <= 0)
        {
            gocpp::panic("invalid argument to Intn"_s);
        }
        if(n <= (1 << 31) - 1)
        {
            return int(rec::Int31n(gocpp::recv(r), int32_t(n)));
        }
        return int(rec::Int63n(gocpp::recv(r), int64_t(n)));
    }

    // Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0).
    double rec::Float64(struct Rand* r)
    {
        again:
        auto f = double(rec::Int63(gocpp::recv(r))) / (1 << 63);
        if(f == 1)
        {
            goto again;
        }
        return f;
    }

    // Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0).
    double rec::Float32(struct Rand* r)
    {
        again:
        auto f = float(rec::Float64(gocpp::recv(r)));
        if(f == 1)
        {
            goto again;
        }
        return f;
    }

    // Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
    // in the half-open interval [0,n).
    gocpp::slice<int> rec::Perm(struct Rand* r, int n)
    {
        auto m = gocpp::make(gocpp::Tag<gocpp::slice<int>>(), n);
        for(auto i = 0; i < n; i++)
        {
            auto j = rec::Intn(gocpp::recv(r), i + 1);
            m[i] = m[j];
            m[j] = i;
        }
        return m;
    }

    // Shuffle pseudo-randomizes the order of elements.
    // n is the number of elements. Shuffle panics if n < 0.
    // swap swaps the elements with indexes i and j.
    void rec::Shuffle(struct Rand* r, int n, std::function<void (int i, int j)> swap)
    {
        if(n < 0)
        {
            gocpp::panic("invalid argument to Shuffle"_s);
        }
        auto i = n - 1;
        for(; i > (1 << 31) - 1 - 1; i--)
        {
            auto j = int(rec::Int63n(gocpp::recv(r), int64_t(i + 1)));
            swap(i, j);
        }
        for(; i > 0; i--)
        {
            auto j = int(rec::int31n(gocpp::recv(r), int32_t(i + 1)));
            swap(i, j);
        }
    }

    // Read generates len(p) random bytes and writes them into p. It
    // always returns len(p) and a nil error.
    // Read should not be called concurrently with any other Rand method.
    std::tuple<int, struct gocpp::error> rec::Read(struct Rand* r, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        //Go type switch emulation
        {
            const auto& gocpp_id_1 = gocpp::type_info(r->src);
            int conditionId = -1;
            if(gocpp_id_1 == typeid(lockedSource*)) { conditionId = 0; }
            else if(gocpp_id_1 == typeid(runtimeSource*)) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                {
                    lockedSource* src = gocpp::any_cast<lockedSource*>(r->src);
                    return rec::read(gocpp::recv(src), p, & r->readVal, & r->readPos);
                    break;
                }
                case 1:
                {
                    runtimeSource* src = gocpp::any_cast<runtimeSource*>(r->src);
                    return rec::read(gocpp::recv(src), p, & r->readVal, & r->readPos);
                    break;
                }
            }
        }
        return read(p, r->src, & r->readVal, & r->readPos);
    }

    std::tuple<int, struct gocpp::error> read(gocpp::slice<unsigned char> p, struct Source src, int64_t* readVal, int8_t* readPos)
    {
        int n;
        struct gocpp::error err;
        auto pos = *readPos;
        auto val = *readVal;
        auto [rng, gocpp_id_2] = gocpp::getValue<rngSource*>(src);
        for(n = 0; n < len(p); n++)
        {
            if(pos == 0)
            {
                if(rng != nullptr)
                {
                    val = rec::Int63(gocpp::recv(rng));
                }
                else
                {
                    val = rec::Int63(gocpp::recv(src));
                }
                pos = 7;
            }
            p[n] = (unsigned char)(val);
            val >>= 8;
            pos--;
        }
        *readPos = pos;
        *readVal = val;
        return {n, err};
    }

    // globalRandGenerator is the source of random numbers for the top-level
    // convenience functions. When possible it uses the runtime fastrand64
    // function to avoid locking. This is not possible if the user called Seed,
    // either explicitly or implicitly via GODEBUG=randautoseed=0.
    atomic::Pointer<Rand> globalRandGenerator;
    godebug::Setting* randautoseed = godebug::New("randautoseed"_s);
    // globalRand returns the generator to use for the top-level convenience
    // functions.
    struct Rand* globalRand()
    {
        if(auto r = rec::Load<Rand>(gocpp::recv(globalRandGenerator)); r != nullptr)
        {
            return r;
        }
        // This is the first call. Initialize based on GODEBUG.
        Rand* r = {};
        if(rec::Value(gocpp::recv(randautoseed)) == "0"_s)
        {
            rec::IncNonDefault(gocpp::recv(randautoseed));
            r = New(new(lockedSource));
            rec::Seed(gocpp::recv(r), 1);
        }
        else
        {
            r = gocpp::InitPtr<Rand>([=](auto& x) {
                x.src = new runtimeSource {};
                x.s64 = new runtimeSource {};
            });
        }
        if(! rec::CompareAndSwap<Rand>(gocpp::recv(globalRandGenerator), nullptr, r))
        {
            return rec::Load<Rand>(gocpp::recv(globalRandGenerator));
        }
        return r;
    }

    //go:linkname runtime_rand runtime.rand
    uint64_t runtime_rand()
    /* convertBlockStmt, nil block */;

    // runtimeSource is an implementation of Source64 that uses the runtime
    // fastrand functions.
    
    template<typename T> requires gocpp::GoStruct<T>
    runtimeSource::operator T()
    {
        T result;
        result.mu = this->mu;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool runtimeSource::operator==(const T& ref) const
    {
        if (mu != ref.mu) return false;
        return true;
    }

    std::ostream& runtimeSource::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << mu;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct runtimeSource& value)
    {
        return value.PrintTo(os);
    }

    int64_t rec::Int63(runtimeSource*)
    {
        return int64_t(runtime_rand() & rngMask);
    }

    void rec::Seed(runtimeSource*, int64_t)
    {
        gocpp::panic("internal error: call to runtimeSource.Seed"_s);
    }

    uint64_t rec::Uint64(runtimeSource*)
    {
        return runtime_rand();
    }

    std::tuple<int, struct gocpp::error> rec::read(struct runtimeSource* fs, gocpp::slice<unsigned char> p, int64_t* readVal, int8_t* readPos)
    {
        int n;
        struct gocpp::error err;
        rec::Lock(gocpp::recv(fs->mu));
        std::tie(n, err) = read(p, fs, readVal, readPos);
        rec::Unlock(gocpp::recv(fs->mu));
        return {n, err};
    }

    // Seed uses the provided seed value to initialize the default Source to a
    // deterministic state. Seed values that have the same remainder when
    // divided by 2³¹-1 generate the same pseudo-random sequence.
    // Seed, unlike the [Rand.Seed] method, is safe for concurrent use.
    //
    // If Seed is not called, the generator is seeded randomly at program startup.
    //
    // Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.
    // To force the old behavior, call Seed(1) at program startup.
    // Alternately, set GODEBUG=randautoseed=0 in the environment
    // before making any calls to functions in this package.
    //
    // Deprecated: As of Go 1.20 there is no reason to call Seed with
    // a random value. Programs that call Seed with a known value to get
    // a specific sequence of results should use New(NewSource(seed)) to
    // obtain a local random generator.
    void Seed(int64_t seed)
    {
        auto orig = rec::Load<Rand>(gocpp::recv(globalRandGenerator));
        if(orig != nullptr)
        {
            if(auto [gocpp_id_3, ok] = gocpp::getValue<lockedSource*>(orig->src); ok)
            {
                rec::Seed(gocpp::recv(orig), seed);
                return;
            }
        }
        auto r = New(new(lockedSource));
        rec::Seed(gocpp::recv(r), seed);
        if(! rec::CompareAndSwap<Rand>(gocpp::recv(globalRandGenerator), orig, r))
        {
            Seed(seed);
        }
    }

    // Int63 returns a non-negative pseudo-random 63-bit integer as an int64
    // from the default [Source].
    int64_t Int63()
    {
        return rec::Int63(gocpp::recv(globalRand()));
    }

    // Uint32 returns a pseudo-random 32-bit value as a uint32
    // from the default [Source].
    uint32_t Uint32()
    {
        return rec::Uint32(gocpp::recv(globalRand()));
    }

    // Uint64 returns a pseudo-random 64-bit value as a uint64
    // from the default [Source].
    uint64_t Uint64()
    {
        return rec::Uint64(gocpp::recv(globalRand()));
    }

    // Int31 returns a non-negative pseudo-random 31-bit integer as an int32
    // from the default [Source].
    int32_t Int31()
    {
        return rec::Int31(gocpp::recv(globalRand()));
    }

    // Int returns a non-negative pseudo-random int from the default [Source].
    int Int()
    {
        return rec::Int(gocpp::recv(globalRand()));
    }

    // Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
    // from the default [Source].
    // It panics if n <= 0.
    int64_t Int63n(int64_t n)
    {
        return rec::Int63n(gocpp::recv(globalRand()), n);
    }

    // Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
    // from the default [Source].
    // It panics if n <= 0.
    int32_t Int31n(int32_t n)
    {
        return rec::Int31n(gocpp::recv(globalRand()), n);
    }

    // Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
    // from the default [Source].
    // It panics if n <= 0.
    int Intn(int n)
    {
        return rec::Intn(gocpp::recv(globalRand()), n);
    }

    // Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
    // from the default [Source].
    double Float64()
    {
        return rec::Float64(gocpp::recv(globalRand()));
    }

    // Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
    // from the default [Source].
    double Float32()
    {
        return rec::Float32(gocpp::recv(globalRand()));
    }

    // Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
    // in the half-open interval [0,n) from the default [Source].
    gocpp::slice<int> Perm(int n)
    {
        return rec::Perm(gocpp::recv(globalRand()), n);
    }

    // Shuffle pseudo-randomizes the order of elements using the default [Source].
    // n is the number of elements. Shuffle panics if n < 0.
    // swap swaps the elements with indexes i and j.
    void Shuffle(int n, std::function<void (int i, int j)> swap)
    {
        rec::Shuffle(gocpp::recv(globalRand()), n, swap);
    }

    // Read generates len(p) random bytes from the default [Source] and
    // writes them into p. It always returns len(p) and a nil error.
    // Read, unlike the [Rand.Read] method, is safe for concurrent use.
    //
    // Deprecated: For almost all use cases, [crypto/rand.Read] is more appropriate.
    std::tuple<int, struct gocpp::error> Read(gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        return rec::Read(gocpp::recv(globalRand()), p);
    }

    // NormFloat64 returns a normally distributed float64 in the range
    // [-[math.MaxFloat64], +[math.MaxFloat64]] with
    // standard normal distribution (mean = 0, stddev = 1)
    // from the default [Source].
    // To produce a different normal distribution, callers can
    // adjust the output using:
    //
    //	sample = NormFloat64() * desiredStdDev + desiredMean
    double NormFloat64()
    {
        return rec::NormFloat64(gocpp::recv(globalRand()));
    }

    // ExpFloat64 returns an exponentially distributed float64 in the range
    // (0, +[math.MaxFloat64]] with an exponential distribution whose rate parameter
    // (lambda) is 1 and whose mean is 1/lambda (1) from the default [Source].
    // To produce a distribution with a different rate parameter,
    // callers can adjust the output using:
    //
    //	sample = ExpFloat64() / desiredRateParameter
    double ExpFloat64()
    {
        return rec::ExpFloat64(gocpp::recv(globalRand()));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    lockedSource::operator T()
    {
        T result;
        result.lk = this->lk;
        result.s = this->s;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool lockedSource::operator==(const T& ref) const
    {
        if (lk != ref.lk) return false;
        if (s != ref.s) return false;
        return true;
    }

    std::ostream& lockedSource::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lk;
        os << " " << s;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct lockedSource& value)
    {
        return value.PrintTo(os);
    }

    int64_t rec::Int63(struct lockedSource* r)
    {
        int64_t n;
        rec::Lock(gocpp::recv(r->lk));
        n = rec::Int63(gocpp::recv(r->s));
        rec::Unlock(gocpp::recv(r->lk));
        return n;
    }

    uint64_t rec::Uint64(struct lockedSource* r)
    {
        uint64_t n;
        rec::Lock(gocpp::recv(r->lk));
        n = rec::Uint64(gocpp::recv(r->s));
        rec::Unlock(gocpp::recv(r->lk));
        return n;
    }

    void rec::Seed(struct lockedSource* r, int64_t seed)
    {
        rec::Lock(gocpp::recv(r->lk));
        rec::seed(gocpp::recv(r), seed);
        rec::Unlock(gocpp::recv(r->lk));
    }

    // seedPos implements Seed for a lockedSource without a race condition.
    void rec::seedPos(struct lockedSource* r, int64_t seed, int8_t* readPos)
    {
        rec::Lock(gocpp::recv(r->lk));
        rec::seed(gocpp::recv(r), seed);
        *readPos = 0;
        rec::Unlock(gocpp::recv(r->lk));
    }

    // seed seeds the underlying source.
    // The caller must have locked r.lk.
    void rec::seed(struct lockedSource* r, int64_t seed)
    {
        if(r->s == nullptr)
        {
            r->s = newSource(seed);
        }
        else
        {
            rec::Seed(gocpp::recv(r->s), seed);
        }
    }

    // read implements Read for a lockedSource without a race condition.
    std::tuple<int, struct gocpp::error> rec::read(struct lockedSource* r, gocpp::slice<unsigned char> p, int64_t* readVal, int8_t* readPos)
    {
        int n;
        struct gocpp::error err;
        rec::Lock(gocpp::recv(r->lk));
        std::tie(n, err) = read(p, r->s, readVal, readPos);
        rec::Unlock(gocpp::recv(r->lk));
        return {n, err};
    }

}

