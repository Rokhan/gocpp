// generated by GoCpp from file '$(ImportDir)/runtime/trace2string.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2string.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2map.h"
#include "golang/runtime/trace2region.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2stack.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // traceStringTable is map of string -> unique ID that also manages
    // writing strings out into the trace.
    
    template<typename T> requires gocpp::GoStruct<T>
    traceStringTable::operator T()
    {
        T result;
        result.lock = this->lock;
        result.buf = this->buf;
        result.tab = this->tab;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceStringTable::operator==(const T& ref) const
    {
        if (lock != ref.lock) return false;
        if (buf != ref.buf) return false;
        if (tab != ref.tab) return false;
        return true;
    }

    std::ostream& traceStringTable::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << lock;
        os << " " << buf;
        os << " " << tab;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceStringTable& value)
    {
        return value.PrintTo(os);
    }

    // put adds a string to the table, emits it, and returns a unique ID for it.
    uint64_t rec::put(golang::runtime::traceStringTable* t, uintptr_t gen, gocpp::string s)
    {
        auto ss = stringStructOf(& s);
        auto [id, added] = rec::put(gocpp::recv(t->tab), ss->str, uintptr_t(ss->len));
        if(added)
        {
            systemstack([=]() mutable -> void
            {
                rec::writeString(gocpp::recv(t), gen, id, s);
            });
        }
        return id;
    }

    // emit emits a string and creates an ID for it, but doesn't add it to the table. Returns the ID.
    uint64_t rec::emit(golang::runtime::traceStringTable* t, uintptr_t gen, gocpp::string s)
    {
        auto id = rec::stealID(gocpp::recv(t->tab));
        systemstack([=]() mutable -> void
        {
            rec::writeString(gocpp::recv(t), gen, id, s);
        });
        return id;
    }

    // writeString writes the string to t.buf.
    //
    // Must run on the systemstack because it may flush buffers and thus could acquire trace.lock.
    //
    //go:systemstack
    void rec::writeString(golang::runtime::traceStringTable* t, uintptr_t gen, uint64_t id, gocpp::string s)
    {
        if(len(s) > maxTraceStringLen)
        {
            s = s.make_slice(0, maxTraceStringLen);
        }
        lock(& t->lock);
        auto w = unsafeTraceWriter(gen, t->buf);
        // Ensure we have a place to write to.
        bool flushed = {};
        std::tie(w, flushed) = rec::ensure(gocpp::recv(w), 2 + 2 * traceBytesPerNumber + len(s));
        if(flushed)
        {
            rec::byte(gocpp::recv(w), (unsigned char)(traceEvStrings));
        }
        rec::byte(gocpp::recv(w), (unsigned char)(traceEvString));
        rec::varint(gocpp::recv(w), id);
        rec::varint(gocpp::recv(w), uint64_t(len(s)));
        rec::stringData(gocpp::recv(w), s);
        t->buf = w.traceBuf;
        unlock(& t->lock);
    }

    // reset clears the string table and flushes any buffers it has.
    //
    // Must be called only once the caller is certain nothing else will be
    // added to this table.
    //
    // Because it flushes buffers, this may acquire trace.lock and thus
    // must run on the systemstack.
    //
    //go:systemstack
    void rec::reset(golang::runtime::traceStringTable* t, uintptr_t gen)
    {
        if(t->buf != nullptr)
        {
            lock(& trace.lock);
            traceBufFlush(t->buf, gen);
            unlock(& trace.lock);
            t->buf = nullptr;
        }
        lock(& t->tab.lock);
        rec::reset(gocpp::recv(t->tab));
        unlock(& t->tab.lock);
    }

}

