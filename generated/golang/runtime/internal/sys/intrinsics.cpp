// generated by GoCpp from file '$(ImportDir)/runtime/internal/sys/intrinsics.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/internal/sys/intrinsics.h"
#include "gocpp/support.h"

namespace golang::sys
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    gocpp::array<unsigned char, 32> deBruijn32tab = gocpp::array<unsigned char, 32> {0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
    gocpp::array<unsigned char, 64> deBruijn64tab = gocpp::array<unsigned char, 64> {0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6};
    std::string ntz8tab = ""s + "\x08\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x05\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x06\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x05\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x07\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x05\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x06\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x05\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s + "\x04\x00\x01\x00\x02\x00\x01\x00\x03\x00\x01\x00\x02\x00\x01\x00"s;
    // TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.
    int TrailingZeros32(uint32_t x)
    {
        if(x == 0)
        {
            return 32;
        }
        return int(deBruijn32tab[(x & - x) * deBruijn32 >> (32 - 5)]);
    }

    // TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.
    int TrailingZeros64(uint64_t x)
    {
        if(x == 0)
        {
            return 64;
        }
        return int(deBruijn64tab[(x & - x) * deBruijn64 >> (64 - 6)]);
    }

    // TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.
    int TrailingZeros8(uint8_t x)
    {
        return int(ntz8tab[x]);
    }

    std::string len8tab = ""s + "\x00\x01\x02\x02\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04"s + "\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05"s + "\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06"s + "\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06"s + "\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07"s + "\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07"s + "\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07"s + "\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s + "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08"s;
    // Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    //
    // nosplit because this is used in src/runtime/histogram.go, which make run in sensitive contexts.
    //
    //go:nosplit
    int Len64(uint64_t x)
    {
        int n;
        if(x >= (1 << 32))
        {
            x >>= 32;
            n = 32;
        }
        if(x >= (1 << 16))
        {
            x >>= 16;
            n += 16;
        }
        if(x >= (1 << 8))
        {
            x >>= 8;
            n += 8;
        }
        return n + int(len8tab[x]);
    }

    // OnesCount64 returns the number of one bits ("population count") in x.
    int OnesCount64(uint64_t x)
    {
        // Implementation: Parallel summing of adjacent bits.
        // See "Hacker's Delight", Chap. 5: Counting Bits.
        // The following pattern shows the general approach:
        //
        //   x = x>>1&(m0&m) + x&(m0&m)
        //   x = x>>2&(m1&m) + x&(m1&m)
        //   x = x>>4&(m2&m) + x&(m2&m)
        //   x = x>>8&(m3&m) + x&(m3&m)
        //   x = x>>16&(m4&m) + x&(m4&m)
        //   x = x>>32&(m5&m) + x&(m5&m)
        //   return int(x)
        //
        // Masking (& operations) can be left away when there's no
        // danger that a field's sum will carry over into the next
        // field: Since the result cannot be > 64, 8 bits is enough
        // and we can ignore the masks for the shifts by 8 and up.
        // Per "Hacker's Delight", the first line can be simplified
        // more, but it saves at best one instruction, so we leave
        // it alone for clarity.
        auto m = (1 << 64) - 1;
        x = (x >> 1) & (m0 & m) + x & (m0 & m);
        x = (x >> 2) & (m1 & m) + x & (m1 & m);
        x = ((x >> 4) + x) & (m2 & m);
        x += x >> 8;
        x += x >> 16;
        x += x >> 32;
        return int(x) & ((1 << 7) - 1);
    }

    // LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.
    int LeadingZeros64(uint64_t x)
    {
        return 64 - Len64(x);
    }

    // LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.
    int LeadingZeros8(uint8_t x)
    {
        return 8 - Len8(x);
    }

    // Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
    int Len8(uint8_t x)
    {
        return int(len8tab[x]);
    }

    // Bswap64 returns its input with byte order reversed
    // 0x0102030405060708 -> 0x0807060504030201
    uint64_t Bswap64(uint64_t x)
    {
        auto c8 = uint64_t(0x00ff00ff00ff00ff);
        auto a = (x >> 8) & c8;
        auto b = (x & c8) << 8;
        x = a | b;
        auto c16 = uint64_t(0x0000ffff0000ffff);
        a = (x >> 16) & c16;
        b = (x & c16) << 16;
        x = a | b;
        auto c32 = uint64_t(0x00000000ffffffff);
        a = (x >> 32) & c32;
        b = (x & c32) << 32;
        x = a | b;
        return x;
    }

    // Bswap32 returns its input with byte order reversed
    // 0x01020304 -> 0x04030201
    uint32_t Bswap32(uint32_t x)
    {
        auto c8 = uint32_t(0x00ff00ff);
        auto a = (x >> 8) & c8;
        auto b = (x & c8) << 8;
        x = a | b;
        auto c16 = uint32_t(0x0000ffff);
        a = (x >> 16) & c16;
        b = (x & c16) << 16;
        x = a | b;
        return x;
    }

    // Prefetch prefetches data from memory addr to cache
    //
    // AMD64: Produce PREFETCHT0 instruction
    //
    // ARM64: Produce PRFM instruction with PLDL1KEEP option
    void Prefetch(uintptr_t addr)
    {
    }

    // PrefetchStreamed prefetches data from memory addr, with a hint that this data is being streamed.
    // That is, it is likely to be accessed very soon, but only once. If possible, this will avoid polluting the cache.
    //
    // AMD64: Produce PREFETCHNTA instruction
    //
    // ARM64: Produce PRFM instruction with PLDL1STRM option
    void PrefetchStreamed(uintptr_t addr)
    {
    }

}

