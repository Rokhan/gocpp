// generated by GoCpp from file '$(ImportDir)/runtime/trace2runtime.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2runtime.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    struct gTraceState
    {
        traceSchedResourceState traceSchedResourceState;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct gTraceState& value);
    struct mTraceState
    {
        atomic::Uintptr seqlock;
        gocpp::array<traceBuf*, 2> buf;
        m* link;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct mTraceState& value);
    struct pTraceState
    {
        traceSchedResourceState traceSchedResourceState;
        int64_t mSyscallID;
        bool maySweep;
        bool inSweep;
        uintptr_t swept;
        uintptr_t reclaimed;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pTraceState& value);
    void traceLockInit();
    void lockRankMayTraceFlush();
    extern gocpp::array<std::string, 15> traceBlockReasonStrings;
    extern gocpp::array<std::string, 3> traceGoStopReasonStrings;
    bool traceEnabled();
    bool traceShuttingDown();
    struct traceLocker
    {
        m* mp;
        uintptr_t gen;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct traceLocker& value);
    struct traceLocker traceAcquire();
    struct traceLocker traceAcquireEnabled();
    void traceRelease(struct traceLocker tl);
    void traceExitingSyscall();
    void traceExitedSyscall();
    void trace_userTaskCreate(uint64_t id, uint64_t parentID, std::string taskType);
    void trace_userTaskEnd(uint64_t id);
    void trace_userRegion(uint64_t id, uint64_t mode, std::string name);
    void trace_userLog(uint64_t id, std::string category, std::string message);
    void traceProcFree(struct p* _1);
    void traceThreadDestroy(struct m* mp);

    namespace rec
    {
        void reset(struct gTraceState* s);
        bool ok(struct traceLocker tl);
        void Gomaxprocs(struct traceLocker tl, int32_t procs);
        void ProcStart(struct traceLocker tl);
        void ProcStop(struct traceLocker tl, struct p* pp);
        void GCActive(struct traceLocker tl);
        void GCStart(struct traceLocker tl);
        void GCDone(struct traceLocker tl);
        void STWStart(struct traceLocker tl, golang::runtime::stwReason reason);
        void STWDone(struct traceLocker tl);
        void GCSweepStart(struct traceLocker tl);
        void GCSweepSpan(struct traceLocker tl, uintptr_t bytesSwept);
        void GCSweepDone(struct traceLocker tl);
        void GCMarkAssistStart(struct traceLocker tl);
        void GCMarkAssistDone(struct traceLocker tl);
        void GoCreate(struct traceLocker tl, struct g* newg, uintptr_t pc);
        void GoStart(struct traceLocker tl);
        void GoEnd(struct traceLocker tl);
        void GoSched(struct traceLocker tl);
        void GoPreempt(struct traceLocker tl);
        void GoStop(struct traceLocker tl, golang::runtime::traceGoStopReason reason);
        void GoPark(struct traceLocker tl, golang::runtime::traceBlockReason reason, int skip);
        void GoUnpark(struct traceLocker tl, struct g* gp, int skip);
        void GoSysCall(struct traceLocker tl);
        void GoSysExit(struct traceLocker tl, bool lostP);
        void ProcSteal(struct traceLocker tl, struct p* pp, bool inSyscall);
        void GoSysBlock(struct traceLocker tl, struct p* pp);
        void HeapAlloc(struct traceLocker tl, uint64_t live);
        void HeapGoal(struct traceLocker tl);
        void OneNewExtraM(struct traceLocker tl, struct g* _1);
        void GoCreateSyscall(struct traceLocker tl, struct g* gp);
        void GoDestroySyscall(struct traceLocker tl);
        void RecordSyscallExitedTime(struct traceLocker _1, struct g* _1, struct p* _2);
    }
}

