// generated by GoCpp from file '$(ImportDir)/runtime/mcentral.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mcentral.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcsweep.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // Central list of free objects of a given size.
    
    template<typename T> requires gocpp::GoStruct<T>
    mcentral::operator T()
    {
        T result;
        result._1 = this->_1;
        result.spanclass = this->spanclass;
        result.partial = this->partial;
        result.full = this->full;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mcentral::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (spanclass != ref.spanclass) return false;
        if (partial != ref.partial) return false;
        if (full != ref.full) return false;
        return true;
    }

    std::ostream& mcentral::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << spanclass;
        os << " " << partial;
        os << " " << full;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mcentral& value)
    {
        return value.PrintTo(os);
    }

    // Initialize a single central free list.
    void rec::init(struct mcentral* c, golang::runtime::spanClass spc)
    {
        c->spanclass = spc;
        lockInit(& c->partial[0].spineLock, lockRankSpanSetSpine);
        lockInit(& c->partial[1].spineLock, lockRankSpanSetSpine);
        lockInit(& c->full[0].spineLock, lockRankSpanSetSpine);
        lockInit(& c->full[1].spineLock, lockRankSpanSetSpine);
    }

    // partialUnswept returns the spanSet which holds partially-filled
    // unswept spans for this sweepgen.
    struct spanSet* rec::partialUnswept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->partial[1 - sweepgen / 2 % 2];
    }

    // partialSwept returns the spanSet which holds partially-filled
    // swept spans for this sweepgen.
    struct spanSet* rec::partialSwept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->partial[sweepgen / 2 % 2];
    }

    // fullUnswept returns the spanSet which holds unswept spans without any
    // free slots for this sweepgen.
    struct spanSet* rec::fullUnswept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->full[1 - sweepgen / 2 % 2];
    }

    // fullSwept returns the spanSet which holds swept spans without any
    // free slots for this sweepgen.
    struct spanSet* rec::fullSwept(struct mcentral* c, uint32_t sweepgen)
    {
        return & c->full[sweepgen / 2 % 2];
    }

    // Allocate a span to use in an mcache.
    struct mspan* rec::cacheSpan(struct mcentral* c)
    {
        auto spanBytes = uintptr_t(class_to_allocnpages[rec::sizeclass(gocpp::recv(c->spanclass))]) * _PageSize;
        deductSweepCredit(spanBytes, 0);
        auto traceDone = false;
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GCSweepStart(gocpp::recv(trace));
            traceRelease(trace);
        }
        auto spanBudget = 100;
        mspan* s = {};
        sweepLocker sl = {};
        auto sg = mheap_.sweepgen;
        if(s = rec::pop(gocpp::recv(rec::partialSwept(gocpp::recv(c), sg))); s != nullptr)
        {
            goto havespan;
        }
        sl = rec::begin(gocpp::recv(sweep.active));
        if(sl.valid)
        {
            for(; spanBudget >= 0; spanBudget--)
            {
                s = rec::pop(gocpp::recv(rec::partialUnswept(gocpp::recv(c), sg)));
                if(s == nullptr)
                {
                    break;
                }
                {
                    auto [s_tmp, ok] = rec::tryAcquire(gocpp::recv(sl), s);
                    if(auto& s = s_tmp; ok)
                    {
                        rec::sweep(gocpp::recv(s), true);
                        rec::end(gocpp::recv(sweep.active), sl);
                        goto havespan;
                    }
                }
            }
            for(; spanBudget >= 0; spanBudget--)
            {
                s = rec::pop(gocpp::recv(rec::fullUnswept(gocpp::recv(c), sg)));
                if(s == nullptr)
                {
                    break;
                }
                {
                    auto [s_tmp, ok] = rec::tryAcquire(gocpp::recv(sl), s);
                    if(auto& s = s_tmp; ok)
                    {
                        rec::sweep(gocpp::recv(s), true);
                        auto freeIndex = rec::nextFreeIndex(gocpp::recv(s));
                        if(freeIndex != s.nelems)
                        {
                            s.freeindex = freeIndex;
                            rec::end(gocpp::recv(sweep.active), sl);
                            goto havespan;
                        }
                        rec::push(gocpp::recv(rec::fullSwept(gocpp::recv(c), sg)), s.mspan);
                    }
                }
            }
            rec::end(gocpp::recv(sweep.active), sl);
        }
        trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GCSweepDone(gocpp::recv(trace));
            traceDone = true;
            traceRelease(trace);
        }
        s = rec::grow(gocpp::recv(c));
        if(s == nullptr)
        {
            return nullptr;
        }
        havespan:
        if(! traceDone)
        {
            auto trace = traceAcquire();
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::GCSweepDone(gocpp::recv(trace));
                traceRelease(trace);
            }
        }
        auto n = int(s->nelems) - int(s->allocCount);
        if(n == 0 || s->freeindex == s->nelems || s->allocCount == s->nelems)
        {
            go_throw("span has no free objects"s);
        }
        auto freeByteBase = s->freeindex &^ (64 - 1);
        auto whichByte = freeByteBase / 8;
        rec::refillAllocCache(gocpp::recv(s), whichByte);
        s->allocCache >>= s->freeindex % 64;
        return s;
    }

    // Return span from an mcache.
    //
    // s must have a span class corresponding to this
    // mcentral and it must not be empty.
    void rec::uncacheSpan(struct mcentral* c, struct mspan* s)
    {
        if(s->allocCount == 0)
        {
            go_throw("uncaching span but s.allocCount == 0"s);
        }
        auto sg = mheap_.sweepgen;
        auto stale = s->sweepgen == sg + 1;
        if(stale)
        {
            atomic::Store(& s->sweepgen, sg - 1);
        }
        else
        {
            atomic::Store(& s->sweepgen, sg);
        }
        if(stale)
        {
            auto ss = sweepLocked {s};
            rec::sweep(gocpp::recv(ss), false);
        }
        else
        {
            if(int(s->nelems) - int(s->allocCount) > 0)
            {
                rec::push(gocpp::recv(rec::partialSwept(gocpp::recv(c), sg)), s);
            }
            else
            {
                rec::push(gocpp::recv(rec::fullSwept(gocpp::recv(c), sg)), s);
            }
        }
    }

    // grow allocates a new empty span from the heap and initializes it for c's size class.
    struct mspan* rec::grow(struct mcentral* c)
    {
        auto npages = uintptr_t(class_to_allocnpages[rec::sizeclass(gocpp::recv(c->spanclass))]);
        auto size = uintptr_t(class_to_size[rec::sizeclass(gocpp::recv(c->spanclass))]);
        auto s = rec::alloc(gocpp::recv(mheap_), npages, c->spanclass);
        if(s == nullptr)
        {
            return nullptr;
        }
        auto n = rec::divideByElemSize(gocpp::recv(s), npages << _PageShift);
        s->limit = rec::base(gocpp::recv(s)) + size * n;
        rec::initHeapBits(gocpp::recv(s), false);
        return s;
    }

}

