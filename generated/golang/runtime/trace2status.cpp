// generated by GoCpp from file '$(ImportDir)/runtime/trace2status.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2status.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2time.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::Load;
        using atomic::rec::Store;
    }

    // traceGoStatus is the status of a goroutine.
    //
    // They correspond directly to the various goroutine
    // statuses.
    // traceProcStatus is the status of a P.
    //
    // They mostly correspond to the various P statuses.
    // traceProcSyscallAbandoned is a special case of
    // traceProcSyscall. It's used in the very specific case
    // where the first a P is mentioned in a generation is
    // part of a ProcSteal event. If that's the first time
    // it's mentioned, then there's no GoSyscallBegin to
    // connect the P stealing back to at that point. This
    // special state indicates this to the parser, so it
    // doesn't try to find a GoSyscallEndBlocked that
    // corresponds with the ProcSteal.
    // writeGoStatus emits a GoStatus event as well as any active ranges on the goroutine.
    struct traceWriter rec::writeGoStatus(struct traceWriter w, uint64_t goid, int64_t mid, golang::runtime::traceGoStatus status, bool markAssist)
    {
        if(status == traceGoBad)
        {
            print("runtime: goid="_s, goid, "\n"_s);
            go_throw("attempted to trace a bad status for a goroutine"_s);
        }
        w = rec::event(gocpp::recv(w), traceEvGoStatus, traceArg(goid), traceArg(uint64_t(mid)), traceArg(status));
        if(markAssist)
        {
            w = rec::event(gocpp::recv(w), traceEvGCMarkAssistActive, traceArg(goid));
        }
        return w;
    }

    // writeProcStatusForP emits a ProcStatus event for the provided p based on its status.
    //
    // The caller must fully own pp and it must be prevented from transitioning (e.g. this can be
    // called by a forEachP callback or from a STW).
    struct traceWriter rec::writeProcStatusForP(struct traceWriter w, struct p* pp, bool inSTW)
    {
        if(! rec::acquireStatus(gocpp::recv(pp->trace), w.gen))
        {
            return w;
        }
        runtime::traceProcStatus status = {};
        //Go switch emulation
        {
            auto condition = pp->status;
            int conditionId = -1;
            if(condition == _Pidle) { conditionId = 0; }
            else if(condition == _Pgcstop) { conditionId = 1; }
            else if(condition == _Prunning) { conditionId = 2; }
            else if(condition == _Psyscall) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    status = traceProcIdle;
                    if(pp->status == _Pgcstop && inSTW)
                    {
                        status = traceProcRunning;
                    }
                    break;
                case 2:
                    status = traceProcRunning;
                    if(rec::ptr(gocpp::recv(w.mp->p)) == pp && w.mp->curg != nullptr && readgstatus(w.mp->curg) &^ _Gscan == _Gsyscall)
                    {
                        status = traceProcSyscall;
                    }
                    break;
                case 3:
                    status = traceProcSyscall;
                    break;
                default:
                    go_throw("attempt to trace invalid or unsupported P status"_s);
                    break;
            }
        }
        w = rec::writeProcStatus(gocpp::recv(w), uint64_t(pp->id), status, pp->trace.inSweep);
        return w;
    }

    // writeProcStatus emits a ProcStatus event with all the provided information.
    //
    // The caller must have taken ownership of a P's status writing, and the P must be
    // prevented from transitioning.
    struct traceWriter rec::writeProcStatus(struct traceWriter w, uint64_t pid, golang::runtime::traceProcStatus status, bool inSweep)
    {
        if(status == traceProcBad)
        {
            print("runtime: pid="_s, pid, "\n"_s);
            go_throw("attempted to trace a bad status for a proc"_s);
        }
        w = rec::event(gocpp::recv(w), traceEvProcStatus, traceArg(pid), traceArg(status));
        if(inSweep)
        {
            w = rec::event(gocpp::recv(w), traceEvGCSweepActive, traceArg(pid));
        }
        return w;
    }

    // goStatusToTraceGoStatus translates the internal status to tracGoStatus.
    //
    // status must not be _Gdead or any status whose name has the suffix "_unused."
    runtime::traceGoStatus goStatusToTraceGoStatus(uint32_t status, golang::runtime::waitReason wr)
    {
        // N.B. Ignore the _Gscan bit. We don't model it in the tracer.
        runtime::traceGoStatus tgs = {};
        //Go switch emulation
        {
            auto condition = status &^ _Gscan;
            int conditionId = -1;
            if(condition == _Grunnable) { conditionId = 0; }
            else if(condition == _Grunning) { conditionId = 1; }
            else if(condition == _Gcopystack) { conditionId = 2; }
            else if(condition == _Gsyscall) { conditionId = 3; }
            else if(condition == _Gwaiting) { conditionId = 4; }
            else if(condition == _Gpreempted) { conditionId = 5; }
            else if(condition == _Gdead) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    tgs = traceGoRunnable;
                    break;
                case 1:
                case 2:
                    tgs = traceGoRunning;
                    break;
                case 3:
                    tgs = traceGoSyscall;
                    break;
                case 4:
                case 5:
                    tgs = traceGoWaiting;
                    if(status == _Gwaiting && wr == waitReasonStoppingTheWorld || wr == waitReasonGCMarkTermination || wr == waitReasonGarbageCollection || wr == waitReasonTraceProcStatus || wr == waitReasonPageTraceFlush || wr == waitReasonGCWorkerActive)
                    {
                        tgs = traceGoRunning;
                    }
                    break;
                case 6:
                    go_throw("tried to trace dead goroutine"_s);
                    break;
                default:
                    go_throw("tried to trace goroutine with invalid or unsupported status"_s);
                    break;
            }
        }
        return tgs;
    }

    // traceSchedResourceState is shared state for scheduling resources (i.e. fields common to
    // both Gs and Ps).
    
    template<typename T> requires gocpp::GoStruct<T>
    traceSchedResourceState::operator T()
    {
        T result;
        result.statusTraced = this->statusTraced;
        result.seq = this->seq;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool traceSchedResourceState::operator==(const T& ref) const
    {
        if (statusTraced != ref.statusTraced) return false;
        if (seq != ref.seq) return false;
        return true;
    }

    std::ostream& traceSchedResourceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << statusTraced;
        os << " " << seq;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceSchedResourceState& value)
    {
        return value.PrintTo(os);
    }

    // acquireStatus acquires the right to emit a Status event for the scheduling resource.
    bool rec::acquireStatus(struct traceSchedResourceState* r, uintptr_t gen)
    {
        if(! rec::CompareAndSwap(gocpp::recv(r->statusTraced[gen % 3]), 0, 1))
        {
            return false;
        }
        rec::readyNextGen(gocpp::recv(r), gen);
        return true;
    }

    // readyNextGen readies r for the generation following gen.
    void rec::readyNextGen(struct traceSchedResourceState* r, uintptr_t gen)
    {
        auto nextGen = traceNextGen(gen);
        r->seq[nextGen % 2] = 0;
        rec::Store(gocpp::recv(r->statusTraced[nextGen % 3]), 0);
    }

    // statusWasTraced returns true if the sched resource's status was already acquired for tracing.
    bool rec::statusWasTraced(struct traceSchedResourceState* r, uintptr_t gen)
    {
        return rec::Load(gocpp::recv(r->statusTraced[gen % 3])) != 0;
    }

    // setStatusTraced indicates that the resource's status was already traced, for example
    // when a goroutine is created.
    void rec::setStatusTraced(struct traceSchedResourceState* r, uintptr_t gen)
    {
        rec::Store(gocpp::recv(r->statusTraced[gen % 3]), 1);
    }

    // nextSeq returns the next sequence number for the resource.
    runtime::traceArg rec::nextSeq(struct traceSchedResourceState* r, uintptr_t gen)
    {
        r->seq[gen % 2]++;
        return traceArg(r->seq[gen % 2]);
    }

}

