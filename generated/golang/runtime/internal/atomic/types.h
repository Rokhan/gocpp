// generated by GoCpp from file '$(ImportDir)/runtime/internal/atomic/types.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/internal/atomic/types.fwd.h"
#include "gocpp/support.h"


namespace golang::atomic
{
    void storePointer(unsafe::Pointer* ptr, unsafe::Pointer go_new);
    bool casPointer(unsafe::Pointer* ptr, unsafe::Pointer old, unsafe::Pointer go_new);
    struct noCopy
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct noCopy& value);
    struct align64
    {

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct align64& value);
    struct Int32
    {
        /* noCopy noCopy; [Known incomplete type] */
        int32_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Int32& value);
    struct Int64
    {
        /* noCopy noCopy; [Known incomplete type] */
        align64 _1;
        int64_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Int64& value);
    struct Uint8
    {
        /* noCopy noCopy; [Known incomplete type] */
        uint8_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uint8& value);
    struct Uint32
    {
        /* noCopy noCopy; [Known incomplete type] */
        uint32_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uint32& value);
    struct Uint64
    {
        /* noCopy noCopy; [Known incomplete type] */
        align64 _1;
        uint64_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uint64& value);
    struct Uintptr
    {
        /* noCopy noCopy; [Known incomplete type] */
        uintptr_t value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Uintptr& value);
    struct UnsafePointer
    {
        /* noCopy noCopy; [Known incomplete type] */
        unsafe::Pointer value;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct UnsafePointer& value);
    struct Bool
    {
        Uint8 u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Bool& value);
    struct Float64
    {
        Uint64 u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Float64& value);
    template<typename T> 
    struct Pointer
    {
        UnsafePointer u;

        using isGoStruct = void;

        template<typename U> requires gocpp::GoStruct<U>
        operator U();

        template<typename U> requires gocpp::GoStruct<U>
        bool operator==(const U& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const struct Pointer<T>& value);

    namespace rec
    {
        int32_t Load(struct Int32* i);
        void Store(struct Int32* i, int32_t value);
        bool CompareAndSwap(struct Int32* i, int32_t old, int32_t go_new);
        int32_t Swap(struct Int32* i, int32_t go_new);
        int32_t Add(struct Int32* i, int32_t delta);
        int64_t Load(struct Int64* i);
        void Store(struct Int64* i, int64_t value);
        bool CompareAndSwap(struct Int64* i, int64_t old, int64_t go_new);
        int64_t Swap(struct Int64* i, int64_t go_new);
        int64_t Add(struct Int64* i, int64_t delta);
        uint8_t Load(struct Uint8* u);
        void Store(struct Uint8* u, uint8_t value);
        void And(struct Uint8* u, uint8_t value);
        void Or(struct Uint8* u, uint8_t value);
        bool Load(struct Bool* b);
        void Store(struct Bool* b, bool value);
        uint32_t Load(struct Uint32* u);
        uint32_t LoadAcquire(struct Uint32* u);
        void Store(struct Uint32* u, uint32_t value);
        void StoreRelease(struct Uint32* u, uint32_t value);
        bool CompareAndSwap(struct Uint32* u, uint32_t old, uint32_t go_new);
        bool CompareAndSwapRelease(struct Uint32* u, uint32_t old, uint32_t go_new);
        uint32_t Swap(struct Uint32* u, uint32_t value);
        void And(struct Uint32* u, uint32_t value);
        void Or(struct Uint32* u, uint32_t value);
        uint32_t Add(struct Uint32* u, int32_t delta);
        uint64_t Load(struct Uint64* u);
        void Store(struct Uint64* u, uint64_t value);
        bool CompareAndSwap(struct Uint64* u, uint64_t old, uint64_t go_new);
        uint64_t Swap(struct Uint64* u, uint64_t value);
        uint64_t Add(struct Uint64* u, int64_t delta);
        uintptr_t Load(struct Uintptr* u);
        uintptr_t LoadAcquire(struct Uintptr* u);
        void Store(struct Uintptr* u, uintptr_t value);
        void StoreRelease(struct Uintptr* u, uintptr_t value);
        bool CompareAndSwap(struct Uintptr* u, uintptr_t old, uintptr_t go_new);
        uintptr_t Swap(struct Uintptr* u, uintptr_t value);
        uintptr_t Add(struct Uintptr* u, uintptr_t delta);
        double Load(struct Float64* f);
        void Store(struct Float64* f, double value);
        unsafe::Pointer Load(struct UnsafePointer* u);
        void StoreNoWB(struct UnsafePointer* u, unsafe::Pointer value);
        void Store(struct UnsafePointer* u, unsafe::Pointer value);
        bool CompareAndSwapNoWB(struct UnsafePointer* u, unsafe::Pointer old, unsafe::Pointer go_new);
        bool CompareAndSwap(struct UnsafePointer* u, unsafe::Pointer old, unsafe::Pointer go_new);
        
        template<typename T>
        T* Load(golang::atomic::Pointer<T>* p);
        
        template<typename T>
        void StoreNoWB(golang::atomic::Pointer<T>* p, T* value);
        
        template<typename T>
        void Store(golang::atomic::Pointer<T>* p, T* value);
        
        template<typename T>
        bool CompareAndSwapNoWB(golang::atomic::Pointer<T>* p, T* old, T* go_new);
        
        template<typename T>
        bool CompareAndSwap(golang::atomic::Pointer<T>* p, T* old, T* go_new);
        void Lock(noCopy*);
        void Unlock(noCopy*);
    }
}

