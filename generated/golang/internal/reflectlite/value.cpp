// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/value.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/reflectlite/type.h"
#include "golang/internal/unsafeheader/unsafeheader.h"
#include "golang/runtime/extern.h"
// #include "golang/runtime/symtab.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::reflectlite
{
    
    template<typename T> requires gocpp::GoStruct<T>
    Value::operator T()
    {
        T result;
        result.typ_ = this->typ_;
        result.ptr = this->ptr;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Value::operator==(const T& ref) const
    {
        if (typ_ != ref.typ_) return false;
        if (ptr != ref.ptr) return false;
        return true;
    }

    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ_;
        os << " " << ptr;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Value& value)
    {
        return value.PrintTo(os);
    }

    Kind kind(flag f)
    {
        return Kind(f & flagKindMask);
    }

    flag ro(flag f)
    {
        if(f & flagRO != 0)
        {
            return flagStickyRO;
        }
        return 0;
    }

    struct abi::Type* typ(struct Value v)
    {
        return (abi::Type*)(noescape(unsafe::Pointer(v.typ_)));
    }

    unsafe::Pointer pointer(struct Value v)
    {
        if(Size(gocpp::recv(typ(gocpp::recv(v)))) != goarch::PtrSize || ! Pointers(gocpp::recv(typ(gocpp::recv(v)))))
        {
            gocpp::panic("can't call pointer on a non-pointer Value");
        }
        if(v.flag & flagIndir != 0)
        {
            return *(unsafe::Pointer*)(v.ptr);
        }
        return v.ptr;
    }

    go_any packEface(struct Value v)
    {
        auto t = typ(gocpp::recv(v));
        go_any i = {};
        auto e = (emptyInterface*)(unsafe::Pointer(& i));
        //Go switch emulation
        {
            int conditionId = -1;
            if(ifaceIndir(t)) { conditionId = 0; }
            else if(v.flag & flagIndir != 0) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    if(v.flag & flagIndir == 0)
                    {
                        gocpp::panic("bad indir");
                    }
                    auto ptr = v.ptr;
                    if(v.flag & flagAddr != 0)
                    {
                        auto c = unsafe_New(t);
                        typedmemmove(t, c, ptr);
                        ptr = c;
                    }
                    e->word = ptr;
                    break;
                case 1:
                    e->word = *(unsafe::Pointer*)(v.ptr);
                    break;
                default:
                    e->word = v.ptr;
                    break;
            }
        }
        e->typ = t;
        return i;
    }

    struct Value unpackEface(go_any i)
    {
        auto e = (emptyInterface*)(unsafe::Pointer(& i));
        auto t = e->typ;
        if(t == nullptr)
        {
            return Value {};
        }
        auto f = flag(Kind(gocpp::recv(t)));
        if(ifaceIndir(t))
        {
            f |= flagIndir;
        }
        return Value {t, e->word, f};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    ValueError::operator T()
    {
        T result;
        result.Method = this->Method;
        result.Kind = this->Kind;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool ValueError::operator==(const T& ref) const
    {
        if (Method != ref.Method) return false;
        if (Kind != ref.Kind) return false;
        return true;
    }

    std::ostream& ValueError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Method;
        os << " " << Kind;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct ValueError& value)
    {
        return value.PrintTo(os);
    }

    std::string Error(struct ValueError* e)
    {
        if(e->Kind == 0)
        {
            return "reflect: call of " + e->Method + " on zero Value";
        }
        return "reflect: call of " + e->Method + " on " + String(gocpp::recv(e->Kind)) + " Value";
    }

    std::string methodName()
    {
        auto [pc, gocpp_id_3, gocpp_id_4, gocpp_id_5] = runtime::Caller(2);
        auto f = runtime::FuncForPC(pc);
        if(f == nullptr)
        {
            return "unknown method";
        }
        return Name(gocpp::recv(f));
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    emptyInterface::operator T()
    {
        T result;
        result.typ = this->typ;
        result.word = this->word;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool emptyInterface::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (word != ref.word) return false;
        return true;
    }

    std::ostream& emptyInterface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << word;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct emptyInterface& value)
    {
        return value.PrintTo(os);
    }

    void mustBeExported(flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {methodName(), 0});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: " + methodName() + " using value obtained using unexported field");
        }
    }

    void mustBeAssignable(flag f)
    {
        if(f == 0)
        {
            gocpp::panic(new ValueError {methodName(), abi::Invalid});
        }
        if(f & flagRO != 0)
        {
            gocpp::panic("reflect: " + methodName() + " using value obtained using unexported field");
        }
        if(f & flagAddr == 0)
        {
            gocpp::panic("reflect: " + methodName() + " using unaddressable value");
        }
    }

    bool CanSet(struct Value v)
    {
        return v.flag & (flagAddr | flagRO) == flagAddr;
    }

    
                        template<typename T>
                        gocpp_id_6::gocpp_id_6(T& ref)
                        {
                            value.reset(new gocpp_id_6Impl<T, std::unique_ptr<T>>(new T(ref)));
                        }

                        template<typename T>
                        gocpp_id_6::gocpp_id_6(const T& ref)
                        {
                            value.reset(new gocpp_id_6Impl<T, std::unique_ptr<T>>(new T(ref)));
                        }

                        template<typename T>
                        gocpp_id_6::gocpp_id_6(T* ptr)
                        {
                            value.reset(new gocpp_id_6Impl<T, gocpp::ptr<T>>(ptr));
                        }

                        std::ostream& gocpp_id_6::PrintTo(std::ostream& os) const
                        {
                            return os;
                        }

                        template<typename T, typename StoreT>
                        void gocpp_id_6::gocpp_id_6Impl<T, StoreT>::vM()
                        {
                            return M(gocpp::PtrRecv<T, false>(value.get()));
                        }

                        void M(const gocpp::PtrRecv<gocpp_id_6, false>& self)
                        {
                            return self.ptr->value->vM();
                        }

                        void M(const gocpp::ObjRecv<gocpp_id_6>& self)
                        {
                            return self.obj.value->vM();
                        }

                        std::ostream& operator<<(std::ostream& os, const struct gocpp_id_6& value)
                        {
                            return value.PrintTo(os);
                        }


    struct Value Elem(struct Value v)
    {
        auto k = kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == abi::Interface) { conditionId = 0; }
            else if(condition == abi::Pointer) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    go_any eface = {};
                    if(NumMethod(gocpp::recv(typ(gocpp::recv(v)))) == 0)
                    {
                        eface = *(go_any*)(v.ptr);
                    }
                    else
                    {
                        eface = (go_any)(*(gocpp_id_6*)(v.ptr));
                    }
                    auto x = unpackEface(eface);
                    if(x.flag != 0)
                    {
                        x.flag |= ro(gocpp::recv(v.flag));
                    }
                    return x;
                    break;
                case 1:
                    auto ptr = v.ptr;
                    if(v.flag & flagIndir != 0)
                    {
                        ptr = *(unsafe::Pointer*)(ptr);
                    }
                    if(ptr == nullptr)
                    {
                        return Value {};
                    }
                    auto tt = (ptrType*)(unsafe::Pointer(typ(gocpp::recv(v))));
                    auto typ = tt->Elem;
                    auto fl = v.flag & flagRO | flagIndir | flagAddr;
                    fl |= flag(Kind(gocpp::recv(typ)));
                    return Value {typ, ptr, fl};
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflectlite.Value.Elem", kind(gocpp::recv(v))});
    }

    
            template<typename T>
            gocpp_id_7::gocpp_id_7(T& ref)
            {
                value.reset(new gocpp_id_7Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_7::gocpp_id_7(const T& ref)
            {
                value.reset(new gocpp_id_7Impl<T, std::unique_ptr<T>>(new T(ref)));
            }

            template<typename T>
            gocpp_id_7::gocpp_id_7(T* ptr)
            {
                value.reset(new gocpp_id_7Impl<T, gocpp::ptr<T>>(ptr));
            }

            std::ostream& gocpp_id_7::PrintTo(std::ostream& os) const
            {
                return os;
            }

            template<typename T, typename StoreT>
            void gocpp_id_7::gocpp_id_7Impl<T, StoreT>::vM()
            {
                return M(gocpp::PtrRecv<T, false>(value.get()));
            }

            void M(const gocpp::PtrRecv<gocpp_id_7, false>& self)
            {
                return self.ptr->value->vM();
            }

            void M(const gocpp::ObjRecv<gocpp_id_7>& self)
            {
                return self.obj.value->vM();
            }

            std::ostream& operator<<(std::ostream& os, const struct gocpp_id_7& value)
            {
                return value.PrintTo(os);
            }


    go_any valueInterface(struct Value v)
    {
        if(v.flag == 0)
        {
            gocpp::panic(new ValueError {"reflectlite.Value.Interface", 0});
        }
        if(kind(gocpp::recv(v)) == abi::Interface)
        {
            if(numMethod(gocpp::recv(v)) == 0)
            {
                return *(go_any*)(v.ptr);
            }
            return *(gocpp_id_7*)(v.ptr);
        }
        return packEface(v);
    }

    bool IsNil(struct Value v)
    {
        auto k = kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == abi::Chan) { conditionId = 0; }
            if(condition == abi::Func) { conditionId = 1; }
            if(condition == abi::Map) { conditionId = 2; }
            if(condition == abi::Pointer) { conditionId = 3; }
            if(condition == abi::UnsafePointer) { conditionId = 4; }
            else if(condition == abi::Interface) { conditionId = 5; }
            else if(condition == abi::Slice) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    auto ptr = v.ptr;
                    if(v.flag & flagIndir != 0)
                    {
                        ptr = *(unsafe::Pointer*)(ptr);
                    }
                    return ptr == nullptr;
                    break;
                case 5:
                case 6:
                    return *(unsafe::Pointer*)(v.ptr) == nullptr;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflectlite.Value.IsNil", kind(gocpp::recv(v))});
    }

    bool IsValid(struct Value v)
    {
        return v.flag != 0;
    }

    Kind Kind(struct Value v)
    {
        return kind(gocpp::recv(v));
    }

    int chanlen(unsafe::Pointer)
    /* convertBlockStmt, nil block */;

    int maplen(unsafe::Pointer)
    /* convertBlockStmt, nil block */;

    int Len(struct Value v)
    {
        auto k = kind(gocpp::recv(v));
        //Go switch emulation
        {
            auto condition = k;
            int conditionId = -1;
            if(condition == abi::Array) { conditionId = 0; }
            else if(condition == abi::Chan) { conditionId = 1; }
            else if(condition == abi::Map) { conditionId = 2; }
            else if(condition == abi::Slice) { conditionId = 3; }
            else if(condition == abi::String) { conditionId = 4; }
            switch(conditionId)
            {
                case 0:
                    auto tt = (arrayType*)(unsafe::Pointer(typ(gocpp::recv(v))));
                    return int(tt->Len);
                    break;
                case 1:
                    return chanlen(pointer(gocpp::recv(v)));
                    break;
                case 2:
                    return maplen(pointer(gocpp::recv(v)));
                    break;
                case 3:
                    return (unsafeheader::Slice*)(v.ptr)->Len;
                    break;
                case 4:
                    return (unsafeheader::String*)(v.ptr)->Len;
                    break;
            }
        }
        gocpp::panic(new ValueError {"reflect.Value.Len", kind(gocpp::recv(v))});
    }

    int numMethod(struct Value v)
    {
        if(typ(gocpp::recv(v)) == nullptr)
        {
            gocpp::panic(new ValueError {"reflectlite.Value.NumMethod", abi::Invalid});
        }
        return NumMethod(gocpp::recv(typ(gocpp::recv(v))));
    }

    void Set(struct Value v, struct Value x)
    {
        mustBeAssignable(gocpp::recv(v));
        mustBeExported(gocpp::recv(x));
        unsafe::Pointer target = {};
        if(kind(gocpp::recv(v)) == abi::Interface)
        {
            target = v.ptr;
        }
        x = assignTo(gocpp::recv(x), "reflectlite.Set", typ(gocpp::recv(v)), target);
        if(x.flag & flagIndir != 0)
        {
            typedmemmove(typ(gocpp::recv(v)), v.ptr, x.ptr);
        }
        else
        {
            *(unsafe::Pointer*)(v.ptr) = x.ptr;
        }
    }

    struct Type Type(struct Value v)
    {
        auto f = v.flag;
        if(f == 0)
        {
            gocpp::panic(new ValueError {"reflectlite.Value.Type", abi::Invalid});
        }
        return toRType(typ(gocpp::recv(v)));
    }

    unsafe::Pointer unsafe_New(abi::Type*)
    /* convertBlockStmt, nil block */;

    struct Value ValueOf(go_any i)
    {
        if(i == nullptr)
        {
            return Value {};
        }
        return unpackEface(i);
    }

    struct Value assignTo(struct Value v, std::string context, struct abi::Type* dst, unsafe::Pointer target)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(directlyAssignable(dst, typ(gocpp::recv(v)))) { conditionId = 0; }
            else if(implements(dst, typ(gocpp::recv(v)))) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    auto fl = v.flag & (flagAddr | flagIndir) | ro(gocpp::recv(v.flag));
                    fl |= flag(Kind(gocpp::recv(dst)));
                    return Value {dst, v.ptr, fl};
                    break;
                case 1:
                    if(target == nullptr)
                    {
                        target = unsafe_New(dst);
                    }
                    if(Kind(gocpp::recv(v)) == abi::Interface && IsNil(gocpp::recv(v)))
                    {
                        return Value {dst, nullptr, flag(abi::Interface)};
                    }
                    auto x = valueInterface(v);
                    if(NumMethod(gocpp::recv(dst)) == 0)
                    {
                        *(go_any*)(target) = x;
                    }
                    else
                    {
                        ifaceE2I(dst, x, target);
                    }
                    return Value {dst, target, flagIndir | flag(abi::Interface)};
                    break;
            }
        }
        gocpp::panic(context + ": value of type " + String(gocpp::recv(toRType(typ(gocpp::recv(v))))) + " is not assignable to type " + String(gocpp::recv(toRType(dst))));
    }

    unsafe::Pointer arrayAt(unsafe::Pointer p, int i, uintptr_t eltSize, std::string whySafe)
    {
        return add(p, uintptr_t(i) * eltSize, "i < len");
    }

    void ifaceE2I(struct abi::Type* t, go_any src, unsafe::Pointer dst)
    /* convertBlockStmt, nil block */;

    void typedmemmove(struct abi::Type* t, unsafe::Pointer dst, unsafe::Pointer src)
    /* convertBlockStmt, nil block */;

    void escapes(go_any x)
    {
        if(dummy.b)
        {
            dummy.x = x;
        }
    }

    struct gocpp_id_8
    {
        bool b;
        go_any x;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.b = this->b;
            result.x = this->x;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (b != ref.b) return false;
            if (x != ref.x) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << b;
            os << " " << x;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_8& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_8 dummy;
    unsafe::Pointer noescape(unsafe::Pointer p)
    {
        auto x = uintptr_t(p);
        return unsafe::Pointer(x ^ 0);
    }

}

