// generated by GoCpp from file '$(ImportDir)/runtime/trace2status.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/trace2status.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2event.h"

namespace golang::runtime
{
    traceGoStatus traceGoBad = 0;
    traceGoStatus traceGoRunnable = 1;
    traceGoStatus traceGoRunning = 2;
    traceGoStatus traceGoSyscall = 3;
    traceGoStatus traceGoWaiting = 4;
    traceProcStatus traceProcBad = 0;
    traceProcStatus traceProcRunning = 1;
    traceProcStatus traceProcIdle = 2;
    traceProcStatus traceProcSyscall = 3;
    traceProcStatus traceProcSyscallAbandoned = 4;
    traceWriter writeGoStatus(struct traceWriter w, uint64_t goid, int64_t mid, traceGoStatus status, bool markAssist)
    {
        if(status == traceGoBad)
        {
            print("runtime: goid=", goid, "\n");
            go_throw("attempted to trace a bad status for a goroutine");
        }
        w = event(gocpp::recv(w), traceEvGoStatus, traceArg(goid), traceArg(uint64_t(mid)), traceArg(status));
        if(markAssist)
        {
            w = event(gocpp::recv(w), traceEvGCMarkAssistActive, traceArg(goid));
        }
        return w;
    }

    traceWriter writeProcStatusForP(struct traceWriter w, p* pp, bool inSTW)
    {
        if(! acquireStatus(gocpp::recv(pp->trace), w.gen))
        {
            return w;
        }
        traceProcStatus status = {};
        //Go switch emulation
        {
            auto condition = pp->status;
            int conditionId = -1;
            if(condition == _Pidle) { conditionId = 0; }
            if(condition == _Pgcstop) { conditionId = 1; }
            else if(condition == _Prunning) { conditionId = 2; }
            else if(condition == _Psyscall) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    status = traceProcIdle;
                    if(pp->status == _Pgcstop && inSTW)
                    {
                        status = traceProcRunning;
                    }
                    break;
                case 2:
                    status = traceProcRunning;
                    if(ptr(gocpp::recv(w.mp->p)) == pp && w.mp->curg != nullptr && readgstatus(w.mp->curg) &^ _Gscan == _Gsyscall)
                    {
                        status = traceProcSyscall;
                    }
                    break;
                case 3:
                    status = traceProcSyscall;
                    break;
                default:
                    go_throw("attempt to trace invalid or unsupported P status");
                    break;
            }
        }
        w = writeProcStatus(gocpp::recv(w), uint64_t(pp->id), status, pp->trace.inSweep);
        return w;
    }

    traceWriter writeProcStatus(struct traceWriter w, uint64_t pid, traceProcStatus status, bool inSweep)
    {
        if(status == traceProcBad)
        {
            print("runtime: pid=", pid, "\n");
            go_throw("attempted to trace a bad status for a proc");
        }
        w = event(gocpp::recv(w), traceEvProcStatus, traceArg(pid), traceArg(status));
        if(inSweep)
        {
            w = event(gocpp::recv(w), traceEvGCSweepActive, traceArg(pid));
        }
        return w;
    }

    traceGoStatus goStatusToTraceGoStatus(uint32_t status, waitReason wr)
    {
        traceGoStatus tgs = {};
        //Go switch emulation
        {
            auto condition = status &^ _Gscan;
            int conditionId = -1;
            if(condition == _Grunnable) { conditionId = 0; }
            else if(condition == _Grunning) { conditionId = 1; }
            else if(condition == _Gcopystack) { conditionId = 2; }
            else if(condition == _Gsyscall) { conditionId = 3; }
            else if(condition == _Gwaiting) { conditionId = 4; }
            else if(condition == _Gpreempted) { conditionId = 5; }
            else if(condition == _Gdead) { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                    tgs = traceGoRunnable;
                    break;
                case 1:
                case 2:
                    tgs = traceGoRunning;
                    break;
                case 3:
                    tgs = traceGoSyscall;
                    break;
                case 4:
                case 5:
                    tgs = traceGoWaiting;
                    if(status == _Gwaiting && wr == waitReasonStoppingTheWorld || wr == waitReasonGCMarkTermination || wr == waitReasonGarbageCollection || wr == waitReasonTraceProcStatus || wr == waitReasonPageTraceFlush || wr == waitReasonGCWorkerActive)
                    {
                        tgs = traceGoRunning;
                    }
                    break;
                case 6:
                    go_throw("tried to trace dead goroutine");
                    break;
                default:
                    go_throw("tried to trace goroutine with invalid or unsupported status");
                    break;
            }
        }
        return tgs;
    }

    
    std::ostream& traceSchedResourceState::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << statusTraced;
        os << " " << seq;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct traceSchedResourceState& value)
    {
        return value.PrintTo(os);
    }

    bool acquireStatus(struct traceSchedResourceState* r, uintptr_t gen)
    {
        if(! CompareAndSwap(gocpp::recv(r->statusTraced[gen % 3]), 0, 1))
        {
            return false;
        }
        readyNextGen(gocpp::recv(r), gen);
        return true;
    }

    void readyNextGen(struct traceSchedResourceState* r, uintptr_t gen)
    {
        auto nextGen = traceNextGen(gen);
        r->seq[nextGen % 2] = 0;
        Store(gocpp::recv(r->statusTraced[nextGen % 3]), 0);
    }

    bool statusWasTraced(struct traceSchedResourceState* r, uintptr_t gen)
    {
        return Load(gocpp::recv(r->statusTraced[gen % 3])) != 0;
    }

    void setStatusTraced(struct traceSchedResourceState* r, uintptr_t gen)
    {
        Store(gocpp::recv(r->statusTraced[gen % 3]), 1);
    }

    traceArg nextSeq(struct traceSchedResourceState* r, uintptr_t gen)
    {
        r->seq[gen % 2]++;
        return traceArg(r->seq[gen % 2]);
    }

}

