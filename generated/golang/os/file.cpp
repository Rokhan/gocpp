// generated by GoCpp from file '$(ImportDir)/os/file.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/os/file.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/errors/wrap.h"
#include "golang/internal/poll/fd_mutex.h"
#include "golang/internal/poll/fd_poll_runtime.h"
#include "golang/internal/poll/fd_windows.h"
#include "golang/internal/safefilepath/path.h"
#include "golang/internal/syscall/windows/syscall_windows.h"
#include "golang/internal/testlog/log.h"
#include "golang/io/fs/fs.h"
#include "golang/io/io.h"
#include "golang/os/dir.h"
#include "golang/os/dir_windows.h"
#include "golang/os/env.h"
#include "golang/os/error.h"
#include "golang/os/file_posix.h"
#include "golang/os/file_windows.h"
#include "golang/os/getwd.h"
#include "golang/os/path_windows.h"
#include "golang/os/rawconn.h"
#include "golang/os/stat.h"
#include "golang/os/stat_windows.h"
#include "golang/os/sticky_notbsd.h"
#include "golang/os/types.h"
#include "golang/os/zero_copy_stub.h"
#include "golang/runtime/extern.h"
#include "golang/sync/mutex.h"
#include "golang/syscall/net.h"
#include "golang/syscall/syscall_windows.h"
#include "golang/syscall/types_windows.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"

namespace golang::os
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace errors::rec;
        using namespace fs::rec;
        using namespace io::rec;
        using namespace os::rec;
        using namespace poll::rec;
        using namespace runtime::rec;
        using namespace safefilepath::rec;
        using namespace sync::rec;
        using namespace syscall::rec;
        using namespace testlog::rec;
        using namespace time::rec;
        using namespace windows::rec;
    }

    std::string rec::Name(struct File* f)
    {
        return f->name;
    }

    File* Stdin = NewFile(uintptr_t(syscall::Stdin), "/dev/stdin");
    File* Stdout = NewFile(uintptr_t(syscall::Stdout), "/dev/stdout");
    File* Stderr = NewFile(uintptr_t(syscall::Stderr), "/dev/stderr");
    
    template<typename T> requires gocpp::GoStruct<T>
    LinkError::operator T()
    {
        T result;
        result.Op = this->Op;
        result.Old = this->Old;
        result.New = this->New;
        result.Err = this->Err;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool LinkError::operator==(const T& ref) const
    {
        if (Op != ref.Op) return false;
        if (Old != ref.Old) return false;
        if (New != ref.New) return false;
        if (Err != ref.Err) return false;
        return true;
    }

    std::ostream& LinkError::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Op;
        os << " " << Old;
        os << " " << New;
        os << " " << Err;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct LinkError& value)
    {
        return value.PrintTo(os);
    }

    std::string rec::Error(struct LinkError* e)
    {
        return e->Op + " " + e->Old + " " + e->New + ": " + rec::Error(gocpp::recv(e->Err));
    }

    struct gocpp::error rec::Unwrap(struct LinkError* e)
    {
        return e->Err;
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "read"); err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, err};
        }
        auto [n, e] = rec::read(gocpp::recv(f), b);
        return {n, rec::wrapErr(gocpp::recv(f), "read", e)};
    }

    std::tuple<int, struct gocpp::error> rec::ReadAt(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "read"); err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, err};
        }
        if(off < 0)
        {
            int n;
            struct gocpp::error err;
            return {0, gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "readat";
                x.Path = f->name;
                x.Err = errors::New("negative offset");
            })};
        }
        for(; len(b) > 0; )
        {
            int n;
            struct gocpp::error err;
            auto [m, e] = rec::pread(gocpp::recv(f), b, off);
            if(e != nullptr)
            {
                int n;
                struct gocpp::error err;
                err = rec::wrapErr(gocpp::recv(f), "read", e);
                break;
            }
            n += m;
            b = b.make_slice(m);
            off += int64_t(m);
        }
        return {n, err};
    }

    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(struct File* f, io::Reader r)
    {
        int64_t n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "write"); err != nullptr)
        {
            int64_t n;
            struct gocpp::error err;
            return {0, err};
        }
        auto [n, handled, e] = rec::readFrom(gocpp::recv(f), r);
        if(! handled)
        {
            int64_t n;
            struct gocpp::error err;
            return genericReadFrom(f, r);
        }
        return {n, rec::wrapErr(gocpp::recv(f), "write", e)};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    noReadFrom::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noReadFrom::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noReadFrom::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noReadFrom& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int64_t, struct gocpp::error> rec::ReadFrom(noReadFrom, io::Reader)
    {
        gocpp::panic("can't happen");
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    fileWithoutReadFrom::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fileWithoutReadFrom::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& fileWithoutReadFrom::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fileWithoutReadFrom& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int64_t, struct gocpp::error> genericReadFrom(struct File* f, io::Reader r)
    {
        return io::Copy(gocpp::Init<fileWithoutReadFrom>([](auto& x) {
            x.File = f;
        }), r);
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct File* f, gocpp::slice<unsigned char> b)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "write"); err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, err};
        }
        auto [n, e] = rec::write(gocpp::recv(f), b);
        if(n < 0)
        {
            int n;
            struct gocpp::error err;
            n = 0;
        }
        if(n != len(b))
        {
            int n;
            struct gocpp::error err;
            err = io::ErrShortWrite;
        }
        epipecheck(f, e);
        if(e != nullptr)
        {
            int n;
            struct gocpp::error err;
            err = rec::wrapErr(gocpp::recv(f), "write", e);
        }
        return {n, err};
    }

    gocpp::error errWriteAtInAppendMode = errors::New("os: invalid use of WriteAt on file opened with O_APPEND");
    std::tuple<int, struct gocpp::error> rec::WriteAt(struct File* f, gocpp::slice<unsigned char> b, int64_t off)
    {
        int n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "write"); err != nullptr)
        {
            int n;
            struct gocpp::error err;
            return {0, err};
        }
        if(f->appendMode)
        {
            int n;
            struct gocpp::error err;
            return {0, errWriteAtInAppendMode};
        }
        if(off < 0)
        {
            int n;
            struct gocpp::error err;
            return {0, gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "writeat";
                x.Path = f->name;
                x.Err = errors::New("negative offset");
            })};
        }
        for(; len(b) > 0; )
        {
            int n;
            struct gocpp::error err;
            auto [m, e] = rec::pwrite(gocpp::recv(f), b, off);
            if(e != nullptr)
            {
                int n;
                struct gocpp::error err;
                err = rec::wrapErr(gocpp::recv(f), "write", e);
                break;
            }
            n += m;
            b = b.make_slice(m);
            off += int64_t(m);
        }
        return {n, err};
    }

    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(struct File* f, io::Writer w)
    {
        int64_t n;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "read"); err != nullptr)
        {
            int64_t n;
            struct gocpp::error err;
            return {0, err};
        }
        auto [n, handled, e] = rec::writeTo(gocpp::recv(f), w);
        if(handled)
        {
            int64_t n;
            struct gocpp::error err;
            return {n, rec::wrapErr(gocpp::recv(f), "read", e)};
        }
        return genericWriteTo(f, w);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    noWriteTo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool noWriteTo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& noWriteTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct noWriteTo& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int64_t, struct gocpp::error> rec::WriteTo(noWriteTo, io::Writer)
    {
        gocpp::panic("can't happen");
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    fileWithoutWriteTo::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fileWithoutWriteTo::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& fileWithoutWriteTo::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fileWithoutWriteTo& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int64_t, struct gocpp::error> genericWriteTo(struct File* f, io::Writer w)
    {
        return io::Copy(w, gocpp::Init<fileWithoutWriteTo>([](auto& x) {
            x.File = f;
        }));
    }

    std::tuple<int64_t, struct gocpp::error> rec::Seek(struct File* f, int64_t offset, int whence)
    {
        int64_t ret;
        struct gocpp::error err;
        if(auto err = rec::checkValid(gocpp::recv(f), "seek"); err != nullptr)
        {
            int64_t ret;
            struct gocpp::error err;
            return {0, err};
        }
        auto [r, e] = rec::seek(gocpp::recv(f), offset, whence);
        if(e == nullptr && f->dirinfo != nullptr && r != 0)
        {
            int64_t ret;
            struct gocpp::error err;
            e = syscall::go_EISDIR;
        }
        if(e != nullptr)
        {
            int64_t ret;
            struct gocpp::error err;
            return {0, rec::wrapErr(gocpp::recv(f), "seek", e)};
        }
        return {r, nullptr};
    }

    std::tuple<int, struct gocpp::error> rec::WriteString(struct File* f, std::string s)
    {
        int n;
        struct gocpp::error err;
        auto b = unsafe::Slice(unsafe::StringData(s), len(s));
        return rec::Write(gocpp::recv(f), b);
    }

    struct gocpp::error Mkdir(std::string name, golang::os::FileMode perm)
    {
        auto longName = fixLongPath(name);
        auto e = ignoringEINTR([=]() mutable -> struct gocpp::error
        {
            return syscall::Mkdir(longName, syscallMode(perm));
        });
        if(e != nullptr)
        {
            return gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "mkdir";
                x.Path = name;
                x.Err = e;
            });
        }
        if(! supportsCreateWithStickyBit && perm & ModeSticky != 0)
        {
            e = setStickyBit(name);
            if(e != nullptr)
            {
                Remove(name);
                return e;
            }
        }
        return nullptr;
    }

    struct gocpp::error setStickyBit(std::string name)
    {
        auto [fi, err] = Stat(name);
        if(err != nullptr)
        {
            return err;
        }
        return Chmod(name, rec::Mode(gocpp::recv(fi)) | ModeSticky);
    }

    struct gocpp::error Chdir(std::string dir)
    {
        if(auto e = syscall::Chdir(dir); e != nullptr)
        {
            testlog::Open(dir);
            return gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "chdir";
                x.Path = dir;
                x.Err = e;
            });
        }
        if(auto log = testlog::Logger(); log != nullptr)
        {
            auto [wd, err] = Getwd();
            if(err == nullptr)
            {
                rec::Chdir(gocpp::recv(log), wd);
            }
        }
        return nullptr;
    }

    std::tuple<struct File*, struct gocpp::error> Open(std::string name)
    {
        return OpenFile(name, O_RDONLY, 0);
    }

    std::tuple<struct File*, struct gocpp::error> Create(std::string name)
    {
        return OpenFile(name, O_RDWR | O_CREATE | O_TRUNC, 0666);
    }

    std::tuple<struct File*, struct gocpp::error> OpenFile(std::string name, int flag, golang::os::FileMode perm)
    {
        testlog::Open(name);
        auto [f, err] = openFileNolog(name, flag, perm);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        f->appendMode = flag & O_APPEND != 0;
        return {f, nullptr};
    }

    fs::FileInfo, gocpp::error> (std::string)> lstat = Lstat;
    struct gocpp::error Rename(std::string oldpath, std::string newpath)
    {
        return rename(oldpath, newpath);
    }

    std::tuple<std::string, struct gocpp::error> Readlink(std::string name)
    {
        return readlink(name);
    }

    std::tuple<int, struct gocpp::error> fixCount(int n, struct gocpp::error err)
    {
        if(n < 0)
        {
            n = 0;
        }
        return {n, err};
    }

    bool checkWrapErr = false;
    struct gocpp::error rec::wrapErr(struct File* f, std::string op, struct gocpp::error err)
    {
        if(err == nullptr || err == io::go_EOF)
        {
            return err;
        }
        if(err == poll::ErrFileClosing)
        {
            err = ErrClosed;
        }
        else
        if(checkWrapErr && errors::Is(err, poll::ErrFileClosing))
        {
            gocpp::panic("unexpected error wrapping poll.ErrFileClosing: " + rec::Error(gocpp::recv(err)));
        }
        return gocpp::InitPtr<os::PathError>([](auto& x) {
            x.Op = op;
            x.Path = f->name;
            x.Err = err;
        });
    }

    std::string TempDir()
    {
        return tempDir();
    }

    std::tuple<std::string, struct gocpp::error> UserCacheDir()
    {
        std::string dir = {};
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "windows") { conditionId = 0; }
            else if(condition == "darwin") { conditionId = 1; }
            else if(condition == "ios") { conditionId = 2; }
            else if(condition == "plan9") { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    dir = Getenv("LocalAppData");
                    if(dir == "")
                    {
                        return {"", errors::New("%LocalAppData% is not defined")};
                    }
                    break;
                case 1:
                case 2:
                    dir = Getenv("HOME");
                    if(dir == "")
                    {
                        return {"", errors::New("$HOME is not defined")};
                    }
                    dir += "/Library/Caches";
                    break;
                case 3:
                    dir = Getenv("home");
                    if(dir == "")
                    {
                        return {"", errors::New("$home is not defined")};
                    }
                    dir += "/lib/cache";
                    break;
                default:
                    dir = Getenv("XDG_CACHE_HOME");
                    if(dir == "")
                    {
                        dir = Getenv("HOME");
                        if(dir == "")
                        {
                            return {"", errors::New("neither $XDG_CACHE_HOME nor $HOME are defined")};
                        }
                        dir += "/.cache";
                    }
                    break;
            }
        }
        return {dir, nullptr};
    }

    std::tuple<std::string, struct gocpp::error> UserConfigDir()
    {
        std::string dir = {};
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "windows") { conditionId = 0; }
            else if(condition == "darwin") { conditionId = 1; }
            else if(condition == "ios") { conditionId = 2; }
            else if(condition == "plan9") { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                    dir = Getenv("AppData");
                    if(dir == "")
                    {
                        return {"", errors::New("%AppData% is not defined")};
                    }
                    break;
                case 1:
                case 2:
                    dir = Getenv("HOME");
                    if(dir == "")
                    {
                        return {"", errors::New("$HOME is not defined")};
                    }
                    dir += "/Library/Application Support";
                    break;
                case 3:
                    dir = Getenv("home");
                    if(dir == "")
                    {
                        return {"", errors::New("$home is not defined")};
                    }
                    dir += "/lib";
                    break;
                default:
                    dir = Getenv("XDG_CONFIG_HOME");
                    if(dir == "")
                    {
                        dir = Getenv("HOME");
                        if(dir == "")
                        {
                            return {"", errors::New("neither $XDG_CONFIG_HOME nor $HOME are defined")};
                        }
                        dir += "/.config";
                    }
                    break;
            }
        }
        return {dir, nullptr};
    }

    std::tuple<std::string, struct gocpp::error> UserHomeDir()
    {
        auto [env, enverr] = std::tuple{"HOME", "$HOME"};
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "windows") { conditionId = 0; }
            else if(condition == "plan9") { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    std::tie(env, enverr) = std::tuple{"USERPROFILE", "%userprofile%"};
                    break;
                case 1:
                    std::tie(env, enverr) = std::tuple{"home", "$home"};
                    break;
            }
        }
        if(auto v = Getenv(env); v != "")
        {
            return {v, nullptr};
        }
        //Go switch emulation
        {
            auto condition = mocklib::GOOS;
            int conditionId = -1;
            if(condition == "android") { conditionId = 0; }
            else if(condition == "ios") { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return {"/sdcard", nullptr};
                    break;
                case 1:
                    return {"/", nullptr};
                    break;
            }
        }
        return {"", errors::New(enverr + " is not defined")};
    }

    struct gocpp::error Chmod(std::string name, golang::os::FileMode mode)
    {
        return chmod(name, mode);
    }

    struct gocpp::error rec::Chmod(struct File* f, golang::os::FileMode mode)
    {
        return rec::chmod(gocpp::recv(f), mode);
    }

    struct gocpp::error rec::SetDeadline(struct File* f, mocklib::Date t)
    {
        return rec::setDeadline(gocpp::recv(f), t);
    }

    struct gocpp::error rec::SetReadDeadline(struct File* f, mocklib::Date t)
    {
        return rec::setReadDeadline(gocpp::recv(f), t);
    }

    struct gocpp::error rec::SetWriteDeadline(struct File* f, mocklib::Date t)
    {
        return rec::setWriteDeadline(gocpp::recv(f), t);
    }

    std::tuple<syscall::RawConn, struct gocpp::error> rec::SyscallConn(struct File* f)
    {
        if(auto err = rec::checkValid(gocpp::recv(f), "SyscallConn"); err != nullptr)
        {
            return {nullptr, err};
        }
        return newRawConn(f);
    }

    fs::FS DirFS(std::string dir)
    {
        return dirFS(dir);
    }

    std::tuple<fs::File, struct gocpp::error> rec::Open(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "open";
                x.Path = name;
                x.Err = err;
            })};
        }
        File* f;
        std::tie(f, err) = Open(fullname);
        if(err != nullptr)
        {
            gocpp::getValue<fs::PathError*>(err)->Path = name;
            return {nullptr, err};
        }
        return {f, nullptr};
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::ReadFile(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "readfile";
                x.Path = name;
                x.Err = err;
            })};
        }
        gocpp::slice<unsigned char> b;
        std::tie(b, err) = ReadFile(fullname);
        if(err != nullptr)
        {
            if(auto [e, ok] = gocpp::getValue<fs::PathError*>(err); ok)
            {
                e->Path = name;
            }
            return {nullptr, err};
        }
        return {b, nullptr};
    }

    std::tuple<gocpp::slice<os::DirEntry>, struct gocpp::error> rec::ReadDir(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "readdir";
                x.Path = name;
                x.Err = err;
            })};
        }
        fs::DirEntry> entries;
        std::tie(entries, err) = ReadDir(fullname);
        if(err != nullptr)
        {
            if(auto [e, ok] = gocpp::getValue<fs::PathError*>(err); ok)
            {
                e->Path = name;
            }
            return {nullptr, err};
        }
        return {entries, nullptr};
    }

    std::tuple<fs::FileInfo, struct gocpp::error> rec::Stat(golang::os::dirFS dir, std::string name)
    {
        auto [fullname, err] = rec::join(gocpp::recv(dir), name);
        if(err != nullptr)
        {
            return {nullptr, gocpp::InitPtr<os::PathError>([](auto& x) {
                x.Op = "stat";
                x.Path = name;
                x.Err = err;
            })};
        }
        fs::FileInfo f;
        std::tie(f, err) = Stat(fullname);
        if(err != nullptr)
        {
            gocpp::getValue<fs::PathError*>(err)->Path = name;
            return {nullptr, err};
        }
        return {f, nullptr};
    }

    std::tuple<std::string, struct gocpp::error> rec::join(golang::os::dirFS dir, std::string name)
    {
        if(dir == "")
        {
            return {"", errors::New("os: DirFS with empty root")};
        }
        if(! fs::ValidPath(name))
        {
            return {"", ErrInvalid};
        }
        auto [name, err] = safefilepath::FromFS(name);
        if(err != nullptr)
        {
            return {"", ErrInvalid};
        }
        if(IsPathSeparator(dir[len(dir) - 1]))
        {
            return {string(dir) + name, nullptr};
        }
        return {string(dir) + string(PathSeparator) + name, nullptr};
    }

    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> ReadFile(std::string name)
    {
        gocpp::Defer defer;
        try
        {
            auto [f, err] = Open(name);
            if(err != nullptr)
            {
                return {nullptr, err};
            }
            defer.push_back([=]{ rec::Close(gocpp::recv(f)); });
            int size = {};
            if(auto [info, err] = rec::Stat(gocpp::recv(f)); err == nullptr)
            {
                auto size64 = rec::Size(gocpp::recv(info));
                if(int64_t(int(size64)) == size64)
                {
                    size = int(size64);
                }
            }
            size++;
            if(size < 512)
            {
                size = 512;
            }
            auto data = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), 0, size);
            for(; ; )
            {
                auto [n, err] = rec::Read(gocpp::recv(f), data.make_slice(len(data), cap(data)));
                data = data.make_slice(0, len(data) + n);
                if(err != nullptr)
                {
                    if(err == io::go_EOF)
                    {
                        err = nullptr;
                    }
                    return {data, err};
                }
                if(len(data) >= cap(data))
                {
                    auto d = append(data.make_slice(0, cap(data)), 0);
                    data = d.make_slice(0, len(data));
                }
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    struct gocpp::error WriteFile(std::string name, gocpp::slice<unsigned char> data, golang::os::FileMode perm)
    {
        auto [f, err] = OpenFile(name, O_WRONLY | O_CREATE | O_TRUNC, perm);
        if(err != nullptr)
        {
            return err;
        }
        std::tie(gocpp_id_0, err) = rec::Write(gocpp::recv(f), data);
        if(auto err1 = rec::Close(gocpp::recv(f)); err1 != nullptr && err == nullptr)
        {
            err = err1;
        }
        return err;
    }

}

