// generated by GoCpp from file '$(ImportDir)/runtime/mfixalloc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mfixalloc.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/stubs.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // fixalloc is a simple free-list allocator for fixed size objects.
    // Malloc uses a FixAlloc wrapped around sysAlloc to manage its
    // mcache and mspan objects.
    //
    // Memory returned by fixalloc.alloc is zeroed by default, but the
    // caller may take responsibility for zeroing allocations by setting
    // the zero flag to false. This is only safe if the memory never
    // contains heap pointers.
    //
    // The caller is responsible for locking around FixAlloc calls.
    // Callers can keep state in the object but the first word is
    // smashed by freeing and reallocating.
    //
    // Consider marking fixalloc'd types not in heap by embedding
    // runtime/internal/sys.NotInHeap.
    
    template<typename T> requires gocpp::GoStruct<T>
    fixalloc::operator T()
    {
        T result;
        result.size = this->size;
        result.first = this->first;
        result.arg = this->arg;
        result.list = this->list;
        result.chunk = this->chunk;
        result.nchunk = this->nchunk;
        result.nalloc = this->nalloc;
        result.inuse = this->inuse;
        result.stat = this->stat;
        result.zero = this->zero;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool fixalloc::operator==(const T& ref) const
    {
        if (size != ref.size) return false;
        if (first != ref.first) return false;
        if (arg != ref.arg) return false;
        if (list != ref.list) return false;
        if (chunk != ref.chunk) return false;
        if (nchunk != ref.nchunk) return false;
        if (nalloc != ref.nalloc) return false;
        if (inuse != ref.inuse) return false;
        if (stat != ref.stat) return false;
        if (zero != ref.zero) return false;
        return true;
    }

    std::ostream& fixalloc::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << size;
        os << " " << first;
        os << " " << arg;
        os << " " << list;
        os << " " << chunk;
        os << " " << nchunk;
        os << " " << nalloc;
        os << " " << inuse;
        os << " " << stat;
        os << " " << zero;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct fixalloc& value)
    {
        return value.PrintTo(os);
    }

    // A generic linked list of blocks.  (Typically the block is bigger than sizeof(MLink).)
    // Since assignments to mlink.next will result in a write barrier being performed
    // this cannot be used by some of the internal GC structures. For example when
    // the sweeper is placing an unmarked object on the free list it does not want the
    // write barrier to be called since that could result in the object being reachable.
    
    template<typename T> requires gocpp::GoStruct<T>
    mlink::operator T()
    {
        T result;
        result._1 = this->_1;
        result.next = this->next;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mlink::operator==(const T& ref) const
    {
        if (_1 != ref._1) return false;
        if (next != ref.next) return false;
        return true;
    }

    std::ostream& mlink::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << _1;
        os << " " << next;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mlink& value)
    {
        return value.PrintTo(os);
    }

    // Initialize f to allocate objects of the given size,
    // using the allocator to obtain chunks of memory.
    void rec::init(struct fixalloc* f, uintptr_t size, std::function<void (unsafe::Pointer arg, unsafe::Pointer p)> first, unsafe::Pointer arg, golang::runtime::sysMemStat* stat)
    {
        if(size > _FixAllocChunk)
        {
            go_throw("runtime: fixalloc size too large"s);
        }
        size = gocpp::max(size, gocpp::Sizeof<mlink>());
        f->size = size;
        f->first = first;
        f->arg = arg;
        f->list = nullptr;
        f->chunk = 0;
        f->nchunk = 0;
        f->nalloc = uint32_t(_FixAllocChunk / size * size);
        f->inuse = 0;
        f->stat = stat;
        f->zero = true;
    }

    unsafe::Pointer rec::alloc(struct fixalloc* f)
    {
        if(f->size == 0)
        {
            print("runtime: use of FixAlloc_Alloc before FixAlloc_Init\n"s);
            go_throw("runtime: internal error"s);
        }
        if(f->list != nullptr)
        {
            auto v = unsafe::Pointer(f->list);
            f->list = f->list->next;
            f->inuse += f->size;
            if(f->zero)
            {
                memclrNoHeapPointers(v, f->size);
            }
            return v;
        }
        if(uintptr_t(f->nchunk) < f->size)
        {
            f->chunk = uintptr_t(persistentalloc(uintptr_t(f->nalloc), 0, f->stat));
            f->nchunk = f->nalloc;
        }
        auto v = unsafe::Pointer(f->chunk);
        if(f->first != nullptr)
        {
            rec::first(gocpp::recv(f), f->arg, v);
        }
        f->chunk = f->chunk + f->size;
        f->nchunk -= uint32_t(f->size);
        f->inuse += f->size;
        return v;
    }

    void rec::free(struct fixalloc* f, unsafe::Pointer p)
    {
        f->inuse -= f->size;
        auto v = (mlink*)(p);
        v->next = f->list;
        f->list = v;
    }

}

