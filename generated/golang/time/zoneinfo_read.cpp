// generated by GoCpp from file '$(ImportDir)/time/zoneinfo_read.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/time/zoneinfo_read.h"
#include "gocpp/support.h"

#include "golang/errors/errors.h"
#include "golang/runtime/extern.h"
#include "golang/syscall/zerrors_windows.h"
#include "golang/time/sys_windows.h"
#include "golang/time/time.h"
#include "golang/time/zoneinfo.h"
#include "golang/time/zoneinfo_goroot.h"

namespace golang::time
{
    void registerLoadFromEmbeddedTZData(std::function<std::tuple<std::string, std::string> (std::string)> f)
    {
        loadFromEmbeddedTZData = f;
    }

    std::function<std::tuple<std::string, std::string> (std::string zipname)> loadFromEmbeddedTZData;
    std::string Error(fileSizeError f)
    {
        return "time: file " + string(f) + " is too large";
    }

    
    std::ostream& dataIO::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << p;
        os << " " << error;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct dataIO& value)
    {
        return value.PrintTo(os);
    }

    gocpp::slice<unsigned char> read(struct dataIO* d, int n)
    {
        if(len(d->p) < n)
        {
            d->p = nullptr;
            d->error = true;
            return nullptr;
        }
        auto p = d->p.make_slice(0, n);
        d->p = d->p.make_slice(n);
        return p;
    }

    std::tuple<uint32_t, bool> big4(struct dataIO* d)
    {
        uint32_t n;
        bool ok;
        auto p = read(gocpp::recv(d), 4);
        if(len(p) < 4)
        {
            uint32_t n;
            bool ok;
            d->error = true;
            return {0, false};
        }
        return {uint32_t(p[3]) | (uint32_t(p[2]) << 8) | (uint32_t(p[1]) << 16) | (uint32_t(p[0]) << 24), true};
    }

    std::tuple<uint64_t, bool> big8(struct dataIO* d)
    {
        uint64_t n;
        bool ok;
        auto [n1, ok1] = big4(gocpp::recv(d));
        auto [n2, ok2] = big4(gocpp::recv(d));
        if(! ok1 || ! ok2)
        {
            uint64_t n;
            bool ok;
            d->error = true;
            return {0, false};
        }
        return {(uint64_t(n1) << 32) | uint64_t(n2), true};
    }

    std::tuple<unsigned char, bool> byte(struct dataIO* d)
    {
        unsigned char n;
        bool ok;
        auto p = read(gocpp::recv(d), 1);
        if(len(p) < 1)
        {
            unsigned char n;
            bool ok;
            d->error = true;
            return {0, false};
        }
        return {p[0], true};
    }

    gocpp::slice<unsigned char> rest(struct dataIO* d)
    {
        auto r = d->p;
        d->p = nullptr;
        return r;
    }

    std::string byteString(gocpp::slice<unsigned char> p)
    {
        for(auto i = 0; i < len(p); i++)
        {
            if(p[i] == 0)
            {
                return string(p.make_slice(0, i));
            }
        }
        return string(p);
    }

    std::string errBadData = errors::New("malformed time zone information");
    std::tuple<Location*, std::string> LoadLocationFromTZData(std::string name, gocpp::slice<unsigned char> data)
    {
        auto d = dataIO {data, false};
        if(auto magic = read(gocpp::recv(d), 4); string(magic) != "TZif")
        {
            return {nullptr, errBadData};
        }
        int version = {};
        gocpp::slice<unsigned char> p = {};
        if(p = read(gocpp::recv(d), 16); len(p) != 16)
        {
            return {nullptr, errBadData};
        }
        else
        {
            //Go switch emulation
            {
                auto condition = p[0];
                int conditionId = -1;
                if(condition == 0) { conditionId = 0; }
                else if(condition == '2') { conditionId = 1; }
                else if(condition == '3') { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        version = 1;
                        break;
                    case 1:
                        version = 2;
                        break;
                    case 2:
                        version = 3;
                        break;
                    default:
                        return {nullptr, errBadData};
                        break;
                }
            }
        }
        auto NUTCLocal = 0;
        auto NStdWall = 1;
        auto NLeap = 2;
        auto NTime = 3;
        auto NZone = 4;
        auto NChar = 5;
        gocpp::array<int, 6> n = {};
        for(auto i = 0; i < 6; i++)
        {
            auto [nn, ok] = big4(gocpp::recv(d));
            if(! ok)
            {
                return {nullptr, errBadData};
            }
            if(uint32_t(int(nn)) != nn)
            {
                return {nullptr, errBadData};
            }
            n[i] = int(nn);
        }
        auto is64 = false;
        if(version > 1)
        {
            auto skip = n[NTime] * 4 + n[NTime] + n[NZone] * 6 + n[NChar] + n[NLeap] * 8 + n[NStdWall] + n[NUTCLocal];
            skip += 4 + 16;
            read(gocpp::recv(d), skip);
            is64 = true;
            for(auto i = 0; i < 6; i++)
            {
                auto [nn, ok] = big4(gocpp::recv(d));
                if(! ok)
                {
                    return {nullptr, errBadData};
                }
                if(uint32_t(int(nn)) != nn)
                {
                    return {nullptr, errBadData};
                }
                n[i] = int(nn);
            }
        }
        auto size = 4;
        if(is64)
        {
            size = 8;
        }
        auto txtimes = dataIO {read(gocpp::recv(d), n[NTime] * size), false};
        auto txzones = read(gocpp::recv(d), n[NTime]);
        auto zonedata = dataIO {read(gocpp::recv(d), n[NZone] * 6), false};
        auto abbrev = read(gocpp::recv(d), n[NChar]);
        read(gocpp::recv(d), n[NLeap] * (size + 4));
        auto isstd = read(gocpp::recv(d), n[NStdWall]);
        auto isutc = read(gocpp::recv(d), n[NUTCLocal]);
        if(d->error)
        {
            return {nullptr, errBadData};
        }
        std::string extend = {};
        auto rest = rest(gocpp::recv(d));
        if(len(rest) > 2 && rest[0] == '\n' && rest[len(rest) - 1] == '\n')
        {
            extend = string(rest.make_slice(1, len(rest) - 1));
        }
        auto nzone = n[NZone];
        if(nzone == 0)
        {
            return {nullptr, errBadData};
        }
        auto zones = gocpp::make(gocpp::Tag<gocpp::slice<zone>>(), nzone);
        for(auto [i, gocpp_ignored] : zones)
        {
            bool ok = {};
            uint32_t n = {};
            if(std::tie(n, ok) = big4(gocpp::recv(zonedata)); ! ok)
            {
                return {nullptr, errBadData};
            }
            if(uint32_t(int(n)) != n)
            {
                return {nullptr, errBadData};
            }
            zones[i].offset = int(int32_t(n));
            unsigned char b = {};
            if(std::tie(b, ok) = unsigned char(gocpp::recv(zonedata)); ! ok)
            {
                return {nullptr, errBadData};
            }
            zones[i].isDST = b != 0;
            if(std::tie(b, ok) = unsigned char(gocpp::recv(zonedata)); ! ok || int(b) >= len(abbrev))
            {
                return {nullptr, errBadData};
            }
            zones[i].name = byteString(abbrev.make_slice(b));
            if(mocklib::GOOS == "aix" && len(name) > 8 && (name.make_slice(0, 8) == "Etc/GMT+" || name.make_slice(0, 8) == "Etc/GMT-"))
            {
                if(name != "Etc/GMT+0")
                {
                    zones[i].name = name.make_slice(4);
                }
            }
        }
        auto tx = gocpp::make(gocpp::Tag<gocpp::slice<zoneTrans>>(), n[NTime]);
        for(auto [i, gocpp_ignored] : tx)
        {
            int64_t n = {};
            if(! is64)
            {
                if(auto [n4, ok] = big4(gocpp::recv(txtimes)); ! ok)
                {
                    return {nullptr, errBadData};
                }
                else
                {
                    n = int64_t(int32_t(n4));
                }
            }
            else
            {
                if(auto [n8, ok] = big8(gocpp::recv(txtimes)); ! ok)
                {
                    return {nullptr, errBadData};
                }
                else
                {
                    n = int64_t(n8);
                }
            }
            tx[i].when = n;
            if(int(txzones[i]) >= len(zones))
            {
                return {nullptr, errBadData};
            }
            tx[i].index = txzones[i];
            if(i < len(isstd))
            {
                tx[i].isstd = isstd[i] != 0;
            }
            if(i < len(isutc))
            {
                tx[i].isutc = isutc[i] != 0;
            }
        }
        if(len(tx) == 0)
        {
            tx = append(tx, gocpp::Init<zoneTrans>([](zoneTrans& x) { x.when = alpha; x.index = 0; }));
        }
        auto l = gocpp::InitPtr<Location>([](Location& x) { x.zone = zones; x.tx = tx; x.name = name; x.extend = extend; });
        int64_t sec;
        int32_t _;
        int64_t _;
        std::tie(sec, _, _) = now();
        for(auto [i, gocpp_ignored] : tx)
        {
            if(tx[i].when <= sec && (i + 1 == len(tx) || sec < tx[i + 1].when))
            {
                l->cacheStart = tx[i].when;
                l->cacheEnd = omega;
                l->cacheZone = & l->zone[tx[i].index];
                if(i + 1 < len(tx))
                {
                    l->cacheEnd = tx[i + 1].when;
                }
                else
                if(l->extend != "")
                {
                    if(auto [name, offset, estart, eend, isDST, ok] = tzset(l->extend, l->cacheStart, sec); ok)
                    {
                        l->cacheStart = estart;
                        l->cacheEnd = eend;
                        if(auto zoneIdx = findZone(l->zone, name, offset, isDST); zoneIdx != - 1)
                        {
                            l->cacheZone = & l->zone[zoneIdx];
                        }
                        else
                        {
                            l->cacheZone = gocpp::InitPtr<zone>([](zone& x) { x.name = name; x.offset = offset; x.isDST = isDST; });
                        }
                    }
                }
                break;
            }
        }
        return {l, nullptr};
    }

    int findZone(gocpp::slice<zone> zones, std::string name, int offset, bool isDST)
    {
        for(auto [i, z] : zones)
        {
            if(z.name == name && z.offset == offset && z.isDST == isDST)
            {
                return i;
            }
        }
        return - 1;
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> loadTzinfoFromDirOrZip(std::string dir, std::string name)
    {
        if(len(dir) > 4 && dir.make_slice(len(dir) - 4) == ".zip")
        {
            return loadTzinfoFromZip(dir, name);
        }
        if(dir != "")
        {
            name = dir + "/" + name;
        }
        return readFile(name);
    }

    int get4(gocpp::slice<unsigned char> b)
    {
        if(len(b) < 4)
        {
            return 0;
        }
        return int(b[0]) | (int(b[1]) << 8) | (int(b[2]) << 16) | (int(b[3]) << 24);
    }

    int get2(gocpp::slice<unsigned char> b)
    {
        if(len(b) < 2)
        {
            return 0;
        }
        return int(b[0]) | (int(b[1]) << 8);
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> loadTzinfoFromZip(std::string zipfile, std::string name)
    {
        gocpp::Defer defer;
        auto [fd, err] = open(zipfile);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        defer.push_back([=]{ closefd(fd); });
        auto zecheader = 0x06054b50;
        auto zcheader = 0x02014b50;
        auto ztailsize = 22;
        auto zheadersize = 30;
        auto zheader = 0x04034b50;
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), ztailsize);
        if(auto err = preadn(fd, buf, - ztailsize); err != nullptr || get4(buf) != zecheader)
        {
            return {nullptr, errors::New("corrupt zip file " + zipfile)};
        }
        auto n = get2(buf.make_slice(10));
        auto size = get4(buf.make_slice(12));
        auto off = get4(buf.make_slice(16));
        buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
        if(auto err = preadn(fd, buf, off); err != nullptr)
        {
            return {nullptr, errors::New("corrupt zip file " + zipfile)};
        }
        for(auto i = 0; i < n; i++)
        {
            if(get4(buf) != zcheader)
            {
                break;
            }
            auto meth = get2(buf.make_slice(10));
            auto size = get4(buf.make_slice(24));
            auto namelen = get2(buf.make_slice(28));
            auto xlen = get2(buf.make_slice(30));
            auto fclen = get2(buf.make_slice(32));
            auto off = get4(buf.make_slice(42));
            auto zname = buf.make_slice(46, 46 + namelen);
            buf = buf.make_slice(46 + namelen + xlen + fclen);
            if(string(zname) != name)
            {
                continue;
            }
            if(meth != 0)
            {
                return {nullptr, errors::New("unsupported compression for " + name + " in " + zipfile)};
            }
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), zheadersize + namelen);
            if(auto err = preadn(fd, buf, off); err != nullptr || get4(buf) != zheader || get2(buf.make_slice(8)) != meth || get2(buf.make_slice(26)) != namelen || string(buf.make_slice(30, 30 + namelen)) != name)
            {
                return {nullptr, errors::New("corrupt zip file " + zipfile)};
            }
            xlen = get2(buf.make_slice(28));
            buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), size);
            if(auto err = preadn(fd, buf, off + 30 + namelen + xlen); err != nullptr)
            {
                return {nullptr, errors::New("corrupt zip file " + zipfile)};
            }
            return {buf, nullptr};
        }
        return {nullptr, syscall::ENOENT};
    }

    std::function<std::tuple<gocpp::slice<unsigned char>, std::string> (std::string file, std::string name)> loadTzinfoFromTzdata;
    std::tuple<gocpp::slice<unsigned char>, std::string> loadTzinfo(std::string name, std::string source)
    {
        if(len(source) >= 6 && source.make_slice(len(source) - 6) == "tzdata")
        {
            return loadTzinfoFromTzdata(source, name);
        }
        return loadTzinfoFromDirOrZip(source, name);
    }

    std::tuple<Location*, std::string> loadLocation(std::string name, gocpp::slice<std::string> sources)
    {
        Location* z;
        std::string firstErr;
        for(auto [_, source] : sources)
        {
            Location* z;
            std::string firstErr;
            auto [zoneData, err] = loadTzinfo(name, source);
            if(err == nullptr)
            {
                Location* z;
                std::string firstErr;
                if(std::tie(z, err) = LoadLocationFromTZData(name, zoneData); err == nullptr)
                {
                    Location* z;
                    std::string firstErr;
                    return {z, nullptr};
                }
            }
            if(firstErr == nullptr && err != syscall::ENOENT)
            {
                Location* z;
                std::string firstErr;
                firstErr = err;
            }
        }
        if(loadFromEmbeddedTZData != nullptr)
        {
            Location* z;
            std::string firstErr;
            auto [zoneData, err] = loadFromEmbeddedTZData(name);
            if(err == nullptr)
            {
                Location* z;
                std::string firstErr;
                if(std::tie(z, err) = LoadLocationFromTZData(name, gocpp::Tag<gocpp::slice<unsigned char>>()(zoneData)); err == nullptr)
                {
                    Location* z;
                    std::string firstErr;
                    return {z, nullptr};
                }
            }
            if(firstErr == nullptr && err != syscall::ENOENT)
            {
                Location* z;
                std::string firstErr;
                firstErr = err;
            }
        }
        if(auto [source, ok] = gorootZoneSource(runtime::GOROOT()); ok)
        {
            Location* z;
            std::string firstErr;
            auto [zoneData, err] = loadTzinfo(name, source);
            if(err == nullptr)
            {
                Location* z;
                std::string firstErr;
                if(std::tie(z, err) = LoadLocationFromTZData(name, zoneData); err == nullptr)
                {
                    Location* z;
                    std::string firstErr;
                    return {z, nullptr};
                }
            }
            if(firstErr == nullptr && err != syscall::ENOENT)
            {
                Location* z;
                std::string firstErr;
                firstErr = err;
            }
        }
        if(firstErr != nullptr)
        {
            Location* z;
            std::string firstErr;
            return {nullptr, firstErr};
        }
        return {nullptr, errors::New("unknown time zone " + name)};
    }

    std::tuple<gocpp::slice<unsigned char>, std::string> readFile(std::string name)
    {
        gocpp::Defer defer;
        auto [f, err] = open(name);
        if(err != nullptr)
        {
            return {nullptr, err};
        }
        defer.push_back([=]{ closefd(f); });
        gocpp::array<unsigned char, 4096> buf = {};
        gocpp::slice<unsigned char> ret = {};
        int n = {};
        for(; ; )
        {
            std::tie(n, err) = read(f, buf.make_slice(0, ));
            if(n > 0)
            {
                ret = append(ret, buf.make_slice(0, n));
            }
            if(n == 0 || err != nullptr)
            {
                break;
            }
            if(len(ret) > maxFileSize)
            {
                return {nullptr, fileSizeError(name)};
            }
        }
        return {ret, err};
    }

}

