// generated by GoCpp from file '$(ImportDir)/reflect/abi.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/reflect/abi.fwd.h"
#include "gocpp/support.h"

#include "golang/internal/abi/abi.h"
#include "golang/internal/abi/type.h"
#include "golang/reflect/type.h"

namespace golang::reflect
{
    extern int intArgRegs;
    extern int floatArgRegs;
    extern uintptr_t floatRegSize;
    struct abiStep
    {
        reflect::abiStepKind kind;
        uintptr_t offset;
        uintptr_t size;
        uintptr_t stkOff;
        int ireg;
        int freg;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct abiStep& value);
    struct abiSeq
    {
        gocpp::slice<abiStep> steps;
        gocpp::slice<int> valueStart;
        uintptr_t stackBytes;
        int iregs;
        int fregs;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct abiSeq& value);
    struct abiDesc
    {
        abiSeq call;
        abiSeq ret;
        uintptr_t stackCallArgsSize;
        uintptr_t retOffset;
        uintptr_t spill;
        bitVector* stackPtrs;
        abi::IntArgRegBitmap inRegPtrs;
        abi::IntArgRegBitmap outRegPtrs;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct abiDesc& value);
    void dumpPtrBitMap(abi::IntArgRegBitmap b);
    struct abiDesc newAbiDesc(struct funcType* t, struct abi::Type* rcvr);
    void intFromReg(struct abi::RegArgs* r, int reg, uintptr_t argSize, unsafe::Pointer to);
    void intToReg(struct abi::RegArgs* r, int reg, uintptr_t argSize, unsafe::Pointer from);
    void floatFromReg(struct abi::RegArgs* r, int reg, uintptr_t argSize, unsafe::Pointer to);
    void floatToReg(struct abi::RegArgs* r, int reg, uintptr_t argSize, unsafe::Pointer from);

    namespace rec
    {
        void dump(struct abiSeq* a);
        gocpp::slice<abiStep> stepsForValue(struct abiSeq* a, int i);
        struct abiStep* addArg(struct abiSeq* a, struct abi::Type* t);
        std::tuple<struct abiStep*, bool> addRcvr(struct abiSeq* a, struct abi::Type* rcvr);
        bool regAssign(struct abiSeq* a, struct abi::Type* t, uintptr_t offset);
        bool assignIntN(struct abiSeq* a, uintptr_t offset, uintptr_t size, int n, uint8_t ptrMap);
        bool assignFloatN(struct abiSeq* a, uintptr_t offset, uintptr_t size, int n);
        void stackAssign(struct abiSeq* a, uintptr_t size, uintptr_t alignment);
        void dump(struct abiDesc* a);
    }
}

