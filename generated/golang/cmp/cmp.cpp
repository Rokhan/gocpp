// generated by GoCpp from file '$(ImportDir)/cmp/cmp.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/cmp/cmp.h"
#include "gocpp/support.h"

namespace golang::cmp
{
    
    template<typename T>
    Ordered::Ordered(T& ref)
    {
        value.reset(new OrderedImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Ordered::Ordered(const T& ref)
    {
        value.reset(new OrderedImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Ordered::Ordered(T* ptr)
    {
        value.reset(new OrderedImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Ordered::PrintTo(std::ostream& os) const
    {
        return os;
    }


    std::ostream& operator<<(std::ostream& os, const struct Ordered& value)
    {
        return value.PrintTo(os);
    }

    bool Less(T x, T y)
    {
        return (isNaN(x) && ! isNaN(y)) || x < y;
    }

    int Compare(T x, T y)
    {
        auto xNaN = isNaN(x);
        auto yNaN = isNaN(y);
        if(xNaN && yNaN)
        {
            return 0;
        }
        if(xNaN || x < y)
        {
            return - 1;
        }
        if(yNaN || x > y)
        {
            return + 1;
        }
        return 0;
    }

    bool isNaN(T x)
    {
        return x != x;
    }

    T Or(gocpp::slice<T> vals)
    {
        T zero = {};
        for(auto [_, val] : vals)
        {
            if(val != zero)
            {
                return val;
            }
        }
        return zero;
    }

}

