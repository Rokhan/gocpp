// generated by GoCpp from file '$(ImportDir)/internal/abi/type.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/type.fwd.h"
#include "gocpp/support.h"


namespace golang::abi
{
    struct Type
    {
        uintptr_t Size_;
        uintptr_t PtrBytes;
        uint32_t Hash;
        golang::abi::TFlag TFlag;
        uint8_t Align_;
        uint8_t FieldAlign_;
        uint8_t Kind_;
        std::function<bool (unsafe::Pointer, unsafe::Pointer)> Equal;
        unsigned char* GCData;
        golang::abi::NameOff Str;
        golang::abi::TypeOff PtrToThis;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Type& value);
    extern gocpp::slice<std::string> kindNames;
    struct Method
    {
        golang::abi::NameOff Name;
        golang::abi::TypeOff Mtyp;
        golang::abi::TextOff Ifn;
        golang::abi::TextOff Tfn;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Method& value);
    struct UncommonType
    {
        golang::abi::NameOff PkgPath;
        uint16_t Mcount;
        uint16_t Xcount;
        uint32_t Moff;
        uint32_t _;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct UncommonType& value);
    unsafe::Pointer addChecked(unsafe::Pointer p, uintptr_t x, std::string whySafe);
    struct Imethod
    {
        golang::abi::NameOff Name;
        golang::abi::TypeOff Typ;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Imethod& value);
    struct ArrayType
    {
        Type* Elem;
        Type* Slice;
        uintptr_t Len;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ArrayType& value);
    struct ChanType
    {
        Type* Elem;
        golang::abi::ChanDir Dir;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct ChanType& value);
    struct structTypeUncommon
    {
        UncommonType u;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct structTypeUncommon& value);
    struct InterfaceType
    {
        /* Name PkgPath; [Known incomplete type] */
        gocpp::slice<Imethod> Methods;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct InterfaceType& value);
    struct MapType
    {
        Type* Key;
        Type* Elem;
        Type* Bucket;
        std::function<uintptr_t (unsafe::Pointer, uintptr_t)> Hasher;
        uint8_t KeySize;
        uint8_t ValueSize;
        uint16_t BucketSize;
        uint32_t Flags;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct MapType& value);
    struct SliceType
    {
        Type* Elem;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct SliceType& value);
    struct FuncType
    {
        uint16_t InCount;
        uint16_t OutCount;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct FuncType& value);
    struct PtrType
    {
        Type* Elem;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct PtrType& value);
    struct StructField
    {
        /* Name Name; [Known incomplete type] */
        Type* Typ;
        uintptr_t Offset;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructField& value);
    struct StructType
    {
        /* Name PkgPath; [Known incomplete type] */
        gocpp::slice<StructField> Fields;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct StructType& value);
    struct Name
    {
        unsigned char* Bytes;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Name& value);
    int writeVarint(gocpp::slice<unsigned char> buf, int n);
    struct Name NewName(std::string n, std::string tag, bool exported, bool embedded);

    namespace rec
    {
        std::string String(golang::abi::Kind k);
        abi::Kind Kind(struct Type* t);
        bool HasName(struct Type* t);
        bool Pointers(struct Type* t);
        bool IfaceIndir(struct Type* t);
        bool IsDirectIface(struct Type* t);
        gocpp::slice<unsigned char> GcSlice(struct Type* t, uintptr_t begin, uintptr_t end);
        gocpp::slice<Method> Methods(struct UncommonType* t);
        gocpp::slice<Method> ExportedMethods(struct UncommonType* t);
        int Len(struct Type* t);
        struct Type* Common(struct Type* t);
        abi::ChanDir ChanDir(struct Type* t);
        struct UncommonType* Uncommon(struct Type* t);
        struct Type* Elem(struct Type* t);
        struct StructType* StructType(struct Type* t);
        struct MapType* MapType(struct Type* t);
        struct ArrayType* ArrayType(struct Type* t);
        struct FuncType* FuncType(struct Type* t);
        struct InterfaceType* InterfaceType(struct Type* t);
        uintptr_t Size(struct Type* t);
        int Align(struct Type* t);
        int FieldAlign(struct Type* t);
        gocpp::slice<Method> ExportedMethods(struct Type* t);
        int NumMethod(struct Type* t);
        int NumMethod(struct InterfaceType* t);
        bool IndirectKey(struct MapType* mt);
        bool IndirectElem(struct MapType* mt);
        bool ReflexiveKey(struct MapType* mt);
        bool NeedKeyUpdate(struct MapType* mt);
        bool HashMightPanic(struct MapType* mt);
        struct Type* Key(struct Type* t);
        struct Type* In(struct FuncType* t, int i);
        int NumIn(struct FuncType* t);
        int NumOut(struct FuncType* t);
        struct Type* Out(struct FuncType* t, int i);
        gocpp::slice<Type*> InSlice(struct FuncType* t);
        gocpp::slice<Type*> OutSlice(struct FuncType* t);
        bool IsVariadic(struct FuncType* t);
        bool Embedded(struct StructField* f);
        unsigned char* DataChecked(struct Name n, int off, std::string whySafe);
        unsigned char* Data(struct Name n, int off);
        bool IsExported(struct Name n);
        bool HasTag(struct Name n);
        bool IsEmbedded(struct Name n);
        std::tuple<int, int> ReadVarint(struct Name n, int off);
        bool IsBlank(struct Name n);
        std::string Name(struct Name n);
        std::string Tag(struct Name n);
    }
}

