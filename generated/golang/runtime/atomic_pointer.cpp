// generated by GoCpp from file '$(ImportDir)/runtime/atomic_pointer.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/atomic_pointer.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goexperiment/exp_cgocheck2_off.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/cgocheck.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // atomicwb performs a write barrier before an atomic pointer write.
    // The caller should guard the call with "if writeBarrier.enabled".
    //
    //go:nosplit
    void atomicwb(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        auto slot = (uintptr_t*)(unsafe::Pointer(ptr));
        auto buf = rec::get2(gocpp::recv(rec::ptr(gocpp::recv(getg()->m->p))->wbBuf));
        buf[0] = *slot;
        buf[1] = uintptr_t(go_new);
    }

    // atomicstorep performs *ptr = new atomically and invokes a write barrier.
    //
    //go:nosplit
    void atomicstorep(unsafe::Pointer ptr, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb((unsafe::Pointer*)(ptr), go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite((unsafe::Pointer*)(ptr), go_new);
        }
        atomic::StorepNoWB(noescape(ptr), go_new);
    }

    // atomic_storePointer is the implementation of runtime/internal/UnsafePointer.Store
    // (like StoreNoWB but with the write barrier).
    //
    //go:nosplit
    //go:linkname atomic_storePointer runtime/internal/atomic.storePointer
    void atomic_storePointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        atomicstorep(unsafe::Pointer(ptr), go_new);
    }

    // atomic_casPointer is the implementation of runtime/internal/UnsafePointer.CompareAndSwap
    // (like CompareAndSwapNoWB but with the write barrier).
    //
    //go:nosplit
    //go:linkname atomic_casPointer runtime/internal/atomic.casPointer
    bool atomic_casPointer(unsafe::Pointer* ptr, unsafe::Pointer old, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        return atomic::Casp1(ptr, old, go_new);
    }

    //go:linkname sync_atomic_StoreUintptr sync/atomic.StoreUintptr
    void sync_atomic_StoreUintptr(uintptr_t* ptr, uintptr_t go_new)
    /* convertBlockStmt, nil block */;

    //go:linkname sync_atomic_StorePointer sync/atomic.StorePointer
    //go:nosplit
    void sync_atomic_StorePointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        sync_atomic_StoreUintptr((uintptr_t*)(unsafe::Pointer(ptr)), uintptr_t(go_new));
    }

    //go:linkname sync_atomic_SwapUintptr sync/atomic.SwapUintptr
    uintptr_t sync_atomic_SwapUintptr(uintptr_t* ptr, uintptr_t go_new)
    /* convertBlockStmt, nil block */;

    //go:linkname sync_atomic_SwapPointer sync/atomic.SwapPointer
    //go:nosplit
    unsafe::Pointer sync_atomic_SwapPointer(unsafe::Pointer* ptr, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        auto old = unsafe::Pointer(sync_atomic_SwapUintptr((uintptr_t*)(noescape(unsafe::Pointer(ptr))), uintptr_t(go_new)));
        return old;
    }

    //go:linkname sync_atomic_CompareAndSwapUintptr sync/atomic.CompareAndSwapUintptr
    bool sync_atomic_CompareAndSwapUintptr(uintptr_t* ptr, uintptr_t old, uintptr_t go_new)
    /* convertBlockStmt, nil block */;

    //go:linkname sync_atomic_CompareAndSwapPointer sync/atomic.CompareAndSwapPointer
    //go:nosplit
    bool sync_atomic_CompareAndSwapPointer(unsafe::Pointer* ptr, unsafe::Pointer old, unsafe::Pointer go_new)
    {
        if(writeBarrier.enabled)
        {
            atomicwb(ptr, go_new);
        }
        if(goexperiment::CgoCheck2)
        {
            cgoCheckPtrWrite(ptr, go_new);
        }
        return sync_atomic_CompareAndSwapUintptr((uintptr_t*)(noescape(unsafe::Pointer(ptr))), uintptr_t(old), uintptr_t(go_new));
    }

}

