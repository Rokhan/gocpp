// generated by GoCpp from file '$(ImportDir)/sync/atomic/value.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/atomic/value.h"
#include "gocpp/support.h"

#include "golang/sync/atomic/doc.h"
#include "golang/unsafe/unsafe.h"

namespace golang::atomic
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A Value provides an atomic load and store of a consistently typed value.
    // The zero value for a Value returns nil from Load.
    // Once Store has been called, a Value must not be copied.
    //
    // A Value must not be copied after first use.
    
    template<typename T> requires gocpp::GoStruct<T>
    Value::operator T()
    {
        T result;
        result.v = this->v;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Value::operator==(const T& ref) const
    {
        if (v != ref.v) return false;
        return true;
    }

    std::ostream& Value::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << v;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Value& value)
    {
        return value.PrintTo(os);
    }

    // efaceWords is interface{} internal representation.
    
    template<typename T> requires gocpp::GoStruct<T>
    efaceWords::operator T()
    {
        T result;
        result.typ = this->typ;
        result.data = this->data;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool efaceWords::operator==(const T& ref) const
    {
        if (typ != ref.typ) return false;
        if (data != ref.data) return false;
        return true;
    }

    std::ostream& efaceWords::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << data;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct efaceWords& value)
    {
        return value.PrintTo(os);
    }

    // Load returns the value set by the most recent Store.
    // It returns nil if there has been no call to Store for this Value.
    go_any rec::Load(struct Value* v)
    {
        go_any val;
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto typ = LoadPointer(& vp->typ);
        if(typ == nullptr || typ == unsafe::Pointer(& firstStoreInProgress))
        {
            return nullptr;
        }
        auto data = LoadPointer(& vp->data);
        auto vlp = (efaceWords*)(unsafe::Pointer(& val));
        vlp->typ = typ;
        vlp->data = data;
        return val;
    }

    unsigned char firstStoreInProgress;
    // Store sets the value of the Value v to val.
    // All calls to Store for a given Value must use values of the same concrete type.
    // Store of an inconsistent type panics, as does Store(nil).
    void rec::Store(struct Value* v, go_any val)
    {
        if(val == nullptr)
        {
            gocpp::panic("sync/atomic: store of nil value into Value"s);
        }
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto vlp = (efaceWords*)(unsafe::Pointer(& val));
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, unsafe::Pointer(& firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, vlp->data);
                StorePointer(& vp->typ, vlp->typ);
                runtime_procUnpin();
                return;
            }
            if(typ == unsafe::Pointer(& firstStoreInProgress))
            {
                continue;
            }
            if(typ != vlp->typ)
            {
                gocpp::panic("sync/atomic: store of inconsistently typed value into Value"s);
            }
            StorePointer(& vp->data, vlp->data);
            return;
        }
    }

    // Swap stores new into Value and returns the previous value. It returns nil if
    // the Value is empty.
    //
    // All calls to Swap for a given Value must use values of the same concrete
    // type. Swap of an inconsistent type panics, as does Swap(nil).
    go_any rec::Swap(struct Value* v, go_any go_new)
    {
        go_any old;
        if(go_new == nullptr)
        {
            gocpp::panic("sync/atomic: swap of nil value into Value"s);
        }
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto np = (efaceWords*)(unsafe::Pointer(& go_new));
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, unsafe::Pointer(& firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, np->data);
                StorePointer(& vp->typ, np->typ);
                runtime_procUnpin();
                return nullptr;
            }
            if(typ == unsafe::Pointer(& firstStoreInProgress))
            {
                continue;
            }
            if(typ != np->typ)
            {
                gocpp::panic("sync/atomic: swap of inconsistently typed value into Value"s);
            }
            auto op = (efaceWords*)(unsafe::Pointer(& old));
            std::tie(op->typ, op->data) = std::tuple{np->typ, SwapPointer(& vp->data, np->data)};
            return old;
        }
    }

    // CompareAndSwap executes the compare-and-swap operation for the Value.
    //
    // All calls to CompareAndSwap for a given Value must use values of the same
    // concrete type. CompareAndSwap of an inconsistent type panics, as does
    // CompareAndSwap(old, nil).
    bool rec::CompareAndSwap(struct Value* v, go_any old, go_any go_new)
    {
        bool swapped;
        if(go_new == nullptr)
        {
            gocpp::panic("sync/atomic: compare and swap of nil value into Value"s);
        }
        auto vp = (efaceWords*)(unsafe::Pointer(v));
        auto np = (efaceWords*)(unsafe::Pointer(& go_new));
        auto op = (efaceWords*)(unsafe::Pointer(& old));
        if(op->typ != nullptr && np->typ != op->typ)
        {
            gocpp::panic("sync/atomic: compare and swap of inconsistently typed values"s);
        }
        for(; ; )
        {
            auto typ = LoadPointer(& vp->typ);
            if(typ == nullptr)
            {
                if(old != nullptr)
                {
                    return false;
                }
                runtime_procPin();
                if(! CompareAndSwapPointer(& vp->typ, nullptr, unsafe::Pointer(& firstStoreInProgress)))
                {
                    runtime_procUnpin();
                    continue;
                }
                StorePointer(& vp->data, np->data);
                StorePointer(& vp->typ, np->typ);
                runtime_procUnpin();
                return true;
            }
            if(typ == unsafe::Pointer(& firstStoreInProgress))
            {
                continue;
            }
            if(typ != np->typ)
            {
                gocpp::panic("sync/atomic: compare and swap of inconsistently typed value into Value"s);
            }
            auto data = LoadPointer(& vp->data);
            go_any i = {};
            (efaceWords*)(unsafe::Pointer(& i))->typ = typ;
            (efaceWords*)(unsafe::Pointer(& i))->data = data;
            if(i != old)
            {
                return false;
            }
            return CompareAndSwapPointer(& vp->data, data, np->data);
        }
    }

    // Disable/enable preemption, implemented in runtime.
    int runtime_procPin()
    /* convertBlockStmt, nil block */;

    void runtime_procUnpin()
    /* convertBlockStmt, nil block */;

}

