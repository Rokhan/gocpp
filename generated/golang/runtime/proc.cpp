// generated by GoCpp from file '$(ImportDir)/runtime/proc.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/proc.h"
#include "gocpp/support.h"

#include "golang/internal/abi/funcpc.h"
#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/cpu/cpu.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goexperiment/exp_exectracer2_on.h"
#include "golang/internal/goos/zgoos_windows.h"
#include "golang/runtime/alg.h"
#include "golang/runtime/asan0.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/cpuprof.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/env_posix.h"
#include "golang/runtime/error.h"
#include "golang/runtime/exithook.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/fds_nonunix.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/iface.h"
#include "golang/runtime/internal/atomic/atomic_amd64.h"
#include "golang/runtime/internal/atomic/stubs.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lfstack.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mcentral.h"
#include "golang/runtime/mcheckmark.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mfixalloc.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcpacer.h"
#include "golang/runtime/mgcscavenge.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagealloc.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/msan0.h"
#include "golang/runtime/mspanset.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/netpoll.h"
#include "golang/runtime/netpoll_windows.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/preempt.h"
#include "golang/runtime/print.h"
#include "golang/runtime/profbuf.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/rand.h"
#include "golang/runtime/runtime.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/rwmutex.h"
#include "golang/runtime/security_nonunix.h"
#include "golang/runtime/sema.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/stkframe.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/sys_nonppc64x.h"
#include "golang/runtime/time.h"
#include "golang/runtime/time_nofake.h"
#include "golang/runtime/tls_windows_amd64.h"
#include "golang/runtime/trace2.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2cpu.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/traceback.h"
#include "golang/runtime/type.h"
#include "golang/runtime/vdso_in_none.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Add;
        using atomic::rec::CompareAndSwap;
        using atomic::rec::CompareAndSwapNoWB;
        using atomic::rec::Load;
        using atomic::rec::Store;
        using atomic::rec::Swap;
    }

    std::string modinfo;
    m m0;
    g g0;
    mcache* mcache0;
    uintptr_t raceprocctx0;
    mutex raceFiniLock;
    gocpp::slice<initTask*> runtime_inittasks;
    gocpp::channel<bool> main_init_done;
    void main_main()
    /* convertBlockStmt, nil block */;

    bool mainStarted;
    int64_t runtimeInitTime;
    sigset initSigmask;
    void main()
    {
        gocpp::Defer defer;
        try
        {
            auto mp = getg()->m;
            mp->g0->racectx = 0;
            if(goarch::PtrSize == 8)
            {
                maxstacksize = 1000000000;
            }
            else
            {
                maxstacksize = 250000000;
            }
            maxstackceiling = 2 * maxstacksize;
            mainStarted = true;
            if(GOARCH != "wasm")
            {
                systemstack([=]() mutable -> void
                {
                    newm(sysmon, nullptr, - 1);
                });
            }
            lockOSThread();
            if(mp != & m0)
            {
                go_throw("runtime.main not on m0");
            }
            runtimeInitTime = nanotime();
            if(runtimeInitTime == 0)
            {
                go_throw("nanotime returning zero");
            }
            if(debug.inittrace != 0)
            {
                inittrace.id = getg()->goid;
                inittrace.active = true;
            }
            doInit(runtime_inittasks);
            auto needUnlock = true;
            defer.push_back([=]{ [=]() mutable -> void
            {
                if(needUnlock)
                {
                    unlockOSThread();
                }
            }(); });
            gcenable();
            main_init_done = gocpp::make(gocpp::Tag<gocpp::channel<bool>>());
            if(iscgo)
            {
                if(_cgo_pthread_key_created == nullptr)
                {
                    go_throw("_cgo_pthread_key_created missing");
                }
                if(_cgo_thread_start == nullptr)
                {
                    go_throw("_cgo_thread_start missing");
                }
                if(GOOS != "windows")
                {
                    if(_cgo_setenv == nullptr)
                    {
                        go_throw("_cgo_setenv missing");
                    }
                    if(_cgo_unsetenv == nullptr)
                    {
                        go_throw("_cgo_unsetenv missing");
                    }
                }
                if(_cgo_notify_runtime_init_done == nullptr)
                {
                    go_throw("_cgo_notify_runtime_init_done missing");
                }
                if(set_crosscall2 == nullptr)
                {
                    go_throw("set_crosscall2 missing");
                }
                set_crosscall2();
                startTemplateThread();
                cgocall(_cgo_notify_runtime_init_done, nullptr);
            }
            for(auto m = & firstmoduledata; m != nullptr; m = m->next)
            {
                doInit(m->inittasks);
            }
            inittrace.active = false;
            close(main_init_done);
            needUnlock = false;
            unlockOSThread();
            if(isarchive || islibrary)
            {
                return;
            }
            auto fn = main_main;
            fn();
            if(raceenabled)
            {
                runExitHooks(0);
                racefini();
            }
            if(rec::Load(gocpp::recv(runningPanicDefers)) != 0)
            {
                for(auto c = 0; c < 1000; c++)
                {
                    if(rec::Load(gocpp::recv(runningPanicDefers)) == 0)
                    {
                        break;
                    }
                    Gosched();
                }
            }
            if(rec::Load(gocpp::recv(panicking)) != 0)
            {
                gopark(nullptr, nullptr, waitReasonPanicWait, traceBlockForever, 1);
            }
            runExitHooks(0);
            exit(0);
            for(; ; )
            {
                int32_t* x = {};
                *x = 0;
            }
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void os_beforeExit(int exitCode)
    {
        runExitHooks(exitCode);
        if(exitCode == 0 && raceenabled)
        {
            racefini();
        }
    }

    void init()
    {
        gocpp::go([&]{ forcegchelper(); });
    }

    void forcegchelper()
    {
        forcegc.g = getg();
        lockInit(& forcegc.lock, lockRankForcegc);
        for(; ; )
        {
            lock(& forcegc.lock);
            if(rec::Load(gocpp::recv(forcegc.idle)))
            {
                go_throw("forcegc: phase error");
            }
            rec::Store(gocpp::recv(forcegc.idle), true);
            goparkunlock(& forcegc.lock, waitReasonForceGCIdle, traceBlockSystemGoroutine, 1);
            if(debug.gctrace > 0)
            {
                println("GC forced");
            }
            gcStart(gocpp::Init<gcTrigger>([=](auto& x) {
                x.kind = gcTriggerTime;
                x.now = nanotime();
            }));
        }
    }

    void Gosched()
    {
        checkTimeouts();
        mcall(gosched_m);
    }

    void goschedguarded()
    {
        mcall(goschedguarded_m);
    }

    void goschedIfBusy()
    {
        auto gp = getg();
        if(! gp->preempt && rec::Load(gocpp::recv(sched.npidle)) > 0)
        {
            return;
        }
        mcall(gosched_m);
    }

    void gopark(std::function<bool (g*, unsafe::Pointer)> unlockf, unsafe::Pointer lock, golang::runtime::waitReason reason, golang::runtime::traceBlockReason traceReason, int traceskip)
    {
        if(reason != waitReasonSleep)
        {
            checkTimeouts();
        }
        auto mp = acquirem();
        auto gp = mp->curg;
        auto status = readgstatus(gp);
        if(status != _Grunning && status != _Gscanrunning)
        {
            go_throw("gopark: bad g status");
        }
        mp->waitlock = lock;
        mp->waitunlockf = unlockf;
        gp->waitreason = reason;
        mp->waitTraceBlockReason = traceReason;
        mp->waitTraceSkip = traceskip;
        releasem(mp);
        mcall(park_m);
    }

    void goparkunlock(struct mutex* lock, golang::runtime::waitReason reason, golang::runtime::traceBlockReason traceReason, int traceskip)
    {
        gopark(parkunlock_c, unsafe::Pointer(lock), reason, traceReason, traceskip);
    }

    void goready(struct g* gp, int traceskip)
    {
        systemstack([=]() mutable -> void
        {
            ready(gp, traceskip, true);
        });
    }

    struct sudog* acquireSudog()
    {
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(len(pp->sudogcache) == 0)
        {
            lock(& sched.sudoglock);
            for(; len(pp->sudogcache) < cap(pp->sudogcache) / 2 && sched.sudogcache != nullptr; )
            {
                auto s = sched.sudogcache;
                sched.sudogcache = s->next;
                s->next = nullptr;
                pp->sudogcache = append(pp->sudogcache, s);
            }
            unlock(& sched.sudoglock);
            if(len(pp->sudogcache) == 0)
            {
                pp->sudogcache = append(pp->sudogcache, new(sudog));
            }
        }
        auto n = len(pp->sudogcache);
        auto s = pp->sudogcache[n - 1];
        pp->sudogcache[n - 1] = nullptr;
        pp->sudogcache = pp->sudogcache.make_slice(0, n - 1);
        if(s->elem != nullptr)
        {
            go_throw("acquireSudog: found s.elem != nil in cache");
        }
        releasem(mp);
        return s;
    }

    void releaseSudog(struct sudog* s)
    {
        if(s->elem != nullptr)
        {
            go_throw("runtime: sudog with non-nil elem");
        }
        if(s->isSelect)
        {
            go_throw("runtime: sudog with non-false isSelect");
        }
        if(s->next != nullptr)
        {
            go_throw("runtime: sudog with non-nil next");
        }
        if(s->prev != nullptr)
        {
            go_throw("runtime: sudog with non-nil prev");
        }
        if(s->waitlink != nullptr)
        {
            go_throw("runtime: sudog with non-nil waitlink");
        }
        if(s->c != nullptr)
        {
            go_throw("runtime: sudog with non-nil c");
        }
        auto gp = getg();
        if(gp->param != nullptr)
        {
            go_throw("runtime: releaseSudog with non-nil gp.param");
        }
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(len(pp->sudogcache) == cap(pp->sudogcache))
        {
            sudog* first = {};
            sudog* last = {};
            for(; len(pp->sudogcache) > cap(pp->sudogcache) / 2; )
            {
                auto n = len(pp->sudogcache);
                auto p = pp->sudogcache[n - 1];
                pp->sudogcache[n - 1] = nullptr;
                pp->sudogcache = pp->sudogcache.make_slice(0, n - 1);
                if(first == nullptr)
                {
                    first = p;
                }
                else
                {
                    last->next = p;
                }
                last = p;
            }
            lock(& sched.sudoglock);
            last->next = sched.sudogcache;
            sched.sudogcache = first;
            unlock(& sched.sudoglock);
        }
        pp->sudogcache = append(pp->sudogcache, s);
        releasem(mp);
    }

    void badmcall(std::function<void (g*)> fn)
    {
        go_throw("runtime: mcall called on m->g0 stack");
    }

    void badmcall2(std::function<void (g*)> fn)
    {
        go_throw("runtime: mcall function returned");
    }

    void badreflectcall()
    {
        gocpp::panic(plainError("arg size to reflect.call more than 1GB"));
    }

    void badmorestackg0()
    {
        if(! crashStackImplemented)
        {
            writeErrStr("fatal: morestack on g0\n");
            return;
        }
        auto g = getg();
        switchToCrashStack([=]() mutable -> void
        {
            print("runtime: morestack on g0, stack [", hex(g->stack.lo), " ", hex(g->stack.hi), "], sp=", hex(g->sched.sp), ", called from\n");
            g->m->traceback = 2;
            traceback1(g->sched.pc, g->sched.sp, g->sched.lr, g, 0);
            print("\n");
            go_throw("morestack on g0");
        });
    }

    void badmorestackgsignal()
    {
        writeErrStr("fatal: morestack on gsignal\n");
    }

    void badctxt()
    {
        go_throw("ctxt != 0");
    }

    g gcrash;
    atomic::Pointer<g> crashingG;
    void switchToCrashStack(std::function<void ()> fn)
    {
        auto me = getg();
        if(rec::CompareAndSwapNoWB(gocpp::recv(crashingG), nullptr, me))
        {
            switchToCrashStack0(fn);
            abort();
        }
        if(rec::Load(gocpp::recv(crashingG)) == me)
        {
            writeErrStr("fatal: recursive switchToCrashStack\n");
            abort();
        }
        usleep_no_g(100);
        writeErrStr("fatal: concurrent switchToCrashStack\n");
        abort();
    }

    bool crashStackImplemented = (GOARCH == "amd64" || GOARCH == "arm64" || GOARCH == "mips64" || GOARCH == "mips64le" || GOARCH == "ppc64" || GOARCH == "ppc64le" || GOARCH == "riscv64" || GOARCH == "wasm") && GOOS != "windows";
    void switchToCrashStack0(std::function<void ()> fn)
    /* convertBlockStmt, nil block */;

    bool lockedOSThread()
    {
        auto gp = getg();
        return gp->lockedm != 0 && gp->m->lockedg != 0;
    }

    mutex allglock;
    gocpp::slice<g*> allgs;
    uintptr_t allglen;
    g** allgptr;
    void allgadd(struct g* gp)
    {
        if(readgstatus(gp) == _Gidle)
        {
            go_throw("allgadd: bad status Gidle");
        }
        lock(& allglock);
        allgs = append(allgs, gp);
        if(& allgs[0] != allgptr)
        {
            atomicstorep(unsafe::Pointer(& allgptr), unsafe::Pointer(& allgs[0]));
        }
        atomic::Storeuintptr(& allglen, uintptr_t(len(allgs)));
        unlock(& allglock);
    }

    gocpp::slice<g*> allGsSnapshot()
    {
        assertWorldStoppedOrLockHeld(& allglock);
        return allgs.make_slice(, len(allgs), len(allgs));
    }

    std::tuple<struct g**, uintptr_t> atomicAllG()
    {
        auto length = atomic::Loaduintptr(& allglen);
        auto ptr = (g**)(atomic::Loadp(unsafe::Pointer(& allgptr)));
        return {ptr, length};
    }

    struct g* atomicAllGIndex(struct g** ptr, uintptr_t i)
    {
        return *(g**)(add(unsafe::Pointer(ptr), i * goarch::PtrSize));
    }

    void forEachG(std::function<void (struct g* gp)> fn)
    {
        lock(& allglock);
        for(auto [gocpp_ignored, gp] : allgs)
        {
            fn(gp);
        }
        unlock(& allglock);
    }

    void forEachGRace(std::function<void (struct g* gp)> fn)
    {
        auto [ptr, length] = atomicAllG();
        for(auto i = uintptr_t(0); i < length; i++)
        {
            auto gp = atomicAllGIndex(ptr, i);
            fn(gp);
        }
        return;
    }

    void cpuinit(std::string env)
    {
        //Go switch emulation
        {
            auto condition = GOOS;
            int conditionId = -1;
            if(condition == "aix") { conditionId = 0; }
            else if(condition == "darwin") { conditionId = 1; }
            else if(condition == "ios") { conditionId = 2; }
            else if(condition == "dragonfly") { conditionId = 3; }
            else if(condition == "freebsd") { conditionId = 4; }
            else if(condition == "netbsd") { conditionId = 5; }
            else if(condition == "openbsd") { conditionId = 6; }
            else if(condition == "illumos") { conditionId = 7; }
            else if(condition == "solaris") { conditionId = 8; }
            else if(condition == "linux") { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    cpu::DebugOptions = true;
                    break;
            }
        }
        cpu::Initialize(env);
        //Go switch emulation
        {
            auto condition = GOARCH;
            int conditionId = -1;
            if(condition == "386") { conditionId = 0; }
            else if(condition == "amd64") { conditionId = 1; }
            else if(condition == "arm") { conditionId = 2; }
            else if(condition == "arm64") { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                case 1:
                    x86HasPOPCNT = cpu::X86.HasPOPCNT;
                    x86HasSSE41 = cpu::X86.HasSSE41;
                    x86HasFMA = cpu::X86.HasFMA;
                    break;
                case 2:
                    armHasVFPv4 = cpu::ARM.HasVFPv4;
                    break;
                case 3:
                    arm64HasATOMICS = cpu::ARM64.HasATOMICS;
                    break;
            }
        }
    }

    std::string getGodebugEarly()
    {
        auto prefix = "GODEBUG=";
        std::string env = {};
        //Go switch emulation
        {
            auto condition = GOOS;
            int conditionId = -1;
            if(condition == "aix") { conditionId = 0; }
            else if(condition == "darwin") { conditionId = 1; }
            else if(condition == "ios") { conditionId = 2; }
            else if(condition == "dragonfly") { conditionId = 3; }
            else if(condition == "freebsd") { conditionId = 4; }
            else if(condition == "netbsd") { conditionId = 5; }
            else if(condition == "openbsd") { conditionId = 6; }
            else if(condition == "illumos") { conditionId = 7; }
            else if(condition == "solaris") { conditionId = 8; }
            else if(condition == "linux") { conditionId = 9; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    auto n = int32_t(0);
                    for(; argv_index(argv, argc + 1 + n) != nullptr; )
                    {
                        n++;
                    }
                    for(auto i = int32_t(0); i < n; i++)
                    {
                        auto p = argv_index(argv, argc + 1 + i);
                        auto s = unsafe::String(p, findnull(p));
                        if(hasPrefix(s, prefix))
                        {
                            env = gostring(p).make_slice(len(prefix));
                            break;
                        }
                    }
                    break;
            }
        }
        return env;
    }

    void schedinit()
    {
        lockInit(& sched.lock, lockRankSched);
        lockInit(& sched.sysmonlock, lockRankSysmon);
        lockInit(& sched.deferlock, lockRankDefer);
        lockInit(& sched.sudoglock, lockRankSudog);
        lockInit(& deadlock, lockRankDeadlock);
        lockInit(& paniclk, lockRankPanic);
        lockInit(& allglock, lockRankAllg);
        lockInit(& allpLock, lockRankAllp);
        lockInit(& reflectOffs.lock, lockRankReflectOffs);
        lockInit(& finlock, lockRankFin);
        lockInit(& cpuprof.lock, lockRankCpuprof);
        rec::init(gocpp::recv(allocmLock), lockRankAllocmR, lockRankAllocmRInternal, lockRankAllocmW);
        rec::init(gocpp::recv(execLock), lockRankExecR, lockRankExecRInternal, lockRankExecW);
        traceLockInit();
        lockInit(& memstats.heapStats.noPLock, lockRankLeafRank);
        auto gp = getg();
        if(raceenabled)
        {
            std::tie(gp->racectx, raceprocctx0) = raceinit();
        }
        sched.maxmcount = 10000;
        worldStopped();
        rec::init(gocpp::recv(ticks));
        moduledataverify();
        stackinit();
        mallocinit();
        auto godebug = getGodebugEarly();
        initPageTrace(godebug);
        cpuinit(godebug);
        randinit();
        alginit();
        mcommoninit(gp->m, - 1);
        modulesinit();
        typelinksinit();
        itabsinit();
        stkobjinit();
        sigsave(& gp->m->sigmask);
        initSigmask = gp->m->sigmask;
        goargs();
        goenvs();
        secure();
        checkfds();
        parsedebugvars();
        gcinit();
        gcrash.stack = stackalloc(16384);
        gcrash.stackguard0 = gcrash.stack.lo + 1000;
        gcrash.stackguard1 = gcrash.stack.lo + 1000;
        if(disableMemoryProfiling)
        {
            MemProfileRate = 0;
        }
        lock(& sched.lock);
        rec::Store(gocpp::recv(sched.lastpoll), nanotime());
        auto procs = ncpu;
        if(auto [n, ok] = atoi32(gogetenv("GOMAXPROCS")); ok && n > 0)
        {
            procs = n;
        }
        if(procresize(procs) != nullptr)
        {
            go_throw("unknown runnable goroutine during bootstrap");
        }
        unlock(& sched.lock);
        worldStarted();
        if(buildVersion == "")
        {
            buildVersion = "unknown";
        }
        if(len(modinfo) == 1)
        {
            modinfo = "";
        }
    }

    void dumpgstatus(struct g* gp)
    {
        auto thisg = getg();
        print("runtime:   gp: gp=", gp, ", goid=", gp->goid, ", gp->atomicstatus=", readgstatus(gp), "\n");
        print("runtime: getg:  g=", thisg, ", goid=", thisg->goid, ",  g->atomicstatus=", readgstatus(thisg), "\n");
    }

    void checkmcount()
    {
        assertLockHeld(& sched.lock);
        auto count = mcount() - int32_t(rec::Load(gocpp::recv(extraMInUse))) - int32_t(rec::Load(gocpp::recv(extraMLength)));
        if(count > sched.maxmcount)
        {
            print("runtime: program exceeds ", sched.maxmcount, "-thread limit\n");
            go_throw("thread exhaustion");
        }
    }

    int64_t mReserveID()
    {
        assertLockHeld(& sched.lock);
        if(sched.mnext + 1 < sched.mnext)
        {
            go_throw("runtime: thread ID overflow");
        }
        auto id = sched.mnext;
        sched.mnext++;
        checkmcount();
        return id;
    }

    void mcommoninit(struct m* mp, int64_t id)
    {
        auto gp = getg();
        if(gp != gp->m->g0)
        {
            callers(1, mp->createstack.make_slice(0));
        }
        lock(& sched.lock);
        if(id >= 0)
        {
            mp->id = id;
        }
        else
        {
            mp->id = mReserveID();
        }
        mrandinit(mp);
        mpreinit(mp);
        if(mp->gsignal != nullptr)
        {
            mp->gsignal->stackguard1 = mp->gsignal->stack.lo + stackGuard;
        }
        mp->alllink = allm;
        atomicstorep(unsafe::Pointer(& allm), unsafe::Pointer(mp));
        unlock(& sched.lock);
        if(iscgo || GOOS == "solaris" || GOOS == "illumos" || GOOS == "windows")
        {
            mp->cgoCallers = new(cgoCallers);
        }
    }

    void rec::becomeSpinning(struct m* mp)
    {
        mp->spinning = true;
        rec::Add(gocpp::recv(sched.nmspinning), 1);
        rec::Store(gocpp::recv(sched.needspinning), 0);
    }

    bool rec::hasCgoOnStack(struct m* mp)
    {
        return mp->ncgo > 0 || mp->isextra;
    }

    bool osHasLowResTimer = GOOS == "windows" || GOOS == "openbsd" || GOOS == "netbsd";
    void ready(struct g* gp, int traceskip, bool next)
    {
        auto status = readgstatus(gp);
        auto mp = acquirem();
        if(status &^ _Gscan != _Gwaiting)
        {
            dumpgstatus(gp);
            go_throw("bad g->status in ready");
        }
        auto trace = traceAcquire();
        casgstatus(gp, _Gwaiting, _Grunnable);
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoUnpark(gocpp::recv(trace), gp, traceskip);
            traceRelease(trace);
        }
        runqput(rec::ptr(gocpp::recv(mp->p)), gp, next);
        wakep();
        releasem(mp);
    }

    atomic::Bool freezing;
    void freezetheworld()
    {
        rec::Store(gocpp::recv(freezing), true);
        if(debug.dontfreezetheworld > 0)
        {
            usleep(1000);
            return;
        }
        for(auto i = 0; i < 5; i++)
        {
            sched.stopwait = freezeStopWait;
            rec::Store(gocpp::recv(sched.gcwaiting), true);
            if(! preemptall())
            {
                break;
            }
            usleep(1000);
        }
        usleep(1000);
        preemptall();
        usleep(1000);
    }

    uint32_t readgstatus(struct g* gp)
    {
        return rec::Load(gocpp::recv(gp->atomicstatus));
    }

    void casfrom_Gscanstatus(struct g* gp, uint32_t oldval, uint32_t newval)
    {
        auto success = false;
        //Go switch emulation
        {
            auto condition = oldval;
            int conditionId = -1;
            if(condition == _Gscanrunnable) { conditionId = 0; }
            else if(condition == _Gscanwaiting) { conditionId = 1; }
            else if(condition == _Gscanrunning) { conditionId = 2; }
            else if(condition == _Gscansyscall) { conditionId = 3; }
            else if(condition == _Gscanpreempted) { conditionId = 4; }
            switch(conditionId)
            {
                default:
                    print("runtime: casfrom_Gscanstatus bad oldval gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n");
                    dumpgstatus(gp);
                    go_throw("casfrom_Gscanstatus:top gp->status is not in scan state");
                    break;
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    if(newval == oldval &^ _Gscan)
                    {
                        success = rec::CompareAndSwap(gocpp::recv(gp->atomicstatus), oldval, newval);
                    }
                    break;
            }
        }
        if(! success)
        {
            print("runtime: casfrom_Gscanstatus failed gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n");
            dumpgstatus(gp);
            go_throw("casfrom_Gscanstatus: gp->status is not in scan state");
        }
        releaseLockRank(lockRankGscan);
    }

    bool castogscanstatus(struct g* gp, uint32_t oldval, uint32_t newval)
    {
        //Go switch emulation
        {
            auto condition = oldval;
            int conditionId = -1;
            if(condition == _Grunnable) { conditionId = 0; }
            else if(condition == _Grunning) { conditionId = 1; }
            else if(condition == _Gwaiting) { conditionId = 2; }
            else if(condition == _Gsyscall) { conditionId = 3; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                    if(newval == oldval | _Gscan)
                    {
                        auto r = rec::CompareAndSwap(gocpp::recv(gp->atomicstatus), oldval, newval);
                        if(r)
                        {
                            acquireLockRank(lockRankGscan);
                        }
                        return r;
                    }
                    break;
            }
        }
        print("runtime: castogscanstatus oldval=", hex(oldval), " newval=", hex(newval), "\n");
        go_throw("castogscanstatus");
        gocpp::panic("not reached");
    }

    bool casgstatusAlwaysTrack = false;
    void casgstatus(struct g* gp, uint32_t oldval, uint32_t newval)
    {
        if((oldval & _Gscan != 0) || (newval & _Gscan != 0) || oldval == newval)
        {
            systemstack([=]() mutable -> void
            {
                print("runtime: casgstatus: oldval=", hex(oldval), " newval=", hex(newval), "\n");
                go_throw("casgstatus: bad incoming values");
            });
        }
        acquireLockRank(lockRankGscan);
        releaseLockRank(lockRankGscan);
        auto yieldDelay = 5 * 1000;
        int64_t nextYield = {};
        for(auto i = 0; ! rec::CompareAndSwap(gocpp::recv(gp->atomicstatus), oldval, newval); i++)
        {
            if(oldval == _Gwaiting && rec::Load(gocpp::recv(gp->atomicstatus)) == _Grunnable)
            {
                go_throw("casgstatus: waiting for Gwaiting but is Grunnable");
            }
            if(i == 0)
            {
                nextYield = nanotime() + yieldDelay;
            }
            if(nanotime() < nextYield)
            {
                for(auto x = 0; x < 10 && rec::Load(gocpp::recv(gp->atomicstatus)) != oldval; x++)
                {
                    procyield(1);
                }
            }
            else
            {
                osyield();
                nextYield = nanotime() + yieldDelay / 2;
            }
        }
        if(oldval == _Grunning)
        {
            if(casgstatusAlwaysTrack || gp->trackingSeq % gTrackingPeriod == 0)
            {
                gp->tracking = true;
            }
            gp->trackingSeq++;
        }
        if(! gp->tracking)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = oldval;
            int conditionId = -1;
            if(condition == _Grunnable) { conditionId = 0; }
            else if(condition == _Gwaiting) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    auto now = nanotime();
                    gp->runnableTime += now - gp->trackingStamp;
                    gp->trackingStamp = 0;
                    break;
                case 1:
                    if(! rec::isMutexWait(gocpp::recv(gp->waitreason)))
                    {
                        break;
                    }
                    auto now = nanotime();
                    rec::Add(gocpp::recv(sched.totalMutexWaitTime), (now - gp->trackingStamp) * gTrackingPeriod);
                    gp->trackingStamp = 0;
                    break;
            }
        }
        //Go switch emulation
        {
            auto condition = newval;
            int conditionId = -1;
            if(condition == _Gwaiting) { conditionId = 0; }
            else if(condition == _Grunnable) { conditionId = 1; }
            else if(condition == _Grunning) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    if(! rec::isMutexWait(gocpp::recv(gp->waitreason)))
                    {
                        break;
                    }
                    auto now = nanotime();
                    gp->trackingStamp = now;
                    break;
                case 1:
                    auto now = nanotime();
                    gp->trackingStamp = now;
                    break;
                case 2:
                    gp->tracking = false;
                    rec::record(gocpp::recv(sched.timeToRun), gp->runnableTime);
                    gp->runnableTime = 0;
                    break;
            }
        }
    }

    void casGToWaiting(struct g* gp, uint32_t old, golang::runtime::waitReason reason)
    {
        gp->waitreason = reason;
        casgstatus(gp, old, _Gwaiting);
    }

    uint32_t casgcopystack(struct g* gp)
    {
        for(; ; )
        {
            auto oldstatus = readgstatus(gp) &^ _Gscan;
            if(oldstatus != _Gwaiting && oldstatus != _Grunnable)
            {
                go_throw("copystack: bad status, not Gwaiting or Grunnable");
            }
            if(rec::CompareAndSwap(gocpp::recv(gp->atomicstatus), oldstatus, _Gcopystack))
            {
                return oldstatus;
            }
        }
    }

    void casGToPreemptScan(struct g* gp, uint32_t old, uint32_t go_new)
    {
        if(old != _Grunning || go_new != _Gscan | _Gpreempted)
        {
            go_throw("bad g transition");
        }
        acquireLockRank(lockRankGscan);
        for(; ! rec::CompareAndSwap(gocpp::recv(gp->atomicstatus), _Grunning, _Gscan | _Gpreempted); )
        {
        }
    }

    bool casGFromPreempted(struct g* gp, uint32_t old, uint32_t go_new)
    {
        if(old != _Gpreempted || go_new != _Gwaiting)
        {
            go_throw("bad g transition");
        }
        gp->waitreason = waitReasonPreempted;
        return rec::CompareAndSwap(gocpp::recv(gp->atomicstatus), _Gpreempted, _Gwaiting);
    }

    std::string rec::String(golang::runtime::stwReason r)
    {
        return stwReasonStrings[r];
    }

    bool rec::isGC(golang::runtime::stwReason r)
    {
        return r == stwGCMarkTerm || r == stwGCSweepTerm;
    }

    gocpp::array<std::string, 17> stwReasonStrings = gocpp::Init<gocpp::array<std::string, 17>>([](auto& x) {
        x[stwUnknown] = "unknown";
        x[stwGCMarkTerm] = "GC mark termination";
        x[stwGCSweepTerm] = "GC sweep termination";
        x[stwWriteHeapDump] = "write heap dump";
        x[stwGoroutineProfile] = "goroutine profile";
        x[stwGoroutineProfileCleanup] = "goroutine profile cleanup";
        x[stwAllGoroutinesStack] = "all goroutines stack trace";
        x[stwReadMemStats] = "read mem stats";
        x[stwAllThreadsSyscall] = "AllThreadsSyscall";
        x[stwGOMAXPROCS] = "GOMAXPROCS";
        x[stwStartTrace] = "start trace";
        x[stwStopTrace] = "stop trace";
        x[stwForTestCountPagesInUse] = "CountPagesInUse (test)";
        x[stwForTestReadMetricsSlow] = "ReadMetricsSlow (test)";
        x[stwForTestReadMemStatsSlow] = "ReadMemStatsSlow (test)";
        x[stwForTestPageCachePagesLeaked] = "PageCachePagesLeaked (test)";
        x[stwForTestResetDebugLog] = "ResetDebugLog (test)";
    });
    
    template<typename T> requires gocpp::GoStruct<T>
    worldStop::operator T()
    {
        T result;
        result.reason = this->reason;
        result.start = this->start;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool worldStop::operator==(const T& ref) const
    {
        if (reason != ref.reason) return false;
        if (start != ref.start) return false;
        return true;
    }

    std::ostream& worldStop::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << reason;
        os << " " << start;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct worldStop& value)
    {
        return value.PrintTo(os);
    }

    worldStop stopTheWorldContext;
    struct worldStop stopTheWorld(golang::runtime::stwReason reason)
    {
        semacquire(& worldsema);
        auto gp = getg();
        gp->m->preemptoff = rec::String(gocpp::recv(reason));
        systemstack([=]() mutable -> void
        {
            casGToWaiting(gp, _Grunning, waitReasonStoppingTheWorld);
            stopTheWorldContext = stopTheWorldWithSema(reason);
            casgstatus(gp, _Gwaiting, _Grunning);
        });
        return stopTheWorldContext;
    }

    void startTheWorld(struct worldStop w)
    {
        systemstack([=]() mutable -> void
        {
            startTheWorldWithSema(0, w);
        });
        auto mp = acquirem();
        mp->preemptoff = "";
        semrelease1(& worldsema, true, 0);
        releasem(mp);
    }

    struct worldStop stopTheWorldGC(golang::runtime::stwReason reason)
    {
        semacquire(& gcsema);
        return stopTheWorld(reason);
    }

    void startTheWorldGC(struct worldStop w)
    {
        startTheWorld(w);
        semrelease(& gcsema);
    }

    uint32_t worldsema = 1;
    uint32_t gcsema = 1;
    struct worldStop stopTheWorldWithSema(golang::runtime::stwReason reason)
    {
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::STWStart(gocpp::recv(trace), reason);
            traceRelease(trace);
        }
        auto gp = getg();
        if(gp->m->locks > 0)
        {
            go_throw("stopTheWorld: holding locks");
        }
        lock(& sched.lock);
        auto start = nanotime();
        sched.stopwait = gomaxprocs;
        rec::Store(gocpp::recv(sched.gcwaiting), true);
        preemptall();
        rec::ptr(gocpp::recv(gp->m->p))->status = _Pgcstop;
        sched.stopwait--;
        trace = traceAcquire();
        for(auto [gocpp_ignored, pp] : allp)
        {
            auto s = pp->status;
            if(s == _Psyscall && atomic::Cas(& pp->status, s, _Pgcstop))
            {
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoSysBlock(gocpp::recv(trace), pp);
                    rec::ProcSteal(gocpp::recv(trace), pp, false);
                }
                pp->syscalltick++;
                sched.stopwait--;
            }
        }
        if(rec::ok(gocpp::recv(trace)))
        {
            traceRelease(trace);
        }
        auto now = nanotime();
        for(; ; )
        {
            auto [pp, gocpp_id_1] = pidleget(now);
            if(pp == nullptr)
            {
                break;
            }
            pp->status = _Pgcstop;
            sched.stopwait--;
        }
        auto wait = sched.stopwait > 0;
        unlock(& sched.lock);
        if(wait)
        {
            for(; ; )
            {
                if(notetsleep(& sched.stopnote, 100 * 1000))
                {
                    noteclear(& sched.stopnote);
                    break;
                }
                preemptall();
            }
        }
        auto startTime = nanotime() - start;
        if(rec::isGC(gocpp::recv(reason)))
        {
            rec::record(gocpp::recv(sched.stwStoppingTimeGC), startTime);
        }
        else
        {
            rec::record(gocpp::recv(sched.stwStoppingTimeOther), startTime);
        }
        auto bad = "";
        if(sched.stopwait != 0)
        {
            bad = "stopTheWorld: not stopped (stopwait != 0)";
        }
        else
        {
            for(auto [gocpp_ignored, pp] : allp)
            {
                if(pp->status != _Pgcstop)
                {
                    bad = "stopTheWorld: not stopped (status != _Pgcstop)";
                }
            }
        }
        if(rec::Load(gocpp::recv(freezing)))
        {
            lock(& deadlock);
            lock(& deadlock);
        }
        if(bad != "")
        {
            go_throw(bad);
        }
        worldStopped();
        return gocpp::Init<worldStop>([=](auto& x) {
            x.reason = reason;
            x.start = start;
        });
    }

    int64_t startTheWorldWithSema(int64_t now, struct worldStop w)
    {
        assertWorldStopped();
        auto mp = acquirem();
        if(netpollinited())
        {
            auto [list, delta] = netpoll(0);
            injectglist(& list);
            netpollAdjustWaiters(delta);
        }
        lock(& sched.lock);
        auto procs = gomaxprocs;
        if(newprocs != 0)
        {
            procs = newprocs;
            newprocs = 0;
        }
        auto p1 = procresize(procs);
        rec::Store(gocpp::recv(sched.gcwaiting), false);
        if(rec::Load(gocpp::recv(sched.sysmonwait)))
        {
            rec::Store(gocpp::recv(sched.sysmonwait), false);
            notewakeup(& sched.sysmonnote);
        }
        unlock(& sched.lock);
        worldStarted();
        for(; p1 != nullptr; )
        {
            auto p = p1;
            p1 = rec::ptr(gocpp::recv(p1->link));
            if(p->m != 0)
            {
                auto mp = rec::ptr(gocpp::recv(p->m));
                p->m = 0;
                if(mp->nextp != 0)
                {
                    go_throw("startTheWorld: inconsistent mp->nextp");
                }
                rec::set(gocpp::recv(mp->nextp), p);
                notewakeup(& mp->park);
            }
            else
            {
                newm(nullptr, p, - 1);
            }
        }
        if(now == 0)
        {
            now = nanotime();
        }
        auto totalTime = now - w.start;
        if(rec::isGC(gocpp::recv(w.reason)))
        {
            rec::record(gocpp::recv(sched.stwTotalTimeGC), totalTime);
        }
        else
        {
            rec::record(gocpp::recv(sched.stwTotalTimeOther), totalTime);
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::STWDone(gocpp::recv(trace));
            traceRelease(trace);
        }
        wakep();
        releasem(mp);
        return now;
    }

    bool usesLibcall()
    {
        //Go switch emulation
        {
            auto condition = GOOS;
            int conditionId = -1;
            if(condition == "aix") { conditionId = 0; }
            else if(condition == "darwin") { conditionId = 1; }
            else if(condition == "illumos") { conditionId = 2; }
            else if(condition == "ios") { conditionId = 3; }
            else if(condition == "solaris") { conditionId = 4; }
            else if(condition == "windows") { conditionId = 5; }
            else if(condition == "openbsd") { conditionId = 6; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    return true;
                    break;
                case 6:
                    return GOARCH != "mips64";
                    break;
            }
        }
        return false;
    }

    bool mStackIsSystemAllocated()
    {
        //Go switch emulation
        {
            auto condition = GOOS;
            int conditionId = -1;
            if(condition == "aix") { conditionId = 0; }
            else if(condition == "darwin") { conditionId = 1; }
            else if(condition == "plan9") { conditionId = 2; }
            else if(condition == "illumos") { conditionId = 3; }
            else if(condition == "ios") { conditionId = 4; }
            else if(condition == "solaris") { conditionId = 5; }
            else if(condition == "windows") { conditionId = 6; }
            else if(condition == "openbsd") { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    return true;
                    break;
                case 7:
                    return GOARCH != "mips64";
                    break;
            }
        }
        return false;
    }

    void mstart()
    /* convertBlockStmt, nil block */;

    void mstart0()
    {
        auto gp = getg();
        auto osStack = gp->stack.lo == 0;
        if(osStack)
        {
            auto size = gp->stack.hi;
            if(size == 0)
            {
                size = 16384 * sys::StackGuardMultiplier;
            }
            gp->stack.hi = uintptr_t(noescape(unsafe::Pointer(& size)));
            gp->stack.lo = gp->stack.hi - size + 1024;
        }
        gp->stackguard0 = gp->stack.lo + stackGuard;
        gp->stackguard1 = gp->stackguard0;
        mstart1();
        if(mStackIsSystemAllocated())
        {
            osStack = true;
        }
        mexit(osStack);
    }

    void mstart1()
    {
        auto gp = getg();
        if(gp != gp->m->g0)
        {
            go_throw("bad runtimeÂ·mstart");
        }
        gp->sched.g = guintptr(unsafe::Pointer(gp));
        gp->sched.pc = getcallerpc();
        gp->sched.sp = getcallersp();
        asminit();
        minit();
        if(gp->m == & m0)
        {
            mstartm0();
        }
        if(auto fn = gp->m->mstartfn; fn != nullptr)
        {
            fn();
        }
        if(gp->m != & m0)
        {
            acquirep(rec::ptr(gocpp::recv(gp->m->nextp)));
            gp->m->nextp = 0;
        }
        schedule();
    }

    void mstartm0()
    {
        if((iscgo || GOOS == "windows") && ! cgoHasExtraM)
        {
            cgoHasExtraM = true;
            newextram();
        }
        initsig(false);
    }

    void mPark()
    {
        auto gp = getg();
        notesleep(& gp->m->park);
        noteclear(& gp->m->park);
    }

    void mexit(bool osStack)
    {
        auto mp = getg()->m;
        if(mp == & m0)
        {
            handoffp(releasep());
            lock(& sched.lock);
            sched.nmfreed++;
            checkdead();
            unlock(& sched.lock);
            mPark();
            go_throw("locked m0 woke up");
        }
        sigblock(true);
        unminit();
        if(mp->gsignal != nullptr)
        {
            stackfree(mp->gsignal->stack);
            mp->gsignal = nullptr;
        }
        lock(& sched.lock);
        for(auto pprev = & allm; *pprev != nullptr; pprev = & (*pprev)->alllink)
        {
            if(*pprev == mp)
            {
                *pprev = mp->alllink;
                goto found;
            }
        }
        go_throw("m not found in allm");
        found:
        rec::Store(gocpp::recv(mp->freeWait), freeMWait);
        mp->freelink = sched.freem;
        sched.freem = mp;
        unlock(& sched.lock);
        atomic::Xadd64(& ncgocall, int64_t(mp->ncgocall));
        rec::Add(gocpp::recv(sched.totalRuntimeLockWaitTime), rec::Load(gocpp::recv(mp->mLockProfile.waitTime)));
        handoffp(releasep());
        lock(& sched.lock);
        sched.nmfreed++;
        checkdead();
        unlock(& sched.lock);
        if(GOOS == "darwin" || GOOS == "ios")
        {
            if(rec::Load(gocpp::recv(mp->signalPending)) != 0)
            {
                rec::Add(gocpp::recv(pendingPreemptSignals), - 1);
            }
        }
        mdestroy(mp);
        if(osStack)
        {
            rec::Store(gocpp::recv(mp->freeWait), freeMRef);
            return;
        }
        exitThread(& mp->freeWait);
    }

    void forEachP(golang::runtime::waitReason reason, std::function<void (p*)> fn)
    {
        systemstack([=]() mutable -> void
        {
            auto gp = getg()->m->curg;
            casGToWaiting(gp, _Grunning, reason);
            forEachPInternal(fn);
            casgstatus(gp, _Gwaiting, _Grunning);
        });
    }

    void forEachPInternal(std::function<void (p*)> fn)
    {
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(getg()->m->p));
        lock(& sched.lock);
        if(sched.safePointWait != 0)
        {
            go_throw("forEachP: sched.safePointWait != 0");
        }
        sched.safePointWait = gomaxprocs - 1;
        sched.safePointFn = fn;
        for(auto [gocpp_ignored, p2] : allp)
        {
            if(p2 != pp)
            {
                atomic::Store(& p2->runSafePointFn, 1);
            }
        }
        preemptall();
        for(auto p = rec::ptr(gocpp::recv(sched.pidle)); p != nullptr; p = rec::ptr(gocpp::recv(p->link)))
        {
            if(atomic::Cas(& p->runSafePointFn, 1, 0))
            {
                fn(p);
                sched.safePointWait--;
            }
        }
        auto wait = sched.safePointWait > 0;
        unlock(& sched.lock);
        fn(pp);
        for(auto [gocpp_ignored, p2] : allp)
        {
            auto s = p2->status;
            auto trace = traceAcquire();
            if(s == _Psyscall && p2->runSafePointFn == 1 && atomic::Cas(& p2->status, s, _Pidle))
            {
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoSysBlock(gocpp::recv(trace), p2);
                    rec::ProcSteal(gocpp::recv(trace), p2, false);
                    traceRelease(trace);
                }
                p2->syscalltick++;
                handoffp(p2);
            }
            else
            if(rec::ok(gocpp::recv(trace)))
            {
                traceRelease(trace);
            }
        }
        if(wait)
        {
            for(; ; )
            {
                if(notetsleep(& sched.safePointNote, 100 * 1000))
                {
                    noteclear(& sched.safePointNote);
                    break;
                }
                preemptall();
            }
        }
        if(sched.safePointWait != 0)
        {
            go_throw("forEachP: not done");
        }
        for(auto [gocpp_ignored, p2] : allp)
        {
            if(p2->runSafePointFn != 0)
            {
                go_throw("forEachP: P did not run fn");
            }
        }
        lock(& sched.lock);
        sched.safePointFn = nullptr;
        unlock(& sched.lock);
        releasem(mp);
    }

    void runSafePointFn()
    {
        auto p = rec::ptr(gocpp::recv(getg()->m->p));
        if(! atomic::Cas(& p->runSafePointFn, 1, 0))
        {
            return;
        }
        rec::safePointFn(gocpp::recv(sched), p);
        lock(& sched.lock);
        sched.safePointWait--;
        if(sched.safePointWait == 0)
        {
            notewakeup(& sched.safePointNote);
        }
        unlock(& sched.lock);
    }

    unsafe::Pointer cgoThreadStart;
    
    template<typename T> requires gocpp::GoStruct<T>
    cgothreadstart::operator T()
    {
        T result;
        result.g = this->g;
        result.tls = this->tls;
        result.fn = this->fn;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool cgothreadstart::operator==(const T& ref) const
    {
        if (g != ref.g) return false;
        if (tls != ref.tls) return false;
        if (fn != ref.fn) return false;
        return true;
    }

    std::ostream& cgothreadstart::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << g;
        os << " " << tls;
        os << " " << fn;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cgothreadstart& value)
    {
        return value.PrintTo(os);
    }

    struct m* allocm(struct p* pp, std::function<void ()> fn, int64_t id)
    {
        rec::rlock(gocpp::recv(allocmLock));
        acquirem();
        auto gp = getg();
        if(gp->m->p == 0)
        {
            acquirep(pp);
        }
        if(sched.freem != nullptr)
        {
            lock(& sched.lock);
            m* newList = {};
            for(auto freem = sched.freem; freem != nullptr; )
            {
                auto wait = rec::Load(gocpp::recv(freem->freeWait));
                if(wait == freeMWait)
                {
                    auto next = freem->freelink;
                    freem->freelink = newList;
                    newList = freem;
                    freem = next;
                    continue;
                }
                if(traceEnabled() || traceShuttingDown())
                {
                    traceThreadDestroy(freem);
                }
                if(wait == freeMStack)
                {
                    systemstack([=]() mutable -> void
                    {
                        stackfree(freem->g0->stack);
                    });
                }
                freem = freem->freelink;
            }
            sched.freem = newList;
            unlock(& sched.lock);
        }
        auto mp = new(m);
        mp->mstartfn = fn;
        mcommoninit(mp, id);
        if(iscgo || mStackIsSystemAllocated())
        {
            mp->g0 = malg(- 1);
        }
        else
        {
            mp->g0 = malg(16384 * sys::StackGuardMultiplier);
        }
        mp->g0->m = mp;
        if(pp == rec::ptr(gocpp::recv(gp->m->p)))
        {
            releasep();
        }
        releasem(gp->m);
        rec::runlock(gocpp::recv(allocmLock));
        return mp;
    }

    void needm(bool signal)
    {
        if((iscgo || GOOS == "windows") && ! cgoHasExtraM)
        {
            writeErrStr("fatal error: cgo callback before cgo call\n");
            exit(1);
        }
        sigset sigmask = {};
        sigsave(& sigmask);
        sigblock(false);
        auto [mp, last] = getExtraM();
        mp->needextram = last;
        mp->sigmask = sigmask;
        osSetupTLS(mp);
        setg(mp->g0);
        auto sp = getcallersp();
        callbackUpdateSystemStack(mp, sp, signal);
        mp->isExtraInC = false;
        asminit();
        minit();
        traceLocker trace = {};
        if(goexperiment::ExecTracer2 && ! signal)
        {
            trace = traceAcquire();
        }
        casgstatus(mp->curg, _Gdead, _Gsyscall);
        rec::Add(gocpp::recv(sched.ngsys), - 1);
        if(goexperiment::ExecTracer2 && ! signal)
        {
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::GoCreateSyscall(gocpp::recv(trace), mp->curg);
                traceRelease(trace);
            }
        }
        mp->isExtraInSig = signal;
    }

    void needAndBindM()
    {
        needm(false);
        if(_cgo_pthread_key_created != nullptr && *(uintptr_t*)(_cgo_pthread_key_created) != 0)
        {
            cgoBindM();
        }
    }

    void newextram()
    {
        auto c = rec::Swap(gocpp::recv(extraMWaiters), 0);
        if(c > 0)
        {
            for(auto i = uint32_t(0); i < c; i++)
            {
                oneNewExtraM();
            }
        }
        else
        if(rec::Load(gocpp::recv(extraMLength)) == 0)
        {
            oneNewExtraM();
        }
    }

    void oneNewExtraM()
    {
        auto mp = allocm(nullptr, nullptr, - 1);
        auto gp = malg(4096);
        gp->sched.pc = abi::FuncPCABI0(goexit) + sys::PCQuantum;
        gp->sched.sp = gp->stack.hi;
        gp->sched.sp -= 4 * goarch::PtrSize;
        gp->sched.lr = 0;
        gp->sched.g = guintptr(unsafe::Pointer(gp));
        gp->syscallpc = gp->sched.pc;
        gp->syscallsp = gp->sched.sp;
        gp->stktopsp = gp->sched.sp;
        casgstatus(gp, _Gidle, _Gdead);
        gp->m = mp;
        mp->curg = gp;
        mp->isextra = true;
        mp->isExtraInC = true;
        mp->lockedInt++;
        rec::set(gocpp::recv(mp->lockedg), gp);
        rec::set(gocpp::recv(gp->lockedm), mp);
        gp->goid = rec::Add(gocpp::recv(sched.goidgen), 1);
        if(raceenabled)
        {
            gp->racectx = racegostart(abi::FuncPCABIInternal(newextram) + sys::PCQuantum);
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::OneNewExtraM(gocpp::recv(trace), gp);
            traceRelease(trace);
        }
        allgadd(gp);
        rec::Add(gocpp::recv(sched.ngsys), 1);
        addExtraM(mp);
    }

    void dropm()
    {
        auto mp = getg()->m;
        traceLocker trace = {};
        if(goexperiment::ExecTracer2 && ! mp->isExtraInSig)
        {
            trace = traceAcquire();
        }
        casgstatus(mp->curg, _Gsyscall, _Gdead);
        mp->curg->preemptStop = false;
        rec::Add(gocpp::recv(sched.ngsys), 1);
        if(goexperiment::ExecTracer2 && ! mp->isExtraInSig)
        {
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::GoDestroySyscall(gocpp::recv(trace));
                traceRelease(trace);
            }
        }
        if(goexperiment::ExecTracer2)
        {
            mp->syscalltick--;
        }
        rec::reset(gocpp::recv(mp->curg->trace));
        if(goexperiment::ExecTracer2 && (traceEnabled() || traceShuttingDown()))
        {
            lock(& sched.lock);
            traceThreadDestroy(mp);
            unlock(& sched.lock);
        }
        mp->isExtraInSig = false;
        auto sigmask = mp->sigmask;
        sigblock(false);
        unminit();
        setg(nullptr);
        auto g0 = mp->g0;
        g0->stack.hi = 0;
        g0->stack.lo = 0;
        g0->stackguard0 = 0;
        g0->stackguard1 = 0;
        putExtraM(mp);
        msigrestore(sigmask);
    }

    void cgoBindM()
    {
        if(GOOS == "windows" || GOOS == "plan9")
        {
            fatal("bindm in unexpected GOOS");
        }
        auto g = getg();
        if(g->m->g0 != g)
        {
            fatal("the current g is not g0");
        }
        if(_cgo_bindm != nullptr)
        {
            asmcgocall(_cgo_bindm, unsafe::Pointer(g));
        }
    }

    uintptr_t getm()
    {
        return uintptr_t(unsafe::Pointer(getg()->m));
    }

    atomic::Uintptr extraM;
    atomic::Uint32 extraMLength;
    atomic::Uint32 extraMWaiters;
    atomic::Uint32 extraMInUse;
    struct m* lockextra(bool nilokay)
    {
        auto locked = 1;
        auto incr = false;
        for(; ; )
        {
            auto old = rec::Load(gocpp::recv(extraM));
            if(old == locked)
            {
                osyield_no_g();
                continue;
            }
            if(old == 0 && ! nilokay)
            {
                if(! incr)
                {
                    rec::Add(gocpp::recv(extraMWaiters), 1);
                    incr = true;
                }
                usleep_no_g(1);
                continue;
            }
            if(rec::CompareAndSwap(gocpp::recv(extraM), old, locked))
            {
                return (m*)(unsafe::Pointer(old));
            }
            osyield_no_g();
            continue;
        }
    }

    void unlockextra(struct m* mp, int32_t delta)
    {
        rec::Add(gocpp::recv(extraMLength), delta);
        rec::Store(gocpp::recv(extraM), uintptr_t(unsafe::Pointer(mp)));
    }

    std::tuple<struct m*, bool> getExtraM()
    {
        struct m* mp;
        bool last;
        mp = lockextra(false);
        rec::Add(gocpp::recv(extraMInUse), 1);
        unlockextra(rec::ptr(gocpp::recv(mp->schedlink)), - 1);
        return {mp, rec::ptr(gocpp::recv(mp->schedlink)) == nullptr};
    }

    void putExtraM(struct m* mp)
    {
        rec::Add(gocpp::recv(extraMInUse), - 1);
        addExtraM(mp);
    }

    void addExtraM(struct m* mp)
    {
        auto mnext = lockextra(true);
        rec::set(gocpp::recv(mp->schedlink), mnext);
        unlockextra(mp, 1);
    }

    rwmutex allocmLock;
    rwmutex execLock;
    std::string failthreadcreate = "runtime: failed to create new OS thread\n";
    std::string failallocatestack = "runtime: failed to allocate stack for the new OS thread\n";
    struct gocpp_id_2
    {
        mutex lock;
        golang::runtime::muintptr newm;
        bool waiting;
        note wake;
        uint32_t haveTemplateThread;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.lock = this->lock;
            result.newm = this->newm;
            result.waiting = this->waiting;
            result.wake = this->wake;
            result.haveTemplateThread = this->haveTemplateThread;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (lock != ref.lock) return false;
            if (newm != ref.newm) return false;
            if (waiting != ref.waiting) return false;
            if (wake != ref.wake) return false;
            if (haveTemplateThread != ref.haveTemplateThread) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << lock;
            os << " " << newm;
            os << " " << waiting;
            os << " " << wake;
            os << " " << haveTemplateThread;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_2& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_2 newmHandoff;
    void newm(std::function<void ()> fn, struct p* pp, int64_t id)
    {
        acquirem();
        auto mp = allocm(pp, fn, id);
        rec::set(gocpp::recv(mp->nextp), pp);
        mp->sigmask = initSigmask;
        if(auto gp = getg(); gp != nullptr && gp->m != nullptr && (gp->m->lockedExt != 0 || gp->m->incgo) && GOOS != "plan9")
        {
            lock(& newmHandoff.lock);
            if(newmHandoff.haveTemplateThread == 0)
            {
                go_throw("on a locked thread with no template thread");
            }
            mp->schedlink = newmHandoff.newm;
            rec::set(gocpp::recv(newmHandoff.newm), mp);
            if(newmHandoff.waiting)
            {
                newmHandoff.waiting = false;
                notewakeup(& newmHandoff.wake);
            }
            unlock(& newmHandoff.lock);
            releasem(getg()->m);
            return;
        }
        newm1(mp);
        releasem(getg()->m);
    }

    void newm1(struct m* mp)
    {
        if(iscgo)
        {
            cgothreadstart ts = {};
            if(_cgo_thread_start == nullptr)
            {
                go_throw("_cgo_thread_start missing");
            }
            rec::set(gocpp::recv(ts.g), mp->g0);
            ts.tls = (uint64_t*)(unsafe::Pointer(& mp->tls[0]));
            ts.fn = unsafe::Pointer(abi::FuncPCABI0(mstart));
            if(msanenabled)
            {
                msanwrite(unsafe::Pointer(& ts), gocpp::Sizeof<cgothreadstart>());
            }
            if(asanenabled)
            {
                asanwrite(unsafe::Pointer(& ts), gocpp::Sizeof<cgothreadstart>());
            }
            rec::rlock(gocpp::recv(execLock));
            asmcgocall(_cgo_thread_start, unsafe::Pointer(& ts));
            rec::runlock(gocpp::recv(execLock));
            return;
        }
        rec::rlock(gocpp::recv(execLock));
        newosproc(mp);
        rec::runlock(gocpp::recv(execLock));
    }

    void startTemplateThread()
    {
        if(GOARCH == "wasm")
        {
            return;
        }
        auto mp = acquirem();
        if(! atomic::Cas(& newmHandoff.haveTemplateThread, 0, 1))
        {
            releasem(mp);
            return;
        }
        newm(templateThread, nullptr, - 1);
        releasem(mp);
    }

    void templateThread()
    {
        lock(& sched.lock);
        sched.nmsys++;
        checkdead();
        unlock(& sched.lock);
        for(; ; )
        {
            lock(& newmHandoff.lock);
            for(; newmHandoff.newm != 0; )
            {
                auto newm = rec::ptr(gocpp::recv(newmHandoff.newm));
                newmHandoff.newm = 0;
                unlock(& newmHandoff.lock);
                for(; newm != nullptr; )
                {
                    auto next = rec::ptr(gocpp::recv(newm->schedlink));
                    newm->schedlink = 0;
                    newm1(newm);
                    newm = next;
                }
                lock(& newmHandoff.lock);
            }
            newmHandoff.waiting = true;
            noteclear(& newmHandoff.wake);
            unlock(& newmHandoff.lock);
            notesleep(& newmHandoff.wake);
        }
    }

    void stopm()
    {
        auto gp = getg();
        if(gp->m->locks != 0)
        {
            go_throw("stopm holding locks");
        }
        if(gp->m->p != 0)
        {
            go_throw("stopm holding p");
        }
        if(gp->m->spinning)
        {
            go_throw("stopm spinning");
        }
        lock(& sched.lock);
        mput(gp->m);
        unlock(& sched.lock);
        mPark();
        acquirep(rec::ptr(gocpp::recv(gp->m->nextp)));
        gp->m->nextp = 0;
    }

    void mspinning()
    {
        getg()->m->spinning = true;
    }

    void startm(struct p* pp, bool spinning, bool lockheld)
    {
        auto mp = acquirem();
        if(! lockheld)
        {
            lock(& sched.lock);
        }
        if(pp == nullptr)
        {
            if(spinning)
            {
                go_throw("startm: P required for spinning=true");
            }
            std::tie(pp, gocpp_id_3) = pidleget(0);
            if(pp == nullptr)
            {
                if(! lockheld)
                {
                    unlock(& sched.lock);
                }
                releasem(mp);
                return;
            }
        }
        auto nmp = mget();
        if(nmp == nullptr)
        {
            auto id = mReserveID();
            unlock(& sched.lock);
            std::function<void ()> fn = {};
            if(spinning)
            {
                fn = mspinning;
            }
            newm(fn, pp, id);
            if(lockheld)
            {
                lock(& sched.lock);
            }
            releasem(mp);
            return;
        }
        if(! lockheld)
        {
            unlock(& sched.lock);
        }
        if(nmp->spinning)
        {
            go_throw("startm: m is spinning");
        }
        if(nmp->nextp != 0)
        {
            go_throw("startm: m has p");
        }
        if(spinning && ! runqempty(pp))
        {
            go_throw("startm: p has runnable gs");
        }
        nmp->spinning = spinning;
        rec::set(gocpp::recv(nmp->nextp), pp);
        notewakeup(& nmp->park);
        releasem(mp);
    }

    void handoffp(struct p* pp)
    {
        if(! runqempty(pp) || sched.runqsize != 0)
        {
            startm(pp, false, false);
            return;
        }
        if((traceEnabled() || traceShuttingDown()) && traceReaderAvailable() != nullptr)
        {
            startm(pp, false, false);
            return;
        }
        if(gcBlackenEnabled != 0 && gcMarkWorkAvailable(pp))
        {
            startm(pp, false, false);
            return;
        }
        if(rec::Load(gocpp::recv(sched.nmspinning)) + rec::Load(gocpp::recv(sched.npidle)) == 0 && rec::CompareAndSwap(gocpp::recv(sched.nmspinning), 0, 1))
        {
            rec::Store(gocpp::recv(sched.needspinning), 0);
            startm(pp, true, false);
            return;
        }
        lock(& sched.lock);
        if(rec::Load(gocpp::recv(sched.gcwaiting)))
        {
            pp->status = _Pgcstop;
            sched.stopwait--;
            if(sched.stopwait == 0)
            {
                notewakeup(& sched.stopnote);
            }
            unlock(& sched.lock);
            return;
        }
        if(pp->runSafePointFn != 0 && atomic::Cas(& pp->runSafePointFn, 1, 0))
        {
            rec::safePointFn(gocpp::recv(sched), pp);
            sched.safePointWait--;
            if(sched.safePointWait == 0)
            {
                notewakeup(& sched.safePointNote);
            }
        }
        if(sched.runqsize != 0)
        {
            unlock(& sched.lock);
            startm(pp, false, false);
            return;
        }
        if(rec::Load(gocpp::recv(sched.npidle)) == gomaxprocs - 1 && rec::Load(gocpp::recv(sched.lastpoll)) != 0)
        {
            unlock(& sched.lock);
            startm(pp, false, false);
            return;
        }
        auto when = nobarrierWakeTime(pp);
        pidleput(pp, 0);
        unlock(& sched.lock);
        if(when != 0)
        {
            wakeNetPoller(when);
        }
    }

    void wakep()
    {
        if(rec::Load(gocpp::recv(sched.nmspinning)) != 0 || ! rec::CompareAndSwap(gocpp::recv(sched.nmspinning), 0, 1))
        {
            return;
        }
        auto mp = acquirem();
        p* pp = {};
        lock(& sched.lock);
        std::tie(pp, gocpp_id_4) = pidlegetSpinning(0);
        if(pp == nullptr)
        {
            if(rec::Add(gocpp::recv(sched.nmspinning), - 1) < 0)
            {
                go_throw("wakep: negative nmspinning");
            }
            unlock(& sched.lock);
            releasem(mp);
            return;
        }
        unlock(& sched.lock);
        startm(pp, true, false);
        releasem(mp);
    }

    void stoplockedm()
    {
        auto gp = getg();
        if(gp->m->lockedg == 0 || rec::ptr(gocpp::recv(rec::ptr(gocpp::recv(gp->m->lockedg))->lockedm)) != gp->m)
        {
            go_throw("stoplockedm: inconsistent locking");
        }
        if(gp->m->p != 0)
        {
            auto pp = releasep();
            handoffp(pp);
        }
        incidlelocked(1);
        mPark();
        auto status = readgstatus(rec::ptr(gocpp::recv(gp->m->lockedg)));
        if(status &^ _Gscan != _Grunnable)
        {
            print("runtime:stoplockedm: lockedg (atomicstatus=", status, ") is not Grunnable or Gscanrunnable\n");
            dumpgstatus(rec::ptr(gocpp::recv(gp->m->lockedg)));
            go_throw("stoplockedm: not runnable");
        }
        acquirep(rec::ptr(gocpp::recv(gp->m->nextp)));
        gp->m->nextp = 0;
    }

    void startlockedm(struct g* gp)
    {
        auto mp = rec::ptr(gocpp::recv(gp->lockedm));
        if(mp == getg()->m)
        {
            go_throw("startlockedm: locked to me");
        }
        if(mp->nextp != 0)
        {
            go_throw("startlockedm: m has p");
        }
        incidlelocked(- 1);
        auto pp = releasep();
        rec::set(gocpp::recv(mp->nextp), pp);
        notewakeup(& mp->park);
        stopm();
    }

    void gcstopm()
    {
        auto gp = getg();
        if(! rec::Load(gocpp::recv(sched.gcwaiting)))
        {
            go_throw("gcstopm: not waiting for gc");
        }
        if(gp->m->spinning)
        {
            gp->m->spinning = false;
            if(rec::Add(gocpp::recv(sched.nmspinning), - 1) < 0)
            {
                go_throw("gcstopm: negative nmspinning");
            }
        }
        auto pp = releasep();
        lock(& sched.lock);
        pp->status = _Pgcstop;
        sched.stopwait--;
        if(sched.stopwait == 0)
        {
            notewakeup(& sched.stopnote);
        }
        unlock(& sched.lock);
        stopm();
    }

    void execute(struct g* gp, bool inheritTime)
    {
        auto mp = getg()->m;
        if(goroutineProfile.active)
        {
            tryRecordGoroutineProfile(gp, osyield);
        }
        mp->curg = gp;
        gp->m = mp;
        casgstatus(gp, _Grunnable, _Grunning);
        gp->waitsince = 0;
        gp->preempt = false;
        gp->stackguard0 = gp->stack.lo + stackGuard;
        if(! inheritTime)
        {
            rec::ptr(gocpp::recv(mp->p))->schedtick++;
        }
        auto hz = sched.profilehz;
        if(mp->profilehz != hz)
        {
            setThreadCPUProfiler(hz);
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            if(! goexperiment::ExecTracer2 && gp->syscallsp != 0)
            {
                rec::GoSysExit(gocpp::recv(trace), true);
            }
            rec::GoStart(gocpp::recv(trace));
            traceRelease(trace);
        }
        gogo(& gp->sched);
    }

    std::tuple<struct g*, bool, bool> findRunnable()
    {
        struct g* gp;
        bool inheritTime;
        bool tryWakeP;
        auto mp = getg()->m;
        top:
        auto pp = rec::ptr(gocpp::recv(mp->p));
        if(rec::Load(gocpp::recv(sched.gcwaiting)))
        {
            gcstopm();
            goto top;
        }
        if(pp->runSafePointFn != 0)
        {
            runSafePointFn();
        }
        auto [now, pollUntil, gocpp_id_6] = checkTimers(pp, 0);
        if(traceEnabled() || traceShuttingDown())
        {
            auto gp = traceReader();
            if(gp != nullptr)
            {
                auto trace = traceAcquire();
                casgstatus(gp, _Gwaiting, _Grunnable);
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoUnpark(gocpp::recv(trace), gp, 0);
                    traceRelease(trace);
                }
                return {gp, false, true};
            }
        }
        if(gcBlackenEnabled != 0)
        {
            auto [gp, tnow] = rec::findRunnableGCWorker(gocpp::recv(gcController), pp, now);
            if(gp != nullptr)
            {
                return {gp, false, true};
            }
            now = tnow;
        }
        if(pp->schedtick % 61 == 0 && sched.runqsize > 0)
        {
            lock(& sched.lock);
            auto gp = globrunqget(pp, 1);
            unlock(& sched.lock);
            if(gp != nullptr)
            {
                return {gp, false, false};
            }
        }
        if(rec::Load(gocpp::recv(fingStatus)) & (fingWait | fingWake) == fingWait | fingWake)
        {
            if(auto gp = wakefing(); gp != nullptr)
            {
                ready(gp, 0, true);
            }
        }
        if(*cgo_yield != nullptr)
        {
            asmcgocall(*cgo_yield, nullptr);
        }
        if(auto [gp, inheritTime] = runqget(pp); gp != nullptr)
        {
            return {gp, inheritTime, false};
        }
        if(sched.runqsize != 0)
        {
            lock(& sched.lock);
            auto gp = globrunqget(pp, 0);
            unlock(& sched.lock);
            if(gp != nullptr)
            {
                return {gp, false, false};
            }
        }
        if(netpollinited() && netpollAnyWaiters() && rec::Load(gocpp::recv(sched.lastpoll)) != 0)
        {
            if(auto [list, delta] = netpoll(0); ! rec::empty(gocpp::recv(list)))
            {
                auto gp = rec::pop(gocpp::recv(list));
                injectglist(& list);
                netpollAdjustWaiters(delta);
                auto trace = traceAcquire();
                casgstatus(gp, _Gwaiting, _Grunnable);
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoUnpark(gocpp::recv(trace), gp, 0);
                    traceRelease(trace);
                }
                return {gp, false, false};
            }
        }
        if(mp->spinning || 2 * rec::Load(gocpp::recv(sched.nmspinning)) < gomaxprocs - rec::Load(gocpp::recv(sched.npidle)))
        {
            if(! mp->spinning)
            {
                rec::becomeSpinning(gocpp::recv(mp));
            }
            auto [gp, inheritTime, tnow, w, newWork] = stealWork(now);
            if(gp != nullptr)
            {
                return {gp, inheritTime, false};
            }
            if(newWork)
            {
                goto top;
            }
            now = tnow;
            if(w != 0 && (pollUntil == 0 || w < pollUntil))
            {
                pollUntil = w;
            }
        }
        if(gcBlackenEnabled != 0 && gcMarkWorkAvailable(pp) && rec::addIdleMarkWorker(gocpp::recv(gcController)))
        {
            auto node = (gcBgMarkWorkerNode*)(rec::pop(gocpp::recv(gcBgMarkWorkerPool)));
            if(node != nullptr)
            {
                pp->gcMarkWorkerMode = gcMarkWorkerIdleMode;
                auto gp = rec::ptr(gocpp::recv(node->gp));
                auto trace = traceAcquire();
                casgstatus(gp, _Gwaiting, _Grunnable);
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoUnpark(gocpp::recv(trace), gp, 0);
                    traceRelease(trace);
                }
                return {gp, false, false};
            }
            rec::removeIdleMarkWorker(gocpp::recv(gcController));
        }
        auto [gp, otherReady] = beforeIdle(now, pollUntil);
        if(gp != nullptr)
        {
            auto trace = traceAcquire();
            casgstatus(gp, _Gwaiting, _Grunnable);
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::GoUnpark(gocpp::recv(trace), gp, 0);
                traceRelease(trace);
            }
            return {gp, false, false};
        }
        if(otherReady)
        {
            goto top;
        }
        auto allpSnapshot = allp;
        auto idlepMaskSnapshot = idlepMask;
        auto timerpMaskSnapshot = timerpMask;
        lock(& sched.lock);
        if(rec::Load(gocpp::recv(sched.gcwaiting)) || pp->runSafePointFn != 0)
        {
            unlock(& sched.lock);
            goto top;
        }
        if(sched.runqsize != 0)
        {
            auto gp = globrunqget(pp, 0);
            unlock(& sched.lock);
            return {gp, false, false};
        }
        if(! mp->spinning && rec::Load(gocpp::recv(sched.needspinning)) == 1)
        {
            rec::becomeSpinning(gocpp::recv(mp));
            unlock(& sched.lock);
            goto top;
        }
        if(releasep() != pp)
        {
            go_throw("findrunnable: wrong p");
        }
        now = pidleput(pp, now);
        unlock(& sched.lock);
        auto wasSpinning = mp->spinning;
        if(mp->spinning)
        {
            mp->spinning = false;
            if(rec::Add(gocpp::recv(sched.nmspinning), - 1) < 0)
            {
                go_throw("findrunnable: negative nmspinning");
            }
            lock(& sched.lock);
            if(sched.runqsize != 0)
            {
                auto [pp, gocpp_id_8] = pidlegetSpinning(0);
                if(pp != nullptr)
                {
                    auto gp = globrunqget(pp, 0);
                    if(gp == nullptr)
                    {
                        go_throw("global runq empty with non-zero runqsize");
                    }
                    unlock(& sched.lock);
                    acquirep(pp);
                    rec::becomeSpinning(gocpp::recv(mp));
                    return {gp, false, false};
                }
            }
            unlock(& sched.lock);
            auto pp = checkRunqsNoP(allpSnapshot, idlepMaskSnapshot);
            if(pp != nullptr)
            {
                acquirep(pp);
                rec::becomeSpinning(gocpp::recv(mp));
                goto top;
            }
            g* gp;
            std::tie(pp, gp) = checkIdleGCNoP();
            if(pp != nullptr)
            {
                acquirep(pp);
                rec::becomeSpinning(gocpp::recv(mp));
                pp->gcMarkWorkerMode = gcMarkWorkerIdleMode;
                auto trace = traceAcquire();
                casgstatus(gp, _Gwaiting, _Grunnable);
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoUnpark(gocpp::recv(trace), gp, 0);
                    traceRelease(trace);
                }
                return {gp, false, false};
            }
            pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil);
        }
        if(netpollinited() && (netpollAnyWaiters() || pollUntil != 0) && rec::Swap(gocpp::recv(sched.lastpoll), 0) != 0)
        {
            rec::Store(gocpp::recv(sched.pollUntil), pollUntil);
            if(mp->p != 0)
            {
                go_throw("findrunnable: netpoll with p");
            }
            if(mp->spinning)
            {
                go_throw("findrunnable: netpoll with spinning");
            }
            auto delay = int64_t(- 1);
            if(pollUntil != 0)
            {
                if(now == 0)
                {
                    now = nanotime();
                }
                delay = pollUntil - now;
                if(delay < 0)
                {
                    delay = 0;
                }
            }
            if(faketime != 0)
            {
                delay = 0;
            }
            auto [list, delta] = netpoll(delay);
            now = nanotime();
            rec::Store(gocpp::recv(sched.pollUntil), 0);
            rec::Store(gocpp::recv(sched.lastpoll), now);
            if(faketime != 0 && rec::empty(gocpp::recv(list)))
            {
                stopm();
                goto top;
            }
            lock(& sched.lock);
            auto [pp, gocpp_id_10] = pidleget(now);
            unlock(& sched.lock);
            if(pp == nullptr)
            {
                injectglist(& list);
                netpollAdjustWaiters(delta);
            }
            else
            {
                acquirep(pp);
                if(! rec::empty(gocpp::recv(list)))
                {
                    auto gp = rec::pop(gocpp::recv(list));
                    injectglist(& list);
                    netpollAdjustWaiters(delta);
                    auto trace = traceAcquire();
                    casgstatus(gp, _Gwaiting, _Grunnable);
                    if(rec::ok(gocpp::recv(trace)))
                    {
                        rec::GoUnpark(gocpp::recv(trace), gp, 0);
                        traceRelease(trace);
                    }
                    return {gp, false, false};
                }
                if(wasSpinning)
                {
                    rec::becomeSpinning(gocpp::recv(mp));
                }
                goto top;
            }
        }
        else
        if(pollUntil != 0 && netpollinited())
        {
            auto pollerPollUntil = rec::Load(gocpp::recv(sched.pollUntil));
            if(pollerPollUntil == 0 || pollerPollUntil > pollUntil)
            {
                netpollBreak();
            }
        }
        stopm();
        goto top;
    }

    bool pollWork()
    {
        if(sched.runqsize != 0)
        {
            return true;
        }
        auto p = rec::ptr(gocpp::recv(getg()->m->p));
        if(! runqempty(p))
        {
            return true;
        }
        if(netpollinited() && netpollAnyWaiters() && rec::Load(gocpp::recv(sched.lastpoll)) != 0)
        {
            if(auto [list, delta] = netpoll(0); ! rec::empty(gocpp::recv(list)))
            {
                injectglist(& list);
                netpollAdjustWaiters(delta);
                return true;
            }
        }
        return false;
    }

    std::tuple<struct g*, bool, int64_t, int64_t, bool> stealWork(int64_t now)
    {
        struct g* gp;
        bool inheritTime;
        int64_t rnow;
        int64_t pollUntil;
        bool newWork;
        auto pp = rec::ptr(gocpp::recv(getg()->m->p));
        auto ranTimer = false;
        auto stealTries = 4;
        for(auto i = 0; i < stealTries; i++)
        {
            auto stealTimersOrRunNextG = i == stealTries - 1;
            for(auto go_enum = rec::start(gocpp::recv(stealOrder), cheaprand()); ! rec::done(gocpp::recv(go_enum)); rec::next(gocpp::recv(go_enum)))
            {
                if(rec::Load(gocpp::recv(sched.gcwaiting)))
                {
                    return {nullptr, false, now, pollUntil, true};
                }
                auto p2 = allp[rec::position(gocpp::recv(go_enum))];
                if(pp == p2)
                {
                    continue;
                }
                if(stealTimersOrRunNextG && rec::read(gocpp::recv(timerpMask), rec::position(gocpp::recv(go_enum))))
                {
                    auto [tnow, w, ran] = checkTimers(p2, now);
                    now = tnow;
                    if(w != 0 && (pollUntil == 0 || w < pollUntil))
                    {
                        pollUntil = w;
                    }
                    if(ran)
                    {
                        if(auto [gp, inheritTime] = runqget(pp); gp != nullptr)
                        {
                            return {gp, inheritTime, now, pollUntil, ranTimer};
                        }
                        ranTimer = true;
                    }
                }
                if(! rec::read(gocpp::recv(idlepMask), rec::position(gocpp::recv(go_enum))))
                {
                    if(auto gp = runqsteal(pp, p2, stealTimersOrRunNextG); gp != nullptr)
                    {
                        return {gp, false, now, pollUntil, ranTimer};
                    }
                }
            }
        }
        return {nullptr, false, now, pollUntil, ranTimer};
    }

    struct p* checkRunqsNoP(gocpp::slice<p*> allpSnapshot, pMask idlepMaskSnapshot)
    {
        for(auto [id, p2] : allpSnapshot)
        {
            if(! rec::read(gocpp::recv(idlepMaskSnapshot), uint32_t(id)) && ! runqempty(p2))
            {
                lock(& sched.lock);
                auto [pp, gocpp_id_12] = pidlegetSpinning(0);
                if(pp == nullptr)
                {
                    unlock(& sched.lock);
                    return nullptr;
                }
                unlock(& sched.lock);
                return pp;
            }
        }
        return nullptr;
    }

    int64_t checkTimersNoP(gocpp::slice<p*> allpSnapshot, pMask timerpMaskSnapshot, int64_t pollUntil)
    {
        for(auto [id, p2] : allpSnapshot)
        {
            if(rec::read(gocpp::recv(timerpMaskSnapshot), uint32_t(id)))
            {
                auto w = nobarrierWakeTime(p2);
                if(w != 0 && (pollUntil == 0 || w < pollUntil))
                {
                    pollUntil = w;
                }
            }
        }
        return pollUntil;
    }

    std::tuple<struct p*, struct g*> checkIdleGCNoP()
    {
        if(atomic::Load(& gcBlackenEnabled) == 0 || ! rec::needIdleMarkWorker(gocpp::recv(gcController)))
        {
            return {nullptr, nullptr};
        }
        if(! gcMarkWorkAvailable(nullptr))
        {
            return {nullptr, nullptr};
        }
        lock(& sched.lock);
        auto [pp, now] = pidlegetSpinning(0);
        if(pp == nullptr)
        {
            unlock(& sched.lock);
            return {nullptr, nullptr};
        }
        if(gcBlackenEnabled == 0 || ! rec::addIdleMarkWorker(gocpp::recv(gcController)))
        {
            pidleput(pp, now);
            unlock(& sched.lock);
            return {nullptr, nullptr};
        }
        auto node = (gcBgMarkWorkerNode*)(rec::pop(gocpp::recv(gcBgMarkWorkerPool)));
        if(node == nullptr)
        {
            pidleput(pp, now);
            unlock(& sched.lock);
            rec::removeIdleMarkWorker(gocpp::recv(gcController));
            return {nullptr, nullptr};
        }
        unlock(& sched.lock);
        return {pp, rec::ptr(gocpp::recv(node->gp))};
    }

    void wakeNetPoller(int64_t when)
    {
        if(rec::Load(gocpp::recv(sched.lastpoll)) == 0)
        {
            auto pollerPollUntil = rec::Load(gocpp::recv(sched.pollUntil));
            if(pollerPollUntil == 0 || pollerPollUntil > when)
            {
                netpollBreak();
            }
        }
        else
        {
            if(GOOS != "plan9")
            {
                wakep();
            }
        }
    }

    void resetspinning()
    {
        auto gp = getg();
        if(! gp->m->spinning)
        {
            go_throw("resetspinning: not a spinning m");
        }
        gp->m->spinning = false;
        auto nmspinning = rec::Add(gocpp::recv(sched.nmspinning), - 1);
        if(nmspinning < 0)
        {
            go_throw("findrunnable: negative nmspinning");
        }
        wakep();
    }

    void injectglist(struct gList* glist)
    {
        if(rec::empty(gocpp::recv(glist)))
        {
            return;
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            for(auto gp = rec::ptr(gocpp::recv(glist->head)); gp != nullptr; gp = rec::ptr(gocpp::recv(gp->schedlink)))
            {
                rec::GoUnpark(gocpp::recv(trace), gp, 0);
            }
            traceRelease(trace);
        }
        auto head = rec::ptr(gocpp::recv(glist->head));
        g* tail = {};
        auto qsize = 0;
        for(auto gp = head; gp != nullptr; gp = rec::ptr(gocpp::recv(gp->schedlink)))
        {
            tail = gp;
            qsize++;
            casgstatus(gp, _Gwaiting, _Grunnable);
        }
        gQueue q = {};
        rec::set(gocpp::recv(q.head), head);
        rec::set(gocpp::recv(q.tail), tail);
        *glist = gList {};
        auto startIdle = [=](int n) mutable -> void
        {
            for(auto i = 0; i < n; i++)
            {
                auto mp = acquirem();
                lock(& sched.lock);
                auto [pp, gocpp_id_14] = pidlegetSpinning(0);
                if(pp == nullptr)
                {
                    unlock(& sched.lock);
                    releasem(mp);
                    break;
                }
                startm(pp, false, true);
                unlock(& sched.lock);
                releasem(mp);
            }
        };
        auto pp = rec::ptr(gocpp::recv(getg()->m->p));
        if(pp == nullptr)
        {
            lock(& sched.lock);
            globrunqputbatch(& q, int32_t(qsize));
            unlock(& sched.lock);
            startIdle(qsize);
            return;
        }
        auto npidle = int(rec::Load(gocpp::recv(sched.npidle)));
        gQueue globq = {};
        int n = {};
        for(n = 0; n < npidle && ! rec::empty(gocpp::recv(q)); n++)
        {
            auto g = rec::pop(gocpp::recv(q));
            rec::pushBack(gocpp::recv(globq), g);
        }
        if(n > 0)
        {
            lock(& sched.lock);
            globrunqputbatch(& globq, int32_t(n));
            unlock(& sched.lock);
            startIdle(n);
            qsize -= n;
        }
        if(! rec::empty(gocpp::recv(q)))
        {
            runqputbatch(pp, & q, qsize);
        }
    }

    void schedule()
    {
        auto mp = getg()->m;
        if(mp->locks != 0)
        {
            go_throw("schedule: holding locks");
        }
        if(mp->lockedg != 0)
        {
            stoplockedm();
            execute(rec::ptr(gocpp::recv(mp->lockedg)), false);
        }
        if(mp->incgo)
        {
            go_throw("schedule: in cgo");
        }
        top:
        auto pp = rec::ptr(gocpp::recv(mp->p));
        pp->preempt = false;
        if(mp->spinning && (pp->runnext != 0 || pp->runqhead != pp->runqtail))
        {
            go_throw("schedule: spinning with local work");
        }
        auto [gp, inheritTime, tryWakeP] = findRunnable();
        if(debug.dontfreezetheworld > 0 && rec::Load(gocpp::recv(freezing)))
        {
            lock(& deadlock);
            lock(& deadlock);
        }
        if(mp->spinning)
        {
            resetspinning();
        }
        if(sched.disable.user && ! schedEnabled(gp))
        {
            lock(& sched.lock);
            if(schedEnabled(gp))
            {
                unlock(& sched.lock);
            }
            else
            {
                rec::pushBack(gocpp::recv(sched.disable.runnable), gp);
                sched.disable.n++;
                unlock(& sched.lock);
                goto top;
            }
        }
        if(tryWakeP)
        {
            wakep();
        }
        if(gp->lockedm != 0)
        {
            startlockedm(gp);
            goto top;
        }
        execute(gp, inheritTime);
    }

    void dropg()
    {
        auto gp = getg();
        setMNoWB(& gp->m->curg->m, nullptr);
        setGNoWB(& gp->m->curg, nullptr);
    }

    std::tuple<int64_t, int64_t, bool> checkTimers(struct p* pp, int64_t now)
    {
        int64_t rnow;
        int64_t pollUntil;
        bool ran;
        auto next = rec::Load(gocpp::recv(pp->timer0When));
        auto nextAdj = rec::Load(gocpp::recv(pp->timerModifiedEarliest));
        if(next == 0 || (nextAdj != 0 && nextAdj < next))
        {
            next = nextAdj;
        }
        if(next == 0)
        {
            return {now, 0, false};
        }
        if(now == 0)
        {
            now = nanotime();
        }
        if(now < next)
        {
            if(pp != rec::ptr(gocpp::recv(getg()->m->p)) || int(rec::Load(gocpp::recv(pp->deletedTimers))) <= int(rec::Load(gocpp::recv(pp->numTimers)) / 4))
            {
                return {now, next, false};
            }
        }
        lock(& pp->timersLock);
        if(len(pp->timers) > 0)
        {
            adjusttimers(pp, now);
            for(; len(pp->timers) > 0; )
            {
                if(auto tw = runtimer(pp, now); tw != 0)
                {
                    if(tw > 0)
                    {
                        pollUntil = tw;
                    }
                    break;
                }
                ran = true;
            }
        }
        if(pp == rec::ptr(gocpp::recv(getg()->m->p)) && int(rec::Load(gocpp::recv(pp->deletedTimers))) > len(pp->timers) / 4)
        {
            clearDeletedTimers(pp);
        }
        unlock(& pp->timersLock);
        return {now, pollUntil, ran};
    }

    bool parkunlock_c(struct g* gp, unsafe::Pointer lock)
    {
        unlock((mutex*)(lock));
        return true;
    }

    void park_m(struct g* gp)
    {
        auto mp = getg()->m;
        auto trace = traceAcquire();
        casgstatus(gp, _Grunning, _Gwaiting);
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoPark(gocpp::recv(trace), mp->waitTraceBlockReason, mp->waitTraceSkip);
            traceRelease(trace);
        }
        dropg();
        if(auto fn = mp->waitunlockf; fn != nullptr)
        {
            auto ok = fn(gp, mp->waitlock);
            mp->waitunlockf = nullptr;
            mp->waitlock = nullptr;
            if(! ok)
            {
                auto trace = traceAcquire();
                casgstatus(gp, _Gwaiting, _Grunnable);
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoUnpark(gocpp::recv(trace), gp, 2);
                    traceRelease(trace);
                }
                execute(gp, true);
            }
        }
        schedule();
    }

    void goschedImpl(struct g* gp, bool preempted)
    {
        auto trace = traceAcquire();
        auto status = readgstatus(gp);
        if(status &^ _Gscan != _Grunning)
        {
            dumpgstatus(gp);
            go_throw("bad g status");
        }
        casgstatus(gp, _Grunning, _Grunnable);
        if(rec::ok(gocpp::recv(trace)))
        {
            if(preempted)
            {
                rec::GoPreempt(gocpp::recv(trace));
            }
            else
            {
                rec::GoSched(gocpp::recv(trace));
            }
            traceRelease(trace);
        }
        dropg();
        lock(& sched.lock);
        globrunqput(gp);
        unlock(& sched.lock);
        if(mainStarted)
        {
            wakep();
        }
        schedule();
    }

    void gosched_m(struct g* gp)
    {
        goschedImpl(gp, false);
    }

    void goschedguarded_m(struct g* gp)
    {
        if(! canPreemptM(gp->m))
        {
            gogo(& gp->sched);
        }
        goschedImpl(gp, false);
    }

    void gopreempt_m(struct g* gp)
    {
        goschedImpl(gp, true);
    }

    void preemptPark(struct g* gp)
    {
        auto status = readgstatus(gp);
        if(status &^ _Gscan != _Grunning)
        {
            dumpgstatus(gp);
            go_throw("bad g status");
        }
        if(gp->asyncSafePoint)
        {
            auto f = findfunc(gp->sched.pc);
            if(! rec::valid(gocpp::recv(f)))
            {
                go_throw("preempt at unknown pc");
            }
            if(f.flag & abi::FuncFlagSPWrite != 0)
            {
                println("runtime: unexpected SPWRITE function", funcname(f), "in async preempt");
                go_throw("preempt SPWRITE");
            }
        }
        casGToPreemptScan(gp, _Grunning, _Gscan | _Gpreempted);
        dropg();
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoPark(gocpp::recv(trace), traceBlockPreempted, 0);
        }
        casfrom_Gscanstatus(gp, _Gscan | _Gpreempted, _Gpreempted);
        if(rec::ok(gocpp::recv(trace)))
        {
            traceRelease(trace);
        }
        schedule();
    }

    void goyield()
    {
        checkTimeouts();
        mcall(goyield_m);
    }

    void goyield_m(struct g* gp)
    {
        auto trace = traceAcquire();
        auto pp = rec::ptr(gocpp::recv(gp->m->p));
        casgstatus(gp, _Grunning, _Grunnable);
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoPreempt(gocpp::recv(trace));
            traceRelease(trace);
        }
        dropg();
        runqput(pp, gp, false);
        schedule();
    }

    void goexit1()
    {
        if(raceenabled)
        {
            racegoend();
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoEnd(gocpp::recv(trace));
            traceRelease(trace);
        }
        mcall(goexit0);
    }

    void goexit0(struct g* gp)
    {
        gdestroy(gp);
        schedule();
    }

    void gdestroy(struct g* gp)
    {
        auto mp = getg()->m;
        auto pp = rec::ptr(gocpp::recv(mp->p));
        casgstatus(gp, _Grunning, _Gdead);
        rec::addScannableStack(gocpp::recv(gcController), pp, - int64_t(gp->stack.hi - gp->stack.lo));
        if(isSystemGoroutine(gp, false))
        {
            rec::Add(gocpp::recv(sched.ngsys), - 1);
        }
        gp->m = nullptr;
        auto locked = gp->lockedm != 0;
        gp->lockedm = 0;
        mp->lockedg = 0;
        gp->preemptStop = false;
        gp->paniconfault = false;
        gp->_defer = nullptr;
        gp->_panic = nullptr;
        gp->writebuf = nullptr;
        gp->waitreason = waitReasonZero;
        gp->param = nullptr;
        gp->labels = nullptr;
        gp->timer = nullptr;
        if(gcBlackenEnabled != 0 && gp->gcAssistBytes > 0)
        {
            auto assistWorkPerByte = rec::Load(gocpp::recv(gcController.assistWorkPerByte));
            auto scanCredit = int64_t(assistWorkPerByte * double(gp->gcAssistBytes));
            rec::Add(gocpp::recv(gcController.bgScanCredit), scanCredit);
            gp->gcAssistBytes = 0;
        }
        dropg();
        if(GOARCH == "wasm")
        {
            gfput(pp, gp);
            return;
        }
        if(mp->lockedInt != 0)
        {
            print("invalid m->lockedInt = ", mp->lockedInt, "\n");
            go_throw("internal lockOSThread error");
        }
        gfput(pp, gp);
        if(locked)
        {
            if(GOOS != "plan9")
            {
                gogo(& mp->g0->sched);
            }
            else
            {
                mp->lockedExt = 0;
            }
        }
    }

    void save(uintptr_t pc, uintptr_t sp)
    {
        auto gp = getg();
        if(gp == gp->m->g0 || gp == gp->m->gsignal)
        {
            go_throw("save on system g not allowed");
        }
        gp->sched.pc = pc;
        gp->sched.sp = sp;
        gp->sched.lr = 0;
        gp->sched.ret = 0;
        if(gp->sched.ctxt != nullptr)
        {
            badctxt();
        }
    }

    void reentersyscall(uintptr_t pc, uintptr_t sp)
    {
        auto trace = traceAcquire();
        auto gp = getg();
        gp->m->locks++;
        gp->stackguard0 = stackPreempt;
        gp->throwsplit = true;
        save(pc, sp);
        gp->syscallsp = sp;
        gp->syscallpc = pc;
        casgstatus(gp, _Grunning, _Gsyscall);
        if(staticLockRanking)
        {
            save(pc, sp);
        }
        if(gp->syscallsp < gp->stack.lo || gp->stack.hi < gp->syscallsp)
        {
            systemstack([=]() mutable -> void
            {
                print("entersyscall inconsistent ", hex(gp->syscallsp), " [", hex(gp->stack.lo), ",", hex(gp->stack.hi), "]\n");
                go_throw("entersyscall");
            });
        }
        if(rec::ok(gocpp::recv(trace)))
        {
            systemstack([=]() mutable -> void
            {
                rec::GoSysCall(gocpp::recv(trace));
                traceRelease(trace);
            });
            save(pc, sp);
        }
        if(rec::Load(gocpp::recv(sched.sysmonwait)))
        {
            systemstack(entersyscall_sysmon);
            save(pc, sp);
        }
        if(rec::ptr(gocpp::recv(gp->m->p))->runSafePointFn != 0)
        {
            systemstack(runSafePointFn);
            save(pc, sp);
        }
        gp->m->syscalltick = rec::ptr(gocpp::recv(gp->m->p))->syscalltick;
        auto pp = rec::ptr(gocpp::recv(gp->m->p));
        pp->m = 0;
        rec::set(gocpp::recv(gp->m->oldp), pp);
        gp->m->p = 0;
        atomic::Store(& pp->status, _Psyscall);
        if(rec::Load(gocpp::recv(sched.gcwaiting)))
        {
            systemstack(entersyscall_gcwait);
            save(pc, sp);
        }
        gp->m->locks--;
    }

    void entersyscall()
    {
        reentersyscall(getcallerpc(), getcallersp());
    }

    void entersyscall_sysmon()
    {
        lock(& sched.lock);
        if(rec::Load(gocpp::recv(sched.sysmonwait)))
        {
            rec::Store(gocpp::recv(sched.sysmonwait), false);
            notewakeup(& sched.sysmonnote);
        }
        unlock(& sched.lock);
    }

    void entersyscall_gcwait()
    {
        auto gp = getg();
        auto pp = rec::ptr(gocpp::recv(gp->m->oldp));
        lock(& sched.lock);
        auto trace = traceAcquire();
        if(sched.stopwait > 0 && atomic::Cas(& pp->status, _Psyscall, _Pgcstop))
        {
            if(rec::ok(gocpp::recv(trace)))
            {
                if(goexperiment::ExecTracer2)
                {
                    rec::ProcSteal(gocpp::recv(trace), pp, true);
                }
                else
                {
                    rec::GoSysBlock(gocpp::recv(trace), pp);
                    rec::ProcStop(gocpp::recv(trace), pp);
                }
                traceRelease(trace);
            }
            pp->syscalltick++;
            if(sched.stopwait--; sched.stopwait == 0)
            {
                notewakeup(& sched.stopnote);
            }
        }
        else
        if(rec::ok(gocpp::recv(trace)))
        {
            traceRelease(trace);
        }
        unlock(& sched.lock);
    }

    void entersyscallblock()
    {
        auto gp = getg();
        gp->m->locks++;
        gp->throwsplit = true;
        gp->stackguard0 = stackPreempt;
        gp->m->syscalltick = rec::ptr(gocpp::recv(gp->m->p))->syscalltick;
        rec::ptr(gocpp::recv(gp->m->p))->syscalltick++;
        auto pc = getcallerpc();
        auto sp = getcallersp();
        save(pc, sp);
        gp->syscallsp = gp->sched.sp;
        gp->syscallpc = gp->sched.pc;
        if(gp->syscallsp < gp->stack.lo || gp->stack.hi < gp->syscallsp)
        {
            auto sp1 = sp;
            auto sp2 = gp->sched.sp;
            auto sp3 = gp->syscallsp;
            systemstack([=]() mutable -> void
            {
                print("entersyscallblock inconsistent ", hex(sp1), " ", hex(sp2), " ", hex(sp3), " [", hex(gp->stack.lo), ",", hex(gp->stack.hi), "]\n");
                go_throw("entersyscallblock");
            });
        }
        casgstatus(gp, _Grunning, _Gsyscall);
        if(gp->syscallsp < gp->stack.lo || gp->stack.hi < gp->syscallsp)
        {
            systemstack([=]() mutable -> void
            {
                print("entersyscallblock inconsistent ", hex(sp), " ", hex(gp->sched.sp), " ", hex(gp->syscallsp), " [", hex(gp->stack.lo), ",", hex(gp->stack.hi), "]\n");
                go_throw("entersyscallblock");
            });
        }
        systemstack(entersyscallblock_handoff);
        save(getcallerpc(), getcallersp());
        gp->m->locks--;
    }

    void entersyscallblock_handoff()
    {
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoSysCall(gocpp::recv(trace));
            rec::GoSysBlock(gocpp::recv(trace), rec::ptr(gocpp::recv(getg()->m->p)));
            traceRelease(trace);
        }
        handoffp(releasep());
    }

    void exitsyscall()
    {
        auto gp = getg();
        gp->m->locks++;
        if(getcallersp() > gp->syscallsp)
        {
            go_throw("exitsyscall: syscall frame is no longer valid");
        }
        gp->waitsince = 0;
        auto oldp = rec::ptr(gocpp::recv(gp->m->oldp));
        gp->m->oldp = 0;
        if(exitsyscallfast(oldp))
        {
            if(goroutineProfile.active)
            {
                systemstack([=]() mutable -> void
                {
                    tryRecordGoroutineProfileWB(gp);
                });
            }
            auto trace = traceAcquire();
            if(rec::ok(gocpp::recv(trace)))
            {
                auto lostP = oldp != rec::ptr(gocpp::recv(gp->m->p)) || gp->m->syscalltick != rec::ptr(gocpp::recv(gp->m->p))->syscalltick;
                systemstack([=]() mutable -> void
                {
                    if(goexperiment::ExecTracer2)
                    {
                        rec::GoSysExit(gocpp::recv(trace), lostP);
                    }
                    if(lostP)
                    {
                        rec::GoStart(gocpp::recv(trace));
                    }
                });
            }
            rec::ptr(gocpp::recv(gp->m->p))->syscalltick++;
            casgstatus(gp, _Gsyscall, _Grunning);
            if(rec::ok(gocpp::recv(trace)))
            {
                traceRelease(trace);
            }
            gp->syscallsp = 0;
            gp->m->locks--;
            if(gp->preempt)
            {
                gp->stackguard0 = stackPreempt;
            }
            else
            {
                gp->stackguard0 = gp->stack.lo + stackGuard;
            }
            gp->throwsplit = false;
            if(sched.disable.user && ! schedEnabled(gp))
            {
                Gosched();
            }
            return;
        }
        if(! goexperiment::ExecTracer2)
        {
            auto trace = traceAcquire();
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::RecordSyscallExitedTime(gocpp::recv(trace), gp, oldp);
                traceRelease(trace);
            }
        }
        gp->m->locks--;
        mcall(exitsyscall0);
        gp->syscallsp = 0;
        rec::ptr(gocpp::recv(gp->m->p))->syscalltick++;
        gp->throwsplit = false;
    }

    bool exitsyscallfast(struct p* oldp)
    {
        auto gp = getg();
        if(sched.stopwait == freezeStopWait)
        {
            return false;
        }
        auto trace = traceAcquire();
        if(oldp != nullptr && oldp->status == _Psyscall && atomic::Cas(& oldp->status, _Psyscall, _Pidle))
        {
            wirep(oldp);
            exitsyscallfast_reacquired(trace);
            if(rec::ok(gocpp::recv(trace)))
            {
                traceRelease(trace);
            }
            return true;
        }
        if(rec::ok(gocpp::recv(trace)))
        {
            traceRelease(trace);
        }
        if(sched.pidle != 0)
        {
            bool ok = {};
            systemstack([=]() mutable -> void
            {
                ok = exitsyscallfast_pidle();
                if(ok && ! goexperiment::ExecTracer2)
                {
                    auto trace = traceAcquire();
                    if(rec::ok(gocpp::recv(trace)))
                    {
                        if(oldp != nullptr)
                        {
                            for(; oldp->syscalltick == gp->m->syscalltick; )
                            {
                                osyield();
                            }
                        }
                        rec::GoSysExit(gocpp::recv(trace), true);
                        traceRelease(trace);
                    }
                }
            });
            if(ok)
            {
                return true;
            }
        }
        return false;
    }

    void exitsyscallfast_reacquired(struct traceLocker trace)
    {
        auto gp = getg();
        if(gp->m->syscalltick != rec::ptr(gocpp::recv(gp->m->p))->syscalltick)
        {
            if(rec::ok(gocpp::recv(trace)))
            {
                systemstack([=]() mutable -> void
                {
                    if(goexperiment::ExecTracer2)
                    {
                        rec::ProcSteal(gocpp::recv(trace), rec::ptr(gocpp::recv(gp->m->p)), true);
                        rec::ProcStart(gocpp::recv(trace));
                    }
                    else
                    {
                        rec::GoSysBlock(gocpp::recv(trace), rec::ptr(gocpp::recv(gp->m->p)));
                        rec::GoSysExit(gocpp::recv(trace), true);
                    }
                });
            }
            rec::ptr(gocpp::recv(gp->m->p))->syscalltick++;
        }
    }

    bool exitsyscallfast_pidle()
    {
        lock(& sched.lock);
        auto [pp, gocpp_id_16] = pidleget(0);
        if(pp != nullptr && rec::Load(gocpp::recv(sched.sysmonwait)))
        {
            rec::Store(gocpp::recv(sched.sysmonwait), false);
            notewakeup(& sched.sysmonnote);
        }
        unlock(& sched.lock);
        if(pp != nullptr)
        {
            acquirep(pp);
            return true;
        }
        return false;
    }

    void exitsyscall0(struct g* gp)
    {
        traceLocker trace = {};
        if(goexperiment::ExecTracer2)
        {
            traceExitingSyscall();
            trace = traceAcquire();
        }
        casgstatus(gp, _Gsyscall, _Grunnable);
        if(goexperiment::ExecTracer2)
        {
            traceExitedSyscall();
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::GoSysExit(gocpp::recv(trace), true);
                traceRelease(trace);
            }
        }
        dropg();
        lock(& sched.lock);
        p* pp = {};
        if(schedEnabled(gp))
        {
            std::tie(pp, gocpp_id_17) = pidleget(0);
        }
        bool locked = {};
        if(pp == nullptr)
        {
            globrunqput(gp);
            locked = gp->lockedm != 0;
        }
        else
        if(rec::Load(gocpp::recv(sched.sysmonwait)))
        {
            rec::Store(gocpp::recv(sched.sysmonwait), false);
            notewakeup(& sched.sysmonnote);
        }
        unlock(& sched.lock);
        if(pp != nullptr)
        {
            acquirep(pp);
            execute(gp, false);
        }
        if(locked)
        {
            stoplockedm();
            execute(gp, false);
        }
        stopm();
        schedule();
    }

    void syscall_runtime_BeforeFork()
    {
        auto gp = getg()->m->curg;
        gp->m->locks++;
        sigsave(& gp->m->sigmask);
        sigblock(false);
        gp->stackguard0 = stackFork;
    }

    void syscall_runtime_AfterFork()
    {
        auto gp = getg()->m->curg;
        gp->stackguard0 = gp->stack.lo + stackGuard;
        msigrestore(gp->m->sigmask);
        gp->m->locks--;
    }

    bool inForkedChild;
    void syscall_runtime_AfterForkInChild()
    {
        inForkedChild = true;
        clearSignalHandlers();
        msigrestore(getg()->m->sigmask);
        inForkedChild = false;
    }

    atomic::Int32 pendingPreemptSignals;
    void syscall_runtime_BeforeExec()
    {
        rec::lock(gocpp::recv(execLock));
        if(GOOS == "darwin" || GOOS == "ios")
        {
            for(; rec::Load(gocpp::recv(pendingPreemptSignals)) > 0; )
            {
                osyield();
            }
        }
    }

    void syscall_runtime_AfterExec()
    {
        rec::unlock(gocpp::recv(execLock));
    }

    struct g* malg(int32_t stacksize)
    {
        auto newg = new(g);
        if(stacksize >= 0)
        {
            stacksize = round2(stackSystem + stacksize);
            systemstack([=]() mutable -> void
            {
                newg->stack = stackalloc(uint32_t(stacksize));
            });
            newg->stackguard0 = newg->stack.lo + stackGuard;
            newg->stackguard1 = ~ uintptr_t(0);
            *(uintptr_t*)(unsafe::Pointer(newg->stack.lo)) = 0;
        }
        return newg;
    }

    void newproc(struct funcval* fn)
    {
        auto gp = getg();
        auto pc = getcallerpc();
        systemstack([=]() mutable -> void
        {
            auto newg = newproc1(fn, gp, pc);
            auto pp = rec::ptr(gocpp::recv(getg()->m->p));
            runqput(pp, newg, true);
            if(mainStarted)
            {
                wakep();
            }
        });
    }

    struct g* newproc1(struct funcval* fn, struct g* callergp, uintptr_t callerpc)
    {
        if(fn == nullptr)
        {
            fatal("go of nil func value");
        }
        auto mp = acquirem();
        auto pp = rec::ptr(gocpp::recv(mp->p));
        auto newg = gfget(pp);
        if(newg == nullptr)
        {
            newg = malg(stackMin);
            casgstatus(newg, _Gidle, _Gdead);
            allgadd(newg);
        }
        if(newg->stack.hi == 0)
        {
            go_throw("newproc1: newg missing stack");
        }
        if(readgstatus(newg) != _Gdead)
        {
            go_throw("newproc1: new g is not Gdead");
        }
        auto totalSize = uintptr_t(4 * goarch::PtrSize + sys::MinFrameSize);
        totalSize = alignUp(totalSize, sys::StackAlign);
        auto sp = newg->stack.hi - totalSize;
        if(usesLR)
        {
            *(uintptr_t*)(unsafe::Pointer(sp)) = 0;
            prepGoExitFrame(sp);
        }
        if(GOARCH == "arm64")
        {
            *(uintptr_t*)(unsafe::Pointer(sp - goarch::PtrSize)) = 0;
        }
        memclrNoHeapPointers(unsafe::Pointer(& newg->sched), gocpp::Sizeof<gobuf>());
        newg->sched.sp = sp;
        newg->stktopsp = sp;
        newg->sched.pc = abi::FuncPCABI0(goexit) + sys::PCQuantum;
        newg->sched.g = guintptr(unsafe::Pointer(newg));
        gostartcallfn(& newg->sched, fn);
        newg->parentGoid = callergp->goid;
        newg->gopc = callerpc;
        newg->ancestors = saveAncestors(callergp);
        newg->startpc = fn->fn;
        if(isSystemGoroutine(newg, false))
        {
            rec::Add(gocpp::recv(sched.ngsys), 1);
        }
        else
        {
            if(mp->curg != nullptr)
            {
                newg->labels = mp->curg->labels;
            }
            if(goroutineProfile.active)
            {
                rec::Store(gocpp::recv(newg->goroutineProfiled), goroutineProfileSatisfied);
            }
        }
        newg->trackingSeq = uint8_t(cheaprand());
        if(newg->trackingSeq % gTrackingPeriod == 0)
        {
            newg->tracking = true;
        }
        rec::addScannableStack(gocpp::recv(gcController), pp, int64_t(newg->stack.hi - newg->stack.lo));
        auto trace = traceAcquire();
        casgstatus(newg, _Gdead, _Grunnable);
        if(pp->goidcache == pp->goidcacheend)
        {
            pp->goidcache = rec::Add(gocpp::recv(sched.goidgen), _GoidCacheBatch);
            pp->goidcache -= _GoidCacheBatch - 1;
            pp->goidcacheend = pp->goidcache + _GoidCacheBatch;
        }
        newg->goid = pp->goidcache;
        pp->goidcache++;
        rec::reset(gocpp::recv(newg->trace));
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::GoCreate(gocpp::recv(trace), newg, newg->startpc);
            traceRelease(trace);
        }
        if(raceenabled)
        {
            newg->racectx = racegostart(callerpc);
            newg->raceignore = 0;
            if(newg->labels != nullptr)
            {
                racereleasemergeg(newg, unsafe::Pointer(& labelSync));
            }
        }
        releasem(mp);
        return newg;
    }

    gocpp::slice<ancestorInfo>* saveAncestors(struct g* callergp)
    {
        if(debug.tracebackancestors <= 0 || callergp->goid == 0)
        {
            return nullptr;
        }
        gocpp::slice<ancestorInfo> callerAncestors = {};
        if(callergp->ancestors != nullptr)
        {
            callerAncestors = *callergp->ancestors;
        }
        auto n = int32_t(len(callerAncestors)) + 1;
        if(n > debug.tracebackancestors)
        {
            n = debug.tracebackancestors;
        }
        auto ancestors = gocpp::make(gocpp::Tag<gocpp::slice<ancestorInfo>>(), n);
        copy(ancestors.make_slice(1), callerAncestors);
        gocpp::array<uintptr_t, tracebackInnerFrames> pcs = {};
        auto npcs = gcallers(callergp, 0, pcs.make_slice(0));
        auto ipcs = gocpp::make(gocpp::Tag<gocpp::slice<uintptr_t>>(), npcs);
        copy(ipcs, pcs.make_slice(0));
        ancestors[0] = gocpp::Init<ancestorInfo>([=](auto& x) {
            x.pcs = ipcs;
            x.goid = callergp->goid;
            x.gopc = callergp->gopc;
        });
        auto ancestorsp = new(gocpp::Tag<gocpp::slice<ancestorInfo>>());
        *ancestorsp = ancestors;
        return ancestorsp;
    }

    void gfput(struct p* pp, struct g* gp)
    {
        if(readgstatus(gp) != _Gdead)
        {
            go_throw("gfput: bad status (not Gdead)");
        }
        auto stksize = gp->stack.hi - gp->stack.lo;
        if(stksize != uintptr_t(startingStackSize))
        {
            stackfree(gp->stack);
            gp->stack.lo = 0;
            gp->stack.hi = 0;
            gp->stackguard0 = 0;
        }
        rec::push(gocpp::recv(pp->gFree), gp);
        pp->gFree.n++;
        if(pp->gFree.n >= 64)
        {
            int32_t inc = {};
            gQueue stackQ = {};
            gQueue noStackQ = {};
            for(; pp->gFree.n >= 32; )
            {
                auto gp = rec::pop(gocpp::recv(pp->gFree));
                pp->gFree.n--;
                if(gp->stack.lo == 0)
                {
                    rec::push(gocpp::recv(noStackQ), gp);
                }
                else
                {
                    rec::push(gocpp::recv(stackQ), gp);
                }
                inc++;
            }
            lock(& sched.gFree.lock);
            rec::pushAll(gocpp::recv(sched.gFree.noStack), noStackQ);
            rec::pushAll(gocpp::recv(sched.gFree.stack), stackQ);
            sched.gFree.n += inc;
            unlock(& sched.gFree.lock);
        }
    }

    struct g* gfget(struct p* pp)
    {
        retry:
        if(rec::empty(gocpp::recv(pp->gFree)) && (! rec::empty(gocpp::recv(sched.gFree.stack)) || ! rec::empty(gocpp::recv(sched.gFree.noStack))))
        {
            lock(& sched.gFree.lock);
            for(; pp->gFree.n < 32; )
            {
                auto gp = rec::pop(gocpp::recv(sched.gFree.stack));
                if(gp == nullptr)
                {
                    gp = rec::pop(gocpp::recv(sched.gFree.noStack));
                    if(gp == nullptr)
                    {
                        break;
                    }
                }
                sched.gFree.n--;
                rec::push(gocpp::recv(pp->gFree), gp);
                pp->gFree.n++;
            }
            unlock(& sched.gFree.lock);
            goto retry;
        }
        auto gp = rec::pop(gocpp::recv(pp->gFree));
        if(gp == nullptr)
        {
            return nullptr;
        }
        pp->gFree.n--;
        if(gp->stack.lo != 0 && gp->stack.hi - gp->stack.lo != uintptr_t(startingStackSize))
        {
            systemstack([=]() mutable -> void
            {
                stackfree(gp->stack);
                gp->stack.lo = 0;
                gp->stack.hi = 0;
                gp->stackguard0 = 0;
            });
        }
        if(gp->stack.lo == 0)
        {
            systemstack([=]() mutable -> void
            {
                gp->stack = stackalloc(startingStackSize);
            });
            gp->stackguard0 = gp->stack.lo + stackGuard;
        }
        else
        {
            if(raceenabled)
            {
                racemalloc(unsafe::Pointer(gp->stack.lo), gp->stack.hi - gp->stack.lo);
            }
            if(msanenabled)
            {
                msanmalloc(unsafe::Pointer(gp->stack.lo), gp->stack.hi - gp->stack.lo);
            }
            if(asanenabled)
            {
                asanunpoison(unsafe::Pointer(gp->stack.lo), gp->stack.hi - gp->stack.lo);
            }
        }
        return gp;
    }

    void gfpurge(struct p* pp)
    {
        int32_t inc = {};
        gQueue stackQ = {};
        gQueue noStackQ = {};
        for(; ! rec::empty(gocpp::recv(pp->gFree)); )
        {
            auto gp = rec::pop(gocpp::recv(pp->gFree));
            pp->gFree.n--;
            if(gp->stack.lo == 0)
            {
                rec::push(gocpp::recv(noStackQ), gp);
            }
            else
            {
                rec::push(gocpp::recv(stackQ), gp);
            }
            inc++;
        }
        lock(& sched.gFree.lock);
        rec::pushAll(gocpp::recv(sched.gFree.noStack), noStackQ);
        rec::pushAll(gocpp::recv(sched.gFree.stack), stackQ);
        sched.gFree.n += inc;
        unlock(& sched.gFree.lock);
    }

    void Breakpoint()
    {
        breakpoint();
    }

    void dolockOSThread()
    {
        if(GOARCH == "wasm")
        {
            return;
        }
        auto gp = getg();
        rec::set(gocpp::recv(gp->m->lockedg), gp);
        rec::set(gocpp::recv(gp->lockedm), gp->m);
    }

    void LockOSThread()
    {
        if(atomic::Load(& newmHandoff.haveTemplateThread) == 0 && GOOS != "plan9")
        {
            startTemplateThread();
        }
        auto gp = getg();
        gp->m->lockedExt++;
        if(gp->m->lockedExt == 0)
        {
            gp->m->lockedExt--;
            gocpp::panic("LockOSThread nesting overflow");
        }
        dolockOSThread();
    }

    void lockOSThread()
    {
        getg()->m->lockedInt++;
        dolockOSThread();
    }

    void dounlockOSThread()
    {
        if(GOARCH == "wasm")
        {
            return;
        }
        auto gp = getg();
        if(gp->m->lockedInt != 0 || gp->m->lockedExt != 0)
        {
            return;
        }
        gp->m->lockedg = 0;
        gp->lockedm = 0;
    }

    void UnlockOSThread()
    {
        auto gp = getg();
        if(gp->m->lockedExt == 0)
        {
            return;
        }
        gp->m->lockedExt--;
        dounlockOSThread();
    }

    void unlockOSThread()
    {
        auto gp = getg();
        if(gp->m->lockedInt == 0)
        {
            systemstack(badunlockosthread);
        }
        gp->m->lockedInt--;
        dounlockOSThread();
    }

    void badunlockosthread()
    {
        go_throw("runtime: internal error: misuse of lockOSThread/unlockOSThread");
    }

    int32_t gcount()
    {
        auto n = int32_t(atomic::Loaduintptr(& allglen)) - sched.gFree.n - rec::Load(gocpp::recv(sched.ngsys));
        for(auto [gocpp_ignored, pp] : allp)
        {
            n -= pp->gFree.n;
        }
        if(n < 1)
        {
            n = 1;
        }
        return n;
    }

    int32_t mcount()
    {
        return int32_t(sched.mnext - sched.nmfreed);
    }

    struct gocpp_id_18
    {
        atomic::Uint32 signalLock;
        atomic::Int32 hz;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T()
        {
            T result;
            result.signalLock = this->signalLock;
            result.hz = this->hz;
            return result;
        }

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const
        {
            if (signalLock != ref.signalLock) return false;
            if (hz != ref.hz) return false;
            return true;
        }

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << "" << signalLock;
            os << " " << hz;
            os << '}';
            return os;
        }
    };

    std::ostream& operator<<(std::ostream& os, const struct gocpp_id_18& value)
    {
        return value.PrintTo(os);
    }


    gocpp_id_18 prof;
    void _System()
    {
        _System();
    }

    void _ExternalCode()
    {
        _ExternalCode();
    }

    void _LostExternalCode()
    {
        _LostExternalCode();
    }

    void _GC()
    {
        _GC();
    }

    void _LostSIGPROFDuringAtomic64()
    {
        _LostSIGPROFDuringAtomic64();
    }

    void _LostContendedRuntimeLock()
    {
        _LostContendedRuntimeLock();
    }

    void _VDSO()
    {
        _VDSO();
    }

    void sigprof(uintptr_t pc, uintptr_t sp, uintptr_t lr, struct g* gp, struct m* mp)
    {
        if(rec::Load(gocpp::recv(prof.hz)) == 0)
        {
            return;
        }
        if(mp != nullptr && mp->profilehz == 0)
        {
            return;
        }
        if(GOARCH == "mips" || GOARCH == "mipsle" || GOARCH == "arm")
        {
            if(auto f = findfunc(pc); rec::valid(gocpp::recv(f)))
            {
                if(hasPrefix(funcname(f), "runtime/internal/atomic"))
                {
                    cpuprof.lostAtomic++;
                    return;
                }
            }
            if(GOARCH == "arm" && goarm < 7 && GOOS == "linux" && pc & 0xffff0000 == 0xffff0000)
            {
                cpuprof.lostAtomic++;
                return;
            }
        }
        getg()->m->mallocing++;
        unwinder u = {};
        gocpp::array<uintptr_t, maxCPUProfStack> stk = {};
        auto n = 0;
        if(mp->ncgo > 0 && mp->curg != nullptr && mp->curg->syscallpc != 0 && mp->curg->syscallsp != 0)
        {
            auto cgoOff = 0;
            if(rec::Load(gocpp::recv(mp->cgoCallersUse)) == 0 && mp->cgoCallers != nullptr && mp->cgoCallers[0] != 0)
            {
                for(; cgoOff < len(mp->cgoCallers) && mp->cgoCallers[cgoOff] != 0; )
                {
                    cgoOff++;
                }
                n += copy(stk.make_slice(0), mp->cgoCallers.make_slice(0, cgoOff));
                mp->cgoCallers[0] = 0;
            }
            rec::initAt(gocpp::recv(u), mp->curg->syscallpc, mp->curg->syscallsp, 0, mp->curg, unwindSilentErrors);
        }
        else
        if(usesLibcall() && mp->libcallg != 0 && mp->libcallpc != 0 && mp->libcallsp != 0)
        {
            rec::initAt(gocpp::recv(u), mp->libcallpc, mp->libcallsp, 0, rec::ptr(gocpp::recv(mp->libcallg)), unwindSilentErrors);
        }
        else
        if(mp != nullptr && mp->vdsoSP != 0)
        {
            rec::initAt(gocpp::recv(u), mp->vdsoPC, mp->vdsoSP, 0, gp, unwindSilentErrors | unwindJumpStack);
        }
        else
        {
            rec::initAt(gocpp::recv(u), pc, sp, lr, gp, unwindSilentErrors | unwindTrap | unwindJumpStack);
        }
        n += tracebackPCs(& u, 0, stk.make_slice(n));
        if(n <= 0)
        {
            n = 2;
            if(inVDSOPage(pc))
            {
                pc = abi::FuncPCABIInternal(_VDSO) + sys::PCQuantum;
            }
            else
            if(pc > firstmoduledata.etext)
            {
                pc = abi::FuncPCABIInternal(_ExternalCode) + sys::PCQuantum;
            }
            stk[0] = pc;
            if(mp->preemptoff != "")
            {
                stk[1] = abi::FuncPCABIInternal(_GC) + sys::PCQuantum;
            }
            else
            {
                stk[1] = abi::FuncPCABIInternal(_System) + sys::PCQuantum;
            }
        }
        if(rec::Load(gocpp::recv(prof.hz)) != 0)
        {
            unsafe::Pointer* tagPtr = {};
            if(gp != nullptr && gp->m != nullptr && gp->m->curg != nullptr)
            {
                tagPtr = & gp->m->curg->labels;
            }
            rec::add(gocpp::recv(cpuprof), tagPtr, stk.make_slice(0, n));
            auto gprof = gp;
            m* mp = {};
            p* pp = {};
            if(gp != nullptr && gp->m != nullptr)
            {
                if(gp->m->curg != nullptr)
                {
                    gprof = gp->m->curg;
                }
                mp = gp->m;
                pp = rec::ptr(gocpp::recv(gp->m->p));
            }
            traceCPUSample(gprof, mp, pp, stk.make_slice(0, n));
        }
        getg()->m->mallocing--;
    }

    void setcpuprofilerate(int32_t hz)
    {
        if(hz < 0)
        {
            hz = 0;
        }
        auto gp = getg();
        gp->m->locks++;
        setThreadCPUProfiler(0);
        for(; ! rec::CompareAndSwap(gocpp::recv(prof.signalLock), 0, 1); )
        {
            osyield();
        }
        if(rec::Load(gocpp::recv(prof.hz)) != hz)
        {
            setProcessCPUProfiler(hz);
            rec::Store(gocpp::recv(prof.hz), hz);
        }
        rec::Store(gocpp::recv(prof.signalLock), 0);
        lock(& sched.lock);
        sched.profilehz = hz;
        unlock(& sched.lock);
        if(hz != 0)
        {
            setThreadCPUProfiler(hz);
        }
        gp->m->locks--;
    }

    void rec::init(struct p* pp, int32_t id)
    {
        pp->id = id;
        pp->status = _Pgcstop;
        pp->sudogcache = pp->sudogbuf.make_slice(0, 0);
        pp->deferpool = pp->deferpoolbuf.make_slice(0, 0);
        rec::reset(gocpp::recv(pp->wbBuf));
        if(pp->mcache == nullptr)
        {
            if(id == 0)
            {
                if(mcache0 == nullptr)
                {
                    go_throw("missing mcache?");
                }
                pp->mcache = mcache0;
            }
            else
            {
                pp->mcache = allocmcache();
            }
        }
        if(raceenabled && pp->raceprocctx == 0)
        {
            if(id == 0)
            {
                pp->raceprocctx = raceprocctx0;
                raceprocctx0 = 0;
            }
            else
            {
                pp->raceprocctx = raceproccreate();
            }
        }
        lockInit(& pp->timersLock, lockRankTimers);
        rec::set(gocpp::recv(timerpMask), id);
        rec::clear(gocpp::recv(idlepMask), id);
    }

    void rec::destroy(struct p* pp)
    {
        assertLockHeld(& sched.lock);
        assertWorldStopped();
        for(; pp->runqhead != pp->runqtail; )
        {
            pp->runqtail--;
            auto gp = rec::ptr(gocpp::recv(pp->runq[pp->runqtail % uint32_t(len(pp->runq))]));
            globrunqputhead(gp);
        }
        if(pp->runnext != 0)
        {
            globrunqputhead(rec::ptr(gocpp::recv(pp->runnext)));
            pp->runnext = 0;
        }
        if(len(pp->timers) > 0)
        {
            auto plocal = rec::ptr(gocpp::recv(getg()->m->p));
            lock(& plocal->timersLock);
            lock(& pp->timersLock);
            moveTimers(plocal, pp->timers);
            pp->timers = nullptr;
            rec::Store(gocpp::recv(pp->numTimers), 0);
            rec::Store(gocpp::recv(pp->deletedTimers), 0);
            rec::Store(gocpp::recv(pp->timer0When), 0);
            unlock(& pp->timersLock);
            unlock(& plocal->timersLock);
        }
        if(gcphase != _GCoff)
        {
            wbBufFlush1(pp);
            rec::dispose(gocpp::recv(pp->gcw));
        }
        for(auto [i, gocpp_ignored] : pp->sudogbuf)
        {
            pp->sudogbuf[i] = nullptr;
        }
        pp->sudogcache = pp->sudogbuf.make_slice(0, 0);
        pp->pinnerCache = nullptr;
        for(auto [j, gocpp_ignored] : pp->deferpoolbuf)
        {
            pp->deferpoolbuf[j] = nullptr;
        }
        pp->deferpool = pp->deferpoolbuf.make_slice(0, 0);
        systemstack([=]() mutable -> void
        {
            for(auto i = 0; i < pp->mspancache.len; i++)
            {
                rec::free(gocpp::recv(mheap_.spanalloc), unsafe::Pointer(pp->mspancache.buf[i]));
            }
            pp->mspancache.len = 0;
            lock(& mheap_.lock);
            rec::flush(gocpp::recv(pp->pcache), & mheap_.pages);
            unlock(& mheap_.lock);
        });
        freemcache(pp->mcache);
        pp->mcache = nullptr;
        gfpurge(pp);
        traceProcFree(pp);
        if(raceenabled)
        {
            if(pp->timerRaceCtx != 0)
            {
                auto mp = getg()->m;
                auto phold = rec::ptr(gocpp::recv(mp->p));
                rec::set(gocpp::recv(mp->p), pp);
                racectxend(pp->timerRaceCtx);
                pp->timerRaceCtx = 0;
                rec::set(gocpp::recv(mp->p), phold);
            }
            raceprocdestroy(pp->raceprocctx);
            pp->raceprocctx = 0;
        }
        pp->gcAssistTime = 0;
        pp->status = _Pdead;
    }

    struct p* procresize(int32_t nprocs)
    {
        assertLockHeld(& sched.lock);
        assertWorldStopped();
        auto old = gomaxprocs;
        if(old < 0 || nprocs <= 0)
        {
            go_throw("procresize: invalid arg");
        }
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::Gomaxprocs(gocpp::recv(trace), nprocs);
            traceRelease(trace);
        }
        auto now = nanotime();
        if(sched.procresizetime != 0)
        {
            sched.totaltime += int64_t(old) * (now - sched.procresizetime);
        }
        sched.procresizetime = now;
        auto maskWords = (nprocs + 31) / 32;
        if(nprocs > int32_t(len(allp)))
        {
            lock(& allpLock);
            if(nprocs <= int32_t(cap(allp)))
            {
                allp = allp.make_slice(0, nprocs);
            }
            else
            {
                auto nallp = gocpp::make(gocpp::Tag<gocpp::slice<p*>>(), nprocs);
                copy(nallp, allp.make_slice(0, cap(allp)));
                allp = nallp;
            }
            if(maskWords <= int32_t(cap(idlepMask)))
            {
                idlepMask = idlepMask.make_slice(0, maskWords);
                timerpMask = timerpMask.make_slice(0, maskWords);
            }
            else
            {
                auto nidlepMask = gocpp::make(gocpp::Tag<gocpp::slice<uint32_t>>(), maskWords);
                copy(nidlepMask, idlepMask);
                idlepMask = nidlepMask;
                auto ntimerpMask = gocpp::make(gocpp::Tag<gocpp::slice<uint32_t>>(), maskWords);
                copy(ntimerpMask, timerpMask);
                timerpMask = ntimerpMask;
            }
            unlock(& allpLock);
        }
        for(auto i = old; i < nprocs; i++)
        {
            auto pp = allp[i];
            if(pp == nullptr)
            {
                pp = new(p);
            }
            rec::init(gocpp::recv(pp), i);
            atomicstorep(unsafe::Pointer(& allp[i]), unsafe::Pointer(pp));
        }
        auto gp = getg();
        if(gp->m->p != 0 && rec::ptr(gocpp::recv(gp->m->p))->id < nprocs)
        {
            rec::ptr(gocpp::recv(gp->m->p))->status = _Prunning;
            rec::prepareForSweep(gocpp::recv(rec::ptr(gocpp::recv(gp->m->p))->mcache));
        }
        else
        {
            if(gp->m->p != 0)
            {
                auto trace = traceAcquire();
                if(rec::ok(gocpp::recv(trace)))
                {
                    rec::GoSched(gocpp::recv(trace));
                    rec::ProcStop(gocpp::recv(trace), rec::ptr(gocpp::recv(gp->m->p)));
                    traceRelease(trace);
                }
                rec::ptr(gocpp::recv(gp->m->p))->m = 0;
            }
            gp->m->p = 0;
            auto pp = allp[0];
            pp->m = 0;
            pp->status = _Pidle;
            acquirep(pp);
            auto trace = traceAcquire();
            if(rec::ok(gocpp::recv(trace)))
            {
                rec::GoStart(gocpp::recv(trace));
                traceRelease(trace);
            }
        }
        mcache0 = nullptr;
        for(auto i = nprocs; i < old; i++)
        {
            auto pp = allp[i];
            rec::destroy(gocpp::recv(pp));
        }
        if(int32_t(len(allp)) != nprocs)
        {
            lock(& allpLock);
            allp = allp.make_slice(0, nprocs);
            idlepMask = idlepMask.make_slice(0, maskWords);
            timerpMask = timerpMask.make_slice(0, maskWords);
            unlock(& allpLock);
        }
        p* runnablePs = {};
        for(auto i = nprocs - 1; i >= 0; i--)
        {
            auto pp = allp[i];
            if(rec::ptr(gocpp::recv(gp->m->p)) == pp)
            {
                continue;
            }
            pp->status = _Pidle;
            if(runqempty(pp))
            {
                pidleput(pp, now);
            }
            else
            {
                rec::set(gocpp::recv(pp->m), mget());
                rec::set(gocpp::recv(pp->link), runnablePs);
                runnablePs = pp;
            }
        }
        rec::reset(gocpp::recv(stealOrder), uint32_t(nprocs));
        int32_t* int32p = & gomaxprocs;
        atomic::Store((uint32_t*)(unsafe::Pointer(int32p)), uint32_t(nprocs));
        if(old != nprocs)
        {
            rec::resetCapacity(gocpp::recv(gcCPULimiter), now, nprocs);
        }
        return runnablePs;
    }

    void acquirep(struct p* pp)
    {
        wirep(pp);
        rec::prepareForSweep(gocpp::recv(pp->mcache));
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::ProcStart(gocpp::recv(trace));
            traceRelease(trace);
        }
    }

    void wirep(struct p* pp)
    {
        auto gp = getg();
        if(gp->m->p != 0)
        {
            systemstack([=]() mutable -> void
            {
                go_throw("wirep: already in go");
            });
        }
        if(pp->m != 0 || pp->status != _Pidle)
        {
            systemstack([=]() mutable -> void
            {
                auto id = int64_t(0);
                if(pp->m != 0)
                {
                    id = rec::ptr(gocpp::recv(pp->m))->id;
                }
                print("wirep: p->m=", pp->m, "(", id, ") p->status=", pp->status, "\n");
                go_throw("wirep: invalid p state");
            });
        }
        rec::set(gocpp::recv(gp->m->p), pp);
        rec::set(gocpp::recv(pp->m), gp->m);
        pp->status = _Prunning;
    }

    struct p* releasep()
    {
        auto trace = traceAcquire();
        if(rec::ok(gocpp::recv(trace)))
        {
            rec::ProcStop(gocpp::recv(trace), rec::ptr(gocpp::recv(getg()->m->p)));
            traceRelease(trace);
        }
        return releasepNoTrace();
    }

    struct p* releasepNoTrace()
    {
        auto gp = getg();
        if(gp->m->p == 0)
        {
            go_throw("releasep: invalid arg");
        }
        auto pp = rec::ptr(gocpp::recv(gp->m->p));
        if(rec::ptr(gocpp::recv(pp->m)) != gp->m || pp->status != _Prunning)
        {
            print("releasep: m=", gp->m, " m->p=", rec::ptr(gocpp::recv(gp->m->p)), " p->m=", hex(pp->m), " p->status=", pp->status, "\n");
            go_throw("releasep: invalid p state");
        }
        gp->m->p = 0;
        pp->m = 0;
        pp->status = _Pidle;
        return pp;
    }

    void incidlelocked(int32_t v)
    {
        lock(& sched.lock);
        sched.nmidlelocked += v;
        if(v > 0)
        {
            checkdead();
        }
        unlock(& sched.lock);
    }

    void checkdead()
    {
        assertLockHeld(& sched.lock);
        if(islibrary || isarchive)
        {
            return;
        }
        if(rec::Load(gocpp::recv(panicking)) > 0)
        {
            return;
        }
        int32_t run0 = {};
        if(! iscgo && cgoHasExtraM && rec::Load(gocpp::recv(extraMLength)) > 0)
        {
            run0 = 1;
        }
        auto run = mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys;
        if(run > run0)
        {
            return;
        }
        if(run < 0)
        {
            print("runtime: checkdead: nmidle=", sched.nmidle, " nmidlelocked=", sched.nmidlelocked, " mcount=", mcount(), " nmsys=", sched.nmsys, "\n");
            unlock(& sched.lock);
            go_throw("checkdead: inconsistent counts");
        }
        auto grunning = 0;
        forEachG([=](struct g* gp) mutable -> void
        {
            if(isSystemGoroutine(gp, false))
            {
                return;
            }
            auto s = readgstatus(gp);
            //Go switch emulation
            {
                auto condition = s &^ _Gscan;
                int conditionId = -1;
                if(condition == _Gwaiting) { conditionId = 0; }
                else if(condition == _Gpreempted) { conditionId = 1; }
                else if(condition == _Grunnable) { conditionId = 2; }
                else if(condition == _Grunning) { conditionId = 3; }
                else if(condition == _Gsyscall) { conditionId = 4; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        grunning++;
                        break;
                    case 2:
                    case 3:
                    case 4:
                        print("runtime: checkdead: find g ", gp->goid, " in status ", s, "\n");
                        unlock(& sched.lock);
                        go_throw("checkdead: runnable g");
                        break;
                }
            }
        });
        if(grunning == 0)
        {
            unlock(& sched.lock);
            fatal("no goroutines (main called runtime.Goexit) - deadlock!");
        }
        if(faketime != 0)
        {
            if(auto when = timeSleepUntil(); when < maxWhen)
            {
                faketime = when;
                auto [pp, gocpp_id_20] = pidleget(faketime);
                if(pp == nullptr)
                {
                    unlock(& sched.lock);
                    go_throw("checkdead: no p for timer");
                }
                auto mp = mget();
                if(mp == nullptr)
                {
                    unlock(& sched.lock);
                    go_throw("checkdead: no m for timer");
                }
                rec::Add(gocpp::recv(sched.nmspinning), 1);
                mp->spinning = true;
                rec::set(gocpp::recv(mp->nextp), pp);
                notewakeup(& mp->park);
                return;
            }
        }
        for(auto [gocpp_ignored, pp] : allp)
        {
            if(len(pp->timers) > 0)
            {
                return;
            }
        }
        unlock(& sched.lock);
        fatal("all goroutines are asleep - deadlock!");
    }

    int64_t forcegcperiod = 2 * 60 * 1e9;
    bool needSysmonWorkaround = false;
    void sysmon()
    {
        lock(& sched.lock);
        sched.nmsys++;
        checkdead();
        unlock(& sched.lock);
        auto lasttrace = int64_t(0);
        auto idle = 0;
        auto delay = uint32_t(0);
        for(; ; )
        {
            if(idle == 0)
            {
                delay = 20;
            }
            else
            if(idle > 50)
            {
                delay *= 2;
            }
            if(delay > 10 * 1000)
            {
                delay = 10 * 1000;
            }
            usleep(delay);
            auto now = nanotime();
            if(debug.schedtrace <= 0 && (rec::Load(gocpp::recv(sched.gcwaiting)) || rec::Load(gocpp::recv(sched.npidle)) == gomaxprocs))
            {
                lock(& sched.lock);
                if(rec::Load(gocpp::recv(sched.gcwaiting)) || rec::Load(gocpp::recv(sched.npidle)) == gomaxprocs)
                {
                    auto syscallWake = false;
                    auto next = timeSleepUntil();
                    if(next > now)
                    {
                        rec::Store(gocpp::recv(sched.sysmonwait), true);
                        unlock(& sched.lock);
                        auto sleep = forcegcperiod / 2;
                        if(next - now < sleep)
                        {
                            sleep = next - now;
                        }
                        auto shouldRelax = sleep >= osRelaxMinNS;
                        if(shouldRelax)
                        {
                            osRelax(true);
                        }
                        syscallWake = notetsleep(& sched.sysmonnote, sleep);
                        if(shouldRelax)
                        {
                            osRelax(false);
                        }
                        lock(& sched.lock);
                        rec::Store(gocpp::recv(sched.sysmonwait), false);
                        noteclear(& sched.sysmonnote);
                    }
                    if(syscallWake)
                    {
                        idle = 0;
                        delay = 20;
                    }
                }
                unlock(& sched.lock);
            }
            lock(& sched.sysmonlock);
            now = nanotime();
            if(*cgo_yield != nullptr)
            {
                asmcgocall(*cgo_yield, nullptr);
            }
            auto lastpoll = rec::Load(gocpp::recv(sched.lastpoll));
            if(netpollinited() && lastpoll != 0 && lastpoll + 10 * 1000 * 1000 < now)
            {
                rec::CompareAndSwap(gocpp::recv(sched.lastpoll), lastpoll, now);
                auto [list, delta] = netpoll(0);
                if(! rec::empty(gocpp::recv(list)))
                {
                    incidlelocked(- 1);
                    injectglist(& list);
                    incidlelocked(1);
                    netpollAdjustWaiters(delta);
                }
            }
            if(GOOS == "netbsd" && needSysmonWorkaround)
            {
                if(auto next = timeSleepUntil(); next < now)
                {
                    startm(nullptr, false, false);
                }
            }
            if(rec::Load(gocpp::recv(scavenger.sysmonWake)) != 0)
            {
                rec::wake(gocpp::recv(scavenger));
            }
            if(retake(now) != 0)
            {
                idle = 0;
            }
            else
            {
                idle++;
            }
            if(auto t = (gocpp::Init<gcTrigger>([=](auto& x) {
                x.kind = gcTriggerTime;
                x.now = now;
            })); rec::test(gocpp::recv(t)) && rec::Load(gocpp::recv(forcegc.idle)))
            {
                lock(& forcegc.lock);
                rec::Store(gocpp::recv(forcegc.idle), false);
                gList list = {};
                rec::push(gocpp::recv(list), forcegc.g);
                injectglist(& list);
                unlock(& forcegc.lock);
            }
            if(debug.schedtrace > 0 && lasttrace + int64_t(debug.schedtrace) * 1000000 <= now)
            {
                lasttrace = now;
                schedtrace(debug.scheddetail > 0);
            }
            unlock(& sched.sysmonlock);
        }
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    sysmontick::operator T()
    {
        T result;
        result.schedtick = this->schedtick;
        result.schedwhen = this->schedwhen;
        result.syscalltick = this->syscalltick;
        result.syscallwhen = this->syscallwhen;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool sysmontick::operator==(const T& ref) const
    {
        if (schedtick != ref.schedtick) return false;
        if (schedwhen != ref.schedwhen) return false;
        if (syscalltick != ref.syscalltick) return false;
        if (syscallwhen != ref.syscallwhen) return false;
        return true;
    }

    std::ostream& sysmontick::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << schedtick;
        os << " " << schedwhen;
        os << " " << syscalltick;
        os << " " << syscallwhen;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sysmontick& value)
    {
        return value.PrintTo(os);
    }

    uint32_t retake(int64_t now)
    {
        auto n = 0;
        lock(& allpLock);
        for(auto i = 0; i < len(allp); i++)
        {
            auto pp = allp[i];
            if(pp == nullptr)
            {
                continue;
            }
            auto pd = & pp->sysmontick;
            auto s = pp->status;
            auto sysretake = false;
            if(s == _Prunning || s == _Psyscall)
            {
                auto t = int64_t(pp->schedtick);
                if(int64_t(pd->schedtick) != t)
                {
                    pd->schedtick = uint32_t(t);
                    pd->schedwhen = now;
                }
                else
                if(pd->schedwhen + forcePreemptNS <= now)
                {
                    preemptone(pp);
                    sysretake = true;
                }
            }
            if(s == _Psyscall)
            {
                auto t = int64_t(pp->syscalltick);
                if(! sysretake && int64_t(pd->syscalltick) != t)
                {
                    pd->syscalltick = uint32_t(t);
                    pd->syscallwhen = now;
                    continue;
                }
                if(runqempty(pp) && rec::Load(gocpp::recv(sched.nmspinning)) + rec::Load(gocpp::recv(sched.npidle)) > 0 && pd->syscallwhen + 10 * 1000 * 1000 > now)
                {
                    continue;
                }
                unlock(& allpLock);
                incidlelocked(- 1);
                auto trace = traceAcquire();
                if(atomic::Cas(& pp->status, s, _Pidle))
                {
                    if(rec::ok(gocpp::recv(trace)))
                    {
                        rec::GoSysBlock(gocpp::recv(trace), pp);
                        rec::ProcSteal(gocpp::recv(trace), pp, false);
                        traceRelease(trace);
                    }
                    n++;
                    pp->syscalltick++;
                    handoffp(pp);
                }
                else
                if(rec::ok(gocpp::recv(trace)))
                {
                    traceRelease(trace);
                }
                incidlelocked(1);
                lock(& allpLock);
            }
        }
        unlock(& allpLock);
        return uint32_t(n);
    }

    bool preemptall()
    {
        auto res = false;
        for(auto [gocpp_ignored, pp] : allp)
        {
            if(pp->status != _Prunning)
            {
                continue;
            }
            if(preemptone(pp))
            {
                res = true;
            }
        }
        return res;
    }

    bool preemptone(struct p* pp)
    {
        auto mp = rec::ptr(gocpp::recv(pp->m));
        if(mp == nullptr || mp == getg()->m)
        {
            return false;
        }
        auto gp = mp->curg;
        if(gp == nullptr || gp == mp->g0)
        {
            return false;
        }
        gp->preempt = true;
        gp->stackguard0 = stackPreempt;
        if(preemptMSupported && debug.asyncpreemptoff == 0)
        {
            pp->preempt = true;
            preemptM(mp);
        }
        return true;
    }

    int64_t starttime;
    void schedtrace(bool detailed)
    {
        auto now = nanotime();
        if(starttime == 0)
        {
            starttime = now;
        }
        lock(& sched.lock);
        print("SCHED ", (now - starttime) / 1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", rec::Load(gocpp::recv(sched.npidle)), " threads=", mcount(), " spinningthreads=", rec::Load(gocpp::recv(sched.nmspinning)), " needspinning=", rec::Load(gocpp::recv(sched.needspinning)), " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize);
        if(detailed)
        {
            print(" gcwaiting=", rec::Load(gocpp::recv(sched.gcwaiting)), " nmidlelocked=", sched.nmidlelocked, " stopwait=", sched.stopwait, " sysmonwait=", rec::Load(gocpp::recv(sched.sysmonwait)), "\n");
        }
        for(auto [i, pp] : allp)
        {
            auto mp = rec::ptr(gocpp::recv(pp->m));
            auto h = atomic::Load(& pp->runqhead);
            auto t = atomic::Load(& pp->runqtail);
            if(detailed)
            {
                print("  P", i, ": status=", pp->status, " schedtick=", pp->schedtick, " syscalltick=", pp->syscalltick, " m=");
                if(mp != nullptr)
                {
                    print(mp->id);
                }
                else
                {
                    print("nil");
                }
                print(" runqsize=", t - h, " gfreecnt=", pp->gFree.n, " timerslen=", len(pp->timers), "\n");
            }
            else
            {
                print(" ");
                if(i == 0)
                {
                    print("[");
                }
                print(t - h);
                if(i == len(allp) - 1)
                {
                    print("]\n");
                }
            }
        }
        if(! detailed)
        {
            unlock(& sched.lock);
            return;
        }
        for(auto mp = allm; mp != nullptr; mp = mp->alllink)
        {
            auto pp = rec::ptr(gocpp::recv(mp->p));
            print("  M", mp->id, ": p=");
            if(pp != nullptr)
            {
                print(pp->id);
            }
            else
            {
                print("nil");
            }
            print(" curg=");
            if(mp->curg != nullptr)
            {
                print(mp->curg->goid);
            }
            else
            {
                print("nil");
            }
            print(" mallocing=", mp->mallocing, " throwing=", mp->throwing, " preemptoff=", mp->preemptoff, " locks=", mp->locks, " dying=", mp->dying, " spinning=", mp->spinning, " blocked=", mp->blocked, " lockedg=");
            if(auto lockedg = rec::ptr(gocpp::recv(mp->lockedg)); lockedg != nullptr)
            {
                print(lockedg->goid);
            }
            else
            {
                print("nil");
            }
            print("\n");
        }
        forEachG([=](struct g* gp) mutable -> void
        {
            print("  G", gp->goid, ": status=", readgstatus(gp), "(", rec::String(gocpp::recv(gp->waitreason)), ") m=");
            if(gp->m != nullptr)
            {
                print(gp->m->id);
            }
            else
            {
                print("nil");
            }
            print(" lockedm=");
            if(auto lockedm = rec::ptr(gocpp::recv(gp->lockedm)); lockedm != nullptr)
            {
                print(lockedm->id);
            }
            else
            {
                print("nil");
            }
            print("\n");
        });
        unlock(& sched.lock);
    }

    void schedEnableUser(bool enable)
    {
        lock(& sched.lock);
        if(sched.disable.user == ! enable)
        {
            unlock(& sched.lock);
            return;
        }
        sched.disable.user = ! enable;
        if(enable)
        {
            auto n = sched.disable.n;
            sched.disable.n = 0;
            globrunqputbatch(& sched.disable.runnable, n);
            unlock(& sched.lock);
            for(; n != 0 && rec::Load(gocpp::recv(sched.npidle)) != 0; n--)
            {
                startm(nullptr, false, false);
            }
        }
        else
        {
            unlock(& sched.lock);
        }
    }

    bool schedEnabled(struct g* gp)
    {
        assertLockHeld(& sched.lock);
        if(sched.disable.user)
        {
            return isSystemGoroutine(gp, true);
        }
        return true;
    }

    void mput(struct m* mp)
    {
        assertLockHeld(& sched.lock);
        mp->schedlink = sched.midle;
        rec::set(gocpp::recv(sched.midle), mp);
        sched.nmidle++;
        checkdead();
    }

    struct m* mget()
    {
        assertLockHeld(& sched.lock);
        auto mp = rec::ptr(gocpp::recv(sched.midle));
        if(mp != nullptr)
        {
            sched.midle = mp->schedlink;
            sched.nmidle--;
        }
        return mp;
    }

    void globrunqput(struct g* gp)
    {
        assertLockHeld(& sched.lock);
        rec::pushBack(gocpp::recv(sched.runq), gp);
        sched.runqsize++;
    }

    void globrunqputhead(struct g* gp)
    {
        assertLockHeld(& sched.lock);
        rec::push(gocpp::recv(sched.runq), gp);
        sched.runqsize++;
    }

    void globrunqputbatch(struct gQueue* batch, int32_t n)
    {
        assertLockHeld(& sched.lock);
        rec::pushBackAll(gocpp::recv(sched.runq), *batch);
        sched.runqsize += n;
        *batch = gQueue {};
    }

    struct g* globrunqget(struct p* pp, int32_t max)
    {
        assertLockHeld(& sched.lock);
        if(sched.runqsize == 0)
        {
            return nullptr;
        }
        auto n = sched.runqsize / gomaxprocs + 1;
        if(n > sched.runqsize)
        {
            n = sched.runqsize;
        }
        if(max > 0 && n > max)
        {
            n = max;
        }
        if(n > int32_t(len(pp->runq)) / 2)
        {
            n = int32_t(len(pp->runq)) / 2;
        }
        sched.runqsize -= n;
        auto gp = rec::pop(gocpp::recv(sched.runq));
        n--;
        for(; n > 0; n--)
        {
            auto gp1 = rec::pop(gocpp::recv(sched.runq));
            runqput(pp, gp1, false);
        }
        return gp;
    }

    bool rec::read(golang::runtime::pMask p, uint32_t id)
    {
        auto word = id / 32;
        auto mask = uint32_t(1) << (id % 32);
        return (atomic::Load(& p[word]) & mask) != 0;
    }

    void rec::set(golang::runtime::pMask p, int32_t id)
    {
        auto word = id / 32;
        auto mask = uint32_t(1) << (id % 32);
        atomic::Or(& p[word], mask);
    }

    void rec::clear(golang::runtime::pMask p, int32_t id)
    {
        auto word = id / 32;
        auto mask = uint32_t(1) << (id % 32);
        atomic::And(& p[word], ~ mask);
    }

    void updateTimerPMask(struct p* pp)
    {
        if(rec::Load(gocpp::recv(pp->numTimers)) > 0)
        {
            return;
        }
        lock(& pp->timersLock);
        if(rec::Load(gocpp::recv(pp->numTimers)) == 0)
        {
            rec::clear(gocpp::recv(timerpMask), pp->id);
        }
        unlock(& pp->timersLock);
    }

    int64_t pidleput(struct p* pp, int64_t now)
    {
        assertLockHeld(& sched.lock);
        if(! runqempty(pp))
        {
            go_throw("pidleput: P has non-empty run queue");
        }
        if(now == 0)
        {
            now = nanotime();
        }
        updateTimerPMask(pp);
        rec::set(gocpp::recv(idlepMask), pp->id);
        pp->link = sched.pidle;
        rec::set(gocpp::recv(sched.pidle), pp);
        rec::Add(gocpp::recv(sched.npidle), 1);
        if(! rec::start(gocpp::recv(pp->limiterEvent), limiterEventIdle, now))
        {
            go_throw("must be able to track idle limiter event");
        }
        return now;
    }

    std::tuple<struct p*, int64_t> pidleget(int64_t now)
    {
        assertLockHeld(& sched.lock);
        auto pp = rec::ptr(gocpp::recv(sched.pidle));
        if(pp != nullptr)
        {
            if(now == 0)
            {
                now = nanotime();
            }
            rec::set(gocpp::recv(timerpMask), pp->id);
            rec::clear(gocpp::recv(idlepMask), pp->id);
            sched.pidle = pp->link;
            rec::Add(gocpp::recv(sched.npidle), - 1);
            rec::stop(gocpp::recv(pp->limiterEvent), limiterEventIdle, now);
        }
        return {pp, now};
    }

    std::tuple<struct p*, int64_t> pidlegetSpinning(int64_t now)
    {
        assertLockHeld(& sched.lock);
        auto [pp, now] = pidleget(now);
        if(pp == nullptr)
        {
            rec::Store(gocpp::recv(sched.needspinning), 1);
            return {nullptr, now};
        }
        return {pp, now};
    }

    bool runqempty(struct p* pp)
    {
        for(; ; )
        {
            auto head = atomic::Load(& pp->runqhead);
            auto tail = atomic::Load(& pp->runqtail);
            auto runnext = atomic::Loaduintptr((uintptr_t*)(unsafe::Pointer(& pp->runnext)));
            if(tail == atomic::Load(& pp->runqtail))
            {
                return head == tail && runnext == 0;
            }
        }
    }

    void runqput(struct p* pp, struct g* gp, bool next)
    {
        if(randomizeScheduler && next && randn(2) == 0)
        {
            next = false;
        }
        if(next)
        {
            retryNext:
            auto oldnext = pp->runnext;
            if(! rec::cas(gocpp::recv(pp->runnext), oldnext, guintptr(unsafe::Pointer(gp))))
            {
                goto retryNext;
            }
            if(oldnext == 0)
            {
                return;
            }
            gp = rec::ptr(gocpp::recv(oldnext));
        }
        retry:
        auto h = atomic::LoadAcq(& pp->runqhead);
        auto t = pp->runqtail;
        if(t - h < uint32_t(len(pp->runq)))
        {
            rec::set(gocpp::recv(pp->runq[t % uint32_t(len(pp->runq))]), gp);
            atomic::StoreRel(& pp->runqtail, t + 1);
            return;
        }
        if(runqputslow(pp, gp, h, t))
        {
            return;
        }
        goto retry;
    }

    bool runqputslow(struct p* pp, struct g* gp, uint32_t h, uint32_t t)
    {
        gocpp::array<g*, len(pp->runq) / 2 + 1> batch = {};
        auto n = t - h;
        n = n / 2;
        if(n != uint32_t(len(pp->runq) / 2))
        {
            go_throw("runqputslow: queue is not full");
        }
        for(auto i = uint32_t(0); i < n; i++)
        {
            batch[i] = rec::ptr(gocpp::recv(pp->runq[(h + i) % uint32_t(len(pp->runq))]));
        }
        if(! atomic::CasRel(& pp->runqhead, h, h + n))
        {
            return false;
        }
        batch[n] = gp;
        if(randomizeScheduler)
        {
            for(auto i = uint32_t(1); i <= n; i++)
            {
                auto j = cheaprandn(i + 1);
                std::tie(batch[i], batch[j]) = std::tuple{batch[j], batch[i]};
            }
        }
        for(auto i = uint32_t(0); i < n; i++)
        {
            rec::set(gocpp::recv(batch[i]->schedlink), batch[i + 1]);
        }
        gQueue q = {};
        rec::set(gocpp::recv(q.head), batch[0]);
        rec::set(gocpp::recv(q.tail), batch[n]);
        lock(& sched.lock);
        globrunqputbatch(& q, int32_t(n + 1));
        unlock(& sched.lock);
        return true;
    }

    void runqputbatch(struct p* pp, struct gQueue* q, int qsize)
    {
        auto h = atomic::LoadAcq(& pp->runqhead);
        auto t = pp->runqtail;
        auto n = uint32_t(0);
        for(; ! rec::empty(gocpp::recv(q)) && t - h < uint32_t(len(pp->runq)); )
        {
            auto gp = rec::pop(gocpp::recv(q));
            rec::set(gocpp::recv(pp->runq[t % uint32_t(len(pp->runq))]), gp);
            t++;
            n++;
        }
        qsize -= int(n);
        if(randomizeScheduler)
        {
            auto off = [=](uint32_t o) mutable -> uint32_t
            {
                return (pp->runqtail + o) % uint32_t(len(pp->runq));
            };
            for(auto i = uint32_t(1); i < n; i++)
            {
                auto j = cheaprandn(i + 1);
                std::tie(pp->runq[off(i)], pp->runq[off(j)]) = std::tuple{pp->runq[off(j)], pp->runq[off(i)]};
            }
        }
        atomic::StoreRel(& pp->runqtail, t);
        if(! rec::empty(gocpp::recv(q)))
        {
            lock(& sched.lock);
            globrunqputbatch(q, int32_t(qsize));
            unlock(& sched.lock);
        }
    }

    std::tuple<struct g*, bool> runqget(struct p* pp)
    {
        struct g* gp;
        bool inheritTime;
        auto next = pp->runnext;
        if(next != 0 && rec::cas(gocpp::recv(pp->runnext), next, 0))
        {
            return {rec::ptr(gocpp::recv(next)), true};
        }
        for(; ; )
        {
            auto h = atomic::LoadAcq(& pp->runqhead);
            auto t = pp->runqtail;
            if(t == h)
            {
                return {nullptr, false};
            }
            auto gp = rec::ptr(gocpp::recv(pp->runq[h % uint32_t(len(pp->runq))]));
            if(atomic::CasRel(& pp->runqhead, h, h + 1))
            {
                return {gp, false};
            }
        }
    }

    std::tuple<struct gQueue, uint32_t> runqdrain(struct p* pp)
    {
        struct gQueue drainQ;
        uint32_t n;
        auto oldNext = pp->runnext;
        if(oldNext != 0 && rec::cas(gocpp::recv(pp->runnext), oldNext, 0))
        {
            rec::pushBack(gocpp::recv(drainQ), rec::ptr(gocpp::recv(oldNext)));
            n++;
        }
        retry:
        auto h = atomic::LoadAcq(& pp->runqhead);
        auto t = pp->runqtail;
        auto qn = t - h;
        if(qn == 0)
        {
            return {drainQ, n};
        }
        if(qn > uint32_t(len(pp->runq)))
        {
            goto retry;
        }
        if(! atomic::CasRel(& pp->runqhead, h, h + qn))
        {
            goto retry;
        }
        for(auto i = uint32_t(0); i < qn; i++)
        {
            auto gp = rec::ptr(gocpp::recv(pp->runq[(h + i) % uint32_t(len(pp->runq))]));
            rec::pushBack(gocpp::recv(drainQ), gp);
            n++;
        }
        return {drainQ, n};
    }

    uint32_t runqgrab(struct p* pp, gocpp::array<golang::runtime::guintptr, 256>* batch, uint32_t batchHead, bool stealRunNextG)
    {
        for(; ; )
        {
            auto h = atomic::LoadAcq(& pp->runqhead);
            auto t = atomic::LoadAcq(& pp->runqtail);
            auto n = t - h;
            n = n - n / 2;
            if(n == 0)
            {
                if(stealRunNextG)
                {
                    if(auto next = pp->runnext; next != 0)
                    {
                        if(pp->status == _Prunning)
                        {
                            if(! osHasLowResTimer)
                            {
                                usleep(3);
                            }
                            else
                            {
                                osyield();
                            }
                        }
                        if(! rec::cas(gocpp::recv(pp->runnext), next, 0))
                        {
                            continue;
                        }
                        batch[batchHead % uint32_t(len(batch))] = next;
                        return 1;
                    }
                }
                return 0;
            }
            if(n > uint32_t(len(pp->runq) / 2))
            {
                continue;
            }
            for(auto i = uint32_t(0); i < n; i++)
            {
                auto g = pp->runq[(h + i) % uint32_t(len(pp->runq))];
                batch[(batchHead + i) % uint32_t(len(batch))] = g;
            }
            if(atomic::CasRel(& pp->runqhead, h, h + n))
            {
                return n;
            }
        }
    }

    struct g* runqsteal(struct p* pp, struct p* p2, bool stealRunNextG)
    {
        auto t = pp->runqtail;
        auto n = runqgrab(p2, & pp->runq, t, stealRunNextG);
        if(n == 0)
        {
            return nullptr;
        }
        n--;
        auto gp = rec::ptr(gocpp::recv(pp->runq[(t + n) % uint32_t(len(pp->runq))]));
        if(n == 0)
        {
            return gp;
        }
        auto h = atomic::LoadAcq(& pp->runqhead);
        if(t - h + n >= uint32_t(len(pp->runq)))
        {
            go_throw("runqsteal: runq overflow");
        }
        atomic::StoreRel(& pp->runqtail, t + n);
        return gp;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gQueue::operator T()
    {
        T result;
        result.head = this->head;
        result.tail = this->tail;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gQueue::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        if (tail != ref.tail) return false;
        return true;
    }

    std::ostream& gQueue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gQueue& value)
    {
        return value.PrintTo(os);
    }

    bool rec::empty(struct gQueue* q)
    {
        return q->head == 0;
    }

    void rec::push(struct gQueue* q, struct g* gp)
    {
        gp->schedlink = q->head;
        rec::set(gocpp::recv(q->head), gp);
        if(q->tail == 0)
        {
            rec::set(gocpp::recv(q->tail), gp);
        }
    }

    void rec::pushBack(struct gQueue* q, struct g* gp)
    {
        gp->schedlink = 0;
        if(q->tail != 0)
        {
            rec::set(gocpp::recv(rec::ptr(gocpp::recv(q->tail))->schedlink), gp);
        }
        else
        {
            rec::set(gocpp::recv(q->head), gp);
        }
        rec::set(gocpp::recv(q->tail), gp);
    }

    void rec::pushBackAll(struct gQueue* q, struct gQueue q2)
    {
        if(q2.tail == 0)
        {
            return;
        }
        rec::ptr(gocpp::recv(q2.tail))->schedlink = 0;
        if(q->tail != 0)
        {
            rec::ptr(gocpp::recv(q->tail))->schedlink = q2.head;
        }
        else
        {
            q->head = q2.head;
        }
        q->tail = q2.tail;
    }

    struct g* rec::pop(struct gQueue* q)
    {
        auto gp = rec::ptr(gocpp::recv(q->head));
        if(gp != nullptr)
        {
            q->head = gp->schedlink;
            if(q->head == 0)
            {
                q->tail = 0;
            }
        }
        return gp;
    }

    struct gList rec::popList(struct gQueue* q)
    {
        auto stack = gList {q->head};
        *q = gQueue {};
        return stack;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    gList::operator T()
    {
        T result;
        result.head = this->head;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool gList::operator==(const T& ref) const
    {
        if (head != ref.head) return false;
        return true;
    }

    std::ostream& gList::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gList& value)
    {
        return value.PrintTo(os);
    }

    bool rec::empty(struct gList* l)
    {
        return l->head == 0;
    }

    void rec::push(struct gList* l, struct g* gp)
    {
        gp->schedlink = l->head;
        rec::set(gocpp::recv(l->head), gp);
    }

    void rec::pushAll(struct gList* l, struct gQueue q)
    {
        if(! rec::empty(gocpp::recv(q)))
        {
            rec::ptr(gocpp::recv(q.tail))->schedlink = l->head;
            l->head = q.head;
        }
    }

    struct g* rec::pop(struct gList* l)
    {
        auto gp = rec::ptr(gocpp::recv(l->head));
        if(gp != nullptr)
        {
            l->head = gp->schedlink;
        }
        return gp;
    }

    int setMaxThreads(int in)
    {
        int out;
        lock(& sched.lock);
        out = int(sched.maxmcount);
        if(in > 0x7fffffff)
        {
            sched.maxmcount = 0x7fffffff;
        }
        else
        {
            sched.maxmcount = int32_t(in);
        }
        checkmcount();
        unlock(& sched.lock);
        return out;
    }

    int procPin()
    {
        auto gp = getg();
        auto mp = gp->m;
        mp->locks++;
        return int(rec::ptr(gocpp::recv(mp->p))->id);
    }

    void procUnpin()
    {
        auto gp = getg();
        gp->m->locks--;
    }

    int sync_runtime_procPin()
    {
        return procPin();
    }

    void sync_runtime_procUnpin()
    {
        procUnpin();
    }

    int sync_atomic_runtime_procPin()
    {
        return procPin();
    }

    void sync_atomic_runtime_procUnpin()
    {
        procUnpin();
    }

    bool sync_runtime_canSpin(int i)
    {
        if(i >= active_spin || ncpu <= 1 || gomaxprocs <= rec::Load(gocpp::recv(sched.npidle)) + rec::Load(gocpp::recv(sched.nmspinning)) + 1)
        {
            return false;
        }
        if(auto p = rec::ptr(gocpp::recv(getg()->m->p)); ! runqempty(p))
        {
            return false;
        }
        return true;
    }

    void sync_runtime_doSpin()
    {
        procyield(active_spin_cnt);
    }

    randomOrder stealOrder;
    
    template<typename T> requires gocpp::GoStruct<T>
    randomOrder::operator T()
    {
        T result;
        result.count = this->count;
        result.coprimes = this->coprimes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool randomOrder::operator==(const T& ref) const
    {
        if (count != ref.count) return false;
        if (coprimes != ref.coprimes) return false;
        return true;
    }

    std::ostream& randomOrder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << count;
        os << " " << coprimes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct randomOrder& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    randomEnum::operator T()
    {
        T result;
        result.i = this->i;
        result.count = this->count;
        result.pos = this->pos;
        result.inc = this->inc;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool randomEnum::operator==(const T& ref) const
    {
        if (i != ref.i) return false;
        if (count != ref.count) return false;
        if (pos != ref.pos) return false;
        if (inc != ref.inc) return false;
        return true;
    }

    std::ostream& randomEnum::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << i;
        os << " " << count;
        os << " " << pos;
        os << " " << inc;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct randomEnum& value)
    {
        return value.PrintTo(os);
    }

    void rec::reset(struct randomOrder* ord, uint32_t count)
    {
        ord->count = count;
        ord->coprimes = ord->coprimes.make_slice(0, 0);
        for(auto i = uint32_t(1); i <= count; i++)
        {
            if(gcd(i, count) == 1)
            {
                ord->coprimes = append(ord->coprimes, i);
            }
        }
    }

    struct randomEnum rec::start(struct randomOrder* ord, uint32_t i)
    {
        return gocpp::Init<randomEnum>([=](auto& x) {
            x.count = ord->count;
            x.pos = i % ord->count;
            x.inc = ord->coprimes[i / ord->count % uint32_t(len(ord->coprimes))];
        });
    }

    bool rec::done(struct randomEnum* go_enum)
    {
        return go_enum->i == go_enum->count;
    }

    void rec::next(struct randomEnum* go_enum)
    {
        go_enum->i++;
        go_enum->pos = (go_enum->pos + go_enum->inc) % go_enum->count;
    }

    uint32_t rec::position(struct randomEnum* go_enum)
    {
        return go_enum->pos;
    }

    uint32_t gcd(uint32_t a, uint32_t b)
    {
        for(; b != 0; )
        {
            std::tie(a, b) = std::tuple{b, a % b};
        }
        return a;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    initTask::operator T()
    {
        T result;
        result.state = this->state;
        result.nfns = this->nfns;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool initTask::operator==(const T& ref) const
    {
        if (state != ref.state) return false;
        if (nfns != ref.nfns) return false;
        return true;
    }

    std::ostream& initTask::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << state;
        os << " " << nfns;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct initTask& value)
    {
        return value.PrintTo(os);
    }

    tracestat inittrace;
    
    template<typename T> requires gocpp::GoStruct<T>
    tracestat::operator T()
    {
        T result;
        result.active = this->active;
        result.id = this->id;
        result.allocs = this->allocs;
        result.bytes = this->bytes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool tracestat::operator==(const T& ref) const
    {
        if (active != ref.active) return false;
        if (id != ref.id) return false;
        if (allocs != ref.allocs) return false;
        if (bytes != ref.bytes) return false;
        return true;
    }

    std::ostream& tracestat::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << active;
        os << " " << id;
        os << " " << allocs;
        os << " " << bytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct tracestat& value)
    {
        return value.PrintTo(os);
    }

    void doInit(gocpp::slice<initTask*> ts)
    {
        for(auto [gocpp_ignored, t] : ts)
        {
            doInit1(t);
        }
    }

    void doInit1(struct initTask* t)
    {
        //Go switch emulation
        {
            auto condition = t->state;
            int conditionId = -1;
            if(condition == 2) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    return;
                    break;
                case 1:
                    go_throw("recursive call during initialization - linker skew");
                    break;
                default:
                    t->state = 1;
                    int64_t start = {};
                    tracestat before = {};
                    if(inittrace.active)
                    {
                        start = nanotime();
                        before = inittrace;
                    }
                    if(t->nfns == 0)
                    {
                        go_throw("inittask with no functions");
                    }
                    auto firstFunc = add(unsafe::Pointer(t), 8);
                    for(auto i = uint32_t(0); i < t->nfns; i++)
                    {
                        auto p = add(firstFunc, uintptr_t(i) * goarch::PtrSize);
                        auto f = *(std::function<void ()>*)(unsafe::Pointer(& p));
                        f();
                    }
                    if(inittrace.active)
                    {
                        auto end = nanotime();
                        auto after = inittrace;
                        auto f = *(std::function<void ()>*)(unsafe::Pointer(& firstFunc));
                        auto pkg = funcpkgpath(findfunc(abi::FuncPCABIInternal(f)));
                        gocpp::array<unsigned char, 24> sbuf = {};
                        print("init ", pkg, " @");
                        print(std::string(fmtNSAsMS(sbuf.make_slice(0), uint64_t(start - runtimeInitTime))), " ms, ");
                        print(std::string(fmtNSAsMS(sbuf.make_slice(0), uint64_t(end - start))), " ms clock, ");
                        print(std::string(itoa(sbuf.make_slice(0), after.bytes - before.bytes)), " bytes, ");
                        print(std::string(itoa(sbuf.make_slice(0), after.allocs - before.allocs)), " allocs");
                        print("\n");
                    }
                    t->state = 2;
                    break;
            }
        }
    }

}

int main()
{
    try
    {
        std::cout << std::boolalpha << std::setprecision(5) << std::fixed;
        golang::runtime::main();
        return 0;
    }
    catch(const gocpp::GoPanic& ex)
    {
        std::cout << "Panic: " << ex.what() << std::endl;
        return -1;
    }
}
