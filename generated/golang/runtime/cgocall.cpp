// generated by GoCpp from file '$(ImportDir)/runtime/cgocall.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/cgocall.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/internal/goexperiment/exp_allocheaders_on.h"
#include "golang/internal/goexperiment/exp_cgocheck2_off.h"
#include "golang/runtime/atomic_pointer.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/error.h"
#include "golang/runtime/extern.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/consts.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/malloc.h"
#include "golang/runtime/mbitmap.h"
#include "golang/runtime/mbitmap_allocheaders.h"
#include "golang/runtime/mcache.h"
#include "golang/runtime/mfinal.h"
#include "golang/runtime/mgc.h"
#include "golang/runtime/mgclimit.h"
#include "golang/runtime/mgcwork.h"
#include "golang/runtime/mheap.h"
#include "golang/runtime/mpagecache.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mwbbuf.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/pagetrace_off.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/pinner.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/print.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime1.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/type.h"
#include "golang/runtime/typekind.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace atomic::rec;
        using namespace chacha8rand::rec;
        using namespace goarch::rec;
        using namespace goexperiment::rec;
        using namespace runtime::rec;
        using namespace sys::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    argset::operator T()
    {
        T result;
        result.args = this->args;
        result.retval = this->retval;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool argset::operator==(const T& ref) const
    {
        if (args != ref.args) return false;
        if (retval != ref.retval) return false;
        return true;
    }

    std::ostream& argset::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << args;
        os << " " << retval;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct argset& value)
    {
        return value.PrintTo(os);
    }

    uintptr_t syscall_cgocaller(unsafe::Pointer fn, gocpp::slice<uintptr_t> args)
    {
        auto as = gocpp::Init<argset>([=](auto& x) {
            x.args = unsafe::Pointer(& args[0]);
        });
        cgocall(fn, unsafe::Pointer(& as));
        return as.retval;
    }

    uint64_t ncgocall;
    int32_t cgocall(unsafe::Pointer fn, unsafe::Pointer arg)
    {
        if(! iscgo && GOOS != "solaris" && GOOS != "illumos" && GOOS != "windows")
        {
            go_throw("cgocall unavailable");
        }
        if(fn == nullptr)
        {
            go_throw("cgocall nil");
        }
        if(raceenabled)
        {
            racereleasemerge(unsafe::Pointer(& racecgosync));
        }
        auto mp = getg()->m;
        mp->ncgocall++;
        mp->cgoCallers[0] = 0;
        entersyscall();
        osPreemptExtEnter(mp);
        mp->incgo = true;
        mp->ncgo++;
        auto errno = asmcgocall(fn, arg);
        mp->incgo = false;
        mp->ncgo--;
        osPreemptExtExit(mp);
        exitsyscall();
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& racecgosync));
        }
        KeepAlive(fn);
        KeepAlive(arg);
        KeepAlive(mp);
        return errno;
    }

    void callbackUpdateSystemStack(struct m* mp, uintptr_t sp, bool signal)
    {
        auto g0 = mp->g0;
        if(sp > g0->stack.lo && sp <= g0->stack.hi)
        {
            return;
        }
        if(mp->ncgo > 0)
        {
            auto hi = g0->stack.hi;
            auto lo = g0->stack.lo;
            g0->stack.hi = sp + 1024;
            g0->stack.lo = sp - 32 * 1024;
            g0->stackguard0 = g0->stack.lo + stackGuard;
            g0->stackguard1 = g0->stackguard0;
            print("M ", mp->id, " procid ", mp->procid, " runtime: cgocallback with sp=", hex(sp), " out of bounds [", hex(lo), ", ", hex(hi), "]");
            print("\n");
            exit(2);
        }
        g0->stack.hi = sp + 1024;
        g0->stack.lo = sp - 32 * 1024;
        if(! signal && _cgo_getstackbound != nullptr)
        {
            gocpp::array<uintptr_t, 2> bounds = {};
            asmcgocall(_cgo_getstackbound, unsafe::Pointer(& bounds));
            if(bounds[0] != 0 && sp > bounds[0] && sp <= bounds[1])
            {
                g0->stack.lo = bounds[0];
                g0->stack.hi = bounds[1];
            }
        }
        g0->stackguard0 = g0->stack.lo + stackGuard;
        g0->stackguard1 = g0->stackguard0;
    }

    void cgocallbackg(unsafe::Pointer fn, unsafe::Pointer frame, uintptr_t ctxt)
    {
        auto gp = getg();
        if(gp != gp->m->curg)
        {
            println("runtime: bad g in cgocallback");
            exit(2);
        }
        auto sp = gp->m->g0->sched.sp;
        callbackUpdateSystemStack(gp->m, sp, false);
        lockOSThread();
        auto checkm = gp->m;
        auto syscall = gp->m->syscall;
        auto savedsp = unsafe::Pointer(gp->syscallsp);
        auto savedpc = gp->syscallpc;
        exitsyscall();
        gp->m->incgo = false;
        if(gp->m->isextra)
        {
            gp->m->isExtraInC = false;
        }
        osPreemptExtExit(gp->m);
        if(gp->nocgocallback)
        {
            gocpp::panic("runtime: function marked with #cgo nocallback called back into Go");
        }
        cgocallbackg1(fn, frame, ctxt);
        gp->m->incgo = true;
        unlockOSThread();
        if(gp->m->isextra)
        {
            gp->m->isExtraInC = true;
        }
        if(gp->m != checkm)
        {
            go_throw("m changed unexpectedly in cgocallbackg");
        }
        osPreemptExtEnter(gp->m);
        reentersyscall(savedpc, uintptr_t(savedsp));
        gp->m->syscall = syscall;
    }

    void cgocallbackg1(unsafe::Pointer fn, unsafe::Pointer frame, uintptr_t ctxt)
    {
        gocpp::Defer defer;
        try
        {
            auto gp = getg();
            if(gp->m->needextram || rec::Load(gocpp::recv(extraMWaiters)) > 0)
            {
                gp->m->needextram = false;
                systemstack(newextram);
            }
            if(ctxt != 0)
            {
                auto s = append(gp->cgoCtxt, ctxt);
                auto p = (slice*)(unsafe::Pointer(& gp->cgoCtxt));
                atomicstorep(unsafe::Pointer(& p->array), unsafe::Pointer(& s[0]));
                p->cap = cap(s);
                p->len = len(s);
                defer.push_back([=]{ [=](struct g* gp) mutable -> void
                {
                    auto p = (slice*)(unsafe::Pointer(& gp->cgoCtxt));
                    p->len--;
                }(gp); });
            }
            if(gp->m->ncgo == 0)
            {
                main_init_done.recv();
            }
            auto hz = sched.profilehz;
            if(gp->m->profilehz != hz)
            {
                setThreadCPUProfiler(hz);
            }
            auto restore = true;
            defer.push_back([=]{ unwindm(& restore); });
            if(raceenabled)
            {
                raceacquire(unsafe::Pointer(& racecgosync));
            }
            std::function<void (unsafe::Pointer frame)> cb = {};
            auto cbFV = funcval {uintptr_t(fn)};
            *(unsafe::Pointer*)(unsafe::Pointer(& cb)) = noescape(unsafe::Pointer(& cbFV));
            cb(frame);
            if(raceenabled)
            {
                racereleasemerge(unsafe::Pointer(& racecgosync));
            }
            restore = false;
        }
        catch(gocpp::GoPanic& gp)
        {
            defer.handlePanic(gp);
        }
    }

    void unwindm(bool* restore)
    {
        if(*restore)
        {
            auto mp = acquirem();
            auto sched = & mp->g0->sched;
            sched->sp = *(uintptr_t*)(unsafe::Pointer(sched->sp + alignUp(sys::MinFrameSize, sys::StackAlign)));
            if(mp->ncgo > 0)
            {
                mp->incgo = false;
                mp->ncgo--;
                osPreemptExtExit(mp);
            }
            unlockOSThread();
            releasem(mp);
        }
    }

    void badcgocallback()
    {
        go_throw("misaligned stack in cgocallback");
    }

    void cgounimpl()
    {
        go_throw("cgo not implemented");
    }

    uint64_t racecgosync;
    void cgoCheckPointer(go_any ptr, go_any arg)
    {
        if(! goexperiment::CgoCheck2 && debug.cgocheck == 0)
        {
            return;
        }
        auto ep = efaceOf(& ptr);
        auto t = ep->_type;
        auto top = true;
        if(arg != nullptr && (t->Kind_ & kindMask == kindPtr || t->Kind_ & kindMask == kindUnsafePointer))
        {
            auto p = ep->data;
            if(t->Kind_ & kindDirectIface == 0)
            {
                p = *(unsafe::Pointer*)(p);
            }
            if(p == nullptr || ! cgoIsGoPointer(p))
            {
                return;
            }
            auto aep = efaceOf(& arg);
            //Go switch emulation
            {
                auto condition = aep->_type->Kind_ & kindMask;
                int conditionId = -1;
                if(condition == kindBool) { conditionId = 0; }
                else if(condition == kindSlice) { conditionId = 1; }
                else if(condition == kindArray) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                        if(t->Kind_ & kindMask == kindUnsafePointer)
                        {
                            break;
                        }
                        auto pt = (runtime::ptrtype*)(unsafe::Pointer(t));
                        cgoCheckArg(pt->Elem, p, true, false, cgoCheckPointerFail);
                        return;
                        break;
                    case 1:
                        ep = aep;
                        t = ep->_type;
                        break;
                    case 2:
                        ep = aep;
                        t = ep->_type;
                        top = false;
                        break;
                    default:
                        go_throw("can't happen");
                        break;
                }
            }
        }
        cgoCheckArg(t, ep->data, t->Kind_ & kindDirectIface == 0, top, cgoCheckPointerFail);
    }

    std::string cgoCheckPointerFail = "cgo argument has Go pointer to unpinned Go pointer";
    std::string cgoResultFail = "cgo result is unpinned Go pointer or points to unpinned Go pointer";
    void cgoCheckArg(golang::runtime::_type* t, unsafe::Pointer p, bool indir, bool top, std::string msg)
    {
        if(t->PtrBytes == 0 || p == nullptr)
        {
            return;
        }
        //Go switch emulation
        {
            auto condition = t->Kind_ & kindMask;
            int conditionId = -1;
            else if(condition == kindArray) { conditionId = 0; }
            else if(condition == kindChan) { conditionId = 1; }
            else if(condition == kindMap) { conditionId = 2; }
            else if(condition == kindFunc) { conditionId = 3; }
            else if(condition == kindInterface) { conditionId = 4; }
            else if(condition == kindSlice) { conditionId = 5; }
            else if(condition == kindString) { conditionId = 6; }
            else if(condition == kindStruct) { conditionId = 7; }
            else if(condition == kindPtr) { conditionId = 8; }
            else if(condition == kindUnsafePointer) { conditionId = 9; }
            switch(conditionId)
            {
                default:
                    go_throw("can't happen");
                    break;
                case 0:
                    auto at = (runtime::arraytype*)(unsafe::Pointer(t));
                    if(! indir)
                    {
                        if(at->Len != 1)
                        {
                            go_throw("can't happen");
                        }
                        cgoCheckArg(at->Elem, p, at->Elem->Kind_ & kindDirectIface == 0, top, msg);
                        return;
                    }
                    for(auto i = uintptr_t(0); i < at->Len; i++)
                    {
                        cgoCheckArg(at->Elem, p, true, top, msg);
                        p = add(p, at->Elem->Size_);
                    }
                    break;
                case 1:
                case 2:
                    gocpp::panic(errorString(msg));
                    break;
                case 3:
                    if(indir)
                    {
                        p = *(unsafe::Pointer*)(p);
                    }
                    if(! cgoIsGoPointer(p))
                    {
                        return;
                    }
                    gocpp::panic(errorString(msg));
                    break;
                case 4:
                    auto it = *(runtime::_type**)(p);
                    if(it == nullptr)
                    {
                        return;
                    }
                    if(inheap(uintptr_t(unsafe::Pointer(it))))
                    {
                        gocpp::panic(errorString(msg));
                    }
                    p = *(unsafe::Pointer*)(add(p, goarch::PtrSize));
                    if(! cgoIsGoPointer(p))
                    {
                        return;
                    }
                    if(! top && ! isPinned(p))
                    {
                        gocpp::panic(errorString(msg));
                    }
                    cgoCheckArg(it, p, it->Kind_ & kindDirectIface == 0, false, msg);
                    break;
                case 5:
                    auto st = (runtime::slicetype*)(unsafe::Pointer(t));
                    auto s = (slice*)(p);
                    p = s->array;
                    if(p == nullptr || ! cgoIsGoPointer(p))
                    {
                        return;
                    }
                    if(! top && ! isPinned(p))
                    {
                        gocpp::panic(errorString(msg));
                    }
                    if(st->Elem->PtrBytes == 0)
                    {
                        return;
                    }
                    for(auto i = 0; i < s->cap; i++)
                    {
                        cgoCheckArg(st->Elem, p, true, false, msg);
                        p = add(p, st->Elem->Size_);
                    }
                    break;
                case 6:
                    auto ss = (stringStruct*)(p);
                    if(! cgoIsGoPointer(ss->str))
                    {
                        return;
                    }
                    if(! top && ! isPinned(ss->str))
                    {
                        gocpp::panic(errorString(msg));
                    }
                    break;
                case 7:
                    auto st = (runtime::structtype*)(unsafe::Pointer(t));
                    if(! indir)
                    {
                        if(len(st->Fields) != 1)
                        {
                            go_throw("can't happen");
                        }
                        cgoCheckArg(st->Fields[0].Typ, p, st->Fields[0].Typ->Kind_ & kindDirectIface == 0, top, msg);
                        return;
                    }
                    for(auto [gocpp_ignored, f] : st->Fields)
                    {
                        if(f.Typ->PtrBytes == 0)
                        {
                            continue;
                        }
                        cgoCheckArg(f.Typ, add(p, f.Offset), true, top, msg);
                    }
                    break;
                case 8:
                case 9:
                    if(indir)
                    {
                        p = *(unsafe::Pointer*)(p);
                        if(p == nullptr)
                        {
                            return;
                        }
                    }
                    if(! cgoIsGoPointer(p))
                    {
                        return;
                    }
                    if(! top && ! isPinned(p))
                    {
                        gocpp::panic(errorString(msg));
                    }
                    cgoCheckUnknownPointer(p, msg);
                    break;
            }
        }
    }

    std::tuple<uintptr_t, uintptr_t> cgoCheckUnknownPointer(unsafe::Pointer p, std::string msg)
    {
        uintptr_t base;
        uintptr_t i;
        if(inheap(uintptr_t(p)))
        {
            uintptr_t base;
            uintptr_t i;
            auto [b, span, gocpp_id_1] = findObject(uintptr_t(p), 0, 0);
            base = b;
            if(base == 0)
            {
                uintptr_t base;
                uintptr_t i;
                return {base, i};
            }
            if(goexperiment::AllocHeaders)
            {
                uintptr_t base;
                uintptr_t i;
                auto tp = rec::typePointersOfUnchecked(gocpp::recv(span), base);
                for(; ; )
                {
                    uintptr_t base;
                    uintptr_t i;
                    uintptr_t addr = {};
                    if(std::tie(tp, addr) = rec::next(gocpp::recv(tp), base + span->elemsize); addr == 0)
                    {
                        uintptr_t base;
                        uintptr_t i;
                        break;
                    }
                    auto pp = *(unsafe::Pointer*)(unsafe::Pointer(addr));
                    if(cgoIsGoPointer(pp) && ! isPinned(pp))
                    {
                        uintptr_t base;
                        uintptr_t i;
                        gocpp::panic(errorString(msg));
                    }
                }
            }
            else
            {
                uintptr_t base;
                uintptr_t i;
                auto n = span->elemsize;
                auto hbits = heapBitsForAddr(base, n);
                for(; ; )
                {
                    uintptr_t base;
                    uintptr_t i;
                    uintptr_t addr = {};
                    if(std::tie(hbits, addr) = rec::next(gocpp::recv(hbits)); addr == 0)
                    {
                        uintptr_t base;
                        uintptr_t i;
                        break;
                    }
                    auto pp = *(unsafe::Pointer*)(unsafe::Pointer(addr));
                    if(cgoIsGoPointer(pp) && ! isPinned(pp))
                    {
                        uintptr_t base;
                        uintptr_t i;
                        gocpp::panic(errorString(msg));
                    }
                }
            }
            return {base, i};
        }
        for(auto [gocpp_ignored, datap] : activeModules())
        {
            uintptr_t base;
            uintptr_t i;
            if(cgoInRange(p, datap->data, datap->edata) || cgoInRange(p, datap->bss, datap->ebss))
            {
                uintptr_t base;
                uintptr_t i;
                gocpp::panic(errorString(msg));
            }
        }
        return {base, i};
    }

    bool cgoIsGoPointer(unsafe::Pointer p)
    {
        if(p == nullptr)
        {
            return false;
        }
        if(inHeapOrStack(uintptr_t(p)))
        {
            return true;
        }
        for(auto [gocpp_ignored, datap] : activeModules())
        {
            if(cgoInRange(p, datap->data, datap->edata) || cgoInRange(p, datap->bss, datap->ebss))
            {
                return true;
            }
        }
        return false;
    }

    bool cgoInRange(unsafe::Pointer p, uintptr_t start, uintptr_t end)
    {
        return start <= uintptr_t(p) && uintptr_t(p) < end;
    }

    void cgoCheckResult(go_any val)
    {
        if(! goexperiment::CgoCheck2 && debug.cgocheck == 0)
        {
            return;
        }
        auto ep = efaceOf(& val);
        auto t = ep->_type;
        cgoCheckArg(t, ep->data, t->Kind_ & kindDirectIface == 0, false, cgoResultFail);
    }

}

