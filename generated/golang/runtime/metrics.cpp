// generated by GoCpp from file '$(ImportDir)/runtime/metrics.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/metrics.h"
#include "gocpp/support.h"

// #include "golang/internal/cpu/cpu.h"  [Ignored, known errors]
#include "golang/runtime/debug.h"
#include "golang/runtime/float.h"
#include "golang/runtime/histogram.h"
#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lock_sema.h"  [Ignored, known errors]
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
// #include "golang/runtime/mgcpacer.h"  [Ignored, known errors]
#include "golang/runtime/mstats.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/race0.h"
#include "golang/runtime/runtime2.h"
// #include "golang/runtime/sema.h"  [Ignored, known errors]
#include "golang/runtime/sizeclasses.h"
#include "golang/runtime/slice.h"
// #include "golang/runtime/stubs.h"  [Ignored, known errors]
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    uint32_t metricsSema = 1;
    bool metricsInit = 1;
    gocpp::map<std::string, metricData> metrics = 1;
    gocpp::slice<double> sizeClassBuckets = 1;
    gocpp::slice<double> timeHistBuckets = 1;
    
    std::ostream& metricData::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << deps;
        os << " " << compute;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricData& value)
    {
        return value.PrintTo(os);
    }

    void metricsLock()
    {
        semacquire1(& metricsSema, true, 0, 0, waitReasonSemacquire);
        if(raceenabled)
        {
            raceacquire(unsafe::Pointer(& metricsSema));
        }
    }

    void metricsUnlock()
    {
        if(raceenabled)
        {
            racerelease(unsafe::Pointer(& metricsSema));
        }
        semrelease(& metricsSema);
    }

    void initMetrics()
    {
        if(metricsInit)
        {
            return;
        }
        sizeClassBuckets = gocpp::make(gocpp::Tag<gocpp::slice<double>>(), _NumSizeClasses, _NumSizeClasses + 1);
        sizeClassBuckets[0] = 1;
        for(auto i = 1; i < _NumSizeClasses; i++)
        {
            sizeClassBuckets[i] = double(class_to_size[i] + 1);
        }
        sizeClassBuckets = append(sizeClassBuckets, float64Inf());
        timeHistBuckets = timeHistogramMetricsBuckets();
        metrics = gocpp::map<std::string, metricData> {{ "/cgo/go-to-c-calls:calls", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(NumCgoCall());
        }
; }) }, { "/cpu/classes/gc/mark/assist:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.gcAssistTime));
        }
; }) }, { "/cpu/classes/gc/mark/dedicated:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.gcDedicatedTime));
        }
; }) }, { "/cpu/classes/gc/mark/idle:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.gcIdleTime));
        }
; }) }, { "/cpu/classes/gc/pause:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.gcPauseTime));
        }
; }) }, { "/cpu/classes/gc/total:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.gcTotalTime));
        }
; }) }, { "/cpu/classes/idle:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.idleTime));
        }
; }) }, { "/cpu/classes/scavenge/assist:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.scavengeAssistTime));
        }
; }) }, { "/cpu/classes/scavenge/background:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.scavengeBgTime));
        }
; }) }, { "/cpu/classes/scavenge/total:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.scavengeTotalTime));
        }
; }) }, { "/cpu/classes/total:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.totalTime));
        }
; }) }, { "/cpu/classes/user:cpu-seconds", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(cpuStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(in->cpuStats.userTime));
        }
; }) }, { "/gc/cycles/automatic:gc-cycles", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.gcCyclesDone - in->sysStats.gcCyclesForced;
        }
; }) }, { "/gc/cycles/forced:gc-cycles", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.gcCyclesForced;
        }
; }) }, { "/gc/cycles/total:gc-cycles", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.gcCyclesDone;
        }
; }) }, { "/gc/scan/globals:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(gcStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->gcStats.globalsScan;
        }
; }) }, { "/gc/scan/heap:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(gcStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->gcStats.heapScan;
        }
; }) }, { "/gc/scan/stack:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(gcStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->gcStats.stackScan;
        }
; }) }, { "/gc/scan/total:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(gcStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->gcStats.totalScan;
        }
; }) }, { "/gc/heap/allocs-by-size:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            auto hist = float64HistOrInit(gocpp::recv(out), sizeClassBuckets);
            hist->counts[len(hist->counts) - 1] = in->heapStats.largeAllocCount;
            for(auto [i, count] : in->heapStats.smallAllocCount.make_slice(1))
            {
                hist->counts[i] = count;
            }
        }
; }) }, { "/gc/heap/allocs:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.totalAllocated;
        }
; }) }, { "/gc/heap/allocs:objects", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.totalAllocs;
        }
; }) }, { "/gc/heap/frees-by-size:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            auto hist = float64HistOrInit(gocpp::recv(out), sizeClassBuckets);
            hist->counts[len(hist->counts) - 1] = in->heapStats.largeFreeCount;
            for(auto [i, count] : in->heapStats.smallFreeCount.make_slice(1))
            {
                hist->counts[i] = count;
            }
        }
; }) }, { "/gc/heap/frees:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.totalFreed;
        }
; }) }, { "/gc/heap/frees:objects", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.totalFrees;
        }
; }) }, { "/gc/heap/goal:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.heapGoal;
        }
; }) }, { "/gc/gomemlimit:bytes", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(Load(gocpp::recv(gcController.memoryLimit)));
        }
; }) }, { "/gc/gogc:percent", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(Load(gocpp::recv(gcController.gcPercent)));
        }
; }) }, { "/gc/heap/live:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = gcController.heapMarked;
        }
; }) }, { "/gc/heap/objects:objects", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.numObjects;
        }
; }) }, { "/gc/heap/tiny/allocs:objects", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.tinyAllocCount;
        }
; }) }, { "/gc/limiter/last-enabled:gc-cycle", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(Load(gocpp::recv(gcCPULimiter.lastEnabledCycle)));
        }
; }) }, { "/gc/pauses:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            write(gocpp::recv(sched.stwTotalTimeGC), out);
        }
; }) }, { "/gc/stack/starting-size:bytes", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(startingStackSize);
        }
; }) }, { "/memory/classes/heap/free:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(in->heapStats.committed - in->heapStats.inHeap - in->heapStats.inStacks - in->heapStats.inWorkBufs - in->heapStats.inPtrScalarBits);
        }
; }) }, { "/memory/classes/heap/objects:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->heapStats.inObjects;
        }
; }) }, { "/memory/classes/heap/released:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(in->heapStats.released);
        }
; }) }, { "/memory/classes/heap/stacks:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(in->heapStats.inStacks);
        }
; }) }, { "/memory/classes/heap/unused:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(in->heapStats.inHeap) - in->heapStats.inObjects;
        }
; }) }, { "/memory/classes/metadata/mcache/free:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.mCacheSys - in->sysStats.mCacheInUse;
        }
; }) }, { "/memory/classes/metadata/mcache/inuse:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.mCacheInUse;
        }
; }) }, { "/memory/classes/metadata/mspan/free:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.mSpanSys - in->sysStats.mSpanInUse;
        }
; }) }, { "/memory/classes/metadata/mspan/inuse:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.mSpanInUse;
        }
; }) }, { "/memory/classes/metadata/other:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep, sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(in->heapStats.inWorkBufs + in->heapStats.inPtrScalarBits) + in->sysStats.gcMiscSys;
        }
; }) }, { "/memory/classes/os-stacks:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.stacksSys;
        }
; }) }, { "/memory/classes/other:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.otherSys;
        }
; }) }, { "/memory/classes/profiling/buckets:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = in->sysStats.buckHashSys;
        }
; }) }, { "/memory/classes/total:bytes", gocpp::Init<>([](& x) { x.deps = makeStatDepSet(heapStatsDep, sysStatsDep); x.compute = [=](statAggregate* in, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(in->heapStats.committed + in->heapStats.released) + in->sysStats.stacksSys + in->sysStats.mSpanSys + in->sysStats.mCacheSys + in->sysStats.buckHashSys + in->sysStats.gcMiscSys + in->sysStats.otherSys;
        }
; }) }, { "/sched/gomaxprocs:threads", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(gomaxprocs);
        }
; }) }, { "/sched/goroutines:goroutines", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            out->kind = metricKindUint64;
            out->scalar = uint64_t(gcount());
        }
; }) }, { "/sched/latencies:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            write(gocpp::recv(sched.timeToRun), out);
        }
; }) }, { "/sched/pauses/stopping/gc:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            write(gocpp::recv(sched.stwStoppingTimeGC), out);
        }
; }) }, { "/sched/pauses/stopping/other:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            write(gocpp::recv(sched.stwStoppingTimeOther), out);
        }
; }) }, { "/sched/pauses/total/gc:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            write(gocpp::recv(sched.stwTotalTimeGC), out);
        }
; }) }, { "/sched/pauses/total/other:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            write(gocpp::recv(sched.stwTotalTimeOther), out);
        }
; }) }, { "/sync/mutex/wait/total:seconds", gocpp::Init<>([](& x) { x.compute = [=](statAggregate* _, metricValue* out) mutable -> void
        {
            out->kind = metricKindFloat64;
            out->scalar = float64bits(nsToSec(totalMutexWaitTimeNanos()));
        }
; }) }};
        for(auto [_, info] : godebugs::All)
        {
            if(! info.Opaque)
            {
                metrics["/godebug/non-default-behavior/" + info.Name + ":events"] = gocpp::Init<metricData>([](metricData& x) { x.compute = compute0; });
            }
        }
        metricsInit = true;
    }

    void compute0(statAggregate* _, metricValue* out)
    {
        out->kind = metricKindUint64;
        out->scalar = 0;
    }

    void compute(metricReader f, statAggregate* _, metricValue* out)
    {
        out->kind = metricKindUint64;
        out->scalar = f();
    }

    void godebug_registerMetric(std::string name, std::function<uint64_t ()> read)
    {
        metricsLock();
        initMetrics();
        auto [d, ok] = metrics[name];
        if(! ok)
        {
            go_throw("runtime: unexpected metric registration for " + name);
        }
        d.compute = metricReader(read).compute;
        metrics[name] = d;
        metricsUnlock();
    }

    statDepSet makeStatDepSet(gocpp::slice<statDep> deps)
    {
        statDepSet s = {};
        for(auto [_, d] : deps)
        {
            s[d / 64] |= 1 << (d % 64);
        }
        return s;
    }

    statDepSet difference(statDepSet s, statDepSet b)
    {
        statDepSet c = {};
        for(auto [i, gocpp_ignored] : s)
        {
            c[i] = s[i] &^ b[i];
        }
        return c;
    }

    statDepSet union(statDepSet s, statDepSet b)
    {
        statDepSet c = {};
        for(auto [i, gocpp_ignored] : s)
        {
            c[i] = s[i] | b[i];
        }
        return c;
    }

    bool empty(statDepSet* s)
    {
        for(auto [_, c] : s)
        {
            if(c != 0)
            {
                return false;
            }
        }
        return true;
    }

    bool has(statDepSet* s, statDep d)
    {
        return s[d / 64] & (1 << (d % 64)) != 0;
    }

    
    std::ostream& heapStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << inObjects;
        os << " " << numObjects;
        os << " " << totalAllocated;
        os << " " << totalFreed;
        os << " " << totalAllocs;
        os << " " << totalFrees;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct heapStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    void compute(struct heapStatsAggregate* a)
    {
        read(gocpp::recv(memstats.heapStats), & a->heapStatsDelta);
        a->totalAllocs = a->largeAllocCount;
        a->totalFrees = a->largeFreeCount;
        a->totalAllocated = a->largeAlloc;
        a->totalFreed = a->largeFree;
        for(auto [i, gocpp_ignored] : a->smallAllocCount)
        {
            auto na = a->smallAllocCount[i];
            auto nf = a->smallFreeCount[i];
            a->totalAllocs += na;
            a->totalFrees += nf;
            a->totalAllocated += na * uint64_t(class_to_size[i]);
            a->totalFreed += nf * uint64_t(class_to_size[i]);
        }
        a->inObjects = a->totalAllocated - a->totalFreed;
        a->numObjects = a->totalAllocs - a->totalFrees;
    }

    
    std::ostream& sysStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << stacksSys;
        os << " " << mSpanSys;
        os << " " << mSpanInUse;
        os << " " << mCacheSys;
        os << " " << mCacheInUse;
        os << " " << buckHashSys;
        os << " " << gcMiscSys;
        os << " " << otherSys;
        os << " " << heapGoal;
        os << " " << gcCyclesDone;
        os << " " << gcCyclesForced;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct sysStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    void compute(struct sysStatsAggregate* a)
    {
        a->stacksSys = load(gocpp::recv(memstats.stacks_sys));
        a->buckHashSys = load(gocpp::recv(memstats.buckhash_sys));
        a->gcMiscSys = load(gocpp::recv(memstats.gcMiscSys));
        a->otherSys = load(gocpp::recv(memstats.other_sys));
        a->heapGoal = heapGoal(gocpp::recv(gcController));
        a->gcCyclesDone = uint64_t(memstats.numgc);
        a->gcCyclesForced = uint64_t(memstats.numforcedgc);
        systemstack([=]() mutable -> void
        {
            lock(& mheap_.lock);
            a->mSpanSys = load(gocpp::recv(memstats.mspan_sys));
            a->mSpanInUse = uint64_t(mheap_.spanalloc.inuse);
            a->mCacheSys = load(gocpp::recv(memstats.mcache_sys));
            a->mCacheInUse = uint64_t(mheap_.cachealloc.inuse);
            unlock(& mheap_.lock);
        }
);
    }

    
    std::ostream& cpuStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct cpuStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    void compute(struct cpuStatsAggregate* a)
    {
        a->cpuStats = work.cpuStats;
    }

    
    std::ostream& gcStatsAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << heapScan;
        os << " " << stackScan;
        os << " " << globalsScan;
        os << " " << totalScan;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct gcStatsAggregate& value)
    {
        return value.PrintTo(os);
    }

    void compute(struct gcStatsAggregate* a)
    {
        a->heapScan = Load(gocpp::recv(gcController.heapScan));
        a->stackScan = Load(gocpp::recv(gcController.lastStackScan));
        a->globalsScan = Load(gocpp::recv(gcController.globalsScan));
        a->totalScan = a->heapScan + a->stackScan + a->globalsScan;
    }

    double nsToSec(int64_t ns)
    {
        return double(ns) / 1e9;
    }

    
    std::ostream& statAggregate::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << ensured;
        os << " " << heapStats;
        os << " " << sysStats;
        os << " " << cpuStats;
        os << " " << gcStats;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct statAggregate& value)
    {
        return value.PrintTo(os);
    }

    void ensure(struct statAggregate* a, statDepSet* deps)
    {
        auto missing = difference(gocpp::recv(deps), a->ensured);
        if(empty(gocpp::recv(missing)))
        {
            return;
        }
        for(auto i = statDep(0); i < numStatsDeps; i++)
        {
            if(! has(gocpp::recv(missing), i))
            {
                continue;
            }
            //Go switch emulation
            {
                auto condition = i;
                int conditionId = -1;
                if(condition == heapStatsDep) { conditionId = 0; }
                else if(condition == sysStatsDep) { conditionId = 1; }
                else if(condition == cpuStatsDep) { conditionId = 2; }
                else if(condition == gcStatsDep) { conditionId = 3; }
                switch(conditionId)
                {
                    case 0:
                        compute(gocpp::recv(a->heapStats));
                        break;
                    case 1:
                        compute(gocpp::recv(a->sysStats));
                        break;
                    case 2:
                        compute(gocpp::recv(a->cpuStats));
                        break;
                    case 3:
                        compute(gocpp::recv(a->gcStats));
                        break;
                }
            }
        }
        a->ensured = union(gocpp::recv(a->ensured), missing);
    }

    
    std::ostream& metricSample::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << name;
        os << " " << value;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricSample& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& metricValue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << kind;
        os << " " << scalar;
        os << " " << pointer;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct metricValue& value)
    {
        return value.PrintTo(os);
    }

    metricFloat64Histogram* float64HistOrInit(struct metricValue* v, gocpp::slice<double> buckets)
    {
        metricFloat64Histogram* hist = {};
       