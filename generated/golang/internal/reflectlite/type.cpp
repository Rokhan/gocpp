// generated by GoCpp from file '$(ImportDir)/internal/reflectlite/type.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/reflectlite/type.h"
#include "gocpp/support.h"

#include "golang/internal/abi/type.h"
#include "golang/internal/reflectlite/value.h"
#include "golang/unsafe/unsafe.h"

namespace golang::reflectlite
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace abi::rec;
        using namespace reflectlite::rec;
        using namespace unsafe::rec;
    }

    
    template<typename T>
    Type::Type(T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(const T& ref)
    {
        value.reset(new TypeImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Type::Type(T* ptr)
    {
        value.reset(new TypeImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Type::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vName()
    {
        return rec::Name(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vPkgPath()
    {
        return rec::PkgPath(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    uintptr_t Type::TypeImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    abi::Kind Type::TypeImpl<T, StoreT>::vKind()
    {
        return rec::Kind(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vImplements(struct Type u)
    {
        return rec::Implements(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vAssignableTo(struct Type u)
    {
        return rec::AssignableTo(gocpp::PtrRecv<T, false>(value.get()), u);
    }
    template<typename T, typename StoreT>
    bool Type::TypeImpl<T, StoreT>::vComparable()
    {
        return rec::Comparable(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    std::string Type::TypeImpl<T, StoreT>::vString()
    {
        return rec::String(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct Type Type::TypeImpl<T, StoreT>::vElem()
    {
        return rec::Elem(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct abi::Type* Type::TypeImpl<T, StoreT>::vcommon()
    {
        return rec::common(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    struct uncommonType* Type::TypeImpl<T, StoreT>::vuncommon()
    {
        return rec::uncommon(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        std::string Name(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vName();
        }

        std::string Name(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vName();
        }

        std::string PkgPath(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vPkgPath();
        }

        std::string PkgPath(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vPkgPath();
        }

        uintptr_t Size(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vSize();
        }

        uintptr_t Size(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vSize();
        }

        abi::Kind Kind(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vKind();
        }

        abi::Kind Kind(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vKind();
        }

        bool Implements(const gocpp::PtrRecv<Type, false>& self, struct Type u)
        {
            return self.ptr->value->vImplements(u);
        }

        bool Implements(const gocpp::ObjRecv<Type>& self, struct Type u)
        {
            return self.obj.value->vImplements(u);
        }

        bool AssignableTo(const gocpp::PtrRecv<Type, false>& self, struct Type u)
        {
            return self.ptr->value->vAssignableTo(u);
        }

        bool AssignableTo(const gocpp::ObjRecv<Type>& self, struct Type u)
        {
            return self.obj.value->vAssignableTo(u);
        }

        bool Comparable(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vComparable();
        }

        bool Comparable(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vComparable();
        }

        std::string String(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vString();
        }

        std::string String(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vString();
        }

        struct Type Elem(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vElem();
        }

        struct Type Elem(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vElem();
        }

        struct abi::Type* common(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vcommon();
        }

        struct abi::Type* common(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vcommon();
        }

        struct uncommonType* uncommon(const gocpp::PtrRecv<Type, false>& self)
        {
            return self.ptr->value->vuncommon();
        }

        struct uncommonType* uncommon(const gocpp::ObjRecv<Type>& self)
        {
            return self.obj.value->vuncommon();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Type& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    rtype::operator T()
    {
        T result;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool rtype::operator==(const T& ref) const
    {
        return true;
    }

    std::ostream& rtype::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct rtype& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    mapType::operator T()
    {
        T result;
        result.Key = this->Key;
        result.Elem = this->Elem;
        result.Bucket = this->Bucket;
        result.Hasher = this->Hasher;
        result.KeySize = this->KeySize;
        result.ValueSize = this->ValueSize;
        result.BucketSize = this->BucketSize;
        result.Flags = this->Flags;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool mapType::operator==(const T& ref) const
    {
        if (Key != ref.Key) return false;
        if (Elem != ref.Elem) return false;
        if (Bucket != ref.Bucket) return false;
        if (Hasher != ref.Hasher) return false;
        if (KeySize != ref.KeySize) return false;
        if (ValueSize != ref.ValueSize) return false;
        if (BucketSize != ref.BucketSize) return false;
        if (Flags != ref.Flags) return false;
        return true;
    }

    std::ostream& mapType::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << Key;
        os << " " << Elem;
        os << " " << Bucket;
        os << " " << Hasher;
        os << " " << KeySize;
        os << " " << ValueSize;
        os << " " << BucketSize;
        os << " " << Flags;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct mapType& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    name::operator T()
    {
        T result;
        result.bytes = this->bytes;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool name::operator==(const T& ref) const
    {
        if (bytes != ref.bytes) return false;
        return true;
    }

    std::ostream& name::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << bytes;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct name& value)
    {
        return value.PrintTo(os);
    }

    unsigned char* rec::data(struct name n, int off, std::string whySafe)
    {
        return (unsigned char*)(add(unsafe::Pointer(n.bytes), uintptr_t(off), whySafe));
    }

    bool rec::isExported(struct name n)
    {
        return (*n.bytes) & (1 << 0) != 0;
    }

    bool rec::hasTag(struct name n)
    {
        return (*n.bytes) & (1 << 1) != 0;
    }

    bool rec::embedded(struct name n)
    {
        return (*n.bytes) & (1 << 3) != 0;
    }

    std::tuple<int, int> rec::readVarint(struct name n, int off)
    {
        auto v = 0;
        for(auto i = 0; ; i++)
        {
            auto x = *rec::data(gocpp::recv(n), off + i, "read varint");
            v += int(x & 0x7f) << (7 * i);
            if(x & 0x80 == 0)
            {
                return {i + 1, v};
            }
        }
    }

    std::string rec::name(struct name n)
    {
        if(n.bytes == nullptr)
        {
            return "";
        }
        auto [i, l] = rec::readVarint(gocpp::recv(n), 1);
        return unsafe::String(rec::data(gocpp::recv(n), 1 + i, "non-empty string"), l);
    }

    std::string rec::tag(struct name n)
    {
        if(! rec::hasTag(gocpp::recv(n)))
        {
            return "";
        }
        auto [i, l] = rec::readVarint(gocpp::recv(n), 1);
        auto [i2, l2] = rec::readVarint(gocpp::recv(n), 1 + i + l);
        return unsafe::String(rec::data(gocpp::recv(n), 1 + i + l + i2, "non-empty string"), l2);
    }

    std::string pkgPath(struct abi::Name n)
    {
        if(n->Bytes == nullptr || *rec::DataChecked(gocpp::recv(n), 0, "name flag field") & (1 << 2) == 0)
        {
            return "";
        }
        auto [i, l] = rec::ReadVarint(gocpp::recv(n), 1);
        auto off = 1 + i + l;
        if(rec::HasTag(gocpp::recv(n)))
        {
            auto [i2, l2] = rec::ReadVarint(gocpp::recv(n), off);
            off += i2 + l2;
        }
        int32_t nameOff = {};
        copy((gocpp::array<unsigned char, 4>*)(unsafe::Pointer(& nameOff)).make_slice(0, ), (gocpp::array<unsigned char, 4>*)(unsafe::Pointer(rec::DataChecked(gocpp::recv(n), off, "name offset field"))).make_slice(0, ));
        auto pkgPathName = name {(unsigned char*)(resolveTypeOff(unsafe::Pointer(n->Bytes), nameOff))};
        return rec::name(gocpp::recv(pkgPathName));
    }

    unsafe::Pointer resolveNameOff(unsafe::Pointer ptrInModule, int32_t off)
    /* convertBlockStmt, nil block */;

    unsafe::Pointer resolveTypeOff(unsafe::Pointer rtype, int32_t off)
    /* convertBlockStmt, nil block */;

    struct abi::Name rec::nameOff(struct rtype t, abi::nameOff off)
    {
        return gocpp::Init<abi::Name>([](abi::Name& x) { x.Bytes = (unsigned char*)(resolveNameOff(unsafe::Pointer(t.Type), int32_t(off))); });
    }

    struct abi::Type* rec::typeOff(struct rtype t, abi::typeOff off)
    {
        return (abi::Type*)(resolveTypeOff(unsafe::Pointer(t.Type), int32_t(off)));
    }

    struct uncommonType* rec::uncommon(struct rtype t)
    {
        return rec::Uncommon(gocpp::recv(t));
    }

    std::string rec::String(struct rtype t)
    {
        auto s = rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), t.Str)));
        if(t.TFlag & abi::TFlagExtraStar != 0)
        {
            return s.make_slice(1);
        }
        return s;
    }

    struct abi::Type* rec::common(struct rtype t)
    {
        return t.Type;
    }

    gocpp::slice<abi::Method> rec::exportedMethods(struct rtype t)
    {
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return nullptr;
        }
        return rec::ExportedMethods(gocpp::recv(ut));
    }

    int rec::NumMethod(struct rtype t)
    {
        auto tt = rec::InterfaceType(gocpp::recv(t.Type));
        if(tt != nullptr)
        {
            return rec::NumMethod(gocpp::recv(tt));
        }
        return len(rec::exportedMethods(gocpp::recv(t)));
    }

    std::string rec::PkgPath(struct rtype t)
    {
        if(t.TFlag & abi::TFlagNamed == 0)
        {
            return "";
        }
        auto ut = rec::uncommon(gocpp::recv(t));
        if(ut == nullptr)
        {
            return "";
        }
        return rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(t), ut->PkgPath)));
    }

    std::string rec::Name(struct rtype t)
    {
        if(! rec::HasName(gocpp::recv(t)))
        {
            return "";
        }
        auto s = rec::String(gocpp::recv(t));
        auto i = len(s) - 1;
        auto sqBrackets = 0;
        for(; i >= 0 && (s[i] != '.' || sqBrackets != 0); )
        {
            //Go switch emulation
            {
                auto condition = s[i];
                int conditionId = -1;
                if(condition == ']') { conditionId = 0; }
                else if(condition == '[') { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        sqBrackets++;
                        break;
                    case 1:
                        sqBrackets--;
                        break;
                }
            }
            i--;
        }
        return s.make_slice(i + 1);
    }

    struct rtype toRType(struct abi::Type* t)
    {
        return rtype {t};
    }

    struct abi::Type* elem(struct abi::Type* t)
    {
        auto et = rec::Elem(gocpp::recv(t));
        if(et != nullptr)
        {
            return et;
        }
        gocpp::panic("reflect: Elem of invalid type " + rec::String(gocpp::recv(toRType(t))));
    }

    struct Type rec::Elem(struct rtype t)
    {
        return toType(elem(rec::common(gocpp::recv(t))));
    }

    struct Type rec::In(struct rtype t, int i)
    {
        auto tt = rec::FuncType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: In of non-func type");
        }
        return toType(rec::InSlice(gocpp::recv(tt))[i]);
    }

    struct Type rec::Key(struct rtype t)
    {
        auto tt = rec::MapType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: Key of non-map type");
        }
        return toType(tt->Key);
    }

    int rec::Len(struct rtype t)
    {
        auto tt = rec::ArrayType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: Len of non-array type");
        }
        return int(tt->Len);
    }

    int rec::NumField(struct rtype t)
    {
        auto tt = rec::StructType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: NumField of non-struct type");
        }
        return len(tt->Fields);
    }

    int rec::NumIn(struct rtype t)
    {
        auto tt = rec::FuncType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: NumIn of non-func type");
        }
        return int(tt->InCount);
    }

    int rec::NumOut(struct rtype t)
    {
        auto tt = rec::FuncType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: NumOut of non-func type");
        }
        return rec::NumOut(gocpp::recv(tt));
    }

    struct Type rec::Out(struct rtype t, int i)
    {
        auto tt = rec::FuncType(gocpp::recv(t.Type));
        if(tt == nullptr)
        {
            gocpp::panic("reflect: Out of non-func type");
        }
        return toType(rec::OutSlice(gocpp::recv(tt))[i]);
    }

    unsafe::Pointer add(unsafe::Pointer p, uintptr_t x, std::string whySafe)
    {
        return unsafe::Pointer(uintptr_t(p) + x);
    }

    struct Type TypeOf(go_any i)
    {
        auto eface = *(emptyInterface*)(unsafe::Pointer(& i));
        return toType((abi::Type*)(noescape(unsafe::Pointer(eface.typ))));
    }

    bool rec::Implements(struct rtype t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.Implements");
        }
        if(rec::Kind(gocpp::recv(u)) != Interface)
        {
            gocpp::panic("reflect: non-interface type passed to Type.Implements");
        }
        return implements(rec::common(gocpp::recv(u)), rec::common(gocpp::recv(t)));
    }

    bool rec::AssignableTo(struct rtype t, struct Type u)
    {
        if(u == nullptr)
        {
            gocpp::panic("reflect: nil type passed to Type.AssignableTo");
        }
        auto uu = rec::common(gocpp::recv(u));
        auto tt = rec::common(gocpp::recv(t));
        return directlyAssignable(uu, tt) || implements(uu, tt);
    }

    bool rec::Comparable(struct rtype t)
    {
        return t.Equal != nullptr;
    }

    bool implements(struct abi::Type* T, struct abi::Type* V)
    {
        auto t = rec::InterfaceType(gocpp::recv(T));
        if(t == nullptr)
        {
            return false;
        }
        if(len(t->Methods) == 0)
        {
            return true;
        }
        auto rT = toRType(T);
        auto rV = toRType(V);
        if(rec::Kind(gocpp::recv(V)) == Interface)
        {
            auto v = (interfaceType*)(unsafe::Pointer(V));
            auto i = 0;
            for(auto j = 0; j < len(v->Methods); j++)
            {
                auto tm = & t->Methods[i];
                auto tmName = rec::nameOff(gocpp::recv(rT), tm->Name);
                auto vm = & v->Methods[j];
                auto vmName = rec::nameOff(gocpp::recv(rV), vm->Name);
                if(rec::Name(gocpp::recv(vmName)) == rec::Name(gocpp::recv(tmName)) && rec::typeOff(gocpp::recv(rV), vm->Typ) == rec::typeOff(gocpp::recv(rT), tm->Typ))
                {
                    if(! rec::IsExported(gocpp::recv(tmName)))
                    {
                        auto tmPkgPath = pkgPath(tmName);
                        if(tmPkgPath == "")
                        {
                            tmPkgPath = rec::Name(gocpp::recv(t->PkgPath));
                        }
                        auto vmPkgPath = pkgPath(vmName);
                        if(vmPkgPath == "")
                        {
                            vmPkgPath = rec::Name(gocpp::recv(v->PkgPath));
                        }
                        if(tmPkgPath != vmPkgPath)
                        {
                            continue;
                        }
                    }
                    if(i++; i >= len(t->Methods))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        auto v = rec::Uncommon(gocpp::recv(V));
        if(v == nullptr)
        {
            return false;
        }
        auto i = 0;
        auto vmethods = rec::Methods(gocpp::recv(v));
        for(auto j = 0; j < int(v->Mcount); j++)
        {
            auto tm = & t->Methods[i];
            auto tmName = rec::nameOff(gocpp::recv(rT), tm->Name);
            auto vm = vmethods[j];
            auto vmName = rec::nameOff(gocpp::recv(rV), vm.Name);
            if(rec::Name(gocpp::recv(vmName)) == rec::Name(gocpp::recv(tmName)) && rec::typeOff(gocpp::recv(rV), vm.Mtyp) == rec::typeOff(gocpp::recv(rT), tm->Typ))
            {
                if(! rec::IsExported(gocpp::recv(tmName)))
                {
                    auto tmPkgPath = pkgPath(tmName);
                    if(tmPkgPath == "")
                    {
                        tmPkgPath = rec::Name(gocpp::recv(t->PkgPath));
                    }
                    auto vmPkgPath = pkgPath(vmName);
                    if(vmPkgPath == "")
                    {
                        vmPkgPath = rec::Name(gocpp::recv(rec::nameOff(gocpp::recv(rV), v->PkgPath)));
                    }
                    if(tmPkgPath != vmPkgPath)
                    {
                        continue;
                    }
                }
                if(i++; i >= len(t->Methods))
                {
                    return true;
                }
            }
        }
        return false;
    }

    bool directlyAssignable(struct abi::Type* T, struct abi::Type* V)
    {
        if(T == V)
        {
            return true;
        }
        if(rec::HasName(gocpp::recv(T)) && rec::HasName(gocpp::recv(V)) || rec::Kind(gocpp::recv(T)) != rec::Kind(gocpp::recv(V)))
        {
            return false;
        }
        return haveIdenticalUnderlyingType(T, V, true);
    }

    bool haveIdenticalType(struct abi::Type* T, struct abi::Type* V, bool cmpTags)
    {
        if(cmpTags)
        {
            return T == V;
        }
        if(rec::Name(gocpp::recv(toRType(T))) != rec::Name(gocpp::recv(toRType(V))) || rec::Kind(gocpp::recv(T)) != rec::Kind(gocpp::recv(V)))
        {
            return false;
        }
        return haveIdenticalUnderlyingType(T, V, false);
    }

    bool haveIdenticalUnderlyingType(struct abi::Type* T, struct abi::Type* V, bool cmpTags)
    {
        if(T == V)
        {
            return true;
        }
        auto kind = rec::Kind(gocpp::recv(T));
        if(kind != rec::Kind(gocpp::recv(V)))
        {
            return false;
        }
        if(abi::Bool <= kind && kind <= abi::Complex128 || kind == abi::String || kind == abi::UnsafePointer)
        {
            return true;
        }
        //Go switch emulation
        {
            auto condition = kind;
            int conditionId = -1;
            if(condition == abi::Array) { conditionId = 0; }
            else if(condition == abi::Chan) { conditionId = 1; }
            else if(condition == abi::Func) { conditionId = 2; }
            else if(condition == Interface) { conditionId = 3; }
            else if(condition == abi::Map) { conditionId = 4; }
            else if(condition == Ptr) { conditionId = 5; }
            else if(condition == abi::Slice) { conditionId = 6; }
            else if(condition == abi::Struct) { conditionId = 7; }
            switch(conditionId)
            {
                case 0:
                    return rec::Len(gocpp::recv(T)) == rec::Len(gocpp::recv(V)) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 1:
                    if(rec::ChanDir(gocpp::recv(V)) == abi::BothDir && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags))
                    {
                        return true;
                    }
                    return rec::ChanDir(gocpp::recv(V)) == rec::ChanDir(gocpp::recv(T)) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 2:
                    auto t = (funcType*)(unsafe::Pointer(T));
                    auto v = (funcType*)(unsafe::Pointer(V));
                    if(t->OutCount != v->OutCount || t->InCount != v->InCount)
                    {
                        return false;
                    }
                    for(auto i = 0; i < rec::NumIn(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(rec::In(gocpp::recv(t), i), rec::In(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    for(auto i = 0; i < rec::NumOut(gocpp::recv(t)); i++)
                    {
                        if(! haveIdenticalType(rec::Out(gocpp::recv(t), i), rec::Out(gocpp::recv(v), i), cmpTags))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
                case 3:
                    auto t = (interfaceType*)(unsafe::Pointer(T));
                    auto v = (interfaceType*)(unsafe::Pointer(V));
                    if(len(t->Methods) == 0 && len(v->Methods) == 0)
                    {
                        return true;
                    }
                    return false;
                    break;
                case 4:
                    return haveIdenticalType(rec::Key(gocpp::recv(T)), rec::Key(gocpp::recv(V)), cmpTags) && haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 5:
                case 6:
                    return haveIdenticalType(rec::Elem(gocpp::recv(T)), rec::Elem(gocpp::recv(V)), cmpTags);
                    break;
                case 7:
                    auto t = (structType*)(unsafe::Pointer(T));
                    auto v = (structType*)(unsafe::Pointer(V));
                    if(len(t->Fields) != len(v->Fields))
                    {
                        return false;
                    }
                    if(rec::Name(gocpp::recv(t->PkgPath)) != rec::Name(gocpp::recv(v->PkgPath)))
                    {
                        return false;
                    }
                    for(auto [i, gocpp_ignored] : t->Fields)
                    {
                        auto tf = & t->Fields[i];
                        auto vf = & v->Fields[i];
                        if(rec::Name(gocpp::recv(tf->Name)) != rec::Name(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(! haveIdenticalType(tf->Typ, vf->Typ, cmpTags))
                        {
                            return false;
                        }
                        if(cmpTags && rec::Tag(gocpp::recv(tf->Name)) != rec::Tag(gocpp::recv(vf->Name)))
                        {
                            return false;
                        }
                        if(tf->Offset != vf->Offset)
                        {
                            return false;
                        }
                        if(rec::Embedded(gocpp::recv(tf)) != rec::Embedded(gocpp::recv(vf)))
                        {
                            return false;
                        }
                    }
                    return true;
                    break;
            }
        }
        return false;
    }

    struct Type toType(struct abi::Type* t)
    {
        if(t == nullptr)
        {
            return nullptr;
        }
        return toRType(t);
    }

    bool ifaceIndir(struct abi::Type* t)
    {
        return t->Kind_ & abi::KindDirectIface == 0;
    }

}

