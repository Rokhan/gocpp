// generated by GoCpp from file '$(ImportDir)/encoding/base64/base64.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/encoding/base64/base64.h"
#include "gocpp/support.h"

#include "golang/encoding/binary/binary.h"
#include "golang/io/io.h"
#include "golang/slices/slices.h"
#include "golang/strconv/atoi.h"
#include "golang/strconv/itoa.h"

// Package base64 implements base64 encoding as specified by RFC 4648.
namespace golang::base64
{
    namespace rec
    {
        using namespace mocklib::rec;
        using binary::rec::PutUint32;
        using binary::rec::PutUint64;
        using io::rec::Read;
        using io::rec::Write;
    }

    // An Encoding is a radix 64 encoding/decoding scheme, defined by a
    // 64-character alphabet. The most common encoding is the "base64"
    // encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM
    // (RFC 1421).  RFC 4648 also defines an alternate encoding, which is
    // the standard encoding with - and _ substituted for + and /.
    
    template<typename T> requires gocpp::GoStruct<T>
    Encoding::operator T()
    {
        T result;
        result.encode = this->encode;
        result.decodeMap = this->decodeMap;
        result.padChar = this->padChar;
        result.strict = this->strict;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool Encoding::operator==(const T& ref) const
    {
        if (encode != ref.encode) return false;
        if (decodeMap != ref.decodeMap) return false;
        if (padChar != ref.padChar) return false;
        if (strict != ref.strict) return false;
        return true;
    }

    std::ostream& Encoding::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << encode;
        os << " " << decodeMap;
        os << " " << padChar;
        os << " " << strict;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct Encoding& value)
    {
        return value.PrintTo(os);
    }

    std::string decodeMapInitialize = ""s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s + "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"s;
    // NewEncoding returns a new padded Encoding defined by the given alphabet,
    // which must be a 64-byte string that contains unique byte values and
    // does not contain the padding character or CR / LF ('\r', '\n').
    // The alphabet is treated as a sequence of byte values
    // without any special treatment for multi-byte UTF-8.
    // The resulting Encoding uses the default padding character ('='),
    // which may be changed or disabled via [Encoding.WithPadding].
    struct Encoding* NewEncoding(std::string encoder)
    {
        if(len(encoder) != 64)
        {
            gocpp::panic("encoding alphabet is not 64-bytes long"s);
        }
        auto e = new(Encoding);
        e->padChar = StdPadding;
        copy(e->encode.make_slice(0), encoder);
        copy(e->decodeMap.make_slice(0), decodeMapInitialize);
        for(auto i = 0; i < len(encoder); i++)
        {
            //Go switch emulation
            {
                int conditionId = -1;
                if(encoder[i] == '\n' || encoder[i] == '\r') { conditionId = 0; }
                else if(e->decodeMap[encoder[i]] != invalidIndex) { conditionId = 1; }
                switch(conditionId)
                {
                    case 0:
                        gocpp::panic("encoding alphabet contains newline character"s);
                        break;
                    case 1:
                        gocpp::panic("encoding alphabet includes duplicate symbols"s);
                        break;
                }
            }
            e->decodeMap[encoder[i]] = uint8_t(i);
        }
        return e;
    }

    // WithPadding creates a new encoding identical to enc except
    // with a specified padding character, or [NoPadding] to disable padding.
    // The padding character must not be '\r' or '\n',
    // must not be contained in the encoding's alphabet,
    // must not be negative, and must be a rune equal or below '\xff'.
    // Padding characters above '\x7f' are encoded as their exact byte value
    // rather than using the UTF-8 representation of the codepoint.
    struct Encoding* rec::WithPadding(struct Encoding enc, gocpp::rune padding)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(padding < NoPadding || padding == '\r' || padding == '\n' || padding > 0xff) { conditionId = 0; }
            else if(padding != NoPadding && enc.decodeMap[(unsigned char)(padding)] != invalidIndex) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    gocpp::panic("invalid padding"s);
                    break;
                case 1:
                    gocpp::panic("padding contained in alphabet"s);
                    break;
            }
        }
        enc.padChar = padding;
        return & enc;
    }

    // Strict creates a new encoding identical to enc except with
    // strict decoding enabled. In this mode, the decoder requires that
    // trailing padding bits are zero, as described in RFC 4648 section 3.5.
    //
    // Note that the input is still malleable, as new line characters
    // (CR and LF) are still ignored.
    struct Encoding* rec::Strict(struct Encoding enc)
    {
        enc.strict = true;
        return & enc;
    }

    // StdEncoding is the standard base64 encoding, as defined in RFC 4648.
    Encoding* StdEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"s);
    // URLEncoding is the alternate base64 encoding defined in RFC 4648.
    // It is typically used in URLs and file names.
    Encoding* URLEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"s);
    // RawStdEncoding is the standard raw, unpadded base64 encoding,
    // as defined in RFC 4648 section 3.2.
    // This is the same as [StdEncoding] but omits padding characters.
    Encoding* RawStdEncoding = rec::WithPadding(gocpp::recv(StdEncoding), NoPadding);
    // RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.
    // It is typically used in URLs and file names.
    // This is the same as [URLEncoding] but omits padding characters.
    Encoding* RawURLEncoding = rec::WithPadding(gocpp::recv(URLEncoding), NoPadding);
    // Encode encodes src using the encoding enc,
    // writing [Encoding.EncodedLen](len(src)) bytes to dst.
    //
    // The encoding pads the output to a multiple of 4 bytes,
    // so Encode is not appropriate for use on individual blocks
    // of a large data stream. Use [NewEncoder] instead.
    void rec::Encode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        if(len(src) == 0)
        {
            return;
        }
        _ = enc->encode;
        auto [di, si] = std::tuple{0, 0};
        auto n = (len(src) / 3) * 3;
        for(; si < n; )
        {
            auto val = ((unsigned int)(src[si + 0]) << 16) | ((unsigned int)(src[si + 1]) << 8) | (unsigned int)(src[si + 2]);
            dst[di + 0] = enc->encode[(val >> 18) & 0x3F];
            dst[di + 1] = enc->encode[(val >> 12) & 0x3F];
            dst[di + 2] = enc->encode[(val >> 6) & 0x3F];
            dst[di + 3] = enc->encode[val & 0x3F];
            si += 3;
            di += 4;
        }
        auto remain = len(src) - si;
        if(remain == 0)
        {
            return;
        }
        auto val = (unsigned int)(src[si + 0]) << 16;
        if(remain == 2)
        {
            val |= (unsigned int)(src[si + 1]) << 8;
        }
        dst[di + 0] = enc->encode[(val >> 18) & 0x3F];
        dst[di + 1] = enc->encode[(val >> 12) & 0x3F];
        //Go switch emulation
        {
            auto condition = remain;
            int conditionId = -1;
            if(condition == 2) { conditionId = 0; }
            else if(condition == 1) { conditionId = 1; }
            switch(conditionId)
            {
                case 0:
                    dst[di + 2] = enc->encode[(val >> 6) & 0x3F];
                    if(enc->padChar != NoPadding)
                    {
                        dst[di + 3] = (unsigned char)(enc->padChar);
                    }
                    break;
                case 1:
                    if(enc->padChar != NoPadding)
                    {
                        dst[di + 2] = (unsigned char)(enc->padChar);
                        dst[di + 3] = (unsigned char)(enc->padChar);
                    }
                    break;
            }
        }
    }

    // AppendEncode appends the base64 encoded src to dst
    // and returns the extended buffer.
    gocpp::slice<unsigned char> rec::AppendEncode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto n = rec::EncodedLen(gocpp::recv(enc), len(src));
        dst = slices::Grow(dst, n);
        rec::Encode(gocpp::recv(enc), dst.make_slice(len(dst)).make_slice(0, n), src);
        return dst.make_slice(0, len(dst) + n);
    }

    // EncodeToString returns the base64 encoding of src.
    std::string rec::EncodeToString(struct Encoding* enc, gocpp::slice<unsigned char> src)
    {
        auto buf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), rec::EncodedLen(gocpp::recv(enc), len(src)));
        rec::Encode(gocpp::recv(enc), buf, src);
        return std::string(buf);
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    encoder::operator T()
    {
        T result;
        result.err = this->err;
        result.enc = this->enc;
        result.w = this->w;
        result.buf = this->buf;
        result.nbuf = this->nbuf;
        result.out = this->out;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool encoder::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (enc != ref.enc) return false;
        if (w != ref.w) return false;
        if (buf != ref.buf) return false;
        if (nbuf != ref.nbuf) return false;
        if (out != ref.out) return false;
        return true;
    }

    std::ostream& encoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << enc;
        os << " " << w;
        os << " " << buf;
        os << " " << nbuf;
        os << " " << out;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct encoder& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Write(struct encoder* e, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(e->err != nullptr)
        {
            return {0, e->err};
        }
        if(e->nbuf > 0)
        {
            int i = {};
            for(i = 0; i < len(p) && e->nbuf < 3; i++)
            {
                e->buf[e->nbuf] = p[i];
                e->nbuf++;
            }
            n += i;
            p = p.make_slice(i);
            if(e->nbuf < 3)
            {
                return {n, err};
            }
            rec::Encode(gocpp::recv(e->enc), e->out.make_slice(0), e->buf.make_slice(0));
            if(std::tie(gocpp_id_0, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, 4)); e->err != nullptr)
            {
                return {n, e->err};
            }
            e->nbuf = 0;
        }
        for(; len(p) >= 3; )
        {
            auto nn = len(e->out) / 4 * 3;
            if(nn > len(p))
            {
                nn = len(p);
                nn -= nn % 3;
            }
            rec::Encode(gocpp::recv(e->enc), e->out.make_slice(0), p.make_slice(0, nn));
            if(std::tie(gocpp_id_1, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, nn / 3 * 4)); e->err != nullptr)
            {
                return {n, e->err};
            }
            n += nn;
            p = p.make_slice(nn);
        }
        copy(e->buf.make_slice(0), p);
        e->nbuf = len(p);
        n += len(p);
        return {n, err};
    }

    // Close flushes any pending output from the encoder.
    // It is an error to call Write after calling Close.
    struct gocpp::error rec::Close(struct encoder* e)
    {
        if(e->err == nullptr && e->nbuf > 0)
        {
            rec::Encode(gocpp::recv(e->enc), e->out.make_slice(0), e->buf.make_slice(0, e->nbuf));
            std::tie(gocpp_id_2, e->err) = rec::Write(gocpp::recv(e->w), e->out.make_slice(0, rec::EncodedLen(gocpp::recv(e->enc), e->nbuf)));
            e->nbuf = 0;
        }
        return e->err;
    }

    // NewEncoder returns a new base64 stream encoder. Data written to
    // the returned writer will be encoded using enc and then written to w.
    // Base64 encodings operate in 4-byte blocks; when finished
    // writing, the caller must Close the returned encoder to flush any
    // partially written blocks.
    io::WriteCloser NewEncoder(struct Encoding* enc, io::Writer w)
    {
        return gocpp::InitPtr<encoder>([=](auto& x) {
            x.enc = enc;
            x.w = w;
        });
    }

    // EncodedLen returns the length in bytes of the base64 encoding
    // of an input buffer of length n.
    int rec::EncodedLen(struct Encoding* enc, int n)
    {
        if(enc->padChar == NoPadding)
        {
            return n / 3 * 4 + (n % 3 * 8 + 5) / 6;
        }
        return (n + 2) / 3 * 4;
    }

    std::string rec::Error(golang::base64::CorruptInputError e)
    {
        return "illegal base64 data at input byte "s + strconv::FormatInt(int64_t(e), 10);
    }

    // decodeQuantum decodes up to 4 base64 bytes. The received parameters are
    // the destination buffer dst, the source buffer src and an index in the
    // source buffer si.
    // It returns the number of bytes read from src, the number of bytes written
    // to dst, and an error, if any.
    std::tuple<int, int, struct gocpp::error> rec::decodeQuantum(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src, int si)
    {
        int nsi;
        int n;
        struct gocpp::error err;
        // Decode quantum using the base64 alphabet
        gocpp::array<unsigned char, 4> dbuf = {};
        auto dlen = 4;
        _ = enc->decodeMap;
        for(auto j = 0; j < len(dbuf); j++)
        {
            if(len(src) == si)
            {
                //Go switch emulation
                {
                    int conditionId = -1;
                    if(j == 0) { conditionId = 0; }
                    else if(j == 1) { conditionId = 1; }
                    else if(enc->padChar != NoPadding) { conditionId = 2; }
                    switch(conditionId)
                    {
                        case 0:
                            return {si, 0, nullptr};
                            break;
                        case 1:
                        case 2:
                            return {si, 0, CorruptInputError(si - j)};
                            break;
                    }
                }
                dlen = j;
                break;
            }
            auto in = src[si];
            si++;
            auto out = enc->decodeMap[in];
            if(out != 0xff)
            {
                dbuf[j] = out;
                continue;
            }
            if(in == '\n' || in == '\r')
            {
                j--;
                continue;
            }
            if(gocpp::rune(in) != enc->padChar)
            {
                return {si, 0, CorruptInputError(si - 1)};
            }
            //Go switch emulation
            {
                auto condition = j;
                int conditionId = -1;
                if(condition == 0) { conditionId = 0; }
                else if(condition == 1) { conditionId = 1; }
                else if(condition == 2) { conditionId = 2; }
                switch(conditionId)
                {
                    case 0:
                    case 1:
                        return {si, 0, CorruptInputError(si - 1)};
                        break;
                    case 2:
                        for(; si < len(src) && (src[si] == '\n' || src[si] == '\r'); )
                        {
                            si++;
                        }
                        if(si == len(src))
                        {
                            return {si, 0, CorruptInputError(len(src))};
                        }
                        if(gocpp::rune(src[si]) != enc->padChar)
                        {
                            return {si, 0, CorruptInputError(si - 1)};
                        }
                        si++;
                        break;
                }
            }
            for(; si < len(src) && (src[si] == '\n' || src[si] == '\r'); )
            {
                si++;
            }
            if(si < len(src))
            {
                err = CorruptInputError(si);
            }
            dlen = j;
            break;
        }
        auto val = ((unsigned int)(dbuf[0]) << 18) | ((unsigned int)(dbuf[1]) << 12) | ((unsigned int)(dbuf[2]) << 6) | (unsigned int)(dbuf[3]);
        std::tie(dbuf[2], dbuf[1], dbuf[0]) = std::tuple{(unsigned char)(val >> 0), (unsigned char)(val >> 8), (unsigned char)(val >> 16)};
        //Go switch emulation
        {
            auto condition = dlen;
            int conditionId = -1;
            if(condition == 4) { conditionId = 0; }
            else if(condition == 3) { conditionId = 1; }
            else if(condition == 2) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    dst[2] = dbuf[2];
                    dbuf[2] = 0;
                case 1:
                    dst[1] = dbuf[1];
                    if(enc->strict && dbuf[2] != 0)
                    {
                        return {si, 0, CorruptInputError(si - 1)};
                    }
                    dbuf[1] = 0;
                case 2:
                    dst[0] = dbuf[0];
                    if(enc->strict && (dbuf[1] != 0 || dbuf[2] != 0))
                    {
                        return {si, 0, CorruptInputError(si - 2)};
                    }
                    break;
            }
        }
        return {si, dlen - 1, err};
    }

    // AppendDecode appends the base64 decoded src to dst
    // and returns the extended buffer.
    // If the input is malformed, it returns the partially decoded src and an error.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::AppendDecode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        auto n = len(src);
        for(; n > 0 && gocpp::rune(src[n - 1]) == enc->padChar; )
        {
            n--;
        }
        n = decodedLen(n, NoPadding);
        dst = slices::Grow(dst, n);
        gocpp::error err;
        std::tie(n, err) = rec::Decode(gocpp::recv(enc), dst.make_slice(len(dst)).make_slice(0, n), src);
        return {dst.make_slice(0, len(dst) + n), err};
    }

    // DecodeString returns the bytes represented by the base64 string s.
    std::tuple<gocpp::slice<unsigned char>, struct gocpp::error> rec::DecodeString(struct Encoding* enc, std::string s)
    {
        auto dbuf = gocpp::make(gocpp::Tag<gocpp::slice<unsigned char>>(), rec::DecodedLen(gocpp::recv(enc), len(s)));
        auto [n, err] = rec::Decode(gocpp::recv(enc), dbuf, gocpp::slice<unsigned char>(s));
        return {dbuf.make_slice(0, n), err};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    decoder::operator T()
    {
        T result;
        result.err = this->err;
        result.readErr = this->readErr;
        result.enc = this->enc;
        result.r = this->r;
        result.buf = this->buf;
        result.nbuf = this->nbuf;
        result.out = this->out;
        result.outbuf = this->outbuf;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool decoder::operator==(const T& ref) const
    {
        if (err != ref.err) return false;
        if (readErr != ref.readErr) return false;
        if (enc != ref.enc) return false;
        if (r != ref.r) return false;
        if (buf != ref.buf) return false;
        if (nbuf != ref.nbuf) return false;
        if (out != ref.out) return false;
        if (outbuf != ref.outbuf) return false;
        return true;
    }

    std::ostream& decoder::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << err;
        os << " " << readErr;
        os << " " << enc;
        os << " " << r;
        os << " " << buf;
        os << " " << nbuf;
        os << " " << out;
        os << " " << outbuf;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct decoder& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct decoder* d, gocpp::slice<unsigned char> p)
    {
        int n;
        struct gocpp::error err;
        if(len(d->out) > 0)
        {
            n = copy(p, d->out);
            d->out = d->out.make_slice(n);
            return {n, nullptr};
        }
        if(d->err != nullptr)
        {
            return {0, d->err};
        }
        for(; d->nbuf < 4 && d->readErr == nullptr; )
        {
            auto nn = len(p) / 3 * 4;
            if(nn < 4)
            {
                nn = 4;
            }
            if(nn > len(d->buf))
            {
                nn = len(d->buf);
            }
            std::tie(nn, d->readErr) = rec::Read(gocpp::recv(d->r), d->buf.make_slice(d->nbuf, nn));
            d->nbuf += nn;
        }
        if(d->nbuf < 4)
        {
            if(d->enc->padChar == NoPadding && d->nbuf > 0)
            {
                // Decode final fragment, without padding.
                int nw = {};
                std::tie(nw, d->err) = rec::Decode(gocpp::recv(d->enc), d->outbuf.make_slice(0), d->buf.make_slice(0, d->nbuf));
                d->nbuf = 0;
                d->out = d->outbuf.make_slice(0, nw);
                n = copy(p, d->out);
                d->out = d->out.make_slice(n);
                if(n > 0 || len(p) == 0 && len(d->out) > 0)
                {
                    return {n, nullptr};
                }
                if(d->err != nullptr)
                {
                    return {0, d->err};
                }
            }
            d->err = d->readErr;
            if(d->err == io::go_EOF && d->nbuf > 0)
            {
                d->err = io::ErrUnexpectedEOF;
            }
            return {0, d->err};
        }
        auto nr = d->nbuf / 4 * 4;
        auto nw = d->nbuf / 4 * 3;
        if(nw > len(p))
        {
            std::tie(nw, d->err) = rec::Decode(gocpp::recv(d->enc), d->outbuf.make_slice(0), d->buf.make_slice(0, nr));
            d->out = d->outbuf.make_slice(0, nw);
            n = copy(p, d->out);
            d->out = d->out.make_slice(n);
        }
        else
        {
            std::tie(n, d->err) = rec::Decode(gocpp::recv(d->enc), p, d->buf.make_slice(0, nr));
        }
        d->nbuf -= nr;
        copy(d->buf.make_slice(0, d->nbuf), d->buf.make_slice(nr));
        return {n, d->err};
    }

    // Decode decodes src using the encoding enc. It writes at most
    // [Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes
    // written. If src contains invalid base64 data, it will return the
    // number of bytes successfully written and [CorruptInputError].
    // New line characters (\r and \n) are ignored.
    std::tuple<int, struct gocpp::error> rec::Decode(struct Encoding* enc, gocpp::slice<unsigned char> dst, gocpp::slice<unsigned char> src)
    {
        int n;
        struct gocpp::error err;
        if(len(src) == 0)
        {
            return {0, nullptr};
        }
        _ = enc->decodeMap;
        auto si = 0;
        for(; strconv::IntSize >= 64 && len(src) - si >= 8 && len(dst) - n >= 8; )
        {
            auto src2 = src.make_slice(si, si + 8);
            if(auto [dn, ok] = assemble64(enc->decodeMap[src2[0]], enc->decodeMap[src2[1]], enc->decodeMap[src2[2]], enc->decodeMap[src2[3]], enc->decodeMap[src2[4]], enc->decodeMap[src2[5]], enc->decodeMap[src2[6]], enc->decodeMap[src2[7]]); ok)
            {
                rec::PutUint64(gocpp::recv(binary::BigEndian), dst.make_slice(n), dn);
                n += 6;
                si += 8;
            }
            else
            {
                int ninc = {};
                std::tie(si, ninc, err) = rec::decodeQuantum(gocpp::recv(enc), dst.make_slice(n), src, si);
                n += ninc;
                if(err != nullptr)
                {
                    return {n, err};
                }
            }
        }
        for(; len(src) - si >= 4 && len(dst) - n >= 4; )
        {
            auto src2 = src.make_slice(si, si + 4);
            if(auto [dn, ok] = assemble32(enc->decodeMap[src2[0]], enc->decodeMap[src2[1]], enc->decodeMap[src2[2]], enc->decodeMap[src2[3]]); ok)
            {
                rec::PutUint32(gocpp::recv(binary::BigEndian), dst.make_slice(n), dn);
                n += 3;
                si += 4;
            }
            else
            {
                int ninc = {};
                std::tie(si, ninc, err) = rec::decodeQuantum(gocpp::recv(enc), dst.make_slice(n), src, si);
                n += ninc;
                if(err != nullptr)
                {
                    return {n, err};
                }
            }
        }
        for(; si < len(src); )
        {
            int ninc = {};
            std::tie(si, ninc, err) = rec::decodeQuantum(gocpp::recv(enc), dst.make_slice(n), src, si);
            n += ninc;
            if(err != nullptr)
            {
                return {n, err};
            }
        }
        return {n, err};
    }

    // assemble32 assembles 4 base64 digits into 3 bytes.
    // Each digit comes from the decode map, and will be 0xff
    // if it came from an invalid character.
    std::tuple<uint32_t, bool> assemble32(unsigned char n1, unsigned char n2, unsigned char n3, unsigned char n4)
    {
        uint32_t dn;
        bool ok;
        if(n1 | n2 | n3 | n4 == 0xff)
        {
            return {0, false};
        }
        return {(uint32_t(n1) << 26) | (uint32_t(n2) << 20) | (uint32_t(n3) << 14) | (uint32_t(n4) << 8), true};
    }

    // assemble64 assembles 8 base64 digits into 6 bytes.
    // Each digit comes from the decode map, and will be 0xff
    // if it came from an invalid character.
    std::tuple<uint64_t, bool> assemble64(unsigned char n1, unsigned char n2, unsigned char n3, unsigned char n4, unsigned char n5, unsigned char n6, unsigned char n7, unsigned char n8)
    {
        uint64_t dn;
        bool ok;
        if(n1 | n2 | n3 | n4 | n5 | n6 | n7 | n8 == 0xff)
        {
            return {0, false};
        }
        return {(uint64_t(n1) << 58) | (uint64_t(n2) << 52) | (uint64_t(n3) << 46) | (uint64_t(n4) << 40) | (uint64_t(n5) << 34) | (uint64_t(n6) << 28) | (uint64_t(n7) << 22) | (uint64_t(n8) << 16), true};
    }

    
    template<typename T> requires gocpp::GoStruct<T>
    newlineFilteringReader::operator T()
    {
        T result;
        result.wrapped = this->wrapped;
        return result;
    }

    template<typename T> requires gocpp::GoStruct<T>
    bool newlineFilteringReader::operator==(const T& ref) const
    {
        if (wrapped != ref.wrapped) return false;
        return true;
    }

    std::ostream& newlineFilteringReader::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << wrapped;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct newlineFilteringReader& value)
    {
        return value.PrintTo(os);
    }

    std::tuple<int, struct gocpp::error> rec::Read(struct newlineFilteringReader* r, gocpp::slice<unsigned char> p)
    {
        auto [n, err] = rec::Read(gocpp::recv(r->wrapped), p);
        for(; n > 0; )
        {
            auto offset = 0;
            for(auto [i, b] : p.make_slice(0, n))
            {
                if(b != '\r' && b != '\n')
                {
                    if(i != offset)
                    {
                        p[offset] = b;
                    }
                    offset++;
                }
            }
            if(offset > 0)
            {
                return {offset, err};
            }
            std::tie(n, err) = rec::Read(gocpp::recv(r->wrapped), p);
        }
        return {n, err};
    }

    // NewDecoder constructs a new base64 stream decoder.
    io::Reader NewDecoder(struct Encoding* enc, io::Reader r)
    {
        return gocpp::InitPtr<decoder>([=](auto& x) {
            x.enc = enc;
            x.r = new newlineFilteringReader {r};
        });
    }

    // DecodedLen returns the maximum length in bytes of the decoded data
    // corresponding to n bytes of base64-encoded data.
    int rec::DecodedLen(struct Encoding* enc, int n)
    {
        return decodedLen(n, enc->padChar);
    }

    int decodedLen(int n, gocpp::rune padChar)
    {
        if(padChar == NoPadding)
        {
            return n / 4 * 3 + n % 4 * 6 / 8;
        }
        return n / 4 * 3;
    }

}

