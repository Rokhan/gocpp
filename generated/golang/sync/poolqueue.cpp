// generated by GoCpp from file '$(ImportDir)/sync/poolqueue.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/sync/poolqueue.h"
#include "gocpp/support.h"

// #include "golang/sync/atomic/doc.h"  [Ignored, known errors]
#include "golang/sync/atomic/type.h"
#include "golang/unsafe/unsafe.h"

namespace golang::sync
{
    
    std::ostream& poolDequeue::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << headTail;
        os << " " << vals;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolDequeue& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& eface::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << typ;
        os << " " << val;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct eface& value)
    {
        return value.PrintTo(os);
    }

    int dequeueBits = 32;
    int dequeueLimit = (1 << dequeueBits) / 4;
    struct gocpp_id_0
    {

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const
        {
            os << '{';
            os << '}';
            return os;
        }
    };
    std::tuple<uint32_t, uint32_t> unpack(struct poolDequeue* d, uint64_t ptrs)
    {
        uint32_t head;
        uint32_t tail;
        auto mask = (1 << dequeueBits) - 1;
        head = uint32_t((ptrs >> dequeueBits) & mask);
        tail = uint32_t(ptrs & mask);
        return {head, tail};
    }

    uint64_t pack(struct poolDequeue* d, uint32_t head, uint32_t tail)
    {
        auto mask = (1 << dequeueBits) - 1;
        return (uint64_t(head) << dequeueBits) | uint64_t(tail & mask);
    }

    bool pushHead(struct poolDequeue* d, go_any val)
    {
        auto ptrs = Load(gocpp::recv(d->headTail));
        auto [head, tail] = unpack(gocpp::recv(d), ptrs);
        if((tail + uint32_t(len(d->vals))) & ((1 << dequeueBits) - 1) == head)
        {
            return false;
        }
        auto slot = & d->vals[head & uint32_t(len(d->vals) - 1)];
        auto typ = LoadPointer(gocpp::recv(atomic), & slot->typ);
        if(typ != nullptr)
        {
            return false;
        }
        if(val == nullptr)
        {
            val = dequeueNil(nullptr);
        }
        *(*go_any)(Pointer(gocpp::recv(unsafe), slot)) = val;
        Add(gocpp::recv(d->headTail), 1 << dequeueBits);
        return true;
    }

    std::tuple<go_any, bool> popHead(struct poolDequeue* d)
    {
        eface* slot = {};
        for(; ; )
        {
            auto ptrs = Load(gocpp::recv(d->headTail));
            auto [head, tail] = unpack(gocpp::recv(d), ptrs);
            if(tail == head)
            {
                return {nullptr, false};
            }
            head--;
            auto ptrs2 = pack(gocpp::recv(d), head, tail);
            if(CompareAndSwap(gocpp::recv(d->headTail), ptrs, ptrs2))
            {
                slot = & d->vals[head & uint32_t(len(d->vals) - 1)];
                break;
            }
        }
        auto val = *(*go_any)(Pointer(gocpp::recv(unsafe), slot));
        if(val == dequeueNil(nullptr))
        {
            val = nullptr;
        }
        *slot = eface {};
        return {val, true};
    }

    std::tuple<go_any, bool> popTail(struct poolDequeue* d)
    {
        eface* slot = {};
        for(; ; )
        {
            auto ptrs = Load(gocpp::recv(d->headTail));
            auto [head, tail] = unpack(gocpp::recv(d), ptrs);
            if(tail == head)
            {
                return {nullptr, false};
            }
            auto ptrs2 = pack(gocpp::recv(d), head, tail + 1);
            if(CompareAndSwap(gocpp::recv(d->headTail), ptrs, ptrs2))
            {
                slot = & d->vals[tail & uint32_t(len(d->vals) - 1)];
                break;
            }
        }
        auto val = *(*go_any)(Pointer(gocpp::recv(unsafe), slot));
        if(val == dequeueNil(nullptr))
        {
            val = nullptr;
        }
        slot->val = nullptr;
        StorePointer(gocpp::recv(atomic), & slot->typ, nullptr);
        return {val, true};
    }

    
    std::ostream& poolChain::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << head;
        os << " " << tail;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolChain& value)
    {
        return value.PrintTo(os);
    }

    
    std::ostream& poolChainElt::PrintTo(std::ostream& os) const
    {
        os << '{';
        os << "" << next;
        os << " " << prev;
        os << '}';
        return os;
    }

    std::ostream& operator<<(std::ostream& os, const struct poolChainElt& value)
    {
        return value.PrintTo(os);
    }

    void storePoolChainElt(poolChainElt** pp, poolChainElt* v)
    {
        StorePointer(gocpp::recv(atomic), (*unsafe.Pointer)(Pointer(gocpp::recv(unsafe), pp)), Pointer(gocpp::recv(unsafe), v));
    }

    poolChainElt* loadPoolChainElt(poolChainElt** pp)
    {
        return (*poolChainElt)(LoadPointer(gocpp::recv(atomic), (*unsafe.Pointer)(Pointer(gocpp::recv(unsafe), pp))));
    }

    void pushHead(struct poolChain* c, go_any val)
    {
        auto d = c->head;
        if(d == nullptr)
        {
            auto initSize = 8;
            d = go_new(poolChainElt);
            d->vals = gocpp::make(gocpp::Tag<gocpp::slice<eface>>(), initSize);
            c->head = d;
            storePoolChainElt(& c->tail, d);
        }
        if(pushHead(gocpp::recv(d), val))
        {
            return;
        }
        auto newSize = len(d->vals) * 2;
        if(newSize >= dequeueLimit)
        {
            newSize = dequeueLimit;
        }
        auto d2 = gocpp::InitPtr<poolChainElt>([](poolChainElt& x) { x.prev = d; });
        d2->vals = gocpp::make(gocpp::Tag<gocpp::slice<eface>>(), newSize);
        c->head = d2;
        storePoolChainElt(& d->next, d2);
        pushHead(gocpp::recv(d2), val);
    }

    std::tuple<go_any, bool> popHead(struct poolChain* c)
    {
        auto d = c->head;
        for(; d != nullptr; )
        {
            if(auto [val, ok] = popHead(gocpp::recv(d)); ok)
            {
                return {val, ok};
            }
            d = loadPoolChainElt(& d->prev);
        }
        return {nullptr, false};
    }

    std::tuple<go_any, bool> popTail(struct poolChain* c)
    {
        auto d = loadPoolChainElt(& c->tail);
        if(d == nullptr)
        {
            return {nullptr, false};
        }
        for(; ; )
        {
            auto d2 = loadPoolChainElt(& d->next);
            if(auto [val, ok] = popTail(gocpp::recv(d)); ok)
            {
                return {val, ok};
            }
            if(d2 == nullptr)
            {
                return {nullptr, false};
            }
            if(CompareAndSwapPointer(gocpp::recv(atomic), (*unsafe.Pointer)(Pointer(gocpp::recv(unsafe), & c->tail)), Pointer(gocpp::recv(unsafe), d), Pointer(gocpp::recv(unsafe), d2)))
            {
                storePoolChainElt(& d2->prev, nullptr);
            }
            d = d2;
        }
    }

}

