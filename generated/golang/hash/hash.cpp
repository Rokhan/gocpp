// generated by GoCpp from file '$(ImportDir)/hash/hash.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/hash/hash.h"
#include "gocpp/support.h"

#include "golang/io/io.h"

namespace golang::hash
{
    namespace rec
    {
        using namespace mocklib::rec;
        using namespace io::rec;
    }

    
    template<typename T>
    Hash::Hash(T& ref)
    {
        value.reset(new HashImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash::Hash(const T& ref)
    {
        value.reset(new HashImpl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash::Hash(T* ptr)
    {
        value.reset(new HashImpl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Hash::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    gocpp::slice<unsigned char> Hash::HashImpl<T, StoreT>::vSum(gocpp::slice<unsigned char> b)
    {
        return rec::Sum(gocpp::PtrRecv<T, false>(value.get()), b);
    }
    template<typename T, typename StoreT>
    void Hash::HashImpl<T, StoreT>::vReset()
    {
        return rec::Reset(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Hash::HashImpl<T, StoreT>::vSize()
    {
        return rec::Size(gocpp::PtrRecv<T, false>(value.get()));
    }
    template<typename T, typename StoreT>
    int Hash::HashImpl<T, StoreT>::vBlockSize()
    {
        return rec::BlockSize(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        gocpp::slice<unsigned char> Sum(const gocpp::PtrRecv<struct Hash, false>& self, gocpp::slice<unsigned char> b)
        {
            return self.ptr->value->vSum(b);
        }

        gocpp::slice<unsigned char> Sum(const gocpp::ObjRecv<struct Hash>& self, gocpp::slice<unsigned char> b)
        {
            return self.obj.value->vSum(b);
        }

        void Reset(const gocpp::PtrRecv<struct Hash, false>& self)
        {
            return self.ptr->value->vReset();
        }

        void Reset(const gocpp::ObjRecv<struct Hash>& self)
        {
            return self.obj.value->vReset();
        }

        int Size(const gocpp::PtrRecv<struct Hash, false>& self)
        {
            return self.ptr->value->vSize();
        }

        int Size(const gocpp::ObjRecv<struct Hash>& self)
        {
            return self.obj.value->vSize();
        }

        int BlockSize(const gocpp::PtrRecv<struct Hash, false>& self)
        {
            return self.ptr->value->vBlockSize();
        }

        int BlockSize(const gocpp::ObjRecv<struct Hash>& self)
        {
            return self.obj.value->vBlockSize();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Hash& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Hash32::Hash32(T& ref)
    {
        value.reset(new Hash32Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash32::Hash32(const T& ref)
    {
        value.reset(new Hash32Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash32::Hash32(T* ptr)
    {
        value.reset(new Hash32Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Hash32::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint32_t Hash32::Hash32Impl<T, StoreT>::vSum32()
    {
        return rec::Sum32(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        uint32_t Sum32(const gocpp::PtrRecv<struct Hash32, false>& self)
        {
            return self.ptr->value->vSum32();
        }

        uint32_t Sum32(const gocpp::ObjRecv<struct Hash32>& self)
        {
            return self.obj.value->vSum32();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Hash32& value)
    {
        return value.PrintTo(os);
    }

    
    template<typename T>
    Hash64::Hash64(T& ref)
    {
        value.reset(new Hash64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash64::Hash64(const T& ref)
    {
        value.reset(new Hash64Impl<T, std::unique_ptr<T>>(new T(ref)));
    }

    template<typename T>
    Hash64::Hash64(T* ptr)
    {
        value.reset(new Hash64Impl<T, gocpp::ptr<T>>(ptr));
    }

    std::ostream& Hash64::PrintTo(std::ostream& os) const
    {
        return os;
    }

    template<typename T, typename StoreT>
    uint64_t Hash64::Hash64Impl<T, StoreT>::vSum64()
    {
        return rec::Sum64(gocpp::PtrRecv<T, false>(value.get()));
    }

    namespace rec
    {
        uint64_t Sum64(const gocpp::PtrRecv<struct Hash64, false>& self)
        {
            return self.ptr->value->vSum64();
        }

        uint64_t Sum64(const gocpp::ObjRecv<struct Hash64>& self)
        {
            return self.obj.value->vSum64();
        }
    }

    std::ostream& operator<<(std::ostream& os, const struct Hash64& value)
    {
        return value.PrintTo(os);
    }

}

