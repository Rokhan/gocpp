// generated by GoCpp from file '$(ImportDir)/internal/abi/symtab.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/abi/symtab.h"
#include "gocpp/support.h"

namespace golang::abi
{
    namespace rec
    {
        using namespace mocklib::rec;
    }

    // A FuncFlag records bits about a function, passed to the runtime.
    // FuncFlagTopFrame indicates a function that appears at the top of its stack.
    // The traceback routine stop at such a function and consider that a
    // successful, complete traversal of the stack.
    // Examples of TopFrame functions include goexit, which appears
    // at the top of a user goroutine stack, and mstart, which appears
    // at the top of a system goroutine stack.
    // FuncFlagSPWrite indicates a function that writes an arbitrary value to SP
    // (any write other than adding or subtracting a constant amount).
    // The traceback routines cannot encode such changes into the
    // pcsp tables, so the function traceback cannot safely unwind past
    // SPWrite functions. Stopping at an SPWrite function is considered
    // to be an incomplete unwinding of the stack. In certain contexts
    // (in particular garbage collector stack scans) that is a fatal error.
    // FuncFlagAsm indicates that a function was implemented in assembly.
    // A FuncID identifies particular functions that need to be treated
    // specially by the runtime.
    // Note that in some situations involving plugins, there may be multiple
    // copies of a particular special runtime function.
    // ArgsSizeUnknown is set in Func.argsize to mark all functions
    // whose argument size is unknown (C vararg functions, and
    // assembly code without an explicit specification).
    // This value is generated by the compiler, assembler, or linker.
    // IDs for PCDATA and FUNCDATA tables in Go binaries.
    //
    // These must agree with ../../../runtime/funcdata.h.
    // Special values for the PCDATA_UnsafePoint table.
    // UnsafePointRestart1(2) apply on a sequence of instructions, within
    // which if an async preemption happens, we should back off the PC
    // to the start of the sequence when resuming.
    // We need two so we can distinguish the start/end of the sequence
    // in case that two sequences are next to each other.
    // Like UnsafePointRestart1, but back to function entry if async preempted.
}

