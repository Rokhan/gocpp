// generated by GoCpp from file '$(ImportDir)/fmt/print.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/fmt/print.fwd.h"
#include "gocpp/support.h"

#include "golang/fmt/format.h"
#include "golang/internal/abi/type.h"
#include "golang/io/io.h"
// #include "golang/reflect/value.h"  [Ignored, known errors]
// #include "golang/sync/cond.h"  [Ignored, known errors]
#include "golang/sync/pool.h"

namespace golang::fmt
{
    extern std::string commaSpaceString;
    extern std::string nilAngleString;
    extern std::string nilParenString;
    extern std::string nilString;
    extern std::string mapString;
    extern std::string percentBangString;
    extern std::string missingString;
    extern std::string badIndexString;
    extern std::string panicString;
    extern std::string extraString;
    extern std::string badWidthString;
    extern std::string badPrecString;
    extern std::string noVerbString;
    extern std::string invReflectString;
    struct State : gocpp::Interface
    {
        State(){}
        State(State& i) = default;
        State(const State& i) = default;
        State& operator=(State& i) = default;
        State& operator=(const State& i) = default;

        template<typename T>
        State(T& ref);

        template<typename T>
        State(const T& ref);

        template<typename T>
        State(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IState
        {
            virtual std::tuple<int, std::string> vWrite(gocpp::slice<unsigned char> b) = 0;
            virtual std::tuple<int, bool> vWidth() = 0;
            virtual std::tuple<int, bool> vPrecision() = 0;
            virtual bool vFlag(int c) = 0;
        };

        template<typename T, typename StoreT>
        struct StateImpl : IState
        {
            explicit StateImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<int, std::string> vWrite(gocpp::slice<unsigned char> b) override;

            std::tuple<int, bool> vWidth() override;

            std::tuple<int, bool> vPrecision() override;

            bool vFlag(int c) override;

            StoreT value;
        };

        std::shared_ptr<IState> value;
    };

    std::tuple<int, std::string> Write(const gocpp::PtrRecv<State, false>& self, gocpp::slice<unsigned char> b);
    std::tuple<int, std::string> Write(const gocpp::ObjRecv<State>& self, gocpp::slice<unsigned char> b);

    std::tuple<int, bool> Width(const gocpp::PtrRecv<State, false>& self);
    std::tuple<int, bool> Width(const gocpp::ObjRecv<State>& self);

    std::tuple<int, bool> Precision(const gocpp::PtrRecv<State, false>& self);
    std::tuple<int, bool> Precision(const gocpp::ObjRecv<State>& self);

    bool Flag(const gocpp::PtrRecv<State, false>& self, int c);
    bool Flag(const gocpp::ObjRecv<State>& self, int c);

    std::ostream& operator<<(std::ostream& os, const struct State& value);
    struct Formatter : gocpp::Interface
    {
        Formatter(){}
        Formatter(Formatter& i) = default;
        Formatter(const Formatter& i) = default;
        Formatter& operator=(Formatter& i) = default;
        Formatter& operator=(const Formatter& i) = default;

        template<typename T>
        Formatter(T& ref);

        template<typename T>
        Formatter(const T& ref);

        template<typename T>
        Formatter(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IFormatter
        {
            virtual void vFormat(State f, gocpp::rune verb) = 0;
        };

        template<typename T, typename StoreT>
        struct FormatterImpl : IFormatter
        {
            explicit FormatterImpl(T* ptr)
            {
                value.reset(ptr);
            }

            void vFormat(State f, gocpp::rune verb) override;

            StoreT value;
        };

        std::shared_ptr<IFormatter> value;
    };

    void Format(const gocpp::PtrRecv<Formatter, false>& self, State f, gocpp::rune verb);
    void Format(const gocpp::ObjRecv<Formatter>& self, State f, gocpp::rune verb);

    std::ostream& operator<<(std::ostream& os, const struct Formatter& value);
    struct Stringer : gocpp::Interface
    {
        Stringer(){}
        Stringer(Stringer& i) = default;
        Stringer(const Stringer& i) = default;
        Stringer& operator=(Stringer& i) = default;
        Stringer& operator=(const Stringer& i) = default;

        template<typename T>
        Stringer(T& ref);

        template<typename T>
        Stringer(const T& ref);

        template<typename T>
        Stringer(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IStringer
        {
            virtual std::string vString() = 0;
        };

        template<typename T, typename StoreT>
        struct StringerImpl : IStringer
        {
            explicit StringerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vString() override;

            StoreT value;
        };

        std::shared_ptr<IStringer> value;
    };

    std::string String(const gocpp::PtrRecv<Stringer, false>& self);
    std::string String(const gocpp::ObjRecv<Stringer>& self);

    std::ostream& operator<<(std::ostream& os, const struct Stringer& value);
    struct GoStringer : gocpp::Interface
    {
        GoStringer(){}
        GoStringer(GoStringer& i) = default;
        GoStringer(const GoStringer& i) = default;
        GoStringer& operator=(GoStringer& i) = default;
        GoStringer& operator=(const GoStringer& i) = default;

        template<typename T>
        GoStringer(T& ref);

        template<typename T>
        GoStringer(const T& ref);

        template<typename T>
        GoStringer(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IGoStringer
        {
            virtual std::string vGoString() = 0;
        };

        template<typename T, typename StoreT>
        struct GoStringerImpl : IGoStringer
        {
            explicit GoStringerImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::string vGoString() override;

            StoreT value;
        };

        std::shared_ptr<IGoStringer> value;
    };

    std::string GoString(const gocpp::PtrRecv<GoStringer, false>& self);
    std::string GoString(const gocpp::ObjRecv<GoStringer>& self);

    std::ostream& operator<<(std::ostream& os, const struct GoStringer& value);
    std::string FormatString(State state, gocpp::rune verb);
    void write(buffer* b, gocpp::slice<unsigned char> p);
    void writeString(buffer* b, std::string s);
    void writeByte(buffer* b, unsigned char c);
    void writeRune(buffer* b, gocpp::rune r);
    struct pp
    {
        buffer buf;
        go_any arg;
        reflect::Value value;
        fmt fmt;
        bool reordered;
        bool goodArgNum;
        bool panicking;
        bool erroring;
        bool wrapErrs;
        gocpp::slice<int> wrappedErrs;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pp& value);
    extern sync::Pool ppFree;
    pp* newPrinter();
    void free(struct pp* p);
    std::tuple<int, bool> Width(struct pp* p);
    std::tuple<int, bool> Precision(struct pp* p);
    bool Flag(struct pp* p, int b);
    std::tuple<int, std::string> Write(struct pp* p, gocpp::slice<unsigned char> b);
    std::tuple<int, std::string> WriteString(struct pp* p, std::string s);
    std::tuple<int, std::string> Fprintf(io::Writer w, std::string format, gocpp::slice<go_any> a);

    template<typename... Args>
    std::tuple<int, std::string> Fprintf(io::Writer w, std::string format, Args... a)
    {
        return Fprintf(w, format, gocpp::ToSlice<go_any>(a...));
    }

    std::tuple<int, std::string> Printf(std::string format, gocpp::slice<go_any> a);

    template<typename... Args>
    std::tuple<int, std::string> Printf(std::string format, Args... a)
    {
        return Printf(format, gocpp::ToSlice<go_any>(a...));
    }

    std::string Sprintf(std::string format, gocpp::slice<go_any> a);

    template<typename... Args>
    std::string Sprintf(std::string format, Args... a)
    {
        return Sprintf(format, gocpp::ToSlice<go_any>(a...));
    }

    gocpp::slice<unsigned char> Appendf(gocpp::slice<unsigned char> b, std::string format, gocpp::slice<go_any> a);

    template<typename... Args>
    gocpp::slice<unsigned char> Appendf(gocpp::slice<unsigned char> b, std::string format, Args... a)
    {
        return Appendf(b, format, gocpp::ToSlice<go_any>(a...));
    }

    std::tuple<int, std::string> Fprint(io::Writer w, gocpp::slice<go_any> a);

    template<typename... Args>
    std::tuple<int, std::string> Fprint(io::Writer w, Args... a)
    {
        return Fprint(w, gocpp::ToSlice<go_any>(a...));
    }

    std::tuple<int, std::string> Print(gocpp::slice<go_any> a);

    template<typename... Args>
    std::tuple<int, std::string> Print(Args... a)
    {
        return Print(gocpp::ToSlice<go_any>(a...));
    }

    std::string Sprint(gocpp::slice<go_any> a);

    template<typename... Args>
    std::string Sprint(Args... a)
    {
        return Sprint(gocpp::ToSlice<go_any>(a...));
    }

    gocpp::slice<unsigned char> Append(gocpp::slice<unsigned char> b, gocpp::slice<go_any> a);

    template<typename... Args>
    gocpp::slice<unsigned char> Append(gocpp::slice<unsigned char> b, Args... a)
    {
        return Append(b, gocpp::ToSlice<go_any>(a...));
    }

    std::tuple<int, std::string> Fprintln(io::Writer w, gocpp::slice<go_any> a);

    template<typename... Args>
    std::tuple<int, std::string> Fprintln(io::Writer w, Args... a)
    {
        return Fprintln(w, gocpp::ToSlice<go_any>(a...));
    }

    std::tuple<int, std::string> Println(gocpp::slice<go_any> a);

    template<typename... Args>
    std::tuple<int, std::string> Println(Args... a)
    {
        return Println(gocpp::ToSlice<go_any>(a...));
    }

    std::string Sprintln(gocpp::slice<go_any> a);

    template<typename... Args>
    std::string Sprintln(Args... a)
    {
        return Sprintln(gocpp::ToSlice<go_any>(a...));
    }

    gocpp::slice<unsigned char> Appendln(gocpp::slice<unsigned char> b, gocpp::slice<go_any> a);

    template<typename... Args>
    gocpp::slice<unsigned char> Appendln(gocpp::slice<unsigned char> b, Args... a)
    {
        return Appendln(b, gocpp::ToSlice<go_any>(a...));
    }

    reflect::Value getField(reflect::Value v, int i);
    bool tooLarge(int x);
    std::tuple<int, bool, int> parsenum(std::string s, int start, int end);
    void unknownType(struct pp* p, reflect::Value v);
    void badVerb(struct pp* p, gocpp::rune verb);
    void fmtBool(struct pp* p, bool v, gocpp::rune verb);
    void fmt0x64(struct pp* p, uint64_t v, bool leading0x);
    void fmtInteger(struct pp* p, uint64_t v, bool isSigned, gocpp::rune verb);
    void fmtFloat(struct pp* p, double v, int size, gocpp::rune verb);
    void fmtComplex(struct pp* p, gocpp::complex128 v, int size, gocpp::rune verb);
    void fmtString(struct pp* p, std::string v, gocpp::rune verb);
    void fmtBytes(struct pp* p, gocpp::slice<unsigned char> v, gocpp::rune verb, std::string typeString);
    void fmtPointer(struct pp* p, reflect::Value value, gocpp::rune verb);
    void catchPanic(struct pp* p, go_any arg, gocpp::rune verb, std::string method);
    bool handleMethods(struct pp* p, gocpp::rune verb);
    void printArg(struct pp* p, go_any arg, gocpp::rune verb);
    void printValue(struct pp* p, reflect::Value value, gocpp::rune verb, int depth);
    std::tuple<int, bool, int> intFromArg(gocpp::slice<go_any> a, int argNum);
    std::tuple<int, int, bool> parseArgNumber(std::string format);
    std::tuple<int, int, bool> argNumber(struct pp* p, int argNum, std::string format, int i, int numArgs);
    void badArgNum(struct pp* p, gocpp::rune verb);
    void missingArg(struct pp* p, gocpp::rune verb);
    void doPrintf(struct pp* p, std::string format, gocpp::slice<go_any> a);
    void doPrint(struct pp* p, gocpp::slice<go_any> a);
    void doPrintln(struct pp* p, gocpp::slice<go_any> a);
}

