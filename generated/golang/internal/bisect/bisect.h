// generated by GoCpp from file '$(ImportDir)/internal/bisect/bisect.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/internal/bisect/bisect.fwd.h"
#include "gocpp/support.h"

#include "golang/sync/mutex.h"

namespace golang::bisect
{
    std::tuple<struct Matcher*, struct gocpp::error> New(std::string pattern);
    struct Matcher
    {
        bool verbose;
        bool quiet;
        bool enable;
        gocpp::slice<cond> list;
        /* atomicPointerDedup dedup; [Known incomplete type] */

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct Matcher& value);
    struct atomicPointerDedup
    {
        unsafe::Pointer p;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct atomicPointerDedup& value);
    struct cond
    {
        uint64_t mask;
        uint64_t bits;
        bool result;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct cond& value);
    struct gocpp::error printFileLine(struct Writer w, uint64_t h, std::string file, int line);
    gocpp::slice<unsigned char> appendFileLine(gocpp::slice<unsigned char> dst, std::string file, int line);
    struct Writer : gocpp::Interface
    {
        Writer(){}
        Writer(Writer& i) = default;
        Writer(const Writer& i) = default;
        Writer& operator=(Writer& i) = default;
        Writer& operator=(const Writer& i) = default;

        template<typename T>
        Writer(T& ref);

        template<typename T>
        Writer(const T& ref);

        template<typename T>
        Writer(T* ptr);

        using isGoInterface = void;

        std::ostream& PrintTo(std::ostream& os) const;

        struct IWriter
        {
            virtual std::tuple<int, struct gocpp::error> vWrite(gocpp::slice<unsigned char>) = 0;
        };

        template<typename T, typename StoreT>
        struct WriterImpl : IWriter
        {
            explicit WriterImpl(T* ptr)
            {
                value.reset(ptr);
            }

            std::tuple<int, struct gocpp::error> vWrite(gocpp::slice<unsigned char>) override;

            StoreT value;
        };

        std::shared_ptr<IWriter> value;
    };

    namespace rec
    {
        std::tuple<int, struct gocpp::error> Write(const gocpp::PtrRecv<Writer, false>& self, gocpp::slice<unsigned char>);
        std::tuple<int, struct gocpp::error> Write(const gocpp::ObjRecv<Writer>& self, gocpp::slice<unsigned char>);
    }

    std::ostream& operator<<(std::ostream& os, const struct Writer& value);
    struct gocpp::error PrintMarker(struct Writer w, uint64_t h);
    struct gocpp::error printStack(struct Writer w, uint64_t h, gocpp::slice<uintptr_t> stk);
    std::string Marker(uint64_t id);
    gocpp::slice<unsigned char> AppendMarker(gocpp::slice<unsigned char> dst, uint64_t id);
    std::tuple<std::string, uint64_t, bool> CutMarker(std::string line);
    uint64_t Hash(gocpp::slice<go_any> data);
    
    template<typename... Args>
    uint64_t Hash(Args... data)
    {
        return Hash(gocpp::ToSlice<go_any>(data...));
    }
    
    template<typename... Args>
    uint64_t Hash(go_any value, Args... data)
    {
        return Hash(gocpp::ToSlice<go_any>(value, data...));
    }
    struct parseError
    {
        std::string text;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct parseError& value);
    uint64_t fnv(uint64_t h, unsigned char x);
    uint64_t fnvString(uint64_t h, std::string x);
    uint64_t fnvUint64(uint64_t h, uint64_t x);
    uint64_t fnvUint32(uint64_t h, uint32_t x);
    struct dedup
    {
        gocpp::array<gocpp::array<uint64_t, 4>, 128> recent;
        mocklib::Mutex mu;
        gocpp::map<uint64_t, bool> m;

        using isGoStruct = void;

        template<typename T> requires gocpp::GoStruct<T>
        operator T();

        template<typename T> requires gocpp::GoStruct<T>
        bool operator==(const T& ref) const;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct dedup& value);

    namespace rec
    {
        struct dedup* Load(struct atomicPointerDedup* p);
        bool CompareAndSwap(struct atomicPointerDedup* p, struct dedup* old, struct dedup* go_new);
        bool MarkerOnly(struct Matcher* m);
        bool ShouldEnable(struct Matcher* m, uint64_t id);
        bool ShouldPrint(struct Matcher* m, uint64_t id);
        bool matchResult(struct Matcher* m, uint64_t id);
        bool FileLine(struct Matcher* m, struct Writer w, std::string file, int line);
        bool fileLine(struct Matcher* m, struct Writer w, std::string file, int line);
        bool Stack(struct Matcher* m, struct Writer w);
        bool stack(struct Matcher* m, struct Writer w);
        std::string Error(struct parseError* e);
        bool seen(struct dedup* d, uint64_t h);
        bool seenLossy(struct dedup* d, uint64_t h);
    }
}

