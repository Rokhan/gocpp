// generated by GoCpp from file '$(ImportDir)/runtime/print.go'
#include <complex>
#include <functional>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/print.h"
#include "gocpp/support.h"

#include "golang/internal/abi/symtab.h"
#include "golang/internal/abi/type.h"
#include "golang/internal/chacha8rand/chacha8.h"
#include "golang/internal/goarch/goarch.h"
#include "golang/runtime/cgocall.h"
#include "golang/runtime/chan.h"
#include "golang/runtime/coro.h"
#include "golang/runtime/debuglog_off.h"
#include "golang/runtime/internal/atomic/types.h"
#include "golang/runtime/internal/sys/nih.h"
#include "golang/runtime/lock_sema.h"
#include "golang/runtime/lockrank.h"
#include "golang/runtime/lockrank_off.h"
#include "golang/runtime/mprof.h"
#include "golang/runtime/os_windows.h"
#include "golang/runtime/panic.h"
#include "golang/runtime/plugin.h"
#include "golang/runtime/proc.h"
#include "golang/runtime/runtime2.h"
#include "golang/runtime/signal_windows.h"
#include "golang/runtime/slice.h"
#include "golang/runtime/stack.h"
#include "golang/runtime/string.h"
#include "golang/runtime/stubs.h"
#include "golang/runtime/symtab.h"
#include "golang/runtime/time.h"
#include "golang/runtime/trace2buf.h"
#include "golang/runtime/trace2runtime.h"
#include "golang/runtime/trace2status.h"
#include "golang/runtime/trace2time.h"
#include "golang/runtime/write_err.h"
#include "golang/unsafe/unsafe.h"

namespace golang::runtime
{
    namespace rec
    {
        using namespace mocklib::rec;
        using atomic::rec::Load;
    }

    // The compiler knows that a print of a value of this type
    // should use printhex instead of printuint (decimal).
    gocpp::slice<unsigned char> bytes(gocpp::string s)
    {
        gocpp::slice<unsigned char> ret;
        auto rp = (slice*)(unsafe::Pointer(& ret));
        auto sp = stringStructOf(& s);
        rp->array = sp->str;
        rp->len = sp->len;
        rp->cap = sp->len;
        return ret;
    }

    // printBacklog is a circular buffer of messages written with the builtin
    // print* functions, for use in postmortem analysis of core dumps.
    gocpp::array<unsigned char, 512> printBacklog;
    int printBacklogIndex;
    // recordForPanic maintains a circular buffer of messages written by the
    // runtime leading up to a process crash, allowing the messages to be
    // extracted from a core dump.
    //
    // The text written during a process crash (following "panic" or "fatal
    // error") is not saved, since the goroutine stacks will generally be readable
    // from the runtime data structures in the core file.
    void recordForPanic(gocpp::slice<unsigned char> b)
    {
        printlock();
        if(rec::Load(gocpp::recv(panicking)) == 0)
        {
            for(auto i = 0; i < len(b); )
            {
                auto n = copy(printBacklog.make_slice(printBacklogIndex), b.make_slice(i));
                i += n;
                printBacklogIndex += n;
                printBacklogIndex %= len(printBacklog);
            }
        }
        printunlock();
    }

    mutex debuglock;
    void printlock()
    {
        auto mp = getg()->m;
        mp->locks++;
        mp->printlock++;
        if(mp->printlock == 1)
        {
            lock(& debuglock);
        }
        mp->locks--;
    }

    void printunlock()
    {
        auto mp = getg()->m;
        mp->printlock--;
        if(mp->printlock == 0)
        {
            unlock(& debuglock);
        }
    }

    // write to goroutine-local buffer if diverting output,
    // or else standard error.
    void gwrite(gocpp::slice<unsigned char> b)
    {
        if(len(b) == 0)
        {
            return;
        }
        recordForPanic(b);
        auto gp = getg();
        if(gp == nullptr || gp->writebuf == nullptr || gp->m->dying > 0)
        {
            writeErr(b);
            return;
        }
        auto n = copy(gp->writebuf.make_slice(len(gp->writebuf), cap(gp->writebuf)), b);
        gp->writebuf = gp->writebuf.make_slice(0, len(gp->writebuf) + n);
    }

    void printsp()
    {
        printstring(" "_s);
    }

    void printnl()
    {
        printstring("\n"_s);
    }

    void printbool(bool v)
    {
        if(v)
        {
            printstring("true"_s);
        }
        else
        {
            printstring("false"_s);
        }
    }

    void printfloat(double v)
    {
        //Go switch emulation
        {
            int conditionId = -1;
            if(v != v) { conditionId = 0; }
            else if(v + v == v && v > 0) { conditionId = 1; }
            else if(v + v == v && v < 0) { conditionId = 2; }
            switch(conditionId)
            {
                case 0:
                    printstring("NaN"_s);
                    return;
                    break;
                case 1:
                    printstring("+Inf"_s);
                    return;
                    break;
                case 2:
                    printstring("-Inf"_s);
                    return;
                    break;
            }
        }
        auto n = 7;
        gocpp::array<unsigned char, n + 7> buf = {};
        buf[0] = '+';
        auto e = 0;
        if(v == 0)
        {
            if(1 / v < 0)
            {
                buf[0] = '-';
            }
        }
        else
        {
            if(v < 0)
            {
                v = - v;
                buf[0] = '-';
            }
            for(; v >= 10; )
            {
                e++;
                v /= 10;
            }
            for(; v < 1; )
            {
                e--;
                v *= 10;
            }
            auto h = 5.0;
            for(auto i = 0; i < n; i++)
            {
                h /= 10;
            }
            v += h;
            if(v >= 10)
            {
                e++;
                v /= 10;
            }
        }
        for(auto i = 0; i < n; i++)
        {
            auto s = int(v);
            buf[i + 2] = (unsigned char)(s + '0');
            v -= double(s);
            v *= 10;
        }
        buf[1] = buf[2];
        buf[2] = '.';
        buf[n + 2] = 'e';
        buf[n + 3] = '+';
        if(e < 0)
        {
            e = - e;
            buf[n + 3] = '-';
        }
        buf[n + 4] = (unsigned char)(e / 100) + '0';
        buf[n + 5] = (unsigned char)(e / 10) % 10 + '0';
        buf[n + 6] = (unsigned char)(e % 10) + '0';
        gwrite(buf.make_slice(0));
    }

    void printcomplex(struct gocpp::complex128 c)
    {
        print("("_s, real(c), imag(c), "i)"_s);
    }

    void printuint(uint64_t v)
    {
        gocpp::array<unsigned char, 100> buf = {};
        auto i = len(buf);
        for(i--; i > 0; i--)
        {
            buf[i] = (unsigned char)(v % 10 + '0');
            if(v < 10)
            {
                break;
            }
            v /= 10;
        }
        gwrite(buf.make_slice(i));
    }

    void printint(int64_t v)
    {
        if(v < 0)
        {
            printstring("-"_s);
            v = - v;
        }
        printuint(uint64_t(v));
    }

    long minhexdigits = 0;
    void printhex(uint64_t v)
    {
        auto dig = "0123456789abcdef"_s;
        gocpp::array<unsigned char, 100> buf = {};
        auto i = len(buf);
        for(i--; i > 0; i--)
        {
            buf[i] = dig[v % 16];
            if(v < 16 && len(buf) - i >= minhexdigits)
            {
                break;
            }
            v /= 16;
        }
        i--;
        buf[i] = 'x';
        i--;
        buf[i] = '0';
        gwrite(buf.make_slice(i));
    }

    void printpointer(unsafe::Pointer p)
    {
        printhex(uint64_t(uintptr_t(p)));
    }

    void printuintptr(uintptr_t p)
    {
        printhex(uint64_t(p));
    }

    void printstring(gocpp::string s)
    {
        gwrite(bytes(s));
    }

    void printslice(gocpp::slice<unsigned char> s)
    {
        auto sp = (slice*)(unsafe::Pointer(& s));
        print("["_s, len(s), "/"_s, cap(s), "]"_s);
        printpointer(sp->array);
    }

    void printeface(struct eface e)
    {
        print("("_s, e._type, ","_s, e.data, ")"_s);
    }

    void printiface(struct iface i)
    {
        print("("_s, i.tab, ","_s, i.data, ")"_s);
    }

    // hexdumpWords prints a word-oriented hex dump of [p, end).
    //
    // If mark != nil, it will be called with each printed word's address
    // and should return a character mark to appear just before that
    // word's value. It can return 0 to indicate no mark.
    void hexdumpWords(uintptr_t p, uintptr_t end, std::function<unsigned char (uintptr_t _1)> mark)
    {
        printlock();
        gocpp::array<unsigned char, 1> markbuf = {};
        markbuf[0] = ' ';
        minhexdigits = int(gocpp::Sizeof<uintptr_t>() * 2);
        for(auto i = uintptr_t(0); p + i < end; i += goarch::PtrSize)
        {
            if(i % 16 == 0)
            {
                if(i != 0)
                {
                    println();
                }
                print(hex(p + i), ": "_s);
            }
            if(mark != nullptr)
            {
                markbuf[0] = mark(p + i);
                if(markbuf[0] == 0)
                {
                    markbuf[0] = ' ';
                }
            }
            gwrite(markbuf.make_slice(0));
            auto val = *(uintptr_t*)(unsafe::Pointer(p + i));
            print(hex(val));
            print(" "_s);
            auto fn = findfunc(val);
            if(rec::valid(gocpp::recv(fn)))
            {
                print("<"_s, funcname(fn), "+"_s, hex(val - rec::entry(gocpp::recv(fn))), "> "_s);
            }
        }
        minhexdigits = 0;
        println();
        printunlock();
    }

}

