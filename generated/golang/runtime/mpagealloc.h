// generated by GoCpp from file '$(ImportDir)/runtime/mpagealloc.go'
#pragma once

#include <functional>
#include <string>
#include <tuple>
#include <vector>

#include "golang/runtime/mpagealloc.fwd.h"
#include "gocpp/support.h"

#include "golang/runtime/internal/atomic/types.h"
// #include "golang/runtime/lockrank_off.h"  [Ignored, known errors]
// #include "golang/runtime/mgcscavenge.h"  [Ignored, known errors]
#include "golang/runtime/mpallocbits.h"
#include "golang/runtime/mranges.h"
#include "golang/runtime/mstats.h"
#include "golang/runtime/runtime2.h"

namespace golang::runtime
{
    offAddr maxSearchAddr();
    chunkIdx chunkIndex(uintptr_t p);
    uintptr_t chunkBase(chunkIdx ci);
    unsigned int chunkPageIndex(uintptr_t p);
    unsigned int l1(chunkIdx i);
    unsigned int l2(chunkIdx i);
    int offAddrToLevelIndex(int level, offAddr addr);
    offAddr levelIndexToOffAddr(int level, int idx);
    std::tuple<int, int> addrsToSummaryRange(int level, uintptr_t base, uintptr_t limit);
    std::tuple<int, int> blockAlignSummaryRange(int level, int lo, int hi);
    struct pageAlloc
    {
        gocpp::array<gocpp::slice<pallocSum>, summaryLevels> summary;
        gocpp::array<gocpp::array<pallocData, 1 << pallocChunksL2Bits>*, 1 << pallocChunksL1Bits> chunks;
        offAddr searchAddr;
        chunkIdx start;
        chunkIdx end;
        addrRanges inUse;
        /* gocpp_id_0 scav; [Known incomplete type] */
        mutex* mheapLock;
        sysMemStat* sysStat;
        uintptr_t summaryMappedReady;
        bool chunkHugePages;
        bool test;

        using isGoStruct = void;

        std::ostream& PrintTo(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream& os, const struct pageAlloc& value);
    void init(struct pageAlloc* p, mutex* mheapLock, sysMemStat* sysStat, bool test);
    pallocData* tryChunkOf(struct pageAlloc* p, chunkIdx ci);
    pallocData* chunkOf(struct pageAlloc* p, chunkIdx ci);
    void grow(struct pageAlloc* p, uintptr_t base, uintptr_t size);
    void enableChunkHugePages(struct pageAlloc* p);
    void update(struct pageAlloc* p, uintptr_t base, uintptr_t npages, bool contig, bool alloc);
    uintptr_t allocRange(struct pageAlloc* p, uintptr_t base, uintptr_t npages);
    offAddr findMappedAddr(struct pageAlloc* p, offAddr addr);
    std::tuple<uintptr_t, offAddr> find(struct pageAlloc* p, uintptr_t npages);
    std::tuple<uintptr_t, uintptr_t> alloc(struct pageAlloc* p, uintptr_t npages);
    void free(struct pageAlloc* p, uintptr_t base, uintptr_t npages);
    pallocSum packPallocSum(unsigned int start, unsigned int max, unsigned int end);
    unsigned int start(pallocSum p);
    unsigned int max(pallocSum p);
    unsigned int end(pallocSum p);
    std::tuple<unsigned int, unsigned int, unsigned int> unpack(pallocSum p);
    pallocSum mergeSummaries(gocpp::slice<pallocSum> sums, unsigned int logMaxPagesPerSum);
}

